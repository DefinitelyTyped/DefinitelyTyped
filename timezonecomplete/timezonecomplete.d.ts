// Type definitions for timezonecomplete 1.6.0
// Project: https://github.com/SpiritIT/timezonecomplete
// Definitions by: Rogier Schouten <https://github.com/rogierschouten>
// Definitions: https://github.com/borisyankov/DefinitelyTyped
// Generated by dts-bundle v0.2.0

declare module 'timezonecomplete' {
    import basics = require("__timezonecomplete/basics");
    export import TimeUnit = basics.TimeUnit;
    export import WeekDay = basics.WeekDay;
    export import isLeapYear = basics.isLeapYear;
    export import daysInMonth = basics.daysInMonth;
    export import daysInYear = basics.daysInYear;
    export import firstWeekDayOfMonth = basics.firstWeekDayOfMonth;
    export import lastWeekDayOfMonth = basics.lastWeekDayOfMonth;
    export import weekDayOnOrAfter = basics.weekDayOnOrAfter;
    export import weekDayOnOrBefore = basics.weekDayOnOrBefore;
    export import weekNumber = basics.weekNumber;
    export import weekOfMonth = basics.weekOfMonth;
    export import dayOfYear = basics.dayOfYear;
    export import secondOfDay = basics.secondOfDay;
    import datetime = require("__timezonecomplete/datetime");
    export import DateTime = datetime.DateTime;
    import duration = require("__timezonecomplete/duration");
    export import Duration = duration.Duration;
    import javascript = require("__timezonecomplete/javascript");
    export import DateFunctions = javascript.DateFunctions;
    import period = require("__timezonecomplete/period");
    export import Period = period.Period;
    export import PeriodDst = period.PeriodDst;
    export import periodDstToString = period.periodDstToString;
    import timesource = require("__timezonecomplete/timesource");
    export import TimeSource = timesource.TimeSource;
    export import RealTimeSource = timesource.RealTimeSource;
    import timezone = require("__timezonecomplete/timezone");
    export import NormalizeOption = timezone.NormalizeOption;
    export import TimeZoneKind = timezone.TimeZoneKind;
    export import TimeZone = timezone.TimeZone;
}

declare module '__timezonecomplete/basics' {
    import javascript = require("__timezonecomplete/javascript");
    /**
     * Day-of-week. Note the enum values correspond to JavaScript day-of-week:
     * Sunday = 0, Monday = 1 etc
     */
    export enum WeekDay {
        Sunday = 0,
        Monday = 1,
        Tuesday = 2,
        Wednesday = 3,
        Thursday = 4,
        Friday = 5,
        Saturday = 6,
    }
    /**
     * Time units
     */
    export enum TimeUnit {
        Second = 0,
        Minute = 1,
        Hour = 2,
        Day = 3,
        Week = 4,
        Month = 5,
        Year = 6,
    }
    /**
     * @return True iff the given year is a leap year.
     */
    export function isLeapYear(year: number): boolean;
    /**
     * The days in a given year
     */
    export function daysInYear(year: number): number;
    /**
     * @param year	The full year
     * @param month	The month 1-12
     * @return The number of days in the given month
     */
    export function daysInMonth(year: number, month: number): number;
    /**
     * Returns the day of the year of the given date [0..365]. January first is 0.
     *
     * @param year	The year e.g. 1986
     * @param month Month 1-12
     * @param day Day of month 1-31
     */
    export function dayOfYear(year: number, month: number, day: number): number;
    /**
     * Returns the last instance of the given weekday in the given month
     *
     * @param year	The year
     * @param month	the month 1-12
     * @param weekDay	the desired week day
     *
     * @return the last occurrence of the week day in the month
     */
    export function lastWeekDayOfMonth(year: number, month: number, weekDay: WeekDay): number;
    /**
     * Returns the first instance of the given weekday in the given month
     *
     * @param year	The year
     * @param month	the month 1-12
     * @param weekDay	the desired week day
     *
     * @return the first occurrence of the week day in the month
     */
    export function firstWeekDayOfMonth(year: number, month: number, weekDay: WeekDay): number;
    /**
     * Returns the day-of-month that is on the given weekday and which is >= the given day.
     * Throws if the month has no such day.
     */
    export function weekDayOnOrAfter(year: number, month: number, day: number, weekDay: WeekDay): number;
    /**
     * Returns the day-of-month that is on the given weekday and which is <= the given day.
     * Throws if the month has no such day.
     */
    export function weekDayOnOrBefore(year: number, month: number, day: number, weekDay: WeekDay): number;
    export function weekOfMonth(year: number, month: number, day: number): number;
    /**
     * The ISO 8601 week number for the given date. Week 1 is the week
     * that has January 4th in it, and it starts on Monday.
     * See https://en.wikipedia.org/wiki/ISO_week_date
     *
     * @param year	Year e.g. 1988
     * @param month	Month 1-12
     * @param day	Day of month 1-31
     *
     * @return Week number 1-53
     */
    export function weekNumber(year: number, month: number, day: number): number;
    /**
     * Convert a unix milli timestamp into a TimeT structure.
     * This does NOT take leap seconds into account.
     */
    export function unixToTimeNoLeapSecs(unixMillis: number): TimeStruct;
    /**
     * Convert a year, month, day etc into a unix milli timestamp.
     * This does NOT take leap seconds into account.
     *
     * @param year	Year e.g. 1970
     * @param month	Month 1-12
     * @param day	Day 1-31
     * @param hour	Hour 0-23
     * @param minute	Minute 0-59
     * @param second	Second 0-59 (no leap seconds)
     * @param milli	Millisecond 0-999
     */
    export function timeToUnixNoLeapSecs(year?: number, month?: number, day?: number, hour?: number, minute?: number, second?: number, milli?: number): number;
    /**
     * Convert a TimeT structure into a unix milli timestamp.
     * This does NOT take leap seconds into account.
     */
    export function timeToUnixNoLeapSecs(tm: TimeStruct): number;
    /**
     * Return the day-of-week.
     * This does NOT take leap seconds into account.
     */
    export function weekDayNoLeapSecs(unixMillis: number): WeekDay;
    /**
     * N-th second in the day, counting from 0
     */
    export function secondOfDay(hour: number, minute: number, second: number): number;
    /**
     * Basic representation of a date and time
     */
    export class TimeStruct {
        /**
         * Year, 1970-...
         */
        year: number;
        /**
         * Month 1-12
         */
        month: number;
        /**
         * Day of month, 1-31
         */
        day: number;
        /**
         * Hour 0-23
         */
        hour: number;
        /**
         * Minute 0-59
         */
        minute: number;
        /**
         * Seconds, 0-59
         */
        second: number;
        /**
         * Milliseconds 0-999
         */
        milli: number;
        /**
         * Create a TimeStruct from a number of unix milliseconds
         */
        static fromUnix(unixMillis: number): TimeStruct;
        /**
         * Create a TimeStruct from a JavaScript date
         *
         * @param d	The date
         * @param df	Which functions to take (getX() or getUTCX())
         */
        static fromDate(d: Date, df: javascript.DateFunctions): TimeStruct;
        /**
         * Returns a TimeStruct from an ISO 8601 string WITHOUT time zone
         */
        static fromString(s: string): TimeStruct;
        /**
         * Constructor
         *
         * @param year	Year e.g. 1970
         * @param month	Month 1-12
         * @param day	Day 1-31
         * @param hour	Hour 0-23
         * @param minute	Minute 0-59
         * @param second	Second 0-59 (no leap seconds)
         * @param milli	Millisecond 0-999
         */
        constructor(/**
            * Year, 1970-...
            */
            year?: number, /**
            * Month 1-12
            */
            month?: number, /**
            * Day of month, 1-31
            */
            day?: number, /**
            * Hour 0-23
            */
            hour?: number, /**
            * Minute 0-59
            */
            minute?: number, /**
            * Seconds, 0-59
            */
            second?: number, /**
            * Milliseconds 0-999
            */
            milli?: number);
        /**
         * Validate a TimeStruct, returns false if invalid.
         */
        validate(): boolean;
        /**
         * The day-of-year 0-365
         */
        yearDay(): number;
        /**
         * Returns this time as a unix millisecond timestamp
         * Does NOT take leap seconds into account.
         */
        toUnixNoLeapSecs(): number;
        /**
         * Deep equals
         */
        equals(other: TimeStruct): boolean;
        /**
         * < operator
         */
        lessThan(other: TimeStruct): boolean;
        clone(): TimeStruct;
        valueOf(): number;
        /**
         * ISO 8601 string YYYY-MM-DDThh:mm:ss.nnn
         */
        toString(): string;
        inspect(): string;
    }
}

declare module '__timezonecomplete/datetime' {
    import basics = require("__timezonecomplete/basics");
    import duration = require("__timezonecomplete/duration");
    import javascript = require("__timezonecomplete/javascript");
    import timesource = require("__timezonecomplete/timesource");
    import timezone = require("__timezonecomplete/timezone");
    /**
     * DateTime class which is time zone-aware
     * and which can be mocked for testing purposes.
     */
    export class DateTime {
        /**
         * Actual time source in use. Setting this property allows to
         * fake time in tests. DateTime.nowLocal() and DateTime.nowUtc()
         * use this property for obtaining the current time.
         */
        static timeSource: timesource.TimeSource;
        /**
         * Current date+time in local time (derived from DateTime.timeSource.now()).
         */
        static nowLocal(): DateTime;
        /**
         * Current date+time in UTC time (derived from DateTime.timeSource.now()).
         */
        static nowUtc(): DateTime;
        /**
         * Current date+time in the given time zone (derived from DateTime.timeSource.now()).
         * @param timeZone	The desired time zone.
         */
        static now(timeZone: timezone.TimeZone): DateTime;
        /**
         * Constructor. Creates current time in local timezone.
         */
        constructor();
        /**
         * Constructor
         * Non-existing local times are normalized by rounding up to the next DST offset.
         *
         * @param isoString	String in ISO 8601 format. Instead of ISO time zone,
         *		 it may include a space and then and IANA time zone.
         * e.g. "2007-04-05T12:30:40.500"					(no time zone, naive date)
         * e.g. "2007-04-05T12:30:40.500+01:00"				(UTC offset without daylight saving time)
         * or   "2007-04-05T12:30:40.500Z"					(UTC)
         * or   "2007-04-05T12:30:40.500 Europe/Amsterdam"	(IANA time zone, with daylight saving time if applicable)
         * @param timeZone	if given, the date in the string is assumed to be in this time zone.
         *					Note that it is NOT CONVERTED to the time zone. Useful
         *					for strings without a time zone
         */
        constructor(isoString: string, timeZone?: timezone.TimeZone);
        /**
         * Constructor. You provide a date, then you say whether to take the
         * date.getYear()/getXxx methods or the date.getUTCYear()/date.getUTCXxx methods,
         * and then you state which time zone that date is in.
         * Non-existing local times are normalized by rounding up to the next DST offset.
         * Note that the Date class has bugs and inconsistencies when constructing them with times around
         * DST changes.
         *
         * @param date	A date object.
         * @param getters	Specifies which set of Date getters contains the date in the given time zone: the
         *					Date.getXxx() methods or the Date.getUTCXxx() methods.
         * @param timeZone	The time zone that the given date is assumed to be in (may be null for unaware dates)
         */
        constructor(date: Date, getFuncs: javascript.DateFunctions, timeZone?: timezone.TimeZone);
        /**
         * Constructor. Note that unlike JavaScript dates we require fields to be in normal ranges.
         * Use the add(duration) or sub(duration) for arithmetic.
         * @param year	The full year (e.g. 2014)
         * @param month	The month [1-12] (note this deviates from JavaScript Date)
         * @param day	The day of the month [1-31]
         * @param hour	The hour of the day [0-24)
         * @param minute	The minute of the hour [0-59]
         * @param second	The second of the minute [0-59]
         * @param millisecond	The millisecond of the second [0-999]
         * @param timeZone	The time zone, or null (for unaware dates)
         */
        constructor(year: number, month: number, day: number, hour?: number, minute?: number, second?: number, millisecond?: number, timeZone?: timezone.TimeZone);
        /**
         * Constructor
         * @param unixTimestamp	milliseconds since 1970-01-01T00:00:00.000
         * @param timeZone	the time zone that the timestamp is assumed to be in (usually UTC).
         */
        constructor(unixTimestamp: number, timeZone?: timezone.TimeZone);
        /**
         * @return a copy of this object
         */
        clone(): DateTime;
        /**
         * @return The time zone that the date is in. May be null for unaware dates.
         */
        zone(): timezone.TimeZone;
        /**
         * Zone name abbreviation at this time
         * @param dstDependent (default true) set to false for a DST-agnostic abbreviation
         * @return The abbreviation
         */
        zoneAbbreviation(dstDependent?: boolean): string;
        /**
         * @return the offset w.r.t. UTC in minutes. Returns 0 for unaware dates and for UTC dates.
         */
        offset(): number;
        /**
         * @return The full year e.g. 2014
         */
        year(): number;
        /**
         * @return The month 1-12 (note this deviates from JavaScript Date)
         */
        month(): number;
        /**
         * @return The day of the month 1-31
         */
        day(): number;
        /**
         * @return The hour 0-23
         */
        hour(): number;
        /**
         * @return the minutes 0-59
         */
        minute(): number;
        /**
         * @return the seconds 0-59
         */
        second(): number;
        /**
         * @return the milliseconds 0-999
         */
        millisecond(): number;
        /**
         * @return the day-of-week (the enum values correspond to JavaScript
         * week day numbers)
         */
        weekDay(): basics.WeekDay;
        /**
         * Returns the day number within the year: Jan 1st has number 0,
         * Jan 2nd has number 1 etc.
         *
         * @return the day-of-year [0-366]
         */
        dayOfYear(): number;
        /**
         * The ISO 8601 week number. Week 1 is the week
         * that has January 4th in it, and it starts on Monday.
         * See https://en.wikipedia.org/wiki/ISO_week_date
         *
         * @return Week number [1-53]
         */
        weekNumber(): number;
        /**
         * The week of this month. There is no official standard for this,
         * but we assume the same rules for the weekNumber (i.e.
         * week 1 is the week that has the 4th day of the month in it)
         *
         * @return Week number [1-5]
         */
        weekOfMonth(): number;
        /**
         * Returns the number of seconds that have passed on the current day
         * Does not consider leap seconds
         *
         * @return seconds [0-86399]
         */
        secondOfDay(): number;
        /**
         * @return Milliseconds since 1970-01-01T00:00:00.000Z
         */
        unixUtcMillis(): number;
        /**
         * @return The full year e.g. 2014
         */
        utcYear(): number;
        /**
         * @return The UTC month 1-12 (note this deviates from JavaScript Date)
         */
        utcMonth(): number;
        /**
         * @return The UTC day of the month 1-31
         */
        utcDay(): number;
        /**
         * @return The UTC hour 0-23
         */
        utcHour(): number;
        /**
         * @return The UTC minutes 0-59
         */
        utcMinute(): number;
        /**
         * @return The UTC seconds 0-59
         */
        utcSecond(): number;
        /**
         * Returns the UTC day number within the year: Jan 1st has number 0,
         * Jan 2nd has number 1 etc.
         *
         * @return the day-of-year [0-366]
         */
        utcDayOfYear(): number;
        /**
         * @return The UTC milliseconds 0-999
         */
        utcMillisecond(): number;
        /**
         * @return the UTC day-of-week (the enum values correspond to JavaScript
         * week day numbers)
         */
        utcWeekDay(): basics.WeekDay;
        /**
         * The ISO 8601 UTC week number. Week 1 is the week
         * that has January 4th in it, and it starts on Monday.
         * See https://en.wikipedia.org/wiki/ISO_week_date
         *
         * @return Week number [1-53]
         */
        utcWeekNumber(): number;
        /**
         * The week of this month. There is no official standard for this,
         * but we assume the same rules for the weekNumber (i.e.
         * week 1 is the week that has the 4th day of the month in it)
         *
         * @return Week number [1-5]
         */
        utcWeekOfMonth(): number;
        /**
         * Returns the number of seconds that have passed on the current day
         * Does not consider leap seconds
         *
         * @return seconds [0-86399]
         */
        utcSecondOfDay(): number;
        /**
         * Convert this date to the given time zone (in-place).
         * Throws if this date does not have a time zone.
         * @return this (for chaining)
         */
        convert(zone?: timezone.TimeZone): DateTime;
        /**
         * Returns this date converted to the given time zone.
         * Unaware dates can only be converted to unaware dates (clone)
         * Converting an unaware date to an aware date throws an exception. Use the constructor
         * if you really need to do that.
         *
         * @param zone	The new time zone. This may be null to create unaware date.
         * @return The converted date
         */
        toZone(zone?: timezone.TimeZone): DateTime;
        /**
         * Convert to JavaScript date with the zone time in the getX() methods.
         * Unless the timezone is local, the Date.getUTCX() methods will NOT be correct.
         * This is because Date calculates getUTCX() from getX() applying local time zone.
         */
        toDate(): Date;
        /**
         * Add a time duration relative to UTC. Note that this simply adds a number
         * of milliseconds to UTC and converts back to zone(),
         * There is not DST handling.
         * @return this + duration
         */
        add(duration: duration.Duration): DateTime;
        /**
         * Add an amount of time relative to UTC, as regularly as possible.
         *
         * Adding e.g. 1 hour will increment the utcHour() field, adding 1 month
         * increments the utcMonth() field.
         * Adding an amount of units leaves lower units intact. E.g.
         * adding a month will leave the day() field untouched if possible.
         *
         * Note adding Months or Years will clamp the date to the end-of-month if
         * the start date was at the end of a month, i.e. contrary to JavaScript
         * Date#setUTCMonth() it will not overflow into the next month
         *
         * In case of DST changes, the utc time fields are still untouched but local
         * time fields may shift.
         */
        add(amount: number, unit: basics.TimeUnit): DateTime;
        /**
         * Add an amount of time to the zone time, as regularly as possible.
         *
         * Adding e.g. 1 hour will increment the hour() field of the zone
         * date by one. In case of DST changes, the time fields may additionally
         * increase by the DST offset, if a non-existing local time would
         * be reached otherwise.
         *
         * Adding a unit of time will leave lower-unit fields intact, unless the result
         * would be a non-existing time. Then an extra DST offset is added.
         *
         * Note adding Months or Years will clamp the date to the end-of-month if
         * the start date was at the end of a month, i.e. contrary to JavaScript
         * Date#setUTCMonth() it will not overflow into the next month
         */
        addLocal(amount: number, unit: basics.TimeUnit): DateTime;
        /**
         * Same as add(-1*duration);
         */
        sub(duration: duration.Duration): DateTime;
        /**
         * Same as add(-1*amount, unit);
         */
        sub(amount: number, unit: basics.TimeUnit): DateTime;
        /**
         * Same as addLocal(-1*amount, unit);
         */
        subLocal(amount: number, unit: basics.TimeUnit): DateTime;
        /**
         * Time difference between two DateTimes
         * @return this - other
         */
        diff(other: DateTime): duration.Duration;
        /**
         * @return True iff (this < other)
         */
        lessThan(other: DateTime): boolean;
        /**
         * @return True iff (this <= other)
         */
        lessEqual(other: DateTime): boolean;
        /**
         * @return True iff this and other represent the same time in UTC
         */
        equals(other: DateTime): boolean;
        /**
         * @return True iff this and other represent the same time and
         * have the same zone
         */
        identical(other: DateTime): boolean;
        /**
         * @return True iff this > other
         */
        greaterThan(other: DateTime): boolean;
        /**
         * @return True iff this >= other
         */
        greaterEqual(other: DateTime): boolean;
        /**
         * Proper ISO 8601 format string with any IANA zone converted to ISO offset
         * E.g. "2014-01-01T23:15:33+01:00" for Europe/Amsterdam
         */
        toIsoString(): string;
        format(formatString: string): string;
        /**
         * Modified ISO 8601 format string with IANA name if applicable.
         * E.g. "2014-01-01T23:15:33.000 Europe/Amsterdam"
         */
        toString(): string;
        /**
         * Used by util.inspect()
         */
        inspect(): string;
        /**
         * The valueOf() method returns the primitive value of the specified object.
         */
        valueOf(): any;
        /**
         * Modified ISO 8601 format string in UTC without time zone info
         */
        toUtcString(): string;
    }
}

declare module '__timezonecomplete/duration' {
    /**
     * Time duration. Create one e.g. like this: var d = Duration.hours(1).
     * Note that time durations do not take leap seconds etc. into account:
     * one hour is simply represented as 3600000 milliseconds.
     */
    export class Duration {
        /**
         * Construct a time duration
         * @param n	Number of hours
         * @return A duration of n hours
         */
        static hours(n: number): Duration;
        /**
         * Construct a time duration
         * @param n	Number of minutes
         * @return A duration of n minutes
         */
        static minutes(n: number): Duration;
        /**
         * Construct a time duration
         * @param n	Number of seconds
         * @return A duration of n seconds
         */
        static seconds(n: number): Duration;
        /**
         * Construct a time duration
         * @param n	Number of milliseconds
         * @return A duration of n milliseconds
         */
        static milliseconds(n: number): Duration;
        /**
         * Construct a time duration of 0
         */
        constructor();
        /**
         * Construct a time duration from a number of milliseconds
         */
        constructor(milliseconds: number);
        /**
         * Construct a time duration from a string in format
         * [-]h[:m[:s[.n]]] e.g. -01:00:30.501
         */
        constructor(input: string);
        /**
         * @return another instance of Duration with the same value.
         */
        clone(): Duration;
        /**
         * The entire duration in milliseconds (negative or positive)
         */
        milliseconds(): number;
        /**
         * The millisecond part of the duration (always positive)
         * @return e.g. 400 for a -01:02:03.400 duration
         */
        millisecond(): number;
        /**
         * The entire duration in seconds (negative or positive, fractional)
         * @return e.g. 1.5 for a 1500 milliseconds duration
         */
        seconds(): number;
        /**
         * The second part of the duration (always positive)
         * @return e.g. 3 for a -01:02:03.400 duration
         */
        second(): number;
        /**
         * The entire duration in minutes (negative or positive, fractional)
         * @return e.g. 1.5 for a 90000 milliseconds duration
         */
        minutes(): number;
        /**
         * The minute part of the duration (always positive)
         * @return e.g. 2 for a -01:02:03.400 duration
         */
        minute(): number;
        /**
         * The entire duration in hours (negative or positive, fractional)
         * @return e.g. 1.5 for a 5400000 milliseconds duration
         */
        hours(): number;
        /**
         * The hour part of the duration (always positive).
         * Note that this part can exceed 23 hours, because for
         * now, we do not have a days() function
         * @return e.g. 25 for a -25:02:03.400 duration
         */
        wholeHours(): number;
        /**
         * Sign
         * @return "-" if the duration is negative
         */
        sign(): string;
        /**
         * @return True iff (this < other)
         */
        lessThan(other: Duration): boolean;
        /**
         * @return True iff this and other represent the same time duration
         */
        equals(other: Duration): boolean;
        /**
         * @return True iff this > other
         */
        greaterThan(other: Duration): boolean;
        /**
         * @return The minimum (most negative) of this and other
         */
        min(other: Duration): Duration;
        /**
         * @return The maximum (most positive) of this and other
         */
        max(other: Duration): Duration;
        /**
         * Multiply with a fixed number.
         * @return a new Duration of (this * value)
         */
        multiply(value: number): Duration;
        /**
         * Divide by a fixed number.
         * @return a new Duration of (this / value)
         */
        divide(value: number): Duration;
        /**
         * Add a duration.
         * @return a new Duration of (this + value)
         */
        add(value: Duration): Duration;
        /**
         * Subtract a duration.
         * @return a new Duration of (this - value)
         */
        sub(value: Duration): Duration;
        /**
         * String in [-]hh:mm:ss.nnn notation. All fields are
         * always present except the sign.
         */
        toFullString(): string;
        /**
         * String in [-]hh[:mm[:ss[.nnn]]] notation. Fields are
         * added as necessary
         */
        toString(): string;
        /**
         * Used by util.inspect()
         */
        inspect(): string;
        /**
         * The valueOf() method returns the primitive value of the specified object.
         */
        valueOf(): any;
    }
}

declare module '__timezonecomplete/javascript' {
    /**
     * Indicates how a Date object should be interpreted.
     * Either we can take getYear(), getMonth() etc for our field
     * values, or we can take getUTCYear(), getUtcMonth() etc to do that.
     */
    export enum DateFunctions {
        /**
         * Use the Date.getFullYear(), Date.getMonth(), ... functions.
         */
        Get = 0,
        /**
         * Use the Date.getUTCFullYear(), Date.getUTCMonth(), ... functions.
         */
        GetUTC = 1,
    }
}

declare module '__timezonecomplete/period' {
    import basics = require("__timezonecomplete/basics");
    import datetime = require("__timezonecomplete/datetime");
    /**
     * Specifies how the period should repeat across the day
     * during DST changes.
     */
    export enum PeriodDst {
        /**
         * Keep repeating in similar intervals measured in UTC,
         * unaffected by Daylight Saving Time.
         * E.g. a repetition of one hour will take one real hour
         * every time, even in a time zone with DST.
         * Leap seconds, leap days and month length
         * differences will still make the intervals different.
         */
        RegularIntervals = 0,
        /**
         * Ensure that the time at which the intervals occur stay
         * at the same place in the day, local time. So e.g.
         * a period of one day, starting at 8:05AM Europe/Amsterdam time
         * will always start at 8:05 Europe/Amsterdam. This means that
         * in UTC time, some intervals will be 25 hours and some
         * 23 hours during DST changes.
         * Another example: an hourly interval will be hourly in local time,
         * skipping an hour in UTC for a DST backward change.
         */
        RegularLocalTime = 1,
    }
    /**
     * Convert a PeriodDst to a string: "regular intervals" or "regular local time"
     */
    export function periodDstToString(p: PeriodDst): string;
    /**
     * Repeating time period: consists of a starting point and
     * a time length. This class accounts for leap seconds and leap days.
     */
    export class Period {
        /**
         * Constructor
         * LIMITATION: if dst equals RegularLocalTime, and unit is Second, Minute or Hour,
         * then the amount must be a factor of 24. So 120 seconds is allowed while 121 seconds is not.
         * This is due to the enormous processing power required by these cases. They are not
         * implemented and you will get an assert.
         *
         * @param start The start of the period. If the period is in Months or Years, and
         *				the day is 29 or 30 or 31, the results are maximised to end-of-month.
         * @param amount	The amount of units.
         * @param unit	The unit.
         * @param dst	Specifies how to handle Daylight Saving Time. Not relevant
         *				if the time zone of the start datetime does not have DST.
         */
        constructor(start: datetime.DateTime, amount: number, unit: basics.TimeUnit, dst: PeriodDst);
        /**
         * The start date
         */
        start(): datetime.DateTime;
        /**
         * The amount of units
         */
        amount(): number;
        /**
         * The unit
         */
        unit(): basics.TimeUnit;
        /**
         * The dst handling mode
         */
        dst(): PeriodDst;
        /**
         * The first occurrence of the period greater than
         * the given date. The given date need not be at a period boundary.
         * Pre: the fromdate and startdate must either both have timezones or not
         * @param fromDate: the date after which to return the next date
         * @return the first date matching the period after fromDate, given
         *			in the same zone as the fromDate.
         */
        findFirst(fromDate: datetime.DateTime): datetime.DateTime;
        /**
         * Returns the next timestamp in the period. The given timestamp must
         * be at a period boundary, otherwise the answer is incorrect.
         * This function has MUCH better performance than findFirst.
         * Returns the datetime "count" times away from the given datetime.
         * @param prev	Boundary date. Must have a time zone (any time zone) iff the period start date has one.
         * @param count	Optional, must be >= 1 and whole.
         * @return (prev + count * period), in the same timezone as prev.
         */
        findNext(prev: datetime.DateTime, count?: number): datetime.DateTime;
        /**
         * Checks whether the given date is on a period boundary
         * (expensive!)
         */
        isBoundary(occurrence: datetime.DateTime): boolean;
        /**
         * Returns an ISO duration string e.g.
         * 2014-01-01T12:00:00.000+01:00/P1H
         * 2014-01-01T12:00:00.000+01:00/PT1M   (one minute)
         * 2014-01-01T12:00:00.000+01:00/P1M   (one month)
         */
        toIsoString(): string;
        /**
         * A string representation e.g.
         * "10 years, starting at 2014-03-01T12:00:00 Europe/Amsterdam, keeping regular intervals".
         */
        toString(): string;
        /**
         * Used by util.inspect()
         */
        inspect(): string;
    }
}

declare module '__timezonecomplete/timesource' {
    /**
     * For testing purposes, we often need to manipulate what the current
     * time is. This is an interface for a custom time source object
     * so in tests you can use a custom time source.
     */
    export interface TimeSource {
        /**
         * Return the current date+time as a javascript Date object
         */
        now(): Date;
    }
    /**
     * Default time source, returns actual time
     */
    export class RealTimeSource implements TimeSource {
        now(): Date;
    }
}

declare module '__timezonecomplete/timezone' {
    import javascript = require("__timezonecomplete/javascript");
    /**
     * The type of time zone
     */
    export enum TimeZoneKind {
        /**
         * Local time offset as determined by JavaScript Date class.
         */
        Local = 0,
        /**
         * Fixed offset from UTC, without DST.
         */
        Offset = 1,
        /**
         * IANA timezone managed through Olsen TZ database. Includes
         * DST if applicable.
         */
        Proper = 2,
    }
    /**
     * Option for TimeZone#normalizeLocal()
     */
    export enum NormalizeOption {
        /**
         * Normalize non-existing times by ADDING the DST offset
         */
        Up = 0,
        /**
         * Normalize non-existing times by SUBTRACTING the DST offset
         */
        Down = 1,
    }
    /**
     * Time zone. The object is immutable because it is cached:
     * requesting a time zone twice yields the very same object.
     * Note that we use time zone offsets inverted w.r.t. JavaScript Date.getTimezoneOffset(),
     * i.e. offset 90 means +01:30.
     *
     * Time zones come in three flavors: the local time zone, as calculated by JavaScript Date,
     * a fixed offset ("+01:30") without DST, or a IANA timezone ("Europe/Amsterdam") with DST
     * applied depending on the time zone rules.
     */
    export class TimeZone {
        /**
         * The local time zone for a given date. Note that
         * the time zone varies with the date: amsterdam time for
         * 2014-01-01 is +01:00 and amsterdam time for 2014-07-01 is +02:00
         */
        static local(): TimeZone;
        /**
         * The UTC time zone.
         */
        static utc(): TimeZone;
        /**
         * Returns a time zone object from the cache. If it does not exist, it is created.
         * @return The time zone with the given offset w.r.t. UTC in minutes, e.g. 90 for +01:30
         */
        static zone(offset: number): TimeZone;
        /**
         * Returns a time zone object from the cache. If it does not exist, it is created.
         * @param s: Empty string for local time, a TZ database time zone name (e.g. Europe/Amsterdam)
         *			 or an offset string (either +01:30, +0130, +01, Z). For a full list of names, see:
         *			 https://en.wikipedia.org/wiki/List_of_tz_database_time_zones
         */
        static zone(s: string): TimeZone;
        /**
         * Do not use this constructor, use the static
         * TimeZone.zone() method instead.
         * @param name NORMALIZED name, assumed to be correct
         */
        constructor(name: string);
        /**
         * The time zone identifier. Can be an offset "-01:30" or an
         * IANA time zone name "Europe/Amsterdam", or "localtime" for
         * the local time zone.
         */
        name(): string;
        /**
         * The kind of time zone (Local/Offset/Proper)
         */
        kind(): TimeZoneKind;
        /**
         * Equality operator. Maps zero offsets and different names for UTC onto
         * each other. Other time zones are not mapped onto each other.
         */
        equals(other: TimeZone): boolean;
        /**
         * Is this zone equivalent to UTC?
         */
        isUtc(): boolean;
        /**
         * Does this zone have Daylight Saving Time at all?
         */
        hasDst(): boolean;
        /**
         * Calculate timezone offset from a UTC time.
         *
         * @param year Full year
         * @param month Month 1-12 (note this deviates from JavaScript date)
         * @param day Day of month 1-31
         * @param hour Hour 0-23
         * @param minute Minute 0-59
         * @param second Second 0-59
         * @param millisecond Millisecond 0-999
         *
         * @return the offset of this time zone with respect to UTC at the given time, in minutes.
         */
        offsetForUtc(year: number, month: number, day: number, hour?: number, minute?: number, second?: number, millisecond?: number): number;
        /**
         * Calculate timezone offset from a zone-local time (NOT a UTC time).
         * @param year local full year
         * @param month local month 1-12 (note this deviates from JavaScript date)
         * @param day local day of month 1-31
         * @param hour local hour 0-23
         * @param minute local minute 0-59
         * @param second local second 0-59
         * @param millisecond local millisecond 0-999
         * @return the offset of this time zone with respect to UTC at the given time, in minutes.
         */
        offsetForZone(year: number, month: number, day: number, hour?: number, minute?: number, second?: number, millisecond?: number): number;
        /**
         * Note: will be removed in version 2.0.0
         *
         * Convenience function, takes values from a Javascript Date
         * Calls offsetForUtc() with the contents of the date
         *
         * @param date: the date
         * @param funcs: the set of functions to use: get() or getUTC()
         */
        offsetForUtcDate(date: Date, funcs: javascript.DateFunctions): number;
        /**
         * Note: will be removed in version 2.0.0
         *
         * Convenience function, takes values from a Javascript Date
         * Calls offsetForUtc() with the contents of the date
         *
         * @param date: the date
         * @param funcs: the set of functions to use: get() or getUTC()
         */
        offsetForZoneDate(date: Date, funcs: javascript.DateFunctions): number;
        /**
         * Zone abbreviation at given UTC timestamp e.g. CEST for Central European Summer Time.
         *
         * @param year Full year
         * @param month Month 1-12 (note this deviates from JavaScript date)
         * @param day Day of month 1-31
         * @param hour Hour 0-23
         * @param minute Minute 0-59
         * @param second Second 0-59
         * @param millisecond Millisecond 0-999
         * @param dstDependent (default true) set to false for a DST-agnostic abbreviation
         *
         * @return "local" for local timezone, the offset for an offset zone, or the abbreviation for a proper zone.
         */
        abbreviationForUtc(year: number, month: number, day: number, hour?: number, minute?: number, second?: number, millisecond?: number, dstDependent?: boolean): string;
        /**
         * Normalizes non-existing local times by adding a forward offset change.
         * During a forward standard offset change or DST offset change, some amount of
         * local time is skipped. Therefore, this amount of local time does not exist.
         * This function adds the amount of forward change to any non-existing time. After all,
         * this is probably what the user meant.
         *
         * @param localUnixMillis	Unix timestamp in zone time
         * @param opt	(optional) Round up or down? Default: up
         *
         * @returns	Unix timestamp in zone time, normalized.
         */
        normalizeZoneTime(localUnixMillis: number, opt?: NormalizeOption): number;
        /**
         * The time zone identifier (normalized).
         * Either "localtime", IANA name, or "+hh:mm" offset.
         */
        toString(): string;
        /**
         * Used by util.inspect()
         */
        inspect(): string;
        /**
         * Convert an offset number into an offset string
         * @param offset The offset in minutes from UTC e.g. 90 minutes
         * @return the offset in ISO notation "+01:30" for +90 minutes
         */
        static offsetToString(offset: number): string;
        /**
         * String to offset conversion.
         * @param s	Formats: "-01:00", "-0100", "-01", "Z"
         * @return offset w.r.t. UTC in minutes
         */
        static stringToOffset(s: string): number;
    }
}

