/* *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved. 
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0  
 
THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, 
MERCHANTABLITY OR NON-INFRINGEMENT. 
 
See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var TypeScript;
(function (TypeScript) {
    var ArrayUtilities = (function () {
        function ArrayUtilities() {
        }
        ArrayUtilities.isArray = function (value) {
            return Object.prototype.toString.apply(value, []) === '[object Array]';
        };

        ArrayUtilities.sequenceEquals = function (array1, array2, equals) {
            if (array1 === array2) {
                return true;
            }

            if (array1 === null || array2 === null) {
                return false;
            }

            if (array1.length !== array2.length) {
                return false;
            }

            for (var i = 0, n = array1.length; i < n; i++) {
                if (!equals(array1[i], array2[i])) {
                    return false;
                }
            }

            return true;
        };

        ArrayUtilities.contains = function (array, value) {
            for (var i = 0; i < array.length; i++) {
                if (array[i] === value) {
                    return true;
                }
            }

            return false;
        };

        ArrayUtilities.groupBy = function (array, func) {
            var result = {};

            for (var i = 0, n = array.length; i < n; i++) {
                var v = array[i];
                var k = func(v);

                var list = result[k] || [];
                list.push(v);
                result[k] = list;
            }

            return result;
        };

        ArrayUtilities.min = function (array, func) {
            var min = func(array[0]);

            for (var i = 1; i < array.length; i++) {
                var next = func(array[i]);
                if (next < min) {
                    min = next;
                }
            }

            return min;
        };

        ArrayUtilities.max = function (array, func) {
            var max = func(array[0]);

            for (var i = 1; i < array.length; i++) {
                var next = func(array[i]);
                if (next > max) {
                    max = next;
                }
            }

            return max;
        };

        ArrayUtilities.last = function (array) {
            if (array.length === 0) {
                throw TypeScript.Errors.argumentOutOfRange('array');
            }

            return array[array.length - 1];
        };

        ArrayUtilities.firstOrDefault = function (array, func) {
            for (var i = 0, n = array.length; i < n; i++) {
                var value = array[i];
                if (func(value)) {
                    return value;
                }
            }

            return null;
        };

        ArrayUtilities.sum = function (array, func) {
            var result = 0;

            for (var i = 0, n = array.length; i < n; i++) {
                result += func(array[i]);
            }

            return result;
        };

        ArrayUtilities.whereNotNull = function (array) {
            var result = [];
            for (var i = 0; i < array.length; i++) {
                var value = array[i];
                if (value !== null) {
                    result.push(value);
                }
            }

            return result;
        };

        ArrayUtilities.select = function (values, func) {
            var result = [];

            for (var i = 0; i < values.length; i++) {
                result.push(func(values[i]));
            }

            return result;
        };

        ArrayUtilities.where = function (values, func) {
            var result = [];

            for (var i = 0; i < values.length; i++) {
                if (func(values[i])) {
                    result.push(values[i]);
                }
            }

            return result;
        };

        ArrayUtilities.any = function (array, func) {
            for (var i = 0, n = array.length; i < n; i++) {
                if (func(array[i])) {
                    return true;
                }
            }

            return false;
        };

        ArrayUtilities.all = function (array, func) {
            for (var i = 0, n = array.length; i < n; i++) {
                if (!func(array[i])) {
                    return false;
                }
            }

            return true;
        };

        ArrayUtilities.binarySearch = function (array, value) {
            var low = 0;
            var high = array.length - 1;

            while (low <= high) {
                var middle = low + ((high - low) >> 1);
                var midValue = array[middle];

                if (midValue === value) {
                    return middle;
                } else if (midValue > value) {
                    high = middle - 1;
                } else {
                    low = middle + 1;
                }
            }

            return ~low;
        };

        ArrayUtilities.createArray = function (length, defaultvalue) {
            var result = [];
            for (var i = 0; i < length; i++) {
                result.push(defaultvalue);
            }

            return result;
        };

        ArrayUtilities.grow = function (array, length, defaultValue) {
            var count = length - array.length;
            for (var i = 0; i < count; i++) {
                array.push(defaultValue);
            }
        };

        ArrayUtilities.copy = function (sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
            for (var i = 0; i < length; i++) {
                destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
            }
        };
        return ArrayUtilities;
    })();
    TypeScript.ArrayUtilities = ArrayUtilities;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Constants) {
        Constants[Constants["Max31BitInteger"] = 1073741823] = "Max31BitInteger";
        Constants[Constants["Min31BitInteger"] = -1073741824] = "Min31BitInteger";
    })(TypeScript.Constants || (TypeScript.Constants = {}));
    var Constants = TypeScript.Constants;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Contract = (function () {
        function Contract() {
        }
        Contract.requires = function (expression) {
            if (!expression) {
                throw new Error("Contract violated. False expression.");
            }
        };

        Contract.throwIfFalse = function (expression) {
            if (!expression) {
                throw new Error("Contract violated. False expression.");
            }
        };

        Contract.throwIfNull = function (value) {
            if (value === null) {
                throw new Error("Contract violated. Null value.");
            }
        };
        return Contract;
    })();
    TypeScript.Contract = Contract;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Debug = (function () {
        function Debug() {
        }
        Debug.assert = function (expression, message) {
            if (!expression) {
                throw new Error("Debug Failure. False expression: " + (message ? message : ""));
            }
        };
        return Debug;
    })();
    TypeScript.Debug = Debug;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (DiagnosticCategory) {
        DiagnosticCategory[DiagnosticCategory["Warning"] = 0] = "Warning";
        DiagnosticCategory[DiagnosticCategory["Error"] = 1] = "Error";
        DiagnosticCategory[DiagnosticCategory["Message"] = 2] = "Message";
        DiagnosticCategory[DiagnosticCategory["NoPrefix"] = 3] = "NoPrefix";
    })(TypeScript.DiagnosticCategory || (TypeScript.DiagnosticCategory = {}));
    var DiagnosticCategory = TypeScript.DiagnosticCategory;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (DiagnosticCode) {
        DiagnosticCode[DiagnosticCode["error_TS_0__1"] = 0] = "error_TS_0__1";
        DiagnosticCode[DiagnosticCode["warning_TS_0__1"] = 1] = "warning_TS_0__1";

        DiagnosticCode[DiagnosticCode["_0__NL__1_TB__2"] = 2] = "_0__NL__1_TB__2";
        DiagnosticCode[DiagnosticCode["_0_TB__1"] = 3] = "_0_TB__1";

        DiagnosticCode[DiagnosticCode["Unrecognized_escape_sequence"] = 4] = "Unrecognized_escape_sequence";
        DiagnosticCode[DiagnosticCode["Unexpected_character_0"] = 5] = "Unexpected_character_0";
        DiagnosticCode[DiagnosticCode["Missing_closing_quote_character"] = 6] = "Missing_closing_quote_character";
        DiagnosticCode[DiagnosticCode["Identifier_expected"] = 7] = "Identifier_expected";
        DiagnosticCode[DiagnosticCode["_0_keyword_expected"] = 8] = "_0_keyword_expected";
        DiagnosticCode[DiagnosticCode["_0_expected"] = 9] = "_0_expected";
        DiagnosticCode[DiagnosticCode["Identifier_expected__0__is_a_keyword"] = 10] = "Identifier_expected__0__is_a_keyword";
        DiagnosticCode[DiagnosticCode["Automatic_semicolon_insertion_not_allowed"] = 11] = "Automatic_semicolon_insertion_not_allowed";
        DiagnosticCode[DiagnosticCode["Unexpected_token__0_expected"] = 12] = "Unexpected_token__0_expected";
        DiagnosticCode[DiagnosticCode["Trailing_separator_not_allowed"] = 13] = "Trailing_separator_not_allowed";
        DiagnosticCode[DiagnosticCode["_StarSlash__expected"] = 14] = "_StarSlash__expected";
        DiagnosticCode[DiagnosticCode["_public_or_private_modifier_must_precede__static_"] = 15] = "_public_or_private_modifier_must_precede__static_";
        DiagnosticCode[DiagnosticCode["Unexpected_token_"] = 16] = "Unexpected_token_";
        DiagnosticCode[DiagnosticCode["A_catch_clause_variable_cannot_have_a_type_annotation"] = 17] = "A_catch_clause_variable_cannot_have_a_type_annotation";
        DiagnosticCode[DiagnosticCode["Rest_parameter_must_be_last_in_list"] = 18] = "Rest_parameter_must_be_last_in_list";
        DiagnosticCode[DiagnosticCode["Parameter_cannot_have_question_mark_and_initializer"] = 19] = "Parameter_cannot_have_question_mark_and_initializer";
        DiagnosticCode[DiagnosticCode["Required_parameter_cannot_follow_optional_parameter"] = 20] = "Required_parameter_cannot_follow_optional_parameter";
        DiagnosticCode[DiagnosticCode["Index_signatures_cannot_have_rest_parameters"] = 21] = "Index_signatures_cannot_have_rest_parameters";
        DiagnosticCode[DiagnosticCode["Index_signature_parameter_cannot_have_accessibility_modifiers"] = 22] = "Index_signature_parameter_cannot_have_accessibility_modifiers";
        DiagnosticCode[DiagnosticCode["Index_signature_parameter_cannot_have_a_question_mark"] = 23] = "Index_signature_parameter_cannot_have_a_question_mark";
        DiagnosticCode[DiagnosticCode["Index_signature_parameter_cannot_have_an_initializer"] = 24] = "Index_signature_parameter_cannot_have_an_initializer";
        DiagnosticCode[DiagnosticCode["Index_signature_must_have_a_type_annotation"] = 25] = "Index_signature_must_have_a_type_annotation";
        DiagnosticCode[DiagnosticCode["Index_signature_parameter_must_have_a_type_annotation"] = 26] = "Index_signature_parameter_must_have_a_type_annotation";
        DiagnosticCode[DiagnosticCode["Index_signature_parameter_type_must_be__string__or__number_"] = 27] = "Index_signature_parameter_type_must_be__string__or__number_";
        DiagnosticCode[DiagnosticCode["_extends__clause_already_seen"] = 28] = "_extends__clause_already_seen";
        DiagnosticCode[DiagnosticCode["_extends__clause_must_precede__implements__clause"] = 29] = "_extends__clause_must_precede__implements__clause";
        DiagnosticCode[DiagnosticCode["Class_can_only_extend_single_type"] = 30] = "Class_can_only_extend_single_type";
        DiagnosticCode[DiagnosticCode["_implements__clause_already_seen"] = 31] = "_implements__clause_already_seen";
        DiagnosticCode[DiagnosticCode["Accessibility_modifier_already_seen"] = 32] = "Accessibility_modifier_already_seen";
        DiagnosticCode[DiagnosticCode["_0__modifier_must_precede__1__modifier"] = 33] = "_0__modifier_must_precede__1__modifier";
        DiagnosticCode[DiagnosticCode["_0__modifier_already_seen"] = 34] = "_0__modifier_already_seen";
        DiagnosticCode[DiagnosticCode["_0__modifier_cannot_appear_on_a_class_element"] = 35] = "_0__modifier_cannot_appear_on_a_class_element";
        DiagnosticCode[DiagnosticCode["Interface_declaration_cannot_have__implements__clause"] = 36] = "Interface_declaration_cannot_have__implements__clause";
        DiagnosticCode[DiagnosticCode["_super__invocation_cannot_have_type_arguments"] = 37] = "_super__invocation_cannot_have_type_arguments";
        DiagnosticCode[DiagnosticCode["Non_ambient_modules_cannot_use_quoted_names"] = 38] = "Non_ambient_modules_cannot_use_quoted_names";
        DiagnosticCode[DiagnosticCode["Statements_are_not_allowed_in_ambient_contexts"] = 39] = "Statements_are_not_allowed_in_ambient_contexts";
        DiagnosticCode[DiagnosticCode["Implementations_are_not_allowed_in_ambient_contexts"] = 40] = "Implementations_are_not_allowed_in_ambient_contexts";
        DiagnosticCode[DiagnosticCode["_declare__modifier_not_allowed_for_code_already_in_an_ambient_context"] = 41] = "_declare__modifier_not_allowed_for_code_already_in_an_ambient_context";
        DiagnosticCode[DiagnosticCode["Initializers_are_not_allowed_in_ambient_contexts"] = 42] = "Initializers_are_not_allowed_in_ambient_contexts";
        DiagnosticCode[DiagnosticCode["Overload_and_ambient_signatures_cannot_specify_parameter_properties"] = 43] = "Overload_and_ambient_signatures_cannot_specify_parameter_properties";
        DiagnosticCode[DiagnosticCode["Function_implementation_expected"] = 44] = "Function_implementation_expected";
        DiagnosticCode[DiagnosticCode["Constructor_implementation_expected"] = 45] = "Constructor_implementation_expected";
        DiagnosticCode[DiagnosticCode["Function_overload_name_must_be__0_"] = 46] = "Function_overload_name_must_be__0_";
        DiagnosticCode[DiagnosticCode["_0__modifier_cannot_appear_on_a_module_element"] = 47] = "_0__modifier_cannot_appear_on_a_module_element";
        DiagnosticCode[DiagnosticCode["_declare__modifier_cannot_appear_on_an_interface_declaration"] = 48] = "_declare__modifier_cannot_appear_on_an_interface_declaration";
        DiagnosticCode[DiagnosticCode["_declare__modifier_required_for_top_level_element"] = 49] = "_declare__modifier_required_for_top_level_element";
        DiagnosticCode[DiagnosticCode["_set__accessor_must_have_only_one_parameter"] = 50] = "_set__accessor_must_have_only_one_parameter";
        DiagnosticCode[DiagnosticCode["_set__accessor_parameter_cannot_have_accessibility_modifier"] = 51] = "_set__accessor_parameter_cannot_have_accessibility_modifier";
        DiagnosticCode[DiagnosticCode["_set__accessor_parameter_cannot_be_optional"] = 52] = "_set__accessor_parameter_cannot_be_optional";
        DiagnosticCode[DiagnosticCode["_set__accessor_parameter_cannot_have_initializer"] = 53] = "_set__accessor_parameter_cannot_have_initializer";
        DiagnosticCode[DiagnosticCode["_set__accessor_cannot_have_rest_parameter"] = 54] = "_set__accessor_cannot_have_rest_parameter";
        DiagnosticCode[DiagnosticCode["_get__accessor_cannot_have_parameters"] = 55] = "_get__accessor_cannot_have_parameters";
        DiagnosticCode[DiagnosticCode["Rest_parameter_cannot_be_optional"] = 56] = "Rest_parameter_cannot_be_optional";
        DiagnosticCode[DiagnosticCode["Rest_parameter_cannot_have_initializer"] = 57] = "Rest_parameter_cannot_have_initializer";
        DiagnosticCode[DiagnosticCode["Modifiers_cannot_appear_here"] = 58] = "Modifiers_cannot_appear_here";
        DiagnosticCode[DiagnosticCode["Accessors_are_only_available_when_targeting_EcmaScript5_and_higher"] = 59] = "Accessors_are_only_available_when_targeting_EcmaScript5_and_higher";
        DiagnosticCode[DiagnosticCode["Class_name_cannot_be__0_"] = 60] = "Class_name_cannot_be__0_";
        DiagnosticCode[DiagnosticCode["Interface_name_cannot_be__0_"] = 61] = "Interface_name_cannot_be__0_";
        DiagnosticCode[DiagnosticCode["Enum_name_cannot_be__0_"] = 62] = "Enum_name_cannot_be__0_";
        DiagnosticCode[DiagnosticCode["Module_name_cannot_be__0_"] = 63] = "Module_name_cannot_be__0_";
        DiagnosticCode[DiagnosticCode["Enum_member_must_have_initializer"] = 64] = "Enum_member_must_have_initializer";
        DiagnosticCode[DiagnosticCode["_module_______is_deprecated__Use__require_______instead"] = 65] = "_module_______is_deprecated__Use__require_______instead";
        DiagnosticCode[DiagnosticCode["Export_assignments_cannot_be_used_in_internal_modules"] = 66] = "Export_assignments_cannot_be_used_in_internal_modules";
        DiagnosticCode[DiagnosticCode["Export_assignment_not_allowed_in_module_with_exported_element"] = 67] = "Export_assignment_not_allowed_in_module_with_exported_element";
        DiagnosticCode[DiagnosticCode["Module_cannot_have_multiple_export_assignments"] = 68] = "Module_cannot_have_multiple_export_assignments";

        DiagnosticCode[DiagnosticCode["Duplicate_identifier__0_"] = 69] = "Duplicate_identifier__0_";
        DiagnosticCode[DiagnosticCode["The_name__0__does_not_exist_in_the_current_scope"] = 70] = "The_name__0__does_not_exist_in_the_current_scope";
        DiagnosticCode[DiagnosticCode["The_name__0__does_not_refer_to_a_value"] = 71] = "The_name__0__does_not_refer_to_a_value";
        DiagnosticCode[DiagnosticCode["Keyword__super__can_only_be_used_inside_a_class_instance_method"] = 72] = "Keyword__super__can_only_be_used_inside_a_class_instance_method";
        DiagnosticCode[DiagnosticCode["The_left_hand_side_of_an_assignment_expression_must_be_a_variable__property_or_indexer"] = 73] = "The_left_hand_side_of_an_assignment_expression_must_be_a_variable__property_or_indexer";
        DiagnosticCode[DiagnosticCode["Value_of_type__0__is_not_callable__Did_you_mean_to_include__new__"] = 74] = "Value_of_type__0__is_not_callable__Did_you_mean_to_include__new__";
        DiagnosticCode[DiagnosticCode["Value_of_type__0__is_not_callable"] = 75] = "Value_of_type__0__is_not_callable";
        DiagnosticCode[DiagnosticCode["Value_of_type__0__is_not_newable"] = 76] = "Value_of_type__0__is_not_newable";
        DiagnosticCode[DiagnosticCode["Value_of_type__0__is_not_indexable_by_type__1_"] = 77] = "Value_of_type__0__is_not_indexable_by_type__1_";
        DiagnosticCode[DiagnosticCode["Operator__0__cannot_be_applied_to_types__1__and__2_"] = 78] = "Operator__0__cannot_be_applied_to_types__1__and__2_";
        DiagnosticCode[DiagnosticCode["Operator__0__cannot_be_applied_to_types__1__and__2__3"] = 79] = "Operator__0__cannot_be_applied_to_types__1__and__2__3";
        DiagnosticCode[DiagnosticCode["Cannot_convert__0__to__1_"] = 80] = "Cannot_convert__0__to__1_";
        DiagnosticCode[DiagnosticCode["Cannot_convert__0__to__1__NL__2"] = 81] = "Cannot_convert__0__to__1__NL__2";
        DiagnosticCode[DiagnosticCode["Expected_var__class__interface__or_module"] = 82] = "Expected_var__class__interface__or_module";
        DiagnosticCode[DiagnosticCode["Operator__0__cannot_be_applied_to_type__1_"] = 83] = "Operator__0__cannot_be_applied_to_type__1_";
        DiagnosticCode[DiagnosticCode["Getter__0__already_declared"] = 84] = "Getter__0__already_declared";
        DiagnosticCode[DiagnosticCode["Setter__0__already_declared"] = 85] = "Setter__0__already_declared";
        DiagnosticCode[DiagnosticCode["Accessor_cannot_have_type_parameters"] = 86] = "Accessor_cannot_have_type_parameters";
        DiagnosticCode[DiagnosticCode["Exported_class__0__extends_private_class__1_"] = 87] = "Exported_class__0__extends_private_class__1_";
        DiagnosticCode[DiagnosticCode["Exported_class__0__implements_private_interface__1_"] = 88] = "Exported_class__0__implements_private_interface__1_";
        DiagnosticCode[DiagnosticCode["Exported_interface__0__extends_private_interface__1_"] = 89] = "Exported_interface__0__extends_private_interface__1_";
        DiagnosticCode[DiagnosticCode["Exported_class__0__extends_class_from_inaccessible_module__1_"] = 90] = "Exported_class__0__extends_class_from_inaccessible_module__1_";
        DiagnosticCode[DiagnosticCode["Exported_class__0__implements_interface_from_inaccessible_module__1_"] = 91] = "Exported_class__0__implements_interface_from_inaccessible_module__1_";
        DiagnosticCode[DiagnosticCode["Exported_interface__0__extends_interface_from_inaccessible_module__1_"] = 92] = "Exported_interface__0__extends_interface_from_inaccessible_module__1_";
        DiagnosticCode[DiagnosticCode["Public_static_property__0__of__exported_class_has_or_is_using_private_type__1_"] = 93] = "Public_static_property__0__of__exported_class_has_or_is_using_private_type__1_";
        DiagnosticCode[DiagnosticCode["Public_property__0__of__exported_class_has_or_is_using_private_type__1_"] = 94] = "Public_property__0__of__exported_class_has_or_is_using_private_type__1_";
        DiagnosticCode[DiagnosticCode["Property__0__of__exported_interface_has_or_is_using_private_type__1_"] = 95] = "Property__0__of__exported_interface_has_or_is_using_private_type__1_";
        DiagnosticCode[DiagnosticCode["Exported_variable__0__has_or_is_using_private_type__1_"] = 96] = "Exported_variable__0__has_or_is_using_private_type__1_";
        DiagnosticCode[DiagnosticCode["Public_static_property__0__of__exported_class_is_using_inaccessible_module__1_"] = 97] = "Public_static_property__0__of__exported_class_is_using_inaccessible_module__1_";
        DiagnosticCode[DiagnosticCode["Public_property__0__of__exported_class_is_using_inaccessible_module__1_"] = 98] = "Public_property__0__of__exported_class_is_using_inaccessible_module__1_";
        DiagnosticCode[DiagnosticCode["Property__0__of__exported_interface_is_using_inaccessible_module__1_"] = 99] = "Property__0__of__exported_interface_is_using_inaccessible_module__1_";
        DiagnosticCode[DiagnosticCode["Exported_variable__0__is_using_inaccessible_module__1_"] = 100] = "Exported_variable__0__is_using_inaccessible_module__1_";
        DiagnosticCode[DiagnosticCode["Parameter__0__of_constructor_from_exported_class_has_or_is_using_private_type__1_"] = 101] = "Parameter__0__of_constructor_from_exported_class_has_or_is_using_private_type__1_";
        DiagnosticCode[DiagnosticCode["Parameter__0__of_public_static_property_setter_from_exported_class_has_or_is_using_private_type__1_"] = 102] = "Parameter__0__of_public_static_property_setter_from_exported_class_has_or_is_using_private_type__1_";
        DiagnosticCode[DiagnosticCode["Parameter__0__of_public_property_setter_from_exported_class_has_or_is_using_private_type__1_"] = 103] = "Parameter__0__of_public_property_setter_from_exported_class_has_or_is_using_private_type__1_";
        DiagnosticCode[DiagnosticCode["Parameter__0__of_constructor_signature_from_exported_interface_has_or_is_using_private_type__1_"] = 104] = "Parameter__0__of_constructor_signature_from_exported_interface_has_or_is_using_private_type__1_";
        DiagnosticCode[DiagnosticCode["Parameter__0__of_call_signature_from_exported_interface_has_or_is_using_private_type__1_"] = 105] = "Parameter__0__of_call_signature_from_exported_interface_has_or_is_using_private_type__1_";
        DiagnosticCode[DiagnosticCode["Parameter__0__of_public_static_method_from_exported_class_has_or_is_using_private_type__1_"] = 106] = "Parameter__0__of_public_static_method_from_exported_class_has_or_is_using_private_type__1_";
        DiagnosticCode[DiagnosticCode["Parameter__0__of_public_method_from_exported_class_has_or_is_using_private_type__1_"] = 107] = "Parameter__0__of_public_method_from_exported_class_has_or_is_using_private_type__1_";
        DiagnosticCode[DiagnosticCode["Parameter__0__of_method_from_exported_interface_has_or_is_using_private_type__1_"] = 108] = "Parameter__0__of_method_from_exported_interface_has_or_is_using_private_type__1_";
        DiagnosticCode[DiagnosticCode["Parameter__0__of_exported_function_has_or_is_using_private_type__1_"] = 109] = "Parameter__0__of_exported_function_has_or_is_using_private_type__1_";
        DiagnosticCode[DiagnosticCode["Parameter__0__of_constructor_from_exported_class_is_using_inaccessible_module__1_"] = 110] = "Parameter__0__of_constructor_from_exported_class_is_using_inaccessible_module__1_";
        DiagnosticCode[DiagnosticCode["Parameter__0__of_public_static_property_setter_from_exported_class_is_using_inaccessible_module__1_"] = 111] = "Parameter__0__of_public_static_property_setter_from_exported_class_is_using_inaccessible_module__1_";
        DiagnosticCode[DiagnosticCode["Parameter__0__of_public_property_setter_from_exported_class_is_using_inaccessible_module__1_"] = 112] = "Parameter__0__of_public_property_setter_from_exported_class_is_using_inaccessible_module__1_";
        DiagnosticCode[DiagnosticCode["Parameter__0__of_constructor_signature_from_exported_interface_is_using_inaccessible_module__1_"] = 113] = "Parameter__0__of_constructor_signature_from_exported_interface_is_using_inaccessible_module__1_";
        DiagnosticCode[DiagnosticCode["Parameter__0__of_call_signature_from_exported_interface_is_using_inaccessible_module__1_"] = 114] = "Parameter__0__of_call_signature_from_exported_interface_is_using_inaccessible_module__1_";
        DiagnosticCode[DiagnosticCode["Parameter__0__of_public_static_method_from_exported_class_is_using_inaccessible_module__1_"] = 115] = "Parameter__0__of_public_static_method_from_exported_class_is_using_inaccessible_module__1_";
        DiagnosticCode[DiagnosticCode["Parameter__0__of_public_method_from_exported_class_is_using_inaccessible_module__1_"] = 116] = "Parameter__0__of_public_method_from_exported_class_is_using_inaccessible_module__1_";
        DiagnosticCode[DiagnosticCode["Parameter__0__of_method_from_exported_interface_is_using_inaccessible_module__1_"] = 117] = "Parameter__0__of_method_from_exported_interface_is_using_inaccessible_module__1_";
        DiagnosticCode[DiagnosticCode["Parameter__0__of_exported_function_is_using_inaccessible_module__1_"] = 118] = "Parameter__0__of_exported_function_is_using_inaccessible_module__1_";
        DiagnosticCode[DiagnosticCode["Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_private_type__0_"] = 119] = "Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_private_type__0_";
        DiagnosticCode[DiagnosticCode["Return_type_of_public_property_getter_from_exported_class_has_or_is_using_private_type__0_"] = 120] = "Return_type_of_public_property_getter_from_exported_class_has_or_is_using_private_type__0_";
        DiagnosticCode[DiagnosticCode["Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_type__0_"] = 121] = "Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_type__0_";
        DiagnosticCode[DiagnosticCode["Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_type__0_"] = 122] = "Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_type__0_";
        DiagnosticCode[DiagnosticCode["Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_type__0_"] = 123] = "Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_type__0_";
        DiagnosticCode[DiagnosticCode["Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_type__0_"] = 124] = "Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_type__0_";
        DiagnosticCode[DiagnosticCode["Return_type_of_public_method_from_exported_class_has_or_is_using_private_type__0_"] = 125] = "Return_type_of_public_method_from_exported_class_has_or_is_using_private_type__0_";
        DiagnosticCode[DiagnosticCode["Return_type_of_method_from_exported_interface_has_or_is_using_private_type__0_"] = 126] = "Return_type_of_method_from_exported_interface_has_or_is_using_private_type__0_";
        DiagnosticCode[DiagnosticCode["Return_type_of_exported_function_has_or_is_using_private_type__0_"] = 127] = "Return_type_of_exported_function_has_or_is_using_private_type__0_";
        DiagnosticCode[DiagnosticCode["Return_type_of_public_static_property_getter_from_exported_class_is_using_inaccessible_module__0_"] = 128] = "Return_type_of_public_static_property_getter_from_exported_class_is_using_inaccessible_module__0_";
        DiagnosticCode[DiagnosticCode["Return_type_of_public_property_getter_from_exported_class_is_using_inaccessible_module__0_"] = 129] = "Return_type_of_public_property_getter_from_exported_class_is_using_inaccessible_module__0_";
        DiagnosticCode[DiagnosticCode["Return_type_of_constructor_signature_from_exported_interface_is_using_inaccessible_module__0_"] = 130] = "Return_type_of_constructor_signature_from_exported_interface_is_using_inaccessible_module__0_";
        DiagnosticCode[DiagnosticCode["Return_type_of_call_signature_from_exported_interface_is_using_inaccessible_module__0_"] = 131] = "Return_type_of_call_signature_from_exported_interface_is_using_inaccessible_module__0_";
        DiagnosticCode[DiagnosticCode["Return_type_of_index_signature_from_exported_interface_is_using_inaccessible_module__0_"] = 132] = "Return_type_of_index_signature_from_exported_interface_is_using_inaccessible_module__0_";
        DiagnosticCode[DiagnosticCode["Return_type_of_public_static_method_from_exported_class_is_using_inaccessible_module__0_"] = 133] = "Return_type_of_public_static_method_from_exported_class_is_using_inaccessible_module__0_";
        DiagnosticCode[DiagnosticCode["Return_type_of_public_method_from_exported_class_is_using_inaccessible_module__0_"] = 134] = "Return_type_of_public_method_from_exported_class_is_using_inaccessible_module__0_";
        DiagnosticCode[DiagnosticCode["Return_type_of_method_from_exported_interface_is_using_inaccessible_module__0_"] = 135] = "Return_type_of_method_from_exported_interface_is_using_inaccessible_module__0_";
        DiagnosticCode[DiagnosticCode["Return_type_of_exported_function_is_using_inaccessible_module__0_"] = 136] = "Return_type_of_exported_function_is_using_inaccessible_module__0_";
        DiagnosticCode[DiagnosticCode["_new_T____cannot_be_used_to_create_an_array__Use__new_Array_T_____instead"] = 137] = "_new_T____cannot_be_used_to_create_an_array__Use__new_Array_T_____instead";
        DiagnosticCode[DiagnosticCode["A_parameter_list_must_follow_a_generic_type_argument_list______expected"] = 138] = "A_parameter_list_must_follow_a_generic_type_argument_list______expected";
        DiagnosticCode[DiagnosticCode["Multiple_constructor_implementations_are_not_allowed"] = 139] = "Multiple_constructor_implementations_are_not_allowed";
        DiagnosticCode[DiagnosticCode["Unable_to_resolve_external_module__0_"] = 140] = "Unable_to_resolve_external_module__0_";
        DiagnosticCode[DiagnosticCode["Module_cannot_be_aliased_to_a_non_module_type"] = 141] = "Module_cannot_be_aliased_to_a_non_module_type";
        DiagnosticCode[DiagnosticCode["A_class_may_only_extend_another_class"] = 142] = "A_class_may_only_extend_another_class";
        DiagnosticCode[DiagnosticCode["A_class_may_only_implement_another_class_or_interface"] = 143] = "A_class_may_only_implement_another_class_or_interface";
        DiagnosticCode[DiagnosticCode["An_interface_may_only_extend_another_class_or_interface"] = 144] = "An_interface_may_only_extend_another_class_or_interface";
        DiagnosticCode[DiagnosticCode["An_interface_cannot_implement_another_type"] = 145] = "An_interface_cannot_implement_another_type";
        DiagnosticCode[DiagnosticCode["Unable_to_resolve_type"] = 146] = "Unable_to_resolve_type";
        DiagnosticCode[DiagnosticCode["Unable_to_resolve_type_of__0_"] = 147] = "Unable_to_resolve_type_of__0_";
        DiagnosticCode[DiagnosticCode["Unable_to_resolve_type_parameter_constraint"] = 148] = "Unable_to_resolve_type_parameter_constraint";
        DiagnosticCode[DiagnosticCode["Type_parameter_constraint_cannot_be_a_primitive_type"] = 149] = "Type_parameter_constraint_cannot_be_a_primitive_type";
        DiagnosticCode[DiagnosticCode["Supplied_parameters_do_not_match_any_signature_of_call_target"] = 150] = "Supplied_parameters_do_not_match_any_signature_of_call_target";
        DiagnosticCode[DiagnosticCode["Supplied_parameters_do_not_match_any_signature_of_call_target__NL__0"] = 151] = "Supplied_parameters_do_not_match_any_signature_of_call_target__NL__0";
        DiagnosticCode[DiagnosticCode["Invalid__new__expression"] = 152] = "Invalid__new__expression";
        DiagnosticCode[DiagnosticCode["Call_signatures_used_in_a__new__expression_must_have_a__void__return_type"] = 153] = "Call_signatures_used_in_a__new__expression_must_have_a__void__return_type";
        DiagnosticCode[DiagnosticCode["Could_not_select_overload_for__new__expression"] = 154] = "Could_not_select_overload_for__new__expression";
        DiagnosticCode[DiagnosticCode["Type__0__does_not_satisfy_the_constraint__1__for_type_parameter__2_"] = 155] = "Type__0__does_not_satisfy_the_constraint__1__for_type_parameter__2_";
        DiagnosticCode[DiagnosticCode["Could_not_select_overload_for__call__expression"] = 156] = "Could_not_select_overload_for__call__expression";
        DiagnosticCode[DiagnosticCode["Unable_to_invoke_type_with_no_call_signatures"] = 157] = "Unable_to_invoke_type_with_no_call_signatures";
        DiagnosticCode[DiagnosticCode["Calls_to__super__are_only_valid_inside_a_class"] = 158] = "Calls_to__super__are_only_valid_inside_a_class";
        DiagnosticCode[DiagnosticCode["Generic_type__0__requires_1_type_argument_s_"] = 159] = "Generic_type__0__requires_1_type_argument_s_";
        DiagnosticCode[DiagnosticCode["Type_of_conditional_expression_cannot_be_determined__Best_common_type_could_not_be_found_between__0__and__1_"] = 160] = "Type_of_conditional_expression_cannot_be_determined__Best_common_type_could_not_be_found_between__0__and__1_";
        DiagnosticCode[DiagnosticCode["Type_of_array_literal_cannot_be_determined__Best_common_type_could_not_be_found_for_array_elements"] = 161] = "Type_of_array_literal_cannot_be_determined__Best_common_type_could_not_be_found_for_array_elements";
        DiagnosticCode[DiagnosticCode["Could_not_find_enclosing_symbol_for_dotted_name__0_"] = 162] = "Could_not_find_enclosing_symbol_for_dotted_name__0_";
        DiagnosticCode[DiagnosticCode["The_property__0__does_not_exist_on_value_of_type__1__"] = 163] = "The_property__0__does_not_exist_on_value_of_type__1__";
        DiagnosticCode[DiagnosticCode["Could_not_find_symbol__0_"] = 164] = "Could_not_find_symbol__0_";
        DiagnosticCode[DiagnosticCode["_get__and__set__accessor_must_have_the_same_type"] = 165] = "_get__and__set__accessor_must_have_the_same_type";
        DiagnosticCode[DiagnosticCode["_this__cannot_be_referenced_in_current_location"] = 166] = "_this__cannot_be_referenced_in_current_location";
        DiagnosticCode[DiagnosticCode["Use_of_deprecated__bool__type__Use__boolean__instead"] = 167] = "Use_of_deprecated__bool__type__Use__boolean__instead";

        DiagnosticCode[DiagnosticCode["Class__0__is_recursively_referenced_as_a_base_type_of_itself"] = 168] = "Class__0__is_recursively_referenced_as_a_base_type_of_itself";
        DiagnosticCode[DiagnosticCode["Interface__0__is_recursively_referenced_as_a_base_type_of_itself"] = 169] = "Interface__0__is_recursively_referenced_as_a_base_type_of_itself";
        DiagnosticCode[DiagnosticCode["_super__property_access_is_permitted_only_in_a_constructor__instance_member_function__or_instance_member_accessor_of_a_derived_class"] = 170] = "_super__property_access_is_permitted_only_in_a_constructor__instance_member_function__or_instance_member_accessor_of_a_derived_class";
        DiagnosticCode[DiagnosticCode["_super__cannot_be_referenced_in_non_derived_classes"] = 171] = "_super__cannot_be_referenced_in_non_derived_classes";
        DiagnosticCode[DiagnosticCode["A__super__call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_intialized_properties_or_has_parameter_properties"] = 172] = "A__super__call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_intialized_properties_or_has_parameter_properties";
        DiagnosticCode[DiagnosticCode["Constructors_for_derived_classes_must_contain_a__super__call"] = 173] = "Constructors_for_derived_classes_must_contain_a__super__call";
        DiagnosticCode[DiagnosticCode["Super_calls_are_not_permitted_outside_constructors_or_in_local_functions_inside_constructors"] = 174] = "Super_calls_are_not_permitted_outside_constructors_or_in_local_functions_inside_constructors";
        DiagnosticCode[DiagnosticCode["_0_1__is_inaccessible"] = 175] = "_0_1__is_inaccessible";
        DiagnosticCode[DiagnosticCode["_this__cannot_be_referenced_within_module_bodies"] = 176] = "_this__cannot_be_referenced_within_module_bodies";
        DiagnosticCode[DiagnosticCode["_this__must_only_be_used_inside_a_function_or_script_context"] = 177] = "_this__must_only_be_used_inside_a_function_or_script_context";
        DiagnosticCode[DiagnosticCode["Invalid__addition__expression___types_do_not_agree"] = 178] = "Invalid__addition__expression___types_do_not_agree";
        DiagnosticCode[DiagnosticCode["The_right_hand_side_of_an_arithmetic_operation_must_be_of_type__any____number__or_an_enum_type"] = 179] = "The_right_hand_side_of_an_arithmetic_operation_must_be_of_type__any____number__or_an_enum_type";
        DiagnosticCode[DiagnosticCode["The_left_hand_side_of_an_arithmetic_operation_must_be_of_type__any____number__or_an_enum_type"] = 180] = "The_left_hand_side_of_an_arithmetic_operation_must_be_of_type__any____number__or_an_enum_type";
        DiagnosticCode[DiagnosticCode["The_type_of_a_unary_arithmetic_operation_operand_must_be_of_type__any____number__or_an_enum_type"] = 181] = "The_type_of_a_unary_arithmetic_operation_operand_must_be_of_type__any____number__or_an_enum_type";
        DiagnosticCode[DiagnosticCode["Variable_declarations_for_for_in_expressions_cannot_contain_a_type_annotation"] = 182] = "Variable_declarations_for_for_in_expressions_cannot_contain_a_type_annotation";
        DiagnosticCode[DiagnosticCode["Variable_declarations_for_for_in_expressions_must_be_of_types__string__or__any_"] = 183] = "Variable_declarations_for_for_in_expressions_must_be_of_types__string__or__any_";
        DiagnosticCode[DiagnosticCode["The_right_operand_of_a_for_in_expression_must_be_of_type__any____an_object_type_or_a_type_parameter"] = 184] = "The_right_operand_of_a_for_in_expression_must_be_of_type__any____an_object_type_or_a_type_parameter";
        DiagnosticCode[DiagnosticCode["The_left_hand_side_of_an__in__expression_must_be_of_types__string__or__any_"] = 185] = "The_left_hand_side_of_an__in__expression_must_be_of_types__string__or__any_";
        DiagnosticCode[DiagnosticCode["The_right_hand_side_of_an__in__expression_must_be_of_type__any___an_object_type_or_a_type_parameter"] = 186] = "The_right_hand_side_of_an__in__expression_must_be_of_type__any___an_object_type_or_a_type_parameter";
        DiagnosticCode[DiagnosticCode["The_left_hand_side_of_an__instanceOf__expression_must_be_of_type__any___an_object_type_or_a_type_parameter"] = 187] = "The_left_hand_side_of_an__instanceOf__expression_must_be_of_type__any___an_object_type_or_a_type_parameter";
        DiagnosticCode[DiagnosticCode["The_right_hand_side_of_an__instanceOf__expression_must_be_of_type__any__or_a_subtype_of_the__Function__interface_type"] = 188] = "The_right_hand_side_of_an__instanceOf__expression_must_be_of_type__any__or_a_subtype_of_the__Function__interface_type";
        DiagnosticCode[DiagnosticCode["Setters_cannot_return_a_value"] = 189] = "Setters_cannot_return_a_value";
        DiagnosticCode[DiagnosticCode["Tried_to_set_variable_type_to_module_type__0__"] = 190] = "Tried_to_set_variable_type_to_module_type__0__";
        DiagnosticCode[DiagnosticCode["Tried_to_set_variable_type_to_uninitialized_module_type__0__"] = 191] = "Tried_to_set_variable_type_to_uninitialized_module_type__0__";
        DiagnosticCode[DiagnosticCode["Function__0__declared_a_non_void_return_type__but_has_no_return_expression"] = 192] = "Function__0__declared_a_non_void_return_type__but_has_no_return_expression";
        DiagnosticCode[DiagnosticCode["Getters_must_return_a_value"] = 193] = "Getters_must_return_a_value";
        DiagnosticCode[DiagnosticCode["Getter_and_setter_accessors_do_not_agree_in_visibility"] = 194] = "Getter_and_setter_accessors_do_not_agree_in_visibility";
        DiagnosticCode[DiagnosticCode["Invalid_left_hand_side_of_assignment_expression"] = 195] = "Invalid_left_hand_side_of_assignment_expression";
        DiagnosticCode[DiagnosticCode["Function_declared_a_non_void_return_type__but_has_no_return_expression"] = 196] = "Function_declared_a_non_void_return_type__but_has_no_return_expression";
        DiagnosticCode[DiagnosticCode["Cannot_resolve_return_type_reference"] = 197] = "Cannot_resolve_return_type_reference";
        DiagnosticCode[DiagnosticCode["Constructors_cannot_have_a_return_type_of__void_"] = 198] = "Constructors_cannot_have_a_return_type_of__void_";
        DiagnosticCode[DiagnosticCode["Subsequent_variable_declarations_must_have_the_same_type___Variable__0__must_be_of_type__1___but_here_has_type___2_"] = 199] = "Subsequent_variable_declarations_must_have_the_same_type___Variable__0__must_be_of_type__1___but_here_has_type___2_";
        DiagnosticCode[DiagnosticCode["All_symbols_within_a__with__block_will_be_resolved_to__any__"] = 200] = "All_symbols_within_a__with__block_will_be_resolved_to__any__";
        DiagnosticCode[DiagnosticCode["Import_declarations_in_an_internal_module_cannot_reference_an_external_module"] = 201] = "Import_declarations_in_an_internal_module_cannot_reference_an_external_module";
        DiagnosticCode[DiagnosticCode["Class__0__declares_interface__1__but_does_not_implement_it__NL__2"] = 202] = "Class__0__declares_interface__1__but_does_not_implement_it__NL__2";
        DiagnosticCode[DiagnosticCode["Class__0__declares_class__1__but_does_not_implement_it__NL__2"] = 203] = "Class__0__declares_class__1__but_does_not_implement_it__NL__2";
        DiagnosticCode[DiagnosticCode["The_operand_of_an_increment_or_decrement_operator_must_be_a_variable__property_or_indexer"] = 204] = "The_operand_of_an_increment_or_decrement_operator_must_be_a_variable__property_or_indexer";
        DiagnosticCode[DiagnosticCode["_this__cannot_be_referenced_in_initializers_in_a_class_body"] = 205] = "_this__cannot_be_referenced_in_initializers_in_a_class_body";
        DiagnosticCode[DiagnosticCode["Class__0__cannot_extend_class__1__NL__2"] = 206] = "Class__0__cannot_extend_class__1__NL__2";
        DiagnosticCode[DiagnosticCode["Interface__0__cannot_extend_class__1__NL__2"] = 207] = "Interface__0__cannot_extend_class__1__NL__2";
        DiagnosticCode[DiagnosticCode["Interface__0__cannot_extend_interface__1__NL__2"] = 208] = "Interface__0__cannot_extend_interface__1__NL__2";
        DiagnosticCode[DiagnosticCode["Duplicate_overload_signature_for__0_"] = 209] = "Duplicate_overload_signature_for__0_";
        DiagnosticCode[DiagnosticCode["Duplicate_constructor_overload_signature"] = 210] = "Duplicate_constructor_overload_signature";
        DiagnosticCode[DiagnosticCode["Duplicate_overload_call_signature"] = 211] = "Duplicate_overload_call_signature";
        DiagnosticCode[DiagnosticCode["Duplicate_overload_construct_signature"] = 212] = "Duplicate_overload_construct_signature";
        DiagnosticCode[DiagnosticCode["Overload_signature_is_not_compatible_with_function_definition"] = 213] = "Overload_signature_is_not_compatible_with_function_definition";
        DiagnosticCode[DiagnosticCode["Overload_signature_is_not_compatible_with_function_definition__NL__0"] = 214] = "Overload_signature_is_not_compatible_with_function_definition__NL__0";
        DiagnosticCode[DiagnosticCode["Overload_signatures_must_all_be_public_or_private"] = 215] = "Overload_signatures_must_all_be_public_or_private";
        DiagnosticCode[DiagnosticCode["Overload_signatures_must_all_be_exported_or_local"] = 216] = "Overload_signatures_must_all_be_exported_or_local";
        DiagnosticCode[DiagnosticCode["Overload_signatures_must_all_be_ambient_or_non_ambient"] = 217] = "Overload_signatures_must_all_be_ambient_or_non_ambient";
        DiagnosticCode[DiagnosticCode["Overload_signatures_must_all_be_optional_or_required"] = 218] = "Overload_signatures_must_all_be_optional_or_required";
        DiagnosticCode[DiagnosticCode["Specialized_overload_signature_is_not_subtype_of_any_non_specialized_signature"] = 219] = "Specialized_overload_signature_is_not_subtype_of_any_non_specialized_signature";
        DiagnosticCode[DiagnosticCode["_this__cannot_be_referenced_in_constructor_arguments"] = 220] = "_this__cannot_be_referenced_in_constructor_arguments";
        DiagnosticCode[DiagnosticCode["Static_member_cannot_be_accessed_off_an_instance_variable"] = 221] = "Static_member_cannot_be_accessed_off_an_instance_variable";
        DiagnosticCode[DiagnosticCode["Instance_member_cannot_be_accessed_off_a_class"] = 222] = "Instance_member_cannot_be_accessed_off_a_class";
        DiagnosticCode[DiagnosticCode["Untyped_function_calls_may_not_accept_type_arguments"] = 223] = "Untyped_function_calls_may_not_accept_type_arguments";
        DiagnosticCode[DiagnosticCode["Non_generic_functions_may_not_accept_type_arguments"] = 224] = "Non_generic_functions_may_not_accept_type_arguments";
        DiagnosticCode[DiagnosticCode["A_generic_type_may_not_reference_itself_with_its_own_type_parameters"] = 225] = "A_generic_type_may_not_reference_itself_with_its_own_type_parameters";
        DiagnosticCode[DiagnosticCode["Static_methods_cannot_reference_class_type_parameters"] = 226] = "Static_methods_cannot_reference_class_type_parameters";
        DiagnosticCode[DiagnosticCode["Value_of_type__0__is_not_callable__Did_you_mean_to_include__new___"] = 227] = "Value_of_type__0__is_not_callable__Did_you_mean_to_include__new___";
        DiagnosticCode[DiagnosticCode["Rest_parameters_must_be_array_types"] = 228] = "Rest_parameters_must_be_array_types";
        DiagnosticCode[DiagnosticCode["Overload_signature_implementation_cannot_use_specialized_type"] = 229] = "Overload_signature_implementation_cannot_use_specialized_type";
        DiagnosticCode[DiagnosticCode["Export_assignments_may_only_be_used_in_External_modules"] = 230] = "Export_assignments_may_only_be_used_in_External_modules";
        DiagnosticCode[DiagnosticCode["Export_assignments_may_only_be_made_with_acceptable_kinds"] = 231] = "Export_assignments_may_only_be_made_with_acceptable_kinds";
        DiagnosticCode[DiagnosticCode["Only_public_instance_methods_of_the_base_class_are_accessible_via_the_super_keyword"] = 232] = "Only_public_instance_methods_of_the_base_class_are_accessible_via_the_super_keyword";
        DiagnosticCode[DiagnosticCode["Numeric_indexer_type___0___must_be_a_subtype_of_string_indexer_type___1__"] = 233] = "Numeric_indexer_type___0___must_be_a_subtype_of_string_indexer_type___1__";
        DiagnosticCode[DiagnosticCode["Numeric_indexer_type___0___must_be_a_subtype_of_string_indexer_type___1____NL__2"] = 234] = "Numeric_indexer_type___0___must_be_a_subtype_of_string_indexer_type___1____NL__2";
        DiagnosticCode[DiagnosticCode["All_numerically_named_properties_must_be_subtypes_of_numeric_indexer_type___0__"] = 235] = "All_numerically_named_properties_must_be_subtypes_of_numeric_indexer_type___0__";
        DiagnosticCode[DiagnosticCode["All_numerically_named_properties_must_be_subtypes_of_numeric_indexer_type___0____NL__1"] = 236] = "All_numerically_named_properties_must_be_subtypes_of_numeric_indexer_type___0____NL__1";
        DiagnosticCode[DiagnosticCode["All_named_properties_must_be_subtypes_of_string_indexer_type___0__"] = 237] = "All_named_properties_must_be_subtypes_of_string_indexer_type___0__";
        DiagnosticCode[DiagnosticCode["All_named_properties_must_be_subtypes_of_string_indexer_type___0____NL__1"] = 238] = "All_named_properties_must_be_subtypes_of_string_indexer_type___0____NL__1";
        DiagnosticCode[DiagnosticCode["Generic_type_references_must_include_all_type_arguments"] = 239] = "Generic_type_references_must_include_all_type_arguments";

        DiagnosticCode[DiagnosticCode["Type__0__is_missing_property__1__from_type__2_"] = 240] = "Type__0__is_missing_property__1__from_type__2_";
        DiagnosticCode[DiagnosticCode["Types_of_property__0__of_types__1__and__2__are_incompatible"] = 241] = "Types_of_property__0__of_types__1__and__2__are_incompatible";
        DiagnosticCode[DiagnosticCode["Types_of_property__0__of_types__1__and__2__are_incompatible__NL__3"] = 242] = "Types_of_property__0__of_types__1__and__2__are_incompatible__NL__3";
        DiagnosticCode[DiagnosticCode["Property__0__defined_as_private_in_type__1__is_defined_as_public_in_type__2_"] = 243] = "Property__0__defined_as_private_in_type__1__is_defined_as_public_in_type__2_";
        DiagnosticCode[DiagnosticCode["Property__0__defined_as_public_in_type__1__is_defined_as_private_in_type__2_"] = 244] = "Property__0__defined_as_public_in_type__1__is_defined_as_private_in_type__2_";
        DiagnosticCode[DiagnosticCode["Types__0__and__1__define_property__2__as_private"] = 245] = "Types__0__and__1__define_property__2__as_private";
        DiagnosticCode[DiagnosticCode["Call_signatures_of_types__0__and__1__are_incompatible"] = 246] = "Call_signatures_of_types__0__and__1__are_incompatible";
        DiagnosticCode[DiagnosticCode["Call_signatures_of_types__0__and__1__are_incompatible__NL__2"] = 247] = "Call_signatures_of_types__0__and__1__are_incompatible__NL__2";
        DiagnosticCode[DiagnosticCode["Type__0__requires_a_call_signature__but_Type__1__lacks_one"] = 248] = "Type__0__requires_a_call_signature__but_Type__1__lacks_one";
        DiagnosticCode[DiagnosticCode["Construct_signatures_of_types__0__and__1__are_incompatible"] = 249] = "Construct_signatures_of_types__0__and__1__are_incompatible";
        DiagnosticCode[DiagnosticCode["Construct_signatures_of_types__0__and__1__are_incompatible__NL__2"] = 250] = "Construct_signatures_of_types__0__and__1__are_incompatible__NL__2";
        DiagnosticCode[DiagnosticCode["Type__0__requires_a_construct_signature__but_Type__1__lacks_one"] = 251] = "Type__0__requires_a_construct_signature__but_Type__1__lacks_one";
        DiagnosticCode[DiagnosticCode["Index_signatures_of_types__0__and__1__are_incompatible"] = 252] = "Index_signatures_of_types__0__and__1__are_incompatible";
        DiagnosticCode[DiagnosticCode["Index_signatures_of_types__0__and__1__are_incompatible__NL__2"] = 253] = "Index_signatures_of_types__0__and__1__are_incompatible__NL__2";
        DiagnosticCode[DiagnosticCode["Call_signature_expects__0__or_fewer_parameters"] = 254] = "Call_signature_expects__0__or_fewer_parameters";
        DiagnosticCode[DiagnosticCode["Could_not_apply_type__0__to_argument__1__which_is_of_type__2_"] = 255] = "Could_not_apply_type__0__to_argument__1__which_is_of_type__2_";
        DiagnosticCode[DiagnosticCode["Class__0__defines_instance_member_accessor__1___but_extended_class__2__defines_it_as_instance_member_function"] = 256] = "Class__0__defines_instance_member_accessor__1___but_extended_class__2__defines_it_as_instance_member_function";
        DiagnosticCode[DiagnosticCode["Class__0__defines_instance_member_property__1___but_extended_class__2__defines_it_as_instance_member_function"] = 257] = "Class__0__defines_instance_member_property__1___but_extended_class__2__defines_it_as_instance_member_function";
        DiagnosticCode[DiagnosticCode["Class__0__defines_instance_member_function__1___but_extended_class__2__defines_it_as_instance_member_accessor"] = 258] = "Class__0__defines_instance_member_function__1___but_extended_class__2__defines_it_as_instance_member_accessor";
        DiagnosticCode[DiagnosticCode["Class__0__defines_instance_member_function__1___but_extended_class__2__defines_it_as_instance_member_property"] = 259] = "Class__0__defines_instance_member_function__1___but_extended_class__2__defines_it_as_instance_member_property";
        DiagnosticCode[DiagnosticCode["Types_of_static_property__0__of_class__1__and_class__2__are_incompatible"] = 260] = "Types_of_static_property__0__of_class__1__and_class__2__are_incompatible";
        DiagnosticCode[DiagnosticCode["Types_of_static_property__0__of_class__1__and_class__2__are_incompatible__NL__3"] = 261] = "Types_of_static_property__0__of_class__1__and_class__2__are_incompatible__NL__3";
        DiagnosticCode[DiagnosticCode["Type_reference_cannot_refer_to_container__0_"] = 262] = "Type_reference_cannot_refer_to_container__0_";
        DiagnosticCode[DiagnosticCode["Type_reference_must_refer_to_type"] = 263] = "Type_reference_must_refer_to_type";
        DiagnosticCode[DiagnosticCode["Enums_with_multiple_declarations_must_provide_an_initializer_for_the_first_enum_element"] = 264] = "Enums_with_multiple_declarations_must_provide_an_initializer_for_the_first_enum_element";

        DiagnosticCode[DiagnosticCode["Current_host_does_not_support__w_atch_option"] = 265] = "Current_host_does_not_support__w_atch_option";
        DiagnosticCode[DiagnosticCode["ECMAScript_target_version__0__not_supported___Using_default__1__code_generation"] = 266] = "ECMAScript_target_version__0__not_supported___Using_default__1__code_generation";
        DiagnosticCode[DiagnosticCode["Module_code_generation__0__not_supported___Using_default__1__code_generation"] = 267] = "Module_code_generation__0__not_supported___Using_default__1__code_generation";
        DiagnosticCode[DiagnosticCode["Could_not_find_file___0_"] = 268] = "Could_not_find_file___0_";
        DiagnosticCode[DiagnosticCode["Unknown_extension_for_file___0__Only__ts_and_d_ts_extensions_are_allowed"] = 269] = "Unknown_extension_for_file___0__Only__ts_and_d_ts_extensions_are_allowed";
        DiagnosticCode[DiagnosticCode["A_file_cannot_have_a_reference_itself"] = 270] = "A_file_cannot_have_a_reference_itself";
        DiagnosticCode[DiagnosticCode["Cannot_resolve_referenced_file___0_"] = 271] = "Cannot_resolve_referenced_file___0_";
        DiagnosticCode[DiagnosticCode["Cannot_resolve_imported_file___0_"] = 272] = "Cannot_resolve_imported_file___0_";
        DiagnosticCode[DiagnosticCode["Cannot_find_the_common_subdirectory_path_for_the_input_files"] = 273] = "Cannot_find_the_common_subdirectory_path_for_the_input_files";
        DiagnosticCode[DiagnosticCode["Cannot_compile_dynamic_modules_when_emitting_into_single_file"] = 274] = "Cannot_compile_dynamic_modules_when_emitting_into_single_file";
        DiagnosticCode[DiagnosticCode["Emit_Error__0"] = 275] = "Emit_Error__0";
    })(TypeScript.DiagnosticCode || (TypeScript.DiagnosticCode = {}));
    var DiagnosticCode = TypeScript.DiagnosticCode;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.diagnosticMessages = {
        error_TS_0__1: {
            category: 3 /* NoPrefix */,
            message: "error TS{0}: {1}",
            code: 0
        },
        warning_TS_0__1: {
            category: 3 /* NoPrefix */,
            message: "warning TS{0}: {1}",
            code: 1
        },
        _0__NL__1_TB__2: {
            category: 3 /* NoPrefix */,
            message: "{0}{NL}{{1}TB}{2}",
            code: 21
        },
        _0_TB__1: {
            category: 3 /* NoPrefix */,
            message: "{{0}TB}{1}",
            code: 22
        },
        Unrecognized_escape_sequence: {
            category: 1 /* Error */,
            message: "Unrecognized escape sequence.",
            code: 1000
        },
        Unexpected_character_0: {
            category: 1 /* Error */,
            message: "Unexpected character {0}.",
            code: 1001
        },
        Missing_closing_quote_character: {
            category: 1 /* Error */,
            message: "Missing close quote character.",
            code: 1002
        },
        Identifier_expected: {
            category: 1 /* Error */,
            message: "Identifier expected.",
            code: 1003
        },
        _0_keyword_expected: {
            category: 1 /* Error */,
            message: "'{0}' keyword expected.",
            code: 1004
        },
        _0_expected: {
            category: 1 /* Error */,
            message: "'{0}' expected.",
            code: 1005
        },
        Identifier_expected__0__is_a_keyword: {
            category: 1 /* Error */,
            message: "Identifier expected; '{0}' is a keyword.",
            code: 1006
        },
        Automatic_semicolon_insertion_not_allowed: {
            category: 1 /* Error */,
            message: "Automatic semicolon insertion not allowed.",
            code: 1007
        },
        Unexpected_token__0_expected: {
            category: 1 /* Error */,
            message: "Unexpected token; '{0}' expected.",
            code: 1008
        },
        Trailing_separator_not_allowed: {
            category: 1 /* Error */,
            message: "Trailing separator not allowed.",
            code: 1009
        },
        _StarSlash__expected: {
            category: 1 /* Error */,
            message: "'*/' expected.",
            code: 1010
        },
        _public_or_private_modifier_must_precede__static_: {
            category: 1 /* Error */,
            message: "'public' or 'private' modifier must precede 'static'.",
            code: 1011
        },
        Unexpected_token_: {
            category: 1 /* Error */,
            message: "Unexpected token.",
            code: 1012
        },
        A_catch_clause_variable_cannot_have_a_type_annotation: {
            category: 1 /* Error */,
            message: "A catch clause variable cannot have a type annotation.",
            code: 1013
        },
        Rest_parameter_must_be_last_in_list: {
            category: 1 /* Error */,
            message: "Rest parameter must be last in list.",
            code: 1014
        },
        Parameter_cannot_have_question_mark_and_initializer: {
            category: 1 /* Error */,
            message: "Parameter cannot have question mark and initializer.",
            code: 1015
        },
        Required_parameter_cannot_follow_optional_parameter: {
            category: 1 /* Error */,
            message: "Required parameter cannot follow optional parameter.",
            code: 1016
        },
        Index_signatures_cannot_have_rest_parameters: {
            category: 1 /* Error */,
            message: "Index signatures cannot have rest parameters.",
            code: 1017
        },
        Index_signature_parameter_cannot_have_accessibility_modifiers: {
            category: 1 /* Error */,
            message: "Index signature parameter cannot have accessibility modifiers.",
            code: 1018
        },
        Index_signature_parameter_cannot_have_a_question_mark: {
            category: 1 /* Error */,
            message: "Index signature parameter cannot have a question mark.",
            code: 1019
        },
        Index_signature_parameter_cannot_have_an_initializer: {
            category: 1 /* Error */,
            message: "Index signature parameter cannot have an initializer.",
            code: 1020
        },
        Index_signature_must_have_a_type_annotation: {
            category: 1 /* Error */,
            message: "Index signature must have a type annotation.",
            code: 1021
        },
        Index_signature_parameter_must_have_a_type_annotation: {
            category: 1 /* Error */,
            message: "Index signature parameter must have a type annotation.",
            code: 1022
        },
        Index_signature_parameter_type_must_be__string__or__number_: {
            category: 1 /* Error */,
            message: "Index signature parameter type must be 'string' or 'number'.",
            code: 1023
        },
        _extends__clause_already_seen: {
            category: 1 /* Error */,
            message: "'extends' clause already seen.",
            code: 1024
        },
        _extends__clause_must_precede__implements__clause: {
            category: 1 /* Error */,
            message: "'extends' clause must precede 'implements' clause.",
            code: 1025
        },
        Class_can_only_extend_single_type: {
            category: 1 /* Error */,
            message: "Class can only extend single type.",
            code: 1026
        },
        _implements__clause_already_seen: {
            category: 1 /* Error */,
            message: "'implements' clause already seen.",
            code: 1027
        },
        Accessibility_modifier_already_seen: {
            category: 1 /* Error */,
            message: "Accessibility modifier already seen.",
            code: 1028
        },
        _0__modifier_must_precede__1__modifier: {
            category: 1 /* Error */,
            message: "'{0}' modifier must precede '{1}' modifier.",
            code: 1029
        },
        _0__modifier_already_seen: {
            category: 1 /* Error */,
            message: "'{0}' modifier already seen.",
            code: 1030
        },
        _0__modifier_cannot_appear_on_a_class_element: {
            category: 1 /* Error */,
            message: "'{0}' modifier cannot appear on a class element.",
            code: 1031
        },
        Interface_declaration_cannot_have__implements__clause: {
            category: 1 /* Error */,
            message: "Interface declaration cannot have 'implements' clause.",
            code: 1032
        },
        _super__invocation_cannot_have_type_arguments: {
            category: 1 /* Error */,
            message: "'super' invocation cannot have type arguments.",
            code: 1034
        },
        Non_ambient_modules_cannot_use_quoted_names: {
            category: 1 /* Error */,
            message: "Non ambient modules cannot use quoted names.",
            code: 1035
        },
        Statements_are_not_allowed_in_ambient_contexts: {
            category: 1 /* Error */,
            message: "Statements are not allowed in ambient contexts.",
            code: 1036
        },
        Implementations_are_not_allowed_in_ambient_contexts: {
            category: 1 /* Error */,
            message: "Implementations are not allowed in ambient contexts.",
            code: 1037
        },
        _declare__modifier_not_allowed_for_code_already_in_an_ambient_context: {
            category: 1 /* Error */,
            message: "'declare' modifier not allowed for code already in an ambient context.",
            code: 1038
        },
        Initializers_are_not_allowed_in_ambient_contexts: {
            category: 1 /* Error */,
            message: "Initializers are not allowed in ambient contexts.",
            code: 1039
        },
        Overload_and_ambient_signatures_cannot_specify_parameter_properties: {
            category: 1 /* Error */,
            message: "Overload and ambient signatures cannot specify parameter properties.",
            code: 1040
        },
        Function_implementation_expected: {
            category: 1 /* Error */,
            message: "Function implementation expected.",
            code: 1041
        },
        Constructor_implementation_expected: {
            category: 1 /* Error */,
            message: "Constructor implementation expected.",
            code: 1042
        },
        Function_overload_name_must_be__0_: {
            category: 1 /* Error */,
            message: "Function overload name must be '{0}'.",
            code: 1043
        },
        _0__modifier_cannot_appear_on_a_module_element: {
            category: 1 /* Error */,
            message: "'{0}' modifier cannot appear on a module element.",
            code: 1044
        },
        _declare__modifier_cannot_appear_on_an_interface_declaration: {
            category: 1 /* Error */,
            message: "'declare' modifier cannot appear on an interface declaration.",
            code: 1045
        },
        _declare__modifier_required_for_top_level_element: {
            category: 1 /* Error */,
            message: "'declare' modifier required for top level element.",
            code: 1046
        },
        Rest_parameter_cannot_be_optional: {
            category: 1 /* Error */,
            message: "Rest parameter cannot be optional.",
            code: 1047
        },
        Rest_parameter_cannot_have_initializer: {
            category: 1 /* Error */,
            message: "Rest parameter cannot have initializer.",
            code: 1048
        },
        _set__accessor_must_have_only_one_parameter: {
            category: 1 /* Error */,
            message: "'set' accessor must have one and only one parameter.",
            code: 1049
        },
        _set__accessor_parameter_cannot_have_accessibility_modifier: {
            category: 1 /* Error */,
            message: "'set' accessor parameter cannot have accessibility modifier.",
            code: 1050
        },
        _set__accessor_parameter_cannot_be_optional: {
            category: 1 /* Error */,
            message: "'set' accessor parameter cannot be optional.",
            code: 1051
        },
        _set__accessor_parameter_cannot_have_initializer: {
            category: 1 /* Error */,
            message: "'set' accessor parameter cannot have initializer.",
            code: 1052
        },
        _set__accessor_cannot_have_rest_parameter: {
            category: 1 /* Error */,
            message: "'set' accessor cannot have rest parameter.",
            code: 1053
        },
        _get__accessor_cannot_have_parameters: {
            category: 1 /* Error */,
            message: "'get' accessor cannot have parameters.",
            code: 1054
        },
        Modifiers_cannot_appear_here: {
            category: 1 /* Error */,
            message: "Modifiers cannot appear here.",
            code: 1055
        },
        Accessors_are_only_available_when_targeting_EcmaScript5_and_higher: {
            category: 1 /* Error */,
            message: "Accessors are only when targeting EcmaScript5 and higher.",
            code: 1056
        },
        Class_name_cannot_be__0_: {
            category: 1 /* Error */,
            message: "Class name cannot be '{0}'.",
            code: 1057
        },
        Interface_name_cannot_be__0_: {
            category: 1 /* Error */,
            message: "Interface name cannot be '{0}'.",
            code: 1058
        },
        Enum_name_cannot_be__0_: {
            category: 1 /* Error */,
            message: "Enum name cannot be '{0}'.",
            code: 1059
        },
        Module_name_cannot_be__0_: {
            category: 1 /* Error */,
            message: "Module name cannot be '{0}'.",
            code: 1060
        },
        Enum_member_must_have_initializer: {
            category: 1 /* Error */,
            message: "Enum member must have initializer.",
            code: 1061
        },
        _module_______is_deprecated__Use__require_______instead: {
            category: 0 /* Warning */,
            message: "'module(...)' is deprecated. Use 'require(...)' instead.",
            code: 1062
        },
        Export_assignments_cannot_be_used_in_internal_modules: {
            category: 1 /* Error */,
            message: "Export assignments cannot be used in internal modules.",
            code: 1063
        },
        Export_assignment_not_allowed_in_module_with_exported_element: {
            category: 1 /* Error */,
            message: "Export assignment not allowed in module with exported element.",
            code: 1064
        },
        Module_cannot_have_multiple_export_assignments: {
            category: 1 /* Error */,
            message: "Module cannot have multiple export assignments.",
            code: 1065
        },
        Duplicate_identifier__0_: {
            category: 1 /* Error */,
            message: "Duplicate identifier '{0}'.",
            code: 2000
        },
        The_name__0__does_not_exist_in_the_current_scope: {
            category: 1 /* Error */,
            message: "The name '{0}' does not exist in the current scope.",
            code: 2001
        },
        The_name__0__does_not_refer_to_a_value: {
            category: 1 /* Error */,
            message: "The name '{0}' does not refer to a value.",
            code: 2002
        },
        Keyword__super__can_only_be_used_inside_a_class_instance_method: {
            category: 1 /* Error */,
            message: "Keyword 'super' can only be used inside a class instance method.",
            code: 2003
        },
        The_left_hand_side_of_an_assignment_expression_must_be_a_variable__property_or_indexer: {
            category: 1 /* Error */,
            message: "The left-hand side of an assignment expression must be a variable, property or indexer.",
            code: 2004
        },
        Value_of_type__0__is_not_callable__Did_you_mean_to_include__new__: {
            category: 1 /* Error */,
            message: "Value of type '{0}' is not callable. Did you mean to include 'new'?",
            code: 2005
        },
        Value_of_type__0__is_not_callable: {
            category: 1 /* Error */,
            message: "Value of type '{0}' is not callable.",
            code: 2006
        },
        Value_of_type__0__is_not_newable: {
            category: 1 /* Error */,
            message: "Value of type '{0}' is not newable.",
            code: 2007
        },
        Value_of_type__0__is_not_indexable_by_type__1_: {
            category: 1 /* Error */,
            message: "Value of type '{0}' is not indexable by type '{1}'.",
            code: 2008
        },
        Operator__0__cannot_be_applied_to_types__1__and__2_: {
            category: 1 /* Error */,
            message: "Operator '{0}' cannot be applied to types '{1}' and '{2}'.",
            code: 2009
        },
        Operator__0__cannot_be_applied_to_types__1__and__2__3: {
            category: 1 /* Error */,
            message: "Operator '{0}' cannot be applied to types '{1}' and '{2}': {3}",
            code: 2010
        },
        Cannot_convert__0__to__1_: {
            category: 1 /* Error */,
            message: "Cannot convert '{0}' to '{1}'.",
            code: 2011
        },
        Cannot_convert__0__to__1__NL__2: {
            category: 1 /* Error */,
            message: "Cannot convert '{0}' to '{1}':{NL}{2}",
            code: 2012
        },
        Expected_var__class__interface__or_module: {
            category: 1 /* Error */,
            message: "Expected var, class, interface, or module.",
            code: 2013
        },
        Operator__0__cannot_be_applied_to_type__1_: {
            category: 1 /* Error */,
            message: "Operator '{0}' cannot be applied to type '{1}'.",
            code: 2014
        },
        Getter__0__already_declared: {
            category: 1 /* Error */,
            message: "Getter '{0}' already declared.",
            code: 2015
        },
        Setter__0__already_declared: {
            category: 1 /* Error */,
            message: "Setter '{0}' already declared.",
            code: 2016
        },
        Accessor_cannot_have_type_parameters: {
            category: 1 /* Error */,
            message: "Accessors cannot have type parameters.",
            code: 2017
        },
        Exported_class__0__extends_private_class__1_: {
            category: 1 /* Error */,
            message: "Exported class '{0}' extends private class '{1}'.",
            code: 2018
        },
        Exported_class__0__implements_private_interface__1_: {
            category: 1 /* Error */,
            message: "Exported class '{0}' implements private interface '{1}'.",
            code: 2019
        },
        Exported_interface__0__extends_private_interface__1_: {
            category: 1 /* Error */,
            message: "Exported interface '{0}' extends private interface '{1}'.",
            code: 2020
        },
        Exported_class__0__extends_class_from_inaccessible_module__1_: {
            category: 1 /* Error */,
            message: "Exported class '{0}' extends class from inaccessible module {1}.",
            code: 2021
        },
        Exported_class__0__implements_interface_from_inaccessible_module__1_: {
            category: 1 /* Error */,
            message: "Exported class '{0}' implements interface from inaccessible module {1}.",
            code: 2022
        },
        Exported_interface__0__extends_interface_from_inaccessible_module__1_: {
            category: 1 /* Error */,
            message: "Exported interface '{0}' extends interface from inaccessible module {1}.",
            code: 2023
        },
        Public_static_property__0__of__exported_class_has_or_is_using_private_type__1_: {
            category: 1 /* Error */,
            message: "Public static property '{0}' of exported class has or is using private type '{1}'.",
            code: 2024
        },
        Public_property__0__of__exported_class_has_or_is_using_private_type__1_: {
            category: 1 /* Error */,
            message: "Public property '{0}' of exported class has or is using private type '{1}'.",
            code: 2025
        },
        Property__0__of__exported_interface_has_or_is_using_private_type__1_: {
            category: 1 /* Error */,
            message: "Property '{0}' of exported interface has or is using private type '{1}'.",
            code: 2026
        },
        Exported_variable__0__has_or_is_using_private_type__1_: {
            category: 1 /* Error */,
            message: "Exported variable '{0}' has or is using private type '{1}'.",
            code: 2027
        },
        Public_static_property__0__of__exported_class_is_using_inaccessible_module__1_: {
            category: 1 /* Error */,
            message: "Public static property '{0}' of exported class is using inaccessible module {1}.",
            code: 2028
        },
        Public_property__0__of__exported_class_is_using_inaccessible_module__1_: {
            category: 1 /* Error */,
            message: "Public property '{0}' of exported class is using inaccessible module {1}.",
            code: 2029
        },
        Property__0__of__exported_interface_is_using_inaccessible_module__1_: {
            category: 1 /* Error */,
            message: "Property '{0}' of exported interface is using inaccessible module {1}.",
            code: 2030
        },
        Exported_variable__0__is_using_inaccessible_module__1_: {
            category: 1 /* Error */,
            message: "Exported variable '{0}' is using inaccessible module {1}.",
            code: 2031
        },
        Parameter__0__of_constructor_from_exported_class_has_or_is_using_private_type__1_: {
            category: 1 /* Error */,
            message: "Parameter '{0}' of constructor from exported class has or is using private type '{1}'.",
            code: 2032
        },
        Parameter__0__of_public_static_property_setter_from_exported_class_has_or_is_using_private_type__1_: {
            category: 1 /* Error */,
            message: "Parameter '{0}' of public static property setter from exported class has or is using private type '{1}'.",
            code: 2033
        },
        Parameter__0__of_public_property_setter_from_exported_class_has_or_is_using_private_type__1_: {
            category: 1 /* Error */,
            message: "Parameter '{0}' of public property setter from exported class has or is using private type '{1}'.",
            code: 2034
        },
        Parameter__0__of_constructor_signature_from_exported_interface_has_or_is_using_private_type__1_: {
            category: 1 /* Error */,
            message: "Parameter '{0}' of constructor signature from exported interface has or is using private type '{1}'.",
            code: 2035
        },
        Parameter__0__of_call_signature_from_exported_interface_has_or_is_using_private_type__1_: {
            category: 1 /* Error */,
            message: "Parameter '{0}' of call signature from exported interface has or is using private type '{1}'.",
            code: 2036
        },
        Parameter__0__of_public_static_method_from_exported_class_has_or_is_using_private_type__1_: {
            category: 1 /* Error */,
            message: "Parameter '{0}' of public static method from exported class has or is using private type '{1}'.",
            code: 2037
        },
        Parameter__0__of_public_method_from_exported_class_has_or_is_using_private_type__1_: {
            category: 1 /* Error */,
            message: "Parameter '{0}' of public method from exported class has or is using private type '{1}'.",
            code: 2038
        },
        Parameter__0__of_method_from_exported_interface_has_or_is_using_private_type__1_: {
            category: 1 /* Error */,
            message: "Parameter '{0}' of method from exported interface has or is using private type '{1}'.",
            code: 2039
        },
        Parameter__0__of_exported_function_has_or_is_using_private_type__1_: {
            category: 1 /* Error */,
            message: "Parameter '{0}' of exported function has or is using private type '{1}'.",
            code: 2040
        },
        Parameter__0__of_constructor_from_exported_class_is_using_inaccessible_module__1_: {
            category: 1 /* Error */,
            message: "Parameter '{0}' of constructor from exported class is using inaccessible module {1}.",
            code: 2041
        },
        Parameter__0__of_public_static_property_setter_from_exported_class_is_using_inaccessible_module__1_: {
            category: 1 /* Error */,
            message: "Parameter '{0}' of public static property setter from exported class is using inaccessible module {1}.",
            code: 2042
        },
        Parameter__0__of_public_property_setter_from_exported_class_is_using_inaccessible_module__1_: {
            category: 1 /* Error */,
            message: "Parameter '{0}' of public property setter from exported class is using inaccessible module {1}.",
            code: 2043
        },
        Parameter__0__of_constructor_signature_from_exported_interface_is_using_inaccessible_module__1_: {
            category: 1 /* Error */,
            message: "Parameter '{0}' of constructor signature from exported interface is using inaccessible module {1}.",
            code: 2044
        },
        Parameter__0__of_call_signature_from_exported_interface_is_using_inaccessible_module__1_: {
            category: 1 /* Error */,
            message: "Parameter '{0}' of call signature from exported interface is using inaccessible module {1}",
            code: 2045
        },
        Parameter__0__of_public_static_method_from_exported_class_is_using_inaccessible_module__1_: {
            category: 1 /* Error */,
            message: "Parameter '{0}' of public static method from exported class is using inaccessible module {1}.",
            code: 2046
        },
        Parameter__0__of_public_method_from_exported_class_is_using_inaccessible_module__1_: {
            category: 1 /* Error */,
            message: "Parameter '{0}' of public method from exported class is using inaccessible module {1}.",
            code: 2047
        },
        Parameter__0__of_method_from_exported_interface_is_using_inaccessible_module__1_: {
            category: 1 /* Error */,
            message: "Parameter '{0}' of method from exported interface is using inaccessible module {1}.",
            code: 2048
        },
        Parameter__0__of_exported_function_is_using_inaccessible_module__1_: {
            category: 1 /* Error */,
            message: "Parameter '{0}' of exported function is using inaccessible module {1}.",
            code: 2049
        },
        Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_private_type__0_: {
            category: 1 /* Error */,
            message: "Return type of public static property getter from exported class has or is using private type '{0}'.",
            code: 2050
        },
        Return_type_of_public_property_getter_from_exported_class_has_or_is_using_private_type__0_: {
            category: 1 /* Error */,
            message: "Return type of public property getter from exported class has or is using private type '{0}'.",
            code: 2051
        },
        Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_type__0_: {
            category: 1 /* Error */,
            message: "Return type of constructor signature from exported interface has or is using private type '{0}'.",
            code: 2052
        },
        Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_type__0_: {
            category: 1 /* Error */,
            message: "Return type of call signature from exported interface has or is using private type '{0}'.",
            code: 2053
        },
        Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_type__0_: {
            category: 1 /* Error */,
            message: "Return type of index signature from exported interface has or is using private type '{0}'.",
            code: 2054
        },
        Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_type__0_: {
            category: 1 /* Error */,
            message: "Return type of public static method from exported class has or is using private type '{0}'.",
            code: 2055
        },
        Return_type_of_public_method_from_exported_class_has_or_is_using_private_type__0_: {
            category: 1 /* Error */,
            message: "Return type of public method from exported class has or is using private type '{0}'.",
            code: 2056
        },
        Return_type_of_method_from_exported_interface_has_or_is_using_private_type__0_: {
            category: 1 /* Error */,
            message: "Return type of method from exported interface has or is using private type '{0}'.",
            code: 2057
        },
        Return_type_of_exported_function_has_or_is_using_private_type__0_: {
            category: 1 /* Error */,
            message: "Return type of exported function has or is using private type '{0}'.",
            code: 2058
        },
        Return_type_of_public_static_property_getter_from_exported_class_is_using_inaccessible_module__0_: {
            category: 1 /* Error */,
            message: "Return type of public static property getter from exported class is using inaccessible module {0}.",
            code: 2059
        },
        Return_type_of_public_property_getter_from_exported_class_is_using_inaccessible_module__0_: {
            category: 1 /* Error */,
            message: "Return type of public property getter from exported class is using inaccessible module {0}.",
            code: 2060
        },
        Return_type_of_constructor_signature_from_exported_interface_is_using_inaccessible_module__0_: {
            category: 1 /* Error */,
            message: "Return type of constructor signature from exported interface is using inaccessible module {0}.",
            code: 2061
        },
        Return_type_of_call_signature_from_exported_interface_is_using_inaccessible_module__0_: {
            category: 1 /* Error */,
            message: "Return type of call signature from exported interface is using inaccessible module {0}.",
            code: 2062
        },
        Return_type_of_index_signature_from_exported_interface_is_using_inaccessible_module__0_: {
            category: 1 /* Error */,
            message: "Return type of index signature from exported interface is using inaccessible module {0}.",
            code: 2063
        },
        Return_type_of_public_static_method_from_exported_class_is_using_inaccessible_module__0_: {
            category: 1 /* Error */,
            message: "Return type of public static method from exported class is using inaccessible module {0}.",
            code: 2064
        },
        Return_type_of_public_method_from_exported_class_is_using_inaccessible_module__0_: {
            category: 1 /* Error */,
            message: "Return type of public method from exported class is using inaccessible module {0}.",
            code: 2065
        },
        Return_type_of_method_from_exported_interface_is_using_inaccessible_module__0_: {
            category: 1 /* Error */,
            message: "Return type of method from exported interface is using inaccessible module {0}.",
            code: 2066
        },
        Return_type_of_exported_function_is_using_inaccessible_module__0_: {
            category: 1 /* Error */,
            message: "Return type of exported function is using inaccessible module {0}.",
            code: 2067
        },
        _new_T____cannot_be_used_to_create_an_array__Use__new_Array_T_____instead: {
            category: 1 /* Error */,
            message: "'new T[]' cannot be used to create an array. Use 'new Array<T>()' instead.",
            code: 2068
        },
        A_parameter_list_must_follow_a_generic_type_argument_list______expected: {
            category: 1 /* Error */,
            message: "A parameter list must follow a generic type argument list. '(' expected.",
            code: 2069
        },
        Multiple_constructor_implementations_are_not_allowed: {
            category: 1 /* Error */,
            message: "Multiple constructor implementations are not allowed.",
            code: 2070
        },
        Unable_to_resolve_external_module__0_: {
            category: 1 /* Error */,
            message: "Unable to resolve external module '{0}'.",
            code: 2071
        },
        Module_cannot_be_aliased_to_a_non_module_type: {
            category: 1 /* Error */,
            message: "Module cannot be aliased to a non-module type.",
            code: 2072
        },
        A_class_may_only_extend_another_class: {
            category: 1 /* Error */,
            message: "A class may only extend another class.",
            code: 2073
        },
        A_class_may_only_implement_another_class_or_interface: {
            category: 1 /* Error */,
            message: "A class may only implement another class or interface.",
            code: 2074
        },
        An_interface_may_only_extend_another_class_or_interface: {
            category: 1 /* Error */,
            message: "An interface may only extend another class or interface.",
            code: 2075
        },
        An_interface_cannot_implement_another_type: {
            category: 1 /* Error */,
            message: "An interface cannot implement another type.",
            code: 2076
        },
        Unable_to_resolve_type: {
            category: 1 /* Error */,
            message: "Unable to resolve type.",
            code: 2077
        },
        Unable_to_resolve_type_of__0_: {
            category: 1 /* Error */,
            message: "Unable to resolve type of '{0}'.",
            code: 2078
        },
        Unable_to_resolve_type_parameter_constraint: {
            category: 1 /* Error */,
            message: "Unable to resolve type parameter constraint.",
            code: 2079
        },
        Type_parameter_constraint_cannot_be_a_primitive_type: {
            category: 1 /* Error */,
            message: "Type parameter constraint cannot be a primitive type.",
            code: 2080
        },
        Supplied_parameters_do_not_match_any_signature_of_call_target: {
            category: 1 /* Error */,
            message: "Supplied parameters do not match any signature of call target.",
            code: 2081
        },
        Supplied_parameters_do_not_match_any_signature_of_call_target__NL__0: {
            category: 1 /* Error */,
            message: "Supplied parameters do not match any signature of call target:{NL}{0}",
            code: 2082
        },
        Invalid__new__expression: {
            category: 1 /* Error */,
            message: "Invalid 'new' expression.",
            code: 2083
        },
        Call_signatures_used_in_a__new__expression_must_have_a__void__return_type: {
            category: 1 /* Error */,
            message: "Call signatures used in a 'new' expression must have a 'void' return type.",
            code: 2084
        },
        Could_not_select_overload_for__new__expression: {
            category: 1 /* Error */,
            message: "Could not select overload for 'new' expression.",
            code: 2085
        },
        Type__0__does_not_satisfy_the_constraint__1__for_type_parameter__2_: {
            category: 1 /* Error */,
            message: "Type '{0}' does not satisfy the constraint '{1}' for type parameter '{2}'.",
            code: 2086
        },
        Could_not_select_overload_for__call__expression: {
            category: 1 /* Error */,
            message: "Could not select overload for 'call' expression.",
            code: 2087
        },
        Unable_to_invoke_type_with_no_call_signatures: {
            category: 1 /* Error */,
            message: "Unable to invoke type with no call signatures.",
            code: 2088
        },
        Calls_to__super__are_only_valid_inside_a_class: {
            category: 1 /* Error */,
            message: "Calls to 'super' are only valid inside a class.",
            code: 2089
        },
        Generic_type__0__requires_1_type_argument_s_: {
            category: 1 /* Error */,
            message: "Generic type '{0}' requires {1} type argument(s).",
            code: 2090
        },
        Type_of_conditional_expression_cannot_be_determined__Best_common_type_could_not_be_found_between__0__and__1_: {
            category: 1 /* Error */,
            message: "Type of conditional expression cannot be determined. Best common type could not be found between '{0}' and '{1}'.",
            code: 2091
        },
        Type_of_array_literal_cannot_be_determined__Best_common_type_could_not_be_found_for_array_elements: {
            category: 1 /* Error */,
            message: "Type of array literal cannot be determined. Best common type could not be found for array elements.",
            code: 2092
        },
        Could_not_find_enclosing_symbol_for_dotted_name__0_: {
            category: 1 /* Error */,
            message: "Could not find enclosing symbol for dotted name '{0}'.",
            code: 2093
        },
        The_property__0__does_not_exist_on_value_of_type__1__: {
            category: 1 /* Error */,
            message: "The property '{0}' does not exist on value of type '{1}'.",
            code: 2094
        },
        Could_not_find_symbol__0_: {
            category: 1 /* Error */,
            message: "Could not find symbol '{0}'.",
            code: 2095
        },
        _get__and__set__accessor_must_have_the_same_type: {
            category: 1 /* Error */,
            message: "'get' and 'set' accessor must have the same type.",
            code: 2096
        },
        _this__cannot_be_referenced_in_current_location: {
            category: 1 /* Error */,
            message: "'this' cannot be referenced in current location.",
            code: 2097
        },
        Use_of_deprecated__bool__type__Use__boolean__instead: {
            category: 0 /* Warning */,
            message: "Use of deprecated type 'bool'. Use 'boolean' instead.",
            code: 2098
        },
        Static_methods_cannot_reference_class_type_parameters: {
            category: 1 /* Error */,
            message: "Static methods cannot reference class type parameters.",
            code: 2099
        },
        Class__0__is_recursively_referenced_as_a_base_type_of_itself: {
            category: 1 /* Error */,
            message: "Class '{0}' is recursively referenced as a base type of itself.",
            code: 2100
        },
        Interface__0__is_recursively_referenced_as_a_base_type_of_itself: {
            category: 1 /* Error */,
            message: "Interface '{0}' is recursively referenced as a base type of itself.",
            code: 2101
        },
        _super__property_access_is_permitted_only_in_a_constructor__instance_member_function__or_instance_member_accessor_of_a_derived_class: {
            category: 1 /* Error */,
            message: "'super' property access is permitted only in a constructor, instance member function, or instance member accessor of a derived class.",
            code: 2102
        },
        _super__cannot_be_referenced_in_non_derived_classes: {
            category: 1 /* Error */,
            message: "'super' cannot be referenced in non-derived classes.",
            code: 2103
        },
        A__super__call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_intialized_properties_or_has_parameter_properties: {
            category: 1 /* Error */,
            message: "A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.",
            code: 2104
        },
        Constructors_for_derived_classes_must_contain_a__super__call: {
            category: 1 /* Error */,
            message: "Constructors for derived classes must contain a 'super' call.",
            code: 2105
        },
        Super_calls_are_not_permitted_outside_constructors_or_in_local_functions_inside_constructors: {
            category: 1 /* Error */,
            message: "Super calls are not permitted outside constructors or in local functions inside constructors.",
            code: 2106
        },
        _0_1__is_inaccessible: {
            category: 1 /* Error */,
            message: "'{0}.{1}' is inaccessible.",
            code: 2107
        },
        _this__cannot_be_referenced_within_module_bodies: {
            category: 1 /* Error */,
            message: "'this' cannot be referenced within module bodies.",
            code: 2108
        },
        _this__must_only_be_used_inside_a_function_or_script_context: {
            category: 1 /* Error */,
            message: "'this' must only be used inside a function or script context.",
            code: 2109
        },
        Invalid__addition__expression___types_do_not_agree: {
            category: 1 /* Error */,
            message: "Invalid '+' expression - types not known to support the addition operator.",
            code: 2111
        },
        The_right_hand_side_of_an_arithmetic_operation_must_be_of_type__any____number__or_an_enum_type: {
            category: 1 /* Error */,
            message: "The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.",
            code: 2112
        },
        The_left_hand_side_of_an_arithmetic_operation_must_be_of_type__any____number__or_an_enum_type: {
            category: 1 /* Error */,
            message: "The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.",
            code: 2113
        },
        The_type_of_a_unary_arithmetic_operation_operand_must_be_of_type__any____number__or_an_enum_type: {
            category: 1 /* Error */,
            message: "The type of a unary arithmetic operation operand must be of type 'any', 'number' or an enum type.",
            code: 2114
        },
        Variable_declarations_for_for_in_expressions_cannot_contain_a_type_annotation: {
            category: 1 /* Error */,
            message: "Variable declarations for for/in expressions cannot contain a type annotation.",
            code: 2115
        },
        Variable_declarations_for_for_in_expressions_must_be_of_types__string__or__any_: {
            category: 1 /* Error */,
            message: "Variable declarations for for/in expressions must be of types 'string' or 'any'.",
            code: 2116
        },
        The_right_operand_of_a_for_in_expression_must_be_of_type__any____an_object_type_or_a_type_parameter: {
            category: 1 /* Error */,
            message: "The right operand of a for/in expression must be of type 'any', an object type or a type parameter.",
            code: 2117
        },
        The_left_hand_side_of_an__in__expression_must_be_of_types__string__or__any_: {
            category: 1 /* Error */,
            message: "The left-hand side of an 'in' expression must be of types 'string' or 'any'.",
            code: 2118
        },
        The_right_hand_side_of_an__in__expression_must_be_of_type__any___an_object_type_or_a_type_parameter: {
            category: 1 /* Error */,
            message: "The right-hand side of an 'in' expression must be of type 'any', an object type or a type parameter.",
            code: 2119
        },
        The_left_hand_side_of_an__instanceOf__expression_must_be_of_type__any___an_object_type_or_a_type_parameter: {
            category: 1 /* Error */,
            message: "The left-hand side of an 'instanceOf' expression must be of type 'any', an object type or a type parameter.",
            code: 2120
        },
        The_right_hand_side_of_an__instanceOf__expression_must_be_of_type__any__or_a_subtype_of_the__Function__interface_type: {
            category: 1 /* Error */,
            message: "The right-hand side of an 'instanceOf' expression must be of type 'any' or a subtype of the 'Function' interface type.",
            code: 2121
        },
        Setters_cannot_return_a_value: {
            category: 1 /* Error */,
            message: "Setters cannot return a value.",
            code: 2122
        },
        Tried_to_set_variable_type_to_module_type__0__: {
            category: 1 /* Error */,
            message: "Tried to set variable type to container type '{0}'.",
            code: 2123
        },
        Tried_to_set_variable_type_to_uninitialized_module_type__0__: {
            category: 1 /* Error */,
            message: "Tried to set variable type to uninitialized module type '{0}'.",
            code: 2124
        },
        Function__0__declared_a_non_void_return_type__but_has_no_return_expression: {
            category: 1 /* Error */,
            message: "Function {0} declared a non-void return type, but has no return expression.",
            code: 2125
        },
        Getters_must_return_a_value: {
            category: 1 /* Error */,
            message: "Getters must return a value.",
            code: 2126
        },
        Getter_and_setter_accessors_do_not_agree_in_visibility: {
            category: 1 /* Error */,
            message: "Getter and setter accessors do not agree in visibility.",
            code: 2127
        },
        Invalid_left_hand_side_of_assignment_expression: {
            category: 1 /* Error */,
            message: "Invalid left-hand side of assignment expression.",
            code: 2130
        },
        Function_declared_a_non_void_return_type__but_has_no_return_expression: {
            category: 1 /* Error */,
            message: "Function declared a non-void return type, but has no return expression.",
            code: 2131
        },
        Cannot_resolve_return_type_reference: {
            category: 1 /* Error */,
            message: "Cannot resolve return type reference.",
            code: 2132
        },
        Constructors_cannot_have_a_return_type_of__void_: {
            category: 1 /* Error */,
            message: "Constructors cannot have a return type of 'void'.",
            code: 2133
        },
        Subsequent_variable_declarations_must_have_the_same_type___Variable__0__must_be_of_type__1___but_here_has_type___2_: {
            category: 1 /* Error */,
            message: "Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'",
            code: 2134
        },
        All_symbols_within_a__with__block_will_be_resolved_to__any__: {
            category: 1 /* Error */,
            message: "All symbols within a with block will be resolved to 'any'.",
            code: 2135
        },
        Import_declarations_in_an_internal_module_cannot_reference_an_external_module: {
            category: 1 /* Error */,
            message: "Import declarations in an internal module cannot reference an external module.",
            code: 2136
        },
        Class__0__declares_interface__1__but_does_not_implement_it__NL__2: {
            category: 1 /* Error */,
            message: "Class {0} declares interface {1} but does not implement it:{NL}{2}",
            code: 2137
        },
        Class__0__declares_class__1__but_does_not_implement_it__NL__2: {
            category: 1 /* Error */,
            message: "Class {0} declares class {1} as an implemented interface but does not implement it:{NL}{2}",
            code: 2138
        },
        The_operand_of_an_increment_or_decrement_operator_must_be_a_variable__property_or_indexer: {
            category: 1 /* Error */,
            message: "The operand of an increment or decrement operator must be a variable, property or indexer.",
            code: 2139
        },
        _this__cannot_be_referenced_in_initializers_in_a_class_body: {
            category: 1 /* Error */,
            message: "'this' cannot be referenced in initializers in a class body.",
            code: 2140
        },
        Class__0__cannot_extend_class__1__NL__2: {
            category: 1 /* Error */,
            message: "Class '{0}' cannot extend class '{1}':{NL}{2}",
            code: 2141
        },
        Interface__0__cannot_extend_class__1__NL__2: {
            category: 1 /* Error */,
            message: "Interface '{0}' cannot extend class '{1}':{NL}{2}",
            code: 2142
        },
        Interface__0__cannot_extend_interface__1__NL__2: {
            category: 1 /* Error */,
            message: "Interface '{0}' cannot extend interface '{1}':{NL}{2}",
            code: 2143
        },
        Duplicate_overload_signature_for__0_: {
            category: 1 /* Error */,
            message: "Duplicate overload signature for '{0}'.",
            code: 2144
        },
        Duplicate_constructor_overload_signature: {
            category: 1 /* Error */,
            message: "Duplicate constructor overload signature.",
            code: 2145
        },
        Duplicate_overload_call_signature: {
            category: 1 /* Error */,
            message: "Duplicate overload call signature.",
            code: 2146
        },
        Duplicate_overload_construct_signature: {
            category: 1 /* Error */,
            message: "Duplicate overload construct signature.",
            code: 2147
        },
        Overload_signature_is_not_compatible_with_function_definition: {
            category: 1 /* Error */,
            message: "Overload signature is not compatible with function definition.",
            code: 2148
        },
        Overload_signature_is_not_compatible_with_function_definition__NL__0: {
            category: 1 /* Error */,
            message: "Overload signature is not compatible with function definition:{NL}{0}",
            code: 2149
        },
        Overload_signatures_must_all_be_public_or_private: {
            category: 1 /* Error */,
            message: "Overload signatures must all be public or private.",
            code: 2150
        },
        Overload_signatures_must_all_be_exported_or_local: {
            category: 1 /* Error */,
            message: "Overload signatures must all be exported or local.",
            code: 2151
        },
        Overload_signatures_must_all_be_ambient_or_non_ambient: {
            category: 1 /* Error */,
            message: "Overload signatures must all be ambient or non-ambient.",
            code: 2152
        },
        Overload_signatures_must_all_be_optional_or_required: {
            category: 1 /* Error */,
            message: "Overload signatures must all be optional or required.",
            code: 2153
        },
        Specialized_overload_signature_is_not_subtype_of_any_non_specialized_signature: {
            category: 1 /* Error */,
            message: "Specialized overload signature is not subtype of any non-specialized signature.",
            code: 2154
        },
        _this__cannot_be_referenced_in_constructor_arguments: {
            category: 1 /* Error */,
            message: "'this' cannot be referenced in constructor arguments.",
            code: 2155
        },
        Static_member_cannot_be_accessed_off_an_instance_variable: {
            category: 1 /* Error */,
            message: "Static member cannot be accessed off an instance variable.",
            code: 2156
        },
        Instance_member_cannot_be_accessed_off_a_class: {
            category: 1 /* Error */,
            message: "Instance member cannot be accessed off a class.",
            code: 2157
        },
        Untyped_function_calls_may_not_accept_type_arguments: {
            category: 1 /* Error */,
            message: "Untyped function calls may not accept type arguments.",
            code: 2158
        },
        Non_generic_functions_may_not_accept_type_arguments: {
            category: 1 /* Error */,
            message: "Non-generic functions may not accept type arguments.",
            code: 2159
        },
        A_generic_type_may_not_reference_itself_with_its_own_type_parameters: {
            category: 1 /* Error */,
            message: "A generic type may not reference itself with a wrapped form of its own type parameters.",
            code: 2160
        },
        Value_of_type__0__is_not_callable__Did_you_mean_to_include__new___: {
            category: 1 /* Error */,
            message: "Value of type '{0}' is not callable. Did you mean to include 'new'?",
            code: 2161
        },
        Rest_parameters_must_be_array_types: {
            category: 1 /* Error */,
            message: "Rest parameters must be array types.",
            code: 2162
        },
        Overload_signature_implementation_cannot_use_specialized_type: {
            category: 1 /* Error */,
            message: "Overload signature implementation cannot use specialized type.",
            code: 2163
        },
        Export_assignments_may_only_be_used_in_External_modules: {
            category: 1 /* Error */,
            message: "Export assignments may only be used at the top-level of external modules",
            code: 2164
        },
        Export_assignments_may_only_be_made_with_acceptable_kinds: {
            category: 1 /* Error */,
            message: "Export assignments may only be made with variables, functions, classes, interfaces, enums and internal modules",
            code: 2165
        },
        Only_public_instance_methods_of_the_base_class_are_accessible_via_the_super_keyword: {
            category: 1 /* Error */,
            message: "Only public instance methods of the base class are accessible via the super keyword",
            code: 2166
        },
        Numeric_indexer_type___0___must_be_a_subtype_of_string_indexer_type___1__: {
            category: 1 /* Error */,
            message: "Numeric indexer type '{0}' must be a subtype of string indexer type '{1}'",
            code: 2167
        },
        Numeric_indexer_type___0___must_be_a_subtype_of_string_indexer_type___1____NL__2: {
            category: 1 /* Error */,
            message: "Numeric indexer type '{0}' must be a subtype of string indexer type '{1}':{NL}{2}",
            code: 2168
        },
        All_numerically_named_properties_must_be_subtypes_of_numeric_indexer_type___0__: {
            category: 1 /* Error */,
            message: "All numerically named properties must be subtypes of numeric indexer type '{0}'",
            code: 2169
        },
        All_numerically_named_properties_must_be_subtypes_of_numeric_indexer_type___0____NL__1: {
            category: 1 /* Error */,
            message: "All numerically named properties must be subtypes of numeric indexer type '{0}':{NL}{1}",
            code: 2170
        },
        All_named_properties_must_be_subtypes_of_string_indexer_type___0__: {
            category: 1 /* Error */,
            message: "All named properties must be subtypes of string indexer type '{0}'",
            code: 2171
        },
        All_named_properties_must_be_subtypes_of_string_indexer_type___0____NL__1: {
            category: 1 /* Error */,
            message: "All named properties must be subtypes of string indexer type '{0}':{NL}{1}",
            code: 2172
        },
        Generic_type_references_must_include_all_type_arguments: {
            category: 1 /* Error */,
            message: "Generic type references must include all type arguments",
            code: 2173
        },
        Type__0__is_missing_property__1__from_type__2_: {
            category: 3 /* NoPrefix */,
            message: "Type '{0}' is missing property '{1}' from type '{2}'.",
            code: 4000
        },
        Types_of_property__0__of_types__1__and__2__are_incompatible: {
            category: 3 /* NoPrefix */,
            message: "Types of property '{0}' of types '{1}' and '{2}' are incompatible.",
            code: 4001
        },
        Types_of_property__0__of_types__1__and__2__are_incompatible__NL__3: {
            category: 3 /* NoPrefix */,
            message: "Types of property '{0}' of types '{1}' and '{2}' are incompatible:{NL}{3}",
            code: 4002
        },
        Property__0__defined_as_private_in_type__1__is_defined_as_public_in_type__2_: {
            category: 3 /* NoPrefix */,
            message: "Property '{0}' defined as private in type '{1}' is defined as public in type '{2}'.",
            code: 4003
        },
        Property__0__defined_as_public_in_type__1__is_defined_as_private_in_type__2_: {
            category: 3 /* NoPrefix */,
            message: "Property '{0}' defined as public in type '{1}' is defined as private in type '{2}'.",
            code: 4004
        },
        Types__0__and__1__define_property__2__as_private: {
            category: 3 /* NoPrefix */,
            message: "Types '{0}' and '{1}' define property '{2}' as private.",
            code: 4005
        },
        Call_signatures_of_types__0__and__1__are_incompatible: {
            category: 3 /* NoPrefix */,
            message: "Call signatures of types '{0}' and '{1}' are incompatible.",
            code: 4006
        },
        Call_signatures_of_types__0__and__1__are_incompatible__NL__2: {
            category: 3 /* NoPrefix */,
            message: "Call signatures of types '{0}' and '{1}' are incompatible:{NL}{2}",
            code: 4007
        },
        Type__0__requires_a_call_signature__but_Type__1__lacks_one: {
            category: 3 /* NoPrefix */,
            message: "Type '{0}' requires a call signature, but type '{1}' lacks one.",
            code: 4008
        },
        Construct_signatures_of_types__0__and__1__are_incompatible: {
            category: 3 /* NoPrefix */,
            message: "Construct signatures of types '{0}' and '{1}' are incompatible.",
            code: 4009
        },
        Construct_signatures_of_types__0__and__1__are_incompatible__NL__2: {
            category: 3 /* NoPrefix */,
            message: "Construct signatures of types '{0}' and '{1}' are incompatible:{NL}{2}",
            code: 40010
        },
        Type__0__requires_a_construct_signature__but_Type__1__lacks_one: {
            category: 3 /* NoPrefix */,
            message: "Type '{0}' requires a construct signature, but type '{1}' lacks one.",
            code: 4011
        },
        Index_signatures_of_types__0__and__1__are_incompatible: {
            category: 3 /* NoPrefix */,
            message: "Index signatures of types '{0}' and '{1}' are incompatible.",
            code: 4012
        },
        Index_signatures_of_types__0__and__1__are_incompatible__NL__2: {
            category: 3 /* NoPrefix */,
            message: "Index signatures of types '{0}' and '{1}' are incompatible:{NL}{2}",
            code: 4013
        },
        Call_signature_expects__0__or_fewer_parameters: {
            category: 3 /* NoPrefix */,
            message: "Call signature expects {0} or fewer parameters.",
            code: 4014
        },
        Could_not_apply_type__0__to_argument__1__which_is_of_type__2_: {
            category: 3 /* NoPrefix */,
            message: "Could not apply type'{0}' to argument {1} which is of type '{2}'.",
            code: 4015
        },
        Class__0__defines_instance_member_accessor__1___but_extended_class__2__defines_it_as_instance_member_function: {
            category: 3 /* NoPrefix */,
            message: "Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function.",
            code: 4016
        },
        Class__0__defines_instance_member_property__1___but_extended_class__2__defines_it_as_instance_member_function: {
            category: 3 /* NoPrefix */,
            message: "Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function.",
            code: 4017
        },
        Class__0__defines_instance_member_function__1___but_extended_class__2__defines_it_as_instance_member_accessor: {
            category: 3 /* NoPrefix */,
            message: "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor.",
            code: 4018
        },
        Class__0__defines_instance_member_function__1___but_extended_class__2__defines_it_as_instance_member_property: {
            category: 3 /* NoPrefix */,
            message: "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member property.",
            code: 4019
        },
        Types_of_static_property__0__of_class__1__and_class__2__are_incompatible: {
            category: 3 /* NoPrefix */,
            message: "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible.",
            code: 4020
        },
        Types_of_static_property__0__of_class__1__and_class__2__are_incompatible__NL__3: {
            category: 3 /* NoPrefix */,
            message: "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible:{NL}{3}",
            code: 4021
        },
        Type_reference_cannot_refer_to_container__0_: {
            category: 1 /* Error */,
            message: "Type reference cannot refer to container '{0}'.",
            code: 4022
        },
        Type_reference_must_refer_to_type: {
            category: 1 /* Error */,
            message: "Type reference cannot must refer to type.",
            code: 4023
        },
        Enums_with_multiple_declarations_must_provide_an_initializer_for_the_first_enum_element: {
            category: 1 /* Error */,
            message: "Enums with multiple declarations must provide an initializer for the first enum element.",
            code: 4024
        },
        Current_host_does_not_support__w_atch_option: {
            category: 1 /* Error */,
            message: "Current host does not support -w[atch] option.",
            code: 5001
        },
        ECMAScript_target_version__0__not_supported___Using_default__1__code_generation: {
            category: 0 /* Warning */,
            message: "ECMAScript target version '{0}' not supported.  Using default '{1}' code generation.",
            code: 5002
        },
        Module_code_generation__0__not_supported___Using_default__1__code_generation: {
            category: 0 /* Warning */,
            message: "Module code generation '{0}' not supported.  Using default '{1}' code generation.",
            code: 5003
        },
        Could_not_find_file___0_: {
            category: 1 /* Error */,
            message: "Could not find file: '{0}'.",
            code: 5004
        },
        Unknown_extension_for_file___0__Only__ts_and_d_ts_extensions_are_allowed: {
            category: 1 /* Error */,
            message: "Unknown extension for file: '{0}'. Only .ts and .d.ts extensions are allowed.",
            code: 5005
        },
        A_file_cannot_have_a_reference_itself: {
            category: 1 /* Error */,
            message: "A file cannot have a reference itself.",
            code: 5006
        },
        Cannot_resolve_referenced_file___0_: {
            category: 1 /* Error */,
            message: "Cannot resolve referenced file: '{0}'.",
            code: 5007
        },
        Cannot_resolve_imported_file___0_: {
            category: 1 /* Error */,
            message: "Cannot resolve imported file: '{0}'.",
            code: 5008
        },
        Cannot_find_the_common_subdirectory_path_for_the_input_files: {
            category: 1 /* Error */,
            message: "Cannot find the common subdirectory path for the input files",
            code: 5009
        },
        Cannot_compile_dynamic_modules_when_emitting_into_single_file: {
            category: 1 /* Error */,
            message: "Cannot compile dynamic modules when emitting into single file",
            code: 5010
        },
        Emit_Error__0: {
            category: 1 /* Error */,
            message: "Emit Error: {0}.",
            code: 5011
        }
    };

    var seenCodes = [];
    for (var name in TypeScript.diagnosticMessages) {
        if (TypeScript.diagnosticMessages.hasOwnProperty(name)) {
            var diagnosticMessage = TypeScript.diagnosticMessages[name];
            var value = seenCodes[diagnosticMessage.code];
            if (value) {
                throw new Error("Duplicate diagnostic code: " + diagnosticMessage.code);
            }

            seenCodes[diagnosticMessage.code] = diagnosticMessage;
        }
    }
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Errors = (function () {
        function Errors() {
        }
        Errors.argument = function (argument, message) {
            return new Error("Invalid argument: " + argument + "." + (message ? (" " + message) : ""));
        };

        Errors.argumentOutOfRange = function (argument) {
            return new Error("Argument out of range: " + argument + ".");
        };

        Errors.argumentNull = function (argument) {
            return new Error("Argument null: " + argument + ".");
        };

        Errors.abstract = function () {
            return new Error("Operation not implemented properly by subclass.");
        };

        Errors.notYetImplemented = function () {
            return new Error("Not yet implemented.");
        };

        Errors.invalidOperation = function (message) {
            return new Error(message ? ("Invalid operation: " + message) : "Invalid operation.");
        };
        return Errors;
    })();
    TypeScript.Errors = Errors;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Hash = (function () {
        function Hash() {
        }
        Hash.computeFnv1aCharArrayHashCode = function (text, start, len) {
            var hashCode = Hash.FNV_BASE;
            var end = start + len;

            for (var i = start; i < end; i++) {
                hashCode = (hashCode ^ text[i]) * Hash.FNV_PRIME;
            }

            return hashCode;
        };

        Hash.computeSimple31BitCharArrayHashCode = function (key, start, len) {
            var hash = 0;

            for (var i = 0; i < len; i++) {
                var ch = key[start + i];

                hash = (((hash << 5) + hash) + ch) | 0;
            }

            return hash & 0x7FFFFFFF;
        };

        Hash.computeSimple31BitStringHashCode = function (key) {
            var hash = 0;

            var start = 0;
            var len = key.length;

            for (var i = 0; i < len; i++) {
                var ch = key.charCodeAt(start + i);

                hash = (((hash << 5) + hash) + ch) | 0;
            }

            return hash & 0x7FFFFFFF;
        };

        Hash.computeMurmur2CharArrayHashCode = function (key, start, len) {
            var m = 0x5bd1e995;
            var r = 24;

            var numberOfCharsLeft = len;
            var h = (0 ^ numberOfCharsLeft);

            var index = start;
            while (numberOfCharsLeft >= 2) {
                var c1 = key[index];
                var c2 = key[index + 1];

                var k = c1 | (c2 << 16);

                k *= m;
                k ^= k >> r;
                k *= m;

                h *= m;
                h ^= k;

                index += 2;
                numberOfCharsLeft -= 2;
            }

            if (numberOfCharsLeft === 1) {
                h ^= key[index];
                h *= m;
            }

            h ^= h >> 13;
            h *= m;
            h ^= h >> 15;

            return h;
        };

        Hash.computeMurmur2StringHashCode = function (key) {
            var m = 0x5bd1e995;
            var r = 24;

            var start = 0;
            var len = key.length;
            var numberOfCharsLeft = len;

            var h = (0 ^ numberOfCharsLeft);

            var index = start;
            while (numberOfCharsLeft >= 2) {
                var c1 = key.charCodeAt(index);
                var c2 = key.charCodeAt(index + 1);

                var k = c1 | (c2 << 16);

                k *= m;
                k ^= k >> r;
                k *= m;

                h *= m;
                h ^= k;

                index += 2;
                numberOfCharsLeft -= 2;
            }

            if (numberOfCharsLeft === 1) {
                h ^= key.charCodeAt(index);
                h *= m;
            }

            h ^= h >> 13;
            h *= m;
            h ^= h >> 15;

            return h;
        };

        Hash.getPrime = function (min) {
            for (var i = 0; i < Hash.primes.length; i++) {
                var num = Hash.primes[i];
                if (num >= min) {
                    return num;
                }
            }

            throw TypeScript.Errors.notYetImplemented();
        };

        Hash.expandPrime = function (oldSize) {
            var num = oldSize << 1;
            if (num > 2146435069 && 2146435069 > oldSize) {
                return 2146435069;
            }
            return Hash.getPrime(num);
        };

        Hash.combine = function (value, currentHash) {
            return (((currentHash << 5) + currentHash) + value) & 0x7FFFFFFF;
        };
        Hash.FNV_BASE = 2166136261;
        Hash.FNV_PRIME = 16777619;

        Hash.primes = [
            3,
            7,
            11,
            17,
            23,
            29,
            37,
            47,
            59,
            71,
            89,
            107,
            131,
            163,
            197,
            239,
            293,
            353,
            431,
            521,
            631,
            761,
            919,
            1103,
            1327,
            1597,
            1931,
            2333,
            2801,
            3371,
            4049,
            4861,
            5839,
            7013,
            8419,
            10103,
            12143,
            14591,
            17519,
            21023,
            25229,
            30293,
            36353,
            43627,
            52361,
            62851,
            75431,
            90523,
            108631,
            130363,
            156437,
            187751,
            225307,
            270371,
            324449,
            389357,
            467237,
            560689,
            672827,
            807403,
            968897,
            1162687,
            1395263,
            1674319,
            2009191,
            2411033,
            2893249,
            3471899,
            4166287,
            4999559,
            5999471,
            7199369
        ];
        return Hash;
    })();
    TypeScript.Hash = Hash;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Collections) {
        Collections.DefaultHashTableCapacity = 256;

        var HashTableEntry = (function () {
            function HashTableEntry(Key, Value, HashCode, Next) {
                this.Key = Key;
                this.Value = Value;
                this.HashCode = HashCode;
                this.Next = Next;
            }
            return HashTableEntry;
        })();

        var HashTable = (function () {
            function HashTable(capacity, hash, equals) {
                this.hash = hash;
                this.equals = equals;
                this.entries = [];
                this.count = 0;
                var size = TypeScript.Hash.getPrime(capacity);
                this.hash = hash;
                this.equals = equals;
                this.entries = TypeScript.ArrayUtilities.createArray(size, null);
            }
            HashTable.prototype.set = function (key, value) {
                this.addOrSet(key, value, false);
            };

            HashTable.prototype.add = function (key, value) {
                this.addOrSet(key, value, true);
            };

            HashTable.prototype.containsKey = function (key) {
                var hashCode = this.computeHashCode(key);
                var entry = this.findEntry(key, hashCode);
                return entry !== null;
            };

            HashTable.prototype.get = function (key) {
                var hashCode = this.computeHashCode(key);
                var entry = this.findEntry(key, hashCode);

                return entry === null ? null : entry.Value;
            };

            HashTable.prototype.computeHashCode = function (key) {
                var hashCode = this.hash === null ? key.hashCode() : this.hash(key);

                hashCode = hashCode & 0x7FFFFFFF;
                TypeScript.Debug.assert(hashCode > 0);

                return hashCode;
            };

            HashTable.prototype.addOrSet = function (key, value, throwOnExistingEntry) {
                var hashCode = this.computeHashCode(key);

                var entry = this.findEntry(key, hashCode);
                if (entry !== null) {
                    if (throwOnExistingEntry) {
                        throw TypeScript.Errors.argument('key', 'Key was already in table.');
                    }

                    entry.Key = key;
                    entry.Value = value;
                    return;
                }

                return this.addEntry(key, value, hashCode);
            };

            HashTable.prototype.findEntry = function (key, hashCode) {
                for (var e = this.entries[hashCode % this.entries.length]; e !== null; e = e.Next) {
                    if (e.HashCode === hashCode) {
                        var equals = this.equals === null ? key === e.Key : this.equals(key, e.Key);

                        if (equals) {
                            return e;
                        }
                    }
                }

                return null;
            };

            HashTable.prototype.addEntry = function (key, value, hashCode) {
                var index = hashCode % this.entries.length;

                var e = new HashTableEntry(key, value, hashCode, this.entries[index]);

                this.entries[index] = e;

                if (this.count === this.entries.length) {
                    this.grow();
                }

                this.count++;
                return e.Key;
            };

            HashTable.prototype.grow = function () {
                var newSize = TypeScript.Hash.expandPrime(this.entries.length);

                var oldEntries = this.entries;
                var newEntries = TypeScript.ArrayUtilities.createArray(newSize, null);

                this.entries = newEntries;

                for (var i = 0; i < oldEntries.length; i++) {
                    var e = oldEntries[i];

                    while (e !== null) {
                        var newIndex = e.HashCode % newSize;
                        var tmp = e.Next;
                        e.Next = newEntries[newIndex];
                        newEntries[newIndex] = e;
                        e = tmp;
                    }
                }
            };
            return HashTable;
        })();
        Collections.HashTable = HashTable;

        function createHashTable(capacity, hash, equals) {
            if (typeof capacity === "undefined") { capacity = Collections.DefaultHashTableCapacity; }
            if (typeof hash === "undefined") { hash = null; }
            if (typeof equals === "undefined") { equals = null; }
            return new HashTable(capacity, hash, equals);
        }
        Collections.createHashTable = createHashTable;

        var currentHashCode = 1;
        function identityHashCode(value) {
            if (value.__hash === undefined) {
                value.__hash = currentHashCode;
                currentHashCode++;
            }

            return value.__hash;
        }
        Collections.identityHashCode = identityHashCode;
    })(TypeScript.Collections || (TypeScript.Collections = {}));
    var Collections = TypeScript.Collections;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Diagnostic = (function () {
        function Diagnostic(fileName, start, length, diagnosticCode, arguments) {
            if (typeof arguments === "undefined") { arguments = null; }
            this._diagnosticCode = diagnosticCode;
            this._arguments = (arguments && arguments.length > 0) ? arguments : null;
            this._fileName = fileName;
            this._originalStart = this._start = start;
            this._length = length;
        }
        Diagnostic.prototype.toJSON = function (key) {
            var result = {};
            result.start = this.start();
            result.length = this.length();

            result.diagnosticCode = TypeScript.DiagnosticCode[this.diagnosticCode()];

            var arguments = (this).arguments();
            if (arguments && arguments.length > 0) {
                result.arguments = arguments;
            }

            return result;
        };

        Diagnostic.prototype.fileName = function () {
            return this._fileName;
        };

        Diagnostic.prototype.start = function () {
            return this._start;
        };

        Diagnostic.prototype.length = function () {
            return this._length;
        };

        Diagnostic.prototype.diagnosticCode = function () {
            return this._diagnosticCode;
        };

        Diagnostic.prototype.arguments = function () {
            return this._arguments;
        };

        Diagnostic.prototype.text = function () {
            return TypeScript.getDiagnosticText(this._diagnosticCode, this._arguments);
        };

        Diagnostic.prototype.message = function () {
            return TypeScript.getDiagnosticMessage(this._diagnosticCode, this._arguments);
        };

        Diagnostic.prototype.adjustOffset = function (pos) {
            this._start = this._originalStart + pos;
        };

        Diagnostic.prototype.additionalLocations = function () {
            return [];
        };

        Diagnostic.equals = function (diagnostic1, diagnostic2) {
            return diagnostic1._fileName === diagnostic2._fileName && diagnostic1._start === diagnostic2._start && diagnostic1._length === diagnostic2._length && diagnostic1._diagnosticCode === diagnostic2._diagnosticCode && TypeScript.ArrayUtilities.sequenceEquals(diagnostic1._arguments, diagnostic2._arguments, function (v1, v2) {
                return v1 === v2;
            });
        };
        return Diagnostic;
    })();
    TypeScript.Diagnostic = Diagnostic;

    function getLargestIndex(diagnostic) {
        var largest = -1;
        var stringComponents = diagnostic.split("_");

        for (var i = 0; i < stringComponents.length; i++) {
            var val = parseInt(stringComponents[i]);
            if (!isNaN(val) && val > largest) {
                largest = val;
            }
        }

        return largest;
    }

    function getDiagnosticInfoFromCode(diagnosticCode) {
        var diagnosticName = TypeScript.DiagnosticCode[diagnosticCode];
        return TypeScript.diagnosticMessages[diagnosticName];
    }
    TypeScript.getDiagnosticInfoFromCode = getDiagnosticInfoFromCode;

    function getDiagnosticText(diagnosticCode, args) {
        var diagnosticName = TypeScript.DiagnosticCode[diagnosticCode];

        var diagnostic = TypeScript.diagnosticMessages[diagnosticName];

        var actualCount = args ? args.length : 0;
        if (!diagnostic) {
            throw new Error("Invalid diagnostic");
        } else {
            var expectedCount = 1 + getLargestIndex(diagnosticName);

            if (expectedCount !== actualCount) {
                throw new Error("Expected " + expectedCount + " arguments to diagnostic, got " + actualCount + " instead");
            }
        }

        var diagnosticMessageText = diagnostic.message.replace(/{({(\d+)})?TB}/g, function (match, p1, num) {
            var tabChar = "\t";
            var result = tabChar;
            if (num && args[num]) {
                for (var i = 1; i < args[num]; i++) {
                    result += tabChar;
                }
            }

            return result;
        });

        diagnosticMessageText = diagnosticMessageText.replace(/{(\d+)}/g, function (match, num) {
            return typeof args[num] !== 'undefined' ? args[num] : match;
        });

        diagnosticMessageText = diagnosticMessageText.replace(/{(NL)}/g, function (match) {
            return "\r\n";
        });

        return diagnosticMessageText;
    }
    TypeScript.getDiagnosticText = getDiagnosticText;

    function getDiagnosticMessage(diagnosticCode, args) {
        var diagnostic = getDiagnosticInfoFromCode(diagnosticCode);
        var diagnosticMessageText = getDiagnosticText(diagnosticCode, args);

        var message;
        if (diagnostic.category === 1 /* Error */) {
            message = getDiagnosticText(0 /* error_TS_0__1 */, [diagnostic.code, diagnosticMessageText]);
        } else if (diagnostic.category === 0 /* Warning */) {
            message = getDiagnosticText(1 /* warning_TS_0__1 */, [diagnostic.code, diagnosticMessageText]);
        } else {
            message = diagnosticMessageText;
        }

        return message;
    }
    TypeScript.getDiagnosticMessage = getDiagnosticMessage;
})(TypeScript || (TypeScript = {}));
var ByteOrderMark;
(function (ByteOrderMark) {
    ByteOrderMark[ByteOrderMark["None"] = 0] = "None";
    ByteOrderMark[ByteOrderMark["Utf8"] = 1] = "Utf8";
    ByteOrderMark[ByteOrderMark["Utf16BigEndian"] = 2] = "Utf16BigEndian";
    ByteOrderMark[ByteOrderMark["Utf16LittleEndian"] = 3] = "Utf16LittleEndian";
})(ByteOrderMark || (ByteOrderMark = {}));

var FileInformation = (function () {
    function FileInformation(contents, byteOrderMark) {
        this._contents = contents;
        this._byteOrderMark = byteOrderMark;
    }
    FileInformation.prototype.contents = function () {
        return this._contents;
    };

    FileInformation.prototype.byteOrderMark = function () {
        return this._byteOrderMark;
    };
    return FileInformation;
})();

var Environment = (function () {
    function getWindowsScriptHostEnvironment() {
        try  {
            var fso = new ActiveXObject("Scripting.FileSystemObject");
        } catch (e) {
            return null;
        }

        var streamObjectPool = [];

        function getStreamObject() {
            if (streamObjectPool.length > 0) {
                return streamObjectPool.pop();
            } else {
                return new ActiveXObject("ADODB.Stream");
            }
        }

        function releaseStreamObject(obj) {
            streamObjectPool.push(obj);
        }

        var args = [];
        for (var i = 0; i < WScript.Arguments.length; i++) {
            args[i] = WScript.Arguments.Item(i);
        }

        return {
            currentDirectory: function () {
                return (WScript).CreateObject("WScript.Shell").CurrentDirectory;
            },
            readFile: function (path) {
                try  {
                    var streamObj = getStreamObject();
                    streamObj.Open();
                    streamObj.Type = 2;

                    streamObj.Charset = 'x-ansi';

                    streamObj.LoadFromFile(path);
                    var bomChar = streamObj.ReadText(2);

                    streamObj.Position = 0;

                    var byteOrderMark = 0 /* None */;

                    if (bomChar.charCodeAt(0) === 0xFE && bomChar.charCodeAt(1) === 0xFF) {
                        streamObj.Charset = 'unicode';
                        byteOrderMark = 2 /* Utf16BigEndian */;
                    } else if (bomChar.charCodeAt(0) === 0xFF && bomChar.charCodeAt(1) === 0xFE) {
                        streamObj.Charset = 'unicode';
                        byteOrderMark = 3 /* Utf16LittleEndian */;
                    } else if (bomChar.charCodeAt(0) === 0xEF && bomChar.charCodeAt(1) === 0xBB) {
                        streamObj.Charset = 'utf-8';
                        byteOrderMark = 1 /* Utf8 */;
                    } else {
                        streamObj.Charset = 'utf-8';
                    }

                    var contents = streamObj.ReadText(-1);
                    streamObj.Close();
                    releaseStreamObject(streamObj);
                    return new FileInformation(contents, byteOrderMark);
                } catch (err) {
                    throw new Error("Error reading file \"" + path + "\": " + err.message);
                }
            },
            writeFile: function (path, contents, writeByteOrderMark) {
                var textStream = getStreamObject();
                textStream.Charset = 'utf-8';
                textStream.Open();
                textStream.WriteText(contents, 0);

                if (!writeByteOrderMark) {
                    textStream.Position = 3;
                } else {
                    textStream.Position = 0;
                }

                var fileStream = getStreamObject();
                fileStream.Type = 1;
                fileStream.Open();

                textStream.CopyTo(fileStream);

                fileStream.Flush();
                fileStream.SaveToFile(path, 2);
                fileStream.Close();

                textStream.Flush();
                textStream.Close();
            },
            fileExists: function (path) {
                return fso.FileExists(path);
            },
            deleteFile: function (path) {
                if (fso.FileExists(path)) {
                    fso.DeleteFile(path, true);
                }
            },
            directoryExists: function (path) {
                return fso.FolderExists(path);
            },
            listFiles: function (path, spec, options) {
                options = options || {};
                function filesInFolder(folder, root) {
                    var paths = [];
                    var fc;

                    if (options.recursive) {
                        fc = new Enumerator(folder.subfolders);

                        for (; !fc.atEnd(); fc.moveNext()) {
                            paths = paths.concat(filesInFolder(fc.item(), root + "\\" + fc.item().Name));
                        }
                    }

                    fc = new Enumerator(folder.files);

                    for (; !fc.atEnd(); fc.moveNext()) {
                        if (!spec || fc.item().Name.match(spec)) {
                            paths.push(root + "\\" + fc.item().Name);
                        }
                    }

                    return paths;
                }

                var folder = fso.GetFolder(path);
                var paths = [];

                return filesInFolder(folder, path);
            },
            arguments: args,
            standardOut: WScript.StdOut
        };
    }
    ;

    function getNodeEnvironment() {
        var _fs = require('fs');
        var _path = require('path');
        var _module = require('module');

        return {
            currentDirectory: function () {
                return (process).cwd();
            },
            readFile: function (file) {
                var buffer = _fs.readFileSync(file);
                switch (buffer[0]) {
                    case 0xFE:
                        if (buffer[1] === 0xFF) {
                            var i = 0;
                            while ((i + 1) < buffer.length) {
                                var temp = buffer[i];
                                buffer[i] = buffer[i + 1];
                                buffer[i + 1] = temp;
                                i += 2;
                            }
                            return new FileInformation(buffer.toString("ucs2", 2), 2 /* Utf16BigEndian */);
                        }
                        break;
                    case 0xFF:
                        if (buffer[1] === 0xFE) {
                            return new FileInformation(buffer.toString("ucs2", 2), 3 /* Utf16LittleEndian */);
                        }
                        break;
                    case 0xEF:
                        if (buffer[1] === 0xBB) {
                            return new FileInformation(buffer.toString("utf8", 3), 1 /* Utf8 */);
                        }
                }

                return new FileInformation(buffer.toString("utf8", 0), 0 /* None */);
            },
            writeFile: function (path, contents, writeByteOrderMark) {
                function mkdirRecursiveSync(path) {
                    var stats = _fs.statSync(path);
                    if (stats.isFile()) {
                        throw "\"" + path + "\" exists but isn't a directory.";
                    } else if (stats.isDirectory()) {
                        return;
                    } else {
                        mkdirRecursiveSync(_path.dirname(path));
                        _fs.mkdirSync(path, 0775);
                    }
                }
                mkdirRecursiveSync(_path.dirname(path));

                if (writeByteOrderMark) {
                    contents = '\uFEFF' + contents;
                }
                _fs.writeFileSync(path, contents, "utf8");
            },
            fileExists: function (path) {
                return _fs.existsSync(path);
            },
            deleteFile: function (path) {
                try  {
                    _fs.unlinkSync(path);
                } catch (e) {
                }
            },
            directoryExists: function (path) {
                return _fs.existsSync(path) && _fs.statSync(path).isDirectory();
            },
            listFiles: function dir(path, spec, options) {
                options = options || {};

                function filesInFolder(folder) {
                    var paths = [];

                    var files = _fs.readdirSync(folder);
                    for (var i = 0; i < files.length; i++) {
                        var stat = _fs.statSync(folder + "\\" + files[i]);
                        if (options.recursive && stat.isDirectory()) {
                            paths = paths.concat(filesInFolder(folder + "\\" + files[i]));
                        } else if (stat.isFile() && (!spec || files[i].match(spec))) {
                            paths.push(folder + "\\" + files[i]);
                        }
                    }

                    return paths;
                }

                return filesInFolder(path);
            },
            arguments: process.argv.slice(2),
            standardOut: {
                Write: function (str) {
                    process.stdout.write(str);
                },
                WriteLine: function (str) {
                    process.stdout.write(str + '\n');
                },
                Close: function () {
                }
            }
        };
    }
    ;

    if (typeof WScript !== "undefined" && typeof ActiveXObject === "function") {
        return getWindowsScriptHostEnvironment();
    } else if (typeof module !== 'undefined' && module.exports) {
        return getNodeEnvironment();
    } else {
        return null;
    }
})();
var TypeScript;
(function (TypeScript) {
    var IntegerUtilities = (function () {
        function IntegerUtilities() {
        }
        IntegerUtilities.integerDivide = function (numerator, denominator) {
            return (numerator / denominator) >> 0;
        };

        IntegerUtilities.integerMultiplyLow32Bits = function (n1, n2) {
            var n1Low16 = n1 & 0x0000ffff;
            var n1High16 = n1 >>> 16;

            var n2Low16 = n2 & 0x0000ffff;
            var n2High16 = n2 >>> 16;

            var resultLow32 = (((n1 & 0xffff0000) * n2) >>> 0) + (((n1 & 0x0000ffff) * n2) >>> 0) >>> 0;
            return resultLow32;
        };

        IntegerUtilities.integerMultiplyHigh32Bits = function (n1, n2) {
            var n1Low16 = n1 & 0x0000ffff;
            var n1High16 = n1 >>> 16;

            var n2Low16 = n2 & 0x0000ffff;
            var n2High16 = n2 >>> 16;

            var resultHigh32 = n1High16 * n2High16 + ((((n1Low16 * n2Low16) >>> 17) + n1Low16 * n2High16) >>> 15);
            return resultHigh32;
        };
        return IntegerUtilities;
    })();
    TypeScript.IntegerUtilities = IntegerUtilities;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var MathPrototype = (function () {
        function MathPrototype() {
        }
        MathPrototype.max = function (a, b) {
            return a >= b ? a : b;
        };

        MathPrototype.min = function (a, b) {
            return a <= b ? a : b;
        };
        return MathPrototype;
    })();
    TypeScript.MathPrototype = MathPrototype;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Collections) {
        Collections.DefaultStringTableCapacity = 256;

        var StringTableEntry = (function () {
            function StringTableEntry(Text, HashCode, Next) {
                this.Text = Text;
                this.HashCode = HashCode;
                this.Next = Next;
            }
            return StringTableEntry;
        })();

        var StringTable = (function () {
            function StringTable(capacity) {
                this.entries = [];
                this.count = 0;
                var size = TypeScript.Hash.getPrime(capacity);
                this.entries = TypeScript.ArrayUtilities.createArray(size, null);
            }
            StringTable.prototype.addCharArray = function (key, start, len) {
                var hashCode = TypeScript.Hash.computeSimple31BitCharArrayHashCode(key, start, len) & 0x7FFFFFFF;

                var entry = this.findCharArrayEntry(key, start, len, hashCode);
                if (entry !== null) {
                    return entry.Text;
                }

                var slice = key.slice(start, start + len);
                return this.addEntry(TypeScript.StringUtilities.fromCharCodeArray(slice), hashCode);
            };

            StringTable.prototype.findCharArrayEntry = function (key, start, len, hashCode) {
                for (var e = this.entries[hashCode % this.entries.length]; e !== null; e = e.Next) {
                    if (e.HashCode === hashCode && StringTable.textCharArrayEquals(e.Text, key, start, len)) {
                        return e;
                    }
                }

                return null;
            };

            StringTable.prototype.addEntry = function (text, hashCode) {
                var index = hashCode % this.entries.length;

                var e = new StringTableEntry(text, hashCode, this.entries[index]);

                this.entries[index] = e;

                if (this.count === this.entries.length) {
                    this.grow();
                }

                this.count++;
                return e.Text;
            };

            StringTable.prototype.grow = function () {
                var newSize = TypeScript.Hash.expandPrime(this.entries.length);

                var oldEntries = this.entries;
                var newEntries = TypeScript.ArrayUtilities.createArray(newSize, null);

                this.entries = newEntries;

                for (var i = 0; i < oldEntries.length; i++) {
                    var e = oldEntries[i];
                    while (e !== null) {
                        var newIndex = e.HashCode % newSize;
                        var tmp = e.Next;
                        e.Next = newEntries[newIndex];
                        newEntries[newIndex] = e;
                        e = tmp;
                    }
                }
            };

            StringTable.textCharArrayEquals = function (text, array, start, length) {
                if (text.length !== length) {
                    return false;
                }

                var s = start;
                for (var i = 0; i < length; i++) {
                    if (text.charCodeAt(i) !== array[s]) {
                        return false;
                    }

                    s++;
                }

                return true;
            };
            return StringTable;
        })();
        Collections.StringTable = StringTable;

        Collections.DefaultStringTable = new StringTable(Collections.DefaultStringTableCapacity);
    })(TypeScript.Collections || (TypeScript.Collections = {}));
    var Collections = TypeScript.Collections;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var StringUtilities = (function () {
        function StringUtilities() {
        }
        StringUtilities.isString = function (value) {
            return Object.prototype.toString.apply(value, []) === '[object String]';
        };

        StringUtilities.fromCharCodeArray = function (array) {
            return String.fromCharCode.apply(null, array);
        };

        StringUtilities.endsWith = function (string, value) {
            return string.substring(string.length - value.length, string.length) === value;
        };

        StringUtilities.startsWith = function (string, value) {
            return string.substr(0, value.length) === value;
        };

        StringUtilities.copyTo = function (source, sourceIndex, destination, destinationIndex, count) {
            for (var i = 0; i < count; i++) {
                destination[destinationIndex + i] = source.charCodeAt(sourceIndex + i);
            }
        };

        StringUtilities.repeat = function (value, count) {
            return Array(count + 1).join(value);
        };

        StringUtilities.stringEquals = function (val1, val2) {
            return val1 === val2;
        };
        return StringUtilities;
    })();
    TypeScript.StringUtilities = StringUtilities;
})(TypeScript || (TypeScript = {}));
var global = Function("return this").call(null);

var TypeScript;
(function (TypeScript) {
    var Clock;
    (function (Clock) {
        Clock.now;
        Clock.resolution;

        if (typeof WScript !== "undefined" && typeof global['WScript'].InitializeProjection !== "undefined") {
            global['WScript'].InitializeProjection();

            Clock.now = function () {
                return TestUtilities.QueryPerformanceCounter();
            };

            Clock.resolution = TestUtilities.QueryPerformanceFrequency();
        } else {
            Clock.now = function () {
                return Date.now();
            };

            Clock.resolution = 1000;
        }
    })(Clock || (Clock = {}));

    var Timer = (function () {
        function Timer() {
            this.time = 0;
        }
        Timer.prototype.start = function () {
            this.time = 0;
            this.startTime = Clock.now();
        };

        Timer.prototype.end = function () {
            this.time = (Clock.now() - this.startTime);
        };
        return Timer;
    })();
    TypeScript.Timer = Timer;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (CharacterCodes) {
        CharacterCodes[CharacterCodes["nullCharacter"] = 0] = "nullCharacter";
        CharacterCodes[CharacterCodes["maxAsciiCharacter"] = 127] = "maxAsciiCharacter";

        CharacterCodes[CharacterCodes["lineFeed"] = 10] = "lineFeed";
        CharacterCodes[CharacterCodes["carriageReturn"] = 13] = "carriageReturn";
        CharacterCodes[CharacterCodes["lineSeparator"] = 0x2028] = "lineSeparator";
        CharacterCodes[CharacterCodes["paragraphSeparator"] = 0x2029] = "paragraphSeparator";

        CharacterCodes[CharacterCodes["nextLine"] = 0x0085] = "nextLine";

        CharacterCodes[CharacterCodes["space"] = 0x0020] = "space";
        CharacterCodes[CharacterCodes["nonBreakingSpace"] = 0x00A0] = "nonBreakingSpace";
        CharacterCodes[CharacterCodes["enQuad"] = 0x2000] = "enQuad";
        CharacterCodes[CharacterCodes["emQuad"] = 0x2001] = "emQuad";
        CharacterCodes[CharacterCodes["enSpace"] = 0x2002] = "enSpace";
        CharacterCodes[CharacterCodes["emSpace"] = 0x2003] = "emSpace";
        CharacterCodes[CharacterCodes["threePerEmSpace"] = 0x2004] = "threePerEmSpace";
        CharacterCodes[CharacterCodes["fourPerEmSpace"] = 0x2005] = "fourPerEmSpace";
        CharacterCodes[CharacterCodes["sixPerEmSpace"] = 0x2006] = "sixPerEmSpace";
        CharacterCodes[CharacterCodes["figureSpace"] = 0x2007] = "figureSpace";
        CharacterCodes[CharacterCodes["punctuationSpace"] = 0x2008] = "punctuationSpace";
        CharacterCodes[CharacterCodes["thinSpace"] = 0x2009] = "thinSpace";
        CharacterCodes[CharacterCodes["hairSpace"] = 0x200A] = "hairSpace";
        CharacterCodes[CharacterCodes["zeroWidthSpace"] = 0x200B] = "zeroWidthSpace";
        CharacterCodes[CharacterCodes["narrowNoBreakSpace"] = 0x202F] = "narrowNoBreakSpace";
        CharacterCodes[CharacterCodes["ideographicSpace"] = 0x3000] = "ideographicSpace";

        CharacterCodes[CharacterCodes["_"] = 95] = "_";
        CharacterCodes[CharacterCodes["$"] = 36] = "$";

        CharacterCodes[CharacterCodes["_0"] = 48] = "_0";
        CharacterCodes[CharacterCodes["_9"] = 57] = "_9";

        CharacterCodes[CharacterCodes["a"] = 97] = "a";
        CharacterCodes[CharacterCodes["b"] = 98] = "b";
        CharacterCodes[CharacterCodes["c"] = 99] = "c";
        CharacterCodes[CharacterCodes["d"] = 100] = "d";
        CharacterCodes[CharacterCodes["e"] = 101] = "e";
        CharacterCodes[CharacterCodes["f"] = 102] = "f";
        CharacterCodes[CharacterCodes["g"] = 103] = "g";
        CharacterCodes[CharacterCodes["h"] = 104] = "h";
        CharacterCodes[CharacterCodes["i"] = 105] = "i";
        CharacterCodes[CharacterCodes["k"] = 107] = "k";
        CharacterCodes[CharacterCodes["l"] = 108] = "l";
        CharacterCodes[CharacterCodes["m"] = 109] = "m";
        CharacterCodes[CharacterCodes["n"] = 110] = "n";
        CharacterCodes[CharacterCodes["o"] = 111] = "o";
        CharacterCodes[CharacterCodes["p"] = 112] = "p";
        CharacterCodes[CharacterCodes["q"] = 113] = "q";
        CharacterCodes[CharacterCodes["r"] = 114] = "r";
        CharacterCodes[CharacterCodes["s"] = 115] = "s";
        CharacterCodes[CharacterCodes["t"] = 116] = "t";
        CharacterCodes[CharacterCodes["u"] = 117] = "u";
        CharacterCodes[CharacterCodes["v"] = 118] = "v";
        CharacterCodes[CharacterCodes["w"] = 119] = "w";
        CharacterCodes[CharacterCodes["x"] = 120] = "x";
        CharacterCodes[CharacterCodes["y"] = 121] = "y";
        CharacterCodes[CharacterCodes["z"] = 122] = "z";

        CharacterCodes[CharacterCodes["A"] = 65] = "A";
        CharacterCodes[CharacterCodes["E"] = 69] = "E";
        CharacterCodes[CharacterCodes["F"] = 70] = "F";
        CharacterCodes[CharacterCodes["X"] = 88] = "X";
        CharacterCodes[CharacterCodes["Z"] = 90] = "Z";

        CharacterCodes[CharacterCodes["ampersand"] = 38] = "ampersand";
        CharacterCodes[CharacterCodes["asterisk"] = 42] = "asterisk";
        CharacterCodes[CharacterCodes["at"] = 64] = "at";
        CharacterCodes[CharacterCodes["backslash"] = 92] = "backslash";
        CharacterCodes[CharacterCodes["bar"] = 124] = "bar";
        CharacterCodes[CharacterCodes["caret"] = 94] = "caret";
        CharacterCodes[CharacterCodes["closeBrace"] = 125] = "closeBrace";
        CharacterCodes[CharacterCodes["closeBracket"] = 93] = "closeBracket";
        CharacterCodes[CharacterCodes["closeParen"] = 41] = "closeParen";
        CharacterCodes[CharacterCodes["colon"] = 58] = "colon";
        CharacterCodes[CharacterCodes["comma"] = 44] = "comma";
        CharacterCodes[CharacterCodes["dot"] = 46] = "dot";
        CharacterCodes[CharacterCodes["doubleQuote"] = 34] = "doubleQuote";
        CharacterCodes[CharacterCodes["equals"] = 61] = "equals";
        CharacterCodes[CharacterCodes["exclamation"] = 33] = "exclamation";
        CharacterCodes[CharacterCodes["greaterThan"] = 62] = "greaterThan";
        CharacterCodes[CharacterCodes["lessThan"] = 60] = "lessThan";
        CharacterCodes[CharacterCodes["minus"] = 45] = "minus";
        CharacterCodes[CharacterCodes["openBrace"] = 123] = "openBrace";
        CharacterCodes[CharacterCodes["openBracket"] = 91] = "openBracket";
        CharacterCodes[CharacterCodes["openParen"] = 40] = "openParen";
        CharacterCodes[CharacterCodes["percent"] = 37] = "percent";
        CharacterCodes[CharacterCodes["plus"] = 43] = "plus";
        CharacterCodes[CharacterCodes["question"] = 63] = "question";
        CharacterCodes[CharacterCodes["semicolon"] = 59] = "semicolon";
        CharacterCodes[CharacterCodes["singleQuote"] = 39] = "singleQuote";
        CharacterCodes[CharacterCodes["slash"] = 47] = "slash";
        CharacterCodes[CharacterCodes["tilde"] = 126] = "tilde";

        CharacterCodes[CharacterCodes["backspace"] = 8] = "backspace";
        CharacterCodes[CharacterCodes["formFeed"] = 12] = "formFeed";
        CharacterCodes[CharacterCodes["byteOrderMark"] = 0xFEFF] = "byteOrderMark";
        CharacterCodes[CharacterCodes["tab"] = 9] = "tab";
        CharacterCodes[CharacterCodes["verticalTab"] = 11] = "verticalTab";
    })(TypeScript.CharacterCodes || (TypeScript.CharacterCodes = {}));
    var CharacterCodes = TypeScript.CharacterCodes;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (ScriptSnapshot) {
        var StringScriptSnapshot = (function () {
            function StringScriptSnapshot(text) {
                this.text = text;
            }
            StringScriptSnapshot.prototype.getText = function (start, end) {
                return this.text.substring(start, end);
            };

            StringScriptSnapshot.prototype.getLength = function () {
                return this.text.length;
            };

            StringScriptSnapshot.prototype.getLineStartPositions = function () {
                return TypeScript.TextUtilities.parseLineStarts(TypeScript.SimpleText.fromString(this.text));
            };

            StringScriptSnapshot.prototype.getTextChangeRangeSinceVersion = function (scriptVersion) {
                throw TypeScript.Errors.notYetImplemented();
            };
            return StringScriptSnapshot;
        })();

        function fromString(text) {
            return new StringScriptSnapshot(text);
        }
        ScriptSnapshot.fromString = fromString;
    })(TypeScript.ScriptSnapshot || (TypeScript.ScriptSnapshot = {}));
    var ScriptSnapshot = TypeScript.ScriptSnapshot;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var LineMap = (function () {
        function LineMap(_lineStarts, length) {
            this._lineStarts = _lineStarts;
            this.length = length;
        }
        LineMap.prototype.toJSON = function (key) {
            return { lineStarts: this._lineStarts, length: this.length };
        };

        LineMap.prototype.equals = function (other) {
            return this.length === other.length && TypeScript.ArrayUtilities.sequenceEquals(this.lineStarts(), other.lineStarts(), function (v1, v2) {
                return v1 === v2;
            });
        };

        LineMap.prototype.lineStarts = function () {
            return this._lineStarts;
        };

        LineMap.prototype.lineCount = function () {
            return this.lineStarts().length;
        };

        LineMap.prototype.getPosition = function (line, character) {
            return this.lineStarts()[line] + character;
        };

        LineMap.prototype.getLineNumberFromPosition = function (position) {
            if (position < 0 || position > this.length) {
                throw TypeScript.Errors.argumentOutOfRange("position");
            }

            if (position === this.length) {
                return this.lineCount() - 1;
            }

            var lineNumber = TypeScript.ArrayUtilities.binarySearch(this.lineStarts(), position);
            if (lineNumber < 0) {
                lineNumber = (~lineNumber) - 1;
            }

            return lineNumber;
        };

        LineMap.prototype.getLineStartPosition = function (lineNumber) {
            return this.lineStarts()[lineNumber];
        };

        LineMap.prototype.fillLineAndCharacterFromPosition = function (position, lineAndCharacter) {
            if (position < 0 || position > this.length) {
                throw TypeScript.Errors.argumentOutOfRange("position");
            }

            var lineNumber = this.getLineNumberFromPosition(position);
            lineAndCharacter.line = lineNumber;
            lineAndCharacter.character = position - this.lineStarts()[lineNumber];
        };

        LineMap.prototype.getLineAndCharacterFromPosition = function (position) {
            if (position < 0 || position > this.length) {
                throw TypeScript.Errors.argumentOutOfRange("position");
            }

            var lineNumber = this.getLineNumberFromPosition(position);

            return new TypeScript.LineAndCharacter(lineNumber, position - this.lineStarts()[lineNumber]);
        };

        LineMap.fromSimpleText = function (text) {
            var lineStarts = TypeScript.TextUtilities.parseLineStarts(text);

            return new LineMap(lineStarts, text.length());
        };

        LineMap.fromScriptSnapshot = function (scriptSnapshot) {
            return new LineMap(scriptSnapshot.getLineStartPositions(), scriptSnapshot.getLength());
        };

        LineMap.fromString = function (text) {
            return LineMap.fromSimpleText(TypeScript.SimpleText.fromString(text));
        };
        LineMap.empty = new LineMap([0], 0);
        return LineMap;
    })();
    TypeScript.LineMap = LineMap;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var LineAndCharacter = (function () {
        function LineAndCharacter(line, character) {
            this._line = 0;
            this._character = 0;
            if (line < 0) {
                throw TypeScript.Errors.argumentOutOfRange("line");
            }

            if (character < 0) {
                throw TypeScript.Errors.argumentOutOfRange("character");
            }

            this._line = line;
            this._character = character;
        }
        LineAndCharacter.prototype.line = function () {
            return this._line;
        };

        LineAndCharacter.prototype.character = function () {
            return this._character;
        };
        return LineAndCharacter;
    })();
    TypeScript.LineAndCharacter = LineAndCharacter;
})(TypeScript || (TypeScript = {}));
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var TypeScript;
(function (TypeScript) {
    (function (TextFactory) {
        function getStartAndLengthOfLineBreakEndingAt(text, index, info) {
            var c = text.charCodeAt(index);
            if (c === 10 /* lineFeed */) {
                if (index > 0 && text.charCodeAt(index - 1) === 13 /* carriageReturn */) {
                    info.startPosition = index - 1;
                    info.length = 2;
                } else {
                    info.startPosition = index;
                    info.length = 1;
                }
            } else if (TypeScript.TextUtilities.isAnyLineBreakCharacter(c)) {
                info.startPosition = index;
                info.length = 1;
            } else {
                info.startPosition = index + 1;
                info.length = 0;
            }
        }

        var LinebreakInfo = (function () {
            function LinebreakInfo(startPosition, length) {
                this.startPosition = startPosition;
                this.length = length;
            }
            return LinebreakInfo;
        })();

        var TextLine = (function () {
            function TextLine(text, body, lineBreakLength, lineNumber) {
                this._text = null;
                this._textSpan = null;
                TypeScript.Contract.throwIfNull(text);
                TypeScript.Contract.throwIfFalse(lineBreakLength >= 0);
                TypeScript.Contract.requires(lineNumber >= 0);
                this._text = text;
                this._textSpan = body;
                this._lineBreakLength = lineBreakLength;
                this._lineNumber = lineNumber;
            }
            TextLine.prototype.start = function () {
                return this._textSpan.start();
            };

            TextLine.prototype.end = function () {
                return this._textSpan.end();
            };

            TextLine.prototype.endIncludingLineBreak = function () {
                return this.end() + this._lineBreakLength;
            };

            TextLine.prototype.extent = function () {
                return this._textSpan;
            };

            TextLine.prototype.extentIncludingLineBreak = function () {
                return TypeScript.TextSpan.fromBounds(this.start(), this.endIncludingLineBreak());
            };

            TextLine.prototype.toString = function () {
                return this._text.toString(this._textSpan);
            };

            TextLine.prototype.lineNumber = function () {
                return this._lineNumber;
            };
            return TextLine;
        })();

        var TextBase = (function () {
            function TextBase() {
                this.lazyLineStarts = null;
                this.linebreakInfo = new LinebreakInfo(0, 0);
                this.lastLineFoundForPosition = null;
            }
            TextBase.prototype.length = function () {
                throw TypeScript.Errors.abstract();
            };

            TextBase.prototype.charCodeAt = function (position) {
                throw TypeScript.Errors.abstract();
            };

            TextBase.prototype.checkSubSpan = function (span) {
                if (span.start() < 0 || span.start() > this.length() || span.end() > this.length()) {
                    throw TypeScript.Errors.argumentOutOfRange("span");
                }
            };

            TextBase.prototype.toString = function (span) {
                if (typeof span === "undefined") { span = null; }
                throw TypeScript.Errors.abstract();
            };

            TextBase.prototype.subText = function (span) {
                this.checkSubSpan(span);

                return new SubText(this, span);
            };

            TextBase.prototype.substr = function (start, length, intern) {
                throw TypeScript.Errors.abstract();
            };

            TextBase.prototype.copyTo = function (sourceIndex, destination, destinationIndex, count) {
                throw TypeScript.Errors.abstract();
            };

            TextBase.prototype.lineCount = function () {
                return this.lineStarts().length;
            };

            TextBase.prototype.lines = function () {
                var lines = [];

                var length = this.lineCount();
                for (var i = 0; i < length; ++i) {
                    lines[i] = this.getLineFromLineNumber(i);
                }

                return lines;
            };

            TextBase.prototype.lineMap = function () {
                return new TypeScript.LineMap(this.lineStarts(), this.length());
            };

            TextBase.prototype.lineStarts = function () {
                if (this.lazyLineStarts === null) {
                    this.lazyLineStarts = TypeScript.TextUtilities.parseLineStarts(this);
                }

                return this.lazyLineStarts;
            };

            TextBase.prototype.getLineFromLineNumber = function (lineNumber) {
                var lineStarts = this.lineStarts();

                if (lineNumber < 0 || lineNumber >= lineStarts.length) {
                    throw TypeScript.Errors.argumentOutOfRange("lineNumber");
                }

                var first = lineStarts[lineNumber];
                if (lineNumber === lineStarts.length - 1) {
                    return new TextLine(this, new TypeScript.TextSpan(first, this.length() - first), 0, lineNumber);
                } else {
                    getStartAndLengthOfLineBreakEndingAt(this, lineStarts[lineNumber + 1] - 1, this.linebreakInfo);
                    return new TextLine(this, new TypeScript.TextSpan(first, this.linebreakInfo.startPosition - first), this.linebreakInfo.length, lineNumber);
                }
            };

            TextBase.prototype.getLineFromPosition = function (position) {
                var lastFound = this.lastLineFoundForPosition;
                if (lastFound !== null && lastFound.start() <= position && lastFound.endIncludingLineBreak() > position) {
                    return lastFound;
                }

                var lineNumber = this.getLineNumberFromPosition(position);

                var result = this.getLineFromLineNumber(lineNumber);
                this.lastLineFoundForPosition = result;
                return result;
            };

            TextBase.prototype.getLineNumberFromPosition = function (position) {
                if (position < 0 || position > this.length()) {
                    throw TypeScript.Errors.argumentOutOfRange("position");
                }

                if (position === this.length()) {
                    return this.lineCount() - 1;
                }

                var lineNumber = TypeScript.ArrayUtilities.binarySearch(this.lineStarts(), position);
                if (lineNumber < 0) {
                    lineNumber = (~lineNumber) - 1;
                }

                return lineNumber;
            };

            TextBase.prototype.getLinePosition = function (position) {
                if (position < 0 || position > this.length()) {
                    throw TypeScript.Errors.argumentOutOfRange("position");
                }

                var lineNumber = this.getLineNumberFromPosition(position);

                return new TypeScript.LineAndCharacter(lineNumber, position - this.lineStarts()[lineNumber]);
            };
            return TextBase;
        })();

        var SubText = (function (_super) {
            __extends(SubText, _super);
            function SubText(text, span) {
                _super.call(this);

                if (text === null) {
                    throw TypeScript.Errors.argumentNull("text");
                }

                if (span.start() < 0 || span.start() >= text.length() || span.end() < 0 || span.end() > text.length()) {
                    throw TypeScript.Errors.argument("span");
                }

                this.text = text;
                this.span = span;
            }
            SubText.prototype.length = function () {
                return this.span.length();
            };

            SubText.prototype.charCodeAt = function (position) {
                if (position < 0 || position > this.length()) {
                    throw TypeScript.Errors.argumentOutOfRange("position");
                }

                return this.text.charCodeAt(this.span.start() + position);
            };

            SubText.prototype.subText = function (span) {
                this.checkSubSpan(span);

                return new SubText(this.text, this.getCompositeSpan(span.start(), span.length()));
            };

            SubText.prototype.copyTo = function (sourceIndex, destination, destinationIndex, count) {
                var span = this.getCompositeSpan(sourceIndex, count);
                this.text.copyTo(span.start(), destination, destinationIndex, span.length());
            };

            SubText.prototype.getCompositeSpan = function (start, length) {
                var compositeStart = TypeScript.MathPrototype.min(this.text.length(), this.span.start() + start);
                var compositeEnd = TypeScript.MathPrototype.min(this.text.length(), compositeStart + length);
                return new TypeScript.TextSpan(compositeStart, compositeEnd - compositeStart);
            };
            return SubText;
        })(TextBase);

        var StringText = (function (_super) {
            __extends(StringText, _super);
            function StringText(data) {
                _super.call(this);
                this.source = null;

                if (data === null) {
                    throw TypeScript.Errors.argumentNull("data");
                }

                this.source = data;
            }
            StringText.prototype.length = function () {
                return this.source.length;
            };

            StringText.prototype.charCodeAt = function (position) {
                if (position < 0 || position >= this.source.length) {
                    throw TypeScript.Errors.argumentOutOfRange("position");
                }

                return this.source.charCodeAt(position);
            };

            StringText.prototype.substr = function (start, length, intern) {
                return this.source.substr(start, length);
            };

            StringText.prototype.toString = function (span) {
                if (typeof span === "undefined") { span = null; }
                if (span === null) {
                    span = new TypeScript.TextSpan(0, this.length());
                }

                this.checkSubSpan(span);

                if (span.start() === 0 && span.length() === this.length()) {
                    return this.source;
                }

                return this.source.substr(span.start(), span.length());
            };

            StringText.prototype.copyTo = function (sourceIndex, destination, destinationIndex, count) {
                TypeScript.StringUtilities.copyTo(this.source, sourceIndex, destination, destinationIndex, count);
            };
            return StringText;
        })(TextBase);

        function createText(value) {
            return new StringText(value);
        }
        TextFactory.createText = createText;
    })(TypeScript.TextFactory || (TypeScript.TextFactory = {}));
    var TextFactory = TypeScript.TextFactory;
})(TypeScript || (TypeScript = {}));

var TypeScript;
(function (TypeScript) {
    (function (SimpleText) {
        var SimpleSubText = (function () {
            function SimpleSubText(text, span) {
                this.text = null;
                this.span = null;
                if (text === null) {
                    throw TypeScript.Errors.argumentNull("text");
                }

                if (span.start() < 0 || span.start() >= text.length() || span.end() < 0 || span.end() > text.length()) {
                    throw TypeScript.Errors.argument("span");
                }

                this.text = text;
                this.span = span;
            }
            SimpleSubText.prototype.checkSubSpan = function (span) {
                if (span.start() < 0 || span.start() > this.length() || span.end() > this.length()) {
                    throw TypeScript.Errors.argumentOutOfRange("span");
                }
            };

            SimpleSubText.prototype.checkSubPosition = function (position) {
                if (position < 0 || position >= this.length()) {
                    throw TypeScript.Errors.argumentOutOfRange("position");
                }
            };

            SimpleSubText.prototype.length = function () {
                return this.span.length();
            };

            SimpleSubText.prototype.subText = function (span) {
                this.checkSubSpan(span);

                return new SimpleSubText(this.text, this.getCompositeSpan(span.start(), span.length()));
            };

            SimpleSubText.prototype.copyTo = function (sourceIndex, destination, destinationIndex, count) {
                var span = this.getCompositeSpan(sourceIndex, count);
                this.text.copyTo(span.start(), destination, destinationIndex, span.length());
            };

            SimpleSubText.prototype.substr = function (start, length, intern) {
                var span = this.getCompositeSpan(start, length);
                return this.text.substr(span.start(), span.length(), intern);
            };

            SimpleSubText.prototype.getCompositeSpan = function (start, length) {
                var compositeStart = TypeScript.MathPrototype.min(this.text.length(), this.span.start() + start);
                var compositeEnd = TypeScript.MathPrototype.min(this.text.length(), compositeStart + length);
                return new TypeScript.TextSpan(compositeStart, compositeEnd - compositeStart);
            };

            SimpleSubText.prototype.charCodeAt = function (index) {
                this.checkSubPosition(index);
                return this.text.charCodeAt(this.span.start() + index);
            };

            SimpleSubText.prototype.lineMap = function () {
                return TypeScript.LineMap.fromSimpleText(this);
            };
            return SimpleSubText;
        })();

        var SimpleStringText = (function () {
            function SimpleStringText(value) {
                this.value = value;
            }
            SimpleStringText.prototype.length = function () {
                return this.value.length;
            };

            SimpleStringText.prototype.copyTo = function (sourceIndex, destination, destinationIndex, count) {
                TypeScript.StringUtilities.copyTo(this.value, sourceIndex, destination, destinationIndex, count);
            };

            SimpleStringText.prototype.substr = function (start, length, intern) {
                if (intern) {
                    var array = length <= SimpleStringText.charArray.length ? SimpleStringText.charArray : TypeScript.ArrayUtilities.createArray(length, 0);
                    this.copyTo(start, array, 0, length);
                    return TypeScript.Collections.DefaultStringTable.addCharArray(array, 0, length);
                }

                return this.value.substr(start, length);
            };

            SimpleStringText.prototype.subText = function (span) {
                return new SimpleSubText(this, span);
            };

            SimpleStringText.prototype.charCodeAt = function (index) {
                return this.value.charCodeAt(index);
            };

            SimpleStringText.prototype.lineMap = function () {
                return TypeScript.LineMap.fromSimpleText(this);
            };
            SimpleStringText.charArray = TypeScript.ArrayUtilities.createArray(1024, 0);
            return SimpleStringText;
        })();

        var SimpleScriptSnapshotText = (function () {
            function SimpleScriptSnapshotText(scriptSnapshot) {
                this.scriptSnapshot = scriptSnapshot;
            }
            SimpleScriptSnapshotText.prototype.charCodeAt = function (index) {
                return this.scriptSnapshot.getText(index, index + 1).charCodeAt(0);
            };

            SimpleScriptSnapshotText.prototype.length = function () {
                return this.scriptSnapshot.getLength();
            };

            SimpleScriptSnapshotText.prototype.copyTo = function (sourceIndex, destination, destinationIndex, count) {
                var text = this.scriptSnapshot.getText(sourceIndex, sourceIndex + count);
                TypeScript.StringUtilities.copyTo(text, 0, destination, destinationIndex, count);
            };

            SimpleScriptSnapshotText.prototype.substr = function (start, length, intern) {
                return this.scriptSnapshot.getText(start, start + length);
            };

            SimpleScriptSnapshotText.prototype.subText = function (span) {
                return new SimpleSubText(this, span);
            };

            SimpleScriptSnapshotText.prototype.lineMap = function () {
                var lineStartPositions = this.scriptSnapshot.getLineStartPositions();
                return new TypeScript.LineMap(lineStartPositions, this.length());
            };
            return SimpleScriptSnapshotText;
        })();

        function fromString(value) {
            return new SimpleStringText(value);
        }
        SimpleText.fromString = fromString;

        function fromScriptSnapshot(scriptSnapshot) {
            return new SimpleScriptSnapshotText(scriptSnapshot);
        }
        SimpleText.fromScriptSnapshot = fromScriptSnapshot;
    })(TypeScript.SimpleText || (TypeScript.SimpleText = {}));
    var SimpleText = TypeScript.SimpleText;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (TextUtilities) {
        function parseLineStarts(text) {
            var length = text.length();

            if (0 === length) {
                var result = [];
                result.push(0);
                return result;
            }

            var position = 0;
            var index = 0;
            var arrayBuilder = [];
            var lineNumber = 0;

            while (index < length) {
                var c = text.charCodeAt(index);
                var lineBreakLength;

                if (c > 13 /* carriageReturn */ && c <= 127) {
                    index++;
                    continue;
                } else if (c === 13 /* carriageReturn */ && index + 1 < length && text.charCodeAt(index + 1) === 10 /* lineFeed */) {
                    lineBreakLength = 2;
                } else if (c === 10 /* lineFeed */) {
                    lineBreakLength = 1;
                } else {
                    lineBreakLength = TextUtilities.getLengthOfLineBreak(text, index);
                }

                if (0 === lineBreakLength) {
                    index++;
                } else {
                    arrayBuilder.push(position);
                    index += lineBreakLength;
                    position = index;
                    lineNumber++;
                }
            }

            arrayBuilder.push(position);

            return arrayBuilder;
        }
        TextUtilities.parseLineStarts = parseLineStarts;

        function getLengthOfLineBreakSlow(text, index, c) {
            if (c === 13 /* carriageReturn */) {
                var next = index + 1;
                return (next < text.length()) && 10 /* lineFeed */ === text.charCodeAt(next) ? 2 : 1;
            } else if (isAnyLineBreakCharacter(c)) {
                return 1;
            } else {
                return 0;
            }
        }
        TextUtilities.getLengthOfLineBreakSlow = getLengthOfLineBreakSlow;

        function getLengthOfLineBreak(text, index) {
            var c = text.charCodeAt(index);

            if (c > 13 /* carriageReturn */ && c <= 127) {
                return 0;
            }

            return getLengthOfLineBreakSlow(text, index, c);
        }
        TextUtilities.getLengthOfLineBreak = getLengthOfLineBreak;

        function isAnyLineBreakCharacter(c) {
            return c === 10 /* lineFeed */ || c === 13 /* carriageReturn */ || c === 133 /* nextLine */ || c === 8232 /* lineSeparator */ || c === 8233 /* paragraphSeparator */;
        }
        TextUtilities.isAnyLineBreakCharacter = isAnyLineBreakCharacter;
    })(TypeScript.TextUtilities || (TypeScript.TextUtilities = {}));
    var TextUtilities = TypeScript.TextUtilities;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var TextSpan = (function () {
        function TextSpan(start, length) {
            if (start < 0) {
                TypeScript.Errors.argument("start");
            }

            if (start + length < start) {
                throw new Error("length");
            }

            this._start = start;
            this._length = length;
        }
        TextSpan.prototype.start = function () {
            return this._start;
        };

        TextSpan.prototype.length = function () {
            return this._length;
        };

        TextSpan.prototype.end = function () {
            return this._start + this._length;
        };

        TextSpan.prototype.isEmpty = function () {
            return this._length === 0;
        };

        TextSpan.prototype.containsPosition = function (position) {
            return position >= this._start && position < this.end();
        };

        TextSpan.prototype.containsTextSpan = function (span) {
            return span._start >= this._start && span.end() <= this.end();
        };

        TextSpan.prototype.overlapsWith = function (span) {
            var overlapStart = TypeScript.MathPrototype.max(this._start, span._start);
            var overlapEnd = TypeScript.MathPrototype.min(this.end(), span.end());

            return overlapStart < overlapEnd;
        };

        TextSpan.prototype.overlap = function (span) {
            var overlapStart = TypeScript.MathPrototype.max(this._start, span._start);
            var overlapEnd = TypeScript.MathPrototype.min(this.end(), span.end());

            if (overlapStart < overlapEnd) {
                return TextSpan.fromBounds(overlapStart, overlapEnd);
            }

            return null;
        };

        TextSpan.prototype.intersectsWithTextSpan = function (span) {
            return span._start <= this.end() && span.end() >= this._start;
        };

        TextSpan.prototype.intersectsWith = function (start, length) {
            var end = start + length;
            return start <= this.end() && end >= this._start;
        };

        TextSpan.prototype.intersectsWithPosition = function (position) {
            return position <= this.end() && position >= this._start;
        };

        TextSpan.prototype.intersection = function (span) {
            var intersectStart = TypeScript.MathPrototype.max(this._start, span._start);
            var intersectEnd = TypeScript.MathPrototype.min(this.end(), span.end());

            if (intersectStart <= intersectEnd) {
                return TextSpan.fromBounds(intersectStart, intersectEnd);
            }

            return null;
        };

        TextSpan.fromBounds = function (start, end) {
            TypeScript.Contract.requires(start >= 0);
            TypeScript.Contract.requires(end - start >= 0);
            return new TextSpan(start, end - start);
        };
        return TextSpan;
    })();
    TypeScript.TextSpan = TextSpan;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var TextChangeRange = (function () {
        function TextChangeRange(span, newLength) {
            if (newLength < 0) {
                throw TypeScript.Errors.argumentOutOfRange("newLength");
            }

            this._span = span;
            this._newLength = newLength;
        }
        TextChangeRange.prototype.span = function () {
            return this._span;
        };

        TextChangeRange.prototype.newLength = function () {
            return this._newLength;
        };

        TextChangeRange.prototype.newSpan = function () {
            return new TypeScript.TextSpan(this.span().start(), this.newLength());
        };

        TextChangeRange.prototype.isUnchanged = function () {
            return this.span().isEmpty() && this.newLength() === 0;
        };

        TextChangeRange.collapseChangesFromSingleVersion = function (changes) {
            var diff = 0;
            var start = 1073741823 /* Max31BitInteger */;
            var end = 0;

            for (var i = 0; i < changes.length; i++) {
                var change = changes[i];
                diff += change.newLength() - change.span().length();

                if (change.span().start() < start) {
                    start = change.span().start();
                }

                if (change.span().end() > end) {
                    end = change.span().end();
                }
            }

            if (start > end) {
                return null;
            }

            var combined = TypeScript.TextSpan.fromBounds(start, end);
            var newLen = combined.length() + diff;

            return new TextChangeRange(combined, newLen);
        };

        TextChangeRange.collapseChangesAcrossMultipleVersions = function (changes) {
            if (changes.length === 0) {
                return TextChangeRange.unchanged;
            }

            if (changes.length === 1) {
                return changes[0];
            }

            var change0 = changes[0];

            var oldStartN = change0.span().start();
            var oldEndN = change0.span().end();
            var newEndN = oldStartN + change0.newLength();

            for (var i = 1; i < changes.length; i++) {
                var nextChange = changes[i];

                var oldStart1 = oldStartN;
                var oldEnd1 = oldEndN;
                var newEnd1 = newEndN;

                var oldStart2 = nextChange.span().start();
                var oldEnd2 = nextChange.span().end();
                var newEnd2 = oldStart2 + nextChange.newLength();

                oldStartN = TypeScript.MathPrototype.min(oldStart1, oldStart2);
                oldEndN = TypeScript.MathPrototype.max(oldEnd1, oldEnd1 + (oldEnd2 - newEnd1));
                newEndN = TypeScript.MathPrototype.max(newEnd2, newEnd2 + (newEnd1 - oldEnd2));
            }

            return new TextChangeRange(TypeScript.TextSpan.fromBounds(oldStartN, oldEndN), newEndN - oldStartN);
        };
        TextChangeRange.unchanged = new TextChangeRange(new TypeScript.TextSpan(0, 0), 0);
        return TextChangeRange;
    })();
    TypeScript.TextChangeRange = TextChangeRange;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var CharacterInfo = (function () {
        function CharacterInfo() {
        }
        CharacterInfo.isDecimalDigit = function (c) {
            return c >= 48 /* _0 */ && c <= 57 /* _9 */;
        };

        CharacterInfo.isHexDigit = function (c) {
            return CharacterInfo.isDecimalDigit(c) || (c >= 65 /* A */ && c <= 70 /* F */) || (c >= 97 /* a */ && c <= 102 /* f */);
        };

        CharacterInfo.hexValue = function (c) {
            return CharacterInfo.isDecimalDigit(c) ? (c - 48 /* _0 */) : (c >= 65 /* A */ && c <= 70 /* F */) ? c - 65 /* A */ + 10 : c - 97 /* a */ + 10;
        };

        CharacterInfo.isWhitespace = function (ch) {
            switch (ch) {
                case 32 /* space */:
                case 160 /* nonBreakingSpace */:
                case 8192 /* enQuad */:
                case 8193 /* emQuad */:
                case 8194 /* enSpace */:
                case 8195 /* emSpace */:
                case 8196 /* threePerEmSpace */:
                case 8197 /* fourPerEmSpace */:
                case 8198 /* sixPerEmSpace */:
                case 8199 /* figureSpace */:
                case 8200 /* punctuationSpace */:
                case 8201 /* thinSpace */:
                case 8202 /* hairSpace */:
                case 8203 /* zeroWidthSpace */:
                case 8239 /* narrowNoBreakSpace */:
                case 12288 /* ideographicSpace */:

                case 9 /* tab */:
                case 11 /* verticalTab */:
                case 12 /* formFeed */:
                case 65279 /* byteOrderMark */:
                    return true;
            }

            return false;
        };

        CharacterInfo.isLineTerminator = function (ch) {
            switch (ch) {
                case 13 /* carriageReturn */:
                case 10 /* lineFeed */:
                case 8233 /* paragraphSeparator */:
                case 8232 /* lineSeparator */:
                    return true;
            }

            return false;
        };
        return CharacterInfo;
    })();
    TypeScript.CharacterInfo = CharacterInfo;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (SyntaxConstants) {
        SyntaxConstants[SyntaxConstants["TriviaNewLineMask"] = 0x00000001] = "TriviaNewLineMask";
        SyntaxConstants[SyntaxConstants["TriviaCommentMask"] = 0x00000002] = "TriviaCommentMask";
        SyntaxConstants[SyntaxConstants["TriviaFullWidthShift"] = 2] = "TriviaFullWidthShift";

        SyntaxConstants[SyntaxConstants["NodeDataComputed"] = 0x00000001] = "NodeDataComputed";
        SyntaxConstants[SyntaxConstants["NodeIncrementallyUnusableMask"] = 0x00000002] = "NodeIncrementallyUnusableMask";
        SyntaxConstants[SyntaxConstants["NodeParsedInStrictModeMask"] = 0x00000004] = "NodeParsedInStrictModeMask";
        SyntaxConstants[SyntaxConstants["NodeFullWidthShift"] = 3] = "NodeFullWidthShift";
    })(TypeScript.SyntaxConstants || (TypeScript.SyntaxConstants = {}));
    var SyntaxConstants = TypeScript.SyntaxConstants;
})(TypeScript || (TypeScript = {}));
var FormattingOptions = (function () {
    function FormattingOptions(useTabs, spacesPerTab, indentSpaces, newLineCharacter) {
        this.useTabs = useTabs;
        this.spacesPerTab = spacesPerTab;
        this.indentSpaces = indentSpaces;
        this.newLineCharacter = newLineCharacter;
    }
    FormattingOptions.defaultOptions = new FormattingOptions(false, 4, 4, "\r\n");
    return FormattingOptions;
})();
var TypeScript;
(function (TypeScript) {
    (function (Indentation) {
        function columnForEndOfToken(token, syntaxInformationMap, options) {
            return columnForStartOfToken(token, syntaxInformationMap, options) + token.width();
        }
        Indentation.columnForEndOfToken = columnForEndOfToken;

        function columnForStartOfToken(token, syntaxInformationMap, options) {
            var firstTokenInLine = syntaxInformationMap.firstTokenInLineContainingToken(token);
            var leadingTextInReverse = [];

            var current = token;
            while (current !== firstTokenInLine) {
                current = syntaxInformationMap.previousToken(current);

                if (current === firstTokenInLine) {
                    leadingTextInReverse.push(current.trailingTrivia().fullText());
                    leadingTextInReverse.push(current.text());
                } else {
                    leadingTextInReverse.push(current.fullText());
                }
            }

            collectLeadingTriviaTextToStartOfLine(firstTokenInLine, leadingTextInReverse);

            return columnForLeadingTextInReverse(leadingTextInReverse, options);
        }
        Indentation.columnForStartOfToken = columnForStartOfToken;

        function columnForStartOfFirstTokenInLineContainingToken(token, syntaxInformationMap, options) {
            var firstTokenInLine = syntaxInformationMap.firstTokenInLineContainingToken(token);
            var leadingTextInReverse = [];

            collectLeadingTriviaTextToStartOfLine(firstTokenInLine, leadingTextInReverse);

            return columnForLeadingTextInReverse(leadingTextInReverse, options);
        }
        Indentation.columnForStartOfFirstTokenInLineContainingToken = columnForStartOfFirstTokenInLineContainingToken;

        function collectLeadingTriviaTextToStartOfLine(firstTokenInLine, leadingTextInReverse) {
            var leadingTrivia = firstTokenInLine.leadingTrivia();

            for (var i = leadingTrivia.count() - 1; i >= 0; i--) {
                var trivia = leadingTrivia.syntaxTriviaAt(i);
                if (trivia.kind() === 5 /* NewLineTrivia */) {
                    break;
                }

                if (trivia.kind() === 6 /* MultiLineCommentTrivia */) {
                    var lineSegments = TypeScript.Syntax.splitMultiLineCommentTriviaIntoMultipleLines(trivia);
                    leadingTextInReverse.push(TypeScript.ArrayUtilities.last(lineSegments));

                    if (lineSegments.length > 0) {
                        break;
                    }
                }

                leadingTextInReverse.push(trivia.fullText());
            }
        }

        function columnForLeadingTextInReverse(leadingTextInReverse, options) {
            var column = 0;

            for (var i = leadingTextInReverse.length - 1; i >= 0; i--) {
                var text = leadingTextInReverse[i];
                column = columnForPositionInStringWorker(text, text.length, column, options);
            }

            return column;
        }

        function columnForPositionInString(input, position, options) {
            return columnForPositionInStringWorker(input, position, 0, options);
        }
        Indentation.columnForPositionInString = columnForPositionInString;

        function columnForPositionInStringWorker(input, position, startColumn, options) {
            var column = startColumn;
            var spacesPerTab = options.spacesPerTab;

            for (var j = 0; j < position; j++) {
                var ch = input.charCodeAt(j);

                if (ch === 9 /* tab */) {
                    column += spacesPerTab - column % spacesPerTab;
                } else {
                    column++;
                }
            }

            return column;
        }

        function indentationString(column, options) {
            var numberOfTabs = 0;
            var numberOfSpaces = TypeScript.MathPrototype.max(0, column);

            if (options.useTabs) {
                numberOfTabs = Math.floor(column / options.spacesPerTab);
                numberOfSpaces -= numberOfTabs * options.spacesPerTab;
            }

            return TypeScript.StringUtilities.repeat('\t', numberOfTabs) + TypeScript.StringUtilities.repeat(' ', numberOfSpaces);
        }
        Indentation.indentationString = indentationString;

        function indentationTrivia(column, options) {
            return TypeScript.Syntax.whitespace(this.indentationString(column, options));
        }
        Indentation.indentationTrivia = indentationTrivia;

        function firstNonWhitespacePosition(value) {
            for (var i = 0; i < value.length; i++) {
                var ch = value.charCodeAt(i);
                if (!TypeScript.CharacterInfo.isWhitespace(ch)) {
                    return i;
                }
            }

            return value.length;
        }
        Indentation.firstNonWhitespacePosition = firstNonWhitespacePosition;
    })(TypeScript.Indentation || (TypeScript.Indentation = {}));
    var Indentation = TypeScript.Indentation;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (LanguageVersion) {
        LanguageVersion[LanguageVersion["EcmaScript3"] = 0] = "EcmaScript3";
        LanguageVersion[LanguageVersion["EcmaScript5"] = 1] = "EcmaScript5";
    })(TypeScript.LanguageVersion || (TypeScript.LanguageVersion = {}));
    var LanguageVersion = TypeScript.LanguageVersion;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var ParseOptions = (function () {
        function ParseOptions(allowAutomaticSemicolonInsertion, allowModuleKeywordInExternalModuleReference) {
            this._allowAutomaticSemicolonInsertion = allowAutomaticSemicolonInsertion;
            this._allowModuleKeywordInExternalModuleReference = allowModuleKeywordInExternalModuleReference;
        }
        ParseOptions.prototype.toJSON = function (key) {
            return {
                allowAutomaticSemicolonInsertion: this._allowAutomaticSemicolonInsertion,
                allowModuleKeywordInExternalModuleReference: this._allowModuleKeywordInExternalModuleReference
            };
        };

        ParseOptions.prototype.allowAutomaticSemicolonInsertion = function () {
            return this._allowAutomaticSemicolonInsertion;
        };

        ParseOptions.prototype.allowModuleKeywordInExternalModuleReference = function () {
            return this._allowModuleKeywordInExternalModuleReference;
        };
        return ParseOptions;
    })();
    TypeScript.ParseOptions = ParseOptions;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var PositionedElement = (function () {
        function PositionedElement(parent, element, fullStart) {
            this._parent = parent;
            this._element = element;
            this._fullStart = fullStart;
        }
        PositionedElement.create = function (parent, element, fullStart) {
            if (element === null) {
                return null;
            }

            if (element.isNode()) {
                return new PositionedNode(parent, element, fullStart);
            } else if (element.isToken()) {
                return new PositionedToken(parent, element, fullStart);
            } else if (element.isList()) {
                return new PositionedList(parent, element, fullStart);
            } else if (element.isSeparatedList()) {
                return new PositionedSeparatedList(parent, element, fullStart);
            } else {
                throw TypeScript.Errors.invalidOperation();
            }
        };

        PositionedElement.prototype.parent = function () {
            return this._parent;
        };

        PositionedElement.prototype.parentElement = function () {
            return this._parent && this._parent._element;
        };

        PositionedElement.prototype.element = function () {
            return this._element;
        };

        PositionedElement.prototype.kind = function () {
            return this.element().kind();
        };

        PositionedElement.prototype.childIndex = function (child) {
            return TypeScript.Syntax.childIndex(this.element(), child);
        };

        PositionedElement.prototype.childCount = function () {
            return this.element().childCount();
        };

        PositionedElement.prototype.childAt = function (index) {
            var offset = TypeScript.Syntax.childOffsetAt(this.element(), index);
            return PositionedElement.create(this, this.element().childAt(index), this.fullStart() + offset);
        };

        PositionedElement.prototype.childStart = function (child) {
            var offset = TypeScript.Syntax.childOffset(this.element(), child);
            return this.fullStart() + offset + child.leadingTriviaWidth();
        };

        PositionedElement.prototype.childEnd = function (child) {
            var offset = TypeScript.Syntax.childOffset(this.element(), child);
            return this.fullStart() + offset + child.leadingTriviaWidth() + child.width();
        };

        PositionedElement.prototype.childStartAt = function (index) {
            var offset = TypeScript.Syntax.childOffsetAt(this.element(), index);
            var child = this.element().childAt(index);
            return this.fullStart() + offset + child.leadingTriviaWidth();
        };

        PositionedElement.prototype.childEndAt = function (index) {
            var offset = TypeScript.Syntax.childOffsetAt(this.element(), index);
            var child = this.element().childAt(index);
            return this.fullStart() + offset + child.leadingTriviaWidth() + child.width();
        };

        PositionedElement.prototype.getPositionedChild = function (child) {
            var offset = TypeScript.Syntax.childOffset(this.element(), child);
            return PositionedElement.create(this, child, this.fullStart() + offset);
        };

        PositionedElement.prototype.fullStart = function () {
            return this._fullStart;
        };

        PositionedElement.prototype.fullEnd = function () {
            return this.fullStart() + this.element().fullWidth();
        };

        PositionedElement.prototype.fullWidth = function () {
            return this.element().fullWidth();
        };

        PositionedElement.prototype.start = function () {
            return this.fullStart() + this.element().leadingTriviaWidth();
        };

        PositionedElement.prototype.end = function () {
            return this.fullStart() + this.element().leadingTriviaWidth() + this.element().width();
        };

        PositionedElement.prototype.root = function () {
            var current = this;
            while (current.parent() !== null) {
                current = current.parent();
            }

            return current;
        };

        PositionedElement.prototype.containingNode = function () {
            var current = this.parent();

            while (current !== null && !current.element().isNode()) {
                current = current.parent();
            }

            return current;
        };
        return PositionedElement;
    })();
    TypeScript.PositionedElement = PositionedElement;

    var PositionedNodeOrToken = (function (_super) {
        __extends(PositionedNodeOrToken, _super);
        function PositionedNodeOrToken(parent, nodeOrToken, fullStart) {
            _super.call(this, parent, nodeOrToken, fullStart);
        }
        PositionedNodeOrToken.prototype.nodeOrToken = function () {
            return this.element();
        };
        return PositionedNodeOrToken;
    })(PositionedElement);
    TypeScript.PositionedNodeOrToken = PositionedNodeOrToken;

    var PositionedNode = (function (_super) {
        __extends(PositionedNode, _super);
        function PositionedNode(parent, node, fullStart) {
            _super.call(this, parent, node, fullStart);
        }
        PositionedNode.prototype.node = function () {
            return this.element();
        };
        return PositionedNode;
    })(PositionedNodeOrToken);
    TypeScript.PositionedNode = PositionedNode;

    var PositionedToken = (function (_super) {
        __extends(PositionedToken, _super);
        function PositionedToken(parent, token, fullStart) {
            _super.call(this, parent, token, fullStart);
        }
        PositionedToken.prototype.token = function () {
            return this.element();
        };

        PositionedToken.prototype.previousToken = function (includeSkippedTokens) {
            if (typeof includeSkippedTokens === "undefined") { includeSkippedTokens = false; }
            var triviaList = this.token().leadingTrivia();
            if (includeSkippedTokens && triviaList && triviaList.hasSkippedToken()) {
                var currentTriviaEndPosition = this.start();
                for (var i = triviaList.count() - 1; i >= 0; i--) {
                    var trivia = triviaList.syntaxTriviaAt(i);
                    if (trivia.isSkippedToken()) {
                        return new PositionedSkippedToken(this, trivia.skippedToken(), currentTriviaEndPosition - trivia.fullWidth());
                    }

                    currentTriviaEndPosition -= trivia.fullWidth();
                }
            }

            var start = this.fullStart();
            if (start === 0) {
                return null;
            }

            return this.root().node().findToken(start - 1, includeSkippedTokens);
        };

        PositionedToken.prototype.nextToken = function (includeSkippedTokens) {
            if (typeof includeSkippedTokens === "undefined") { includeSkippedTokens = false; }
            if (this.token().tokenKind === 10 /* EndOfFileToken */) {
                return null;
            }

            var triviaList = this.token().trailingTrivia();
            if (includeSkippedTokens && triviaList && triviaList.hasSkippedToken()) {
                var fullStart = this.end();
                for (var i = 0, n = triviaList.count(); i < n; i++) {
                    var trivia = triviaList.syntaxTriviaAt(i);
                    if (trivia.isSkippedToken()) {
                        return new PositionedSkippedToken(this, trivia.skippedToken(), fullStart);
                    }

                    fullStart += trivia.fullWidth();
                }
            }

            return this.root().node().findToken(this.fullEnd(), includeSkippedTokens);
        };
        return PositionedToken;
    })(PositionedNodeOrToken);
    TypeScript.PositionedToken = PositionedToken;

    var PositionedList = (function (_super) {
        __extends(PositionedList, _super);
        function PositionedList(parent, list, fullStart) {
            _super.call(this, parent, list, fullStart);
        }
        PositionedList.prototype.list = function () {
            return this.element();
        };
        return PositionedList;
    })(PositionedElement);
    TypeScript.PositionedList = PositionedList;

    var PositionedSeparatedList = (function (_super) {
        __extends(PositionedSeparatedList, _super);
        function PositionedSeparatedList(parent, list, fullStart) {
            _super.call(this, parent, list, fullStart);
        }
        PositionedSeparatedList.prototype.list = function () {
            return this.element();
        };
        return PositionedSeparatedList;
    })(PositionedElement);
    TypeScript.PositionedSeparatedList = PositionedSeparatedList;

    var PositionedSkippedToken = (function (_super) {
        __extends(PositionedSkippedToken, _super);
        function PositionedSkippedToken(parentToken, token, fullStart) {
            _super.call(this, parentToken.parent(), token, fullStart);
            this._parentToken = parentToken;
        }
        PositionedSkippedToken.prototype.parentToken = function () {
            return this._parentToken;
        };

        PositionedSkippedToken.prototype.previousToken = function (includeSkippedTokens) {
            if (typeof includeSkippedTokens === "undefined") { includeSkippedTokens = false; }
            var start = this.fullStart();

            if (includeSkippedTokens) {
                var previousToken;

                if (start >= this.parentToken().end()) {
                    previousToken = TypeScript.Syntax.findSkippedTokenInTrailingTriviaList(this.parentToken(), start - 1);

                    if (previousToken) {
                        return previousToken;
                    }

                    return this.parentToken();
                } else {
                    previousToken = TypeScript.Syntax.findSkippedTokenInLeadingTriviaList(this.parentToken(), start - 1);

                    if (previousToken) {
                        return previousToken;
                    }
                }
            }

            var start = this.parentToken().fullStart();
            if (start === 0) {
                return null;
            }

            return this.root().node().findToken(start - 1, includeSkippedTokens);
        };

        PositionedSkippedToken.prototype.nextToken = function (includeSkippedTokens) {
            if (typeof includeSkippedTokens === "undefined") { includeSkippedTokens = false; }
            if (this.token().tokenKind === 10 /* EndOfFileToken */) {
                return null;
            }

            if (includeSkippedTokens) {
                var end = this.end();
                var nextToken;

                if (end <= this.parentToken().start()) {
                    nextToken = TypeScript.Syntax.findSkippedTokenInLeadingTriviaList(this.parentToken(), end);

                    if (nextToken) {
                        return nextToken;
                    }

                    return this.parentToken();
                } else {
                    nextToken = TypeScript.Syntax.findSkippedTokenInTrailingTriviaList(this.parentToken(), end);

                    if (nextToken) {
                        return nextToken;
                    }
                }
            }

            return this.root().node().findToken(this.parentToken().fullEnd(), includeSkippedTokens);
        };
        return PositionedSkippedToken;
    })(PositionedToken);
    TypeScript.PositionedSkippedToken = PositionedSkippedToken;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Scanner = (function () {
        function Scanner(fileName, text, languageVersion, window) {
            if (typeof window === "undefined") { window = TypeScript.ArrayUtilities.createArray(2048, 0); }
            Scanner.initializeStaticData();

            this.slidingWindow = new TypeScript.SlidingWindow(this, window, 0, text.length());
            this.fileName = fileName;
            this.text = text;
            this._languageVersion = languageVersion;
        }
        Scanner.initializeStaticData = function () {
            if (Scanner.isKeywordStartCharacter.length === 0) {
                Scanner.isKeywordStartCharacter = TypeScript.ArrayUtilities.createArray(127 /* maxAsciiCharacter */, false);
                Scanner.isIdentifierStartCharacter = TypeScript.ArrayUtilities.createArray(127 /* maxAsciiCharacter */, false);
                Scanner.isIdentifierPartCharacter = TypeScript.ArrayUtilities.createArray(127 /* maxAsciiCharacter */, false);
                Scanner.isNumericLiteralStart = TypeScript.ArrayUtilities.createArray(127 /* maxAsciiCharacter */, false);

                for (var character = 0; character < 127 /* maxAsciiCharacter */; character++) {
                    if (character >= 97 /* a */ && character <= 122 /* z */) {
                        Scanner.isIdentifierStartCharacter[character] = true;
                        Scanner.isIdentifierPartCharacter[character] = true;
                    } else if ((character >= 65 /* A */ && character <= 90 /* Z */) || character === 95 /* _ */ || character === 36 /* $ */) {
                        Scanner.isIdentifierStartCharacter[character] = true;
                        Scanner.isIdentifierPartCharacter[character] = true;
                    } else if (character >= 48 /* _0 */ && character <= 57 /* _9 */) {
                        Scanner.isIdentifierPartCharacter[character] = true;
                        Scanner.isNumericLiteralStart[character] = true;
                    }
                }

                Scanner.isNumericLiteralStart[46 /* dot */] = true;

                for (var keywordKind = TypeScript.SyntaxKind.FirstKeyword; keywordKind <= TypeScript.SyntaxKind.LastKeyword; keywordKind++) {
                    var keyword = TypeScript.SyntaxFacts.getText(keywordKind);
                    Scanner.isKeywordStartCharacter[keyword.charCodeAt(0)] = true;
                }
            }
        };

        Scanner.prototype.languageVersion = function () {
            return this._languageVersion;
        };

        Scanner.prototype.fetchMoreItems = function (argument, sourceIndex, window, destinationIndex, spaceAvailable) {
            var charactersRemaining = this.text.length() - sourceIndex;
            var amountToRead = TypeScript.MathPrototype.min(charactersRemaining, spaceAvailable);
            this.text.copyTo(sourceIndex, window, destinationIndex, amountToRead);
            return amountToRead;
        };

        Scanner.prototype.currentCharCode = function () {
            return this.slidingWindow.currentItem(null);
        };

        Scanner.prototype.absoluteIndex = function () {
            return this.slidingWindow.absoluteIndex();
        };

        Scanner.prototype.setAbsoluteIndex = function (index) {
            this.slidingWindow.setAbsoluteIndex(index);
        };

        Scanner.prototype.scan = function (diagnostics, allowRegularExpression) {
            var diagnosticsLength = diagnostics.length;
            var fullStart = this.slidingWindow.absoluteIndex();
            var leadingTriviaInfo = this.scanTriviaInfo(diagnostics, false);

            var start = this.slidingWindow.absoluteIndex();
            var kind = this.scanSyntaxToken(diagnostics, allowRegularExpression);
            var end = this.slidingWindow.absoluteIndex();

            var trailingTriviaInfo = this.scanTriviaInfo(diagnostics, true);

            var token = this.createToken(fullStart, leadingTriviaInfo, start, kind, end, trailingTriviaInfo);

            return diagnosticsLength !== diagnostics.length ? TypeScript.Syntax.realizeToken(token) : token;
        };

        Scanner.prototype.createToken = function (fullStart, leadingTriviaInfo, start, kind, end, trailingTriviaInfo) {
            if (kind >= TypeScript.SyntaxKind.FirstFixedWidth) {
                if (leadingTriviaInfo === 0) {
                    if (trailingTriviaInfo === 0) {
                        return new TypeScript.Syntax.FixedWidthTokenWithNoTrivia(kind);
                    } else {
                        return new TypeScript.Syntax.FixedWidthTokenWithTrailingTrivia(this.text, fullStart, kind, trailingTriviaInfo);
                    }
                } else if (trailingTriviaInfo === 0) {
                    return new TypeScript.Syntax.FixedWidthTokenWithLeadingTrivia(this.text, fullStart, kind, leadingTriviaInfo);
                } else {
                    return new TypeScript.Syntax.FixedWidthTokenWithLeadingAndTrailingTrivia(this.text, fullStart, kind, leadingTriviaInfo, trailingTriviaInfo);
                }
            } else {
                var width = end - start;
                if (leadingTriviaInfo === 0) {
                    if (trailingTriviaInfo === 0) {
                        return new TypeScript.Syntax.VariableWidthTokenWithNoTrivia(this.text, fullStart, kind, width);
                    } else {
                        return new TypeScript.Syntax.VariableWidthTokenWithTrailingTrivia(this.text, fullStart, kind, width, trailingTriviaInfo);
                    }
                } else if (trailingTriviaInfo === 0) {
                    return new TypeScript.Syntax.VariableWidthTokenWithLeadingTrivia(this.text, fullStart, kind, leadingTriviaInfo, width);
                } else {
                    return new TypeScript.Syntax.VariableWidthTokenWithLeadingAndTrailingTrivia(this.text, fullStart, kind, leadingTriviaInfo, width, trailingTriviaInfo);
                }
            }
        };

        Scanner.scanTrivia = function (text, start, length, isTrailing) {
            var scanner = new Scanner(null, text.subText(new TypeScript.TextSpan(start, length)), 1 /* EcmaScript5 */, Scanner.triviaWindow);
            return scanner.scanTrivia(isTrailing);
        };

        Scanner.prototype.scanTrivia = function (isTrailing) {
            var trivia = [];

            while (true) {
                if (!this.slidingWindow.isAtEndOfSource()) {
                    var ch = this.currentCharCode();

                    switch (ch) {
                        case 32 /* space */:
                        case 160 /* nonBreakingSpace */:
                        case 8192 /* enQuad */:
                        case 8193 /* emQuad */:
                        case 8194 /* enSpace */:
                        case 8195 /* emSpace */:
                        case 8196 /* threePerEmSpace */:
                        case 8197 /* fourPerEmSpace */:
                        case 8198 /* sixPerEmSpace */:
                        case 8199 /* figureSpace */:
                        case 8200 /* punctuationSpace */:
                        case 8201 /* thinSpace */:
                        case 8202 /* hairSpace */:
                        case 8203 /* zeroWidthSpace */:
                        case 8239 /* narrowNoBreakSpace */:
                        case 12288 /* ideographicSpace */:

                        case 9 /* tab */:
                        case 11 /* verticalTab */:
                        case 12 /* formFeed */:
                        case 65279 /* byteOrderMark */:
                            trivia.push(this.scanWhitespaceTrivia());
                            continue;

                        case 47 /* slash */:
                            var ch2 = this.slidingWindow.peekItemN(1);
                            if (ch2 === 47 /* slash */) {
                                trivia.push(this.scanSingleLineCommentTrivia());
                                continue;
                            }

                            if (ch2 === 42 /* asterisk */) {
                                trivia.push(this.scanMultiLineCommentTrivia());
                                continue;
                            }

                            throw TypeScript.Errors.invalidOperation();

                        case 13 /* carriageReturn */:
                        case 10 /* lineFeed */:
                        case 8233 /* paragraphSeparator */:
                        case 8232 /* lineSeparator */:
                            trivia.push(this.scanLineTerminatorSequenceTrivia(ch));

                            if (!isTrailing) {
                                continue;
                            }

                            break;

                        default:
                            throw TypeScript.Errors.invalidOperation();
                    }
                }

                return TypeScript.Syntax.triviaList(trivia);
            }
        };

        Scanner.prototype.scanTriviaInfo = function (diagnostics, isTrailing) {
            var width = 0;
            var hasCommentOrNewLine = 0;

            while (true) {
                var ch = this.currentCharCode();

                switch (ch) {
                    case 32 /* space */:
                    case 160 /* nonBreakingSpace */:
                    case 8192 /* enQuad */:
                    case 8193 /* emQuad */:
                    case 8194 /* enSpace */:
                    case 8195 /* emSpace */:
                    case 8196 /* threePerEmSpace */:
                    case 8197 /* fourPerEmSpace */:
                    case 8198 /* sixPerEmSpace */:
                    case 8199 /* figureSpace */:
                    case 8200 /* punctuationSpace */:
                    case 8201 /* thinSpace */:
                    case 8202 /* hairSpace */:
                    case 8203 /* zeroWidthSpace */:
                    case 8239 /* narrowNoBreakSpace */:
                    case 12288 /* ideographicSpace */:

                    case 9 /* tab */:
                    case 11 /* verticalTab */:
                    case 12 /* formFeed */:
                    case 65279 /* byteOrderMark */:
                        this.slidingWindow.moveToNextItem();
                        width++;
                        continue;

                    case 47 /* slash */:
                        var ch2 = this.slidingWindow.peekItemN(1);
                        if (ch2 === 47 /* slash */) {
                            hasCommentOrNewLine |= 2 /* TriviaCommentMask */;
                            width += this.scanSingleLineCommentTriviaLength();
                            continue;
                        }

                        if (ch2 === 42 /* asterisk */) {
                            hasCommentOrNewLine |= 2 /* TriviaCommentMask */;
                            width += this.scanMultiLineCommentTriviaLength(diagnostics);
                            continue;
                        }

                        break;

                    case 13 /* carriageReturn */:
                    case 10 /* lineFeed */:
                    case 8233 /* paragraphSeparator */:
                    case 8232 /* lineSeparator */:
                        hasCommentOrNewLine |= 1 /* TriviaNewLineMask */;
                        width += this.scanLineTerminatorSequenceLength(ch);

                        if (!isTrailing) {
                            continue;
                        }

                        break;
                }

                return (width << 2 /* TriviaFullWidthShift */) | hasCommentOrNewLine;
            }
        };

        Scanner.prototype.isNewLineCharacter = function (ch) {
            switch (ch) {
                case 13 /* carriageReturn */:
                case 10 /* lineFeed */:
                case 8233 /* paragraphSeparator */:
                case 8232 /* lineSeparator */:
                    return true;
                default:
                    return false;
            }
        };

        Scanner.prototype.scanWhitespaceTrivia = function () {
            var absoluteStartIndex = this.slidingWindow.getAndPinAbsoluteIndex();

            var width = 0;
            while (true) {
                var ch = this.currentCharCode();

                switch (ch) {
                    case 32 /* space */:
                    case 160 /* nonBreakingSpace */:
                    case 8192 /* enQuad */:
                    case 8193 /* emQuad */:
                    case 8194 /* enSpace */:
                    case 8195 /* emSpace */:
                    case 8196 /* threePerEmSpace */:
                    case 8197 /* fourPerEmSpace */:
                    case 8198 /* sixPerEmSpace */:
                    case 8199 /* figureSpace */:
                    case 8200 /* punctuationSpace */:
                    case 8201 /* thinSpace */:
                    case 8202 /* hairSpace */:
                    case 8203 /* zeroWidthSpace */:
                    case 8239 /* narrowNoBreakSpace */:
                    case 12288 /* ideographicSpace */:

                    case 9 /* tab */:
                    case 11 /* verticalTab */:
                    case 12 /* formFeed */:
                    case 65279 /* byteOrderMark */:
                        this.slidingWindow.moveToNextItem();
                        width++;
                        continue;
                }

                break;
            }

            var text = this.substring(absoluteStartIndex, absoluteStartIndex + width, false);
            this.slidingWindow.releaseAndUnpinAbsoluteIndex(absoluteStartIndex);

            return TypeScript.Syntax.whitespace(text);
        };

        Scanner.prototype.scanSingleLineCommentTrivia = function () {
            var absoluteStartIndex = this.slidingWindow.getAndPinAbsoluteIndex();
            var width = this.scanSingleLineCommentTriviaLength();

            var text = this.substring(absoluteStartIndex, absoluteStartIndex + width, false);
            this.slidingWindow.releaseAndUnpinAbsoluteIndex(absoluteStartIndex);

            return TypeScript.Syntax.singleLineComment(text);
        };

        Scanner.prototype.scanSingleLineCommentTriviaLength = function () {
            this.slidingWindow.moveToNextItem();
            this.slidingWindow.moveToNextItem();

            var width = 2;
            while (true) {
                if (this.slidingWindow.isAtEndOfSource() || this.isNewLineCharacter(this.currentCharCode())) {
                    return width;
                }

                this.slidingWindow.moveToNextItem();
                width++;
            }
        };

        Scanner.prototype.scanMultiLineCommentTrivia = function () {
            var absoluteStartIndex = this.slidingWindow.getAndPinAbsoluteIndex();
            var width = this.scanMultiLineCommentTriviaLength(null);

            var text = this.substring(absoluteStartIndex, absoluteStartIndex + width, false);
            this.slidingWindow.releaseAndUnpinAbsoluteIndex(absoluteStartIndex);

            return TypeScript.Syntax.multiLineComment(text);
        };

        Scanner.prototype.scanMultiLineCommentTriviaLength = function (diagnostics) {
            this.slidingWindow.moveToNextItem();
            this.slidingWindow.moveToNextItem();

            var width = 2;
            while (true) {
                if (this.slidingWindow.isAtEndOfSource()) {
                    if (diagnostics !== null) {
                        diagnostics.push(new TypeScript.SyntaxDiagnostic(this.fileName, this.slidingWindow.absoluteIndex(), 0, 14 /* _StarSlash__expected */, null));
                    }

                    return width;
                }

                var ch = this.currentCharCode();
                if (ch === 42 /* asterisk */ && this.slidingWindow.peekItemN(1) === 47 /* slash */) {
                    this.slidingWindow.moveToNextItem();
                    this.slidingWindow.moveToNextItem();
                    width += 2;
                    return width;
                }

                this.slidingWindow.moveToNextItem();
                width++;
            }
        };

        Scanner.prototype.scanLineTerminatorSequenceTrivia = function (ch) {
            var absoluteStartIndex = this.slidingWindow.getAndPinAbsoluteIndex();
            var width = this.scanLineTerminatorSequenceLength(ch);

            var text = this.substring(absoluteStartIndex, absoluteStartIndex + width, false);
            this.slidingWindow.releaseAndUnpinAbsoluteIndex(absoluteStartIndex);

            return TypeScript.Syntax.trivia(5 /* NewLineTrivia */, text);
        };

        Scanner.prototype.scanLineTerminatorSequenceLength = function (ch) {
            this.slidingWindow.moveToNextItem();

            if (ch === 13 /* carriageReturn */ && this.currentCharCode() === 10 /* lineFeed */) {
                this.slidingWindow.moveToNextItem();
                return 2;
            } else {
                return 1;
            }
        };

        Scanner.prototype.scanSyntaxToken = function (diagnostics, allowRegularExpression) {
            if (this.slidingWindow.isAtEndOfSource()) {
                return 10 /* EndOfFileToken */;
            }

            var character = this.currentCharCode();

            switch (character) {
                case 34 /* doubleQuote */:
                case 39 /* singleQuote */:
                    return this.scanStringLiteral(diagnostics);

                case 47 /* slash */:
                    return this.scanSlashToken(allowRegularExpression);

                case 46 /* dot */:
                    return this.scanDotToken();

                case 45 /* minus */:
                    return this.scanMinusToken();

                case 33 /* exclamation */:
                    return this.scanExclamationToken();

                case 61 /* equals */:
                    return this.scanEqualsToken();

                case 124 /* bar */:
                    return this.scanBarToken();

                case 42 /* asterisk */:
                    return this.scanAsteriskToken();

                case 43 /* plus */:
                    return this.scanPlusToken();

                case 37 /* percent */:
                    return this.scanPercentToken();

                case 38 /* ampersand */:
                    return this.scanAmpersandToken();

                case 94 /* caret */:
                    return this.scanCaretToken();

                case 60 /* lessThan */:
                    return this.scanLessThanToken();

                case 62 /* greaterThan */:
                    return this.advanceAndSetTokenKind(82 /* GreaterThanToken */);

                case 44 /* comma */:
                    return this.advanceAndSetTokenKind(80 /* CommaToken */);

                case 58 /* colon */:
                    return this.advanceAndSetTokenKind(107 /* ColonToken */);

                case 59 /* semicolon */:
                    return this.advanceAndSetTokenKind(79 /* SemicolonToken */);

                case 126 /* tilde */:
                    return this.advanceAndSetTokenKind(103 /* TildeToken */);

                case 40 /* openParen */:
                    return this.advanceAndSetTokenKind(73 /* OpenParenToken */);

                case 41 /* closeParen */:
                    return this.advanceAndSetTokenKind(74 /* CloseParenToken */);

                case 123 /* openBrace */:
                    return this.advanceAndSetTokenKind(71 /* OpenBraceToken */);

                case 125 /* closeBrace */:
                    return this.advanceAndSetTokenKind(72 /* CloseBraceToken */);

                case 91 /* openBracket */:
                    return this.advanceAndSetTokenKind(75 /* OpenBracketToken */);

                case 93 /* closeBracket */:
                    return this.advanceAndSetTokenKind(76 /* CloseBracketToken */);

                case 63 /* question */:
                    return this.advanceAndSetTokenKind(106 /* QuestionToken */);
            }

            if (Scanner.isNumericLiteralStart[character]) {
                return this.scanNumericLiteral();
            }

            if (Scanner.isIdentifierStartCharacter[character]) {
                var result = this.tryFastScanIdentifierOrKeyword(character);
                if (result !== 0 /* None */) {
                    return result;
                }
            }

            if (this.isIdentifierStart(this.peekCharOrUnicodeEscape())) {
                return this.slowScanIdentifier(diagnostics);
            }

            return this.scanDefaultCharacter(character, diagnostics);
        };

        Scanner.prototype.isIdentifierStart = function (interpretedChar) {
            if (Scanner.isIdentifierStartCharacter[interpretedChar]) {
                return true;
            }

            return interpretedChar > 127 /* maxAsciiCharacter */ && TypeScript.Unicode.isIdentifierStart(interpretedChar, this._languageVersion);
        };

        Scanner.prototype.isIdentifierPart = function (interpretedChar) {
            if (Scanner.isIdentifierPartCharacter[interpretedChar]) {
                return true;
            }

            return interpretedChar > 127 /* maxAsciiCharacter */ && TypeScript.Unicode.isIdentifierPart(interpretedChar, this._languageVersion);
        };

        Scanner.prototype.tryFastScanIdentifierOrKeyword = function (firstCharacter) {
            var startIndex = this.slidingWindow.getAndPinAbsoluteIndex();

            while (true) {
                var character = this.currentCharCode();
                if (Scanner.isIdentifierPartCharacter[character]) {
                    this.slidingWindow.moveToNextItem();
                } else if (character === 92 /* backslash */ || character > 127 /* maxAsciiCharacter */) {
                    this.slidingWindow.rewindToPinnedIndex(startIndex);
                    this.slidingWindow.releaseAndUnpinAbsoluteIndex(startIndex);
                    return 0 /* None */;
                } else {
                    var endIndex = this.slidingWindow.absoluteIndex();

                    var kind;
                    if (Scanner.isKeywordStartCharacter[firstCharacter]) {
                        var offset = startIndex - this.slidingWindow.windowAbsoluteStartIndex;
                        kind = TypeScript.ScannerUtilities.identifierKind(this.slidingWindow.window, offset, endIndex - startIndex);
                    } else {
                        kind = 11 /* IdentifierName */;
                    }

                    this.slidingWindow.releaseAndUnpinAbsoluteIndex(startIndex);
                    return kind;
                }
            }
        };

        Scanner.prototype.slowScanIdentifier = function (diagnostics) {
            var startIndex = this.slidingWindow.absoluteIndex();

            do {
                this.scanCharOrUnicodeEscape(diagnostics);
            } while(this.isIdentifierPart(this.peekCharOrUnicodeEscape()));

            return 11 /* IdentifierName */;
        };

        Scanner.prototype.scanNumericLiteral = function () {
            if (this.isHexNumericLiteral()) {
                return this.scanHexNumericLiteral();
            } else {
                return this.scanDecimalNumericLiteral();
            }
        };

        Scanner.prototype.scanDecimalNumericLiteral = function () {
            while (TypeScript.CharacterInfo.isDecimalDigit(this.currentCharCode())) {
                this.slidingWindow.moveToNextItem();
            }

            if (this.currentCharCode() === 46 /* dot */) {
                this.slidingWindow.moveToNextItem();
            }

            while (TypeScript.CharacterInfo.isDecimalDigit(this.currentCharCode())) {
                this.slidingWindow.moveToNextItem();
            }

            var ch = this.currentCharCode();
            if (ch === 101 /* e */ || ch === 69 /* E */) {
                this.slidingWindow.moveToNextItem();

                ch = this.currentCharCode();
                if (ch === 45 /* minus */ || ch === 43 /* plus */) {
                    if (TypeScript.CharacterInfo.isDecimalDigit(this.slidingWindow.peekItemN(1))) {
                        this.slidingWindow.moveToNextItem();
                    }
                }
            }

            while (TypeScript.CharacterInfo.isDecimalDigit(this.currentCharCode())) {
                this.slidingWindow.moveToNextItem();
            }

            return 13 /* NumericLiteral */;
        };

        Scanner.prototype.scanHexNumericLiteral = function () {
            this.slidingWindow.moveToNextItem();
            this.slidingWindow.moveToNextItem();

            while (TypeScript.CharacterInfo.isHexDigit(this.currentCharCode())) {
                this.slidingWindow.moveToNextItem();
            }

            return 13 /* NumericLiteral */;
        };

        Scanner.prototype.isHexNumericLiteral = function () {
            if (this.currentCharCode() === 48 /* _0 */) {
                var ch = this.slidingWindow.peekItemN(1);

                if (ch === 120 /* x */ || ch === 88 /* X */) {
                    ch = this.slidingWindow.peekItemN(2);

                    return TypeScript.CharacterInfo.isHexDigit(ch);
                }
            }

            return false;
        };

        Scanner.prototype.advanceAndSetTokenKind = function (kind) {
            this.slidingWindow.moveToNextItem();
            return kind;
        };

        Scanner.prototype.scanLessThanToken = function () {
            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === 61 /* equals */) {
                this.slidingWindow.moveToNextItem();
                return 83 /* LessThanEqualsToken */;
            } else if (this.currentCharCode() === 60 /* lessThan */) {
                this.slidingWindow.moveToNextItem();
                if (this.currentCharCode() === 61 /* equals */) {
                    this.slidingWindow.moveToNextItem();
                    return 113 /* LessThanLessThanEqualsToken */;
                } else {
                    return 96 /* LessThanLessThanToken */;
                }
            } else {
                return 81 /* LessThanToken */;
            }
        };

        Scanner.prototype.scanBarToken = function () {
            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === 61 /* equals */) {
                this.slidingWindow.moveToNextItem();
                return 117 /* BarEqualsToken */;
            } else if (this.currentCharCode() === 124 /* bar */) {
                this.slidingWindow.moveToNextItem();
                return 105 /* BarBarToken */;
            } else {
                return 100 /* BarToken */;
            }
        };

        Scanner.prototype.scanCaretToken = function () {
            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === 61 /* equals */) {
                this.slidingWindow.moveToNextItem();
                return 118 /* CaretEqualsToken */;
            } else {
                return 101 /* CaretToken */;
            }
        };

        Scanner.prototype.scanAmpersandToken = function () {
            this.slidingWindow.moveToNextItem();
            var character = this.currentCharCode();
            if (character === 61 /* equals */) {
                this.slidingWindow.moveToNextItem();
                return 116 /* AmpersandEqualsToken */;
            } else if (this.currentCharCode() === 38 /* ampersand */) {
                this.slidingWindow.moveToNextItem();
                return 104 /* AmpersandAmpersandToken */;
            } else {
                return 99 /* AmpersandToken */;
            }
        };

        Scanner.prototype.scanPercentToken = function () {
            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === 61 /* equals */) {
                this.slidingWindow.moveToNextItem();
                return 112 /* PercentEqualsToken */;
            } else {
                return 93 /* PercentToken */;
            }
        };

        Scanner.prototype.scanMinusToken = function () {
            this.slidingWindow.moveToNextItem();
            var character = this.currentCharCode();

            if (character === 61 /* equals */) {
                this.slidingWindow.moveToNextItem();
                return 110 /* MinusEqualsToken */;
            } else if (character === 45 /* minus */) {
                this.slidingWindow.moveToNextItem();
                return 95 /* MinusMinusToken */;
            } else {
                return 91 /* MinusToken */;
            }
        };

        Scanner.prototype.scanPlusToken = function () {
            this.slidingWindow.moveToNextItem();
            var character = this.currentCharCode();
            if (character === 61 /* equals */) {
                this.slidingWindow.moveToNextItem();
                return 109 /* PlusEqualsToken */;
            } else if (character === 43 /* plus */) {
                this.slidingWindow.moveToNextItem();
                return 94 /* PlusPlusToken */;
            } else {
                return 90 /* PlusToken */;
            }
        };

        Scanner.prototype.scanAsteriskToken = function () {
            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === 61 /* equals */) {
                this.slidingWindow.moveToNextItem();
                return 111 /* AsteriskEqualsToken */;
            } else {
                return 92 /* AsteriskToken */;
            }
        };

        Scanner.prototype.scanEqualsToken = function () {
            this.slidingWindow.moveToNextItem();
            var character = this.currentCharCode();
            if (character === 61 /* equals */) {
                this.slidingWindow.moveToNextItem();

                if (this.currentCharCode() === 61 /* equals */) {
                    this.slidingWindow.moveToNextItem();

                    return 88 /* EqualsEqualsEqualsToken */;
                } else {
                    return 85 /* EqualsEqualsToken */;
                }
            } else if (character === 62 /* greaterThan */) {
                this.slidingWindow.moveToNextItem();
                return 86 /* EqualsGreaterThanToken */;
            } else {
                return 108 /* EqualsToken */;
            }
        };

        Scanner.prototype.isDotPrefixedNumericLiteral = function () {
            if (this.currentCharCode() === 46 /* dot */) {
                var ch = this.slidingWindow.peekItemN(1);
                return TypeScript.CharacterInfo.isDecimalDigit(ch);
            }

            return false;
        };

        Scanner.prototype.scanDotToken = function () {
            if (this.isDotPrefixedNumericLiteral()) {
                return this.scanNumericLiteral();
            }

            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === 46 /* dot */ && this.slidingWindow.peekItemN(1) === 46 /* dot */) {
                this.slidingWindow.moveToNextItem();
                this.slidingWindow.moveToNextItem();
                return 78 /* DotDotDotToken */;
            } else {
                return 77 /* DotToken */;
            }
        };

        Scanner.prototype.scanSlashToken = function (allowRegularExpression) {
            if (allowRegularExpression) {
                var result = this.tryScanRegularExpressionToken();
                if (result !== 0 /* None */) {
                    return result;
                }
            }

            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === 61 /* equals */) {
                this.slidingWindow.moveToNextItem();
                return 120 /* SlashEqualsToken */;
            } else {
                return 119 /* SlashToken */;
            }
        };

        Scanner.prototype.tryScanRegularExpressionToken = function () {
            var startIndex = this.slidingWindow.getAndPinAbsoluteIndex();
            try  {
                this.slidingWindow.moveToNextItem();

                var inEscape = false;
                var inCharacterClass = false;
                while (true) {
                    var ch = this.currentCharCode();
                    if (this.isNewLineCharacter(ch) || this.slidingWindow.isAtEndOfSource()) {
                        this.slidingWindow.rewindToPinnedIndex(startIndex);
                        return 0 /* None */;
                    }

                    this.slidingWindow.moveToNextItem();
                    if (inEscape) {
                        inEscape = false;
                        continue;
                    }

                    switch (ch) {
                        case 92 /* backslash */:
                            inEscape = true;
                            continue;

                        case 91 /* openBracket */:
                            inCharacterClass = true;
                            continue;

                        case 93 /* closeBracket */:
                            inCharacterClass = false;
                            continue;

                        case 47 /* slash */:
                            if (inCharacterClass) {
                                continue;
                            }

                            break;

                        default:
                            continue;
                    }

                    break;
                }

                while (Scanner.isIdentifierPartCharacter[this.currentCharCode()]) {
                    this.slidingWindow.moveToNextItem();
                }

                return 12 /* RegularExpressionLiteral */;
            } finally {
                this.slidingWindow.releaseAndUnpinAbsoluteIndex(startIndex);
            }
        };

        Scanner.prototype.scanExclamationToken = function () {
            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === 61 /* equals */) {
                this.slidingWindow.moveToNextItem();

                if (this.currentCharCode() === 61 /* equals */) {
                    this.slidingWindow.moveToNextItem();

                    return 89 /* ExclamationEqualsEqualsToken */;
                } else {
                    return 87 /* ExclamationEqualsToken */;
                }
            } else {
                return 102 /* ExclamationToken */;
            }
        };

        Scanner.prototype.scanDefaultCharacter = function (character, diagnostics) {
            var position = this.slidingWindow.absoluteIndex();
            this.slidingWindow.moveToNextItem();

            var text = String.fromCharCode(character);
            var messageText = this.getErrorMessageText(text);
            diagnostics.push(new TypeScript.SyntaxDiagnostic(this.fileName, position, 1, 5 /* Unexpected_character_0 */, [messageText]));

            return 9 /* ErrorToken */;
        };

        Scanner.prototype.getErrorMessageText = function (text) {
            if (text === "\\") {
                return '"\\"';
            }

            return JSON.stringify(text);
        };

        Scanner.prototype.skipEscapeSequence = function (diagnostics) {
            var rewindPoint = this.slidingWindow.getAndPinAbsoluteIndex();
            try  {
                this.slidingWindow.moveToNextItem();

                var ch = this.currentCharCode();
                this.slidingWindow.moveToNextItem();
                switch (ch) {
                    case 120 /* x */:
                    case 117 /* u */:
                        this.slidingWindow.rewindToPinnedIndex(rewindPoint);
                        var value = this.scanUnicodeOrHexEscape(diagnostics);
                        return;

                    case 13 /* carriageReturn */:
                        if (this.currentCharCode() === 10 /* lineFeed */) {
                            this.slidingWindow.moveToNextItem();
                        }
                        return;

                    default:
                        return;
                }
            } finally {
                this.slidingWindow.releaseAndUnpinAbsoluteIndex(rewindPoint);
            }
        };

        Scanner.prototype.scanStringLiteral = function (diagnostics) {
            var quoteCharacter = this.currentCharCode();

            this.slidingWindow.moveToNextItem();

            while (true) {
                var ch = this.currentCharCode();
                if (ch === 92 /* backslash */) {
                    this.skipEscapeSequence(diagnostics);
                } else if (ch === quoteCharacter) {
                    this.slidingWindow.moveToNextItem();
                    break;
                } else if (this.isNewLineCharacter(ch) || this.slidingWindow.isAtEndOfSource()) {
                    diagnostics.push(new TypeScript.SyntaxDiagnostic(this.fileName, this.slidingWindow.absoluteIndex(), 1, 6 /* Missing_closing_quote_character */, null));
                    break;
                } else {
                    this.slidingWindow.moveToNextItem();
                }
            }

            return 14 /* StringLiteral */;
        };

        Scanner.prototype.isUnicodeOrHexEscape = function (character) {
            return this.isUnicodeEscape(character) || this.isHexEscape(character);
        };

        Scanner.prototype.isUnicodeEscape = function (character) {
            if (character === 92 /* backslash */) {
                var ch2 = this.slidingWindow.peekItemN(1);
                if (ch2 === 117 /* u */) {
                    return true;
                }
            }

            return false;
        };

        Scanner.prototype.isHexEscape = function (character) {
            if (character === 92 /* backslash */) {
                var ch2 = this.slidingWindow.peekItemN(1);
                if (ch2 === 120 /* x */) {
                    return true;
                }
            }

            return false;
        };

        Scanner.prototype.peekCharOrUnicodeOrHexEscape = function () {
            var character = this.currentCharCode();
            if (this.isUnicodeOrHexEscape(character)) {
                return this.peekUnicodeOrHexEscape();
            } else {
                return character;
            }
        };

        Scanner.prototype.peekCharOrUnicodeEscape = function () {
            var character = this.currentCharCode();
            if (this.isUnicodeEscape(character)) {
                return this.peekUnicodeOrHexEscape();
            } else {
                return character;
            }
        };

        Scanner.prototype.peekUnicodeOrHexEscape = function () {
            var startIndex = this.slidingWindow.getAndPinAbsoluteIndex();

            var ch = this.scanUnicodeOrHexEscape(null);

            this.slidingWindow.rewindToPinnedIndex(startIndex);
            this.slidingWindow.releaseAndUnpinAbsoluteIndex(startIndex);

            return ch;
        };

        Scanner.prototype.scanCharOrUnicodeEscape = function (errors) {
            var ch = this.currentCharCode();
            if (ch === 92 /* backslash */) {
                var ch2 = this.slidingWindow.peekItemN(1);
                if (ch2 === 117 /* u */) {
                    return this.scanUnicodeOrHexEscape(errors);
                }
            }

            this.slidingWindow.moveToNextItem();
            return ch;
        };

        Scanner.prototype.scanCharOrUnicodeOrHexEscape = function (errors) {
            var ch = this.currentCharCode();
            if (ch === 92 /* backslash */) {
                var ch2 = this.slidingWindow.peekItemN(1);
                if (ch2 === 117 /* u */ || ch2 === 120 /* x */) {
                    return this.scanUnicodeOrHexEscape(errors);
                }
            }

            this.slidingWindow.moveToNextItem();
            return ch;
        };

        Scanner.prototype.scanUnicodeOrHexEscape = function (errors) {
            var start = this.slidingWindow.absoluteIndex();
            var character = this.currentCharCode();

            this.slidingWindow.moveToNextItem();

            character = this.currentCharCode();

            var intChar = 0;
            this.slidingWindow.moveToNextItem();

            var count = character === 117 /* u */ ? 4 : 2;

            for (var i = 0; i < count; i++) {
                var ch2 = this.currentCharCode();
                if (!TypeScript.CharacterInfo.isHexDigit(ch2)) {
                    if (errors !== null) {
                        var end = this.slidingWindow.absoluteIndex();
                        var info = this.createIllegalEscapeDiagnostic(start, end);
                        errors.push(info);
                    }

                    break;
                }

                intChar = (intChar << 4) + TypeScript.CharacterInfo.hexValue(ch2);
                this.slidingWindow.moveToNextItem();
            }

            return intChar;
        };

        Scanner.prototype.substring = function (start, end, intern) {
            var length = end - start;
            var offset = start - this.slidingWindow.windowAbsoluteStartIndex;

            if (intern) {
                return TypeScript.Collections.DefaultStringTable.addCharArray(this.slidingWindow.window, offset, length);
            } else {
                return TypeScript.StringUtilities.fromCharCodeArray(this.slidingWindow.window.slice(offset, offset + length));
            }
        };

        Scanner.prototype.createIllegalEscapeDiagnostic = function (start, end) {
            return new TypeScript.SyntaxDiagnostic(this.fileName, start, end - start, 4 /* Unrecognized_escape_sequence */, null);
        };

        Scanner.isValidIdentifier = function (text, languageVersion) {
            var scanner = new Scanner(null, text, TypeScript.LanguageVersion, Scanner.triviaWindow);
            var errors = [];
            var token = scanner.scan(errors, false);

            return errors.length === 0 && TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(token) && token.width() === text.length();
        };
        Scanner.isKeywordStartCharacter = [];
        Scanner.isIdentifierStartCharacter = [];
        Scanner.isIdentifierPartCharacter = [];
        Scanner.isNumericLiteralStart = [];

        Scanner.triviaWindow = TypeScript.ArrayUtilities.createArray(2048, 0);
        return Scanner;
    })();
    TypeScript.Scanner = Scanner;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var ScannerUtilities = (function () {
        function ScannerUtilities() {
        }
        ScannerUtilities.identifierKind = function (array, startIndex, length) {
            switch (length) {
                case 2:
                    switch (array[startIndex]) {
                        case 100 /* d */:
                            return (array[startIndex + 1] === 111 /* o */) ? 22 /* DoKeyword */ : 11 /* IdentifierName */;
                        case 105 /* i */:
                            switch (array[startIndex + 1]) {
                                case 102 /* f */:
                                    return 28 /* IfKeyword */;
                                case 110 /* n */:
                                    return 29 /* InKeyword */;
                                default:
                                    return 11 /* IdentifierName */;
                            }

                        default:
                            return 11 /* IdentifierName */;
                    }

                case 3:
                    switch (array[startIndex]) {
                        case 102 /* f */:
                            return (array[startIndex + 1] === 111 /* o */ && array[startIndex + 2] === 114 /* r */) ? 26 /* ForKeyword */ : 11 /* IdentifierName */;
                        case 110 /* n */:
                            return (array[startIndex + 1] === 101 /* e */ && array[startIndex + 2] === 119 /* w */) ? 31 /* NewKeyword */ : 11 /* IdentifierName */;
                        case 116 /* t */:
                            return (array[startIndex + 1] === 114 /* r */ && array[startIndex + 2] === 121 /* y */) ? 38 /* TryKeyword */ : 11 /* IdentifierName */;
                        case 118 /* v */:
                            return (array[startIndex + 1] === 97 /* a */ && array[startIndex + 2] === 114 /* r */) ? 40 /* VarKeyword */ : 11 /* IdentifierName */;
                        case 108 /* l */:
                            return (array[startIndex + 1] === 101 /* e */ && array[startIndex + 2] === 116 /* t */) ? 53 /* LetKeyword */ : 11 /* IdentifierName */;
                        case 97 /* a */:
                            return (array[startIndex + 1] === 110 /* n */ && array[startIndex + 2] === 121 /* y */) ? 60 /* AnyKeyword */ : 11 /* IdentifierName */;
                        case 103 /* g */:
                            return (array[startIndex + 1] === 101 /* e */ && array[startIndex + 2] === 116 /* t */) ? 65 /* GetKeyword */ : 11 /* IdentifierName */;
                        case 115 /* s */:
                            return (array[startIndex + 1] === 101 /* e */ && array[startIndex + 2] === 116 /* t */) ? 69 /* SetKeyword */ : 11 /* IdentifierName */;
                        default:
                            return 11 /* IdentifierName */;
                    }

                case 4:
                    switch (array[startIndex]) {
                        case 99 /* c */:
                            return (array[startIndex + 1] === 97 /* a */ && array[startIndex + 2] === 115 /* s */ && array[startIndex + 3] === 101 /* e */) ? 16 /* CaseKeyword */ : 11 /* IdentifierName */;
                        case 101 /* e */:
                            switch (array[startIndex + 1]) {
                                case 108 /* l */:
                                    return (array[startIndex + 2] === 115 /* s */ && array[startIndex + 3] === 101 /* e */) ? 23 /* ElseKeyword */ : 11 /* IdentifierName */;
                                case 110 /* n */:
                                    return (array[startIndex + 2] === 117 /* u */ && array[startIndex + 3] === 109 /* m */) ? 46 /* EnumKeyword */ : 11 /* IdentifierName */;
                                default:
                                    return 11 /* IdentifierName */;
                            }

                        case 110 /* n */:
                            return (array[startIndex + 1] === 117 /* u */ && array[startIndex + 2] === 108 /* l */ && array[startIndex + 3] === 108 /* l */) ? 32 /* NullKeyword */ : 11 /* IdentifierName */;
                        case 116 /* t */:
                            switch (array[startIndex + 1]) {
                                case 104 /* h */:
                                    return (array[startIndex + 2] === 105 /* i */ && array[startIndex + 3] === 115 /* s */) ? 35 /* ThisKeyword */ : 11 /* IdentifierName */;
                                case 114 /* r */:
                                    return (array[startIndex + 2] === 117 /* u */ && array[startIndex + 3] === 101 /* e */) ? 37 /* TrueKeyword */ : 11 /* IdentifierName */;
                                default:
                                    return 11 /* IdentifierName */;
                            }

                        case 118 /* v */:
                            return (array[startIndex + 1] === 111 /* o */ && array[startIndex + 2] === 105 /* i */ && array[startIndex + 3] === 100 /* d */) ? 41 /* VoidKeyword */ : 11 /* IdentifierName */;
                        case 119 /* w */:
                            return (array[startIndex + 1] === 105 /* i */ && array[startIndex + 2] === 116 /* t */ && array[startIndex + 3] === 104 /* h */) ? 43 /* WithKeyword */ : 11 /* IdentifierName */;
                        case 98 /* b */:
                            return (array[startIndex + 1] === 111 /* o */ && array[startIndex + 2] === 111 /* o */ && array[startIndex + 3] === 108 /* l */) ? 62 /* BoolKeyword */ : 11 /* IdentifierName */;
                        default:
                            return 11 /* IdentifierName */;
                    }

                case 5:
                    switch (array[startIndex]) {
                        case 98 /* b */:
                            return (array[startIndex + 1] === 114 /* r */ && array[startIndex + 2] === 101 /* e */ && array[startIndex + 3] === 97 /* a */ && array[startIndex + 4] === 107 /* k */) ? 15 /* BreakKeyword */ : 11 /* IdentifierName */;
                        case 99 /* c */:
                            switch (array[startIndex + 1]) {
                                case 97 /* a */:
                                    return (array[startIndex + 2] === 116 /* t */ && array[startIndex + 3] === 99 /* c */ && array[startIndex + 4] === 104 /* h */) ? 17 /* CatchKeyword */ : 11 /* IdentifierName */;
                                case 108 /* l */:
                                    return (array[startIndex + 2] === 97 /* a */ && array[startIndex + 3] === 115 /* s */ && array[startIndex + 4] === 115 /* s */) ? 44 /* ClassKeyword */ : 11 /* IdentifierName */;
                                case 111 /* o */:
                                    return (array[startIndex + 2] === 110 /* n */ && array[startIndex + 3] === 115 /* s */ && array[startIndex + 4] === 116 /* t */) ? 45 /* ConstKeyword */ : 11 /* IdentifierName */;
                                default:
                                    return 11 /* IdentifierName */;
                            }

                        case 102 /* f */:
                            return (array[startIndex + 1] === 97 /* a */ && array[startIndex + 2] === 108 /* l */ && array[startIndex + 3] === 115 /* s */ && array[startIndex + 4] === 101 /* e */) ? 24 /* FalseKeyword */ : 11 /* IdentifierName */;
                        case 116 /* t */:
                            return (array[startIndex + 1] === 104 /* h */ && array[startIndex + 2] === 114 /* r */ && array[startIndex + 3] === 111 /* o */ && array[startIndex + 4] === 119 /* w */) ? 36 /* ThrowKeyword */ : 11 /* IdentifierName */;
                        case 119 /* w */:
                            return (array[startIndex + 1] === 104 /* h */ && array[startIndex + 2] === 105 /* i */ && array[startIndex + 3] === 108 /* l */ && array[startIndex + 4] === 101 /* e */) ? 42 /* WhileKeyword */ : 11 /* IdentifierName */;
                        case 115 /* s */:
                            return (array[startIndex + 1] === 117 /* u */ && array[startIndex + 2] === 112 /* p */ && array[startIndex + 3] === 101 /* e */ && array[startIndex + 4] === 114 /* r */) ? 50 /* SuperKeyword */ : 11 /* IdentifierName */;
                        case 121 /* y */:
                            return (array[startIndex + 1] === 105 /* i */ && array[startIndex + 2] === 101 /* e */ && array[startIndex + 3] === 108 /* l */ && array[startIndex + 4] === 100 /* d */) ? 59 /* YieldKeyword */ : 11 /* IdentifierName */;
                        default:
                            return 11 /* IdentifierName */;
                    }

                case 6:
                    switch (array[startIndex]) {
                        case 100 /* d */:
                            return (array[startIndex + 1] === 101 /* e */ && array[startIndex + 2] === 108 /* l */ && array[startIndex + 3] === 101 /* e */ && array[startIndex + 4] === 116 /* t */ && array[startIndex + 5] === 101 /* e */) ? 21 /* DeleteKeyword */ : 11 /* IdentifierName */;
                        case 114 /* r */:
                            return (array[startIndex + 1] === 101 /* e */ && array[startIndex + 2] === 116 /* t */ && array[startIndex + 3] === 117 /* u */ && array[startIndex + 4] === 114 /* r */ && array[startIndex + 5] === 110 /* n */) ? 33 /* ReturnKeyword */ : 11 /* IdentifierName */;
                        case 115 /* s */:
                            switch (array[startIndex + 1]) {
                                case 119 /* w */:
                                    return (array[startIndex + 2] === 105 /* i */ && array[startIndex + 3] === 116 /* t */ && array[startIndex + 4] === 99 /* c */ && array[startIndex + 5] === 104 /* h */) ? 34 /* SwitchKeyword */ : 11 /* IdentifierName */;
                                case 116 /* t */:
                                    switch (array[startIndex + 2]) {
                                        case 97 /* a */:
                                            return (array[startIndex + 3] === 116 /* t */ && array[startIndex + 4] === 105 /* i */ && array[startIndex + 5] === 99 /* c */) ? 58 /* StaticKeyword */ : 11 /* IdentifierName */;
                                        case 114 /* r */:
                                            return (array[startIndex + 3] === 105 /* i */ && array[startIndex + 4] === 110 /* n */ && array[startIndex + 5] === 103 /* g */) ? 70 /* StringKeyword */ : 11 /* IdentifierName */;
                                        default:
                                            return 11 /* IdentifierName */;
                                    }

                                default:
                                    return 11 /* IdentifierName */;
                            }

                        case 116 /* t */:
                            return (array[startIndex + 1] === 121 /* y */ && array[startIndex + 2] === 112 /* p */ && array[startIndex + 3] === 101 /* e */ && array[startIndex + 4] === 111 /* o */ && array[startIndex + 5] === 102 /* f */) ? 39 /* TypeOfKeyword */ : 11 /* IdentifierName */;
                        case 101 /* e */:
                            return (array[startIndex + 1] === 120 /* x */ && array[startIndex + 2] === 112 /* p */ && array[startIndex + 3] === 111 /* o */ && array[startIndex + 4] === 114 /* r */ && array[startIndex + 5] === 116 /* t */) ? 47 /* ExportKeyword */ : 11 /* IdentifierName */;
                        case 105 /* i */:
                            return (array[startIndex + 1] === 109 /* m */ && array[startIndex + 2] === 112 /* p */ && array[startIndex + 3] === 111 /* o */ && array[startIndex + 4] === 114 /* r */ && array[startIndex + 5] === 116 /* t */) ? 49 /* ImportKeyword */ : 11 /* IdentifierName */;
                        case 112 /* p */:
                            return (array[startIndex + 1] === 117 /* u */ && array[startIndex + 2] === 98 /* b */ && array[startIndex + 3] === 108 /* l */ && array[startIndex + 4] === 105 /* i */ && array[startIndex + 5] === 99 /* c */) ? 57 /* PublicKeyword */ : 11 /* IdentifierName */;
                        case 109 /* m */:
                            return (array[startIndex + 1] === 111 /* o */ && array[startIndex + 2] === 100 /* d */ && array[startIndex + 3] === 117 /* u */ && array[startIndex + 4] === 108 /* l */ && array[startIndex + 5] === 101 /* e */) ? 66 /* ModuleKeyword */ : 11 /* IdentifierName */;
                        case 110 /* n */:
                            return (array[startIndex + 1] === 117 /* u */ && array[startIndex + 2] === 109 /* m */ && array[startIndex + 3] === 98 /* b */ && array[startIndex + 4] === 101 /* e */ && array[startIndex + 5] === 114 /* r */) ? 68 /* NumberKeyword */ : 11 /* IdentifierName */;
                        default:
                            return 11 /* IdentifierName */;
                    }

                case 7:
                    switch (array[startIndex]) {
                        case 100 /* d */:
                            switch (array[startIndex + 1]) {
                                case 101 /* e */:
                                    switch (array[startIndex + 2]) {
                                        case 102 /* f */:
                                            return (array[startIndex + 3] === 97 /* a */ && array[startIndex + 4] === 117 /* u */ && array[startIndex + 5] === 108 /* l */ && array[startIndex + 6] === 116 /* t */) ? 20 /* DefaultKeyword */ : 11 /* IdentifierName */;
                                        case 99 /* c */:
                                            return (array[startIndex + 3] === 108 /* l */ && array[startIndex + 4] === 97 /* a */ && array[startIndex + 5] === 114 /* r */ && array[startIndex + 6] === 101 /* e */) ? 64 /* DeclareKeyword */ : 11 /* IdentifierName */;
                                        default:
                                            return 11 /* IdentifierName */;
                                    }

                                default:
                                    return 11 /* IdentifierName */;
                            }

                        case 102 /* f */:
                            return (array[startIndex + 1] === 105 /* i */ && array[startIndex + 2] === 110 /* n */ && array[startIndex + 3] === 97 /* a */ && array[startIndex + 4] === 108 /* l */ && array[startIndex + 5] === 108 /* l */ && array[startIndex + 6] === 121 /* y */) ? 25 /* FinallyKeyword */ : 11 /* IdentifierName */;
                        case 101 /* e */:
                            return (array[startIndex + 1] === 120 /* x */ && array[startIndex + 2] === 116 /* t */ && array[startIndex + 3] === 101 /* e */ && array[startIndex + 4] === 110 /* n */ && array[startIndex + 5] === 100 /* d */ && array[startIndex + 6] === 115 /* s */) ? 48 /* ExtendsKeyword */ : 11 /* IdentifierName */;
                        case 112 /* p */:
                            switch (array[startIndex + 1]) {
                                case 97 /* a */:
                                    return (array[startIndex + 2] === 99 /* c */ && array[startIndex + 3] === 107 /* k */ && array[startIndex + 4] === 97 /* a */ && array[startIndex + 5] === 103 /* g */ && array[startIndex + 6] === 101 /* e */) ? 54 /* PackageKeyword */ : 11 /* IdentifierName */;
                                case 114 /* r */:
                                    return (array[startIndex + 2] === 105 /* i */ && array[startIndex + 3] === 118 /* v */ && array[startIndex + 4] === 97 /* a */ && array[startIndex + 5] === 116 /* t */ && array[startIndex + 6] === 101 /* e */) ? 55 /* PrivateKeyword */ : 11 /* IdentifierName */;
                                default:
                                    return 11 /* IdentifierName */;
                            }

                        case 98 /* b */:
                            return (array[startIndex + 1] === 111 /* o */ && array[startIndex + 2] === 111 /* o */ && array[startIndex + 3] === 108 /* l */ && array[startIndex + 4] === 101 /* e */ && array[startIndex + 5] === 97 /* a */ && array[startIndex + 6] === 110 /* n */) ? 61 /* BooleanKeyword */ : 11 /* IdentifierName */;
                        case 114 /* r */:
                            return (array[startIndex + 1] === 101 /* e */ && array[startIndex + 2] === 113 /* q */ && array[startIndex + 3] === 117 /* u */ && array[startIndex + 4] === 105 /* i */ && array[startIndex + 5] === 114 /* r */ && array[startIndex + 6] === 101 /* e */) ? 67 /* RequireKeyword */ : 11 /* IdentifierName */;
                        default:
                            return 11 /* IdentifierName */;
                    }

                case 8:
                    switch (array[startIndex]) {
                        case 99 /* c */:
                            return (array[startIndex + 1] === 111 /* o */ && array[startIndex + 2] === 110 /* n */ && array[startIndex + 3] === 116 /* t */ && array[startIndex + 4] === 105 /* i */ && array[startIndex + 5] === 110 /* n */ && array[startIndex + 6] === 117 /* u */ && array[startIndex + 7] === 101 /* e */) ? 18 /* ContinueKeyword */ : 11 /* IdentifierName */;
                        case 100 /* d */:
                            return (array[startIndex + 1] === 101 /* e */ && array[startIndex + 2] === 98 /* b */ && array[startIndex + 3] === 117 /* u */ && array[startIndex + 4] === 103 /* g */ && array[startIndex + 5] === 103 /* g */ && array[startIndex + 6] === 101 /* e */ && array[startIndex + 7] === 114 /* r */) ? 19 /* DebuggerKeyword */ : 11 /* IdentifierName */;
                        case 102 /* f */:
                            return (array[startIndex + 1] === 117 /* u */ && array[startIndex + 2] === 110 /* n */ && array[startIndex + 3] === 99 /* c */ && array[startIndex + 4] === 116 /* t */ && array[startIndex + 5] === 105 /* i */ && array[startIndex + 6] === 111 /* o */ && array[startIndex + 7] === 110 /* n */) ? 27 /* FunctionKeyword */ : 11 /* IdentifierName */;
                        default:
                            return 11 /* IdentifierName */;
                    }

                case 9:
                    switch (array[startIndex]) {
                        case 105 /* i */:
                            return (array[startIndex + 1] === 110 /* n */ && array[startIndex + 2] === 116 /* t */ && array[startIndex + 3] === 101 /* e */ && array[startIndex + 4] === 114 /* r */ && array[startIndex + 5] === 102 /* f */ && array[startIndex + 6] === 97 /* a */ && array[startIndex + 7] === 99 /* c */ && array[startIndex + 8] === 101 /* e */) ? 52 /* InterfaceKeyword */ : 11 /* IdentifierName */;
                        case 112 /* p */:
                            return (array[startIndex + 1] === 114 /* r */ && array[startIndex + 2] === 111 /* o */ && array[startIndex + 3] === 116 /* t */ && array[startIndex + 4] === 101 /* e */ && array[startIndex + 5] === 99 /* c */ && array[startIndex + 6] === 116 /* t */ && array[startIndex + 7] === 101 /* e */ && array[startIndex + 8] === 100 /* d */) ? 56 /* ProtectedKeyword */ : 11 /* IdentifierName */;
                        default:
                            return 11 /* IdentifierName */;
                    }

                case 10:
                    switch (array[startIndex]) {
                        case 105 /* i */:
                            switch (array[startIndex + 1]) {
                                case 110 /* n */:
                                    return (array[startIndex + 2] === 115 /* s */ && array[startIndex + 3] === 116 /* t */ && array[startIndex + 4] === 97 /* a */ && array[startIndex + 5] === 110 /* n */ && array[startIndex + 6] === 99 /* c */ && array[startIndex + 7] === 101 /* e */ && array[startIndex + 8] === 111 /* o */ && array[startIndex + 9] === 102 /* f */) ? 30 /* InstanceOfKeyword */ : 11 /* IdentifierName */;
                                case 109 /* m */:
                                    return (array[startIndex + 2] === 112 /* p */ && array[startIndex + 3] === 108 /* l */ && array[startIndex + 4] === 101 /* e */ && array[startIndex + 5] === 109 /* m */ && array[startIndex + 6] === 101 /* e */ && array[startIndex + 7] === 110 /* n */ && array[startIndex + 8] === 116 /* t */ && array[startIndex + 9] === 115 /* s */) ? 51 /* ImplementsKeyword */ : 11 /* IdentifierName */;
                                default:
                                    return 11 /* IdentifierName */;
                            }

                        default:
                            return 11 /* IdentifierName */;
                    }

                case 11:
                    return (array[startIndex] === 99 /* c */ && array[startIndex + 1] === 111 /* o */ && array[startIndex + 2] === 110 /* n */ && array[startIndex + 3] === 115 /* s */ && array[startIndex + 4] === 116 /* t */ && array[startIndex + 5] === 114 /* r */ && array[startIndex + 6] === 117 /* u */ && array[startIndex + 7] === 99 /* c */ && array[startIndex + 8] === 116 /* t */ && array[startIndex + 9] === 111 /* o */ && array[startIndex + 10] === 114 /* r */) ? 63 /* ConstructorKeyword */ : 11 /* IdentifierName */;
                default:
                    return 11 /* IdentifierName */;
            }
        };
        return ScannerUtilities;
    })();
    TypeScript.ScannerUtilities = ScannerUtilities;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Syntax) {
        var EmptySeparatedSyntaxList = (function () {
            function EmptySeparatedSyntaxList() {
            }
            EmptySeparatedSyntaxList.prototype.kind = function () {
                return 2 /* SeparatedList */;
            };

            EmptySeparatedSyntaxList.prototype.isNode = function () {
                return false;
            };

            EmptySeparatedSyntaxList.prototype.isToken = function () {
                return false;
            };

            EmptySeparatedSyntaxList.prototype.isList = function () {
                return false;
            };

            EmptySeparatedSyntaxList.prototype.isSeparatedList = function () {
                return true;
            };

            EmptySeparatedSyntaxList.prototype.toJSON = function (key) {
                return [];
            };

            EmptySeparatedSyntaxList.prototype.childCount = function () {
                return 0;
            };

            EmptySeparatedSyntaxList.prototype.nonSeparatorCount = function () {
                return 0;
            };

            EmptySeparatedSyntaxList.prototype.separatorCount = function () {
                return 0;
            };

            EmptySeparatedSyntaxList.prototype.toArray = function () {
                return [];
            };

            EmptySeparatedSyntaxList.prototype.toNonSeparatorArray = function () {
                return [];
            };

            EmptySeparatedSyntaxList.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            };

            EmptySeparatedSyntaxList.prototype.nonSeparatorAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            };

            EmptySeparatedSyntaxList.prototype.separatorAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            };

            EmptySeparatedSyntaxList.prototype.collectTextElements = function (elements) {
            };

            EmptySeparatedSyntaxList.prototype.firstToken = function () {
                return null;
            };

            EmptySeparatedSyntaxList.prototype.lastToken = function () {
                return null;
            };

            EmptySeparatedSyntaxList.prototype.fullWidth = function () {
                return 0;
            };

            EmptySeparatedSyntaxList.prototype.fullText = function () {
                return "";
            };

            EmptySeparatedSyntaxList.prototype.width = function () {
                return 0;
            };

            EmptySeparatedSyntaxList.prototype.isTypeScriptSpecific = function () {
                return false;
            };

            EmptySeparatedSyntaxList.prototype.isIncrementallyUnusable = function () {
                return false;
            };

            EmptySeparatedSyntaxList.prototype.findTokenInternal = function (parent, position, fullStart) {
                throw TypeScript.Errors.invalidOperation();
            };

            EmptySeparatedSyntaxList.prototype.insertChildrenInto = function (array, index) {
            };

            EmptySeparatedSyntaxList.prototype.leadingTrivia = function () {
                return Syntax.emptyTriviaList;
            };

            EmptySeparatedSyntaxList.prototype.trailingTrivia = function () {
                return Syntax.emptyTriviaList;
            };

            EmptySeparatedSyntaxList.prototype.leadingTriviaWidth = function () {
                return 0;
            };

            EmptySeparatedSyntaxList.prototype.trailingTriviaWidth = function () {
                return 0;
            };
            return EmptySeparatedSyntaxList;
        })();

        Syntax.emptySeparatedList = new EmptySeparatedSyntaxList();

        var SingletonSeparatedSyntaxList = (function () {
            function SingletonSeparatedSyntaxList(item) {
                this.item = item;
            }
            SingletonSeparatedSyntaxList.prototype.toJSON = function (key) {
                return [this.item];
            };

            SingletonSeparatedSyntaxList.prototype.kind = function () {
                return 2 /* SeparatedList */;
            };

            SingletonSeparatedSyntaxList.prototype.isNode = function () {
                return false;
            };
            SingletonSeparatedSyntaxList.prototype.isToken = function () {
                return false;
            };
            SingletonSeparatedSyntaxList.prototype.isList = function () {
                return false;
            };
            SingletonSeparatedSyntaxList.prototype.isSeparatedList = function () {
                return true;
            };

            SingletonSeparatedSyntaxList.prototype.childCount = function () {
                return 1;
            };
            SingletonSeparatedSyntaxList.prototype.nonSeparatorCount = function () {
                return 1;
            };
            SingletonSeparatedSyntaxList.prototype.separatorCount = function () {
                return 0;
            };

            SingletonSeparatedSyntaxList.prototype.toArray = function () {
                return [this.item];
            };
            SingletonSeparatedSyntaxList.prototype.toNonSeparatorArray = function () {
                return [this.item];
            };

            SingletonSeparatedSyntaxList.prototype.childAt = function (index) {
                if (index !== 0) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }

                return this.item;
            };

            SingletonSeparatedSyntaxList.prototype.nonSeparatorAt = function (index) {
                if (index !== 0) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }

                return this.item;
            };

            SingletonSeparatedSyntaxList.prototype.separatorAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            };

            SingletonSeparatedSyntaxList.prototype.collectTextElements = function (elements) {
                this.item.collectTextElements(elements);
            };

            SingletonSeparatedSyntaxList.prototype.firstToken = function () {
                return this.item.firstToken();
            };

            SingletonSeparatedSyntaxList.prototype.lastToken = function () {
                return this.item.lastToken();
            };

            SingletonSeparatedSyntaxList.prototype.fullWidth = function () {
                return this.item.fullWidth();
            };

            SingletonSeparatedSyntaxList.prototype.width = function () {
                return this.item.width();
            };

            SingletonSeparatedSyntaxList.prototype.fullText = function () {
                return this.item.fullText();
            };

            SingletonSeparatedSyntaxList.prototype.leadingTrivia = function () {
                return this.item.leadingTrivia();
            };

            SingletonSeparatedSyntaxList.prototype.trailingTrivia = function () {
                return this.item.trailingTrivia();
            };

            SingletonSeparatedSyntaxList.prototype.leadingTriviaWidth = function () {
                return this.item.leadingTriviaWidth();
            };

            SingletonSeparatedSyntaxList.prototype.trailingTriviaWidth = function () {
                return this.item.trailingTriviaWidth();
            };

            SingletonSeparatedSyntaxList.prototype.isTypeScriptSpecific = function () {
                return this.item.isTypeScriptSpecific();
            };

            SingletonSeparatedSyntaxList.prototype.isIncrementallyUnusable = function () {
                return this.item.isIncrementallyUnusable();
            };

            SingletonSeparatedSyntaxList.prototype.findTokenInternal = function (parent, position, fullStart) {
                return (this.item).findTokenInternal(new TypeScript.PositionedSeparatedList(parent, this, fullStart), position, fullStart);
            };

            SingletonSeparatedSyntaxList.prototype.insertChildrenInto = function (array, index) {
                array.splice(index, 0, this.item);
            };
            return SingletonSeparatedSyntaxList;
        })();

        var NormalSeparatedSyntaxList = (function () {
            function NormalSeparatedSyntaxList(elements) {
                this._data = 0;
                this.elements = elements;
            }
            NormalSeparatedSyntaxList.prototype.kind = function () {
                return 2 /* SeparatedList */;
            };

            NormalSeparatedSyntaxList.prototype.isToken = function () {
                return false;
            };
            NormalSeparatedSyntaxList.prototype.isNode = function () {
                return false;
            };
            NormalSeparatedSyntaxList.prototype.isList = function () {
                return false;
            };
            NormalSeparatedSyntaxList.prototype.isSeparatedList = function () {
                return true;
            };
            NormalSeparatedSyntaxList.prototype.toJSON = function (key) {
                return this.elements;
            };

            NormalSeparatedSyntaxList.prototype.childCount = function () {
                return this.elements.length;
            };
            NormalSeparatedSyntaxList.prototype.nonSeparatorCount = function () {
                return TypeScript.IntegerUtilities.integerDivide(this.elements.length + 1, 2);
            };
            NormalSeparatedSyntaxList.prototype.separatorCount = function () {
                return TypeScript.IntegerUtilities.integerDivide(this.elements.length, 2);
            };

            NormalSeparatedSyntaxList.prototype.toArray = function () {
                return this.elements.slice(0);
            };

            NormalSeparatedSyntaxList.prototype.toNonSeparatorArray = function () {
                var result = [];
                for (var i = 0, n = this.nonSeparatorCount(); i < n; i++) {
                    result.push(this.nonSeparatorAt(i));
                }

                return result;
            };

            NormalSeparatedSyntaxList.prototype.childAt = function (index) {
                if (index < 0 || index >= this.elements.length) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }

                return this.elements[index];
            };

            NormalSeparatedSyntaxList.prototype.nonSeparatorAt = function (index) {
                var value = index * 2;
                if (value < 0 || value >= this.elements.length) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }

                return this.elements[value];
            };

            NormalSeparatedSyntaxList.prototype.separatorAt = function (index) {
                var value = index * 2 + 1;
                if (value < 0 || value >= this.elements.length) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }

                return this.elements[value];
            };

            NormalSeparatedSyntaxList.prototype.firstToken = function () {
                var token;
                for (var i = 0, n = this.elements.length; i < n; i++) {
                    if (i % 2 === 0) {
                        var nodeOrToken = this.elements[i];
                        token = nodeOrToken.firstToken();
                        if (token !== null) {
                            return token;
                        }
                    } else {
                        token = this.elements[i];
                        if (token.width() > 0) {
                            return token;
                        }
                    }
                }

                return null;
            };

            NormalSeparatedSyntaxList.prototype.lastToken = function () {
                var token;
                for (var i = this.elements.length - 1; i >= 0; i--) {
                    if (i % 2 === 0) {
                        var nodeOrToken = this.elements[i];
                        token = nodeOrToken.lastToken();
                        if (token !== null) {
                            return token;
                        }
                    } else {
                        token = this.elements[i];
                        if (token.width() > 0) {
                            return token;
                        }
                    }
                }

                return null;
            };

            NormalSeparatedSyntaxList.prototype.fullText = function () {
                var elements = [];
                this.collectTextElements(elements);
                return elements.join("");
            };

            NormalSeparatedSyntaxList.prototype.isTypeScriptSpecific = function () {
                for (var i = 0, n = this.nonSeparatorCount(); i < n; i++) {
                    if (this.nonSeparatorAt(i).isTypeScriptSpecific()) {
                        return true;
                    }
                }

                return false;
            };

            NormalSeparatedSyntaxList.prototype.isIncrementallyUnusable = function () {
                return (this.data() & 2 /* NodeIncrementallyUnusableMask */) !== 0;
            };

            NormalSeparatedSyntaxList.prototype.fullWidth = function () {
                return this.data() >>> 3 /* NodeFullWidthShift */;
            };

            NormalSeparatedSyntaxList.prototype.width = function () {
                var fullWidth = this.fullWidth();
                return fullWidth - this.leadingTriviaWidth() - this.trailingTriviaWidth();
            };

            NormalSeparatedSyntaxList.prototype.leadingTrivia = function () {
                return this.firstToken().leadingTrivia();
            };

            NormalSeparatedSyntaxList.prototype.trailingTrivia = function () {
                return this.lastToken().trailingTrivia();
            };

            NormalSeparatedSyntaxList.prototype.leadingTriviaWidth = function () {
                return this.firstToken().leadingTriviaWidth();
            };

            NormalSeparatedSyntaxList.prototype.trailingTriviaWidth = function () {
                return this.lastToken().trailingTriviaWidth();
            };

            NormalSeparatedSyntaxList.prototype.computeData = function () {
                var fullWidth = 0;
                var isIncrementallyUnusable = false;

                for (var i = 0, n = this.elements.length; i < n; i++) {
                    var element = this.elements[i];

                    var childWidth = element.fullWidth();
                    fullWidth += childWidth;

                    isIncrementallyUnusable = isIncrementallyUnusable || element.isIncrementallyUnusable();
                }

                return (fullWidth << 3 /* NodeFullWidthShift */) | (isIncrementallyUnusable ? 2 /* NodeIncrementallyUnusableMask */ : 0) | 1 /* NodeDataComputed */;
            };

            NormalSeparatedSyntaxList.prototype.data = function () {
                if ((this._data & 1 /* NodeDataComputed */) === 0) {
                    this._data = this.computeData();
                }

                return this._data;
            };

            NormalSeparatedSyntaxList.prototype.findTokenInternal = function (parent, position, fullStart) {
                parent = new TypeScript.PositionedSeparatedList(parent, this, fullStart);
                for (var i = 0, n = this.elements.length; i < n; i++) {
                    var element = this.elements[i];

                    var childWidth = element.fullWidth();
                    if (position < childWidth) {
                        return (element).findTokenInternal(parent, position, fullStart);
                    }

                    position -= childWidth;
                    fullStart += childWidth;
                }

                throw TypeScript.Errors.invalidOperation();
            };

            NormalSeparatedSyntaxList.prototype.collectTextElements = function (elements) {
                for (var i = 0, n = this.elements.length; i < n; i++) {
                    var element = this.elements[i];
                    element.collectTextElements(elements);
                }
            };

            NormalSeparatedSyntaxList.prototype.insertChildrenInto = function (array, index) {
                if (index === 0) {
                    array.unshift.apply(array, this.elements);
                } else {
                    array.splice.apply(array, [index, 0].concat(this.elements));
                }
            };
            return NormalSeparatedSyntaxList;
        })();

        function separatedList(nodes) {
            return separatedListAndValidate(nodes, false);
        }
        Syntax.separatedList = separatedList;

        function separatedListAndValidate(nodes, validate) {
            if (nodes === undefined || nodes === null || nodes.length === 0) {
                return Syntax.emptySeparatedList;
            }

            if (validate) {
                for (var i = 0; i < nodes.length; i++) {
                    var item = nodes[i];

                    if (i % 2 === 1) {
                    }
                }
            }

            if (nodes.length === 1) {
                return new SingletonSeparatedSyntaxList(nodes[0]);
            }

            return new NormalSeparatedSyntaxList(nodes);
        }
    })(TypeScript.Syntax || (TypeScript.Syntax = {}));
    var Syntax = TypeScript.Syntax;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SlidingWindow = (function () {
        function SlidingWindow(source, window, defaultValue, sourceLength) {
            if (typeof sourceLength === "undefined") { sourceLength = -1; }
            this.source = source;
            this.window = window;
            this.defaultValue = defaultValue;
            this.sourceLength = sourceLength;
            this.windowCount = 0;
            this.windowAbsoluteStartIndex = 0;
            this.currentRelativeItemIndex = 0;
            this._pinCount = 0;
            this.firstPinnedAbsoluteIndex = -1;
        }
        SlidingWindow.prototype.windowAbsoluteEndIndex = function () {
            return this.windowAbsoluteStartIndex + this.windowCount;
        };

        SlidingWindow.prototype.addMoreItemsToWindow = function (argument) {
            if (this.sourceLength >= 0 && this.absoluteIndex() >= this.sourceLength) {
                return false;
            }

            if (this.windowCount >= this.window.length) {
                this.tryShiftOrGrowWindow();
            }

            var spaceAvailable = this.window.length - this.windowCount;
            var amountFetched = this.source.fetchMoreItems(argument, this.windowAbsoluteEndIndex(), this.window, this.windowCount, spaceAvailable);

            this.windowCount += amountFetched;
            return amountFetched > 0;
        };

        SlidingWindow.prototype.tryShiftOrGrowWindow = function () {
            var currentIndexIsPastWindowHalfwayPoint = this.currentRelativeItemIndex > (this.window.length >>> 1);

            var isAllowedToShift = this.firstPinnedAbsoluteIndex === -1 || this.firstPinnedAbsoluteIndex > this.windowAbsoluteStartIndex;

            if (currentIndexIsPastWindowHalfwayPoint && isAllowedToShift) {
                var shiftStartIndex = this.firstPinnedAbsoluteIndex === -1 ? this.currentRelativeItemIndex : this.firstPinnedAbsoluteIndex - this.windowAbsoluteStartIndex;

                var shiftCount = this.windowCount - shiftStartIndex;

                if (shiftCount > 0) {
                    TypeScript.ArrayUtilities.copy(this.window, shiftStartIndex, this.window, 0, shiftCount);
                }

                this.windowAbsoluteStartIndex += shiftStartIndex;

                this.windowCount -= shiftStartIndex;

                this.currentRelativeItemIndex -= shiftStartIndex;
            } else {
                TypeScript.ArrayUtilities.grow(this.window, this.window.length * 2, this.defaultValue);
            }
        };

        SlidingWindow.prototype.absoluteIndex = function () {
            return this.windowAbsoluteStartIndex + this.currentRelativeItemIndex;
        };

        SlidingWindow.prototype.isAtEndOfSource = function () {
            return this.absoluteIndex() >= this.sourceLength;
        };

        SlidingWindow.prototype.getAndPinAbsoluteIndex = function () {
            var absoluteIndex = this.absoluteIndex();
            var pinCount = this._pinCount++;
            if (pinCount === 0) {
                this.firstPinnedAbsoluteIndex = absoluteIndex;
            }

            return absoluteIndex;
        };

        SlidingWindow.prototype.releaseAndUnpinAbsoluteIndex = function (absoluteIndex) {
            this._pinCount--;
            if (this._pinCount === 0) {
                this.firstPinnedAbsoluteIndex = -1;
            }
        };

        SlidingWindow.prototype.rewindToPinnedIndex = function (absoluteIndex) {
            var relativeIndex = absoluteIndex - this.windowAbsoluteStartIndex;

            this.currentRelativeItemIndex = relativeIndex;
        };

        SlidingWindow.prototype.currentItem = function (argument) {
            if (this.currentRelativeItemIndex >= this.windowCount) {
                if (!this.addMoreItemsToWindow(argument)) {
                    return this.defaultValue;
                }
            }

            return this.window[this.currentRelativeItemIndex];
        };

        SlidingWindow.prototype.peekItemN = function (n) {
            while (this.currentRelativeItemIndex + n >= this.windowCount) {
                if (!this.addMoreItemsToWindow(null)) {
                    return this.defaultValue;
                }
            }

            return this.window[this.currentRelativeItemIndex + n];
        };

        SlidingWindow.prototype.moveToNextItem = function () {
            this.currentRelativeItemIndex++;
        };

        SlidingWindow.prototype.disgardAllItemsFromCurrentIndexOnwards = function () {
            this.windowCount = this.currentRelativeItemIndex;
        };

        SlidingWindow.prototype.setAbsoluteIndex = function (absoluteIndex) {
            if (this.absoluteIndex() === absoluteIndex) {
                return;
            }

            if (this._pinCount > 0) {
            }

            if (absoluteIndex >= this.windowAbsoluteStartIndex && absoluteIndex < this.windowAbsoluteEndIndex()) {
                this.currentRelativeItemIndex = (absoluteIndex - this.windowAbsoluteStartIndex);
            } else {
                this.windowAbsoluteStartIndex = absoluteIndex;

                this.windowCount = 0;

                this.currentRelativeItemIndex = 0;
            }
        };

        SlidingWindow.prototype.pinCount = function () {
            return this._pinCount;
        };
        return SlidingWindow;
    })();
    TypeScript.SlidingWindow = SlidingWindow;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Strings = (function () {
        function Strings() {
        }
        Strings.module__class__interface__enum__import_or_statement = "module, class, interface, enum, import or statement";
        Strings.constructor__function__accessor_or_variable = "constructor, function, accessor or variable";
        Strings.statement = "statement";
        Strings.case_or_default_clause = "case or default clause";
        Strings.identifier = "identifier";
        Strings.call__construct__index__property_or_function_signature = "call, construct, index, property or function signature";
        Strings.expression = "expression";
        Strings.type_name = "type name";
        Strings.property_or_accessor = "property or accessor";
        Strings.parameter = "parameter";
        Strings.type = "type";
        Strings.type_parameter = "type parameter";
        return Strings;
    })();
    TypeScript.Strings = Strings;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Syntax) {
        function emptySourceUnit() {
            return TypeScript.Syntax.normalModeFactory.sourceUnit(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(10 /* EndOfFileToken */, { text: "" }));
        }
        Syntax.emptySourceUnit = emptySourceUnit;

        function getStandaloneExpression(positionedToken) {
            var token = positionedToken.token();
            if (positionedToken !== null && positionedToken.kind() === 11 /* IdentifierName */) {
                var parentPositionedNode = positionedToken.containingNode();
                var parentNode = parentPositionedNode.node();

                if (parentNode.kind() === 122 /* QualifiedName */ && (parentNode).right === token) {
                    return parentPositionedNode;
                } else if (parentNode.kind() === 211 /* MemberAccessExpression */ && (parentNode).name === token) {
                    return parentPositionedNode;
                }
            }

            return positionedToken;
        }
        Syntax.getStandaloneExpression = getStandaloneExpression;

        function isInModuleOrTypeContext(positionedToken) {
            if (positionedToken !== null) {
                var positionedNodeOrToken = TypeScript.Syntax.getStandaloneExpression(positionedToken);
                var parent = positionedNodeOrToken.containingNode();

                if (parent !== null) {
                    switch (parent.kind()) {
                        case 246 /* ModuleNameModuleReference */:
                            return true;
                        case 122 /* QualifiedName */:
                            return true;
                        default:
                            return isInTypeOnlyContext(positionedToken);
                    }
                }
            }

            return false;
        }
        Syntax.isInModuleOrTypeContext = isInModuleOrTypeContext;

        function isInTypeOnlyContext(positionedToken) {
            var positionedNodeOrToken = TypeScript.Syntax.getStandaloneExpression(positionedToken);
            var positionedParent = positionedNodeOrToken.containingNode();

            var parent = positionedParent.node();
            var nodeOrToken = positionedNodeOrToken.nodeOrToken();

            if (parent !== null) {
                switch (parent.kind()) {
                    case 125 /* ArrayType */:
                        return (parent).type === nodeOrToken;
                    case 219 /* CastExpression */:
                        return (parent).type === nodeOrToken;
                    case 244 /* TypeAnnotation */:
                    case 229 /* HeritageClause */:
                    case 227 /* TypeArgumentList */:
                        return true;
                }
            }

            return false;
        }
        Syntax.isInTypeOnlyContext = isInTypeOnlyContext;

        function childOffset(parent, child) {
            var offset = 0;
            for (var i = 0, n = parent.childCount(); i < n; i++) {
                var current = parent.childAt(i);
                if (current === child) {
                    return offset;
                }

                if (current !== null) {
                    offset += current.fullWidth();
                }
            }

            throw TypeScript.Errors.invalidOperation();
        }
        Syntax.childOffset = childOffset;

        function childOffsetAt(parent, index) {
            var offset = 0;
            for (var i = 0; i < index; i++) {
                var current = parent.childAt(i);
                if (current !== null) {
                    offset += current.fullWidth();
                }
            }

            return offset;
        }
        Syntax.childOffsetAt = childOffsetAt;

        function childIndex(parent, child) {
            for (var i = 0, n = parent.childCount(); i < n; i++) {
                var current = parent.childAt(i);
                if (current === child) {
                    return i;
                }
            }

            throw TypeScript.Errors.invalidOperation();
        }
        Syntax.childIndex = childIndex;

        function nodeStructuralEquals(node1, node2) {
            if (node1 === null) {
                return node2 === null;
            }

            return node1.structuralEquals(node2);
        }
        Syntax.nodeStructuralEquals = nodeStructuralEquals;

        function nodeOrTokenStructuralEquals(node1, node2) {
            if (node1 === node2) {
                return true;
            }

            if (node1 === null || node2 === null) {
                return false;
            }

            if (node1.isToken()) {
                return node2.isToken() ? tokenStructuralEquals(node1, node2) : false;
            }

            return node2.isNode() ? nodeStructuralEquals(node1, node2) : false;
        }
        Syntax.nodeOrTokenStructuralEquals = nodeOrTokenStructuralEquals;

        function tokenStructuralEquals(token1, token2) {
            if (token1 === token2) {
                return true;
            }

            if (token1 === null || token2 === null) {
                return false;
            }

            return token1.kind() === token2.kind() && token1.width() === token2.width() && token1.fullWidth() === token2.fullWidth() && token1.text() === token2.text() && TypeScript.Syntax.triviaListStructuralEquals(token1.leadingTrivia(), token2.leadingTrivia()) && TypeScript.Syntax.triviaListStructuralEquals(token1.trailingTrivia(), token2.trailingTrivia());
        }
        Syntax.tokenStructuralEquals = tokenStructuralEquals;

        function triviaListStructuralEquals(triviaList1, triviaList2) {
            if (triviaList1.count() !== triviaList2.count()) {
                return false;
            }

            for (var i = 0, n = triviaList1.count(); i < n; i++) {
                if (!TypeScript.Syntax.triviaStructuralEquals(triviaList1.syntaxTriviaAt(i), triviaList2.syntaxTriviaAt(i))) {
                    return false;
                }
            }

            return true;
        }
        Syntax.triviaListStructuralEquals = triviaListStructuralEquals;

        function triviaStructuralEquals(trivia1, trivia2) {
            return trivia1.kind() === trivia2.kind() && trivia1.fullWidth() === trivia2.fullWidth() && trivia1.fullText() === trivia2.fullText();
        }
        Syntax.triviaStructuralEquals = triviaStructuralEquals;

        function listStructuralEquals(list1, list2) {
            if (list1.childCount() !== list2.childCount()) {
                return false;
            }

            for (var i = 0, n = list1.childCount(); i < n; i++) {
                var child1 = list1.childAt(i);
                var child2 = list2.childAt(i);

                if (!TypeScript.Syntax.nodeOrTokenStructuralEquals(child1, child2)) {
                    return false;
                }
            }

            return true;
        }
        Syntax.listStructuralEquals = listStructuralEquals;

        function separatedListStructuralEquals(list1, list2) {
            if (list1.childCount() !== list2.childCount()) {
                return false;
            }

            for (var i = 0, n = list1.childCount(); i < n; i++) {
                var element1 = list1.childAt(i);
                var element2 = list2.childAt(i);
                if (!TypeScript.Syntax.nodeOrTokenStructuralEquals(element1, element2)) {
                    return false;
                }
            }

            return true;
        }
        Syntax.separatedListStructuralEquals = separatedListStructuralEquals;

        function elementStructuralEquals(element1, element2) {
            if (element1 === element2) {
                return true;
            }

            if (element1 === null || element2 === null) {
                return false;
            }

            if (element2.kind() !== element2.kind()) {
                return false;
            }

            if (element1.isToken()) {
                return tokenStructuralEquals(element1, element2);
            } else if (element1.isNode()) {
                return nodeStructuralEquals(element1, element2);
            } else if (element1.isList()) {
                return listStructuralEquals(element1, element2);
            } else if (element1.isSeparatedList()) {
                return separatedListStructuralEquals(element1, element2);
            }

            throw TypeScript.Errors.invalidOperation();
        }
        Syntax.elementStructuralEquals = elementStructuralEquals;

        function identifierName(text, info) {
            if (typeof info === "undefined") { info = null; }
            return Syntax.identifier(text);
        }
        Syntax.identifierName = identifierName;

        function trueExpression() {
            return TypeScript.Syntax.token(37 /* TrueKeyword */);
        }
        Syntax.trueExpression = trueExpression;

        function falseExpression() {
            return TypeScript.Syntax.token(24 /* FalseKeyword */);
        }
        Syntax.falseExpression = falseExpression;

        function numericLiteralExpression(text) {
            return TypeScript.Syntax.token(13 /* NumericLiteral */, { text: text });
        }
        Syntax.numericLiteralExpression = numericLiteralExpression;

        function stringLiteralExpression(text) {
            return TypeScript.Syntax.token(14 /* StringLiteral */, { text: text });
        }
        Syntax.stringLiteralExpression = stringLiteralExpression;

        function isSuperInvocationExpression(node) {
            return node.kind() === 212 /* InvocationExpression */ && (node).expression.kind() === 50 /* SuperKeyword */;
        }
        Syntax.isSuperInvocationExpression = isSuperInvocationExpression;

        function isSuperInvocationExpressionStatement(node) {
            return node.kind() === 148 /* ExpressionStatement */ && isSuperInvocationExpression((node).expression);
        }
        Syntax.isSuperInvocationExpressionStatement = isSuperInvocationExpressionStatement;

        function isSuperMemberAccessExpression(node) {
            return node.kind() === 211 /* MemberAccessExpression */ && (node).expression.kind() === 50 /* SuperKeyword */;
        }
        Syntax.isSuperMemberAccessExpression = isSuperMemberAccessExpression;

        function isSuperMemberAccessInvocationExpression(node) {
            return node.kind() === 212 /* InvocationExpression */ && isSuperMemberAccessExpression((node).expression);
        }
        Syntax.isSuperMemberAccessInvocationExpression = isSuperMemberAccessInvocationExpression;

        function assignmentExpression(left, token, right) {
            return TypeScript.Syntax.normalModeFactory.binaryExpression(173 /* AssignmentExpression */, left, token, right);
        }
        Syntax.assignmentExpression = assignmentExpression;

        function nodeHasSkippedOrMissingTokens(node) {
            for (var i = 0; i < node.childCount(); i++) {
                var child = node.childAt(i);
                if (child !== null && child.isToken()) {
                    var token = child;

                    if (token.hasSkippedToken() || (token.width() === 0 && token.kind() !== 10 /* EndOfFileToken */)) {
                        return true;
                    }
                }
            }
            return false;
        }
        Syntax.nodeHasSkippedOrMissingTokens = nodeHasSkippedOrMissingTokens;

        function isUnterminatedStringLiteral(token) {
            if (token && token.kind() === 14 /* StringLiteral */) {
                var text = token.text();
                return text.length < 2 || text.charCodeAt(text.length - 1) !== text.charCodeAt(0);
            }

            return false;
        }
        Syntax.isUnterminatedStringLiteral = isUnterminatedStringLiteral;

        function isUnterminatedMultilineCommentTrivia(trivia) {
            if (trivia && trivia.kind() === 6 /* MultiLineCommentTrivia */) {
                var text = trivia.fullText();
                return text.length < 4 || text.substring(text.length - 2) !== "*/";
            }
            return false;
        }
        Syntax.isUnterminatedMultilineCommentTrivia = isUnterminatedMultilineCommentTrivia;

        function isEntirelyInsideCommentTrivia(trivia, fullStart, position) {
            if (trivia && trivia.isComment() && position > fullStart) {
                var end = fullStart + trivia.fullWidth();
                if (position < end) {
                    return true;
                } else if (position === end) {
                    return trivia.kind() === 7 /* SingleLineCommentTrivia */ || isUnterminatedMultilineCommentTrivia(trivia);
                }
            }

            return false;
        }
        Syntax.isEntirelyInsideCommentTrivia = isEntirelyInsideCommentTrivia;

        function isEntirelyInsideComment(sourceUnit, position) {
            var positionedToken = sourceUnit.findToken(position);
            var fullStart = positionedToken.fullStart();
            var triviaList = null;
            var lastTriviaBeforeToken = null;

            if (positionedToken.kind() === 10 /* EndOfFileToken */) {
                if (positionedToken.token().hasLeadingTrivia()) {
                    triviaList = positionedToken.token().leadingTrivia();
                } else {
                    positionedToken = positionedToken.previousToken();
                    if (positionedToken) {
                        if (positionedToken && positionedToken.token().hasTrailingTrivia()) {
                            triviaList = positionedToken.token().trailingTrivia();
                            fullStart = positionedToken.end();
                        }
                    }
                }
            } else {
                if (position <= (fullStart + positionedToken.token().leadingTriviaWidth())) {
                    triviaList = positionedToken.token().leadingTrivia();
                } else if (position >= (fullStart + positionedToken.token().width())) {
                    triviaList = positionedToken.token().trailingTrivia();
                    fullStart = positionedToken.end();
                }
            }

            if (triviaList) {
                for (var i = 0, n = triviaList.count(); i < n; i++) {
                    var trivia = triviaList.syntaxTriviaAt(i);
                    if (position <= fullStart) {
                        break;
                    } else if (position <= fullStart + trivia.fullWidth() && trivia.isComment()) {
                        lastTriviaBeforeToken = trivia;
                        break;
                    }

                    fullStart += trivia.fullWidth();
                }
            }

            return lastTriviaBeforeToken && isEntirelyInsideCommentTrivia(lastTriviaBeforeToken, fullStart, position);
        }
        Syntax.isEntirelyInsideComment = isEntirelyInsideComment;

        function isEntirelyInStringOrRegularExpressionLiteral(sourceUnit, position) {
            var positionedToken = sourceUnit.findToken(position);

            if (positionedToken) {
                if (positionedToken.kind() === 10 /* EndOfFileToken */) {
                    positionedToken = positionedToken.previousToken();
                    return positionedToken && positionedToken.token().trailingTriviaWidth() === 0 && isUnterminatedStringLiteral(positionedToken.token());
                } else if (position > positionedToken.start()) {
                    return (position < positionedToken.end() && (positionedToken.kind() === 14 /* StringLiteral */ || positionedToken.kind() === 12 /* RegularExpressionLiteral */)) || (position <= positionedToken.end() && isUnterminatedStringLiteral(positionedToken.token()));
                }
            }

            return false;
        }
        Syntax.isEntirelyInStringOrRegularExpressionLiteral = isEntirelyInStringOrRegularExpressionLiteral;

        function findSkippedTokenInTriviaList(positionedToken, position, lookInLeadingTriviaList) {
            var triviaList = null;
            var fullStart;

            if (lookInLeadingTriviaList) {
                triviaList = positionedToken.token().leadingTrivia();
                fullStart = positionedToken.fullStart();
            } else {
                triviaList = positionedToken.token().trailingTrivia();
                fullStart = positionedToken.end();
            }

            if (triviaList && triviaList.hasSkippedToken()) {
                for (var i = 0, n = triviaList.count(); i < n; i++) {
                    var trivia = triviaList.syntaxTriviaAt(i);
                    var triviaWidth = trivia.fullWidth();

                    if (trivia.isSkippedToken() && position >= fullStart && position <= fullStart + triviaWidth) {
                        return new TypeScript.PositionedSkippedToken(positionedToken, trivia.skippedToken(), fullStart);
                    }

                    fullStart += triviaWidth;
                }
            }

            return null;
        }

        function findSkippedTokenInLeadingTriviaList(positionedToken, position) {
            return findSkippedTokenInTriviaList(positionedToken, position, true);
        }
        Syntax.findSkippedTokenInLeadingTriviaList = findSkippedTokenInLeadingTriviaList;

        function findSkippedTokenInTrailingTriviaList(positionedToken, position) {
            return findSkippedTokenInTriviaList(positionedToken, position, false);
        }
        Syntax.findSkippedTokenInTrailingTriviaList = findSkippedTokenInTrailingTriviaList;

        function findSkippedTokenInPositionedToken(positionedToken, position) {
            var positionInLeadingTriviaList = (position < positionedToken.start());
            return findSkippedTokenInTriviaList(positionedToken, position, positionInLeadingTriviaList);
        }
        Syntax.findSkippedTokenInPositionedToken = findSkippedTokenInPositionedToken;

        function getAncestorOfKind(positionedToken, kind) {
            while (positionedToken && positionedToken.parent()) {
                if (positionedToken.parent().kind() === kind) {
                    return positionedToken.parent();
                }

                positionedToken = positionedToken.parent();
            }

            return null;
        }
        Syntax.getAncestorOfKind = getAncestorOfKind;

        function hasAncestorOfKind(positionedToken, kind) {
            return TypeScript.Syntax.getAncestorOfKind(positionedToken, kind) !== null;
        }
        Syntax.hasAncestorOfKind = hasAncestorOfKind;
    })(TypeScript.Syntax || (TypeScript.Syntax = {}));
    var Syntax = TypeScript.Syntax;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxDiagnostic = (function (_super) {
        __extends(SyntaxDiagnostic, _super);
        function SyntaxDiagnostic() {
            _super.apply(this, arguments);
        }
        SyntaxDiagnostic.equals = function (diagnostic1, diagnostic2) {
            return TypeScript.Diagnostic.equals(diagnostic1, diagnostic2);
        };
        return SyntaxDiagnostic;
    })(TypeScript.Diagnostic);
    TypeScript.SyntaxDiagnostic = SyntaxDiagnostic;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Syntax) {
        var NormalModeFactory = (function () {
            function NormalModeFactory() {
            }
            NormalModeFactory.prototype.sourceUnit = function (moduleElements, endOfFileToken) {
                return new TypeScript.SourceUnitSyntax(moduleElements, endOfFileToken, false);
            };
            NormalModeFactory.prototype.externalModuleReference = function (moduleOrRequireKeyword, openParenToken, stringLiteral, closeParenToken) {
                return new TypeScript.ExternalModuleReferenceSyntax(moduleOrRequireKeyword, openParenToken, stringLiteral, closeParenToken, false);
            };
            NormalModeFactory.prototype.moduleNameModuleReference = function (moduleName) {
                return new TypeScript.ModuleNameModuleReferenceSyntax(moduleName, false);
            };
            NormalModeFactory.prototype.importDeclaration = function (importKeyword, identifier, equalsToken, moduleReference, semicolonToken) {
                return new TypeScript.ImportDeclarationSyntax(importKeyword, identifier, equalsToken, moduleReference, semicolonToken, false);
            };
            NormalModeFactory.prototype.exportAssignment = function (exportKeyword, equalsToken, identifier, semicolonToken) {
                return new TypeScript.ExportAssignmentSyntax(exportKeyword, equalsToken, identifier, semicolonToken, false);
            };
            NormalModeFactory.prototype.classDeclaration = function (modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken) {
                return new TypeScript.ClassDeclarationSyntax(modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken, false);
            };
            NormalModeFactory.prototype.interfaceDeclaration = function (modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, body) {
                return new TypeScript.InterfaceDeclarationSyntax(modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, body, false);
            };
            NormalModeFactory.prototype.heritageClause = function (extendsOrImplementsKeyword, typeNames) {
                return new TypeScript.HeritageClauseSyntax(extendsOrImplementsKeyword, typeNames, false);
            };
            NormalModeFactory.prototype.moduleDeclaration = function (modifiers, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken) {
                return new TypeScript.ModuleDeclarationSyntax(modifiers, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken, false);
            };
            NormalModeFactory.prototype.functionDeclaration = function (modifiers, functionKeyword, identifier, callSignature, block, semicolonToken) {
                return new TypeScript.FunctionDeclarationSyntax(modifiers, functionKeyword, identifier, callSignature, block, semicolonToken, false);
            };
            NormalModeFactory.prototype.variableStatement = function (modifiers, variableDeclaration, semicolonToken) {
                return new TypeScript.VariableStatementSyntax(modifiers, variableDeclaration, semicolonToken, false);
            };
            NormalModeFactory.prototype.variableDeclaration = function (varKeyword, variableDeclarators) {
                return new TypeScript.VariableDeclarationSyntax(varKeyword, variableDeclarators, false);
            };
            NormalModeFactory.prototype.variableDeclarator = function (identifier, typeAnnotation, equalsValueClause) {
                return new TypeScript.VariableDeclaratorSyntax(identifier, typeAnnotation, equalsValueClause, false);
            };
            NormalModeFactory.prototype.equalsValueClause = function (equalsToken, value) {
                return new TypeScript.EqualsValueClauseSyntax(equalsToken, value, false);
            };
            NormalModeFactory.prototype.prefixUnaryExpression = function (kind, operatorToken, operand) {
                return new TypeScript.PrefixUnaryExpressionSyntax(kind, operatorToken, operand, false);
            };
            NormalModeFactory.prototype.arrayLiteralExpression = function (openBracketToken, expressions, closeBracketToken) {
                return new TypeScript.ArrayLiteralExpressionSyntax(openBracketToken, expressions, closeBracketToken, false);
            };
            NormalModeFactory.prototype.omittedExpression = function () {
                return new TypeScript.OmittedExpressionSyntax(false);
            };
            NormalModeFactory.prototype.parenthesizedExpression = function (openParenToken, expression, closeParenToken) {
                return new TypeScript.ParenthesizedExpressionSyntax(openParenToken, expression, closeParenToken, false);
            };
            NormalModeFactory.prototype.simpleArrowFunctionExpression = function (identifier, equalsGreaterThanToken, body) {
                return new TypeScript.SimpleArrowFunctionExpressionSyntax(identifier, equalsGreaterThanToken, body, false);
            };
            NormalModeFactory.prototype.parenthesizedArrowFunctionExpression = function (callSignature, equalsGreaterThanToken, body) {
                return new TypeScript.ParenthesizedArrowFunctionExpressionSyntax(callSignature, equalsGreaterThanToken, body, false);
            };
            NormalModeFactory.prototype.qualifiedName = function (left, dotToken, right) {
                return new TypeScript.QualifiedNameSyntax(left, dotToken, right, false);
            };
            NormalModeFactory.prototype.typeArgumentList = function (lessThanToken, typeArguments, greaterThanToken) {
                return new TypeScript.TypeArgumentListSyntax(lessThanToken, typeArguments, greaterThanToken, false);
            };
            NormalModeFactory.prototype.constructorType = function (newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type) {
                return new TypeScript.ConstructorTypeSyntax(newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type, false);
            };
            NormalModeFactory.prototype.functionType = function (typeParameterList, parameterList, equalsGreaterThanToken, type) {
                return new TypeScript.FunctionTypeSyntax(typeParameterList, parameterList, equalsGreaterThanToken, type, false);
            };
            NormalModeFactory.prototype.objectType = function (openBraceToken, typeMembers, closeBraceToken) {
                return new TypeScript.ObjectTypeSyntax(openBraceToken, typeMembers, closeBraceToken, false);
            };
            NormalModeFactory.prototype.arrayType = function (type, openBracketToken, closeBracketToken) {
                return new TypeScript.ArrayTypeSyntax(type, openBracketToken, closeBracketToken, false);
            };
            NormalModeFactory.prototype.genericType = function (name, typeArgumentList) {
                return new TypeScript.GenericTypeSyntax(name, typeArgumentList, false);
            };
            NormalModeFactory.prototype.typeAnnotation = function (colonToken, type) {
                return new TypeScript.TypeAnnotationSyntax(colonToken, type, false);
            };
            NormalModeFactory.prototype.block = function (openBraceToken, statements, closeBraceToken) {
                return new TypeScript.BlockSyntax(openBraceToken, statements, closeBraceToken, false);
            };
            NormalModeFactory.prototype.parameter = function (dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause) {
                return new TypeScript.ParameterSyntax(dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause, false);
            };
            NormalModeFactory.prototype.memberAccessExpression = function (expression, dotToken, name) {
                return new TypeScript.MemberAccessExpressionSyntax(expression, dotToken, name, false);
            };
            NormalModeFactory.prototype.postfixUnaryExpression = function (kind, operand, operatorToken) {
                return new TypeScript.PostfixUnaryExpressionSyntax(kind, operand, operatorToken, false);
            };
            NormalModeFactory.prototype.elementAccessExpression = function (expression, openBracketToken, argumentExpression, closeBracketToken) {
                return new TypeScript.ElementAccessExpressionSyntax(expression, openBracketToken, argumentExpression, closeBracketToken, false);
            };
            NormalModeFactory.prototype.invocationExpression = function (expression, argumentList) {
                return new TypeScript.InvocationExpressionSyntax(expression, argumentList, false);
            };
            NormalModeFactory.prototype.argumentList = function (typeArgumentList, openParenToken, _arguments, closeParenToken) {
                return new TypeScript.ArgumentListSyntax(typeArgumentList, openParenToken, _arguments, closeParenToken, false);
            };
            NormalModeFactory.prototype.binaryExpression = function (kind, left, operatorToken, right) {
                return new TypeScript.BinaryExpressionSyntax(kind, left, operatorToken, right, false);
            };
            NormalModeFactory.prototype.conditionalExpression = function (condition, questionToken, whenTrue, colonToken, whenFalse) {
                return new TypeScript.ConditionalExpressionSyntax(condition, questionToken, whenTrue, colonToken, whenFalse, false);
            };
            NormalModeFactory.prototype.constructSignature = function (newKeyword, callSignature) {
                return new TypeScript.ConstructSignatureSyntax(newKeyword, callSignature, false);
            };
            NormalModeFactory.prototype.methodSignature = function (propertyName, questionToken, callSignature) {
                return new TypeScript.MethodSignatureSyntax(propertyName, questionToken, callSignature, false);
            };
            NormalModeFactory.prototype.indexSignature = function (openBracketToken, parameter, closeBracketToken, typeAnnotation) {
                return new TypeScript.IndexSignatureSyntax(openBracketToken, parameter, closeBracketToken, typeAnnotation, false);
            };
            NormalModeFactory.prototype.propertySignature = function (propertyName, questionToken, typeAnnotation) {
                return new TypeScript.PropertySignatureSyntax(propertyName, questionToken, typeAnnotation, false);
            };
            NormalModeFactory.prototype.callSignature = function (typeParameterList, parameterList, typeAnnotation) {
                return new TypeScript.CallSignatureSyntax(typeParameterList, parameterList, typeAnnotation, false);
            };
            NormalModeFactory.prototype.parameterList = function (openParenToken, parameters, closeParenToken) {
                return new TypeScript.ParameterListSyntax(openParenToken, parameters, closeParenToken, false);
            };
            NormalModeFactory.prototype.typeParameterList = function (lessThanToken, typeParameters, greaterThanToken) {
                return new TypeScript.TypeParameterListSyntax(lessThanToken, typeParameters, greaterThanToken, false);
            };
            NormalModeFactory.prototype.typeParameter = function (identifier, constraint) {
                return new TypeScript.TypeParameterSyntax(identifier, constraint, false);
            };
            NormalModeFactory.prototype.constraint = function (extendsKeyword, type) {
                return new TypeScript.ConstraintSyntax(extendsKeyword, type, false);
            };
            NormalModeFactory.prototype.elseClause = function (elseKeyword, statement) {
                return new TypeScript.ElseClauseSyntax(elseKeyword, statement, false);
            };
            NormalModeFactory.prototype.ifStatement = function (ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause) {
                return new TypeScript.IfStatementSyntax(ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause, false);
            };
            NormalModeFactory.prototype.expressionStatement = function (expression, semicolonToken) {
                return new TypeScript.ExpressionStatementSyntax(expression, semicolonToken, false);
            };
            NormalModeFactory.prototype.constructorDeclaration = function (constructorKeyword, parameterList, block, semicolonToken) {
                return new TypeScript.ConstructorDeclarationSyntax(constructorKeyword, parameterList, block, semicolonToken, false);
            };
            NormalModeFactory.prototype.memberFunctionDeclaration = function (modifiers, propertyName, callSignature, block, semicolonToken) {
                return new TypeScript.MemberFunctionDeclarationSyntax(modifiers, propertyName, callSignature, block, semicolonToken, false);
            };
            NormalModeFactory.prototype.getMemberAccessorDeclaration = function (modifiers, getKeyword, propertyName, parameterList, typeAnnotation, block) {
                return new TypeScript.GetMemberAccessorDeclarationSyntax(modifiers, getKeyword, propertyName, parameterList, typeAnnotation, block, false);
            };
            NormalModeFactory.prototype.setMemberAccessorDeclaration = function (modifiers, setKeyword, propertyName, parameterList, block) {
                return new TypeScript.SetMemberAccessorDeclarationSyntax(modifiers, setKeyword, propertyName, parameterList, block, false);
            };
            NormalModeFactory.prototype.memberVariableDeclaration = function (modifiers, variableDeclarator, semicolonToken) {
                return new TypeScript.MemberVariableDeclarationSyntax(modifiers, variableDeclarator, semicolonToken, false);
            };
            NormalModeFactory.prototype.throwStatement = function (throwKeyword, expression, semicolonToken) {
                return new TypeScript.ThrowStatementSyntax(throwKeyword, expression, semicolonToken, false);
            };
            NormalModeFactory.prototype.returnStatement = function (returnKeyword, expression, semicolonToken) {
                return new TypeScript.ReturnStatementSyntax(returnKeyword, expression, semicolonToken, false);
            };
            NormalModeFactory.prototype.objectCreationExpression = function (newKeyword, expression, argumentList) {
                return new TypeScript.ObjectCreationExpressionSyntax(newKeyword, expression, argumentList, false);
            };
            NormalModeFactory.prototype.switchStatement = function (switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken) {
                return new TypeScript.SwitchStatementSyntax(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken, false);
            };
            NormalModeFactory.prototype.caseSwitchClause = function (caseKeyword, expression, colonToken, statements) {
                return new TypeScript.CaseSwitchClauseSyntax(caseKeyword, expression, colonToken, statements, false);
            };
            NormalModeFactory.prototype.defaultSwitchClause = function (defaultKeyword, colonToken, statements) {
                return new TypeScript.DefaultSwitchClauseSyntax(defaultKeyword, colonToken, statements, false);
            };
            NormalModeFactory.prototype.breakStatement = function (breakKeyword, identifier, semicolonToken) {
                return new TypeScript.BreakStatementSyntax(breakKeyword, identifier, semicolonToken, false);
            };
            NormalModeFactory.prototype.continueStatement = function (continueKeyword, identifier, semicolonToken) {
                return new TypeScript.ContinueStatementSyntax(continueKeyword, identifier, semicolonToken, false);
            };
            NormalModeFactory.prototype.forStatement = function (forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement) {
                return new TypeScript.ForStatementSyntax(forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement, false);
            };
            NormalModeFactory.prototype.forInStatement = function (forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement) {
                return new TypeScript.ForInStatementSyntax(forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement, false);
            };
            NormalModeFactory.prototype.whileStatement = function (whileKeyword, openParenToken, condition, closeParenToken, statement) {
                return new TypeScript.WhileStatementSyntax(whileKeyword, openParenToken, condition, closeParenToken, statement, false);
            };
            NormalModeFactory.prototype.withStatement = function (withKeyword, openParenToken, condition, closeParenToken, statement) {
                return new TypeScript.WithStatementSyntax(withKeyword, openParenToken, condition, closeParenToken, statement, false);
            };
            NormalModeFactory.prototype.enumDeclaration = function (modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken) {
                return new TypeScript.EnumDeclarationSyntax(modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken, false);
            };
            NormalModeFactory.prototype.enumElement = function (propertyName, equalsValueClause) {
                return new TypeScript.EnumElementSyntax(propertyName, equalsValueClause, false);
            };
            NormalModeFactory.prototype.castExpression = function (lessThanToken, type, greaterThanToken, expression) {
                return new TypeScript.CastExpressionSyntax(lessThanToken, type, greaterThanToken, expression, false);
            };
            NormalModeFactory.prototype.objectLiteralExpression = function (openBraceToken, propertyAssignments, closeBraceToken) {
                return new TypeScript.ObjectLiteralExpressionSyntax(openBraceToken, propertyAssignments, closeBraceToken, false);
            };
            NormalModeFactory.prototype.simplePropertyAssignment = function (propertyName, colonToken, expression) {
                return new TypeScript.SimplePropertyAssignmentSyntax(propertyName, colonToken, expression, false);
            };
            NormalModeFactory.prototype.functionPropertyAssignment = function (propertyName, callSignature, block) {
                return new TypeScript.FunctionPropertyAssignmentSyntax(propertyName, callSignature, block, false);
            };
            NormalModeFactory.prototype.getAccessorPropertyAssignment = function (getKeyword, propertyName, openParenToken, closeParenToken, typeAnnotation, block) {
                return new TypeScript.GetAccessorPropertyAssignmentSyntax(getKeyword, propertyName, openParenToken, closeParenToken, typeAnnotation, block, false);
            };
            NormalModeFactory.prototype.setAccessorPropertyAssignment = function (setKeyword, propertyName, openParenToken, parameter, closeParenToken, block) {
                return new TypeScript.SetAccessorPropertyAssignmentSyntax(setKeyword, propertyName, openParenToken, parameter, closeParenToken, block, false);
            };
            NormalModeFactory.prototype.functionExpression = function (functionKeyword, identifier, callSignature, block) {
                return new TypeScript.FunctionExpressionSyntax(functionKeyword, identifier, callSignature, block, false);
            };
            NormalModeFactory.prototype.emptyStatement = function (semicolonToken) {
                return new TypeScript.EmptyStatementSyntax(semicolonToken, false);
            };
            NormalModeFactory.prototype.tryStatement = function (tryKeyword, block, catchClause, finallyClause) {
                return new TypeScript.TryStatementSyntax(tryKeyword, block, catchClause, finallyClause, false);
            };
            NormalModeFactory.prototype.catchClause = function (catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block) {
                return new TypeScript.CatchClauseSyntax(catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block, false);
            };
            NormalModeFactory.prototype.finallyClause = function (finallyKeyword, block) {
                return new TypeScript.FinallyClauseSyntax(finallyKeyword, block, false);
            };
            NormalModeFactory.prototype.labeledStatement = function (identifier, colonToken, statement) {
                return new TypeScript.LabeledStatementSyntax(identifier, colonToken, statement, false);
            };
            NormalModeFactory.prototype.doStatement = function (doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken) {
                return new TypeScript.DoStatementSyntax(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken, false);
            };
            NormalModeFactory.prototype.typeOfExpression = function (typeOfKeyword, expression) {
                return new TypeScript.TypeOfExpressionSyntax(typeOfKeyword, expression, false);
            };
            NormalModeFactory.prototype.deleteExpression = function (deleteKeyword, expression) {
                return new TypeScript.DeleteExpressionSyntax(deleteKeyword, expression, false);
            };
            NormalModeFactory.prototype.voidExpression = function (voidKeyword, expression) {
                return new TypeScript.VoidExpressionSyntax(voidKeyword, expression, false);
            };
            NormalModeFactory.prototype.debuggerStatement = function (debuggerKeyword, semicolonToken) {
                return new TypeScript.DebuggerStatementSyntax(debuggerKeyword, semicolonToken, false);
            };
            return NormalModeFactory;
        })();
        Syntax.NormalModeFactory = NormalModeFactory;

        var StrictModeFactory = (function () {
            function StrictModeFactory() {
            }
            StrictModeFactory.prototype.sourceUnit = function (moduleElements, endOfFileToken) {
                return new TypeScript.SourceUnitSyntax(moduleElements, endOfFileToken, true);
            };
            StrictModeFactory.prototype.externalModuleReference = function (moduleOrRequireKeyword, openParenToken, stringLiteral, closeParenToken) {
                return new TypeScript.ExternalModuleReferenceSyntax(moduleOrRequireKeyword, openParenToken, stringLiteral, closeParenToken, true);
            };
            StrictModeFactory.prototype.moduleNameModuleReference = function (moduleName) {
                return new TypeScript.ModuleNameModuleReferenceSyntax(moduleName, true);
            };
            StrictModeFactory.prototype.importDeclaration = function (importKeyword, identifier, equalsToken, moduleReference, semicolonToken) {
                return new TypeScript.ImportDeclarationSyntax(importKeyword, identifier, equalsToken, moduleReference, semicolonToken, true);
            };
            StrictModeFactory.prototype.exportAssignment = function (exportKeyword, equalsToken, identifier, semicolonToken) {
                return new TypeScript.ExportAssignmentSyntax(exportKeyword, equalsToken, identifier, semicolonToken, true);
            };
            StrictModeFactory.prototype.classDeclaration = function (modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken) {
                return new TypeScript.ClassDeclarationSyntax(modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken, true);
            };
            StrictModeFactory.prototype.interfaceDeclaration = function (modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, body) {
                return new TypeScript.InterfaceDeclarationSyntax(modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, body, true);
            };
            StrictModeFactory.prototype.heritageClause = function (extendsOrImplementsKeyword, typeNames) {
                return new TypeScript.HeritageClauseSyntax(extendsOrImplementsKeyword, typeNames, true);
            };
            StrictModeFactory.prototype.moduleDeclaration = function (modifiers, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken) {
                return new TypeScript.ModuleDeclarationSyntax(modifiers, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken, true);
            };
            StrictModeFactory.prototype.functionDeclaration = function (modifiers, functionKeyword, identifier, callSignature, block, semicolonToken) {
                return new TypeScript.FunctionDeclarationSyntax(modifiers, functionKeyword, identifier, callSignature, block, semicolonToken, true);
            };
            StrictModeFactory.prototype.variableStatement = function (modifiers, variableDeclaration, semicolonToken) {
                return new TypeScript.VariableStatementSyntax(modifiers, variableDeclaration, semicolonToken, true);
            };
            StrictModeFactory.prototype.variableDeclaration = function (varKeyword, variableDeclarators) {
                return new TypeScript.VariableDeclarationSyntax(varKeyword, variableDeclarators, true);
            };
            StrictModeFactory.prototype.variableDeclarator = function (identifier, typeAnnotation, equalsValueClause) {
                return new TypeScript.VariableDeclaratorSyntax(identifier, typeAnnotation, equalsValueClause, true);
            };
            StrictModeFactory.prototype.equalsValueClause = function (equalsToken, value) {
                return new TypeScript.EqualsValueClauseSyntax(equalsToken, value, true);
            };
            StrictModeFactory.prototype.prefixUnaryExpression = function (kind, operatorToken, operand) {
                return new TypeScript.PrefixUnaryExpressionSyntax(kind, operatorToken, operand, true);
            };
            StrictModeFactory.prototype.arrayLiteralExpression = function (openBracketToken, expressions, closeBracketToken) {
                return new TypeScript.ArrayLiteralExpressionSyntax(openBracketToken, expressions, closeBracketToken, true);
            };
            StrictModeFactory.prototype.omittedExpression = function () {
                return new TypeScript.OmittedExpressionSyntax(true);
            };
            StrictModeFactory.prototype.parenthesizedExpression = function (openParenToken, expression, closeParenToken) {
                return new TypeScript.ParenthesizedExpressionSyntax(openParenToken, expression, closeParenToken, true);
            };
            StrictModeFactory.prototype.simpleArrowFunctionExpression = function (identifier, equalsGreaterThanToken, body) {
                return new TypeScript.SimpleArrowFunctionExpressionSyntax(identifier, equalsGreaterThanToken, body, true);
            };
            StrictModeFactory.prototype.parenthesizedArrowFunctionExpression = function (callSignature, equalsGreaterThanToken, body) {
                return new TypeScript.ParenthesizedArrowFunctionExpressionSyntax(callSignature, equalsGreaterThanToken, body, true);
            };
            StrictModeFactory.prototype.qualifiedName = function (left, dotToken, right) {
                return new TypeScript.QualifiedNameSyntax(left, dotToken, right, true);
            };
            StrictModeFactory.prototype.typeArgumentList = function (lessThanToken, typeArguments, greaterThanToken) {
                return new TypeScript.TypeArgumentListSyntax(lessThanToken, typeArguments, greaterThanToken, true);
            };
            StrictModeFactory.prototype.constructorType = function (newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type) {
                return new TypeScript.ConstructorTypeSyntax(newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type, true);
            };
            StrictModeFactory.prototype.functionType = function (typeParameterList, parameterList, equalsGreaterThanToken, type) {
                return new TypeScript.FunctionTypeSyntax(typeParameterList, parameterList, equalsGreaterThanToken, type, true);
            };
            StrictModeFactory.prototype.objectType = function (openBraceToken, typeMembers, closeBraceToken) {
                return new TypeScript.ObjectTypeSyntax(openBraceToken, typeMembers, closeBraceToken, true);
            };
            StrictModeFactory.prototype.arrayType = function (type, openBracketToken, closeBracketToken) {
                return new TypeScript.ArrayTypeSyntax(type, openBracketToken, closeBracketToken, true);
            };
            StrictModeFactory.prototype.genericType = function (name, typeArgumentList) {
                return new TypeScript.GenericTypeSyntax(name, typeArgumentList, true);
            };
            StrictModeFactory.prototype.typeAnnotation = function (colonToken, type) {
                return new TypeScript.TypeAnnotationSyntax(colonToken, type, true);
            };
            StrictModeFactory.prototype.block = function (openBraceToken, statements, closeBraceToken) {
                return new TypeScript.BlockSyntax(openBraceToken, statements, closeBraceToken, true);
            };
            StrictModeFactory.prototype.parameter = function (dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause) {
                return new TypeScript.ParameterSyntax(dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause, true);
            };
            StrictModeFactory.prototype.memberAccessExpression = function (expression, dotToken, name) {
                return new TypeScript.MemberAccessExpressionSyntax(expression, dotToken, name, true);
            };
            StrictModeFactory.prototype.postfixUnaryExpression = function (kind, operand, operatorToken) {
                return new TypeScript.PostfixUnaryExpressionSyntax(kind, operand, operatorToken, true);
            };
            StrictModeFactory.prototype.elementAccessExpression = function (expression, openBracketToken, argumentExpression, closeBracketToken) {
                return new TypeScript.ElementAccessExpressionSyntax(expression, openBracketToken, argumentExpression, closeBracketToken, true);
            };
            StrictModeFactory.prototype.invocationExpression = function (expression, argumentList) {
                return new TypeScript.InvocationExpressionSyntax(expression, argumentList, true);
            };
            StrictModeFactory.prototype.argumentList = function (typeArgumentList, openParenToken, _arguments, closeParenToken) {
                return new TypeScript.ArgumentListSyntax(typeArgumentList, openParenToken, _arguments, closeParenToken, true);
            };
            StrictModeFactory.prototype.binaryExpression = function (kind, left, operatorToken, right) {
                return new TypeScript.BinaryExpressionSyntax(kind, left, operatorToken, right, true);
            };
            StrictModeFactory.prototype.conditionalExpression = function (condition, questionToken, whenTrue, colonToken, whenFalse) {
                return new TypeScript.ConditionalExpressionSyntax(condition, questionToken, whenTrue, colonToken, whenFalse, true);
            };
            StrictModeFactory.prototype.constructSignature = function (newKeyword, callSignature) {
                return new TypeScript.ConstructSignatureSyntax(newKeyword, callSignature, true);
            };
            StrictModeFactory.prototype.methodSignature = function (propertyName, questionToken, callSignature) {
                return new TypeScript.MethodSignatureSyntax(propertyName, questionToken, callSignature, true);
            };
            StrictModeFactory.prototype.indexSignature = function (openBracketToken, parameter, closeBracketToken, typeAnnotation) {
                return new TypeScript.IndexSignatureSyntax(openBracketToken, parameter, closeBracketToken, typeAnnotation, true);
            };
            StrictModeFactory.prototype.propertySignature = function (propertyName, questionToken, typeAnnotation) {
                return new TypeScript.PropertySignatureSyntax(propertyName, questionToken, typeAnnotation, true);
            };
            StrictModeFactory.prototype.callSignature = function (typeParameterList, parameterList, typeAnnotation) {
                return new TypeScript.CallSignatureSyntax(typeParameterList, parameterList, typeAnnotation, true);
            };
            StrictModeFactory.prototype.parameterList = function (openParenToken, parameters, closeParenToken) {
                return new TypeScript.ParameterListSyntax(openParenToken, parameters, closeParenToken, true);
            };
            StrictModeFactory.prototype.typeParameterList = function (lessThanToken, typeParameters, greaterThanToken) {
                return new TypeScript.TypeParameterListSyntax(lessThanToken, typeParameters, greaterThanToken, true);
            };
            StrictModeFactory.prototype.typeParameter = function (identifier, constraint) {
                return new TypeScript.TypeParameterSyntax(identifier, constraint, true);
            };
            StrictModeFactory.prototype.constraint = function (extendsKeyword, type) {
                return new TypeScript.ConstraintSyntax(extendsKeyword, type, true);
            };
            StrictModeFactory.prototype.elseClause = function (elseKeyword, statement) {
                return new TypeScript.ElseClauseSyntax(elseKeyword, statement, true);
            };
            StrictModeFactory.prototype.ifStatement = function (ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause) {
                return new TypeScript.IfStatementSyntax(ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause, true);
            };
            StrictModeFactory.prototype.expressionStatement = function (expression, semicolonToken) {
                return new TypeScript.ExpressionStatementSyntax(expression, semicolonToken, true);
            };
            StrictModeFactory.prototype.constructorDeclaration = function (constructorKeyword, parameterList, block, semicolonToken) {
                return new TypeScript.ConstructorDeclarationSyntax(constructorKeyword, parameterList, block, semicolonToken, true);
            };
            StrictModeFactory.prototype.memberFunctionDeclaration = function (modifiers, propertyName, callSignature, block, semicolonToken) {
                return new TypeScript.MemberFunctionDeclarationSyntax(modifiers, propertyName, callSignature, block, semicolonToken, true);
            };
            StrictModeFactory.prototype.getMemberAccessorDeclaration = function (modifiers, getKeyword, propertyName, parameterList, typeAnnotation, block) {
                return new TypeScript.GetMemberAccessorDeclarationSyntax(modifiers, getKeyword, propertyName, parameterList, typeAnnotation, block, true);
            };
            StrictModeFactory.prototype.setMemberAccessorDeclaration = function (modifiers, setKeyword, propertyName, parameterList, block) {
                return new TypeScript.SetMemberAccessorDeclarationSyntax(modifiers, setKeyword, propertyName, parameterList, block, true);
            };
            StrictModeFactory.prototype.memberVariableDeclaration = function (modifiers, variableDeclarator, semicolonToken) {
                return new TypeScript.MemberVariableDeclarationSyntax(modifiers, variableDeclarator, semicolonToken, true);
            };
            StrictModeFactory.prototype.throwStatement = function (throwKeyword, expression, semicolonToken) {
                return new TypeScript.ThrowStatementSyntax(throwKeyword, expression, semicolonToken, true);
            };
            StrictModeFactory.prototype.returnStatement = function (returnKeyword, expression, semicolonToken) {
                return new TypeScript.ReturnStatementSyntax(returnKeyword, expression, semicolonToken, true);
            };
            StrictModeFactory.prototype.objectCreationExpression = function (newKeyword, expression, argumentList) {
                return new TypeScript.ObjectCreationExpressionSyntax(newKeyword, expression, argumentList, true);
            };
            StrictModeFactory.prototype.switchStatement = function (switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken) {
                return new TypeScript.SwitchStatementSyntax(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken, true);
            };
            StrictModeFactory.prototype.caseSwitchClause = function (caseKeyword, expression, colonToken, statements) {
                return new TypeScript.CaseSwitchClauseSyntax(caseKeyword, expression, colonToken, statements, true);
            };
            StrictModeFactory.prototype.defaultSwitchClause = function (defaultKeyword, colonToken, statements) {
                return new TypeScript.DefaultSwitchClauseSyntax(defaultKeyword, colonToken, statements, true);
            };
            StrictModeFactory.prototype.breakStatement = function (breakKeyword, identifier, semicolonToken) {
                return new TypeScript.BreakStatementSyntax(breakKeyword, identifier, semicolonToken, true);
            };
            StrictModeFactory.prototype.continueStatement = function (continueKeyword, identifier, semicolonToken) {
                return new TypeScript.ContinueStatementSyntax(continueKeyword, identifier, semicolonToken, true);
            };
            StrictModeFactory.prototype.forStatement = function (forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement) {
                return new TypeScript.ForStatementSyntax(forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement, true);
            };
            StrictModeFactory.prototype.forInStatement = function (forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement) {
                return new TypeScript.ForInStatementSyntax(forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement, true);
            };
            StrictModeFactory.prototype.whileStatement = function (whileKeyword, openParenToken, condition, closeParenToken, statement) {
                return new TypeScript.WhileStatementSyntax(whileKeyword, openParenToken, condition, closeParenToken, statement, true);
            };
            StrictModeFactory.prototype.withStatement = function (withKeyword, openParenToken, condition, closeParenToken, statement) {
                return new TypeScript.WithStatementSyntax(withKeyword, openParenToken, condition, closeParenToken, statement, true);
            };
            StrictModeFactory.prototype.enumDeclaration = function (modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken) {
                return new TypeScript.EnumDeclarationSyntax(modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken, true);
            };
            StrictModeFactory.prototype.enumElement = function (propertyName, equalsValueClause) {
                return new TypeScript.EnumElementSyntax(propertyName, equalsValueClause, true);
            };
            StrictModeFactory.prototype.castExpression = function (lessThanToken, type, greaterThanToken, expression) {
                return new TypeScript.CastExpressionSyntax(lessThanToken, type, greaterThanToken, expression, true);
            };
            StrictModeFactory.prototype.objectLiteralExpression = function (openBraceToken, propertyAssignments, closeBraceToken) {
                return new TypeScript.ObjectLiteralExpressionSyntax(openBraceToken, propertyAssignments, closeBraceToken, true);
            };
            StrictModeFactory.prototype.simplePropertyAssignment = function (propertyName, colonToken, expression) {
                return new TypeScript.SimplePropertyAssignmentSyntax(propertyName, colonToken, expression, true);
            };
            StrictModeFactory.prototype.functionPropertyAssignment = function (propertyName, callSignature, block) {
                return new TypeScript.FunctionPropertyAssignmentSyntax(propertyName, callSignature, block, true);
            };
            StrictModeFactory.prototype.getAccessorPropertyAssignment = function (getKeyword, propertyName, openParenToken, closeParenToken, typeAnnotation, block) {
                return new TypeScript.GetAccessorPropertyAssignmentSyntax(getKeyword, propertyName, openParenToken, closeParenToken, typeAnnotation, block, true);
            };
            StrictModeFactory.prototype.setAccessorPropertyAssignment = function (setKeyword, propertyName, openParenToken, parameter, closeParenToken, block) {
                return new TypeScript.SetAccessorPropertyAssignmentSyntax(setKeyword, propertyName, openParenToken, parameter, closeParenToken, block, true);
            };
            StrictModeFactory.prototype.functionExpression = function (functionKeyword, identifier, callSignature, block) {
                return new TypeScript.FunctionExpressionSyntax(functionKeyword, identifier, callSignature, block, true);
            };
            StrictModeFactory.prototype.emptyStatement = function (semicolonToken) {
                return new TypeScript.EmptyStatementSyntax(semicolonToken, true);
            };
            StrictModeFactory.prototype.tryStatement = function (tryKeyword, block, catchClause, finallyClause) {
                return new TypeScript.TryStatementSyntax(tryKeyword, block, catchClause, finallyClause, true);
            };
            StrictModeFactory.prototype.catchClause = function (catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block) {
                return new TypeScript.CatchClauseSyntax(catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block, true);
            };
            StrictModeFactory.prototype.finallyClause = function (finallyKeyword, block) {
                return new TypeScript.FinallyClauseSyntax(finallyKeyword, block, true);
            };
            StrictModeFactory.prototype.labeledStatement = function (identifier, colonToken, statement) {
                return new TypeScript.LabeledStatementSyntax(identifier, colonToken, statement, true);
            };
            StrictModeFactory.prototype.doStatement = function (doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken) {
                return new TypeScript.DoStatementSyntax(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken, true);
            };
            StrictModeFactory.prototype.typeOfExpression = function (typeOfKeyword, expression) {
                return new TypeScript.TypeOfExpressionSyntax(typeOfKeyword, expression, true);
            };
            StrictModeFactory.prototype.deleteExpression = function (deleteKeyword, expression) {
                return new TypeScript.DeleteExpressionSyntax(deleteKeyword, expression, true);
            };
            StrictModeFactory.prototype.voidExpression = function (voidKeyword, expression) {
                return new TypeScript.VoidExpressionSyntax(voidKeyword, expression, true);
            };
            StrictModeFactory.prototype.debuggerStatement = function (debuggerKeyword, semicolonToken) {
                return new TypeScript.DebuggerStatementSyntax(debuggerKeyword, semicolonToken, true);
            };
            return StrictModeFactory;
        })();
        Syntax.StrictModeFactory = StrictModeFactory;

        Syntax.normalModeFactory = new NormalModeFactory();
        Syntax.strictModeFactory = new StrictModeFactory();
    })(TypeScript.Syntax || (TypeScript.Syntax = {}));
    var Syntax = TypeScript.Syntax;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (SyntaxKind) {
        SyntaxKind[SyntaxKind["None"] = 0] = "None";
        SyntaxKind[SyntaxKind["List"] = 1] = "List";
        SyntaxKind[SyntaxKind["SeparatedList"] = 2] = "SeparatedList";
        SyntaxKind[SyntaxKind["TriviaList"] = 3] = "TriviaList";

        SyntaxKind[SyntaxKind["WhitespaceTrivia"] = 4] = "WhitespaceTrivia";
        SyntaxKind[SyntaxKind["NewLineTrivia"] = 5] = "NewLineTrivia";
        SyntaxKind[SyntaxKind["MultiLineCommentTrivia"] = 6] = "MultiLineCommentTrivia";
        SyntaxKind[SyntaxKind["SingleLineCommentTrivia"] = 7] = "SingleLineCommentTrivia";
        SyntaxKind[SyntaxKind["SkippedTokenTrivia"] = 8] = "SkippedTokenTrivia";

        SyntaxKind[SyntaxKind["ErrorToken"] = 9] = "ErrorToken";
        SyntaxKind[SyntaxKind["EndOfFileToken"] = 10] = "EndOfFileToken";

        SyntaxKind[SyntaxKind["IdentifierName"] = 11] = "IdentifierName";

        SyntaxKind[SyntaxKind["RegularExpressionLiteral"] = 12] = "RegularExpressionLiteral";
        SyntaxKind[SyntaxKind["NumericLiteral"] = 13] = "NumericLiteral";
        SyntaxKind[SyntaxKind["StringLiteral"] = 14] = "StringLiteral";

        SyntaxKind[SyntaxKind["BreakKeyword"] = 15] = "BreakKeyword";
        SyntaxKind[SyntaxKind["CaseKeyword"] = 16] = "CaseKeyword";
        SyntaxKind[SyntaxKind["CatchKeyword"] = 17] = "CatchKeyword";
        SyntaxKind[SyntaxKind["ContinueKeyword"] = 18] = "ContinueKeyword";
        SyntaxKind[SyntaxKind["DebuggerKeyword"] = 19] = "DebuggerKeyword";
        SyntaxKind[SyntaxKind["DefaultKeyword"] = 20] = "DefaultKeyword";
        SyntaxKind[SyntaxKind["DeleteKeyword"] = 21] = "DeleteKeyword";
        SyntaxKind[SyntaxKind["DoKeyword"] = 22] = "DoKeyword";
        SyntaxKind[SyntaxKind["ElseKeyword"] = 23] = "ElseKeyword";
        SyntaxKind[SyntaxKind["FalseKeyword"] = 24] = "FalseKeyword";
        SyntaxKind[SyntaxKind["FinallyKeyword"] = 25] = "FinallyKeyword";
        SyntaxKind[SyntaxKind["ForKeyword"] = 26] = "ForKeyword";
        SyntaxKind[SyntaxKind["FunctionKeyword"] = 27] = "FunctionKeyword";
        SyntaxKind[SyntaxKind["IfKeyword"] = 28] = "IfKeyword";
        SyntaxKind[SyntaxKind["InKeyword"] = 29] = "InKeyword";
        SyntaxKind[SyntaxKind["InstanceOfKeyword"] = 30] = "InstanceOfKeyword";
        SyntaxKind[SyntaxKind["NewKeyword"] = 31] = "NewKeyword";
        SyntaxKind[SyntaxKind["NullKeyword"] = 32] = "NullKeyword";
        SyntaxKind[SyntaxKind["ReturnKeyword"] = 33] = "ReturnKeyword";
        SyntaxKind[SyntaxKind["SwitchKeyword"] = 34] = "SwitchKeyword";
        SyntaxKind[SyntaxKind["ThisKeyword"] = 35] = "ThisKeyword";
        SyntaxKind[SyntaxKind["ThrowKeyword"] = 36] = "ThrowKeyword";
        SyntaxKind[SyntaxKind["TrueKeyword"] = 37] = "TrueKeyword";
        SyntaxKind[SyntaxKind["TryKeyword"] = 38] = "TryKeyword";
        SyntaxKind[SyntaxKind["TypeOfKeyword"] = 39] = "TypeOfKeyword";
        SyntaxKind[SyntaxKind["VarKeyword"] = 40] = "VarKeyword";
        SyntaxKind[SyntaxKind["VoidKeyword"] = 41] = "VoidKeyword";
        SyntaxKind[SyntaxKind["WhileKeyword"] = 42] = "WhileKeyword";
        SyntaxKind[SyntaxKind["WithKeyword"] = 43] = "WithKeyword";

        SyntaxKind[SyntaxKind["ClassKeyword"] = 44] = "ClassKeyword";
        SyntaxKind[SyntaxKind["ConstKeyword"] = 45] = "ConstKeyword";
        SyntaxKind[SyntaxKind["EnumKeyword"] = 46] = "EnumKeyword";
        SyntaxKind[SyntaxKind["ExportKeyword"] = 47] = "ExportKeyword";
        SyntaxKind[SyntaxKind["ExtendsKeyword"] = 48] = "ExtendsKeyword";
        SyntaxKind[SyntaxKind["ImportKeyword"] = 49] = "ImportKeyword";
        SyntaxKind[SyntaxKind["SuperKeyword"] = 50] = "SuperKeyword";

        SyntaxKind[SyntaxKind["ImplementsKeyword"] = 51] = "ImplementsKeyword";
        SyntaxKind[SyntaxKind["InterfaceKeyword"] = 52] = "InterfaceKeyword";
        SyntaxKind[SyntaxKind["LetKeyword"] = 53] = "LetKeyword";
        SyntaxKind[SyntaxKind["PackageKeyword"] = 54] = "PackageKeyword";
        SyntaxKind[SyntaxKind["PrivateKeyword"] = 55] = "PrivateKeyword";
        SyntaxKind[SyntaxKind["ProtectedKeyword"] = 56] = "ProtectedKeyword";
        SyntaxKind[SyntaxKind["PublicKeyword"] = 57] = "PublicKeyword";
        SyntaxKind[SyntaxKind["StaticKeyword"] = 58] = "StaticKeyword";
        SyntaxKind[SyntaxKind["YieldKeyword"] = 59] = "YieldKeyword";

        SyntaxKind[SyntaxKind["AnyKeyword"] = 60] = "AnyKeyword";
        SyntaxKind[SyntaxKind["BooleanKeyword"] = 61] = "BooleanKeyword";
        SyntaxKind[SyntaxKind["BoolKeyword"] = 62] = "BoolKeyword";
        SyntaxKind[SyntaxKind["ConstructorKeyword"] = 63] = "ConstructorKeyword";
        SyntaxKind[SyntaxKind["DeclareKeyword"] = 64] = "DeclareKeyword";
        SyntaxKind[SyntaxKind["GetKeyword"] = 65] = "GetKeyword";
        SyntaxKind[SyntaxKind["ModuleKeyword"] = 66] = "ModuleKeyword";
        SyntaxKind[SyntaxKind["RequireKeyword"] = 67] = "RequireKeyword";
        SyntaxKind[SyntaxKind["NumberKeyword"] = 68] = "NumberKeyword";
        SyntaxKind[SyntaxKind["SetKeyword"] = 69] = "SetKeyword";
        SyntaxKind[SyntaxKind["StringKeyword"] = 70] = "StringKeyword";

        SyntaxKind[SyntaxKind["OpenBraceToken"] = 71] = "OpenBraceToken";
        SyntaxKind[SyntaxKind["CloseBraceToken"] = 72] = "CloseBraceToken";
        SyntaxKind[SyntaxKind["OpenParenToken"] = 73] = "OpenParenToken";
        SyntaxKind[SyntaxKind["CloseParenToken"] = 74] = "CloseParenToken";
        SyntaxKind[SyntaxKind["OpenBracketToken"] = 75] = "OpenBracketToken";
        SyntaxKind[SyntaxKind["CloseBracketToken"] = 76] = "CloseBracketToken";
        SyntaxKind[SyntaxKind["DotToken"] = 77] = "DotToken";
        SyntaxKind[SyntaxKind["DotDotDotToken"] = 78] = "DotDotDotToken";
        SyntaxKind[SyntaxKind["SemicolonToken"] = 79] = "SemicolonToken";
        SyntaxKind[SyntaxKind["CommaToken"] = 80] = "CommaToken";
        SyntaxKind[SyntaxKind["LessThanToken"] = 81] = "LessThanToken";
        SyntaxKind[SyntaxKind["GreaterThanToken"] = 82] = "GreaterThanToken";
        SyntaxKind[SyntaxKind["LessThanEqualsToken"] = 83] = "LessThanEqualsToken";
        SyntaxKind[SyntaxKind["GreaterThanEqualsToken"] = 84] = "GreaterThanEqualsToken";
        SyntaxKind[SyntaxKind["EqualsEqualsToken"] = 85] = "EqualsEqualsToken";
        SyntaxKind[SyntaxKind["EqualsGreaterThanToken"] = 86] = "EqualsGreaterThanToken";
        SyntaxKind[SyntaxKind["ExclamationEqualsToken"] = 87] = "ExclamationEqualsToken";
        SyntaxKind[SyntaxKind["EqualsEqualsEqualsToken"] = 88] = "EqualsEqualsEqualsToken";
        SyntaxKind[SyntaxKind["ExclamationEqualsEqualsToken"] = 89] = "ExclamationEqualsEqualsToken";
        SyntaxKind[SyntaxKind["PlusToken"] = 90] = "PlusToken";
        SyntaxKind[SyntaxKind["MinusToken"] = 91] = "MinusToken";
        SyntaxKind[SyntaxKind["AsteriskToken"] = 92] = "AsteriskToken";
        SyntaxKind[SyntaxKind["PercentToken"] = 93] = "PercentToken";
        SyntaxKind[SyntaxKind["PlusPlusToken"] = 94] = "PlusPlusToken";
        SyntaxKind[SyntaxKind["MinusMinusToken"] = 95] = "MinusMinusToken";
        SyntaxKind[SyntaxKind["LessThanLessThanToken"] = 96] = "LessThanLessThanToken";
        SyntaxKind[SyntaxKind["GreaterThanGreaterThanToken"] = 97] = "GreaterThanGreaterThanToken";
        SyntaxKind[SyntaxKind["GreaterThanGreaterThanGreaterThanToken"] = 98] = "GreaterThanGreaterThanGreaterThanToken";
        SyntaxKind[SyntaxKind["AmpersandToken"] = 99] = "AmpersandToken";
        SyntaxKind[SyntaxKind["BarToken"] = 100] = "BarToken";
        SyntaxKind[SyntaxKind["CaretToken"] = 101] = "CaretToken";
        SyntaxKind[SyntaxKind["ExclamationToken"] = 102] = "ExclamationToken";
        SyntaxKind[SyntaxKind["TildeToken"] = 103] = "TildeToken";
        SyntaxKind[SyntaxKind["AmpersandAmpersandToken"] = 104] = "AmpersandAmpersandToken";
        SyntaxKind[SyntaxKind["BarBarToken"] = 105] = "BarBarToken";
        SyntaxKind[SyntaxKind["QuestionToken"] = 106] = "QuestionToken";
        SyntaxKind[SyntaxKind["ColonToken"] = 107] = "ColonToken";
        SyntaxKind[SyntaxKind["EqualsToken"] = 108] = "EqualsToken";
        SyntaxKind[SyntaxKind["PlusEqualsToken"] = 109] = "PlusEqualsToken";
        SyntaxKind[SyntaxKind["MinusEqualsToken"] = 110] = "MinusEqualsToken";
        SyntaxKind[SyntaxKind["AsteriskEqualsToken"] = 111] = "AsteriskEqualsToken";
        SyntaxKind[SyntaxKind["PercentEqualsToken"] = 112] = "PercentEqualsToken";
        SyntaxKind[SyntaxKind["LessThanLessThanEqualsToken"] = 113] = "LessThanLessThanEqualsToken";
        SyntaxKind[SyntaxKind["GreaterThanGreaterThanEqualsToken"] = 114] = "GreaterThanGreaterThanEqualsToken";
        SyntaxKind[SyntaxKind["GreaterThanGreaterThanGreaterThanEqualsToken"] = 115] = "GreaterThanGreaterThanGreaterThanEqualsToken";
        SyntaxKind[SyntaxKind["AmpersandEqualsToken"] = 116] = "AmpersandEqualsToken";
        SyntaxKind[SyntaxKind["BarEqualsToken"] = 117] = "BarEqualsToken";
        SyntaxKind[SyntaxKind["CaretEqualsToken"] = 118] = "CaretEqualsToken";
        SyntaxKind[SyntaxKind["SlashToken"] = 119] = "SlashToken";
        SyntaxKind[SyntaxKind["SlashEqualsToken"] = 120] = "SlashEqualsToken";

        SyntaxKind[SyntaxKind["SourceUnit"] = 121] = "SourceUnit";

        SyntaxKind[SyntaxKind["QualifiedName"] = 122] = "QualifiedName";

        SyntaxKind[SyntaxKind["ObjectType"] = 123] = "ObjectType";
        SyntaxKind[SyntaxKind["FunctionType"] = 124] = "FunctionType";
        SyntaxKind[SyntaxKind["ArrayType"] = 125] = "ArrayType";
        SyntaxKind[SyntaxKind["ConstructorType"] = 126] = "ConstructorType";
        SyntaxKind[SyntaxKind["GenericType"] = 127] = "GenericType";

        SyntaxKind[SyntaxKind["InterfaceDeclaration"] = 128] = "InterfaceDeclaration";
        SyntaxKind[SyntaxKind["FunctionDeclaration"] = 129] = "FunctionDeclaration";
        SyntaxKind[SyntaxKind["ModuleDeclaration"] = 130] = "ModuleDeclaration";
        SyntaxKind[SyntaxKind["ClassDeclaration"] = 131] = "ClassDeclaration";
        SyntaxKind[SyntaxKind["EnumDeclaration"] = 132] = "EnumDeclaration";
        SyntaxKind[SyntaxKind["ImportDeclaration"] = 133] = "ImportDeclaration";
        SyntaxKind[SyntaxKind["ExportAssignment"] = 134] = "ExportAssignment";

        SyntaxKind[SyntaxKind["MemberFunctionDeclaration"] = 135] = "MemberFunctionDeclaration";
        SyntaxKind[SyntaxKind["MemberVariableDeclaration"] = 136] = "MemberVariableDeclaration";
        SyntaxKind[SyntaxKind["ConstructorDeclaration"] = 137] = "ConstructorDeclaration";
        SyntaxKind[SyntaxKind["GetMemberAccessorDeclaration"] = 138] = "GetMemberAccessorDeclaration";
        SyntaxKind[SyntaxKind["SetMemberAccessorDeclaration"] = 139] = "SetMemberAccessorDeclaration";

        SyntaxKind[SyntaxKind["PropertySignature"] = 140] = "PropertySignature";
        SyntaxKind[SyntaxKind["CallSignature"] = 141] = "CallSignature";
        SyntaxKind[SyntaxKind["ConstructSignature"] = 142] = "ConstructSignature";
        SyntaxKind[SyntaxKind["IndexSignature"] = 143] = "IndexSignature";
        SyntaxKind[SyntaxKind["MethodSignature"] = 144] = "MethodSignature";

        SyntaxKind[SyntaxKind["Block"] = 145] = "Block";
        SyntaxKind[SyntaxKind["IfStatement"] = 146] = "IfStatement";
        SyntaxKind[SyntaxKind["VariableStatement"] = 147] = "VariableStatement";
        SyntaxKind[SyntaxKind["ExpressionStatement"] = 148] = "ExpressionStatement";
        SyntaxKind[SyntaxKind["ReturnStatement"] = 149] = "ReturnStatement";
        SyntaxKind[SyntaxKind["SwitchStatement"] = 150] = "SwitchStatement";
        SyntaxKind[SyntaxKind["BreakStatement"] = 151] = "BreakStatement";
        SyntaxKind[SyntaxKind["ContinueStatement"] = 152] = "ContinueStatement";
        SyntaxKind[SyntaxKind["ForStatement"] = 153] = "ForStatement";
        SyntaxKind[SyntaxKind["ForInStatement"] = 154] = "ForInStatement";
        SyntaxKind[SyntaxKind["EmptyStatement"] = 155] = "EmptyStatement";
        SyntaxKind[SyntaxKind["ThrowStatement"] = 156] = "ThrowStatement";
        SyntaxKind[SyntaxKind["WhileStatement"] = 157] = "WhileStatement";
        SyntaxKind[SyntaxKind["TryStatement"] = 158] = "TryStatement";
        SyntaxKind[SyntaxKind["LabeledStatement"] = 159] = "LabeledStatement";
        SyntaxKind[SyntaxKind["DoStatement"] = 160] = "DoStatement";
        SyntaxKind[SyntaxKind["DebuggerStatement"] = 161] = "DebuggerStatement";
        SyntaxKind[SyntaxKind["WithStatement"] = 162] = "WithStatement";

        SyntaxKind[SyntaxKind["PlusExpression"] = 163] = "PlusExpression";
        SyntaxKind[SyntaxKind["NegateExpression"] = 164] = "NegateExpression";
        SyntaxKind[SyntaxKind["BitwiseNotExpression"] = 165] = "BitwiseNotExpression";
        SyntaxKind[SyntaxKind["LogicalNotExpression"] = 166] = "LogicalNotExpression";
        SyntaxKind[SyntaxKind["PreIncrementExpression"] = 167] = "PreIncrementExpression";
        SyntaxKind[SyntaxKind["PreDecrementExpression"] = 168] = "PreDecrementExpression";
        SyntaxKind[SyntaxKind["DeleteExpression"] = 169] = "DeleteExpression";
        SyntaxKind[SyntaxKind["TypeOfExpression"] = 170] = "TypeOfExpression";
        SyntaxKind[SyntaxKind["VoidExpression"] = 171] = "VoidExpression";
        SyntaxKind[SyntaxKind["CommaExpression"] = 172] = "CommaExpression";
        SyntaxKind[SyntaxKind["AssignmentExpression"] = 173] = "AssignmentExpression";
        SyntaxKind[SyntaxKind["AddAssignmentExpression"] = 174] = "AddAssignmentExpression";
        SyntaxKind[SyntaxKind["SubtractAssignmentExpression"] = 175] = "SubtractAssignmentExpression";
        SyntaxKind[SyntaxKind["MultiplyAssignmentExpression"] = 176] = "MultiplyAssignmentExpression";
        SyntaxKind[SyntaxKind["DivideAssignmentExpression"] = 177] = "DivideAssignmentExpression";
        SyntaxKind[SyntaxKind["ModuloAssignmentExpression"] = 178] = "ModuloAssignmentExpression";
        SyntaxKind[SyntaxKind["AndAssignmentExpression"] = 179] = "AndAssignmentExpression";
        SyntaxKind[SyntaxKind["ExclusiveOrAssignmentExpression"] = 180] = "ExclusiveOrAssignmentExpression";
        SyntaxKind[SyntaxKind["OrAssignmentExpression"] = 181] = "OrAssignmentExpression";
        SyntaxKind[SyntaxKind["LeftShiftAssignmentExpression"] = 182] = "LeftShiftAssignmentExpression";
        SyntaxKind[SyntaxKind["SignedRightShiftAssignmentExpression"] = 183] = "SignedRightShiftAssignmentExpression";
        SyntaxKind[SyntaxKind["UnsignedRightShiftAssignmentExpression"] = 184] = "UnsignedRightShiftAssignmentExpression";
        SyntaxKind[SyntaxKind["ConditionalExpression"] = 185] = "ConditionalExpression";
        SyntaxKind[SyntaxKind["LogicalOrExpression"] = 186] = "LogicalOrExpression";
        SyntaxKind[SyntaxKind["LogicalAndExpression"] = 187] = "LogicalAndExpression";
        SyntaxKind[SyntaxKind["BitwiseOrExpression"] = 188] = "BitwiseOrExpression";
        SyntaxKind[SyntaxKind["BitwiseExclusiveOrExpression"] = 189] = "BitwiseExclusiveOrExpression";
        SyntaxKind[SyntaxKind["BitwiseAndExpression"] = 190] = "BitwiseAndExpression";
        SyntaxKind[SyntaxKind["EqualsWithTypeConversionExpression"] = 191] = "EqualsWithTypeConversionExpression";
        SyntaxKind[SyntaxKind["NotEqualsWithTypeConversionExpression"] = 192] = "NotEqualsWithTypeConversionExpression";
        SyntaxKind[SyntaxKind["EqualsExpression"] = 193] = "EqualsExpression";
        SyntaxKind[SyntaxKind["NotEqualsExpression"] = 194] = "NotEqualsExpression";
        SyntaxKind[SyntaxKind["LessThanExpression"] = 195] = "LessThanExpression";
        SyntaxKind[SyntaxKind["GreaterThanExpression"] = 196] = "GreaterThanExpression";
        SyntaxKind[SyntaxKind["LessThanOrEqualExpression"] = 197] = "LessThanOrEqualExpression";
        SyntaxKind[SyntaxKind["GreaterThanOrEqualExpression"] = 198] = "GreaterThanOrEqualExpression";
        SyntaxKind[SyntaxKind["InstanceOfExpression"] = 199] = "InstanceOfExpression";
        SyntaxKind[SyntaxKind["InExpression"] = 200] = "InExpression";
        SyntaxKind[SyntaxKind["LeftShiftExpression"] = 201] = "LeftShiftExpression";
        SyntaxKind[SyntaxKind["SignedRightShiftExpression"] = 202] = "SignedRightShiftExpression";
        SyntaxKind[SyntaxKind["UnsignedRightShiftExpression"] = 203] = "UnsignedRightShiftExpression";
        SyntaxKind[SyntaxKind["MultiplyExpression"] = 204] = "MultiplyExpression";
        SyntaxKind[SyntaxKind["DivideExpression"] = 205] = "DivideExpression";
        SyntaxKind[SyntaxKind["ModuloExpression"] = 206] = "ModuloExpression";
        SyntaxKind[SyntaxKind["AddExpression"] = 207] = "AddExpression";
        SyntaxKind[SyntaxKind["SubtractExpression"] = 208] = "SubtractExpression";
        SyntaxKind[SyntaxKind["PostIncrementExpression"] = 209] = "PostIncrementExpression";
        SyntaxKind[SyntaxKind["PostDecrementExpression"] = 210] = "PostDecrementExpression";
        SyntaxKind[SyntaxKind["MemberAccessExpression"] = 211] = "MemberAccessExpression";
        SyntaxKind[SyntaxKind["InvocationExpression"] = 212] = "InvocationExpression";
        SyntaxKind[SyntaxKind["ArrayLiteralExpression"] = 213] = "ArrayLiteralExpression";
        SyntaxKind[SyntaxKind["ObjectLiteralExpression"] = 214] = "ObjectLiteralExpression";
        SyntaxKind[SyntaxKind["ObjectCreationExpression"] = 215] = "ObjectCreationExpression";
        SyntaxKind[SyntaxKind["ParenthesizedExpression"] = 216] = "ParenthesizedExpression";
        SyntaxKind[SyntaxKind["ParenthesizedArrowFunctionExpression"] = 217] = "ParenthesizedArrowFunctionExpression";
        SyntaxKind[SyntaxKind["SimpleArrowFunctionExpression"] = 218] = "SimpleArrowFunctionExpression";
        SyntaxKind[SyntaxKind["CastExpression"] = 219] = "CastExpression";
        SyntaxKind[SyntaxKind["ElementAccessExpression"] = 220] = "ElementAccessExpression";
        SyntaxKind[SyntaxKind["FunctionExpression"] = 221] = "FunctionExpression";
        SyntaxKind[SyntaxKind["OmittedExpression"] = 222] = "OmittedExpression";

        SyntaxKind[SyntaxKind["VariableDeclaration"] = 223] = "VariableDeclaration";
        SyntaxKind[SyntaxKind["VariableDeclarator"] = 224] = "VariableDeclarator";

        SyntaxKind[SyntaxKind["ArgumentList"] = 225] = "ArgumentList";
        SyntaxKind[SyntaxKind["ParameterList"] = 226] = "ParameterList";
        SyntaxKind[SyntaxKind["TypeArgumentList"] = 227] = "TypeArgumentList";
        SyntaxKind[SyntaxKind["TypeParameterList"] = 228] = "TypeParameterList";

        SyntaxKind[SyntaxKind["HeritageClause"] = 229] = "HeritageClause";
        SyntaxKind[SyntaxKind["EqualsValueClause"] = 230] = "EqualsValueClause";
        SyntaxKind[SyntaxKind["CaseSwitchClause"] = 231] = "CaseSwitchClause";
        SyntaxKind[SyntaxKind["DefaultSwitchClause"] = 232] = "DefaultSwitchClause";
        SyntaxKind[SyntaxKind["ElseClause"] = 233] = "ElseClause";
        SyntaxKind[SyntaxKind["CatchClause"] = 234] = "CatchClause";
        SyntaxKind[SyntaxKind["FinallyClause"] = 235] = "FinallyClause";

        SyntaxKind[SyntaxKind["TypeParameter"] = 236] = "TypeParameter";
        SyntaxKind[SyntaxKind["Constraint"] = 237] = "Constraint";

        SyntaxKind[SyntaxKind["SimplePropertyAssignment"] = 238] = "SimplePropertyAssignment";
        SyntaxKind[SyntaxKind["GetAccessorPropertyAssignment"] = 239] = "GetAccessorPropertyAssignment";
        SyntaxKind[SyntaxKind["SetAccessorPropertyAssignment"] = 240] = "SetAccessorPropertyAssignment";
        SyntaxKind[SyntaxKind["FunctionPropertyAssignment"] = 241] = "FunctionPropertyAssignment";

        SyntaxKind[SyntaxKind["Parameter"] = 242] = "Parameter";
        SyntaxKind[SyntaxKind["EnumElement"] = 243] = "EnumElement";
        SyntaxKind[SyntaxKind["TypeAnnotation"] = 244] = "TypeAnnotation";
        SyntaxKind[SyntaxKind["ExternalModuleReference"] = 245] = "ExternalModuleReference";
        SyntaxKind[SyntaxKind["ModuleNameModuleReference"] = 246] = "ModuleNameModuleReference";

        SyntaxKind[SyntaxKind["FirstStandardKeyword"] = SyntaxKind.BreakKeyword] = "FirstStandardKeyword";
        SyntaxKind[SyntaxKind["LastStandardKeyword"] = SyntaxKind.WithKeyword] = "LastStandardKeyword";

        SyntaxKind[SyntaxKind["FirstFutureReservedKeyword"] = SyntaxKind.ClassKeyword] = "FirstFutureReservedKeyword";
        SyntaxKind[SyntaxKind["LastFutureReservedKeyword"] = SyntaxKind.SuperKeyword] = "LastFutureReservedKeyword";

        SyntaxKind[SyntaxKind["FirstFutureReservedStrictKeyword"] = SyntaxKind.ImplementsKeyword] = "FirstFutureReservedStrictKeyword";
        SyntaxKind[SyntaxKind["LastFutureReservedStrictKeyword"] = SyntaxKind.YieldKeyword] = "LastFutureReservedStrictKeyword";

        SyntaxKind[SyntaxKind["FirstTypeScriptKeyword"] = SyntaxKind.AnyKeyword] = "FirstTypeScriptKeyword";
        SyntaxKind[SyntaxKind["LastTypeScriptKeyword"] = SyntaxKind.StringKeyword] = "LastTypeScriptKeyword";

        SyntaxKind[SyntaxKind["FirstKeyword"] = SyntaxKind.FirstStandardKeyword] = "FirstKeyword";
        SyntaxKind[SyntaxKind["LastKeyword"] = SyntaxKind.LastTypeScriptKeyword] = "LastKeyword";

        SyntaxKind[SyntaxKind["FirstToken"] = SyntaxKind.ErrorToken] = "FirstToken";
        SyntaxKind[SyntaxKind["LastToken"] = SyntaxKind.SlashEqualsToken] = "LastToken";

        SyntaxKind[SyntaxKind["FirstPunctuation"] = SyntaxKind.OpenBraceToken] = "FirstPunctuation";
        SyntaxKind[SyntaxKind["LastPunctuation"] = SyntaxKind.SlashEqualsToken] = "LastPunctuation";

        SyntaxKind[SyntaxKind["FirstFixedWidth"] = SyntaxKind.FirstKeyword] = "FirstFixedWidth";
        SyntaxKind[SyntaxKind["LastFixedWidth"] = SyntaxKind.LastPunctuation] = "LastFixedWidth";
    })(TypeScript.SyntaxKind || (TypeScript.SyntaxKind = {}));
    var SyntaxKind = TypeScript.SyntaxKind;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (SyntaxFacts) {
        var textToKeywordKind = {
            "any": 60 /* AnyKeyword */,
            "bool": 62 /* BoolKeyword */,
            "boolean": 61 /* BooleanKeyword */,
            "break": 15 /* BreakKeyword */,
            "case": 16 /* CaseKeyword */,
            "catch": 17 /* CatchKeyword */,
            "class": 44 /* ClassKeyword */,
            "continue": 18 /* ContinueKeyword */,
            "const": 45 /* ConstKeyword */,
            "constructor": 63 /* ConstructorKeyword */,
            "debugger": 19 /* DebuggerKeyword */,
            "declare": 64 /* DeclareKeyword */,
            "default": 20 /* DefaultKeyword */,
            "delete": 21 /* DeleteKeyword */,
            "do": 22 /* DoKeyword */,
            "else": 23 /* ElseKeyword */,
            "enum": 46 /* EnumKeyword */,
            "export": 47 /* ExportKeyword */,
            "extends": 48 /* ExtendsKeyword */,
            "false": 24 /* FalseKeyword */,
            "finally": 25 /* FinallyKeyword */,
            "for": 26 /* ForKeyword */,
            "function": 27 /* FunctionKeyword */,
            "get": 65 /* GetKeyword */,
            "if": 28 /* IfKeyword */,
            "implements": 51 /* ImplementsKeyword */,
            "import": 49 /* ImportKeyword */,
            "in": 29 /* InKeyword */,
            "instanceof": 30 /* InstanceOfKeyword */,
            "interface": 52 /* InterfaceKeyword */,
            "let": 53 /* LetKeyword */,
            "module": 66 /* ModuleKeyword */,
            "new": 31 /* NewKeyword */,
            "null": 32 /* NullKeyword */,
            "number": 68 /* NumberKeyword */,
            "package": 54 /* PackageKeyword */,
            "private": 55 /* PrivateKeyword */,
            "protected": 56 /* ProtectedKeyword */,
            "public": 57 /* PublicKeyword */,
            "require": 67 /* RequireKeyword */,
            "return": 33 /* ReturnKeyword */,
            "set": 69 /* SetKeyword */,
            "static": 58 /* StaticKeyword */,
            "string": 70 /* StringKeyword */,
            "super": 50 /* SuperKeyword */,
            "switch": 34 /* SwitchKeyword */,
            "this": 35 /* ThisKeyword */,
            "throw": 36 /* ThrowKeyword */,
            "true": 37 /* TrueKeyword */,
            "try": 38 /* TryKeyword */,
            "typeof": 39 /* TypeOfKeyword */,
            "var": 40 /* VarKeyword */,
            "void": 41 /* VoidKeyword */,
            "while": 42 /* WhileKeyword */,
            "with": 43 /* WithKeyword */,
            "yield": 59 /* YieldKeyword */,
            "{": 71 /* OpenBraceToken */,
            "}": 72 /* CloseBraceToken */,
            "(": 73 /* OpenParenToken */,
            ")": 74 /* CloseParenToken */,
            "[": 75 /* OpenBracketToken */,
            "]": 76 /* CloseBracketToken */,
            ".": 77 /* DotToken */,
            "...": 78 /* DotDotDotToken */,
            ";": 79 /* SemicolonToken */,
            ",": 80 /* CommaToken */,
            "<": 81 /* LessThanToken */,
            ">": 82 /* GreaterThanToken */,
            "<=": 83 /* LessThanEqualsToken */,
            ">=": 84 /* GreaterThanEqualsToken */,
            "==": 85 /* EqualsEqualsToken */,
            "=>": 86 /* EqualsGreaterThanToken */,
            "!=": 87 /* ExclamationEqualsToken */,
            "===": 88 /* EqualsEqualsEqualsToken */,
            "!==": 89 /* ExclamationEqualsEqualsToken */,
            "+": 90 /* PlusToken */,
            "-": 91 /* MinusToken */,
            "*": 92 /* AsteriskToken */,
            "%": 93 /* PercentToken */,
            "++": 94 /* PlusPlusToken */,
            "--": 95 /* MinusMinusToken */,
            "<<": 96 /* LessThanLessThanToken */,
            ">>": 97 /* GreaterThanGreaterThanToken */,
            ">>>": 98 /* GreaterThanGreaterThanGreaterThanToken */,
            "&": 99 /* AmpersandToken */,
            "|": 100 /* BarToken */,
            "^": 101 /* CaretToken */,
            "!": 102 /* ExclamationToken */,
            "~": 103 /* TildeToken */,
            "&&": 104 /* AmpersandAmpersandToken */,
            "||": 105 /* BarBarToken */,
            "?": 106 /* QuestionToken */,
            ":": 107 /* ColonToken */,
            "=": 108 /* EqualsToken */,
            "+=": 109 /* PlusEqualsToken */,
            "-=": 110 /* MinusEqualsToken */,
            "*=": 111 /* AsteriskEqualsToken */,
            "%=": 112 /* PercentEqualsToken */,
            "<<=": 113 /* LessThanLessThanEqualsToken */,
            ">>=": 114 /* GreaterThanGreaterThanEqualsToken */,
            ">>>=": 115 /* GreaterThanGreaterThanGreaterThanEqualsToken */,
            "&=": 116 /* AmpersandEqualsToken */,
            "|=": 117 /* BarEqualsToken */,
            "^=": 118 /* CaretEqualsToken */,
            "/": 119 /* SlashToken */,
            "/=": 120 /* SlashEqualsToken */
        };

        var kindToText = [];

        for (var name in textToKeywordKind) {
            if (textToKeywordKind.hasOwnProperty(name)) {
                kindToText[textToKeywordKind[name]] = name;
            }
        }

        kindToText[63 /* ConstructorKeyword */] = "constructor";

        function getTokenKind(text) {
            if (textToKeywordKind.hasOwnProperty(text)) {
                return textToKeywordKind[text];
            }

            return 0 /* None */;
        }
        SyntaxFacts.getTokenKind = getTokenKind;

        function getText(kind) {
            var result = kindToText[kind];
            return result !== undefined ? result : null;
        }
        SyntaxFacts.getText = getText;

        function isTokenKind(kind) {
            return kind >= 9 /* FirstToken */ && kind <= 120 /* LastToken */;
        }
        SyntaxFacts.isTokenKind = isTokenKind;

        function isAnyKeyword(kind) {
            return kind >= TypeScript.SyntaxKind.FirstKeyword && kind <= TypeScript.SyntaxKind.LastKeyword;
        }
        SyntaxFacts.isAnyKeyword = isAnyKeyword;

        function isStandardKeyword(kind) {
            return kind >= 15 /* FirstStandardKeyword */ && kind <= 43 /* LastStandardKeyword */;
        }
        SyntaxFacts.isStandardKeyword = isStandardKeyword;

        function isFutureReservedKeyword(kind) {
            return kind >= 44 /* FirstFutureReservedKeyword */ && kind <= 50 /* LastFutureReservedKeyword */;
        }
        SyntaxFacts.isFutureReservedKeyword = isFutureReservedKeyword;

        function isFutureReservedStrictKeyword(kind) {
            return kind >= 51 /* FirstFutureReservedStrictKeyword */ && kind <= 59 /* LastFutureReservedStrictKeyword */;
        }
        SyntaxFacts.isFutureReservedStrictKeyword = isFutureReservedStrictKeyword;

        function isAnyPunctuation(kind) {
            return kind >= 71 /* FirstPunctuation */ && kind <= 120 /* LastPunctuation */;
        }
        SyntaxFacts.isAnyPunctuation = isAnyPunctuation;

        function isPrefixUnaryExpressionOperatorToken(tokenKind) {
            return getPrefixUnaryExpressionFromOperatorToken(tokenKind) !== 0 /* None */;
        }
        SyntaxFacts.isPrefixUnaryExpressionOperatorToken = isPrefixUnaryExpressionOperatorToken;

        function isBinaryExpressionOperatorToken(tokenKind) {
            return getBinaryExpressionFromOperatorToken(tokenKind) !== 0 /* None */;
        }
        SyntaxFacts.isBinaryExpressionOperatorToken = isBinaryExpressionOperatorToken;

        function getPrefixUnaryExpressionFromOperatorToken(tokenKind) {
            switch (tokenKind) {
                case 90 /* PlusToken */:
                    return 163 /* PlusExpression */;
                case 91 /* MinusToken */:
                    return 164 /* NegateExpression */;
                case 103 /* TildeToken */:
                    return 165 /* BitwiseNotExpression */;
                case 102 /* ExclamationToken */:
                    return 166 /* LogicalNotExpression */;
                case 94 /* PlusPlusToken */:
                    return 167 /* PreIncrementExpression */;
                case 95 /* MinusMinusToken */:
                    return 168 /* PreDecrementExpression */;

                default:
                    return 0 /* None */;
            }
        }
        SyntaxFacts.getPrefixUnaryExpressionFromOperatorToken = getPrefixUnaryExpressionFromOperatorToken;

        function getPostfixUnaryExpressionFromOperatorToken(tokenKind) {
            switch (tokenKind) {
                case 94 /* PlusPlusToken */:
                    return 209 /* PostIncrementExpression */;
                case 95 /* MinusMinusToken */:
                    return 210 /* PostDecrementExpression */;
                default:
                    return 0 /* None */;
            }
        }
        SyntaxFacts.getPostfixUnaryExpressionFromOperatorToken = getPostfixUnaryExpressionFromOperatorToken;

        function getBinaryExpressionFromOperatorToken(tokenKind) {
            switch (tokenKind) {
                case 92 /* AsteriskToken */:
                    return 204 /* MultiplyExpression */;

                case 119 /* SlashToken */:
                    return 205 /* DivideExpression */;

                case 93 /* PercentToken */:
                    return 206 /* ModuloExpression */;

                case 90 /* PlusToken */:
                    return 207 /* AddExpression */;

                case 91 /* MinusToken */:
                    return 208 /* SubtractExpression */;

                case 96 /* LessThanLessThanToken */:
                    return 201 /* LeftShiftExpression */;

                case 97 /* GreaterThanGreaterThanToken */:
                    return 202 /* SignedRightShiftExpression */;

                case 98 /* GreaterThanGreaterThanGreaterThanToken */:
                    return 203 /* UnsignedRightShiftExpression */;

                case 81 /* LessThanToken */:
                    return 195 /* LessThanExpression */;

                case 82 /* GreaterThanToken */:
                    return 196 /* GreaterThanExpression */;

                case 83 /* LessThanEqualsToken */:
                    return 197 /* LessThanOrEqualExpression */;

                case 84 /* GreaterThanEqualsToken */:
                    return 198 /* GreaterThanOrEqualExpression */;

                case 30 /* InstanceOfKeyword */:
                    return 199 /* InstanceOfExpression */;

                case 29 /* InKeyword */:
                    return 200 /* InExpression */;

                case 85 /* EqualsEqualsToken */:
                    return 191 /* EqualsWithTypeConversionExpression */;

                case 87 /* ExclamationEqualsToken */:
                    return 192 /* NotEqualsWithTypeConversionExpression */;

                case 88 /* EqualsEqualsEqualsToken */:
                    return 193 /* EqualsExpression */;

                case 89 /* ExclamationEqualsEqualsToken */:
                    return 194 /* NotEqualsExpression */;

                case 99 /* AmpersandToken */:
                    return 190 /* BitwiseAndExpression */;

                case 101 /* CaretToken */:
                    return 189 /* BitwiseExclusiveOrExpression */;

                case 100 /* BarToken */:
                    return 188 /* BitwiseOrExpression */;

                case 104 /* AmpersandAmpersandToken */:
                    return 187 /* LogicalAndExpression */;

                case 105 /* BarBarToken */:
                    return 186 /* LogicalOrExpression */;

                case 117 /* BarEqualsToken */:
                    return 181 /* OrAssignmentExpression */;

                case 116 /* AmpersandEqualsToken */:
                    return 179 /* AndAssignmentExpression */;

                case 118 /* CaretEqualsToken */:
                    return 180 /* ExclusiveOrAssignmentExpression */;

                case 113 /* LessThanLessThanEqualsToken */:
                    return 182 /* LeftShiftAssignmentExpression */;

                case 114 /* GreaterThanGreaterThanEqualsToken */:
                    return 183 /* SignedRightShiftAssignmentExpression */;

                case 115 /* GreaterThanGreaterThanGreaterThanEqualsToken */:
                    return 184 /* UnsignedRightShiftAssignmentExpression */;

                case 109 /* PlusEqualsToken */:
                    return 174 /* AddAssignmentExpression */;

                case 110 /* MinusEqualsToken */:
                    return 175 /* SubtractAssignmentExpression */;

                case 111 /* AsteriskEqualsToken */:
                    return 176 /* MultiplyAssignmentExpression */;

                case 120 /* SlashEqualsToken */:
                    return 177 /* DivideAssignmentExpression */;

                case 112 /* PercentEqualsToken */:
                    return 178 /* ModuloAssignmentExpression */;

                case 108 /* EqualsToken */:
                    return 173 /* AssignmentExpression */;

                case 80 /* CommaToken */:
                    return 172 /* CommaExpression */;

                default:
                    return 0 /* None */;
            }
        }
        SyntaxFacts.getBinaryExpressionFromOperatorToken = getBinaryExpressionFromOperatorToken;

        function isAnyDivideToken(kind) {
            switch (kind) {
                case 119 /* SlashToken */:
                case 120 /* SlashEqualsToken */:
                    return true;
                default:
                    return false;
            }
        }
        SyntaxFacts.isAnyDivideToken = isAnyDivideToken;

        function isAnyDivideOrRegularExpressionToken(kind) {
            switch (kind) {
                case 119 /* SlashToken */:
                case 120 /* SlashEqualsToken */:
                case 12 /* RegularExpressionLiteral */:
                    return true;
                default:
                    return false;
            }
        }
        SyntaxFacts.isAnyDivideOrRegularExpressionToken = isAnyDivideOrRegularExpressionToken;

        function isParserGenerated(kind) {
            switch (kind) {
                case 97 /* GreaterThanGreaterThanToken */:
                case 98 /* GreaterThanGreaterThanGreaterThanToken */:
                case 84 /* GreaterThanEqualsToken */:
                case 114 /* GreaterThanGreaterThanEqualsToken */:
                case 115 /* GreaterThanGreaterThanGreaterThanEqualsToken */:
                    return true;
                default:
                    return false;
            }
        }
        SyntaxFacts.isParserGenerated = isParserGenerated;

        function isAnyBinaryExpression(kind) {
            switch (kind) {
                case 172 /* CommaExpression */:
                case 173 /* AssignmentExpression */:
                case 174 /* AddAssignmentExpression */:
                case 175 /* SubtractAssignmentExpression */:
                case 176 /* MultiplyAssignmentExpression */:
                case 177 /* DivideAssignmentExpression */:
                case 178 /* ModuloAssignmentExpression */:
                case 179 /* AndAssignmentExpression */:
                case 180 /* ExclusiveOrAssignmentExpression */:
                case 181 /* OrAssignmentExpression */:
                case 182 /* LeftShiftAssignmentExpression */:
                case 183 /* SignedRightShiftAssignmentExpression */:
                case 184 /* UnsignedRightShiftAssignmentExpression */:
                case 186 /* LogicalOrExpression */:
                case 187 /* LogicalAndExpression */:
                case 188 /* BitwiseOrExpression */:
                case 189 /* BitwiseExclusiveOrExpression */:
                case 190 /* BitwiseAndExpression */:
                case 191 /* EqualsWithTypeConversionExpression */:
                case 192 /* NotEqualsWithTypeConversionExpression */:
                case 193 /* EqualsExpression */:
                case 194 /* NotEqualsExpression */:
                case 195 /* LessThanExpression */:
                case 196 /* GreaterThanExpression */:
                case 197 /* LessThanOrEqualExpression */:
                case 198 /* GreaterThanOrEqualExpression */:
                case 199 /* InstanceOfExpression */:
                case 200 /* InExpression */:
                case 201 /* LeftShiftExpression */:
                case 202 /* SignedRightShiftExpression */:
                case 203 /* UnsignedRightShiftExpression */:
                case 204 /* MultiplyExpression */:
                case 205 /* DivideExpression */:
                case 206 /* ModuloExpression */:
                case 207 /* AddExpression */:
                case 208 /* SubtractExpression */:
                    return true;
            }

            return false;
        }
        SyntaxFacts.isAnyBinaryExpression = isAnyBinaryExpression;
    })(TypeScript.SyntaxFacts || (TypeScript.SyntaxFacts = {}));
    var SyntaxFacts = TypeScript.SyntaxFacts;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (SyntaxFacts) {
        function isDirectivePrologueElement(node) {
            if (node.kind() === 148 /* ExpressionStatement */) {
                var expressionStatement = node;
                var expression = expressionStatement.expression;

                if (expression.kind() === 14 /* StringLiteral */) {
                    return true;
                }
            }

            return false;
        }
        SyntaxFacts.isDirectivePrologueElement = isDirectivePrologueElement;

        function isUseStrictDirective(node) {
            var expressionStatement = node;
            var stringLiteral = expressionStatement.expression;

            var text = stringLiteral.text();
            return text === '"use strict"' || text === "'use strict'";
        }
        SyntaxFacts.isUseStrictDirective = isUseStrictDirective;

        function isIdentifierNameOrAnyKeyword(token) {
            var tokenKind = token.tokenKind;
            return tokenKind === 11 /* IdentifierName */ || TypeScript.SyntaxFacts.isAnyKeyword(tokenKind);
        }
        SyntaxFacts.isIdentifierNameOrAnyKeyword = isIdentifierNameOrAnyKeyword;
    })(TypeScript.SyntaxFacts || (TypeScript.SyntaxFacts = {}));
    var SyntaxFacts = TypeScript.SyntaxFacts;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Syntax) {
        var EmptySyntaxList = (function () {
            function EmptySyntaxList() {
            }
            EmptySyntaxList.prototype.kind = function () {
                return 1 /* List */;
            };

            EmptySyntaxList.prototype.isNode = function () {
                return false;
            };
            EmptySyntaxList.prototype.isToken = function () {
                return false;
            };
            EmptySyntaxList.prototype.isList = function () {
                return true;
            };
            EmptySyntaxList.prototype.isSeparatedList = function () {
                return false;
            };

            EmptySyntaxList.prototype.toJSON = function (key) {
                return [];
            };

            EmptySyntaxList.prototype.childCount = function () {
                return 0;
            };

            EmptySyntaxList.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            };

            EmptySyntaxList.prototype.toArray = function () {
                return [];
            };

            EmptySyntaxList.prototype.collectTextElements = function (elements) {
            };

            EmptySyntaxList.prototype.firstToken = function () {
                return null;
            };

            EmptySyntaxList.prototype.lastToken = function () {
                return null;
            };

            EmptySyntaxList.prototype.fullWidth = function () {
                return 0;
            };

            EmptySyntaxList.prototype.width = function () {
                return 0;
            };

            EmptySyntaxList.prototype.leadingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };

            EmptySyntaxList.prototype.trailingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };

            EmptySyntaxList.prototype.leadingTriviaWidth = function () {
                return 0;
            };

            EmptySyntaxList.prototype.trailingTriviaWidth = function () {
                return 0;
            };

            EmptySyntaxList.prototype.fullText = function () {
                return "";
            };

            EmptySyntaxList.prototype.isTypeScriptSpecific = function () {
                return false;
            };

            EmptySyntaxList.prototype.isIncrementallyUnusable = function () {
                return false;
            };

            EmptySyntaxList.prototype.findTokenInternal = function (parent, position, fullStart) {
                throw TypeScript.Errors.invalidOperation();
            };

            EmptySyntaxList.prototype.insertChildrenInto = function (array, index) {
            };
            return EmptySyntaxList;
        })();
        Syntax.EmptySyntaxList = EmptySyntaxList;

        Syntax.emptyList = new EmptySyntaxList();

        var SingletonSyntaxList = (function () {
            function SingletonSyntaxList(item) {
                this.item = item;
            }
            SingletonSyntaxList.prototype.kind = function () {
                return 1 /* List */;
            };

            SingletonSyntaxList.prototype.isToken = function () {
                return false;
            };
            SingletonSyntaxList.prototype.isNode = function () {
                return false;
            };
            SingletonSyntaxList.prototype.isList = function () {
                return true;
            };
            SingletonSyntaxList.prototype.isSeparatedList = function () {
                return false;
            };

            SingletonSyntaxList.prototype.toJSON = function (key) {
                return [this.item];
            };

            SingletonSyntaxList.prototype.childCount = function () {
                return 1;
            };

            SingletonSyntaxList.prototype.childAt = function (index) {
                if (index !== 0) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }

                return this.item;
            };

            SingletonSyntaxList.prototype.toArray = function () {
                return [this.item];
            };

            SingletonSyntaxList.prototype.collectTextElements = function (elements) {
                this.item.collectTextElements(elements);
            };

            SingletonSyntaxList.prototype.firstToken = function () {
                return this.item.firstToken();
            };

            SingletonSyntaxList.prototype.lastToken = function () {
                return this.item.lastToken();
            };

            SingletonSyntaxList.prototype.fullWidth = function () {
                return this.item.fullWidth();
            };

            SingletonSyntaxList.prototype.width = function () {
                return this.item.width();
            };

            SingletonSyntaxList.prototype.leadingTrivia = function () {
                return this.item.leadingTrivia();
            };

            SingletonSyntaxList.prototype.trailingTrivia = function () {
                return this.item.trailingTrivia();
            };

            SingletonSyntaxList.prototype.leadingTriviaWidth = function () {
                return this.item.leadingTriviaWidth();
            };

            SingletonSyntaxList.prototype.trailingTriviaWidth = function () {
                return this.item.trailingTriviaWidth();
            };

            SingletonSyntaxList.prototype.fullText = function () {
                return this.item.fullText();
            };

            SingletonSyntaxList.prototype.isTypeScriptSpecific = function () {
                return this.item.isTypeScriptSpecific();
            };

            SingletonSyntaxList.prototype.isIncrementallyUnusable = function () {
                return this.item.isIncrementallyUnusable();
            };

            SingletonSyntaxList.prototype.findTokenInternal = function (parent, position, fullStart) {
                return (this.item).findTokenInternal(new TypeScript.PositionedList(parent, this, fullStart), position, fullStart);
            };

            SingletonSyntaxList.prototype.insertChildrenInto = function (array, index) {
                array.splice(index, 0, this.item);
            };
            return SingletonSyntaxList;
        })();

        var NormalSyntaxList = (function () {
            function NormalSyntaxList(nodeOrTokens) {
                this._data = 0;
                this.nodeOrTokens = nodeOrTokens;
            }
            NormalSyntaxList.prototype.kind = function () {
                return 1 /* List */;
            };

            NormalSyntaxList.prototype.isNode = function () {
                return false;
            };
            NormalSyntaxList.prototype.isToken = function () {
                return false;
            };
            NormalSyntaxList.prototype.isList = function () {
                return true;
            };
            NormalSyntaxList.prototype.isSeparatedList = function () {
                return false;
            };

            NormalSyntaxList.prototype.toJSON = function (key) {
                return this.nodeOrTokens;
            };

            NormalSyntaxList.prototype.childCount = function () {
                return this.nodeOrTokens.length;
            };

            NormalSyntaxList.prototype.childAt = function (index) {
                if (index < 0 || index >= this.nodeOrTokens.length) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }

                return this.nodeOrTokens[index];
            };

            NormalSyntaxList.prototype.toArray = function () {
                return this.nodeOrTokens.slice(0);
            };

            NormalSyntaxList.prototype.collectTextElements = function (elements) {
                for (var i = 0, n = this.nodeOrTokens.length; i < n; i++) {
                    var element = this.nodeOrTokens[i];
                    element.collectTextElements(elements);
                }
            };

            NormalSyntaxList.prototype.firstToken = function () {
                for (var i = 0, n = this.nodeOrTokens.length; i < n; i++) {
                    var token = this.nodeOrTokens[i].firstToken();
                    if (token !== null) {
                        return token;
                    }
                }

                return null;
            };

            NormalSyntaxList.prototype.lastToken = function () {
                for (var i = this.nodeOrTokens.length - 1; i >= 0; i--) {
                    var token = this.nodeOrTokens[i].lastToken();
                    if (token !== null) {
                        return token;
                    }
                }

                return null;
            };

            NormalSyntaxList.prototype.fullText = function () {
                var elements = [];
                this.collectTextElements(elements);
                return elements.join("");
            };

            NormalSyntaxList.prototype.isTypeScriptSpecific = function () {
                for (var i = 0, n = this.nodeOrTokens.length; i < n; i++) {
                    if (this.nodeOrTokens[i].isTypeScriptSpecific()) {
                        return true;
                    }
                }

                return false;
            };

            NormalSyntaxList.prototype.isIncrementallyUnusable = function () {
                return (this.data() & 2 /* NodeIncrementallyUnusableMask */) !== 0;
            };

            NormalSyntaxList.prototype.fullWidth = function () {
                return this.data() >>> 3 /* NodeFullWidthShift */;
            };

            NormalSyntaxList.prototype.width = function () {
                var fullWidth = this.fullWidth();
                return fullWidth - this.leadingTriviaWidth() - this.trailingTriviaWidth();
            };

            NormalSyntaxList.prototype.leadingTrivia = function () {
                return this.firstToken().leadingTrivia();
            };

            NormalSyntaxList.prototype.trailingTrivia = function () {
                return this.lastToken().trailingTrivia();
            };

            NormalSyntaxList.prototype.leadingTriviaWidth = function () {
                return this.firstToken().leadingTriviaWidth();
            };

            NormalSyntaxList.prototype.trailingTriviaWidth = function () {
                return this.lastToken().trailingTriviaWidth();
            };

            NormalSyntaxList.prototype.computeData = function () {
                var fullWidth = 0;
                var isIncrementallyUnusable = false;

                for (var i = 0, n = this.nodeOrTokens.length; i < n; i++) {
                    var node = this.nodeOrTokens[i];
                    fullWidth += node.fullWidth();
                    isIncrementallyUnusable = isIncrementallyUnusable || node.isIncrementallyUnusable();
                }

                return (fullWidth << 3 /* NodeFullWidthShift */) | (isIncrementallyUnusable ? 2 /* NodeIncrementallyUnusableMask */ : 0) | 1 /* NodeDataComputed */;
            };

            NormalSyntaxList.prototype.data = function () {
                if ((this._data & 1 /* NodeDataComputed */) === 0) {
                    this._data = this.computeData();
                }

                return this._data;
            };

            NormalSyntaxList.prototype.findTokenInternal = function (parent, position, fullStart) {
                parent = new TypeScript.PositionedList(parent, this, fullStart);
                for (var i = 0, n = this.nodeOrTokens.length; i < n; i++) {
                    var nodeOrToken = this.nodeOrTokens[i];

                    var childWidth = nodeOrToken.fullWidth();
                    if (position < childWidth) {
                        return (nodeOrToken).findTokenInternal(parent, position, fullStart);
                    }

                    position -= childWidth;
                    fullStart += childWidth;
                }

                throw TypeScript.Errors.invalidOperation();
            };

            NormalSyntaxList.prototype.insertChildrenInto = function (array, index) {
                if (index === 0) {
                    array.unshift.apply(array, this.nodeOrTokens);
                } else {
                    array.splice.apply(array, [index, 0].concat(this.nodeOrTokens));
                }
            };
            return NormalSyntaxList;
        })();

        function list(nodes) {
            if (nodes === undefined || nodes === null || nodes.length === 0) {
                return Syntax.emptyList;
            }

            if (nodes.length === 1) {
                var item = nodes[0];
                return new SingletonSyntaxList(item);
            }

            return new NormalSyntaxList(nodes);
        }
        Syntax.list = list;
    })(TypeScript.Syntax || (TypeScript.Syntax = {}));
    var Syntax = TypeScript.Syntax;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxNode = (function () {
        function SyntaxNode(parsedInStrictMode) {
            this._data = parsedInStrictMode ? 4 /* NodeParsedInStrictModeMask */ : 0;
        }
        SyntaxNode.prototype.isNode = function () {
            return true;
        };
        SyntaxNode.prototype.isToken = function () {
            return false;
        };
        SyntaxNode.prototype.isList = function () {
            return false;
        };
        SyntaxNode.prototype.isSeparatedList = function () {
            return false;
        };

        SyntaxNode.prototype.kind = function () {
            throw TypeScript.Errors.abstract();
        };

        SyntaxNode.prototype.childCount = function () {
            throw TypeScript.Errors.abstract();
        };

        SyntaxNode.prototype.childAt = function (slot) {
            throw TypeScript.Errors.abstract();
        };

        SyntaxNode.prototype.firstToken = function () {
            for (var i = 0, n = this.childCount(); i < n; i++) {
                var element = this.childAt(i);

                if (element !== null) {
                    if (element.fullWidth() > 0 || element.kind() === 10 /* EndOfFileToken */) {
                        return element.firstToken();
                    }
                }
            }

            return null;
        };

        SyntaxNode.prototype.lastToken = function () {
            for (var i = this.childCount() - 1; i >= 0; i--) {
                var element = this.childAt(i);

                if (element !== null) {
                    if (element.fullWidth() > 0 || element.kind() === 10 /* EndOfFileToken */) {
                        return element.lastToken();
                    }
                }
            }

            return null;
        };

        SyntaxNode.prototype.insertChildrenInto = function (array, index) {
            for (var i = this.childCount() - 1; i >= 0; i--) {
                var element = this.childAt(i);

                if (element !== null) {
                    if (element.isNode() || element.isToken()) {
                        array.splice(index, 0, element);
                    } else if (element.isList()) {
                        (element).insertChildrenInto(array, index);
                    } else if (element.isSeparatedList()) {
                        (element).insertChildrenInto(array, index);
                    } else {
                        throw TypeScript.Errors.invalidOperation();
                    }
                }
            }
        };

        SyntaxNode.prototype.leadingTrivia = function () {
            return this.firstToken().leadingTrivia();
        };

        SyntaxNode.prototype.trailingTrivia = function () {
            return this.lastToken().trailingTrivia();
        };

        SyntaxNode.prototype.toJSON = function (key) {
            var result = {
                kind: TypeScript.SyntaxKind[this.kind()],
                fullWidth: this.fullWidth()
            };

            if (this.isIncrementallyUnusable()) {
                result.isIncrementallyUnusable = true;
            }

            if (this.parsedInStrictMode()) {
                result.parsedInStrictMode = true;
            }

            for (var i = 0, n = this.childCount(); i < n; i++) {
                var value = this.childAt(i);

                if (value) {
                    for (var name in this) {
                        if (value === this[name]) {
                            result[name] = value;
                            break;
                        }
                    }
                }
            }

            return result;
        };

        SyntaxNode.prototype.accept = function (visitor) {
            throw TypeScript.Errors.abstract();
        };

        SyntaxNode.prototype.fullText = function () {
            var elements = [];
            this.collectTextElements(elements);
            return elements.join("");
        };

        SyntaxNode.prototype.collectTextElements = function (elements) {
            for (var i = 0, n = this.childCount(); i < n; i++) {
                var element = this.childAt(i);

                if (element !== null) {
                    element.collectTextElements(elements);
                }
            }
        };

        SyntaxNode.prototype.replaceToken = function (token1, token2) {
            if (token1 === token2) {
                return this;
            }

            return this.accept(new TypeScript.SyntaxTokenReplacer(token1, token2));
        };

        SyntaxNode.prototype.withLeadingTrivia = function (trivia) {
            return this.replaceToken(this.firstToken(), this.firstToken().withLeadingTrivia(trivia));
        };

        SyntaxNode.prototype.withTrailingTrivia = function (trivia) {
            return this.replaceToken(this.lastToken(), this.lastToken().withTrailingTrivia(trivia));
        };

        SyntaxNode.prototype.hasLeadingTrivia = function () {
            return this.lastToken().hasLeadingTrivia();
        };

        SyntaxNode.prototype.hasTrailingTrivia = function () {
            return this.lastToken().hasTrailingTrivia();
        };

        SyntaxNode.prototype.isTypeScriptSpecific = function () {
            return false;
        };

        SyntaxNode.prototype.isIncrementallyUnusable = function () {
            return (this.data() & 2 /* NodeIncrementallyUnusableMask */) !== 0;
        };

        SyntaxNode.prototype.parsedInStrictMode = function () {
            return (this.data() & 4 /* NodeParsedInStrictModeMask */) !== 0;
        };

        SyntaxNode.prototype.fullWidth = function () {
            return this.data() >>> 3 /* NodeFullWidthShift */;
        };

        SyntaxNode.prototype.computeData = function () {
            var slotCount = this.childCount();

            var fullWidth = 0;
            var childWidth = 0;

            var isIncrementallyUnusable = ((this._data & 2 /* NodeIncrementallyUnusableMask */) !== 0) || slotCount === 0;

            for (var i = 0, n = slotCount; i < n; i++) {
                var element = this.childAt(i);

                if (element !== null) {
                    childWidth = element.fullWidth();
                    fullWidth += childWidth;

                    if (!isIncrementallyUnusable) {
                        isIncrementallyUnusable = element.isIncrementallyUnusable();
                    }
                }
            }

            return (fullWidth << 3 /* NodeFullWidthShift */) | (isIncrementallyUnusable ? 2 /* NodeIncrementallyUnusableMask */ : 0) | 1 /* NodeDataComputed */;
        };

        SyntaxNode.prototype.data = function () {
            if ((this._data & 1 /* NodeDataComputed */) === 0) {
                this._data |= this.computeData();
            }

            return this._data;
        };

        SyntaxNode.prototype.findToken = function (position, includeSkippedTokens) {
            if (typeof includeSkippedTokens === "undefined") { includeSkippedTokens = false; }
            var endOfFileToken = this.tryGetEndOfFileAt(position);
            if (endOfFileToken !== null) {
                return endOfFileToken;
            }

            if (position < 0 || position >= this.fullWidth()) {
                throw TypeScript.Errors.argumentOutOfRange("position");
            }

            var positionedToken = this.findTokenInternal(null, position, 0);

            if (includeSkippedTokens) {
                return TypeScript.Syntax.findSkippedTokenInPositionedToken(positionedToken, position) || positionedToken;
            }

            return positionedToken;
        };

        SyntaxNode.prototype.tryGetEndOfFileAt = function (position) {
            if (this.kind() === 121 /* SourceUnit */ && position === this.fullWidth()) {
                var sourceUnit = this;
                return new TypeScript.PositionedToken(new TypeScript.PositionedNode(null, sourceUnit, 0), sourceUnit.endOfFileToken, sourceUnit.moduleElements.fullWidth());
            }

            return null;
        };

        SyntaxNode.prototype.findTokenInternal = function (parent, position, fullStart) {
            parent = new TypeScript.PositionedNode(parent, this, fullStart);
            for (var i = 0, n = this.childCount(); i < n; i++) {
                var element = this.childAt(i);

                if (element !== null) {
                    var childWidth = element.fullWidth();

                    if (position < childWidth) {
                        return (element).findTokenInternal(parent, position, fullStart);
                    }

                    position -= childWidth;
                    fullStart += childWidth;
                }
            }

            throw TypeScript.Errors.invalidOperation();
        };

        SyntaxNode.prototype.findTokenOnLeft = function (position, includeSkippedTokens) {
            if (typeof includeSkippedTokens === "undefined") { includeSkippedTokens = false; }
            var positionedToken = this.findToken(position, includeSkippedTokens);
            var start = positionedToken.start();

            if (position > start) {
                return positionedToken;
            }

            if (positionedToken.fullStart() === 0) {
                return null;
            }

            return positionedToken.previousToken(includeSkippedTokens);
        };

        SyntaxNode.prototype.findCompleteTokenOnLeft = function (position, includeSkippedTokens) {
            if (typeof includeSkippedTokens === "undefined") { includeSkippedTokens = false; }
            var positionedToken = this.findToken(position, includeSkippedTokens);

            if (positionedToken.token().width() > 0 && position >= positionedToken.end()) {
                return positionedToken;
            }

            return positionedToken.previousToken(includeSkippedTokens);
        };

        SyntaxNode.prototype.isModuleElement = function () {
            return false;
        };

        SyntaxNode.prototype.isClassElement = function () {
            return false;
        };

        SyntaxNode.prototype.isTypeMember = function () {
            return false;
        };

        SyntaxNode.prototype.isStatement = function () {
            return false;
        };

        SyntaxNode.prototype.isSwitchClause = function () {
            return false;
        };

        SyntaxNode.prototype.structuralEquals = function (node) {
            if (this === node) {
                return true;
            }
            if (node === null) {
                return false;
            }
            if (this.kind() !== node.kind()) {
                return false;
            }

            for (var i = 0, n = this.childCount(); i < n; i++) {
                var element1 = this.childAt(i);
                var element2 = node.childAt(i);

                if (!TypeScript.Syntax.elementStructuralEquals(element1, element2)) {
                    return false;
                }
            }

            return true;
        };

        SyntaxNode.prototype.width = function () {
            return this.fullWidth() - this.leadingTriviaWidth() - this.trailingTriviaWidth();
        };

        SyntaxNode.prototype.leadingTriviaWidth = function () {
            var firstToken = this.firstToken();
            return firstToken === null ? 0 : firstToken.leadingTriviaWidth();
        };

        SyntaxNode.prototype.trailingTriviaWidth = function () {
            var lastToken = this.lastToken();
            return lastToken === null ? 0 : lastToken.trailingTriviaWidth();
        };
        return SyntaxNode;
    })();
    TypeScript.SyntaxNode = SyntaxNode;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SourceUnitSyntax = (function (_super) {
        __extends(SourceUnitSyntax, _super);
        function SourceUnitSyntax(moduleElements, endOfFileToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.moduleElements = moduleElements;
            this.endOfFileToken = endOfFileToken;
        }
        SourceUnitSyntax.prototype.accept = function (visitor) {
            return visitor.visitSourceUnit(this);
        };

        SourceUnitSyntax.prototype.kind = function () {
            return 121 /* SourceUnit */;
        };

        SourceUnitSyntax.prototype.childCount = function () {
            return 2;
        };

        SourceUnitSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.moduleElements;
                case 1:
                    return this.endOfFileToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        SourceUnitSyntax.prototype.update = function (moduleElements, endOfFileToken) {
            if (this.moduleElements === moduleElements && this.endOfFileToken === endOfFileToken) {
                return this;
            }

            return new SourceUnitSyntax(moduleElements, endOfFileToken, this.parsedInStrictMode());
        };

        SourceUnitSyntax.create = function (endOfFileToken) {
            return new SourceUnitSyntax(TypeScript.Syntax.emptyList, endOfFileToken, false);
        };

        SourceUnitSyntax.create1 = function (endOfFileToken) {
            return new SourceUnitSyntax(TypeScript.Syntax.emptyList, endOfFileToken, false);
        };

        SourceUnitSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        SourceUnitSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        SourceUnitSyntax.prototype.withModuleElements = function (moduleElements) {
            return this.update(moduleElements, this.endOfFileToken);
        };

        SourceUnitSyntax.prototype.withModuleElement = function (moduleElement) {
            return this.withModuleElements(TypeScript.Syntax.list([moduleElement]));
        };

        SourceUnitSyntax.prototype.withEndOfFileToken = function (endOfFileToken) {
            return this.update(this.moduleElements, endOfFileToken);
        };

        SourceUnitSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.moduleElements.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return SourceUnitSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.SourceUnitSyntax = SourceUnitSyntax;

    var ModuleReferenceSyntax = (function (_super) {
        __extends(ModuleReferenceSyntax, _super);
        function ModuleReferenceSyntax(parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
        }
        ModuleReferenceSyntax.prototype.isModuleReference = function () {
            return true;
        };

        ModuleReferenceSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ModuleReferenceSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ModuleReferenceSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ModuleReferenceSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ModuleReferenceSyntax = ModuleReferenceSyntax;

    var ExternalModuleReferenceSyntax = (function (_super) {
        __extends(ExternalModuleReferenceSyntax, _super);
        function ExternalModuleReferenceSyntax(moduleOrRequireKeyword, openParenToken, stringLiteral, closeParenToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.moduleOrRequireKeyword = moduleOrRequireKeyword;
            this.openParenToken = openParenToken;
            this.stringLiteral = stringLiteral;
            this.closeParenToken = closeParenToken;
        }
        ExternalModuleReferenceSyntax.prototype.accept = function (visitor) {
            return visitor.visitExternalModuleReference(this);
        };

        ExternalModuleReferenceSyntax.prototype.kind = function () {
            return 245 /* ExternalModuleReference */;
        };

        ExternalModuleReferenceSyntax.prototype.childCount = function () {
            return 4;
        };

        ExternalModuleReferenceSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.moduleOrRequireKeyword;
                case 1:
                    return this.openParenToken;
                case 2:
                    return this.stringLiteral;
                case 3:
                    return this.closeParenToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ExternalModuleReferenceSyntax.prototype.update = function (moduleOrRequireKeyword, openParenToken, stringLiteral, closeParenToken) {
            if (this.moduleOrRequireKeyword === moduleOrRequireKeyword && this.openParenToken === openParenToken && this.stringLiteral === stringLiteral && this.closeParenToken === closeParenToken) {
                return this;
            }

            return new ExternalModuleReferenceSyntax(moduleOrRequireKeyword, openParenToken, stringLiteral, closeParenToken, this.parsedInStrictMode());
        };

        ExternalModuleReferenceSyntax.create1 = function (moduleOrRequireKeyword, stringLiteral) {
            return new ExternalModuleReferenceSyntax(moduleOrRequireKeyword, TypeScript.Syntax.token(73 /* OpenParenToken */), stringLiteral, TypeScript.Syntax.token(74 /* CloseParenToken */), false);
        };

        ExternalModuleReferenceSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ExternalModuleReferenceSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ExternalModuleReferenceSyntax.prototype.withModuleOrRequireKeyword = function (moduleOrRequireKeyword) {
            return this.update(moduleOrRequireKeyword, this.openParenToken, this.stringLiteral, this.closeParenToken);
        };

        ExternalModuleReferenceSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.moduleOrRequireKeyword, openParenToken, this.stringLiteral, this.closeParenToken);
        };

        ExternalModuleReferenceSyntax.prototype.withStringLiteral = function (stringLiteral) {
            return this.update(this.moduleOrRequireKeyword, this.openParenToken, stringLiteral, this.closeParenToken);
        };

        ExternalModuleReferenceSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.moduleOrRequireKeyword, this.openParenToken, this.stringLiteral, closeParenToken);
        };

        ExternalModuleReferenceSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ExternalModuleReferenceSyntax;
    })(ModuleReferenceSyntax);
    TypeScript.ExternalModuleReferenceSyntax = ExternalModuleReferenceSyntax;

    var ModuleNameModuleReferenceSyntax = (function (_super) {
        __extends(ModuleNameModuleReferenceSyntax, _super);
        function ModuleNameModuleReferenceSyntax(moduleName, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.moduleName = moduleName;
        }
        ModuleNameModuleReferenceSyntax.prototype.accept = function (visitor) {
            return visitor.visitModuleNameModuleReference(this);
        };

        ModuleNameModuleReferenceSyntax.prototype.kind = function () {
            return 246 /* ModuleNameModuleReference */;
        };

        ModuleNameModuleReferenceSyntax.prototype.childCount = function () {
            return 1;
        };

        ModuleNameModuleReferenceSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.moduleName;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ModuleNameModuleReferenceSyntax.prototype.update = function (moduleName) {
            if (this.moduleName === moduleName) {
                return this;
            }

            return new ModuleNameModuleReferenceSyntax(moduleName, this.parsedInStrictMode());
        };

        ModuleNameModuleReferenceSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ModuleNameModuleReferenceSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ModuleNameModuleReferenceSyntax.prototype.withModuleName = function (moduleName) {
            return this.update(moduleName);
        };

        ModuleNameModuleReferenceSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ModuleNameModuleReferenceSyntax;
    })(ModuleReferenceSyntax);
    TypeScript.ModuleNameModuleReferenceSyntax = ModuleNameModuleReferenceSyntax;

    var ImportDeclarationSyntax = (function (_super) {
        __extends(ImportDeclarationSyntax, _super);
        function ImportDeclarationSyntax(importKeyword, identifier, equalsToken, moduleReference, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.importKeyword = importKeyword;
            this.identifier = identifier;
            this.equalsToken = equalsToken;
            this.moduleReference = moduleReference;
            this.semicolonToken = semicolonToken;
        }
        ImportDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitImportDeclaration(this);
        };

        ImportDeclarationSyntax.prototype.kind = function () {
            return 133 /* ImportDeclaration */;
        };

        ImportDeclarationSyntax.prototype.childCount = function () {
            return 5;
        };

        ImportDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.importKeyword;
                case 1:
                    return this.identifier;
                case 2:
                    return this.equalsToken;
                case 3:
                    return this.moduleReference;
                case 4:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ImportDeclarationSyntax.prototype.isModuleElement = function () {
            return true;
        };

        ImportDeclarationSyntax.prototype.update = function (importKeyword, identifier, equalsToken, moduleReference, semicolonToken) {
            if (this.importKeyword === importKeyword && this.identifier === identifier && this.equalsToken === equalsToken && this.moduleReference === moduleReference && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new ImportDeclarationSyntax(importKeyword, identifier, equalsToken, moduleReference, semicolonToken, this.parsedInStrictMode());
        };

        ImportDeclarationSyntax.create1 = function (identifier, moduleReference) {
            return new ImportDeclarationSyntax(TypeScript.Syntax.token(49 /* ImportKeyword */), identifier, TypeScript.Syntax.token(108 /* EqualsToken */), moduleReference, TypeScript.Syntax.token(79 /* SemicolonToken */), false);
        };

        ImportDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ImportDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ImportDeclarationSyntax.prototype.withImportKeyword = function (importKeyword) {
            return this.update(importKeyword, this.identifier, this.equalsToken, this.moduleReference, this.semicolonToken);
        };

        ImportDeclarationSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.importKeyword, identifier, this.equalsToken, this.moduleReference, this.semicolonToken);
        };

        ImportDeclarationSyntax.prototype.withEqualsToken = function (equalsToken) {
            return this.update(this.importKeyword, this.identifier, equalsToken, this.moduleReference, this.semicolonToken);
        };

        ImportDeclarationSyntax.prototype.withModuleReference = function (moduleReference) {
            return this.update(this.importKeyword, this.identifier, this.equalsToken, moduleReference, this.semicolonToken);
        };

        ImportDeclarationSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.importKeyword, this.identifier, this.equalsToken, this.moduleReference, semicolonToken);
        };

        ImportDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ImportDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ImportDeclarationSyntax = ImportDeclarationSyntax;

    var ExportAssignmentSyntax = (function (_super) {
        __extends(ExportAssignmentSyntax, _super);
        function ExportAssignmentSyntax(exportKeyword, equalsToken, identifier, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.exportKeyword = exportKeyword;
            this.equalsToken = equalsToken;
            this.identifier = identifier;
            this.semicolonToken = semicolonToken;
        }
        ExportAssignmentSyntax.prototype.accept = function (visitor) {
            return visitor.visitExportAssignment(this);
        };

        ExportAssignmentSyntax.prototype.kind = function () {
            return 134 /* ExportAssignment */;
        };

        ExportAssignmentSyntax.prototype.childCount = function () {
            return 4;
        };

        ExportAssignmentSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.exportKeyword;
                case 1:
                    return this.equalsToken;
                case 2:
                    return this.identifier;
                case 3:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ExportAssignmentSyntax.prototype.isModuleElement = function () {
            return true;
        };

        ExportAssignmentSyntax.prototype.update = function (exportKeyword, equalsToken, identifier, semicolonToken) {
            if (this.exportKeyword === exportKeyword && this.equalsToken === equalsToken && this.identifier === identifier && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new ExportAssignmentSyntax(exportKeyword, equalsToken, identifier, semicolonToken, this.parsedInStrictMode());
        };

        ExportAssignmentSyntax.create1 = function (identifier) {
            return new ExportAssignmentSyntax(TypeScript.Syntax.token(47 /* ExportKeyword */), TypeScript.Syntax.token(108 /* EqualsToken */), identifier, TypeScript.Syntax.token(79 /* SemicolonToken */), false);
        };

        ExportAssignmentSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ExportAssignmentSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ExportAssignmentSyntax.prototype.withExportKeyword = function (exportKeyword) {
            return this.update(exportKeyword, this.equalsToken, this.identifier, this.semicolonToken);
        };

        ExportAssignmentSyntax.prototype.withEqualsToken = function (equalsToken) {
            return this.update(this.exportKeyword, equalsToken, this.identifier, this.semicolonToken);
        };

        ExportAssignmentSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.exportKeyword, this.equalsToken, identifier, this.semicolonToken);
        };

        ExportAssignmentSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.exportKeyword, this.equalsToken, this.identifier, semicolonToken);
        };

        ExportAssignmentSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ExportAssignmentSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ExportAssignmentSyntax = ExportAssignmentSyntax;

    var ClassDeclarationSyntax = (function (_super) {
        __extends(ClassDeclarationSyntax, _super);
        function ClassDeclarationSyntax(modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.modifiers = modifiers;
            this.classKeyword = classKeyword;
            this.identifier = identifier;
            this.typeParameterList = typeParameterList;
            this.heritageClauses = heritageClauses;
            this.openBraceToken = openBraceToken;
            this.classElements = classElements;
            this.closeBraceToken = closeBraceToken;
        }
        ClassDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitClassDeclaration(this);
        };

        ClassDeclarationSyntax.prototype.kind = function () {
            return 131 /* ClassDeclaration */;
        };

        ClassDeclarationSyntax.prototype.childCount = function () {
            return 8;
        };

        ClassDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.classKeyword;
                case 2:
                    return this.identifier;
                case 3:
                    return this.typeParameterList;
                case 4:
                    return this.heritageClauses;
                case 5:
                    return this.openBraceToken;
                case 6:
                    return this.classElements;
                case 7:
                    return this.closeBraceToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ClassDeclarationSyntax.prototype.isModuleElement = function () {
            return true;
        };

        ClassDeclarationSyntax.prototype.update = function (modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken) {
            if (this.modifiers === modifiers && this.classKeyword === classKeyword && this.identifier === identifier && this.typeParameterList === typeParameterList && this.heritageClauses === heritageClauses && this.openBraceToken === openBraceToken && this.classElements === classElements && this.closeBraceToken === closeBraceToken) {
                return this;
            }

            return new ClassDeclarationSyntax(modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken, this.parsedInStrictMode());
        };

        ClassDeclarationSyntax.create = function (classKeyword, identifier, openBraceToken, closeBraceToken) {
            return new ClassDeclarationSyntax(TypeScript.Syntax.emptyList, classKeyword, identifier, null, TypeScript.Syntax.emptyList, openBraceToken, TypeScript.Syntax.emptyList, closeBraceToken, false);
        };

        ClassDeclarationSyntax.create1 = function (identifier) {
            return new ClassDeclarationSyntax(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(44 /* ClassKeyword */), identifier, null, TypeScript.Syntax.emptyList, TypeScript.Syntax.token(71 /* OpenBraceToken */), TypeScript.Syntax.emptyList, TypeScript.Syntax.token(72 /* CloseBraceToken */), false);
        };

        ClassDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ClassDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ClassDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.classKeyword, this.identifier, this.typeParameterList, this.heritageClauses, this.openBraceToken, this.classElements, this.closeBraceToken);
        };

        ClassDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };

        ClassDeclarationSyntax.prototype.withClassKeyword = function (classKeyword) {
            return this.update(this.modifiers, classKeyword, this.identifier, this.typeParameterList, this.heritageClauses, this.openBraceToken, this.classElements, this.closeBraceToken);
        };

        ClassDeclarationSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.modifiers, this.classKeyword, identifier, this.typeParameterList, this.heritageClauses, this.openBraceToken, this.classElements, this.closeBraceToken);
        };

        ClassDeclarationSyntax.prototype.withTypeParameterList = function (typeParameterList) {
            return this.update(this.modifiers, this.classKeyword, this.identifier, typeParameterList, this.heritageClauses, this.openBraceToken, this.classElements, this.closeBraceToken);
        };

        ClassDeclarationSyntax.prototype.withHeritageClauses = function (heritageClauses) {
            return this.update(this.modifiers, this.classKeyword, this.identifier, this.typeParameterList, heritageClauses, this.openBraceToken, this.classElements, this.closeBraceToken);
        };

        ClassDeclarationSyntax.prototype.withHeritageClause = function (heritageClause) {
            return this.withHeritageClauses(TypeScript.Syntax.list([heritageClause]));
        };

        ClassDeclarationSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
            return this.update(this.modifiers, this.classKeyword, this.identifier, this.typeParameterList, this.heritageClauses, openBraceToken, this.classElements, this.closeBraceToken);
        };

        ClassDeclarationSyntax.prototype.withClassElements = function (classElements) {
            return this.update(this.modifiers, this.classKeyword, this.identifier, this.typeParameterList, this.heritageClauses, this.openBraceToken, classElements, this.closeBraceToken);
        };

        ClassDeclarationSyntax.prototype.withClassElement = function (classElement) {
            return this.withClassElements(TypeScript.Syntax.list([classElement]));
        };

        ClassDeclarationSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
            return this.update(this.modifiers, this.classKeyword, this.identifier, this.typeParameterList, this.heritageClauses, this.openBraceToken, this.classElements, closeBraceToken);
        };

        ClassDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ClassDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ClassDeclarationSyntax = ClassDeclarationSyntax;

    var InterfaceDeclarationSyntax = (function (_super) {
        __extends(InterfaceDeclarationSyntax, _super);
        function InterfaceDeclarationSyntax(modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, body, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.modifiers = modifiers;
            this.interfaceKeyword = interfaceKeyword;
            this.identifier = identifier;
            this.typeParameterList = typeParameterList;
            this.heritageClauses = heritageClauses;
            this.body = body;
        }
        InterfaceDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitInterfaceDeclaration(this);
        };

        InterfaceDeclarationSyntax.prototype.kind = function () {
            return 128 /* InterfaceDeclaration */;
        };

        InterfaceDeclarationSyntax.prototype.childCount = function () {
            return 6;
        };

        InterfaceDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.interfaceKeyword;
                case 2:
                    return this.identifier;
                case 3:
                    return this.typeParameterList;
                case 4:
                    return this.heritageClauses;
                case 5:
                    return this.body;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        InterfaceDeclarationSyntax.prototype.isModuleElement = function () {
            return true;
        };

        InterfaceDeclarationSyntax.prototype.update = function (modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, body) {
            if (this.modifiers === modifiers && this.interfaceKeyword === interfaceKeyword && this.identifier === identifier && this.typeParameterList === typeParameterList && this.heritageClauses === heritageClauses && this.body === body) {
                return this;
            }

            return new InterfaceDeclarationSyntax(modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, body, this.parsedInStrictMode());
        };

        InterfaceDeclarationSyntax.create = function (interfaceKeyword, identifier, body) {
            return new InterfaceDeclarationSyntax(TypeScript.Syntax.emptyList, interfaceKeyword, identifier, null, TypeScript.Syntax.emptyList, body, false);
        };

        InterfaceDeclarationSyntax.create1 = function (identifier) {
            return new InterfaceDeclarationSyntax(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(52 /* InterfaceKeyword */), identifier, null, TypeScript.Syntax.emptyList, ObjectTypeSyntax.create1(), false);
        };

        InterfaceDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        InterfaceDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        InterfaceDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.interfaceKeyword, this.identifier, this.typeParameterList, this.heritageClauses, this.body);
        };

        InterfaceDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };

        InterfaceDeclarationSyntax.prototype.withInterfaceKeyword = function (interfaceKeyword) {
            return this.update(this.modifiers, interfaceKeyword, this.identifier, this.typeParameterList, this.heritageClauses, this.body);
        };

        InterfaceDeclarationSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.modifiers, this.interfaceKeyword, identifier, this.typeParameterList, this.heritageClauses, this.body);
        };

        InterfaceDeclarationSyntax.prototype.withTypeParameterList = function (typeParameterList) {
            return this.update(this.modifiers, this.interfaceKeyword, this.identifier, typeParameterList, this.heritageClauses, this.body);
        };

        InterfaceDeclarationSyntax.prototype.withHeritageClauses = function (heritageClauses) {
            return this.update(this.modifiers, this.interfaceKeyword, this.identifier, this.typeParameterList, heritageClauses, this.body);
        };

        InterfaceDeclarationSyntax.prototype.withHeritageClause = function (heritageClause) {
            return this.withHeritageClauses(TypeScript.Syntax.list([heritageClause]));
        };

        InterfaceDeclarationSyntax.prototype.withBody = function (body) {
            return this.update(this.modifiers, this.interfaceKeyword, this.identifier, this.typeParameterList, this.heritageClauses, body);
        };

        InterfaceDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return InterfaceDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.InterfaceDeclarationSyntax = InterfaceDeclarationSyntax;

    var HeritageClauseSyntax = (function (_super) {
        __extends(HeritageClauseSyntax, _super);
        function HeritageClauseSyntax(extendsOrImplementsKeyword, typeNames, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.extendsOrImplementsKeyword = extendsOrImplementsKeyword;
            this.typeNames = typeNames;
        }
        HeritageClauseSyntax.prototype.accept = function (visitor) {
            return visitor.visitHeritageClause(this);
        };

        HeritageClauseSyntax.prototype.kind = function () {
            return 229 /* HeritageClause */;
        };

        HeritageClauseSyntax.prototype.childCount = function () {
            return 2;
        };

        HeritageClauseSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.extendsOrImplementsKeyword;
                case 1:
                    return this.typeNames;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        HeritageClauseSyntax.prototype.update = function (extendsOrImplementsKeyword, typeNames) {
            if (this.extendsOrImplementsKeyword === extendsOrImplementsKeyword && this.typeNames === typeNames) {
                return this;
            }

            return new HeritageClauseSyntax(extendsOrImplementsKeyword, typeNames, this.parsedInStrictMode());
        };

        HeritageClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        HeritageClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        HeritageClauseSyntax.prototype.withExtendsOrImplementsKeyword = function (extendsOrImplementsKeyword) {
            return this.update(extendsOrImplementsKeyword, this.typeNames);
        };

        HeritageClauseSyntax.prototype.withTypeNames = function (typeNames) {
            return this.update(this.extendsOrImplementsKeyword, typeNames);
        };

        HeritageClauseSyntax.prototype.withTypeName = function (typeName) {
            return this.withTypeNames(TypeScript.Syntax.separatedList([typeName]));
        };

        HeritageClauseSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return HeritageClauseSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.HeritageClauseSyntax = HeritageClauseSyntax;

    var ModuleDeclarationSyntax = (function (_super) {
        __extends(ModuleDeclarationSyntax, _super);
        function ModuleDeclarationSyntax(modifiers, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.modifiers = modifiers;
            this.moduleKeyword = moduleKeyword;
            this.moduleName = moduleName;
            this.stringLiteral = stringLiteral;
            this.openBraceToken = openBraceToken;
            this.moduleElements = moduleElements;
            this.closeBraceToken = closeBraceToken;
        }
        ModuleDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitModuleDeclaration(this);
        };

        ModuleDeclarationSyntax.prototype.kind = function () {
            return 130 /* ModuleDeclaration */;
        };

        ModuleDeclarationSyntax.prototype.childCount = function () {
            return 7;
        };

        ModuleDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.moduleKeyword;
                case 2:
                    return this.moduleName;
                case 3:
                    return this.stringLiteral;
                case 4:
                    return this.openBraceToken;
                case 5:
                    return this.moduleElements;
                case 6:
                    return this.closeBraceToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ModuleDeclarationSyntax.prototype.isModuleElement = function () {
            return true;
        };

        ModuleDeclarationSyntax.prototype.update = function (modifiers, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken) {
            if (this.modifiers === modifiers && this.moduleKeyword === moduleKeyword && this.moduleName === moduleName && this.stringLiteral === stringLiteral && this.openBraceToken === openBraceToken && this.moduleElements === moduleElements && this.closeBraceToken === closeBraceToken) {
                return this;
            }

            return new ModuleDeclarationSyntax(modifiers, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken, this.parsedInStrictMode());
        };

        ModuleDeclarationSyntax.create = function (moduleKeyword, openBraceToken, closeBraceToken) {
            return new ModuleDeclarationSyntax(TypeScript.Syntax.emptyList, moduleKeyword, null, null, openBraceToken, TypeScript.Syntax.emptyList, closeBraceToken, false);
        };

        ModuleDeclarationSyntax.create1 = function () {
            return new ModuleDeclarationSyntax(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(66 /* ModuleKeyword */), null, null, TypeScript.Syntax.token(71 /* OpenBraceToken */), TypeScript.Syntax.emptyList, TypeScript.Syntax.token(72 /* CloseBraceToken */), false);
        };

        ModuleDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ModuleDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ModuleDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.moduleKeyword, this.moduleName, this.stringLiteral, this.openBraceToken, this.moduleElements, this.closeBraceToken);
        };

        ModuleDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };

        ModuleDeclarationSyntax.prototype.withModuleKeyword = function (moduleKeyword) {
            return this.update(this.modifiers, moduleKeyword, this.moduleName, this.stringLiteral, this.openBraceToken, this.moduleElements, this.closeBraceToken);
        };

        ModuleDeclarationSyntax.prototype.withModuleName = function (moduleName) {
            return this.update(this.modifiers, this.moduleKeyword, moduleName, this.stringLiteral, this.openBraceToken, this.moduleElements, this.closeBraceToken);
        };

        ModuleDeclarationSyntax.prototype.withStringLiteral = function (stringLiteral) {
            return this.update(this.modifiers, this.moduleKeyword, this.moduleName, stringLiteral, this.openBraceToken, this.moduleElements, this.closeBraceToken);
        };

        ModuleDeclarationSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
            return this.update(this.modifiers, this.moduleKeyword, this.moduleName, this.stringLiteral, openBraceToken, this.moduleElements, this.closeBraceToken);
        };

        ModuleDeclarationSyntax.prototype.withModuleElements = function (moduleElements) {
            return this.update(this.modifiers, this.moduleKeyword, this.moduleName, this.stringLiteral, this.openBraceToken, moduleElements, this.closeBraceToken);
        };

        ModuleDeclarationSyntax.prototype.withModuleElement = function (moduleElement) {
            return this.withModuleElements(TypeScript.Syntax.list([moduleElement]));
        };

        ModuleDeclarationSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
            return this.update(this.modifiers, this.moduleKeyword, this.moduleName, this.stringLiteral, this.openBraceToken, this.moduleElements, closeBraceToken);
        };

        ModuleDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ModuleDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ModuleDeclarationSyntax = ModuleDeclarationSyntax;

    var FunctionDeclarationSyntax = (function (_super) {
        __extends(FunctionDeclarationSyntax, _super);
        function FunctionDeclarationSyntax(modifiers, functionKeyword, identifier, callSignature, block, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.modifiers = modifiers;
            this.functionKeyword = functionKeyword;
            this.identifier = identifier;
            this.callSignature = callSignature;
            this.block = block;
            this.semicolonToken = semicolonToken;
        }
        FunctionDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitFunctionDeclaration(this);
        };

        FunctionDeclarationSyntax.prototype.kind = function () {
            return 129 /* FunctionDeclaration */;
        };

        FunctionDeclarationSyntax.prototype.childCount = function () {
            return 6;
        };

        FunctionDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.functionKeyword;
                case 2:
                    return this.identifier;
                case 3:
                    return this.callSignature;
                case 4:
                    return this.block;
                case 5:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        FunctionDeclarationSyntax.prototype.isStatement = function () {
            return true;
        };

        FunctionDeclarationSyntax.prototype.isModuleElement = function () {
            return true;
        };

        FunctionDeclarationSyntax.prototype.update = function (modifiers, functionKeyword, identifier, callSignature, block, semicolonToken) {
            if (this.modifiers === modifiers && this.functionKeyword === functionKeyword && this.identifier === identifier && this.callSignature === callSignature && this.block === block && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new FunctionDeclarationSyntax(modifiers, functionKeyword, identifier, callSignature, block, semicolonToken, this.parsedInStrictMode());
        };

        FunctionDeclarationSyntax.create = function (functionKeyword, identifier, callSignature) {
            return new FunctionDeclarationSyntax(TypeScript.Syntax.emptyList, functionKeyword, identifier, callSignature, null, null, false);
        };

        FunctionDeclarationSyntax.create1 = function (identifier) {
            return new FunctionDeclarationSyntax(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(27 /* FunctionKeyword */), identifier, CallSignatureSyntax.create1(), null, null, false);
        };

        FunctionDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        FunctionDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        FunctionDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.functionKeyword, this.identifier, this.callSignature, this.block, this.semicolonToken);
        };

        FunctionDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };

        FunctionDeclarationSyntax.prototype.withFunctionKeyword = function (functionKeyword) {
            return this.update(this.modifiers, functionKeyword, this.identifier, this.callSignature, this.block, this.semicolonToken);
        };

        FunctionDeclarationSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.modifiers, this.functionKeyword, identifier, this.callSignature, this.block, this.semicolonToken);
        };

        FunctionDeclarationSyntax.prototype.withCallSignature = function (callSignature) {
            return this.update(this.modifiers, this.functionKeyword, this.identifier, callSignature, this.block, this.semicolonToken);
        };

        FunctionDeclarationSyntax.prototype.withBlock = function (block) {
            return this.update(this.modifiers, this.functionKeyword, this.identifier, this.callSignature, block, this.semicolonToken);
        };

        FunctionDeclarationSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.modifiers, this.functionKeyword, this.identifier, this.callSignature, this.block, semicolonToken);
        };

        FunctionDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.modifiers.isTypeScriptSpecific()) {
                return true;
            }
            if (this.callSignature.isTypeScriptSpecific()) {
                return true;
            }
            if (this.block !== null && this.block.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return FunctionDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.FunctionDeclarationSyntax = FunctionDeclarationSyntax;

    var VariableStatementSyntax = (function (_super) {
        __extends(VariableStatementSyntax, _super);
        function VariableStatementSyntax(modifiers, variableDeclaration, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.modifiers = modifiers;
            this.variableDeclaration = variableDeclaration;
            this.semicolonToken = semicolonToken;
        }
        VariableStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitVariableStatement(this);
        };

        VariableStatementSyntax.prototype.kind = function () {
            return 147 /* VariableStatement */;
        };

        VariableStatementSyntax.prototype.childCount = function () {
            return 3;
        };

        VariableStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.variableDeclaration;
                case 2:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        VariableStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        VariableStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        VariableStatementSyntax.prototype.update = function (modifiers, variableDeclaration, semicolonToken) {
            if (this.modifiers === modifiers && this.variableDeclaration === variableDeclaration && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new VariableStatementSyntax(modifiers, variableDeclaration, semicolonToken, this.parsedInStrictMode());
        };

        VariableStatementSyntax.create = function (variableDeclaration, semicolonToken) {
            return new VariableStatementSyntax(TypeScript.Syntax.emptyList, variableDeclaration, semicolonToken, false);
        };

        VariableStatementSyntax.create1 = function (variableDeclaration) {
            return new VariableStatementSyntax(TypeScript.Syntax.emptyList, variableDeclaration, TypeScript.Syntax.token(79 /* SemicolonToken */), false);
        };

        VariableStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        VariableStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        VariableStatementSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.variableDeclaration, this.semicolonToken);
        };

        VariableStatementSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };

        VariableStatementSyntax.prototype.withVariableDeclaration = function (variableDeclaration) {
            return this.update(this.modifiers, variableDeclaration, this.semicolonToken);
        };

        VariableStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.modifiers, this.variableDeclaration, semicolonToken);
        };

        VariableStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.modifiers.isTypeScriptSpecific()) {
                return true;
            }
            if (this.variableDeclaration.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return VariableStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.VariableStatementSyntax = VariableStatementSyntax;

    var VariableDeclarationSyntax = (function (_super) {
        __extends(VariableDeclarationSyntax, _super);
        function VariableDeclarationSyntax(varKeyword, variableDeclarators, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.varKeyword = varKeyword;
            this.variableDeclarators = variableDeclarators;
        }
        VariableDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitVariableDeclaration(this);
        };

        VariableDeclarationSyntax.prototype.kind = function () {
            return 223 /* VariableDeclaration */;
        };

        VariableDeclarationSyntax.prototype.childCount = function () {
            return 2;
        };

        VariableDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.varKeyword;
                case 1:
                    return this.variableDeclarators;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        VariableDeclarationSyntax.prototype.update = function (varKeyword, variableDeclarators) {
            if (this.varKeyword === varKeyword && this.variableDeclarators === variableDeclarators) {
                return this;
            }

            return new VariableDeclarationSyntax(varKeyword, variableDeclarators, this.parsedInStrictMode());
        };

        VariableDeclarationSyntax.create1 = function (variableDeclarators) {
            return new VariableDeclarationSyntax(TypeScript.Syntax.token(40 /* VarKeyword */), variableDeclarators, false);
        };

        VariableDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        VariableDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        VariableDeclarationSyntax.prototype.withVarKeyword = function (varKeyword) {
            return this.update(varKeyword, this.variableDeclarators);
        };

        VariableDeclarationSyntax.prototype.withVariableDeclarators = function (variableDeclarators) {
            return this.update(this.varKeyword, variableDeclarators);
        };

        VariableDeclarationSyntax.prototype.withVariableDeclarator = function (variableDeclarator) {
            return this.withVariableDeclarators(TypeScript.Syntax.separatedList([variableDeclarator]));
        };

        VariableDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.variableDeclarators.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return VariableDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.VariableDeclarationSyntax = VariableDeclarationSyntax;

    var VariableDeclaratorSyntax = (function (_super) {
        __extends(VariableDeclaratorSyntax, _super);
        function VariableDeclaratorSyntax(identifier, typeAnnotation, equalsValueClause, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.identifier = identifier;
            this.typeAnnotation = typeAnnotation;
            this.equalsValueClause = equalsValueClause;
        }
        VariableDeclaratorSyntax.prototype.accept = function (visitor) {
            return visitor.visitVariableDeclarator(this);
        };

        VariableDeclaratorSyntax.prototype.kind = function () {
            return 224 /* VariableDeclarator */;
        };

        VariableDeclaratorSyntax.prototype.childCount = function () {
            return 3;
        };

        VariableDeclaratorSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.identifier;
                case 1:
                    return this.typeAnnotation;
                case 2:
                    return this.equalsValueClause;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        VariableDeclaratorSyntax.prototype.update = function (identifier, typeAnnotation, equalsValueClause) {
            if (this.identifier === identifier && this.typeAnnotation === typeAnnotation && this.equalsValueClause === equalsValueClause) {
                return this;
            }

            return new VariableDeclaratorSyntax(identifier, typeAnnotation, equalsValueClause, this.parsedInStrictMode());
        };

        VariableDeclaratorSyntax.create = function (identifier) {
            return new VariableDeclaratorSyntax(identifier, null, null, false);
        };

        VariableDeclaratorSyntax.create1 = function (identifier) {
            return new VariableDeclaratorSyntax(identifier, null, null, false);
        };

        VariableDeclaratorSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        VariableDeclaratorSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        VariableDeclaratorSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(identifier, this.typeAnnotation, this.equalsValueClause);
        };

        VariableDeclaratorSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
            return this.update(this.identifier, typeAnnotation, this.equalsValueClause);
        };

        VariableDeclaratorSyntax.prototype.withEqualsValueClause = function (equalsValueClause) {
            return this.update(this.identifier, this.typeAnnotation, equalsValueClause);
        };

        VariableDeclaratorSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.typeAnnotation !== null) {
                return true;
            }
            if (this.equalsValueClause !== null && this.equalsValueClause.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return VariableDeclaratorSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.VariableDeclaratorSyntax = VariableDeclaratorSyntax;

    var EqualsValueClauseSyntax = (function (_super) {
        __extends(EqualsValueClauseSyntax, _super);
        function EqualsValueClauseSyntax(equalsToken, value, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.equalsToken = equalsToken;
            this.value = value;
        }
        EqualsValueClauseSyntax.prototype.accept = function (visitor) {
            return visitor.visitEqualsValueClause(this);
        };

        EqualsValueClauseSyntax.prototype.kind = function () {
            return 230 /* EqualsValueClause */;
        };

        EqualsValueClauseSyntax.prototype.childCount = function () {
            return 2;
        };

        EqualsValueClauseSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.equalsToken;
                case 1:
                    return this.value;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        EqualsValueClauseSyntax.prototype.update = function (equalsToken, value) {
            if (this.equalsToken === equalsToken && this.value === value) {
                return this;
            }

            return new EqualsValueClauseSyntax(equalsToken, value, this.parsedInStrictMode());
        };

        EqualsValueClauseSyntax.create1 = function (value) {
            return new EqualsValueClauseSyntax(TypeScript.Syntax.token(108 /* EqualsToken */), value, false);
        };

        EqualsValueClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        EqualsValueClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        EqualsValueClauseSyntax.prototype.withEqualsToken = function (equalsToken) {
            return this.update(equalsToken, this.value);
        };

        EqualsValueClauseSyntax.prototype.withValue = function (value) {
            return this.update(this.equalsToken, value);
        };

        EqualsValueClauseSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.value.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return EqualsValueClauseSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.EqualsValueClauseSyntax = EqualsValueClauseSyntax;

    var PrefixUnaryExpressionSyntax = (function (_super) {
        __extends(PrefixUnaryExpressionSyntax, _super);
        function PrefixUnaryExpressionSyntax(kind, operatorToken, operand, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.operatorToken = operatorToken;
            this.operand = operand;

            this._kind = kind;
        }
        PrefixUnaryExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitPrefixUnaryExpression(this);
        };

        PrefixUnaryExpressionSyntax.prototype.childCount = function () {
            return 2;
        };

        PrefixUnaryExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.operatorToken;
                case 1:
                    return this.operand;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        PrefixUnaryExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        PrefixUnaryExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        PrefixUnaryExpressionSyntax.prototype.kind = function () {
            return this._kind;
        };

        PrefixUnaryExpressionSyntax.prototype.update = function (kind, operatorToken, operand) {
            if (this._kind === kind && this.operatorToken === operatorToken && this.operand === operand) {
                return this;
            }

            return new PrefixUnaryExpressionSyntax(kind, operatorToken, operand, this.parsedInStrictMode());
        };

        PrefixUnaryExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        PrefixUnaryExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        PrefixUnaryExpressionSyntax.prototype.withKind = function (kind) {
            return this.update(kind, this.operatorToken, this.operand);
        };

        PrefixUnaryExpressionSyntax.prototype.withOperatorToken = function (operatorToken) {
            return this.update(this._kind, operatorToken, this.operand);
        };

        PrefixUnaryExpressionSyntax.prototype.withOperand = function (operand) {
            return this.update(this._kind, this.operatorToken, operand);
        };

        PrefixUnaryExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.operand.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return PrefixUnaryExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.PrefixUnaryExpressionSyntax = PrefixUnaryExpressionSyntax;

    var ArrayLiteralExpressionSyntax = (function (_super) {
        __extends(ArrayLiteralExpressionSyntax, _super);
        function ArrayLiteralExpressionSyntax(openBracketToken, expressions, closeBracketToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.openBracketToken = openBracketToken;
            this.expressions = expressions;
            this.closeBracketToken = closeBracketToken;
        }
        ArrayLiteralExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitArrayLiteralExpression(this);
        };

        ArrayLiteralExpressionSyntax.prototype.kind = function () {
            return 213 /* ArrayLiteralExpression */;
        };

        ArrayLiteralExpressionSyntax.prototype.childCount = function () {
            return 3;
        };

        ArrayLiteralExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.openBracketToken;
                case 1:
                    return this.expressions;
                case 2:
                    return this.closeBracketToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ArrayLiteralExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        ArrayLiteralExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        ArrayLiteralExpressionSyntax.prototype.update = function (openBracketToken, expressions, closeBracketToken) {
            if (this.openBracketToken === openBracketToken && this.expressions === expressions && this.closeBracketToken === closeBracketToken) {
                return this;
            }

            return new ArrayLiteralExpressionSyntax(openBracketToken, expressions, closeBracketToken, this.parsedInStrictMode());
        };

        ArrayLiteralExpressionSyntax.create = function (openBracketToken, closeBracketToken) {
            return new ArrayLiteralExpressionSyntax(openBracketToken, TypeScript.Syntax.emptySeparatedList, closeBracketToken, false);
        };

        ArrayLiteralExpressionSyntax.create1 = function () {
            return new ArrayLiteralExpressionSyntax(TypeScript.Syntax.token(75 /* OpenBracketToken */), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.token(76 /* CloseBracketToken */), false);
        };

        ArrayLiteralExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ArrayLiteralExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ArrayLiteralExpressionSyntax.prototype.withOpenBracketToken = function (openBracketToken) {
            return this.update(openBracketToken, this.expressions, this.closeBracketToken);
        };

        ArrayLiteralExpressionSyntax.prototype.withExpressions = function (expressions) {
            return this.update(this.openBracketToken, expressions, this.closeBracketToken);
        };

        ArrayLiteralExpressionSyntax.prototype.withExpression = function (expression) {
            return this.withExpressions(TypeScript.Syntax.separatedList([expression]));
        };

        ArrayLiteralExpressionSyntax.prototype.withCloseBracketToken = function (closeBracketToken) {
            return this.update(this.openBracketToken, this.expressions, closeBracketToken);
        };

        ArrayLiteralExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expressions.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ArrayLiteralExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ArrayLiteralExpressionSyntax = ArrayLiteralExpressionSyntax;

    var OmittedExpressionSyntax = (function (_super) {
        __extends(OmittedExpressionSyntax, _super);
        function OmittedExpressionSyntax(parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
        }
        OmittedExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitOmittedExpression(this);
        };

        OmittedExpressionSyntax.prototype.kind = function () {
            return 222 /* OmittedExpression */;
        };

        OmittedExpressionSyntax.prototype.childCount = function () {
            return 0;
        };

        OmittedExpressionSyntax.prototype.childAt = function (slot) {
            throw TypeScript.Errors.invalidOperation();
        };

        OmittedExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        OmittedExpressionSyntax.prototype.update = function () {
            return this;
        };

        OmittedExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        OmittedExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        OmittedExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return OmittedExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.OmittedExpressionSyntax = OmittedExpressionSyntax;

    var ParenthesizedExpressionSyntax = (function (_super) {
        __extends(ParenthesizedExpressionSyntax, _super);
        function ParenthesizedExpressionSyntax(openParenToken, expression, closeParenToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.openParenToken = openParenToken;
            this.expression = expression;
            this.closeParenToken = closeParenToken;
        }
        ParenthesizedExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitParenthesizedExpression(this);
        };

        ParenthesizedExpressionSyntax.prototype.kind = function () {
            return 216 /* ParenthesizedExpression */;
        };

        ParenthesizedExpressionSyntax.prototype.childCount = function () {
            return 3;
        };

        ParenthesizedExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.openParenToken;
                case 1:
                    return this.expression;
                case 2:
                    return this.closeParenToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ParenthesizedExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        ParenthesizedExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        ParenthesizedExpressionSyntax.prototype.update = function (openParenToken, expression, closeParenToken) {
            if (this.openParenToken === openParenToken && this.expression === expression && this.closeParenToken === closeParenToken) {
                return this;
            }

            return new ParenthesizedExpressionSyntax(openParenToken, expression, closeParenToken, this.parsedInStrictMode());
        };

        ParenthesizedExpressionSyntax.create1 = function (expression) {
            return new ParenthesizedExpressionSyntax(TypeScript.Syntax.token(73 /* OpenParenToken */), expression, TypeScript.Syntax.token(74 /* CloseParenToken */), false);
        };

        ParenthesizedExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ParenthesizedExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ParenthesizedExpressionSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(openParenToken, this.expression, this.closeParenToken);
        };

        ParenthesizedExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(this.openParenToken, expression, this.closeParenToken);
        };

        ParenthesizedExpressionSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.openParenToken, this.expression, closeParenToken);
        };

        ParenthesizedExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ParenthesizedExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ParenthesizedExpressionSyntax = ParenthesizedExpressionSyntax;

    var ArrowFunctionExpressionSyntax = (function (_super) {
        __extends(ArrowFunctionExpressionSyntax, _super);
        function ArrowFunctionExpressionSyntax(equalsGreaterThanToken, body, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.equalsGreaterThanToken = equalsGreaterThanToken;
            this.body = body;
        }
        ArrowFunctionExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        ArrowFunctionExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        ArrowFunctionExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ArrowFunctionExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ArrowFunctionExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ArrowFunctionExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ArrowFunctionExpressionSyntax = ArrowFunctionExpressionSyntax;

    var SimpleArrowFunctionExpressionSyntax = (function (_super) {
        __extends(SimpleArrowFunctionExpressionSyntax, _super);
        function SimpleArrowFunctionExpressionSyntax(identifier, equalsGreaterThanToken, body, parsedInStrictMode) {
            _super.call(this, equalsGreaterThanToken, body, parsedInStrictMode);
            this.identifier = identifier;
        }
        SimpleArrowFunctionExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitSimpleArrowFunctionExpression(this);
        };

        SimpleArrowFunctionExpressionSyntax.prototype.kind = function () {
            return 218 /* SimpleArrowFunctionExpression */;
        };

        SimpleArrowFunctionExpressionSyntax.prototype.childCount = function () {
            return 3;
        };

        SimpleArrowFunctionExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.identifier;
                case 1:
                    return this.equalsGreaterThanToken;
                case 2:
                    return this.body;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        SimpleArrowFunctionExpressionSyntax.prototype.update = function (identifier, equalsGreaterThanToken, body) {
            if (this.identifier === identifier && this.equalsGreaterThanToken === equalsGreaterThanToken && this.body === body) {
                return this;
            }

            return new SimpleArrowFunctionExpressionSyntax(identifier, equalsGreaterThanToken, body, this.parsedInStrictMode());
        };

        SimpleArrowFunctionExpressionSyntax.create1 = function (identifier, body) {
            return new SimpleArrowFunctionExpressionSyntax(identifier, TypeScript.Syntax.token(86 /* EqualsGreaterThanToken */), body, false);
        };

        SimpleArrowFunctionExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        SimpleArrowFunctionExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        SimpleArrowFunctionExpressionSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(identifier, this.equalsGreaterThanToken, this.body);
        };

        SimpleArrowFunctionExpressionSyntax.prototype.withEqualsGreaterThanToken = function (equalsGreaterThanToken) {
            return this.update(this.identifier, equalsGreaterThanToken, this.body);
        };

        SimpleArrowFunctionExpressionSyntax.prototype.withBody = function (body) {
            return this.update(this.identifier, this.equalsGreaterThanToken, body);
        };

        SimpleArrowFunctionExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return SimpleArrowFunctionExpressionSyntax;
    })(ArrowFunctionExpressionSyntax);
    TypeScript.SimpleArrowFunctionExpressionSyntax = SimpleArrowFunctionExpressionSyntax;

    var ParenthesizedArrowFunctionExpressionSyntax = (function (_super) {
        __extends(ParenthesizedArrowFunctionExpressionSyntax, _super);
        function ParenthesizedArrowFunctionExpressionSyntax(callSignature, equalsGreaterThanToken, body, parsedInStrictMode) {
            _super.call(this, equalsGreaterThanToken, body, parsedInStrictMode);
            this.callSignature = callSignature;
        }
        ParenthesizedArrowFunctionExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitParenthesizedArrowFunctionExpression(this);
        };

        ParenthesizedArrowFunctionExpressionSyntax.prototype.kind = function () {
            return 217 /* ParenthesizedArrowFunctionExpression */;
        };

        ParenthesizedArrowFunctionExpressionSyntax.prototype.childCount = function () {
            return 3;
        };

        ParenthesizedArrowFunctionExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.callSignature;
                case 1:
                    return this.equalsGreaterThanToken;
                case 2:
                    return this.body;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ParenthesizedArrowFunctionExpressionSyntax.prototype.update = function (callSignature, equalsGreaterThanToken, body) {
            if (this.callSignature === callSignature && this.equalsGreaterThanToken === equalsGreaterThanToken && this.body === body) {
                return this;
            }

            return new ParenthesizedArrowFunctionExpressionSyntax(callSignature, equalsGreaterThanToken, body, this.parsedInStrictMode());
        };

        ParenthesizedArrowFunctionExpressionSyntax.create1 = function (body) {
            return new ParenthesizedArrowFunctionExpressionSyntax(CallSignatureSyntax.create1(), TypeScript.Syntax.token(86 /* EqualsGreaterThanToken */), body, false);
        };

        ParenthesizedArrowFunctionExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ParenthesizedArrowFunctionExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ParenthesizedArrowFunctionExpressionSyntax.prototype.withCallSignature = function (callSignature) {
            return this.update(callSignature, this.equalsGreaterThanToken, this.body);
        };

        ParenthesizedArrowFunctionExpressionSyntax.prototype.withEqualsGreaterThanToken = function (equalsGreaterThanToken) {
            return this.update(this.callSignature, equalsGreaterThanToken, this.body);
        };

        ParenthesizedArrowFunctionExpressionSyntax.prototype.withBody = function (body) {
            return this.update(this.callSignature, this.equalsGreaterThanToken, body);
        };

        ParenthesizedArrowFunctionExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ParenthesizedArrowFunctionExpressionSyntax;
    })(ArrowFunctionExpressionSyntax);
    TypeScript.ParenthesizedArrowFunctionExpressionSyntax = ParenthesizedArrowFunctionExpressionSyntax;

    var QualifiedNameSyntax = (function (_super) {
        __extends(QualifiedNameSyntax, _super);
        function QualifiedNameSyntax(left, dotToken, right, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.left = left;
            this.dotToken = dotToken;
            this.right = right;
        }
        QualifiedNameSyntax.prototype.accept = function (visitor) {
            return visitor.visitQualifiedName(this);
        };

        QualifiedNameSyntax.prototype.kind = function () {
            return 122 /* QualifiedName */;
        };

        QualifiedNameSyntax.prototype.childCount = function () {
            return 3;
        };

        QualifiedNameSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.left;
                case 1:
                    return this.dotToken;
                case 2:
                    return this.right;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        QualifiedNameSyntax.prototype.isName = function () {
            return true;
        };

        QualifiedNameSyntax.prototype.isType = function () {
            return true;
        };

        QualifiedNameSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        QualifiedNameSyntax.prototype.isExpression = function () {
            return true;
        };

        QualifiedNameSyntax.prototype.update = function (left, dotToken, right) {
            if (this.left === left && this.dotToken === dotToken && this.right === right) {
                return this;
            }

            return new QualifiedNameSyntax(left, dotToken, right, this.parsedInStrictMode());
        };

        QualifiedNameSyntax.create1 = function (left, right) {
            return new QualifiedNameSyntax(left, TypeScript.Syntax.token(77 /* DotToken */), right, false);
        };

        QualifiedNameSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        QualifiedNameSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        QualifiedNameSyntax.prototype.withLeft = function (left) {
            return this.update(left, this.dotToken, this.right);
        };

        QualifiedNameSyntax.prototype.withDotToken = function (dotToken) {
            return this.update(this.left, dotToken, this.right);
        };

        QualifiedNameSyntax.prototype.withRight = function (right) {
            return this.update(this.left, this.dotToken, right);
        };

        QualifiedNameSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return QualifiedNameSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.QualifiedNameSyntax = QualifiedNameSyntax;

    var TypeArgumentListSyntax = (function (_super) {
        __extends(TypeArgumentListSyntax, _super);
        function TypeArgumentListSyntax(lessThanToken, typeArguments, greaterThanToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.lessThanToken = lessThanToken;
            this.typeArguments = typeArguments;
            this.greaterThanToken = greaterThanToken;
        }
        TypeArgumentListSyntax.prototype.accept = function (visitor) {
            return visitor.visitTypeArgumentList(this);
        };

        TypeArgumentListSyntax.prototype.kind = function () {
            return 227 /* TypeArgumentList */;
        };

        TypeArgumentListSyntax.prototype.childCount = function () {
            return 3;
        };

        TypeArgumentListSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.lessThanToken;
                case 1:
                    return this.typeArguments;
                case 2:
                    return this.greaterThanToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        TypeArgumentListSyntax.prototype.update = function (lessThanToken, typeArguments, greaterThanToken) {
            if (this.lessThanToken === lessThanToken && this.typeArguments === typeArguments && this.greaterThanToken === greaterThanToken) {
                return this;
            }

            return new TypeArgumentListSyntax(lessThanToken, typeArguments, greaterThanToken, this.parsedInStrictMode());
        };

        TypeArgumentListSyntax.create = function (lessThanToken, greaterThanToken) {
            return new TypeArgumentListSyntax(lessThanToken, TypeScript.Syntax.emptySeparatedList, greaterThanToken, false);
        };

        TypeArgumentListSyntax.create1 = function () {
            return new TypeArgumentListSyntax(TypeScript.Syntax.token(81 /* LessThanToken */), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.token(82 /* GreaterThanToken */), false);
        };

        TypeArgumentListSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        TypeArgumentListSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        TypeArgumentListSyntax.prototype.withLessThanToken = function (lessThanToken) {
            return this.update(lessThanToken, this.typeArguments, this.greaterThanToken);
        };

        TypeArgumentListSyntax.prototype.withTypeArguments = function (typeArguments) {
            return this.update(this.lessThanToken, typeArguments, this.greaterThanToken);
        };

        TypeArgumentListSyntax.prototype.withTypeArgument = function (typeArgument) {
            return this.withTypeArguments(TypeScript.Syntax.separatedList([typeArgument]));
        };

        TypeArgumentListSyntax.prototype.withGreaterThanToken = function (greaterThanToken) {
            return this.update(this.lessThanToken, this.typeArguments, greaterThanToken);
        };

        TypeArgumentListSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return TypeArgumentListSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.TypeArgumentListSyntax = TypeArgumentListSyntax;

    var ConstructorTypeSyntax = (function (_super) {
        __extends(ConstructorTypeSyntax, _super);
        function ConstructorTypeSyntax(newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.newKeyword = newKeyword;
            this.typeParameterList = typeParameterList;
            this.parameterList = parameterList;
            this.equalsGreaterThanToken = equalsGreaterThanToken;
            this.type = type;
        }
        ConstructorTypeSyntax.prototype.accept = function (visitor) {
            return visitor.visitConstructorType(this);
        };

        ConstructorTypeSyntax.prototype.kind = function () {
            return 126 /* ConstructorType */;
        };

        ConstructorTypeSyntax.prototype.childCount = function () {
            return 5;
        };

        ConstructorTypeSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.newKeyword;
                case 1:
                    return this.typeParameterList;
                case 2:
                    return this.parameterList;
                case 3:
                    return this.equalsGreaterThanToken;
                case 4:
                    return this.type;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ConstructorTypeSyntax.prototype.isType = function () {
            return true;
        };

        ConstructorTypeSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        ConstructorTypeSyntax.prototype.isExpression = function () {
            return true;
        };

        ConstructorTypeSyntax.prototype.update = function (newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type) {
            if (this.newKeyword === newKeyword && this.typeParameterList === typeParameterList && this.parameterList === parameterList && this.equalsGreaterThanToken === equalsGreaterThanToken && this.type === type) {
                return this;
            }

            return new ConstructorTypeSyntax(newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type, this.parsedInStrictMode());
        };

        ConstructorTypeSyntax.create = function (newKeyword, parameterList, equalsGreaterThanToken, type) {
            return new ConstructorTypeSyntax(newKeyword, null, parameterList, equalsGreaterThanToken, type, false);
        };

        ConstructorTypeSyntax.create1 = function (type) {
            return new ConstructorTypeSyntax(TypeScript.Syntax.token(31 /* NewKeyword */), null, ParameterListSyntax.create1(), TypeScript.Syntax.token(86 /* EqualsGreaterThanToken */), type, false);
        };

        ConstructorTypeSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ConstructorTypeSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ConstructorTypeSyntax.prototype.withNewKeyword = function (newKeyword) {
            return this.update(newKeyword, this.typeParameterList, this.parameterList, this.equalsGreaterThanToken, this.type);
        };

        ConstructorTypeSyntax.prototype.withTypeParameterList = function (typeParameterList) {
            return this.update(this.newKeyword, typeParameterList, this.parameterList, this.equalsGreaterThanToken, this.type);
        };

        ConstructorTypeSyntax.prototype.withParameterList = function (parameterList) {
            return this.update(this.newKeyword, this.typeParameterList, parameterList, this.equalsGreaterThanToken, this.type);
        };

        ConstructorTypeSyntax.prototype.withEqualsGreaterThanToken = function (equalsGreaterThanToken) {
            return this.update(this.newKeyword, this.typeParameterList, this.parameterList, equalsGreaterThanToken, this.type);
        };

        ConstructorTypeSyntax.prototype.withType = function (type) {
            return this.update(this.newKeyword, this.typeParameterList, this.parameterList, this.equalsGreaterThanToken, type);
        };

        ConstructorTypeSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ConstructorTypeSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ConstructorTypeSyntax = ConstructorTypeSyntax;

    var FunctionTypeSyntax = (function (_super) {
        __extends(FunctionTypeSyntax, _super);
        function FunctionTypeSyntax(typeParameterList, parameterList, equalsGreaterThanToken, type, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.typeParameterList = typeParameterList;
            this.parameterList = parameterList;
            this.equalsGreaterThanToken = equalsGreaterThanToken;
            this.type = type;
        }
        FunctionTypeSyntax.prototype.accept = function (visitor) {
            return visitor.visitFunctionType(this);
        };

        FunctionTypeSyntax.prototype.kind = function () {
            return 124 /* FunctionType */;
        };

        FunctionTypeSyntax.prototype.childCount = function () {
            return 4;
        };

        FunctionTypeSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.typeParameterList;
                case 1:
                    return this.parameterList;
                case 2:
                    return this.equalsGreaterThanToken;
                case 3:
                    return this.type;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        FunctionTypeSyntax.prototype.isType = function () {
            return true;
        };

        FunctionTypeSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        FunctionTypeSyntax.prototype.isExpression = function () {
            return true;
        };

        FunctionTypeSyntax.prototype.update = function (typeParameterList, parameterList, equalsGreaterThanToken, type) {
            if (this.typeParameterList === typeParameterList && this.parameterList === parameterList && this.equalsGreaterThanToken === equalsGreaterThanToken && this.type === type) {
                return this;
            }

            return new FunctionTypeSyntax(typeParameterList, parameterList, equalsGreaterThanToken, type, this.parsedInStrictMode());
        };

        FunctionTypeSyntax.create = function (parameterList, equalsGreaterThanToken, type) {
            return new FunctionTypeSyntax(null, parameterList, equalsGreaterThanToken, type, false);
        };

        FunctionTypeSyntax.create1 = function (type) {
            return new FunctionTypeSyntax(null, ParameterListSyntax.create1(), TypeScript.Syntax.token(86 /* EqualsGreaterThanToken */), type, false);
        };

        FunctionTypeSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        FunctionTypeSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        FunctionTypeSyntax.prototype.withTypeParameterList = function (typeParameterList) {
            return this.update(typeParameterList, this.parameterList, this.equalsGreaterThanToken, this.type);
        };

        FunctionTypeSyntax.prototype.withParameterList = function (parameterList) {
            return this.update(this.typeParameterList, parameterList, this.equalsGreaterThanToken, this.type);
        };

        FunctionTypeSyntax.prototype.withEqualsGreaterThanToken = function (equalsGreaterThanToken) {
            return this.update(this.typeParameterList, this.parameterList, equalsGreaterThanToken, this.type);
        };

        FunctionTypeSyntax.prototype.withType = function (type) {
            return this.update(this.typeParameterList, this.parameterList, this.equalsGreaterThanToken, type);
        };

        FunctionTypeSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return FunctionTypeSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.FunctionTypeSyntax = FunctionTypeSyntax;

    var ObjectTypeSyntax = (function (_super) {
        __extends(ObjectTypeSyntax, _super);
        function ObjectTypeSyntax(openBraceToken, typeMembers, closeBraceToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.openBraceToken = openBraceToken;
            this.typeMembers = typeMembers;
            this.closeBraceToken = closeBraceToken;
        }
        ObjectTypeSyntax.prototype.accept = function (visitor) {
            return visitor.visitObjectType(this);
        };

        ObjectTypeSyntax.prototype.kind = function () {
            return 123 /* ObjectType */;
        };

        ObjectTypeSyntax.prototype.childCount = function () {
            return 3;
        };

        ObjectTypeSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.openBraceToken;
                case 1:
                    return this.typeMembers;
                case 2:
                    return this.closeBraceToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ObjectTypeSyntax.prototype.isType = function () {
            return true;
        };

        ObjectTypeSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        ObjectTypeSyntax.prototype.isExpression = function () {
            return true;
        };

        ObjectTypeSyntax.prototype.update = function (openBraceToken, typeMembers, closeBraceToken) {
            if (this.openBraceToken === openBraceToken && this.typeMembers === typeMembers && this.closeBraceToken === closeBraceToken) {
                return this;
            }

            return new ObjectTypeSyntax(openBraceToken, typeMembers, closeBraceToken, this.parsedInStrictMode());
        };

        ObjectTypeSyntax.create = function (openBraceToken, closeBraceToken) {
            return new ObjectTypeSyntax(openBraceToken, TypeScript.Syntax.emptySeparatedList, closeBraceToken, false);
        };

        ObjectTypeSyntax.create1 = function () {
            return new ObjectTypeSyntax(TypeScript.Syntax.token(71 /* OpenBraceToken */), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.token(72 /* CloseBraceToken */), false);
        };

        ObjectTypeSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ObjectTypeSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ObjectTypeSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
            return this.update(openBraceToken, this.typeMembers, this.closeBraceToken);
        };

        ObjectTypeSyntax.prototype.withTypeMembers = function (typeMembers) {
            return this.update(this.openBraceToken, typeMembers, this.closeBraceToken);
        };

        ObjectTypeSyntax.prototype.withTypeMember = function (typeMember) {
            return this.withTypeMembers(TypeScript.Syntax.separatedList([typeMember]));
        };

        ObjectTypeSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
            return this.update(this.openBraceToken, this.typeMembers, closeBraceToken);
        };

        ObjectTypeSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ObjectTypeSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ObjectTypeSyntax = ObjectTypeSyntax;

    var ArrayTypeSyntax = (function (_super) {
        __extends(ArrayTypeSyntax, _super);
        function ArrayTypeSyntax(type, openBracketToken, closeBracketToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.type = type;
            this.openBracketToken = openBracketToken;
            this.closeBracketToken = closeBracketToken;
        }
        ArrayTypeSyntax.prototype.accept = function (visitor) {
            return visitor.visitArrayType(this);
        };

        ArrayTypeSyntax.prototype.kind = function () {
            return 125 /* ArrayType */;
        };

        ArrayTypeSyntax.prototype.childCount = function () {
            return 3;
        };

        ArrayTypeSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.type;
                case 1:
                    return this.openBracketToken;
                case 2:
                    return this.closeBracketToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ArrayTypeSyntax.prototype.isType = function () {
            return true;
        };

        ArrayTypeSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        ArrayTypeSyntax.prototype.isExpression = function () {
            return true;
        };

        ArrayTypeSyntax.prototype.update = function (type, openBracketToken, closeBracketToken) {
            if (this.type === type && this.openBracketToken === openBracketToken && this.closeBracketToken === closeBracketToken) {
                return this;
            }

            return new ArrayTypeSyntax(type, openBracketToken, closeBracketToken, this.parsedInStrictMode());
        };

        ArrayTypeSyntax.create1 = function (type) {
            return new ArrayTypeSyntax(type, TypeScript.Syntax.token(75 /* OpenBracketToken */), TypeScript.Syntax.token(76 /* CloseBracketToken */), false);
        };

        ArrayTypeSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ArrayTypeSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ArrayTypeSyntax.prototype.withType = function (type) {
            return this.update(type, this.openBracketToken, this.closeBracketToken);
        };

        ArrayTypeSyntax.prototype.withOpenBracketToken = function (openBracketToken) {
            return this.update(this.type, openBracketToken, this.closeBracketToken);
        };

        ArrayTypeSyntax.prototype.withCloseBracketToken = function (closeBracketToken) {
            return this.update(this.type, this.openBracketToken, closeBracketToken);
        };

        ArrayTypeSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ArrayTypeSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ArrayTypeSyntax = ArrayTypeSyntax;

    var GenericTypeSyntax = (function (_super) {
        __extends(GenericTypeSyntax, _super);
        function GenericTypeSyntax(name, typeArgumentList, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.name = name;
            this.typeArgumentList = typeArgumentList;
        }
        GenericTypeSyntax.prototype.accept = function (visitor) {
            return visitor.visitGenericType(this);
        };

        GenericTypeSyntax.prototype.kind = function () {
            return 127 /* GenericType */;
        };

        GenericTypeSyntax.prototype.childCount = function () {
            return 2;
        };

        GenericTypeSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.name;
                case 1:
                    return this.typeArgumentList;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        GenericTypeSyntax.prototype.isType = function () {
            return true;
        };

        GenericTypeSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        GenericTypeSyntax.prototype.isExpression = function () {
            return true;
        };

        GenericTypeSyntax.prototype.update = function (name, typeArgumentList) {
            if (this.name === name && this.typeArgumentList === typeArgumentList) {
                return this;
            }

            return new GenericTypeSyntax(name, typeArgumentList, this.parsedInStrictMode());
        };

        GenericTypeSyntax.create1 = function (name) {
            return new GenericTypeSyntax(name, TypeArgumentListSyntax.create1(), false);
        };

        GenericTypeSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        GenericTypeSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        GenericTypeSyntax.prototype.withName = function (name) {
            return this.update(name, this.typeArgumentList);
        };

        GenericTypeSyntax.prototype.withTypeArgumentList = function (typeArgumentList) {
            return this.update(this.name, typeArgumentList);
        };

        GenericTypeSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return GenericTypeSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.GenericTypeSyntax = GenericTypeSyntax;

    var TypeAnnotationSyntax = (function (_super) {
        __extends(TypeAnnotationSyntax, _super);
        function TypeAnnotationSyntax(colonToken, type, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.colonToken = colonToken;
            this.type = type;
        }
        TypeAnnotationSyntax.prototype.accept = function (visitor) {
            return visitor.visitTypeAnnotation(this);
        };

        TypeAnnotationSyntax.prototype.kind = function () {
            return 244 /* TypeAnnotation */;
        };

        TypeAnnotationSyntax.prototype.childCount = function () {
            return 2;
        };

        TypeAnnotationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.colonToken;
                case 1:
                    return this.type;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        TypeAnnotationSyntax.prototype.update = function (colonToken, type) {
            if (this.colonToken === colonToken && this.type === type) {
                return this;
            }

            return new TypeAnnotationSyntax(colonToken, type, this.parsedInStrictMode());
        };

        TypeAnnotationSyntax.create1 = function (type) {
            return new TypeAnnotationSyntax(TypeScript.Syntax.token(107 /* ColonToken */), type, false);
        };

        TypeAnnotationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        TypeAnnotationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        TypeAnnotationSyntax.prototype.withColonToken = function (colonToken) {
            return this.update(colonToken, this.type);
        };

        TypeAnnotationSyntax.prototype.withType = function (type) {
            return this.update(this.colonToken, type);
        };

        TypeAnnotationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return TypeAnnotationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.TypeAnnotationSyntax = TypeAnnotationSyntax;

    var BlockSyntax = (function (_super) {
        __extends(BlockSyntax, _super);
        function BlockSyntax(openBraceToken, statements, closeBraceToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.openBraceToken = openBraceToken;
            this.statements = statements;
            this.closeBraceToken = closeBraceToken;
        }
        BlockSyntax.prototype.accept = function (visitor) {
            return visitor.visitBlock(this);
        };

        BlockSyntax.prototype.kind = function () {
            return 145 /* Block */;
        };

        BlockSyntax.prototype.childCount = function () {
            return 3;
        };

        BlockSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.openBraceToken;
                case 1:
                    return this.statements;
                case 2:
                    return this.closeBraceToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        BlockSyntax.prototype.isStatement = function () {
            return true;
        };

        BlockSyntax.prototype.isModuleElement = function () {
            return true;
        };

        BlockSyntax.prototype.update = function (openBraceToken, statements, closeBraceToken) {
            if (this.openBraceToken === openBraceToken && this.statements === statements && this.closeBraceToken === closeBraceToken) {
                return this;
            }

            return new BlockSyntax(openBraceToken, statements, closeBraceToken, this.parsedInStrictMode());
        };

        BlockSyntax.create = function (openBraceToken, closeBraceToken) {
            return new BlockSyntax(openBraceToken, TypeScript.Syntax.emptyList, closeBraceToken, false);
        };

        BlockSyntax.create1 = function () {
            return new BlockSyntax(TypeScript.Syntax.token(71 /* OpenBraceToken */), TypeScript.Syntax.emptyList, TypeScript.Syntax.token(72 /* CloseBraceToken */), false);
        };

        BlockSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        BlockSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        BlockSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
            return this.update(openBraceToken, this.statements, this.closeBraceToken);
        };

        BlockSyntax.prototype.withStatements = function (statements) {
            return this.update(this.openBraceToken, statements, this.closeBraceToken);
        };

        BlockSyntax.prototype.withStatement = function (statement) {
            return this.withStatements(TypeScript.Syntax.list([statement]));
        };

        BlockSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
            return this.update(this.openBraceToken, this.statements, closeBraceToken);
        };

        BlockSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.statements.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return BlockSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.BlockSyntax = BlockSyntax;

    var ParameterSyntax = (function (_super) {
        __extends(ParameterSyntax, _super);
        function ParameterSyntax(dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.dotDotDotToken = dotDotDotToken;
            this.publicOrPrivateKeyword = publicOrPrivateKeyword;
            this.identifier = identifier;
            this.questionToken = questionToken;
            this.typeAnnotation = typeAnnotation;
            this.equalsValueClause = equalsValueClause;
        }
        ParameterSyntax.prototype.accept = function (visitor) {
            return visitor.visitParameter(this);
        };

        ParameterSyntax.prototype.kind = function () {
            return 242 /* Parameter */;
        };

        ParameterSyntax.prototype.childCount = function () {
            return 6;
        };

        ParameterSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.dotDotDotToken;
                case 1:
                    return this.publicOrPrivateKeyword;
                case 2:
                    return this.identifier;
                case 3:
                    return this.questionToken;
                case 4:
                    return this.typeAnnotation;
                case 5:
                    return this.equalsValueClause;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ParameterSyntax.prototype.update = function (dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause) {
            if (this.dotDotDotToken === dotDotDotToken && this.publicOrPrivateKeyword === publicOrPrivateKeyword && this.identifier === identifier && this.questionToken === questionToken && this.typeAnnotation === typeAnnotation && this.equalsValueClause === equalsValueClause) {
                return this;
            }

            return new ParameterSyntax(dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause, this.parsedInStrictMode());
        };

        ParameterSyntax.create = function (identifier) {
            return new ParameterSyntax(null, null, identifier, null, null, null, false);
        };

        ParameterSyntax.create1 = function (identifier) {
            return new ParameterSyntax(null, null, identifier, null, null, null, false);
        };

        ParameterSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ParameterSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ParameterSyntax.prototype.withDotDotDotToken = function (dotDotDotToken) {
            return this.update(dotDotDotToken, this.publicOrPrivateKeyword, this.identifier, this.questionToken, this.typeAnnotation, this.equalsValueClause);
        };

        ParameterSyntax.prototype.withPublicOrPrivateKeyword = function (publicOrPrivateKeyword) {
            return this.update(this.dotDotDotToken, publicOrPrivateKeyword, this.identifier, this.questionToken, this.typeAnnotation, this.equalsValueClause);
        };

        ParameterSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.dotDotDotToken, this.publicOrPrivateKeyword, identifier, this.questionToken, this.typeAnnotation, this.equalsValueClause);
        };

        ParameterSyntax.prototype.withQuestionToken = function (questionToken) {
            return this.update(this.dotDotDotToken, this.publicOrPrivateKeyword, this.identifier, questionToken, this.typeAnnotation, this.equalsValueClause);
        };

        ParameterSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
            return this.update(this.dotDotDotToken, this.publicOrPrivateKeyword, this.identifier, this.questionToken, typeAnnotation, this.equalsValueClause);
        };

        ParameterSyntax.prototype.withEqualsValueClause = function (equalsValueClause) {
            return this.update(this.dotDotDotToken, this.publicOrPrivateKeyword, this.identifier, this.questionToken, this.typeAnnotation, equalsValueClause);
        };

        ParameterSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.dotDotDotToken !== null) {
                return true;
            }
            if (this.publicOrPrivateKeyword !== null) {
                return true;
            }
            if (this.questionToken !== null) {
                return true;
            }
            if (this.typeAnnotation !== null) {
                return true;
            }
            if (this.equalsValueClause !== null) {
                return true;
            }
            return false;
        };
        return ParameterSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ParameterSyntax = ParameterSyntax;

    var MemberAccessExpressionSyntax = (function (_super) {
        __extends(MemberAccessExpressionSyntax, _super);
        function MemberAccessExpressionSyntax(expression, dotToken, name, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.expression = expression;
            this.dotToken = dotToken;
            this.name = name;
        }
        MemberAccessExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitMemberAccessExpression(this);
        };

        MemberAccessExpressionSyntax.prototype.kind = function () {
            return 211 /* MemberAccessExpression */;
        };

        MemberAccessExpressionSyntax.prototype.childCount = function () {
            return 3;
        };

        MemberAccessExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.expression;
                case 1:
                    return this.dotToken;
                case 2:
                    return this.name;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        MemberAccessExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        MemberAccessExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        MemberAccessExpressionSyntax.prototype.update = function (expression, dotToken, name) {
            if (this.expression === expression && this.dotToken === dotToken && this.name === name) {
                return this;
            }

            return new MemberAccessExpressionSyntax(expression, dotToken, name, this.parsedInStrictMode());
        };

        MemberAccessExpressionSyntax.create1 = function (expression, name) {
            return new MemberAccessExpressionSyntax(expression, TypeScript.Syntax.token(77 /* DotToken */), name, false);
        };

        MemberAccessExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        MemberAccessExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        MemberAccessExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(expression, this.dotToken, this.name);
        };

        MemberAccessExpressionSyntax.prototype.withDotToken = function (dotToken) {
            return this.update(this.expression, dotToken, this.name);
        };

        MemberAccessExpressionSyntax.prototype.withName = function (name) {
            return this.update(this.expression, this.dotToken, name);
        };

        MemberAccessExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return MemberAccessExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.MemberAccessExpressionSyntax = MemberAccessExpressionSyntax;

    var PostfixUnaryExpressionSyntax = (function (_super) {
        __extends(PostfixUnaryExpressionSyntax, _super);
        function PostfixUnaryExpressionSyntax(kind, operand, operatorToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.operand = operand;
            this.operatorToken = operatorToken;

            this._kind = kind;
        }
        PostfixUnaryExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitPostfixUnaryExpression(this);
        };

        PostfixUnaryExpressionSyntax.prototype.childCount = function () {
            return 2;
        };

        PostfixUnaryExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.operand;
                case 1:
                    return this.operatorToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        PostfixUnaryExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        PostfixUnaryExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        PostfixUnaryExpressionSyntax.prototype.kind = function () {
            return this._kind;
        };

        PostfixUnaryExpressionSyntax.prototype.update = function (kind, operand, operatorToken) {
            if (this._kind === kind && this.operand === operand && this.operatorToken === operatorToken) {
                return this;
            }

            return new PostfixUnaryExpressionSyntax(kind, operand, operatorToken, this.parsedInStrictMode());
        };

        PostfixUnaryExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        PostfixUnaryExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        PostfixUnaryExpressionSyntax.prototype.withKind = function (kind) {
            return this.update(kind, this.operand, this.operatorToken);
        };

        PostfixUnaryExpressionSyntax.prototype.withOperand = function (operand) {
            return this.update(this._kind, operand, this.operatorToken);
        };

        PostfixUnaryExpressionSyntax.prototype.withOperatorToken = function (operatorToken) {
            return this.update(this._kind, this.operand, operatorToken);
        };

        PostfixUnaryExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.operand.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return PostfixUnaryExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.PostfixUnaryExpressionSyntax = PostfixUnaryExpressionSyntax;

    var ElementAccessExpressionSyntax = (function (_super) {
        __extends(ElementAccessExpressionSyntax, _super);
        function ElementAccessExpressionSyntax(expression, openBracketToken, argumentExpression, closeBracketToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.expression = expression;
            this.openBracketToken = openBracketToken;
            this.argumentExpression = argumentExpression;
            this.closeBracketToken = closeBracketToken;
        }
        ElementAccessExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitElementAccessExpression(this);
        };

        ElementAccessExpressionSyntax.prototype.kind = function () {
            return 220 /* ElementAccessExpression */;
        };

        ElementAccessExpressionSyntax.prototype.childCount = function () {
            return 4;
        };

        ElementAccessExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.expression;
                case 1:
                    return this.openBracketToken;
                case 2:
                    return this.argumentExpression;
                case 3:
                    return this.closeBracketToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ElementAccessExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        ElementAccessExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        ElementAccessExpressionSyntax.prototype.update = function (expression, openBracketToken, argumentExpression, closeBracketToken) {
            if (this.expression === expression && this.openBracketToken === openBracketToken && this.argumentExpression === argumentExpression && this.closeBracketToken === closeBracketToken) {
                return this;
            }

            return new ElementAccessExpressionSyntax(expression, openBracketToken, argumentExpression, closeBracketToken, this.parsedInStrictMode());
        };

        ElementAccessExpressionSyntax.create1 = function (expression, argumentExpression) {
            return new ElementAccessExpressionSyntax(expression, TypeScript.Syntax.token(75 /* OpenBracketToken */), argumentExpression, TypeScript.Syntax.token(76 /* CloseBracketToken */), false);
        };

        ElementAccessExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ElementAccessExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ElementAccessExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(expression, this.openBracketToken, this.argumentExpression, this.closeBracketToken);
        };

        ElementAccessExpressionSyntax.prototype.withOpenBracketToken = function (openBracketToken) {
            return this.update(this.expression, openBracketToken, this.argumentExpression, this.closeBracketToken);
        };

        ElementAccessExpressionSyntax.prototype.withArgumentExpression = function (argumentExpression) {
            return this.update(this.expression, this.openBracketToken, argumentExpression, this.closeBracketToken);
        };

        ElementAccessExpressionSyntax.prototype.withCloseBracketToken = function (closeBracketToken) {
            return this.update(this.expression, this.openBracketToken, this.argumentExpression, closeBracketToken);
        };

        ElementAccessExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            if (this.argumentExpression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ElementAccessExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ElementAccessExpressionSyntax = ElementAccessExpressionSyntax;

    var InvocationExpressionSyntax = (function (_super) {
        __extends(InvocationExpressionSyntax, _super);
        function InvocationExpressionSyntax(expression, argumentList, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.expression = expression;
            this.argumentList = argumentList;
        }
        InvocationExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitInvocationExpression(this);
        };

        InvocationExpressionSyntax.prototype.kind = function () {
            return 212 /* InvocationExpression */;
        };

        InvocationExpressionSyntax.prototype.childCount = function () {
            return 2;
        };

        InvocationExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.expression;
                case 1:
                    return this.argumentList;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        InvocationExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        InvocationExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        InvocationExpressionSyntax.prototype.update = function (expression, argumentList) {
            if (this.expression === expression && this.argumentList === argumentList) {
                return this;
            }

            return new InvocationExpressionSyntax(expression, argumentList, this.parsedInStrictMode());
        };

        InvocationExpressionSyntax.create1 = function (expression) {
            return new InvocationExpressionSyntax(expression, ArgumentListSyntax.create1(), false);
        };

        InvocationExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        InvocationExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        InvocationExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(expression, this.argumentList);
        };

        InvocationExpressionSyntax.prototype.withArgumentList = function (argumentList) {
            return this.update(this.expression, argumentList);
        };

        InvocationExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            if (this.argumentList.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return InvocationExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.InvocationExpressionSyntax = InvocationExpressionSyntax;

    var ArgumentListSyntax = (function (_super) {
        __extends(ArgumentListSyntax, _super);
        function ArgumentListSyntax(typeArgumentList, openParenToken, arguments, closeParenToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.typeArgumentList = typeArgumentList;
            this.openParenToken = openParenToken;
            this.arguments = arguments;
            this.closeParenToken = closeParenToken;
        }
        ArgumentListSyntax.prototype.accept = function (visitor) {
            return visitor.visitArgumentList(this);
        };

        ArgumentListSyntax.prototype.kind = function () {
            return 225 /* ArgumentList */;
        };

        ArgumentListSyntax.prototype.childCount = function () {
            return 4;
        };

        ArgumentListSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.typeArgumentList;
                case 1:
                    return this.openParenToken;
                case 2:
                    return this.arguments;
                case 3:
                    return this.closeParenToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ArgumentListSyntax.prototype.update = function (typeArgumentList, openParenToken, _arguments, closeParenToken) {
            if (this.typeArgumentList === typeArgumentList && this.openParenToken === openParenToken && this.arguments === _arguments && this.closeParenToken === closeParenToken) {
                return this;
            }

            return new ArgumentListSyntax(typeArgumentList, openParenToken, _arguments, closeParenToken, this.parsedInStrictMode());
        };

        ArgumentListSyntax.create = function (openParenToken, closeParenToken) {
            return new ArgumentListSyntax(null, openParenToken, TypeScript.Syntax.emptySeparatedList, closeParenToken, false);
        };

        ArgumentListSyntax.create1 = function () {
            return new ArgumentListSyntax(null, TypeScript.Syntax.token(73 /* OpenParenToken */), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.token(74 /* CloseParenToken */), false);
        };

        ArgumentListSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ArgumentListSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ArgumentListSyntax.prototype.withTypeArgumentList = function (typeArgumentList) {
            return this.update(typeArgumentList, this.openParenToken, this.arguments, this.closeParenToken);
        };

        ArgumentListSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.typeArgumentList, openParenToken, this.arguments, this.closeParenToken);
        };

        ArgumentListSyntax.prototype.withArguments = function (_arguments) {
            return this.update(this.typeArgumentList, this.openParenToken, _arguments, this.closeParenToken);
        };

        ArgumentListSyntax.prototype.withArgument = function (_argument) {
            return this.withArguments(TypeScript.Syntax.separatedList([_argument]));
        };

        ArgumentListSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.typeArgumentList, this.openParenToken, this.arguments, closeParenToken);
        };

        ArgumentListSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.typeArgumentList !== null && this.typeArgumentList.isTypeScriptSpecific()) {
                return true;
            }
            if (this.arguments.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ArgumentListSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ArgumentListSyntax = ArgumentListSyntax;

    var BinaryExpressionSyntax = (function (_super) {
        __extends(BinaryExpressionSyntax, _super);
        function BinaryExpressionSyntax(kind, left, operatorToken, right, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.left = left;
            this.operatorToken = operatorToken;
            this.right = right;

            this._kind = kind;
        }
        BinaryExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitBinaryExpression(this);
        };

        BinaryExpressionSyntax.prototype.childCount = function () {
            return 3;
        };

        BinaryExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.left;
                case 1:
                    return this.operatorToken;
                case 2:
                    return this.right;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        BinaryExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        BinaryExpressionSyntax.prototype.kind = function () {
            return this._kind;
        };

        BinaryExpressionSyntax.prototype.update = function (kind, left, operatorToken, right) {
            if (this._kind === kind && this.left === left && this.operatorToken === operatorToken && this.right === right) {
                return this;
            }

            return new BinaryExpressionSyntax(kind, left, operatorToken, right, this.parsedInStrictMode());
        };

        BinaryExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        BinaryExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        BinaryExpressionSyntax.prototype.withKind = function (kind) {
            return this.update(kind, this.left, this.operatorToken, this.right);
        };

        BinaryExpressionSyntax.prototype.withLeft = function (left) {
            return this.update(this._kind, left, this.operatorToken, this.right);
        };

        BinaryExpressionSyntax.prototype.withOperatorToken = function (operatorToken) {
            return this.update(this._kind, this.left, operatorToken, this.right);
        };

        BinaryExpressionSyntax.prototype.withRight = function (right) {
            return this.update(this._kind, this.left, this.operatorToken, right);
        };

        BinaryExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.left.isTypeScriptSpecific()) {
                return true;
            }
            if (this.right.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return BinaryExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.BinaryExpressionSyntax = BinaryExpressionSyntax;

    var ConditionalExpressionSyntax = (function (_super) {
        __extends(ConditionalExpressionSyntax, _super);
        function ConditionalExpressionSyntax(condition, questionToken, whenTrue, colonToken, whenFalse, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.condition = condition;
            this.questionToken = questionToken;
            this.whenTrue = whenTrue;
            this.colonToken = colonToken;
            this.whenFalse = whenFalse;
        }
        ConditionalExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitConditionalExpression(this);
        };

        ConditionalExpressionSyntax.prototype.kind = function () {
            return 185 /* ConditionalExpression */;
        };

        ConditionalExpressionSyntax.prototype.childCount = function () {
            return 5;
        };

        ConditionalExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.condition;
                case 1:
                    return this.questionToken;
                case 2:
                    return this.whenTrue;
                case 3:
                    return this.colonToken;
                case 4:
                    return this.whenFalse;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ConditionalExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        ConditionalExpressionSyntax.prototype.update = function (condition, questionToken, whenTrue, colonToken, whenFalse) {
            if (this.condition === condition && this.questionToken === questionToken && this.whenTrue === whenTrue && this.colonToken === colonToken && this.whenFalse === whenFalse) {
                return this;
            }

            return new ConditionalExpressionSyntax(condition, questionToken, whenTrue, colonToken, whenFalse, this.parsedInStrictMode());
        };

        ConditionalExpressionSyntax.create1 = function (condition, whenTrue, whenFalse) {
            return new ConditionalExpressionSyntax(condition, TypeScript.Syntax.token(106 /* QuestionToken */), whenTrue, TypeScript.Syntax.token(107 /* ColonToken */), whenFalse, false);
        };

        ConditionalExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ConditionalExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ConditionalExpressionSyntax.prototype.withCondition = function (condition) {
            return this.update(condition, this.questionToken, this.whenTrue, this.colonToken, this.whenFalse);
        };

        ConditionalExpressionSyntax.prototype.withQuestionToken = function (questionToken) {
            return this.update(this.condition, questionToken, this.whenTrue, this.colonToken, this.whenFalse);
        };

        ConditionalExpressionSyntax.prototype.withWhenTrue = function (whenTrue) {
            return this.update(this.condition, this.questionToken, whenTrue, this.colonToken, this.whenFalse);
        };

        ConditionalExpressionSyntax.prototype.withColonToken = function (colonToken) {
            return this.update(this.condition, this.questionToken, this.whenTrue, colonToken, this.whenFalse);
        };

        ConditionalExpressionSyntax.prototype.withWhenFalse = function (whenFalse) {
            return this.update(this.condition, this.questionToken, this.whenTrue, this.colonToken, whenFalse);
        };

        ConditionalExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.condition.isTypeScriptSpecific()) {
                return true;
            }
            if (this.whenTrue.isTypeScriptSpecific()) {
                return true;
            }
            if (this.whenFalse.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ConditionalExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ConditionalExpressionSyntax = ConditionalExpressionSyntax;

    var ConstructSignatureSyntax = (function (_super) {
        __extends(ConstructSignatureSyntax, _super);
        function ConstructSignatureSyntax(newKeyword, callSignature, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.newKeyword = newKeyword;
            this.callSignature = callSignature;
        }
        ConstructSignatureSyntax.prototype.accept = function (visitor) {
            return visitor.visitConstructSignature(this);
        };

        ConstructSignatureSyntax.prototype.kind = function () {
            return 142 /* ConstructSignature */;
        };

        ConstructSignatureSyntax.prototype.childCount = function () {
            return 2;
        };

        ConstructSignatureSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.newKeyword;
                case 1:
                    return this.callSignature;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ConstructSignatureSyntax.prototype.isTypeMember = function () {
            return true;
        };

        ConstructSignatureSyntax.prototype.update = function (newKeyword, callSignature) {
            if (this.newKeyword === newKeyword && this.callSignature === callSignature) {
                return this;
            }

            return new ConstructSignatureSyntax(newKeyword, callSignature, this.parsedInStrictMode());
        };

        ConstructSignatureSyntax.create1 = function () {
            return new ConstructSignatureSyntax(TypeScript.Syntax.token(31 /* NewKeyword */), CallSignatureSyntax.create1(), false);
        };

        ConstructSignatureSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ConstructSignatureSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ConstructSignatureSyntax.prototype.withNewKeyword = function (newKeyword) {
            return this.update(newKeyword, this.callSignature);
        };

        ConstructSignatureSyntax.prototype.withCallSignature = function (callSignature) {
            return this.update(this.newKeyword, callSignature);
        };

        ConstructSignatureSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ConstructSignatureSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ConstructSignatureSyntax = ConstructSignatureSyntax;

    var MethodSignatureSyntax = (function (_super) {
        __extends(MethodSignatureSyntax, _super);
        function MethodSignatureSyntax(propertyName, questionToken, callSignature, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.propertyName = propertyName;
            this.questionToken = questionToken;
            this.callSignature = callSignature;
        }
        MethodSignatureSyntax.prototype.accept = function (visitor) {
            return visitor.visitMethodSignature(this);
        };

        MethodSignatureSyntax.prototype.kind = function () {
            return 144 /* MethodSignature */;
        };

        MethodSignatureSyntax.prototype.childCount = function () {
            return 3;
        };

        MethodSignatureSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.propertyName;
                case 1:
                    return this.questionToken;
                case 2:
                    return this.callSignature;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        MethodSignatureSyntax.prototype.isTypeMember = function () {
            return true;
        };

        MethodSignatureSyntax.prototype.update = function (propertyName, questionToken, callSignature) {
            if (this.propertyName === propertyName && this.questionToken === questionToken && this.callSignature === callSignature) {
                return this;
            }

            return new MethodSignatureSyntax(propertyName, questionToken, callSignature, this.parsedInStrictMode());
        };

        MethodSignatureSyntax.create = function (propertyName, callSignature) {
            return new MethodSignatureSyntax(propertyName, null, callSignature, false);
        };

        MethodSignatureSyntax.create1 = function (propertyName) {
            return new MethodSignatureSyntax(propertyName, null, CallSignatureSyntax.create1(), false);
        };

        MethodSignatureSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        MethodSignatureSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        MethodSignatureSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(propertyName, this.questionToken, this.callSignature);
        };

        MethodSignatureSyntax.prototype.withQuestionToken = function (questionToken) {
            return this.update(this.propertyName, questionToken, this.callSignature);
        };

        MethodSignatureSyntax.prototype.withCallSignature = function (callSignature) {
            return this.update(this.propertyName, this.questionToken, callSignature);
        };

        MethodSignatureSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.callSignature.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return MethodSignatureSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.MethodSignatureSyntax = MethodSignatureSyntax;

    var IndexSignatureSyntax = (function (_super) {
        __extends(IndexSignatureSyntax, _super);
        function IndexSignatureSyntax(openBracketToken, parameter, closeBracketToken, typeAnnotation, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.openBracketToken = openBracketToken;
            this.parameter = parameter;
            this.closeBracketToken = closeBracketToken;
            this.typeAnnotation = typeAnnotation;
        }
        IndexSignatureSyntax.prototype.accept = function (visitor) {
            return visitor.visitIndexSignature(this);
        };

        IndexSignatureSyntax.prototype.kind = function () {
            return 143 /* IndexSignature */;
        };

        IndexSignatureSyntax.prototype.childCount = function () {
            return 4;
        };

        IndexSignatureSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.openBracketToken;
                case 1:
                    return this.parameter;
                case 2:
                    return this.closeBracketToken;
                case 3:
                    return this.typeAnnotation;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        IndexSignatureSyntax.prototype.isTypeMember = function () {
            return true;
        };

        IndexSignatureSyntax.prototype.isClassElement = function () {
            return true;
        };

        IndexSignatureSyntax.prototype.update = function (openBracketToken, parameter, closeBracketToken, typeAnnotation) {
            if (this.openBracketToken === openBracketToken && this.parameter === parameter && this.closeBracketToken === closeBracketToken && this.typeAnnotation === typeAnnotation) {
                return this;
            }

            return new IndexSignatureSyntax(openBracketToken, parameter, closeBracketToken, typeAnnotation, this.parsedInStrictMode());
        };

        IndexSignatureSyntax.create = function (openBracketToken, parameter, closeBracketToken) {
            return new IndexSignatureSyntax(openBracketToken, parameter, closeBracketToken, null, false);
        };

        IndexSignatureSyntax.create1 = function (parameter) {
            return new IndexSignatureSyntax(TypeScript.Syntax.token(75 /* OpenBracketToken */), parameter, TypeScript.Syntax.token(76 /* CloseBracketToken */), null, false);
        };

        IndexSignatureSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        IndexSignatureSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        IndexSignatureSyntax.prototype.withOpenBracketToken = function (openBracketToken) {
            return this.update(openBracketToken, this.parameter, this.closeBracketToken, this.typeAnnotation);
        };

        IndexSignatureSyntax.prototype.withParameter = function (parameter) {
            return this.update(this.openBracketToken, parameter, this.closeBracketToken, this.typeAnnotation);
        };

        IndexSignatureSyntax.prototype.withCloseBracketToken = function (closeBracketToken) {
            return this.update(this.openBracketToken, this.parameter, closeBracketToken, this.typeAnnotation);
        };

        IndexSignatureSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
            return this.update(this.openBracketToken, this.parameter, this.closeBracketToken, typeAnnotation);
        };

        IndexSignatureSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return IndexSignatureSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.IndexSignatureSyntax = IndexSignatureSyntax;

    var PropertySignatureSyntax = (function (_super) {
        __extends(PropertySignatureSyntax, _super);
        function PropertySignatureSyntax(propertyName, questionToken, typeAnnotation, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.propertyName = propertyName;
            this.questionToken = questionToken;
            this.typeAnnotation = typeAnnotation;
        }
        PropertySignatureSyntax.prototype.accept = function (visitor) {
            return visitor.visitPropertySignature(this);
        };

        PropertySignatureSyntax.prototype.kind = function () {
            return 140 /* PropertySignature */;
        };

        PropertySignatureSyntax.prototype.childCount = function () {
            return 3;
        };

        PropertySignatureSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.propertyName;
                case 1:
                    return this.questionToken;
                case 2:
                    return this.typeAnnotation;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        PropertySignatureSyntax.prototype.isTypeMember = function () {
            return true;
        };

        PropertySignatureSyntax.prototype.update = function (propertyName, questionToken, typeAnnotation) {
            if (this.propertyName === propertyName && this.questionToken === questionToken && this.typeAnnotation === typeAnnotation) {
                return this;
            }

            return new PropertySignatureSyntax(propertyName, questionToken, typeAnnotation, this.parsedInStrictMode());
        };

        PropertySignatureSyntax.create = function (propertyName) {
            return new PropertySignatureSyntax(propertyName, null, null, false);
        };

        PropertySignatureSyntax.create1 = function (propertyName) {
            return new PropertySignatureSyntax(propertyName, null, null, false);
        };

        PropertySignatureSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        PropertySignatureSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        PropertySignatureSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(propertyName, this.questionToken, this.typeAnnotation);
        };

        PropertySignatureSyntax.prototype.withQuestionToken = function (questionToken) {
            return this.update(this.propertyName, questionToken, this.typeAnnotation);
        };

        PropertySignatureSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
            return this.update(this.propertyName, this.questionToken, typeAnnotation);
        };

        PropertySignatureSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return PropertySignatureSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.PropertySignatureSyntax = PropertySignatureSyntax;

    var CallSignatureSyntax = (function (_super) {
        __extends(CallSignatureSyntax, _super);
        function CallSignatureSyntax(typeParameterList, parameterList, typeAnnotation, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.typeParameterList = typeParameterList;
            this.parameterList = parameterList;
            this.typeAnnotation = typeAnnotation;
        }
        CallSignatureSyntax.prototype.accept = function (visitor) {
            return visitor.visitCallSignature(this);
        };

        CallSignatureSyntax.prototype.kind = function () {
            return 141 /* CallSignature */;
        };

        CallSignatureSyntax.prototype.childCount = function () {
            return 3;
        };

        CallSignatureSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.typeParameterList;
                case 1:
                    return this.parameterList;
                case 2:
                    return this.typeAnnotation;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        CallSignatureSyntax.prototype.isTypeMember = function () {
            return true;
        };

        CallSignatureSyntax.prototype.update = function (typeParameterList, parameterList, typeAnnotation) {
            if (this.typeParameterList === typeParameterList && this.parameterList === parameterList && this.typeAnnotation === typeAnnotation) {
                return this;
            }

            return new CallSignatureSyntax(typeParameterList, parameterList, typeAnnotation, this.parsedInStrictMode());
        };

        CallSignatureSyntax.create = function (parameterList) {
            return new CallSignatureSyntax(null, parameterList, null, false);
        };

        CallSignatureSyntax.create1 = function () {
            return new CallSignatureSyntax(null, ParameterListSyntax.create1(), null, false);
        };

        CallSignatureSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        CallSignatureSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        CallSignatureSyntax.prototype.withTypeParameterList = function (typeParameterList) {
            return this.update(typeParameterList, this.parameterList, this.typeAnnotation);
        };

        CallSignatureSyntax.prototype.withParameterList = function (parameterList) {
            return this.update(this.typeParameterList, parameterList, this.typeAnnotation);
        };

        CallSignatureSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
            return this.update(this.typeParameterList, this.parameterList, typeAnnotation);
        };

        CallSignatureSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.typeParameterList !== null) {
                return true;
            }
            if (this.parameterList.isTypeScriptSpecific()) {
                return true;
            }
            if (this.typeAnnotation !== null) {
                return true;
            }
            return false;
        };
        return CallSignatureSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.CallSignatureSyntax = CallSignatureSyntax;

    var ParameterListSyntax = (function (_super) {
        __extends(ParameterListSyntax, _super);
        function ParameterListSyntax(openParenToken, parameters, closeParenToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.openParenToken = openParenToken;
            this.parameters = parameters;
            this.closeParenToken = closeParenToken;
        }
        ParameterListSyntax.prototype.accept = function (visitor) {
            return visitor.visitParameterList(this);
        };

        ParameterListSyntax.prototype.kind = function () {
            return 226 /* ParameterList */;
        };

        ParameterListSyntax.prototype.childCount = function () {
            return 3;
        };

        ParameterListSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.openParenToken;
                case 1:
                    return this.parameters;
                case 2:
                    return this.closeParenToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ParameterListSyntax.prototype.update = function (openParenToken, parameters, closeParenToken) {
            if (this.openParenToken === openParenToken && this.parameters === parameters && this.closeParenToken === closeParenToken) {
                return this;
            }

            return new ParameterListSyntax(openParenToken, parameters, closeParenToken, this.parsedInStrictMode());
        };

        ParameterListSyntax.create = function (openParenToken, closeParenToken) {
            return new ParameterListSyntax(openParenToken, TypeScript.Syntax.emptySeparatedList, closeParenToken, false);
        };

        ParameterListSyntax.create1 = function () {
            return new ParameterListSyntax(TypeScript.Syntax.token(73 /* OpenParenToken */), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.token(74 /* CloseParenToken */), false);
        };

        ParameterListSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ParameterListSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ParameterListSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(openParenToken, this.parameters, this.closeParenToken);
        };

        ParameterListSyntax.prototype.withParameters = function (parameters) {
            return this.update(this.openParenToken, parameters, this.closeParenToken);
        };

        ParameterListSyntax.prototype.withParameter = function (parameter) {
            return this.withParameters(TypeScript.Syntax.separatedList([parameter]));
        };

        ParameterListSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.openParenToken, this.parameters, closeParenToken);
        };

        ParameterListSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.parameters.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ParameterListSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ParameterListSyntax = ParameterListSyntax;

    var TypeParameterListSyntax = (function (_super) {
        __extends(TypeParameterListSyntax, _super);
        function TypeParameterListSyntax(lessThanToken, typeParameters, greaterThanToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.lessThanToken = lessThanToken;
            this.typeParameters = typeParameters;
            this.greaterThanToken = greaterThanToken;
        }
        TypeParameterListSyntax.prototype.accept = function (visitor) {
            return visitor.visitTypeParameterList(this);
        };

        TypeParameterListSyntax.prototype.kind = function () {
            return 228 /* TypeParameterList */;
        };

        TypeParameterListSyntax.prototype.childCount = function () {
            return 3;
        };

        TypeParameterListSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.lessThanToken;
                case 1:
                    return this.typeParameters;
                case 2:
                    return this.greaterThanToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        TypeParameterListSyntax.prototype.update = function (lessThanToken, typeParameters, greaterThanToken) {
            if (this.lessThanToken === lessThanToken && this.typeParameters === typeParameters && this.greaterThanToken === greaterThanToken) {
                return this;
            }

            return new TypeParameterListSyntax(lessThanToken, typeParameters, greaterThanToken, this.parsedInStrictMode());
        };

        TypeParameterListSyntax.create = function (lessThanToken, greaterThanToken) {
            return new TypeParameterListSyntax(lessThanToken, TypeScript.Syntax.emptySeparatedList, greaterThanToken, false);
        };

        TypeParameterListSyntax.create1 = function () {
            return new TypeParameterListSyntax(TypeScript.Syntax.token(81 /* LessThanToken */), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.token(82 /* GreaterThanToken */), false);
        };

        TypeParameterListSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        TypeParameterListSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        TypeParameterListSyntax.prototype.withLessThanToken = function (lessThanToken) {
            return this.update(lessThanToken, this.typeParameters, this.greaterThanToken);
        };

        TypeParameterListSyntax.prototype.withTypeParameters = function (typeParameters) {
            return this.update(this.lessThanToken, typeParameters, this.greaterThanToken);
        };

        TypeParameterListSyntax.prototype.withTypeParameter = function (typeParameter) {
            return this.withTypeParameters(TypeScript.Syntax.separatedList([typeParameter]));
        };

        TypeParameterListSyntax.prototype.withGreaterThanToken = function (greaterThanToken) {
            return this.update(this.lessThanToken, this.typeParameters, greaterThanToken);
        };

        TypeParameterListSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return TypeParameterListSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.TypeParameterListSyntax = TypeParameterListSyntax;

    var TypeParameterSyntax = (function (_super) {
        __extends(TypeParameterSyntax, _super);
        function TypeParameterSyntax(identifier, constraint, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.identifier = identifier;
            this.constraint = constraint;
        }
        TypeParameterSyntax.prototype.accept = function (visitor) {
            return visitor.visitTypeParameter(this);
        };

        TypeParameterSyntax.prototype.kind = function () {
            return 236 /* TypeParameter */;
        };

        TypeParameterSyntax.prototype.childCount = function () {
            return 2;
        };

        TypeParameterSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.identifier;
                case 1:
                    return this.constraint;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        TypeParameterSyntax.prototype.update = function (identifier, constraint) {
            if (this.identifier === identifier && this.constraint === constraint) {
                return this;
            }

            return new TypeParameterSyntax(identifier, constraint, this.parsedInStrictMode());
        };

        TypeParameterSyntax.create = function (identifier) {
            return new TypeParameterSyntax(identifier, null, false);
        };

        TypeParameterSyntax.create1 = function (identifier) {
            return new TypeParameterSyntax(identifier, null, false);
        };

        TypeParameterSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        TypeParameterSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        TypeParameterSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(identifier, this.constraint);
        };

        TypeParameterSyntax.prototype.withConstraint = function (constraint) {
            return this.update(this.identifier, constraint);
        };

        TypeParameterSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return TypeParameterSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.TypeParameterSyntax = TypeParameterSyntax;

    var ConstraintSyntax = (function (_super) {
        __extends(ConstraintSyntax, _super);
        function ConstraintSyntax(extendsKeyword, type, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.extendsKeyword = extendsKeyword;
            this.type = type;
        }
        ConstraintSyntax.prototype.accept = function (visitor) {
            return visitor.visitConstraint(this);
        };

        ConstraintSyntax.prototype.kind = function () {
            return 237 /* Constraint */;
        };

        ConstraintSyntax.prototype.childCount = function () {
            return 2;
        };

        ConstraintSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.extendsKeyword;
                case 1:
                    return this.type;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ConstraintSyntax.prototype.update = function (extendsKeyword, type) {
            if (this.extendsKeyword === extendsKeyword && this.type === type) {
                return this;
            }

            return new ConstraintSyntax(extendsKeyword, type, this.parsedInStrictMode());
        };

        ConstraintSyntax.create1 = function (type) {
            return new ConstraintSyntax(TypeScript.Syntax.token(48 /* ExtendsKeyword */), type, false);
        };

        ConstraintSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ConstraintSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ConstraintSyntax.prototype.withExtendsKeyword = function (extendsKeyword) {
            return this.update(extendsKeyword, this.type);
        };

        ConstraintSyntax.prototype.withType = function (type) {
            return this.update(this.extendsKeyword, type);
        };

        ConstraintSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ConstraintSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ConstraintSyntax = ConstraintSyntax;

    var ElseClauseSyntax = (function (_super) {
        __extends(ElseClauseSyntax, _super);
        function ElseClauseSyntax(elseKeyword, statement, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.elseKeyword = elseKeyword;
            this.statement = statement;
        }
        ElseClauseSyntax.prototype.accept = function (visitor) {
            return visitor.visitElseClause(this);
        };

        ElseClauseSyntax.prototype.kind = function () {
            return 233 /* ElseClause */;
        };

        ElseClauseSyntax.prototype.childCount = function () {
            return 2;
        };

        ElseClauseSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.elseKeyword;
                case 1:
                    return this.statement;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ElseClauseSyntax.prototype.update = function (elseKeyword, statement) {
            if (this.elseKeyword === elseKeyword && this.statement === statement) {
                return this;
            }

            return new ElseClauseSyntax(elseKeyword, statement, this.parsedInStrictMode());
        };

        ElseClauseSyntax.create1 = function (statement) {
            return new ElseClauseSyntax(TypeScript.Syntax.token(23 /* ElseKeyword */), statement, false);
        };

        ElseClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ElseClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ElseClauseSyntax.prototype.withElseKeyword = function (elseKeyword) {
            return this.update(elseKeyword, this.statement);
        };

        ElseClauseSyntax.prototype.withStatement = function (statement) {
            return this.update(this.elseKeyword, statement);
        };

        ElseClauseSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.statement.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ElseClauseSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ElseClauseSyntax = ElseClauseSyntax;

    var IfStatementSyntax = (function (_super) {
        __extends(IfStatementSyntax, _super);
        function IfStatementSyntax(ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.ifKeyword = ifKeyword;
            this.openParenToken = openParenToken;
            this.condition = condition;
            this.closeParenToken = closeParenToken;
            this.statement = statement;
            this.elseClause = elseClause;
        }
        IfStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitIfStatement(this);
        };

        IfStatementSyntax.prototype.kind = function () {
            return 146 /* IfStatement */;
        };

        IfStatementSyntax.prototype.childCount = function () {
            return 6;
        };

        IfStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.ifKeyword;
                case 1:
                    return this.openParenToken;
                case 2:
                    return this.condition;
                case 3:
                    return this.closeParenToken;
                case 4:
                    return this.statement;
                case 5:
                    return this.elseClause;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        IfStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        IfStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        IfStatementSyntax.prototype.update = function (ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause) {
            if (this.ifKeyword === ifKeyword && this.openParenToken === openParenToken && this.condition === condition && this.closeParenToken === closeParenToken && this.statement === statement && this.elseClause === elseClause) {
                return this;
            }

            return new IfStatementSyntax(ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause, this.parsedInStrictMode());
        };

        IfStatementSyntax.create = function (ifKeyword, openParenToken, condition, closeParenToken, statement) {
            return new IfStatementSyntax(ifKeyword, openParenToken, condition, closeParenToken, statement, null, false);
        };

        IfStatementSyntax.create1 = function (condition, statement) {
            return new IfStatementSyntax(TypeScript.Syntax.token(28 /* IfKeyword */), TypeScript.Syntax.token(73 /* OpenParenToken */), condition, TypeScript.Syntax.token(74 /* CloseParenToken */), statement, null, false);
        };

        IfStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        IfStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        IfStatementSyntax.prototype.withIfKeyword = function (ifKeyword) {
            return this.update(ifKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, this.elseClause);
        };

        IfStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.ifKeyword, openParenToken, this.condition, this.closeParenToken, this.statement, this.elseClause);
        };

        IfStatementSyntax.prototype.withCondition = function (condition) {
            return this.update(this.ifKeyword, this.openParenToken, condition, this.closeParenToken, this.statement, this.elseClause);
        };

        IfStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.ifKeyword, this.openParenToken, this.condition, closeParenToken, this.statement, this.elseClause);
        };

        IfStatementSyntax.prototype.withStatement = function (statement) {
            return this.update(this.ifKeyword, this.openParenToken, this.condition, this.closeParenToken, statement, this.elseClause);
        };

        IfStatementSyntax.prototype.withElseClause = function (elseClause) {
            return this.update(this.ifKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, elseClause);
        };

        IfStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.condition.isTypeScriptSpecific()) {
                return true;
            }
            if (this.statement.isTypeScriptSpecific()) {
                return true;
            }
            if (this.elseClause !== null && this.elseClause.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return IfStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.IfStatementSyntax = IfStatementSyntax;

    var ExpressionStatementSyntax = (function (_super) {
        __extends(ExpressionStatementSyntax, _super);
        function ExpressionStatementSyntax(expression, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.expression = expression;
            this.semicolonToken = semicolonToken;
        }
        ExpressionStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitExpressionStatement(this);
        };

        ExpressionStatementSyntax.prototype.kind = function () {
            return 148 /* ExpressionStatement */;
        };

        ExpressionStatementSyntax.prototype.childCount = function () {
            return 2;
        };

        ExpressionStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.expression;
                case 1:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ExpressionStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        ExpressionStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        ExpressionStatementSyntax.prototype.update = function (expression, semicolonToken) {
            if (this.expression === expression && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new ExpressionStatementSyntax(expression, semicolonToken, this.parsedInStrictMode());
        };

        ExpressionStatementSyntax.create1 = function (expression) {
            return new ExpressionStatementSyntax(expression, TypeScript.Syntax.token(79 /* SemicolonToken */), false);
        };

        ExpressionStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ExpressionStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ExpressionStatementSyntax.prototype.withExpression = function (expression) {
            return this.update(expression, this.semicolonToken);
        };

        ExpressionStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.expression, semicolonToken);
        };

        ExpressionStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ExpressionStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ExpressionStatementSyntax = ExpressionStatementSyntax;

    var ConstructorDeclarationSyntax = (function (_super) {
        __extends(ConstructorDeclarationSyntax, _super);
        function ConstructorDeclarationSyntax(constructorKeyword, parameterList, block, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.constructorKeyword = constructorKeyword;
            this.parameterList = parameterList;
            this.block = block;
            this.semicolonToken = semicolonToken;
        }
        ConstructorDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitConstructorDeclaration(this);
        };

        ConstructorDeclarationSyntax.prototype.kind = function () {
            return 137 /* ConstructorDeclaration */;
        };

        ConstructorDeclarationSyntax.prototype.childCount = function () {
            return 4;
        };

        ConstructorDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.constructorKeyword;
                case 1:
                    return this.parameterList;
                case 2:
                    return this.block;
                case 3:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ConstructorDeclarationSyntax.prototype.isClassElement = function () {
            return true;
        };

        ConstructorDeclarationSyntax.prototype.update = function (constructorKeyword, parameterList, block, semicolonToken) {
            if (this.constructorKeyword === constructorKeyword && this.parameterList === parameterList && this.block === block && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new ConstructorDeclarationSyntax(constructorKeyword, parameterList, block, semicolonToken, this.parsedInStrictMode());
        };

        ConstructorDeclarationSyntax.create = function (constructorKeyword, parameterList) {
            return new ConstructorDeclarationSyntax(constructorKeyword, parameterList, null, null, false);
        };

        ConstructorDeclarationSyntax.create1 = function () {
            return new ConstructorDeclarationSyntax(TypeScript.Syntax.token(63 /* ConstructorKeyword */), ParameterListSyntax.create1(), null, null, false);
        };

        ConstructorDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ConstructorDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ConstructorDeclarationSyntax.prototype.withConstructorKeyword = function (constructorKeyword) {
            return this.update(constructorKeyword, this.parameterList, this.block, this.semicolonToken);
        };

        ConstructorDeclarationSyntax.prototype.withParameterList = function (parameterList) {
            return this.update(this.constructorKeyword, parameterList, this.block, this.semicolonToken);
        };

        ConstructorDeclarationSyntax.prototype.withBlock = function (block) {
            return this.update(this.constructorKeyword, this.parameterList, block, this.semicolonToken);
        };

        ConstructorDeclarationSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.constructorKeyword, this.parameterList, this.block, semicolonToken);
        };

        ConstructorDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ConstructorDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ConstructorDeclarationSyntax = ConstructorDeclarationSyntax;

    var MemberFunctionDeclarationSyntax = (function (_super) {
        __extends(MemberFunctionDeclarationSyntax, _super);
        function MemberFunctionDeclarationSyntax(modifiers, propertyName, callSignature, block, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.modifiers = modifiers;
            this.propertyName = propertyName;
            this.callSignature = callSignature;
            this.block = block;
            this.semicolonToken = semicolonToken;
        }
        MemberFunctionDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitMemberFunctionDeclaration(this);
        };

        MemberFunctionDeclarationSyntax.prototype.kind = function () {
            return 135 /* MemberFunctionDeclaration */;
        };

        MemberFunctionDeclarationSyntax.prototype.childCount = function () {
            return 5;
        };

        MemberFunctionDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.propertyName;
                case 2:
                    return this.callSignature;
                case 3:
                    return this.block;
                case 4:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        MemberFunctionDeclarationSyntax.prototype.isMemberDeclaration = function () {
            return true;
        };

        MemberFunctionDeclarationSyntax.prototype.isClassElement = function () {
            return true;
        };

        MemberFunctionDeclarationSyntax.prototype.update = function (modifiers, propertyName, callSignature, block, semicolonToken) {
            if (this.modifiers === modifiers && this.propertyName === propertyName && this.callSignature === callSignature && this.block === block && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new MemberFunctionDeclarationSyntax(modifiers, propertyName, callSignature, block, semicolonToken, this.parsedInStrictMode());
        };

        MemberFunctionDeclarationSyntax.create = function (propertyName, callSignature) {
            return new MemberFunctionDeclarationSyntax(TypeScript.Syntax.emptyList, propertyName, callSignature, null, null, false);
        };

        MemberFunctionDeclarationSyntax.create1 = function (propertyName) {
            return new MemberFunctionDeclarationSyntax(TypeScript.Syntax.emptyList, propertyName, CallSignatureSyntax.create1(), null, null, false);
        };

        MemberFunctionDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        MemberFunctionDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        MemberFunctionDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.propertyName, this.callSignature, this.block, this.semicolonToken);
        };

        MemberFunctionDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };

        MemberFunctionDeclarationSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(this.modifiers, propertyName, this.callSignature, this.block, this.semicolonToken);
        };

        MemberFunctionDeclarationSyntax.prototype.withCallSignature = function (callSignature) {
            return this.update(this.modifiers, this.propertyName, callSignature, this.block, this.semicolonToken);
        };

        MemberFunctionDeclarationSyntax.prototype.withBlock = function (block) {
            return this.update(this.modifiers, this.propertyName, this.callSignature, block, this.semicolonToken);
        };

        MemberFunctionDeclarationSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.modifiers, this.propertyName, this.callSignature, this.block, semicolonToken);
        };

        MemberFunctionDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return MemberFunctionDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.MemberFunctionDeclarationSyntax = MemberFunctionDeclarationSyntax;

    var MemberAccessorDeclarationSyntax = (function (_super) {
        __extends(MemberAccessorDeclarationSyntax, _super);
        function MemberAccessorDeclarationSyntax(modifiers, propertyName, parameterList, block, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.modifiers = modifiers;
            this.propertyName = propertyName;
            this.parameterList = parameterList;
            this.block = block;
        }
        MemberAccessorDeclarationSyntax.prototype.isMemberDeclaration = function () {
            return true;
        };

        MemberAccessorDeclarationSyntax.prototype.isClassElement = function () {
            return true;
        };

        MemberAccessorDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        MemberAccessorDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        MemberAccessorDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return MemberAccessorDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.MemberAccessorDeclarationSyntax = MemberAccessorDeclarationSyntax;

    var GetMemberAccessorDeclarationSyntax = (function (_super) {
        __extends(GetMemberAccessorDeclarationSyntax, _super);
        function GetMemberAccessorDeclarationSyntax(modifiers, getKeyword, propertyName, parameterList, typeAnnotation, block, parsedInStrictMode) {
            _super.call(this, modifiers, propertyName, parameterList, block, parsedInStrictMode);
            this.getKeyword = getKeyword;
            this.typeAnnotation = typeAnnotation;
        }
        GetMemberAccessorDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitGetMemberAccessorDeclaration(this);
        };

        GetMemberAccessorDeclarationSyntax.prototype.kind = function () {
            return 138 /* GetMemberAccessorDeclaration */;
        };

        GetMemberAccessorDeclarationSyntax.prototype.childCount = function () {
            return 6;
        };

        GetMemberAccessorDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.getKeyword;
                case 2:
                    return this.propertyName;
                case 3:
                    return this.parameterList;
                case 4:
                    return this.typeAnnotation;
                case 5:
                    return this.block;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        GetMemberAccessorDeclarationSyntax.prototype.update = function (modifiers, getKeyword, propertyName, parameterList, typeAnnotation, block) {
            if (this.modifiers === modifiers && this.getKeyword === getKeyword && this.propertyName === propertyName && this.parameterList === parameterList && this.typeAnnotation === typeAnnotation && this.block === block) {
                return this;
            }

            return new GetMemberAccessorDeclarationSyntax(modifiers, getKeyword, propertyName, parameterList, typeAnnotation, block, this.parsedInStrictMode());
        };

        GetMemberAccessorDeclarationSyntax.create = function (getKeyword, propertyName, parameterList, block) {
            return new GetMemberAccessorDeclarationSyntax(TypeScript.Syntax.emptyList, getKeyword, propertyName, parameterList, null, block, false);
        };

        GetMemberAccessorDeclarationSyntax.create1 = function (propertyName) {
            return new GetMemberAccessorDeclarationSyntax(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(65 /* GetKeyword */), propertyName, ParameterListSyntax.create1(), null, BlockSyntax.create1(), false);
        };

        GetMemberAccessorDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        GetMemberAccessorDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        GetMemberAccessorDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.getKeyword, this.propertyName, this.parameterList, this.typeAnnotation, this.block);
        };

        GetMemberAccessorDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };

        GetMemberAccessorDeclarationSyntax.prototype.withGetKeyword = function (getKeyword) {
            return this.update(this.modifiers, getKeyword, this.propertyName, this.parameterList, this.typeAnnotation, this.block);
        };

        GetMemberAccessorDeclarationSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(this.modifiers, this.getKeyword, propertyName, this.parameterList, this.typeAnnotation, this.block);
        };

        GetMemberAccessorDeclarationSyntax.prototype.withParameterList = function (parameterList) {
            return this.update(this.modifiers, this.getKeyword, this.propertyName, parameterList, this.typeAnnotation, this.block);
        };

        GetMemberAccessorDeclarationSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
            return this.update(this.modifiers, this.getKeyword, this.propertyName, this.parameterList, typeAnnotation, this.block);
        };

        GetMemberAccessorDeclarationSyntax.prototype.withBlock = function (block) {
            return this.update(this.modifiers, this.getKeyword, this.propertyName, this.parameterList, this.typeAnnotation, block);
        };

        GetMemberAccessorDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return GetMemberAccessorDeclarationSyntax;
    })(MemberAccessorDeclarationSyntax);
    TypeScript.GetMemberAccessorDeclarationSyntax = GetMemberAccessorDeclarationSyntax;

    var SetMemberAccessorDeclarationSyntax = (function (_super) {
        __extends(SetMemberAccessorDeclarationSyntax, _super);
        function SetMemberAccessorDeclarationSyntax(modifiers, setKeyword, propertyName, parameterList, block, parsedInStrictMode) {
            _super.call(this, modifiers, propertyName, parameterList, block, parsedInStrictMode);
            this.setKeyword = setKeyword;
        }
        SetMemberAccessorDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitSetMemberAccessorDeclaration(this);
        };

        SetMemberAccessorDeclarationSyntax.prototype.kind = function () {
            return 139 /* SetMemberAccessorDeclaration */;
        };

        SetMemberAccessorDeclarationSyntax.prototype.childCount = function () {
            return 5;
        };

        SetMemberAccessorDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.setKeyword;
                case 2:
                    return this.propertyName;
                case 3:
                    return this.parameterList;
                case 4:
                    return this.block;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        SetMemberAccessorDeclarationSyntax.prototype.update = function (modifiers, setKeyword, propertyName, parameterList, block) {
            if (this.modifiers === modifiers && this.setKeyword === setKeyword && this.propertyName === propertyName && this.parameterList === parameterList && this.block === block) {
                return this;
            }

            return new SetMemberAccessorDeclarationSyntax(modifiers, setKeyword, propertyName, parameterList, block, this.parsedInStrictMode());
        };

        SetMemberAccessorDeclarationSyntax.create = function (setKeyword, propertyName, parameterList, block) {
            return new SetMemberAccessorDeclarationSyntax(TypeScript.Syntax.emptyList, setKeyword, propertyName, parameterList, block, false);
        };

        SetMemberAccessorDeclarationSyntax.create1 = function (propertyName) {
            return new SetMemberAccessorDeclarationSyntax(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(69 /* SetKeyword */), propertyName, ParameterListSyntax.create1(), BlockSyntax.create1(), false);
        };

        SetMemberAccessorDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        SetMemberAccessorDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        SetMemberAccessorDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.setKeyword, this.propertyName, this.parameterList, this.block);
        };

        SetMemberAccessorDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };

        SetMemberAccessorDeclarationSyntax.prototype.withSetKeyword = function (setKeyword) {
            return this.update(this.modifiers, setKeyword, this.propertyName, this.parameterList, this.block);
        };

        SetMemberAccessorDeclarationSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(this.modifiers, this.setKeyword, propertyName, this.parameterList, this.block);
        };

        SetMemberAccessorDeclarationSyntax.prototype.withParameterList = function (parameterList) {
            return this.update(this.modifiers, this.setKeyword, this.propertyName, parameterList, this.block);
        };

        SetMemberAccessorDeclarationSyntax.prototype.withBlock = function (block) {
            return this.update(this.modifiers, this.setKeyword, this.propertyName, this.parameterList, block);
        };

        SetMemberAccessorDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return SetMemberAccessorDeclarationSyntax;
    })(MemberAccessorDeclarationSyntax);
    TypeScript.SetMemberAccessorDeclarationSyntax = SetMemberAccessorDeclarationSyntax;

    var MemberVariableDeclarationSyntax = (function (_super) {
        __extends(MemberVariableDeclarationSyntax, _super);
        function MemberVariableDeclarationSyntax(modifiers, variableDeclarator, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.modifiers = modifiers;
            this.variableDeclarator = variableDeclarator;
            this.semicolonToken = semicolonToken;
        }
        MemberVariableDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitMemberVariableDeclaration(this);
        };

        MemberVariableDeclarationSyntax.prototype.kind = function () {
            return 136 /* MemberVariableDeclaration */;
        };

        MemberVariableDeclarationSyntax.prototype.childCount = function () {
            return 3;
        };

        MemberVariableDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.variableDeclarator;
                case 2:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        MemberVariableDeclarationSyntax.prototype.isMemberDeclaration = function () {
            return true;
        };

        MemberVariableDeclarationSyntax.prototype.isClassElement = function () {
            return true;
        };

        MemberVariableDeclarationSyntax.prototype.update = function (modifiers, variableDeclarator, semicolonToken) {
            if (this.modifiers === modifiers && this.variableDeclarator === variableDeclarator && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new MemberVariableDeclarationSyntax(modifiers, variableDeclarator, semicolonToken, this.parsedInStrictMode());
        };

        MemberVariableDeclarationSyntax.create = function (variableDeclarator, semicolonToken) {
            return new MemberVariableDeclarationSyntax(TypeScript.Syntax.emptyList, variableDeclarator, semicolonToken, false);
        };

        MemberVariableDeclarationSyntax.create1 = function (variableDeclarator) {
            return new MemberVariableDeclarationSyntax(TypeScript.Syntax.emptyList, variableDeclarator, TypeScript.Syntax.token(79 /* SemicolonToken */), false);
        };

        MemberVariableDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        MemberVariableDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        MemberVariableDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.variableDeclarator, this.semicolonToken);
        };

        MemberVariableDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };

        MemberVariableDeclarationSyntax.prototype.withVariableDeclarator = function (variableDeclarator) {
            return this.update(this.modifiers, variableDeclarator, this.semicolonToken);
        };

        MemberVariableDeclarationSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.modifiers, this.variableDeclarator, semicolonToken);
        };

        MemberVariableDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return MemberVariableDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.MemberVariableDeclarationSyntax = MemberVariableDeclarationSyntax;

    var ThrowStatementSyntax = (function (_super) {
        __extends(ThrowStatementSyntax, _super);
        function ThrowStatementSyntax(throwKeyword, expression, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.throwKeyword = throwKeyword;
            this.expression = expression;
            this.semicolonToken = semicolonToken;
        }
        ThrowStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitThrowStatement(this);
        };

        ThrowStatementSyntax.prototype.kind = function () {
            return 156 /* ThrowStatement */;
        };

        ThrowStatementSyntax.prototype.childCount = function () {
            return 3;
        };

        ThrowStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.throwKeyword;
                case 1:
                    return this.expression;
                case 2:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ThrowStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        ThrowStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        ThrowStatementSyntax.prototype.update = function (throwKeyword, expression, semicolonToken) {
            if (this.throwKeyword === throwKeyword && this.expression === expression && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new ThrowStatementSyntax(throwKeyword, expression, semicolonToken, this.parsedInStrictMode());
        };

        ThrowStatementSyntax.create1 = function (expression) {
            return new ThrowStatementSyntax(TypeScript.Syntax.token(36 /* ThrowKeyword */), expression, TypeScript.Syntax.token(79 /* SemicolonToken */), false);
        };

        ThrowStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ThrowStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ThrowStatementSyntax.prototype.withThrowKeyword = function (throwKeyword) {
            return this.update(throwKeyword, this.expression, this.semicolonToken);
        };

        ThrowStatementSyntax.prototype.withExpression = function (expression) {
            return this.update(this.throwKeyword, expression, this.semicolonToken);
        };

        ThrowStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.throwKeyword, this.expression, semicolonToken);
        };

        ThrowStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ThrowStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ThrowStatementSyntax = ThrowStatementSyntax;

    var ReturnStatementSyntax = (function (_super) {
        __extends(ReturnStatementSyntax, _super);
        function ReturnStatementSyntax(returnKeyword, expression, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.returnKeyword = returnKeyword;
            this.expression = expression;
            this.semicolonToken = semicolonToken;
        }
        ReturnStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitReturnStatement(this);
        };

        ReturnStatementSyntax.prototype.kind = function () {
            return 149 /* ReturnStatement */;
        };

        ReturnStatementSyntax.prototype.childCount = function () {
            return 3;
        };

        ReturnStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.returnKeyword;
                case 1:
                    return this.expression;
                case 2:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ReturnStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        ReturnStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        ReturnStatementSyntax.prototype.update = function (returnKeyword, expression, semicolonToken) {
            if (this.returnKeyword === returnKeyword && this.expression === expression && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new ReturnStatementSyntax(returnKeyword, expression, semicolonToken, this.parsedInStrictMode());
        };

        ReturnStatementSyntax.create = function (returnKeyword, semicolonToken) {
            return new ReturnStatementSyntax(returnKeyword, null, semicolonToken, false);
        };

        ReturnStatementSyntax.create1 = function () {
            return new ReturnStatementSyntax(TypeScript.Syntax.token(33 /* ReturnKeyword */), null, TypeScript.Syntax.token(79 /* SemicolonToken */), false);
        };

        ReturnStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ReturnStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ReturnStatementSyntax.prototype.withReturnKeyword = function (returnKeyword) {
            return this.update(returnKeyword, this.expression, this.semicolonToken);
        };

        ReturnStatementSyntax.prototype.withExpression = function (expression) {
            return this.update(this.returnKeyword, expression, this.semicolonToken);
        };

        ReturnStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.returnKeyword, this.expression, semicolonToken);
        };

        ReturnStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression !== null && this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ReturnStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ReturnStatementSyntax = ReturnStatementSyntax;

    var ObjectCreationExpressionSyntax = (function (_super) {
        __extends(ObjectCreationExpressionSyntax, _super);
        function ObjectCreationExpressionSyntax(newKeyword, expression, argumentList, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.newKeyword = newKeyword;
            this.expression = expression;
            this.argumentList = argumentList;
        }
        ObjectCreationExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitObjectCreationExpression(this);
        };

        ObjectCreationExpressionSyntax.prototype.kind = function () {
            return 215 /* ObjectCreationExpression */;
        };

        ObjectCreationExpressionSyntax.prototype.childCount = function () {
            return 3;
        };

        ObjectCreationExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.newKeyword;
                case 1:
                    return this.expression;
                case 2:
                    return this.argumentList;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ObjectCreationExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        ObjectCreationExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        ObjectCreationExpressionSyntax.prototype.update = function (newKeyword, expression, argumentList) {
            if (this.newKeyword === newKeyword && this.expression === expression && this.argumentList === argumentList) {
                return this;
            }

            return new ObjectCreationExpressionSyntax(newKeyword, expression, argumentList, this.parsedInStrictMode());
        };

        ObjectCreationExpressionSyntax.create = function (newKeyword, expression) {
            return new ObjectCreationExpressionSyntax(newKeyword, expression, null, false);
        };

        ObjectCreationExpressionSyntax.create1 = function (expression) {
            return new ObjectCreationExpressionSyntax(TypeScript.Syntax.token(31 /* NewKeyword */), expression, null, false);
        };

        ObjectCreationExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ObjectCreationExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ObjectCreationExpressionSyntax.prototype.withNewKeyword = function (newKeyword) {
            return this.update(newKeyword, this.expression, this.argumentList);
        };

        ObjectCreationExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(this.newKeyword, expression, this.argumentList);
        };

        ObjectCreationExpressionSyntax.prototype.withArgumentList = function (argumentList) {
            return this.update(this.newKeyword, this.expression, argumentList);
        };

        ObjectCreationExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            if (this.argumentList !== null && this.argumentList.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ObjectCreationExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ObjectCreationExpressionSyntax = ObjectCreationExpressionSyntax;

    var SwitchStatementSyntax = (function (_super) {
        __extends(SwitchStatementSyntax, _super);
        function SwitchStatementSyntax(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.switchKeyword = switchKeyword;
            this.openParenToken = openParenToken;
            this.expression = expression;
            this.closeParenToken = closeParenToken;
            this.openBraceToken = openBraceToken;
            this.switchClauses = switchClauses;
            this.closeBraceToken = closeBraceToken;
        }
        SwitchStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitSwitchStatement(this);
        };

        SwitchStatementSyntax.prototype.kind = function () {
            return 150 /* SwitchStatement */;
        };

        SwitchStatementSyntax.prototype.childCount = function () {
            return 7;
        };

        SwitchStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.switchKeyword;
                case 1:
                    return this.openParenToken;
                case 2:
                    return this.expression;
                case 3:
                    return this.closeParenToken;
                case 4:
                    return this.openBraceToken;
                case 5:
                    return this.switchClauses;
                case 6:
                    return this.closeBraceToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        SwitchStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        SwitchStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        SwitchStatementSyntax.prototype.update = function (switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken) {
            if (this.switchKeyword === switchKeyword && this.openParenToken === openParenToken && this.expression === expression && this.closeParenToken === closeParenToken && this.openBraceToken === openBraceToken && this.switchClauses === switchClauses && this.closeBraceToken === closeBraceToken) {
                return this;
            }

            return new SwitchStatementSyntax(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken, this.parsedInStrictMode());
        };

        SwitchStatementSyntax.create = function (switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, closeBraceToken) {
            return new SwitchStatementSyntax(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, TypeScript.Syntax.emptyList, closeBraceToken, false);
        };

        SwitchStatementSyntax.create1 = function (expression) {
            return new SwitchStatementSyntax(TypeScript.Syntax.token(34 /* SwitchKeyword */), TypeScript.Syntax.token(73 /* OpenParenToken */), expression, TypeScript.Syntax.token(74 /* CloseParenToken */), TypeScript.Syntax.token(71 /* OpenBraceToken */), TypeScript.Syntax.emptyList, TypeScript.Syntax.token(72 /* CloseBraceToken */), false);
        };

        SwitchStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        SwitchStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        SwitchStatementSyntax.prototype.withSwitchKeyword = function (switchKeyword) {
            return this.update(switchKeyword, this.openParenToken, this.expression, this.closeParenToken, this.openBraceToken, this.switchClauses, this.closeBraceToken);
        };

        SwitchStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.switchKeyword, openParenToken, this.expression, this.closeParenToken, this.openBraceToken, this.switchClauses, this.closeBraceToken);
        };

        SwitchStatementSyntax.prototype.withExpression = function (expression) {
            return this.update(this.switchKeyword, this.openParenToken, expression, this.closeParenToken, this.openBraceToken, this.switchClauses, this.closeBraceToken);
        };

        SwitchStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.switchKeyword, this.openParenToken, this.expression, closeParenToken, this.openBraceToken, this.switchClauses, this.closeBraceToken);
        };

        SwitchStatementSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
            return this.update(this.switchKeyword, this.openParenToken, this.expression, this.closeParenToken, openBraceToken, this.switchClauses, this.closeBraceToken);
        };

        SwitchStatementSyntax.prototype.withSwitchClauses = function (switchClauses) {
            return this.update(this.switchKeyword, this.openParenToken, this.expression, this.closeParenToken, this.openBraceToken, switchClauses, this.closeBraceToken);
        };

        SwitchStatementSyntax.prototype.withSwitchClause = function (switchClause) {
            return this.withSwitchClauses(TypeScript.Syntax.list([switchClause]));
        };

        SwitchStatementSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
            return this.update(this.switchKeyword, this.openParenToken, this.expression, this.closeParenToken, this.openBraceToken, this.switchClauses, closeBraceToken);
        };

        SwitchStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            if (this.switchClauses.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return SwitchStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.SwitchStatementSyntax = SwitchStatementSyntax;

    var SwitchClauseSyntax = (function (_super) {
        __extends(SwitchClauseSyntax, _super);
        function SwitchClauseSyntax(colonToken, statements, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.colonToken = colonToken;
            this.statements = statements;
        }
        SwitchClauseSyntax.prototype.isSwitchClause = function () {
            return true;
        };

        SwitchClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        SwitchClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        SwitchClauseSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return SwitchClauseSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.SwitchClauseSyntax = SwitchClauseSyntax;

    var CaseSwitchClauseSyntax = (function (_super) {
        __extends(CaseSwitchClauseSyntax, _super);
        function CaseSwitchClauseSyntax(caseKeyword, expression, colonToken, statements, parsedInStrictMode) {
            _super.call(this, colonToken, statements, parsedInStrictMode);
            this.caseKeyword = caseKeyword;
            this.expression = expression;
        }
        CaseSwitchClauseSyntax.prototype.accept = function (visitor) {
            return visitor.visitCaseSwitchClause(this);
        };

        CaseSwitchClauseSyntax.prototype.kind = function () {
            return 231 /* CaseSwitchClause */;
        };

        CaseSwitchClauseSyntax.prototype.childCount = function () {
            return 4;
        };

        CaseSwitchClauseSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.caseKeyword;
                case 1:
                    return this.expression;
                case 2:
                    return this.colonToken;
                case 3:
                    return this.statements;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        CaseSwitchClauseSyntax.prototype.update = function (caseKeyword, expression, colonToken, statements) {
            if (this.caseKeyword === caseKeyword && this.expression === expression && this.colonToken === colonToken && this.statements === statements) {
                return this;
            }

            return new CaseSwitchClauseSyntax(caseKeyword, expression, colonToken, statements, this.parsedInStrictMode());
        };

        CaseSwitchClauseSyntax.create = function (caseKeyword, expression, colonToken) {
            return new CaseSwitchClauseSyntax(caseKeyword, expression, colonToken, TypeScript.Syntax.emptyList, false);
        };

        CaseSwitchClauseSyntax.create1 = function (expression) {
            return new CaseSwitchClauseSyntax(TypeScript.Syntax.token(16 /* CaseKeyword */), expression, TypeScript.Syntax.token(107 /* ColonToken */), TypeScript.Syntax.emptyList, false);
        };

        CaseSwitchClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        CaseSwitchClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        CaseSwitchClauseSyntax.prototype.withCaseKeyword = function (caseKeyword) {
            return this.update(caseKeyword, this.expression, this.colonToken, this.statements);
        };

        CaseSwitchClauseSyntax.prototype.withExpression = function (expression) {
            return this.update(this.caseKeyword, expression, this.colonToken, this.statements);
        };

        CaseSwitchClauseSyntax.prototype.withColonToken = function (colonToken) {
            return this.update(this.caseKeyword, this.expression, colonToken, this.statements);
        };

        CaseSwitchClauseSyntax.prototype.withStatements = function (statements) {
            return this.update(this.caseKeyword, this.expression, this.colonToken, statements);
        };

        CaseSwitchClauseSyntax.prototype.withStatement = function (statement) {
            return this.withStatements(TypeScript.Syntax.list([statement]));
        };

        CaseSwitchClauseSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            if (this.statements.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return CaseSwitchClauseSyntax;
    })(SwitchClauseSyntax);
    TypeScript.CaseSwitchClauseSyntax = CaseSwitchClauseSyntax;

    var DefaultSwitchClauseSyntax = (function (_super) {
        __extends(DefaultSwitchClauseSyntax, _super);
        function DefaultSwitchClauseSyntax(defaultKeyword, colonToken, statements, parsedInStrictMode) {
            _super.call(this, colonToken, statements, parsedInStrictMode);
            this.defaultKeyword = defaultKeyword;
        }
        DefaultSwitchClauseSyntax.prototype.accept = function (visitor) {
            return visitor.visitDefaultSwitchClause(this);
        };

        DefaultSwitchClauseSyntax.prototype.kind = function () {
            return 232 /* DefaultSwitchClause */;
        };

        DefaultSwitchClauseSyntax.prototype.childCount = function () {
            return 3;
        };

        DefaultSwitchClauseSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.defaultKeyword;
                case 1:
                    return this.colonToken;
                case 2:
                    return this.statements;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        DefaultSwitchClauseSyntax.prototype.update = function (defaultKeyword, colonToken, statements) {
            if (this.defaultKeyword === defaultKeyword && this.colonToken === colonToken && this.statements === statements) {
                return this;
            }

            return new DefaultSwitchClauseSyntax(defaultKeyword, colonToken, statements, this.parsedInStrictMode());
        };

        DefaultSwitchClauseSyntax.create = function (defaultKeyword, colonToken) {
            return new DefaultSwitchClauseSyntax(defaultKeyword, colonToken, TypeScript.Syntax.emptyList, false);
        };

        DefaultSwitchClauseSyntax.create1 = function () {
            return new DefaultSwitchClauseSyntax(TypeScript.Syntax.token(20 /* DefaultKeyword */), TypeScript.Syntax.token(107 /* ColonToken */), TypeScript.Syntax.emptyList, false);
        };

        DefaultSwitchClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        DefaultSwitchClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        DefaultSwitchClauseSyntax.prototype.withDefaultKeyword = function (defaultKeyword) {
            return this.update(defaultKeyword, this.colonToken, this.statements);
        };

        DefaultSwitchClauseSyntax.prototype.withColonToken = function (colonToken) {
            return this.update(this.defaultKeyword, colonToken, this.statements);
        };

        DefaultSwitchClauseSyntax.prototype.withStatements = function (statements) {
            return this.update(this.defaultKeyword, this.colonToken, statements);
        };

        DefaultSwitchClauseSyntax.prototype.withStatement = function (statement) {
            return this.withStatements(TypeScript.Syntax.list([statement]));
        };

        DefaultSwitchClauseSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.statements.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return DefaultSwitchClauseSyntax;
    })(SwitchClauseSyntax);
    TypeScript.DefaultSwitchClauseSyntax = DefaultSwitchClauseSyntax;

    var BreakStatementSyntax = (function (_super) {
        __extends(BreakStatementSyntax, _super);
        function BreakStatementSyntax(breakKeyword, identifier, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.breakKeyword = breakKeyword;
            this.identifier = identifier;
            this.semicolonToken = semicolonToken;
        }
        BreakStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitBreakStatement(this);
        };

        BreakStatementSyntax.prototype.kind = function () {
            return 151 /* BreakStatement */;
        };

        BreakStatementSyntax.prototype.childCount = function () {
            return 3;
        };

        BreakStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.breakKeyword;
                case 1:
                    return this.identifier;
                case 2:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        BreakStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        BreakStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        BreakStatementSyntax.prototype.update = function (breakKeyword, identifier, semicolonToken) {
            if (this.breakKeyword === breakKeyword && this.identifier === identifier && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new BreakStatementSyntax(breakKeyword, identifier, semicolonToken, this.parsedInStrictMode());
        };

        BreakStatementSyntax.create = function (breakKeyword, semicolonToken) {
            return new BreakStatementSyntax(breakKeyword, null, semicolonToken, false);
        };

        BreakStatementSyntax.create1 = function () {
            return new BreakStatementSyntax(TypeScript.Syntax.token(15 /* BreakKeyword */), null, TypeScript.Syntax.token(79 /* SemicolonToken */), false);
        };

        BreakStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        BreakStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        BreakStatementSyntax.prototype.withBreakKeyword = function (breakKeyword) {
            return this.update(breakKeyword, this.identifier, this.semicolonToken);
        };

        BreakStatementSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.breakKeyword, identifier, this.semicolonToken);
        };

        BreakStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.breakKeyword, this.identifier, semicolonToken);
        };

        BreakStatementSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return BreakStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.BreakStatementSyntax = BreakStatementSyntax;

    var ContinueStatementSyntax = (function (_super) {
        __extends(ContinueStatementSyntax, _super);
        function ContinueStatementSyntax(continueKeyword, identifier, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.continueKeyword = continueKeyword;
            this.identifier = identifier;
            this.semicolonToken = semicolonToken;
        }
        ContinueStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitContinueStatement(this);
        };

        ContinueStatementSyntax.prototype.kind = function () {
            return 152 /* ContinueStatement */;
        };

        ContinueStatementSyntax.prototype.childCount = function () {
            return 3;
        };

        ContinueStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.continueKeyword;
                case 1:
                    return this.identifier;
                case 2:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ContinueStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        ContinueStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        ContinueStatementSyntax.prototype.update = function (continueKeyword, identifier, semicolonToken) {
            if (this.continueKeyword === continueKeyword && this.identifier === identifier && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new ContinueStatementSyntax(continueKeyword, identifier, semicolonToken, this.parsedInStrictMode());
        };

        ContinueStatementSyntax.create = function (continueKeyword, semicolonToken) {
            return new ContinueStatementSyntax(continueKeyword, null, semicolonToken, false);
        };

        ContinueStatementSyntax.create1 = function () {
            return new ContinueStatementSyntax(TypeScript.Syntax.token(18 /* ContinueKeyword */), null, TypeScript.Syntax.token(79 /* SemicolonToken */), false);
        };

        ContinueStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ContinueStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ContinueStatementSyntax.prototype.withContinueKeyword = function (continueKeyword) {
            return this.update(continueKeyword, this.identifier, this.semicolonToken);
        };

        ContinueStatementSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.continueKeyword, identifier, this.semicolonToken);
        };

        ContinueStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.continueKeyword, this.identifier, semicolonToken);
        };

        ContinueStatementSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return ContinueStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ContinueStatementSyntax = ContinueStatementSyntax;

    var IterationStatementSyntax = (function (_super) {
        __extends(IterationStatementSyntax, _super);
        function IterationStatementSyntax(openParenToken, closeParenToken, statement, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.openParenToken = openParenToken;
            this.closeParenToken = closeParenToken;
            this.statement = statement;
        }
        IterationStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        IterationStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        IterationStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        IterationStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        IterationStatementSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return IterationStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.IterationStatementSyntax = IterationStatementSyntax;

    var BaseForStatementSyntax = (function (_super) {
        __extends(BaseForStatementSyntax, _super);
        function BaseForStatementSyntax(forKeyword, openParenToken, variableDeclaration, closeParenToken, statement, parsedInStrictMode) {
            _super.call(this, openParenToken, closeParenToken, statement, parsedInStrictMode);
            this.forKeyword = forKeyword;
            this.variableDeclaration = variableDeclaration;
        }
        BaseForStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        BaseForStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        BaseForStatementSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return BaseForStatementSyntax;
    })(IterationStatementSyntax);
    TypeScript.BaseForStatementSyntax = BaseForStatementSyntax;

    var ForStatementSyntax = (function (_super) {
        __extends(ForStatementSyntax, _super);
        function ForStatementSyntax(forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement, parsedInStrictMode) {
            _super.call(this, forKeyword, openParenToken, variableDeclaration, closeParenToken, statement, parsedInStrictMode);
            this.initializer = initializer;
            this.firstSemicolonToken = firstSemicolonToken;
            this.condition = condition;
            this.secondSemicolonToken = secondSemicolonToken;
            this.incrementor = incrementor;
        }
        ForStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitForStatement(this);
        };

        ForStatementSyntax.prototype.kind = function () {
            return 153 /* ForStatement */;
        };

        ForStatementSyntax.prototype.childCount = function () {
            return 10;
        };

        ForStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.forKeyword;
                case 1:
                    return this.openParenToken;
                case 2:
                    return this.variableDeclaration;
                case 3:
                    return this.initializer;
                case 4:
                    return this.firstSemicolonToken;
                case 5:
                    return this.condition;
                case 6:
                    return this.secondSemicolonToken;
                case 7:
                    return this.incrementor;
                case 8:
                    return this.closeParenToken;
                case 9:
                    return this.statement;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ForStatementSyntax.prototype.update = function (forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement) {
            if (this.forKeyword === forKeyword && this.openParenToken === openParenToken && this.variableDeclaration === variableDeclaration && this.initializer === initializer && this.firstSemicolonToken === firstSemicolonToken && this.condition === condition && this.secondSemicolonToken === secondSemicolonToken && this.incrementor === incrementor && this.closeParenToken === closeParenToken && this.statement === statement) {
                return this;
            }

            return new ForStatementSyntax(forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement, this.parsedInStrictMode());
        };

        ForStatementSyntax.create = function (forKeyword, openParenToken, firstSemicolonToken, secondSemicolonToken, closeParenToken, statement) {
            return new ForStatementSyntax(forKeyword, openParenToken, null, null, firstSemicolonToken, null, secondSemicolonToken, null, closeParenToken, statement, false);
        };

        ForStatementSyntax.create1 = function (statement) {
            return new ForStatementSyntax(TypeScript.Syntax.token(26 /* ForKeyword */), TypeScript.Syntax.token(73 /* OpenParenToken */), null, null, TypeScript.Syntax.token(79 /* SemicolonToken */), null, TypeScript.Syntax.token(79 /* SemicolonToken */), null, TypeScript.Syntax.token(74 /* CloseParenToken */), statement, false);
        };

        ForStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ForStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ForStatementSyntax.prototype.withForKeyword = function (forKeyword) {
            return this.update(forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
        };

        ForStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.forKeyword, openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
        };

        ForStatementSyntax.prototype.withVariableDeclaration = function (variableDeclaration) {
            return this.update(this.forKeyword, this.openParenToken, variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
        };

        ForStatementSyntax.prototype.withInitializer = function (initializer) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
        };

        ForStatementSyntax.prototype.withFirstSemicolonToken = function (firstSemicolonToken) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
        };

        ForStatementSyntax.prototype.withCondition = function (condition) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
        };

        ForStatementSyntax.prototype.withSecondSemicolonToken = function (secondSemicolonToken) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
        };

        ForStatementSyntax.prototype.withIncrementor = function (incrementor) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, incrementor, this.closeParenToken, this.statement);
        };

        ForStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, closeParenToken, this.statement);
        };

        ForStatementSyntax.prototype.withStatement = function (statement) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, statement);
        };

        ForStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.variableDeclaration !== null && this.variableDeclaration.isTypeScriptSpecific()) {
                return true;
            }
            if (this.initializer !== null && this.initializer.isTypeScriptSpecific()) {
                return true;
            }
            if (this.condition !== null && this.condition.isTypeScriptSpecific()) {
                return true;
            }
            if (this.incrementor !== null && this.incrementor.isTypeScriptSpecific()) {
                return true;
            }
            if (this.statement.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ForStatementSyntax;
    })(BaseForStatementSyntax);
    TypeScript.ForStatementSyntax = ForStatementSyntax;

    var ForInStatementSyntax = (function (_super) {
        __extends(ForInStatementSyntax, _super);
        function ForInStatementSyntax(forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement, parsedInStrictMode) {
            _super.call(this, forKeyword, openParenToken, variableDeclaration, closeParenToken, statement, parsedInStrictMode);
            this.left = left;
            this.inKeyword = inKeyword;
            this.expression = expression;
        }
        ForInStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitForInStatement(this);
        };

        ForInStatementSyntax.prototype.kind = function () {
            return 154 /* ForInStatement */;
        };

        ForInStatementSyntax.prototype.childCount = function () {
            return 8;
        };

        ForInStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.forKeyword;
                case 1:
                    return this.openParenToken;
                case 2:
                    return this.variableDeclaration;
                case 3:
                    return this.left;
                case 4:
                    return this.inKeyword;
                case 5:
                    return this.expression;
                case 6:
                    return this.closeParenToken;
                case 7:
                    return this.statement;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ForInStatementSyntax.prototype.update = function (forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement) {
            if (this.forKeyword === forKeyword && this.openParenToken === openParenToken && this.variableDeclaration === variableDeclaration && this.left === left && this.inKeyword === inKeyword && this.expression === expression && this.closeParenToken === closeParenToken && this.statement === statement) {
                return this;
            }

            return new ForInStatementSyntax(forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement, this.parsedInStrictMode());
        };

        ForInStatementSyntax.create = function (forKeyword, openParenToken, inKeyword, expression, closeParenToken, statement) {
            return new ForInStatementSyntax(forKeyword, openParenToken, null, null, inKeyword, expression, closeParenToken, statement, false);
        };

        ForInStatementSyntax.create1 = function (expression, statement) {
            return new ForInStatementSyntax(TypeScript.Syntax.token(26 /* ForKeyword */), TypeScript.Syntax.token(73 /* OpenParenToken */), null, null, TypeScript.Syntax.token(29 /* InKeyword */), expression, TypeScript.Syntax.token(74 /* CloseParenToken */), statement, false);
        };

        ForInStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ForInStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ForInStatementSyntax.prototype.withForKeyword = function (forKeyword) {
            return this.update(forKeyword, this.openParenToken, this.variableDeclaration, this.left, this.inKeyword, this.expression, this.closeParenToken, this.statement);
        };

        ForInStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.forKeyword, openParenToken, this.variableDeclaration, this.left, this.inKeyword, this.expression, this.closeParenToken, this.statement);
        };

        ForInStatementSyntax.prototype.withVariableDeclaration = function (variableDeclaration) {
            return this.update(this.forKeyword, this.openParenToken, variableDeclaration, this.left, this.inKeyword, this.expression, this.closeParenToken, this.statement);
        };

        ForInStatementSyntax.prototype.withLeft = function (left) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, left, this.inKeyword, this.expression, this.closeParenToken, this.statement);
        };

        ForInStatementSyntax.prototype.withInKeyword = function (inKeyword) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.left, inKeyword, this.expression, this.closeParenToken, this.statement);
        };

        ForInStatementSyntax.prototype.withExpression = function (expression) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.left, this.inKeyword, expression, this.closeParenToken, this.statement);
        };

        ForInStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.left, this.inKeyword, this.expression, closeParenToken, this.statement);
        };

        ForInStatementSyntax.prototype.withStatement = function (statement) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.left, this.inKeyword, this.expression, this.closeParenToken, statement);
        };

        ForInStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.variableDeclaration !== null && this.variableDeclaration.isTypeScriptSpecific()) {
                return true;
            }
            if (this.left !== null && this.left.isTypeScriptSpecific()) {
                return true;
            }
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            if (this.statement.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ForInStatementSyntax;
    })(BaseForStatementSyntax);
    TypeScript.ForInStatementSyntax = ForInStatementSyntax;

    var WhileStatementSyntax = (function (_super) {
        __extends(WhileStatementSyntax, _super);
        function WhileStatementSyntax(whileKeyword, openParenToken, condition, closeParenToken, statement, parsedInStrictMode) {
            _super.call(this, openParenToken, closeParenToken, statement, parsedInStrictMode);
            this.whileKeyword = whileKeyword;
            this.condition = condition;
        }
        WhileStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitWhileStatement(this);
        };

        WhileStatementSyntax.prototype.kind = function () {
            return 157 /* WhileStatement */;
        };

        WhileStatementSyntax.prototype.childCount = function () {
            return 5;
        };

        WhileStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.whileKeyword;
                case 1:
                    return this.openParenToken;
                case 2:
                    return this.condition;
                case 3:
                    return this.closeParenToken;
                case 4:
                    return this.statement;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        WhileStatementSyntax.prototype.update = function (whileKeyword, openParenToken, condition, closeParenToken, statement) {
            if (this.whileKeyword === whileKeyword && this.openParenToken === openParenToken && this.condition === condition && this.closeParenToken === closeParenToken && this.statement === statement) {
                return this;
            }

            return new WhileStatementSyntax(whileKeyword, openParenToken, condition, closeParenToken, statement, this.parsedInStrictMode());
        };

        WhileStatementSyntax.create1 = function (condition, statement) {
            return new WhileStatementSyntax(TypeScript.Syntax.token(42 /* WhileKeyword */), TypeScript.Syntax.token(73 /* OpenParenToken */), condition, TypeScript.Syntax.token(74 /* CloseParenToken */), statement, false);
        };

        WhileStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        WhileStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        WhileStatementSyntax.prototype.withWhileKeyword = function (whileKeyword) {
            return this.update(whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement);
        };

        WhileStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.whileKeyword, openParenToken, this.condition, this.closeParenToken, this.statement);
        };

        WhileStatementSyntax.prototype.withCondition = function (condition) {
            return this.update(this.whileKeyword, this.openParenToken, condition, this.closeParenToken, this.statement);
        };

        WhileStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.whileKeyword, this.openParenToken, this.condition, closeParenToken, this.statement);
        };

        WhileStatementSyntax.prototype.withStatement = function (statement) {
            return this.update(this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, statement);
        };

        WhileStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.condition.isTypeScriptSpecific()) {
                return true;
            }
            if (this.statement.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return WhileStatementSyntax;
    })(IterationStatementSyntax);
    TypeScript.WhileStatementSyntax = WhileStatementSyntax;

    var WithStatementSyntax = (function (_super) {
        __extends(WithStatementSyntax, _super);
        function WithStatementSyntax(withKeyword, openParenToken, condition, closeParenToken, statement, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.withKeyword = withKeyword;
            this.openParenToken = openParenToken;
            this.condition = condition;
            this.closeParenToken = closeParenToken;
            this.statement = statement;
        }
        WithStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitWithStatement(this);
        };

        WithStatementSyntax.prototype.kind = function () {
            return 162 /* WithStatement */;
        };

        WithStatementSyntax.prototype.childCount = function () {
            return 5;
        };

        WithStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.withKeyword;
                case 1:
                    return this.openParenToken;
                case 2:
                    return this.condition;
                case 3:
                    return this.closeParenToken;
                case 4:
                    return this.statement;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        WithStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        WithStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        WithStatementSyntax.prototype.update = function (withKeyword, openParenToken, condition, closeParenToken, statement) {
            if (this.withKeyword === withKeyword && this.openParenToken === openParenToken && this.condition === condition && this.closeParenToken === closeParenToken && this.statement === statement) {
                return this;
            }

            return new WithStatementSyntax(withKeyword, openParenToken, condition, closeParenToken, statement, this.parsedInStrictMode());
        };

        WithStatementSyntax.create1 = function (condition, statement) {
            return new WithStatementSyntax(TypeScript.Syntax.token(43 /* WithKeyword */), TypeScript.Syntax.token(73 /* OpenParenToken */), condition, TypeScript.Syntax.token(74 /* CloseParenToken */), statement, false);
        };

        WithStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        WithStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        WithStatementSyntax.prototype.withWithKeyword = function (withKeyword) {
            return this.update(withKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement);
        };

        WithStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.withKeyword, openParenToken, this.condition, this.closeParenToken, this.statement);
        };

        WithStatementSyntax.prototype.withCondition = function (condition) {
            return this.update(this.withKeyword, this.openParenToken, condition, this.closeParenToken, this.statement);
        };

        WithStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.withKeyword, this.openParenToken, this.condition, closeParenToken, this.statement);
        };

        WithStatementSyntax.prototype.withStatement = function (statement) {
            return this.update(this.withKeyword, this.openParenToken, this.condition, this.closeParenToken, statement);
        };

        WithStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.condition.isTypeScriptSpecific()) {
                return true;
            }
            if (this.statement.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return WithStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.WithStatementSyntax = WithStatementSyntax;

    var EnumDeclarationSyntax = (function (_super) {
        __extends(EnumDeclarationSyntax, _super);
        function EnumDeclarationSyntax(modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.modifiers = modifiers;
            this.enumKeyword = enumKeyword;
            this.identifier = identifier;
            this.openBraceToken = openBraceToken;
            this.enumElements = enumElements;
            this.closeBraceToken = closeBraceToken;
        }
        EnumDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitEnumDeclaration(this);
        };

        EnumDeclarationSyntax.prototype.kind = function () {
            return 132 /* EnumDeclaration */;
        };

        EnumDeclarationSyntax.prototype.childCount = function () {
            return 6;
        };

        EnumDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.enumKeyword;
                case 2:
                    return this.identifier;
                case 3:
                    return this.openBraceToken;
                case 4:
                    return this.enumElements;
                case 5:
                    return this.closeBraceToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        EnumDeclarationSyntax.prototype.isModuleElement = function () {
            return true;
        };

        EnumDeclarationSyntax.prototype.update = function (modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken) {
            if (this.modifiers === modifiers && this.enumKeyword === enumKeyword && this.identifier === identifier && this.openBraceToken === openBraceToken && this.enumElements === enumElements && this.closeBraceToken === closeBraceToken) {
                return this;
            }

            return new EnumDeclarationSyntax(modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken, this.parsedInStrictMode());
        };

        EnumDeclarationSyntax.create = function (enumKeyword, identifier, openBraceToken, closeBraceToken) {
            return new EnumDeclarationSyntax(TypeScript.Syntax.emptyList, enumKeyword, identifier, openBraceToken, TypeScript.Syntax.emptySeparatedList, closeBraceToken, false);
        };

        EnumDeclarationSyntax.create1 = function (identifier) {
            return new EnumDeclarationSyntax(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(46 /* EnumKeyword */), identifier, TypeScript.Syntax.token(71 /* OpenBraceToken */), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.token(72 /* CloseBraceToken */), false);
        };

        EnumDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        EnumDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        EnumDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.enumKeyword, this.identifier, this.openBraceToken, this.enumElements, this.closeBraceToken);
        };

        EnumDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };

        EnumDeclarationSyntax.prototype.withEnumKeyword = function (enumKeyword) {
            return this.update(this.modifiers, enumKeyword, this.identifier, this.openBraceToken, this.enumElements, this.closeBraceToken);
        };

        EnumDeclarationSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.modifiers, this.enumKeyword, identifier, this.openBraceToken, this.enumElements, this.closeBraceToken);
        };

        EnumDeclarationSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
            return this.update(this.modifiers, this.enumKeyword, this.identifier, openBraceToken, this.enumElements, this.closeBraceToken);
        };

        EnumDeclarationSyntax.prototype.withEnumElements = function (enumElements) {
            return this.update(this.modifiers, this.enumKeyword, this.identifier, this.openBraceToken, enumElements, this.closeBraceToken);
        };

        EnumDeclarationSyntax.prototype.withEnumElement = function (enumElement) {
            return this.withEnumElements(TypeScript.Syntax.separatedList([enumElement]));
        };

        EnumDeclarationSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
            return this.update(this.modifiers, this.enumKeyword, this.identifier, this.openBraceToken, this.enumElements, closeBraceToken);
        };

        EnumDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return EnumDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.EnumDeclarationSyntax = EnumDeclarationSyntax;

    var EnumElementSyntax = (function (_super) {
        __extends(EnumElementSyntax, _super);
        function EnumElementSyntax(propertyName, equalsValueClause, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.propertyName = propertyName;
            this.equalsValueClause = equalsValueClause;
        }
        EnumElementSyntax.prototype.accept = function (visitor) {
            return visitor.visitEnumElement(this);
        };

        EnumElementSyntax.prototype.kind = function () {
            return 243 /* EnumElement */;
        };

        EnumElementSyntax.prototype.childCount = function () {
            return 2;
        };

        EnumElementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.propertyName;
                case 1:
                    return this.equalsValueClause;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        EnumElementSyntax.prototype.update = function (propertyName, equalsValueClause) {
            if (this.propertyName === propertyName && this.equalsValueClause === equalsValueClause) {
                return this;
            }

            return new EnumElementSyntax(propertyName, equalsValueClause, this.parsedInStrictMode());
        };

        EnumElementSyntax.create = function (propertyName) {
            return new EnumElementSyntax(propertyName, null, false);
        };

        EnumElementSyntax.create1 = function (propertyName) {
            return new EnumElementSyntax(propertyName, null, false);
        };

        EnumElementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        EnumElementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        EnumElementSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(propertyName, this.equalsValueClause);
        };

        EnumElementSyntax.prototype.withEqualsValueClause = function (equalsValueClause) {
            return this.update(this.propertyName, equalsValueClause);
        };

        EnumElementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.equalsValueClause !== null && this.equalsValueClause.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return EnumElementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.EnumElementSyntax = EnumElementSyntax;

    var CastExpressionSyntax = (function (_super) {
        __extends(CastExpressionSyntax, _super);
        function CastExpressionSyntax(lessThanToken, type, greaterThanToken, expression, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.lessThanToken = lessThanToken;
            this.type = type;
            this.greaterThanToken = greaterThanToken;
            this.expression = expression;
        }
        CastExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitCastExpression(this);
        };

        CastExpressionSyntax.prototype.kind = function () {
            return 219 /* CastExpression */;
        };

        CastExpressionSyntax.prototype.childCount = function () {
            return 4;
        };

        CastExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.lessThanToken;
                case 1:
                    return this.type;
                case 2:
                    return this.greaterThanToken;
                case 3:
                    return this.expression;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        CastExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        CastExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        CastExpressionSyntax.prototype.update = function (lessThanToken, type, greaterThanToken, expression) {
            if (this.lessThanToken === lessThanToken && this.type === type && this.greaterThanToken === greaterThanToken && this.expression === expression) {
                return this;
            }

            return new CastExpressionSyntax(lessThanToken, type, greaterThanToken, expression, this.parsedInStrictMode());
        };

        CastExpressionSyntax.create1 = function (type, expression) {
            return new CastExpressionSyntax(TypeScript.Syntax.token(81 /* LessThanToken */), type, TypeScript.Syntax.token(82 /* GreaterThanToken */), expression, false);
        };

        CastExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        CastExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        CastExpressionSyntax.prototype.withLessThanToken = function (lessThanToken) {
            return this.update(lessThanToken, this.type, this.greaterThanToken, this.expression);
        };

        CastExpressionSyntax.prototype.withType = function (type) {
            return this.update(this.lessThanToken, type, this.greaterThanToken, this.expression);
        };

        CastExpressionSyntax.prototype.withGreaterThanToken = function (greaterThanToken) {
            return this.update(this.lessThanToken, this.type, greaterThanToken, this.expression);
        };

        CastExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(this.lessThanToken, this.type, this.greaterThanToken, expression);
        };

        CastExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return CastExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.CastExpressionSyntax = CastExpressionSyntax;

    var ObjectLiteralExpressionSyntax = (function (_super) {
        __extends(ObjectLiteralExpressionSyntax, _super);
        function ObjectLiteralExpressionSyntax(openBraceToken, propertyAssignments, closeBraceToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.openBraceToken = openBraceToken;
            this.propertyAssignments = propertyAssignments;
            this.closeBraceToken = closeBraceToken;
        }
        ObjectLiteralExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitObjectLiteralExpression(this);
        };

        ObjectLiteralExpressionSyntax.prototype.kind = function () {
            return 214 /* ObjectLiteralExpression */;
        };

        ObjectLiteralExpressionSyntax.prototype.childCount = function () {
            return 3;
        };

        ObjectLiteralExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.openBraceToken;
                case 1:
                    return this.propertyAssignments;
                case 2:
                    return this.closeBraceToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ObjectLiteralExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        ObjectLiteralExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        ObjectLiteralExpressionSyntax.prototype.update = function (openBraceToken, propertyAssignments, closeBraceToken) {
            if (this.openBraceToken === openBraceToken && this.propertyAssignments === propertyAssignments && this.closeBraceToken === closeBraceToken) {
                return this;
            }

            return new ObjectLiteralExpressionSyntax(openBraceToken, propertyAssignments, closeBraceToken, this.parsedInStrictMode());
        };

        ObjectLiteralExpressionSyntax.create = function (openBraceToken, closeBraceToken) {
            return new ObjectLiteralExpressionSyntax(openBraceToken, TypeScript.Syntax.emptySeparatedList, closeBraceToken, false);
        };

        ObjectLiteralExpressionSyntax.create1 = function () {
            return new ObjectLiteralExpressionSyntax(TypeScript.Syntax.token(71 /* OpenBraceToken */), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.token(72 /* CloseBraceToken */), false);
        };

        ObjectLiteralExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ObjectLiteralExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ObjectLiteralExpressionSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
            return this.update(openBraceToken, this.propertyAssignments, this.closeBraceToken);
        };

        ObjectLiteralExpressionSyntax.prototype.withPropertyAssignments = function (propertyAssignments) {
            return this.update(this.openBraceToken, propertyAssignments, this.closeBraceToken);
        };

        ObjectLiteralExpressionSyntax.prototype.withPropertyAssignment = function (propertyAssignment) {
            return this.withPropertyAssignments(TypeScript.Syntax.separatedList([propertyAssignment]));
        };

        ObjectLiteralExpressionSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
            return this.update(this.openBraceToken, this.propertyAssignments, closeBraceToken);
        };

        ObjectLiteralExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.propertyAssignments.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ObjectLiteralExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ObjectLiteralExpressionSyntax = ObjectLiteralExpressionSyntax;

    var PropertyAssignmentSyntax = (function (_super) {
        __extends(PropertyAssignmentSyntax, _super);
        function PropertyAssignmentSyntax(propertyName, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.propertyName = propertyName;
        }
        PropertyAssignmentSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        PropertyAssignmentSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        PropertyAssignmentSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return PropertyAssignmentSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.PropertyAssignmentSyntax = PropertyAssignmentSyntax;

    var SimplePropertyAssignmentSyntax = (function (_super) {
        __extends(SimplePropertyAssignmentSyntax, _super);
        function SimplePropertyAssignmentSyntax(propertyName, colonToken, expression, parsedInStrictMode) {
            _super.call(this, propertyName, parsedInStrictMode);
            this.colonToken = colonToken;
            this.expression = expression;
        }
        SimplePropertyAssignmentSyntax.prototype.accept = function (visitor) {
            return visitor.visitSimplePropertyAssignment(this);
        };

        SimplePropertyAssignmentSyntax.prototype.kind = function () {
            return 238 /* SimplePropertyAssignment */;
        };

        SimplePropertyAssignmentSyntax.prototype.childCount = function () {
            return 3;
        };

        SimplePropertyAssignmentSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.propertyName;
                case 1:
                    return this.colonToken;
                case 2:
                    return this.expression;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        SimplePropertyAssignmentSyntax.prototype.update = function (propertyName, colonToken, expression) {
            if (this.propertyName === propertyName && this.colonToken === colonToken && this.expression === expression) {
                return this;
            }

            return new SimplePropertyAssignmentSyntax(propertyName, colonToken, expression, this.parsedInStrictMode());
        };

        SimplePropertyAssignmentSyntax.create1 = function (propertyName, expression) {
            return new SimplePropertyAssignmentSyntax(propertyName, TypeScript.Syntax.token(107 /* ColonToken */), expression, false);
        };

        SimplePropertyAssignmentSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        SimplePropertyAssignmentSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        SimplePropertyAssignmentSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(propertyName, this.colonToken, this.expression);
        };

        SimplePropertyAssignmentSyntax.prototype.withColonToken = function (colonToken) {
            return this.update(this.propertyName, colonToken, this.expression);
        };

        SimplePropertyAssignmentSyntax.prototype.withExpression = function (expression) {
            return this.update(this.propertyName, this.colonToken, expression);
        };

        SimplePropertyAssignmentSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return SimplePropertyAssignmentSyntax;
    })(PropertyAssignmentSyntax);
    TypeScript.SimplePropertyAssignmentSyntax = SimplePropertyAssignmentSyntax;

    var FunctionPropertyAssignmentSyntax = (function (_super) {
        __extends(FunctionPropertyAssignmentSyntax, _super);
        function FunctionPropertyAssignmentSyntax(propertyName, callSignature, block, parsedInStrictMode) {
            _super.call(this, propertyName, parsedInStrictMode);
            this.callSignature = callSignature;
            this.block = block;
        }
        FunctionPropertyAssignmentSyntax.prototype.accept = function (visitor) {
            return visitor.visitFunctionPropertyAssignment(this);
        };

        FunctionPropertyAssignmentSyntax.prototype.kind = function () {
            return 241 /* FunctionPropertyAssignment */;
        };

        FunctionPropertyAssignmentSyntax.prototype.childCount = function () {
            return 3;
        };

        FunctionPropertyAssignmentSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.propertyName;
                case 1:
                    return this.callSignature;
                case 2:
                    return this.block;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        FunctionPropertyAssignmentSyntax.prototype.update = function (propertyName, callSignature, block) {
            if (this.propertyName === propertyName && this.callSignature === callSignature && this.block === block) {
                return this;
            }

            return new FunctionPropertyAssignmentSyntax(propertyName, callSignature, block, this.parsedInStrictMode());
        };

        FunctionPropertyAssignmentSyntax.create1 = function (propertyName) {
            return new FunctionPropertyAssignmentSyntax(propertyName, CallSignatureSyntax.create1(), BlockSyntax.create1(), false);
        };

        FunctionPropertyAssignmentSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        FunctionPropertyAssignmentSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        FunctionPropertyAssignmentSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(propertyName, this.callSignature, this.block);
        };

        FunctionPropertyAssignmentSyntax.prototype.withCallSignature = function (callSignature) {
            return this.update(this.propertyName, callSignature, this.block);
        };

        FunctionPropertyAssignmentSyntax.prototype.withBlock = function (block) {
            return this.update(this.propertyName, this.callSignature, block);
        };

        FunctionPropertyAssignmentSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.callSignature.isTypeScriptSpecific()) {
                return true;
            }
            if (this.block.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return FunctionPropertyAssignmentSyntax;
    })(PropertyAssignmentSyntax);
    TypeScript.FunctionPropertyAssignmentSyntax = FunctionPropertyAssignmentSyntax;

    var AccessorPropertyAssignmentSyntax = (function (_super) {
        __extends(AccessorPropertyAssignmentSyntax, _super);
        function AccessorPropertyAssignmentSyntax(propertyName, openParenToken, closeParenToken, block, parsedInStrictMode) {
            _super.call(this, propertyName, parsedInStrictMode);
            this.openParenToken = openParenToken;
            this.closeParenToken = closeParenToken;
            this.block = block;
        }
        AccessorPropertyAssignmentSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        AccessorPropertyAssignmentSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        AccessorPropertyAssignmentSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return AccessorPropertyAssignmentSyntax;
    })(PropertyAssignmentSyntax);
    TypeScript.AccessorPropertyAssignmentSyntax = AccessorPropertyAssignmentSyntax;

    var GetAccessorPropertyAssignmentSyntax = (function (_super) {
        __extends(GetAccessorPropertyAssignmentSyntax, _super);
        function GetAccessorPropertyAssignmentSyntax(getKeyword, propertyName, openParenToken, closeParenToken, typeAnnotation, block, parsedInStrictMode) {
            _super.call(this, propertyName, openParenToken, closeParenToken, block, parsedInStrictMode);
            this.getKeyword = getKeyword;
            this.typeAnnotation = typeAnnotation;
        }
        GetAccessorPropertyAssignmentSyntax.prototype.accept = function (visitor) {
            return visitor.visitGetAccessorPropertyAssignment(this);
        };

        GetAccessorPropertyAssignmentSyntax.prototype.kind = function () {
            return 239 /* GetAccessorPropertyAssignment */;
        };

        GetAccessorPropertyAssignmentSyntax.prototype.childCount = function () {
            return 6;
        };

        GetAccessorPropertyAssignmentSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.getKeyword;
                case 1:
                    return this.propertyName;
                case 2:
                    return this.openParenToken;
                case 3:
                    return this.closeParenToken;
                case 4:
                    return this.typeAnnotation;
                case 5:
                    return this.block;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        GetAccessorPropertyAssignmentSyntax.prototype.update = function (getKeyword, propertyName, openParenToken, closeParenToken, typeAnnotation, block) {
            if (this.getKeyword === getKeyword && this.propertyName === propertyName && this.openParenToken === openParenToken && this.closeParenToken === closeParenToken && this.typeAnnotation === typeAnnotation && this.block === block) {
                return this;
            }

            return new GetAccessorPropertyAssignmentSyntax(getKeyword, propertyName, openParenToken, closeParenToken, typeAnnotation, block, this.parsedInStrictMode());
        };

        GetAccessorPropertyAssignmentSyntax.create = function (getKeyword, propertyName, openParenToken, closeParenToken, block) {
            return new GetAccessorPropertyAssignmentSyntax(getKeyword, propertyName, openParenToken, closeParenToken, null, block, false);
        };

        GetAccessorPropertyAssignmentSyntax.create1 = function (propertyName) {
            return new GetAccessorPropertyAssignmentSyntax(TypeScript.Syntax.token(65 /* GetKeyword */), propertyName, TypeScript.Syntax.token(73 /* OpenParenToken */), TypeScript.Syntax.token(74 /* CloseParenToken */), null, BlockSyntax.create1(), false);
        };

        GetAccessorPropertyAssignmentSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        GetAccessorPropertyAssignmentSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        GetAccessorPropertyAssignmentSyntax.prototype.withGetKeyword = function (getKeyword) {
            return this.update(getKeyword, this.propertyName, this.openParenToken, this.closeParenToken, this.typeAnnotation, this.block);
        };

        GetAccessorPropertyAssignmentSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(this.getKeyword, propertyName, this.openParenToken, this.closeParenToken, this.typeAnnotation, this.block);
        };

        GetAccessorPropertyAssignmentSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.getKeyword, this.propertyName, openParenToken, this.closeParenToken, this.typeAnnotation, this.block);
        };

        GetAccessorPropertyAssignmentSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.getKeyword, this.propertyName, this.openParenToken, closeParenToken, this.typeAnnotation, this.block);
        };

        GetAccessorPropertyAssignmentSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
            return this.update(this.getKeyword, this.propertyName, this.openParenToken, this.closeParenToken, typeAnnotation, this.block);
        };

        GetAccessorPropertyAssignmentSyntax.prototype.withBlock = function (block) {
            return this.update(this.getKeyword, this.propertyName, this.openParenToken, this.closeParenToken, this.typeAnnotation, block);
        };

        GetAccessorPropertyAssignmentSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.typeAnnotation !== null && this.typeAnnotation.isTypeScriptSpecific()) {
                return true;
            }
            if (this.block.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return GetAccessorPropertyAssignmentSyntax;
    })(AccessorPropertyAssignmentSyntax);
    TypeScript.GetAccessorPropertyAssignmentSyntax = GetAccessorPropertyAssignmentSyntax;

    var SetAccessorPropertyAssignmentSyntax = (function (_super) {
        __extends(SetAccessorPropertyAssignmentSyntax, _super);
        function SetAccessorPropertyAssignmentSyntax(setKeyword, propertyName, openParenToken, parameter, closeParenToken, block, parsedInStrictMode) {
            _super.call(this, propertyName, openParenToken, closeParenToken, block, parsedInStrictMode);
            this.setKeyword = setKeyword;
            this.parameter = parameter;
        }
        SetAccessorPropertyAssignmentSyntax.prototype.accept = function (visitor) {
            return visitor.visitSetAccessorPropertyAssignment(this);
        };

        SetAccessorPropertyAssignmentSyntax.prototype.kind = function () {
            return 240 /* SetAccessorPropertyAssignment */;
        };

        SetAccessorPropertyAssignmentSyntax.prototype.childCount = function () {
            return 6;
        };

        SetAccessorPropertyAssignmentSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.setKeyword;
                case 1:
                    return this.propertyName;
                case 2:
                    return this.openParenToken;
                case 3:
                    return this.parameter;
                case 4:
                    return this.closeParenToken;
                case 5:
                    return this.block;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        SetAccessorPropertyAssignmentSyntax.prototype.update = function (setKeyword, propertyName, openParenToken, parameter, closeParenToken, block) {
            if (this.setKeyword === setKeyword && this.propertyName === propertyName && this.openParenToken === openParenToken && this.parameter === parameter && this.closeParenToken === closeParenToken && this.block === block) {
                return this;
            }

            return new SetAccessorPropertyAssignmentSyntax(setKeyword, propertyName, openParenToken, parameter, closeParenToken, block, this.parsedInStrictMode());
        };

        SetAccessorPropertyAssignmentSyntax.create1 = function (propertyName, parameter) {
            return new SetAccessorPropertyAssignmentSyntax(TypeScript.Syntax.token(69 /* SetKeyword */), propertyName, TypeScript.Syntax.token(73 /* OpenParenToken */), parameter, TypeScript.Syntax.token(74 /* CloseParenToken */), BlockSyntax.create1(), false);
        };

        SetAccessorPropertyAssignmentSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        SetAccessorPropertyAssignmentSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        SetAccessorPropertyAssignmentSyntax.prototype.withSetKeyword = function (setKeyword) {
            return this.update(setKeyword, this.propertyName, this.openParenToken, this.parameter, this.closeParenToken, this.block);
        };

        SetAccessorPropertyAssignmentSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(this.setKeyword, propertyName, this.openParenToken, this.parameter, this.closeParenToken, this.block);
        };

        SetAccessorPropertyAssignmentSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.setKeyword, this.propertyName, openParenToken, this.parameter, this.closeParenToken, this.block);
        };

        SetAccessorPropertyAssignmentSyntax.prototype.withParameter = function (parameter) {
            return this.update(this.setKeyword, this.propertyName, this.openParenToken, parameter, this.closeParenToken, this.block);
        };

        SetAccessorPropertyAssignmentSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.setKeyword, this.propertyName, this.openParenToken, this.parameter, closeParenToken, this.block);
        };

        SetAccessorPropertyAssignmentSyntax.prototype.withBlock = function (block) {
            return this.update(this.setKeyword, this.propertyName, this.openParenToken, this.parameter, this.closeParenToken, block);
        };

        SetAccessorPropertyAssignmentSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.parameter.isTypeScriptSpecific()) {
                return true;
            }
            if (this.block.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return SetAccessorPropertyAssignmentSyntax;
    })(AccessorPropertyAssignmentSyntax);
    TypeScript.SetAccessorPropertyAssignmentSyntax = SetAccessorPropertyAssignmentSyntax;

    var FunctionExpressionSyntax = (function (_super) {
        __extends(FunctionExpressionSyntax, _super);
        function FunctionExpressionSyntax(functionKeyword, identifier, callSignature, block, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.functionKeyword = functionKeyword;
            this.identifier = identifier;
            this.callSignature = callSignature;
            this.block = block;
        }
        FunctionExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitFunctionExpression(this);
        };

        FunctionExpressionSyntax.prototype.kind = function () {
            return 221 /* FunctionExpression */;
        };

        FunctionExpressionSyntax.prototype.childCount = function () {
            return 4;
        };

        FunctionExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.functionKeyword;
                case 1:
                    return this.identifier;
                case 2:
                    return this.callSignature;
                case 3:
                    return this.block;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        FunctionExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        FunctionExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        FunctionExpressionSyntax.prototype.update = function (functionKeyword, identifier, callSignature, block) {
            if (this.functionKeyword === functionKeyword && this.identifier === identifier && this.callSignature === callSignature && this.block === block) {
                return this;
            }

            return new FunctionExpressionSyntax(functionKeyword, identifier, callSignature, block, this.parsedInStrictMode());
        };

        FunctionExpressionSyntax.create = function (functionKeyword, callSignature, block) {
            return new FunctionExpressionSyntax(functionKeyword, null, callSignature, block, false);
        };

        FunctionExpressionSyntax.create1 = function () {
            return new FunctionExpressionSyntax(TypeScript.Syntax.token(27 /* FunctionKeyword */), null, CallSignatureSyntax.create1(), BlockSyntax.create1(), false);
        };

        FunctionExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        FunctionExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        FunctionExpressionSyntax.prototype.withFunctionKeyword = function (functionKeyword) {
            return this.update(functionKeyword, this.identifier, this.callSignature, this.block);
        };

        FunctionExpressionSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.functionKeyword, identifier, this.callSignature, this.block);
        };

        FunctionExpressionSyntax.prototype.withCallSignature = function (callSignature) {
            return this.update(this.functionKeyword, this.identifier, callSignature, this.block);
        };

        FunctionExpressionSyntax.prototype.withBlock = function (block) {
            return this.update(this.functionKeyword, this.identifier, this.callSignature, block);
        };

        FunctionExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.callSignature.isTypeScriptSpecific()) {
                return true;
            }
            if (this.block.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return FunctionExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.FunctionExpressionSyntax = FunctionExpressionSyntax;

    var EmptyStatementSyntax = (function (_super) {
        __extends(EmptyStatementSyntax, _super);
        function EmptyStatementSyntax(semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.semicolonToken = semicolonToken;
        }
        EmptyStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitEmptyStatement(this);
        };

        EmptyStatementSyntax.prototype.kind = function () {
            return 155 /* EmptyStatement */;
        };

        EmptyStatementSyntax.prototype.childCount = function () {
            return 1;
        };

        EmptyStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        EmptyStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        EmptyStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        EmptyStatementSyntax.prototype.update = function (semicolonToken) {
            if (this.semicolonToken === semicolonToken) {
                return this;
            }

            return new EmptyStatementSyntax(semicolonToken, this.parsedInStrictMode());
        };

        EmptyStatementSyntax.create1 = function () {
            return new EmptyStatementSyntax(TypeScript.Syntax.token(79 /* SemicolonToken */), false);
        };

        EmptyStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        EmptyStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        EmptyStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(semicolonToken);
        };

        EmptyStatementSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return EmptyStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.EmptyStatementSyntax = EmptyStatementSyntax;

    var TryStatementSyntax = (function (_super) {
        __extends(TryStatementSyntax, _super);
        function TryStatementSyntax(tryKeyword, block, catchClause, finallyClause, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.tryKeyword = tryKeyword;
            this.block = block;
            this.catchClause = catchClause;
            this.finallyClause = finallyClause;
        }
        TryStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitTryStatement(this);
        };

        TryStatementSyntax.prototype.kind = function () {
            return 158 /* TryStatement */;
        };

        TryStatementSyntax.prototype.childCount = function () {
            return 4;
        };

        TryStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.tryKeyword;
                case 1:
                    return this.block;
                case 2:
                    return this.catchClause;
                case 3:
                    return this.finallyClause;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        TryStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        TryStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        TryStatementSyntax.prototype.update = function (tryKeyword, block, catchClause, finallyClause) {
            if (this.tryKeyword === tryKeyword && this.block === block && this.catchClause === catchClause && this.finallyClause === finallyClause) {
                return this;
            }

            return new TryStatementSyntax(tryKeyword, block, catchClause, finallyClause, this.parsedInStrictMode());
        };

        TryStatementSyntax.create = function (tryKeyword, block) {
            return new TryStatementSyntax(tryKeyword, block, null, null, false);
        };

        TryStatementSyntax.create1 = function () {
            return new TryStatementSyntax(TypeScript.Syntax.token(38 /* TryKeyword */), BlockSyntax.create1(), null, null, false);
        };

        TryStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        TryStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        TryStatementSyntax.prototype.withTryKeyword = function (tryKeyword) {
            return this.update(tryKeyword, this.block, this.catchClause, this.finallyClause);
        };

        TryStatementSyntax.prototype.withBlock = function (block) {
            return this.update(this.tryKeyword, block, this.catchClause, this.finallyClause);
        };

        TryStatementSyntax.prototype.withCatchClause = function (catchClause) {
            return this.update(this.tryKeyword, this.block, catchClause, this.finallyClause);
        };

        TryStatementSyntax.prototype.withFinallyClause = function (finallyClause) {
            return this.update(this.tryKeyword, this.block, this.catchClause, finallyClause);
        };

        TryStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.block.isTypeScriptSpecific()) {
                return true;
            }
            if (this.catchClause !== null && this.catchClause.isTypeScriptSpecific()) {
                return true;
            }
            if (this.finallyClause !== null && this.finallyClause.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return TryStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.TryStatementSyntax = TryStatementSyntax;

    var CatchClauseSyntax = (function (_super) {
        __extends(CatchClauseSyntax, _super);
        function CatchClauseSyntax(catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.catchKeyword = catchKeyword;
            this.openParenToken = openParenToken;
            this.identifier = identifier;
            this.typeAnnotation = typeAnnotation;
            this.closeParenToken = closeParenToken;
            this.block = block;
        }
        CatchClauseSyntax.prototype.accept = function (visitor) {
            return visitor.visitCatchClause(this);
        };

        CatchClauseSyntax.prototype.kind = function () {
            return 234 /* CatchClause */;
        };

        CatchClauseSyntax.prototype.childCount = function () {
            return 6;
        };

        CatchClauseSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.catchKeyword;
                case 1:
                    return this.openParenToken;
                case 2:
                    return this.identifier;
                case 3:
                    return this.typeAnnotation;
                case 4:
                    return this.closeParenToken;
                case 5:
                    return this.block;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        CatchClauseSyntax.prototype.update = function (catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block) {
            if (this.catchKeyword === catchKeyword && this.openParenToken === openParenToken && this.identifier === identifier && this.typeAnnotation === typeAnnotation && this.closeParenToken === closeParenToken && this.block === block) {
                return this;
            }

            return new CatchClauseSyntax(catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block, this.parsedInStrictMode());
        };

        CatchClauseSyntax.create = function (catchKeyword, openParenToken, identifier, closeParenToken, block) {
            return new CatchClauseSyntax(catchKeyword, openParenToken, identifier, null, closeParenToken, block, false);
        };

        CatchClauseSyntax.create1 = function (identifier) {
            return new CatchClauseSyntax(TypeScript.Syntax.token(17 /* CatchKeyword */), TypeScript.Syntax.token(73 /* OpenParenToken */), identifier, null, TypeScript.Syntax.token(74 /* CloseParenToken */), BlockSyntax.create1(), false);
        };

        CatchClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        CatchClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        CatchClauseSyntax.prototype.withCatchKeyword = function (catchKeyword) {
            return this.update(catchKeyword, this.openParenToken, this.identifier, this.typeAnnotation, this.closeParenToken, this.block);
        };

        CatchClauseSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.catchKeyword, openParenToken, this.identifier, this.typeAnnotation, this.closeParenToken, this.block);
        };

        CatchClauseSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.catchKeyword, this.openParenToken, identifier, this.typeAnnotation, this.closeParenToken, this.block);
        };

        CatchClauseSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
            return this.update(this.catchKeyword, this.openParenToken, this.identifier, typeAnnotation, this.closeParenToken, this.block);
        };

        CatchClauseSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.catchKeyword, this.openParenToken, this.identifier, this.typeAnnotation, closeParenToken, this.block);
        };

        CatchClauseSyntax.prototype.withBlock = function (block) {
            return this.update(this.catchKeyword, this.openParenToken, this.identifier, this.typeAnnotation, this.closeParenToken, block);
        };

        CatchClauseSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.typeAnnotation !== null && this.typeAnnotation.isTypeScriptSpecific()) {
                return true;
            }
            if (this.block.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return CatchClauseSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.CatchClauseSyntax = CatchClauseSyntax;

    var FinallyClauseSyntax = (function (_super) {
        __extends(FinallyClauseSyntax, _super);
        function FinallyClauseSyntax(finallyKeyword, block, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.finallyKeyword = finallyKeyword;
            this.block = block;
        }
        FinallyClauseSyntax.prototype.accept = function (visitor) {
            return visitor.visitFinallyClause(this);
        };

        FinallyClauseSyntax.prototype.kind = function () {
            return 235 /* FinallyClause */;
        };

        FinallyClauseSyntax.prototype.childCount = function () {
            return 2;
        };

        FinallyClauseSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.finallyKeyword;
                case 1:
                    return this.block;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        FinallyClauseSyntax.prototype.update = function (finallyKeyword, block) {
            if (this.finallyKeyword === finallyKeyword && this.block === block) {
                return this;
            }

            return new FinallyClauseSyntax(finallyKeyword, block, this.parsedInStrictMode());
        };

        FinallyClauseSyntax.create1 = function () {
            return new FinallyClauseSyntax(TypeScript.Syntax.token(25 /* FinallyKeyword */), BlockSyntax.create1(), false);
        };

        FinallyClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        FinallyClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        FinallyClauseSyntax.prototype.withFinallyKeyword = function (finallyKeyword) {
            return this.update(finallyKeyword, this.block);
        };

        FinallyClauseSyntax.prototype.withBlock = function (block) {
            return this.update(this.finallyKeyword, block);
        };

        FinallyClauseSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.block.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return FinallyClauseSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.FinallyClauseSyntax = FinallyClauseSyntax;

    var LabeledStatementSyntax = (function (_super) {
        __extends(LabeledStatementSyntax, _super);
        function LabeledStatementSyntax(identifier, colonToken, statement, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.identifier = identifier;
            this.colonToken = colonToken;
            this.statement = statement;
        }
        LabeledStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitLabeledStatement(this);
        };

        LabeledStatementSyntax.prototype.kind = function () {
            return 159 /* LabeledStatement */;
        };

        LabeledStatementSyntax.prototype.childCount = function () {
            return 3;
        };

        LabeledStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.identifier;
                case 1:
                    return this.colonToken;
                case 2:
                    return this.statement;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        LabeledStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        LabeledStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        LabeledStatementSyntax.prototype.update = function (identifier, colonToken, statement) {
            if (this.identifier === identifier && this.colonToken === colonToken && this.statement === statement) {
                return this;
            }

            return new LabeledStatementSyntax(identifier, colonToken, statement, this.parsedInStrictMode());
        };

        LabeledStatementSyntax.create1 = function (identifier, statement) {
            return new LabeledStatementSyntax(identifier, TypeScript.Syntax.token(107 /* ColonToken */), statement, false);
        };

        LabeledStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        LabeledStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        LabeledStatementSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(identifier, this.colonToken, this.statement);
        };

        LabeledStatementSyntax.prototype.withColonToken = function (colonToken) {
            return this.update(this.identifier, colonToken, this.statement);
        };

        LabeledStatementSyntax.prototype.withStatement = function (statement) {
            return this.update(this.identifier, this.colonToken, statement);
        };

        LabeledStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.statement.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return LabeledStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.LabeledStatementSyntax = LabeledStatementSyntax;

    var DoStatementSyntax = (function (_super) {
        __extends(DoStatementSyntax, _super);
        function DoStatementSyntax(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken, parsedInStrictMode) {
            _super.call(this, openParenToken, closeParenToken, statement, parsedInStrictMode);
            this.doKeyword = doKeyword;
            this.whileKeyword = whileKeyword;
            this.condition = condition;
            this.semicolonToken = semicolonToken;
        }
        DoStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitDoStatement(this);
        };

        DoStatementSyntax.prototype.kind = function () {
            return 160 /* DoStatement */;
        };

        DoStatementSyntax.prototype.childCount = function () {
            return 7;
        };

        DoStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.doKeyword;
                case 1:
                    return this.statement;
                case 2:
                    return this.whileKeyword;
                case 3:
                    return this.openParenToken;
                case 4:
                    return this.condition;
                case 5:
                    return this.closeParenToken;
                case 6:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        DoStatementSyntax.prototype.update = function (doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken) {
            if (this.doKeyword === doKeyword && this.statement === statement && this.whileKeyword === whileKeyword && this.openParenToken === openParenToken && this.condition === condition && this.closeParenToken === closeParenToken && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new DoStatementSyntax(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken, this.parsedInStrictMode());
        };

        DoStatementSyntax.create1 = function (statement, condition) {
            return new DoStatementSyntax(TypeScript.Syntax.token(22 /* DoKeyword */), statement, TypeScript.Syntax.token(42 /* WhileKeyword */), TypeScript.Syntax.token(73 /* OpenParenToken */), condition, TypeScript.Syntax.token(74 /* CloseParenToken */), TypeScript.Syntax.token(79 /* SemicolonToken */), false);
        };

        DoStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        DoStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        DoStatementSyntax.prototype.withDoKeyword = function (doKeyword) {
            return this.update(doKeyword, this.statement, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.semicolonToken);
        };

        DoStatementSyntax.prototype.withStatement = function (statement) {
            return this.update(this.doKeyword, statement, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.semicolonToken);
        };

        DoStatementSyntax.prototype.withWhileKeyword = function (whileKeyword) {
            return this.update(this.doKeyword, this.statement, whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.semicolonToken);
        };

        DoStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.doKeyword, this.statement, this.whileKeyword, openParenToken, this.condition, this.closeParenToken, this.semicolonToken);
        };

        DoStatementSyntax.prototype.withCondition = function (condition) {
            return this.update(this.doKeyword, this.statement, this.whileKeyword, this.openParenToken, condition, this.closeParenToken, this.semicolonToken);
        };

        DoStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.doKeyword, this.statement, this.whileKeyword, this.openParenToken, this.condition, closeParenToken, this.semicolonToken);
        };

        DoStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.doKeyword, this.statement, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, semicolonToken);
        };

        DoStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.statement.isTypeScriptSpecific()) {
                return true;
            }
            if (this.condition.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return DoStatementSyntax;
    })(IterationStatementSyntax);
    TypeScript.DoStatementSyntax = DoStatementSyntax;

    var TypeOfExpressionSyntax = (function (_super) {
        __extends(TypeOfExpressionSyntax, _super);
        function TypeOfExpressionSyntax(typeOfKeyword, expression, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.typeOfKeyword = typeOfKeyword;
            this.expression = expression;
        }
        TypeOfExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitTypeOfExpression(this);
        };

        TypeOfExpressionSyntax.prototype.kind = function () {
            return 170 /* TypeOfExpression */;
        };

        TypeOfExpressionSyntax.prototype.childCount = function () {
            return 2;
        };

        TypeOfExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.typeOfKeyword;
                case 1:
                    return this.expression;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        TypeOfExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        TypeOfExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        TypeOfExpressionSyntax.prototype.update = function (typeOfKeyword, expression) {
            if (this.typeOfKeyword === typeOfKeyword && this.expression === expression) {
                return this;
            }

            return new TypeOfExpressionSyntax(typeOfKeyword, expression, this.parsedInStrictMode());
        };

        TypeOfExpressionSyntax.create1 = function (expression) {
            return new TypeOfExpressionSyntax(TypeScript.Syntax.token(39 /* TypeOfKeyword */), expression, false);
        };

        TypeOfExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        TypeOfExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        TypeOfExpressionSyntax.prototype.withTypeOfKeyword = function (typeOfKeyword) {
            return this.update(typeOfKeyword, this.expression);
        };

        TypeOfExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(this.typeOfKeyword, expression);
        };

        TypeOfExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return TypeOfExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.TypeOfExpressionSyntax = TypeOfExpressionSyntax;

    var DeleteExpressionSyntax = (function (_super) {
        __extends(DeleteExpressionSyntax, _super);
        function DeleteExpressionSyntax(deleteKeyword, expression, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.deleteKeyword = deleteKeyword;
            this.expression = expression;
        }
        DeleteExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitDeleteExpression(this);
        };

        DeleteExpressionSyntax.prototype.kind = function () {
            return 169 /* DeleteExpression */;
        };

        DeleteExpressionSyntax.prototype.childCount = function () {
            return 2;
        };

        DeleteExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.deleteKeyword;
                case 1:
                    return this.expression;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        DeleteExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        DeleteExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        DeleteExpressionSyntax.prototype.update = function (deleteKeyword, expression) {
            if (this.deleteKeyword === deleteKeyword && this.expression === expression) {
                return this;
            }

            return new DeleteExpressionSyntax(deleteKeyword, expression, this.parsedInStrictMode());
        };

        DeleteExpressionSyntax.create1 = function (expression) {
            return new DeleteExpressionSyntax(TypeScript.Syntax.token(21 /* DeleteKeyword */), expression, false);
        };

        DeleteExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        DeleteExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        DeleteExpressionSyntax.prototype.withDeleteKeyword = function (deleteKeyword) {
            return this.update(deleteKeyword, this.expression);
        };

        DeleteExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(this.deleteKeyword, expression);
        };

        DeleteExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return DeleteExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.DeleteExpressionSyntax = DeleteExpressionSyntax;

    var VoidExpressionSyntax = (function (_super) {
        __extends(VoidExpressionSyntax, _super);
        function VoidExpressionSyntax(voidKeyword, expression, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.voidKeyword = voidKeyword;
            this.expression = expression;
        }
        VoidExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitVoidExpression(this);
        };

        VoidExpressionSyntax.prototype.kind = function () {
            return 171 /* VoidExpression */;
        };

        VoidExpressionSyntax.prototype.childCount = function () {
            return 2;
        };

        VoidExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.voidKeyword;
                case 1:
                    return this.expression;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        VoidExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        VoidExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        VoidExpressionSyntax.prototype.update = function (voidKeyword, expression) {
            if (this.voidKeyword === voidKeyword && this.expression === expression) {
                return this;
            }

            return new VoidExpressionSyntax(voidKeyword, expression, this.parsedInStrictMode());
        };

        VoidExpressionSyntax.create1 = function (expression) {
            return new VoidExpressionSyntax(TypeScript.Syntax.token(41 /* VoidKeyword */), expression, false);
        };

        VoidExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        VoidExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        VoidExpressionSyntax.prototype.withVoidKeyword = function (voidKeyword) {
            return this.update(voidKeyword, this.expression);
        };

        VoidExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(this.voidKeyword, expression);
        };

        VoidExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return VoidExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.VoidExpressionSyntax = VoidExpressionSyntax;

    var DebuggerStatementSyntax = (function (_super) {
        __extends(DebuggerStatementSyntax, _super);
        function DebuggerStatementSyntax(debuggerKeyword, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.debuggerKeyword = debuggerKeyword;
            this.semicolonToken = semicolonToken;
        }
        DebuggerStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitDebuggerStatement(this);
        };

        DebuggerStatementSyntax.prototype.kind = function () {
            return 161 /* DebuggerStatement */;
        };

        DebuggerStatementSyntax.prototype.childCount = function () {
            return 2;
        };

        DebuggerStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.debuggerKeyword;
                case 1:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        DebuggerStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        DebuggerStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        DebuggerStatementSyntax.prototype.update = function (debuggerKeyword, semicolonToken) {
            if (this.debuggerKeyword === debuggerKeyword && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new DebuggerStatementSyntax(debuggerKeyword, semicolonToken, this.parsedInStrictMode());
        };

        DebuggerStatementSyntax.create1 = function () {
            return new DebuggerStatementSyntax(TypeScript.Syntax.token(19 /* DebuggerKeyword */), TypeScript.Syntax.token(79 /* SemicolonToken */), false);
        };

        DebuggerStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        DebuggerStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        DebuggerStatementSyntax.prototype.withDebuggerKeyword = function (debuggerKeyword) {
            return this.update(debuggerKeyword, this.semicolonToken);
        };

        DebuggerStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.debuggerKeyword, semicolonToken);
        };

        DebuggerStatementSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return DebuggerStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.DebuggerStatementSyntax = DebuggerStatementSyntax;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxRewriter = (function () {
        function SyntaxRewriter() {
        }
        SyntaxRewriter.prototype.visitToken = function (token) {
            return token;
        };

        SyntaxRewriter.prototype.visitNode = function (node) {
            return node.accept(this);
        };

        SyntaxRewriter.prototype.visitNodeOrToken = function (node) {
            return node.isToken() ? this.visitToken(node) : this.visitNode(node);
        };

        SyntaxRewriter.prototype.visitList = function (list) {
            var newItems = null;

            for (var i = 0, n = list.childCount(); i < n; i++) {
                var item = list.childAt(i);
                var newItem = this.visitNodeOrToken(item);

                if (item !== newItem && newItems === null) {
                    newItems = [];
                    for (var j = 0; j < i; j++) {
                        newItems.push(list.childAt(j));
                    }
                }

                if (newItems) {
                    newItems.push(newItem);
                }
            }

            return newItems === null ? list : TypeScript.Syntax.list(newItems);
        };

        SyntaxRewriter.prototype.visitSeparatedList = function (list) {
            var newItems = null;

            for (var i = 0, n = list.childCount(); i < n; i++) {
                var item = list.childAt(i);
                var newItem = item.isToken() ? this.visitToken(item) : this.visitNode(item);

                if (item !== newItem && newItems === null) {
                    newItems = [];
                    for (var j = 0; j < i; j++) {
                        newItems.push(list.childAt(j));
                    }
                }

                if (newItems) {
                    newItems.push(newItem);
                }
            }

            return newItems === null ? list : TypeScript.Syntax.separatedList(newItems);
        };

        SyntaxRewriter.prototype.visitSourceUnit = function (node) {
            return node.update(this.visitList(node.moduleElements), this.visitToken(node.endOfFileToken));
        };

        SyntaxRewriter.prototype.visitExternalModuleReference = function (node) {
            return node.update(this.visitToken(node.moduleOrRequireKeyword), this.visitToken(node.openParenToken), this.visitToken(node.stringLiteral), this.visitToken(node.closeParenToken));
        };

        SyntaxRewriter.prototype.visitModuleNameModuleReference = function (node) {
            return node.update(this.visitNodeOrToken(node.moduleName));
        };

        SyntaxRewriter.prototype.visitImportDeclaration = function (node) {
            return node.update(this.visitToken(node.importKeyword), this.visitToken(node.identifier), this.visitToken(node.equalsToken), this.visitNode(node.moduleReference), this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitExportAssignment = function (node) {
            return node.update(this.visitToken(node.exportKeyword), this.visitToken(node.equalsToken), this.visitToken(node.identifier), this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitClassDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.classKeyword), this.visitToken(node.identifier), node.typeParameterList === null ? null : this.visitNode(node.typeParameterList), this.visitList(node.heritageClauses), this.visitToken(node.openBraceToken), this.visitList(node.classElements), this.visitToken(node.closeBraceToken));
        };

        SyntaxRewriter.prototype.visitInterfaceDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.interfaceKeyword), this.visitToken(node.identifier), node.typeParameterList === null ? null : this.visitNode(node.typeParameterList), this.visitList(node.heritageClauses), this.visitNode(node.body));
        };

        SyntaxRewriter.prototype.visitHeritageClause = function (node) {
            return node.update(this.visitToken(node.extendsOrImplementsKeyword), this.visitSeparatedList(node.typeNames));
        };

        SyntaxRewriter.prototype.visitModuleDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.moduleKeyword), node.moduleName === null ? null : this.visitNodeOrToken(node.moduleName), node.stringLiteral === null ? null : this.visitToken(node.stringLiteral), this.visitToken(node.openBraceToken), this.visitList(node.moduleElements), this.visitToken(node.closeBraceToken));
        };

        SyntaxRewriter.prototype.visitFunctionDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.functionKeyword), this.visitToken(node.identifier), this.visitNode(node.callSignature), node.block === null ? null : this.visitNode(node.block), node.semicolonToken === null ? null : this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitVariableStatement = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitNode(node.variableDeclaration), this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitVariableDeclaration = function (node) {
            return node.update(this.visitToken(node.varKeyword), this.visitSeparatedList(node.variableDeclarators));
        };

        SyntaxRewriter.prototype.visitVariableDeclarator = function (node) {
            return node.update(this.visitToken(node.identifier), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation), node.equalsValueClause === null ? null : this.visitNode(node.equalsValueClause));
        };

        SyntaxRewriter.prototype.visitEqualsValueClause = function (node) {
            return node.update(this.visitToken(node.equalsToken), this.visitNodeOrToken(node.value));
        };

        SyntaxRewriter.prototype.visitPrefixUnaryExpression = function (node) {
            return node.update(node.kind(), this.visitToken(node.operatorToken), this.visitNodeOrToken(node.operand));
        };

        SyntaxRewriter.prototype.visitArrayLiteralExpression = function (node) {
            return node.update(this.visitToken(node.openBracketToken), this.visitSeparatedList(node.expressions), this.visitToken(node.closeBracketToken));
        };

        SyntaxRewriter.prototype.visitOmittedExpression = function (node) {
            return node;
        };

        SyntaxRewriter.prototype.visitParenthesizedExpression = function (node) {
            return node.update(this.visitToken(node.openParenToken), this.visitNodeOrToken(node.expression), this.visitToken(node.closeParenToken));
        };

        SyntaxRewriter.prototype.visitSimpleArrowFunctionExpression = function (node) {
            return node.update(this.visitToken(node.identifier), this.visitToken(node.equalsGreaterThanToken), this.visitNodeOrToken(node.body));
        };

        SyntaxRewriter.prototype.visitParenthesizedArrowFunctionExpression = function (node) {
            return node.update(this.visitNode(node.callSignature), this.visitToken(node.equalsGreaterThanToken), this.visitNodeOrToken(node.body));
        };

        SyntaxRewriter.prototype.visitQualifiedName = function (node) {
            return node.update(this.visitNodeOrToken(node.left), this.visitToken(node.dotToken), this.visitToken(node.right));
        };

        SyntaxRewriter.prototype.visitTypeArgumentList = function (node) {
            return node.update(this.visitToken(node.lessThanToken), this.visitSeparatedList(node.typeArguments), this.visitToken(node.greaterThanToken));
        };

        SyntaxRewriter.prototype.visitConstructorType = function (node) {
            return node.update(this.visitToken(node.newKeyword), node.typeParameterList === null ? null : this.visitNode(node.typeParameterList), this.visitNode(node.parameterList), this.visitToken(node.equalsGreaterThanToken), this.visitNodeOrToken(node.type));
        };

        SyntaxRewriter.prototype.visitFunctionType = function (node) {
            return node.update(node.typeParameterList === null ? null : this.visitNode(node.typeParameterList), this.visitNode(node.parameterList), this.visitToken(node.equalsGreaterThanToken), this.visitNodeOrToken(node.type));
        };

        SyntaxRewriter.prototype.visitObjectType = function (node) {
            return node.update(this.visitToken(node.openBraceToken), this.visitSeparatedList(node.typeMembers), this.visitToken(node.closeBraceToken));
        };

        SyntaxRewriter.prototype.visitArrayType = function (node) {
            return node.update(this.visitNodeOrToken(node.type), this.visitToken(node.openBracketToken), this.visitToken(node.closeBracketToken));
        };

        SyntaxRewriter.prototype.visitGenericType = function (node) {
            return node.update(this.visitNodeOrToken(node.name), this.visitNode(node.typeArgumentList));
        };

        SyntaxRewriter.prototype.visitTypeAnnotation = function (node) {
            return node.update(this.visitToken(node.colonToken), this.visitNodeOrToken(node.type));
        };

        SyntaxRewriter.prototype.visitBlock = function (node) {
            return node.update(this.visitToken(node.openBraceToken), this.visitList(node.statements), this.visitToken(node.closeBraceToken));
        };

        SyntaxRewriter.prototype.visitParameter = function (node) {
            return node.update(node.dotDotDotToken === null ? null : this.visitToken(node.dotDotDotToken), node.publicOrPrivateKeyword === null ? null : this.visitToken(node.publicOrPrivateKeyword), this.visitToken(node.identifier), node.questionToken === null ? null : this.visitToken(node.questionToken), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation), node.equalsValueClause === null ? null : this.visitNode(node.equalsValueClause));
        };

        SyntaxRewriter.prototype.visitMemberAccessExpression = function (node) {
            return node.update(this.visitNodeOrToken(node.expression), this.visitToken(node.dotToken), this.visitToken(node.name));
        };

        SyntaxRewriter.prototype.visitPostfixUnaryExpression = function (node) {
            return node.update(node.kind(), this.visitNodeOrToken(node.operand), this.visitToken(node.operatorToken));
        };

        SyntaxRewriter.prototype.visitElementAccessExpression = function (node) {
            return node.update(this.visitNodeOrToken(node.expression), this.visitToken(node.openBracketToken), this.visitNodeOrToken(node.argumentExpression), this.visitToken(node.closeBracketToken));
        };

        SyntaxRewriter.prototype.visitInvocationExpression = function (node) {
            return node.update(this.visitNodeOrToken(node.expression), this.visitNode(node.argumentList));
        };

        SyntaxRewriter.prototype.visitArgumentList = function (node) {
            return node.update(node.typeArgumentList === null ? null : this.visitNode(node.typeArgumentList), this.visitToken(node.openParenToken), this.visitSeparatedList(node.arguments), this.visitToken(node.closeParenToken));
        };

        SyntaxRewriter.prototype.visitBinaryExpression = function (node) {
            return node.update(node.kind(), this.visitNodeOrToken(node.left), this.visitToken(node.operatorToken), this.visitNodeOrToken(node.right));
        };

        SyntaxRewriter.prototype.visitConditionalExpression = function (node) {
            return node.update(this.visitNodeOrToken(node.condition), this.visitToken(node.questionToken), this.visitNodeOrToken(node.whenTrue), this.visitToken(node.colonToken), this.visitNodeOrToken(node.whenFalse));
        };

        SyntaxRewriter.prototype.visitConstructSignature = function (node) {
            return node.update(this.visitToken(node.newKeyword), this.visitNode(node.callSignature));
        };

        SyntaxRewriter.prototype.visitMethodSignature = function (node) {
            return node.update(this.visitToken(node.propertyName), node.questionToken === null ? null : this.visitToken(node.questionToken), this.visitNode(node.callSignature));
        };

        SyntaxRewriter.prototype.visitIndexSignature = function (node) {
            return node.update(this.visitToken(node.openBracketToken), this.visitNode(node.parameter), this.visitToken(node.closeBracketToken), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation));
        };

        SyntaxRewriter.prototype.visitPropertySignature = function (node) {
            return node.update(this.visitToken(node.propertyName), node.questionToken === null ? null : this.visitToken(node.questionToken), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation));
        };

        SyntaxRewriter.prototype.visitCallSignature = function (node) {
            return node.update(node.typeParameterList === null ? null : this.visitNode(node.typeParameterList), this.visitNode(node.parameterList), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation));
        };

        SyntaxRewriter.prototype.visitParameterList = function (node) {
            return node.update(this.visitToken(node.openParenToken), this.visitSeparatedList(node.parameters), this.visitToken(node.closeParenToken));
        };

        SyntaxRewriter.prototype.visitTypeParameterList = function (node) {
            return node.update(this.visitToken(node.lessThanToken), this.visitSeparatedList(node.typeParameters), this.visitToken(node.greaterThanToken));
        };

        SyntaxRewriter.prototype.visitTypeParameter = function (node) {
            return node.update(this.visitToken(node.identifier), node.constraint === null ? null : this.visitNode(node.constraint));
        };

        SyntaxRewriter.prototype.visitConstraint = function (node) {
            return node.update(this.visitToken(node.extendsKeyword), this.visitNodeOrToken(node.type));
        };

        SyntaxRewriter.prototype.visitElseClause = function (node) {
            return node.update(this.visitToken(node.elseKeyword), this.visitNodeOrToken(node.statement));
        };

        SyntaxRewriter.prototype.visitIfStatement = function (node) {
            return node.update(this.visitToken(node.ifKeyword), this.visitToken(node.openParenToken), this.visitNodeOrToken(node.condition), this.visitToken(node.closeParenToken), this.visitNodeOrToken(node.statement), node.elseClause === null ? null : this.visitNode(node.elseClause));
        };

        SyntaxRewriter.prototype.visitExpressionStatement = function (node) {
            return node.update(this.visitNodeOrToken(node.expression), this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitConstructorDeclaration = function (node) {
            return node.update(this.visitToken(node.constructorKeyword), this.visitNode(node.parameterList), node.block === null ? null : this.visitNode(node.block), node.semicolonToken === null ? null : this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitMemberFunctionDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.propertyName), this.visitNode(node.callSignature), node.block === null ? null : this.visitNode(node.block), node.semicolonToken === null ? null : this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitGetMemberAccessorDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.getKeyword), this.visitToken(node.propertyName), this.visitNode(node.parameterList), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation), this.visitNode(node.block));
        };

        SyntaxRewriter.prototype.visitSetMemberAccessorDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.setKeyword), this.visitToken(node.propertyName), this.visitNode(node.parameterList), this.visitNode(node.block));
        };

        SyntaxRewriter.prototype.visitMemberVariableDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitNode(node.variableDeclarator), this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitThrowStatement = function (node) {
            return node.update(this.visitToken(node.throwKeyword), this.visitNodeOrToken(node.expression), this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitReturnStatement = function (node) {
            return node.update(this.visitToken(node.returnKeyword), node.expression === null ? null : this.visitNodeOrToken(node.expression), this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitObjectCreationExpression = function (node) {
            return node.update(this.visitToken(node.newKeyword), this.visitNodeOrToken(node.expression), node.argumentList === null ? null : this.visitNode(node.argumentList));
        };

        SyntaxRewriter.prototype.visitSwitchStatement = function (node) {
            return node.update(this.visitToken(node.switchKeyword), this.visitToken(node.openParenToken), this.visitNodeOrToken(node.expression), this.visitToken(node.closeParenToken), this.visitToken(node.openBraceToken), this.visitList(node.switchClauses), this.visitToken(node.closeBraceToken));
        };

        SyntaxRewriter.prototype.visitCaseSwitchClause = function (node) {
            return node.update(this.visitToken(node.caseKeyword), this.visitNodeOrToken(node.expression), this.visitToken(node.colonToken), this.visitList(node.statements));
        };

        SyntaxRewriter.prototype.visitDefaultSwitchClause = function (node) {
            return node.update(this.visitToken(node.defaultKeyword), this.visitToken(node.colonToken), this.visitList(node.statements));
        };

        SyntaxRewriter.prototype.visitBreakStatement = function (node) {
            return node.update(this.visitToken(node.breakKeyword), node.identifier === null ? null : this.visitToken(node.identifier), this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitContinueStatement = function (node) {
            return node.update(this.visitToken(node.continueKeyword), node.identifier === null ? null : this.visitToken(node.identifier), this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitForStatement = function (node) {
            return node.update(this.visitToken(node.forKeyword), this.visitToken(node.openParenToken), node.variableDeclaration === null ? null : this.visitNode(node.variableDeclaration), node.initializer === null ? null : this.visitNodeOrToken(node.initializer), this.visitToken(node.firstSemicolonToken), node.condition === null ? null : this.visitNodeOrToken(node.condition), this.visitToken(node.secondSemicolonToken), node.incrementor === null ? null : this.visitNodeOrToken(node.incrementor), this.visitToken(node.closeParenToken), this.visitNodeOrToken(node.statement));
        };

        SyntaxRewriter.prototype.visitForInStatement = function (node) {
            return node.update(this.visitToken(node.forKeyword), this.visitToken(node.openParenToken), node.variableDeclaration === null ? null : this.visitNode(node.variableDeclaration), node.left === null ? null : this.visitNodeOrToken(node.left), this.visitToken(node.inKeyword), this.visitNodeOrToken(node.expression), this.visitToken(node.closeParenToken), this.visitNodeOrToken(node.statement));
        };

        SyntaxRewriter.prototype.visitWhileStatement = function (node) {
            return node.update(this.visitToken(node.whileKeyword), this.visitToken(node.openParenToken), this.visitNodeOrToken(node.condition), this.visitToken(node.closeParenToken), this.visitNodeOrToken(node.statement));
        };

        SyntaxRewriter.prototype.visitWithStatement = function (node) {
            return node.update(this.visitToken(node.withKeyword), this.visitToken(node.openParenToken), this.visitNodeOrToken(node.condition), this.visitToken(node.closeParenToken), this.visitNodeOrToken(node.statement));
        };

        SyntaxRewriter.prototype.visitEnumDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.enumKeyword), this.visitToken(node.identifier), this.visitToken(node.openBraceToken), this.visitSeparatedList(node.enumElements), this.visitToken(node.closeBraceToken));
        };

        SyntaxRewriter.prototype.visitEnumElement = function (node) {
            return node.update(this.visitToken(node.propertyName), node.equalsValueClause === null ? null : this.visitNode(node.equalsValueClause));
        };

        SyntaxRewriter.prototype.visitCastExpression = function (node) {
            return node.update(this.visitToken(node.lessThanToken), this.visitNodeOrToken(node.type), this.visitToken(node.greaterThanToken), this.visitNodeOrToken(node.expression));
        };

        SyntaxRewriter.prototype.visitObjectLiteralExpression = function (node) {
            return node.update(this.visitToken(node.openBraceToken), this.visitSeparatedList(node.propertyAssignments), this.visitToken(node.closeBraceToken));
        };

        SyntaxRewriter.prototype.visitSimplePropertyAssignment = function (node) {
            return node.update(this.visitToken(node.propertyName), this.visitToken(node.colonToken), this.visitNodeOrToken(node.expression));
        };

        SyntaxRewriter.prototype.visitFunctionPropertyAssignment = function (node) {
            return node.update(this.visitToken(node.propertyName), this.visitNode(node.callSignature), this.visitNode(node.block));
        };

        SyntaxRewriter.prototype.visitGetAccessorPropertyAssignment = function (node) {
            return node.update(this.visitToken(node.getKeyword), this.visitToken(node.propertyName), this.visitToken(node.openParenToken), this.visitToken(node.closeParenToken), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation), this.visitNode(node.block));
        };

        SyntaxRewriter.prototype.visitSetAccessorPropertyAssignment = function (node) {
            return node.update(this.visitToken(node.setKeyword), this.visitToken(node.propertyName), this.visitToken(node.openParenToken), this.visitNode(node.parameter), this.visitToken(node.closeParenToken), this.visitNode(node.block));
        };

        SyntaxRewriter.prototype.visitFunctionExpression = function (node) {
            return node.update(this.visitToken(node.functionKeyword), node.identifier === null ? null : this.visitToken(node.identifier), this.visitNode(node.callSignature), this.visitNode(node.block));
        };

        SyntaxRewriter.prototype.visitEmptyStatement = function (node) {
            return node.update(this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitTryStatement = function (node) {
            return node.update(this.visitToken(node.tryKeyword), this.visitNode(node.block), node.catchClause === null ? null : this.visitNode(node.catchClause), node.finallyClause === null ? null : this.visitNode(node.finallyClause));
        };

        SyntaxRewriter.prototype.visitCatchClause = function (node) {
            return node.update(this.visitToken(node.catchKeyword), this.visitToken(node.openParenToken), this.visitToken(node.identifier), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation), this.visitToken(node.closeParenToken), this.visitNode(node.block));
        };

        SyntaxRewriter.prototype.visitFinallyClause = function (node) {
            return node.update(this.visitToken(node.finallyKeyword), this.visitNode(node.block));
        };

        SyntaxRewriter.prototype.visitLabeledStatement = function (node) {
            return node.update(this.visitToken(node.identifier), this.visitToken(node.colonToken), this.visitNodeOrToken(node.statement));
        };

        SyntaxRewriter.prototype.visitDoStatement = function (node) {
            return node.update(this.visitToken(node.doKeyword), this.visitNodeOrToken(node.statement), this.visitToken(node.whileKeyword), this.visitToken(node.openParenToken), this.visitNodeOrToken(node.condition), this.visitToken(node.closeParenToken), this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitTypeOfExpression = function (node) {
            return node.update(this.visitToken(node.typeOfKeyword), this.visitNodeOrToken(node.expression));
        };

        SyntaxRewriter.prototype.visitDeleteExpression = function (node) {
            return node.update(this.visitToken(node.deleteKeyword), this.visitNodeOrToken(node.expression));
        };

        SyntaxRewriter.prototype.visitVoidExpression = function (node) {
            return node.update(this.visitToken(node.voidKeyword), this.visitNodeOrToken(node.expression));
        };

        SyntaxRewriter.prototype.visitDebuggerStatement = function (node) {
            return node.update(this.visitToken(node.debuggerKeyword), this.visitToken(node.semicolonToken));
        };
        return SyntaxRewriter;
    })();
    TypeScript.SyntaxRewriter = SyntaxRewriter;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxDedenter = (function (_super) {
        __extends(SyntaxDedenter, _super);
        function SyntaxDedenter(dedentFirstToken, dedentationAmount, minimumIndent, options) {
            _super.call(this);
            this.dedentationAmount = dedentationAmount;
            this.minimumIndent = minimumIndent;
            this.options = options;
            this.lastTriviaWasNewLine = dedentFirstToken;
        }
        SyntaxDedenter.prototype.abort = function () {
            this.lastTriviaWasNewLine = false;
            this.dedentationAmount = 0;
        };

        SyntaxDedenter.prototype.isAborted = function () {
            return this.dedentationAmount === 0;
        };

        SyntaxDedenter.prototype.visitToken = function (token) {
            if (token.width() === 0) {
                return token;
            }

            var result = token;
            if (this.lastTriviaWasNewLine) {
                result = token.withLeadingTrivia(this.dedentTriviaList(token.leadingTrivia()));
            }

            if (this.isAborted()) {
                return token;
            }

            this.lastTriviaWasNewLine = token.hasTrailingNewLine();
            return result;
        };

        SyntaxDedenter.prototype.dedentTriviaList = function (triviaList) {
            var result = [];
            var dedentNextWhitespace = true;

            for (var i = 0, n = triviaList.count(); i < n && !this.isAborted(); i++) {
                var trivia = triviaList.syntaxTriviaAt(i);

                var dedentThisTrivia = dedentNextWhitespace;
                dedentNextWhitespace = false;

                if (dedentThisTrivia) {
                    if (trivia.kind() === 4 /* WhitespaceTrivia */) {
                        var hasFollowingNewLine = (i < triviaList.count() - 1) && triviaList.syntaxTriviaAt(i + 1).kind() === 5 /* NewLineTrivia */;
                        result.push(this.dedentWhitespace(trivia, hasFollowingNewLine));
                        continue;
                    } else if (trivia.kind() !== 5 /* NewLineTrivia */) {
                        this.abort();
                        break;
                    }
                }

                if (trivia.kind() === 6 /* MultiLineCommentTrivia */) {
                    result.push(this.dedentMultiLineComment(trivia));
                    continue;
                }

                result.push(trivia);
                if (trivia.kind() === 5 /* NewLineTrivia */) {
                    dedentNextWhitespace = true;
                }
            }

            if (dedentNextWhitespace) {
                this.abort();
            }

            if (this.isAborted()) {
                return triviaList;
            }

            return TypeScript.Syntax.triviaList(result);
        };

        SyntaxDedenter.prototype.dedentSegment = function (segment, hasFollowingNewLineTrivia) {
            var firstNonWhitespacePosition = TypeScript.Indentation.firstNonWhitespacePosition(segment);

            if (firstNonWhitespacePosition === segment.length) {
                if (hasFollowingNewLineTrivia) {
                    return "";
                }
            } else if (TypeScript.CharacterInfo.isLineTerminator(segment.charCodeAt(firstNonWhitespacePosition))) {
                return segment.substring(firstNonWhitespacePosition);
            }

            var firstNonWhitespaceColumn = TypeScript.Indentation.columnForPositionInString(segment, firstNonWhitespacePosition, this.options);

            var newFirstNonWhitespaceColumn = TypeScript.MathPrototype.min(firstNonWhitespaceColumn, TypeScript.MathPrototype.max(firstNonWhitespaceColumn - this.dedentationAmount, this.minimumIndent));

            if (newFirstNonWhitespaceColumn === firstNonWhitespaceColumn) {
                this.abort();
                return segment;
            }

            this.dedentationAmount = firstNonWhitespaceColumn - newFirstNonWhitespaceColumn;
            TypeScript.Debug.assert(this.dedentationAmount >= 0);

            var indentationString = TypeScript.Indentation.indentationString(newFirstNonWhitespaceColumn, this.options);

            return indentationString + segment.substring(firstNonWhitespacePosition);
        };

        SyntaxDedenter.prototype.dedentWhitespace = function (trivia, hasFollowingNewLineTrivia) {
            var newIndentation = this.dedentSegment(trivia.fullText(), hasFollowingNewLineTrivia);
            return TypeScript.Syntax.whitespace(newIndentation);
        };

        SyntaxDedenter.prototype.dedentMultiLineComment = function (trivia) {
            var segments = TypeScript.Syntax.splitMultiLineCommentTriviaIntoMultipleLines(trivia);
            if (segments.length === 1) {
                return trivia;
            }

            for (var i = 1; i < segments.length; i++) {
                var segment = segments[i];
                segments[i] = this.dedentSegment(segment, false);
            }

            var result = segments.join("");

            return TypeScript.Syntax.multiLineComment(result);
        };

        SyntaxDedenter.dedentNode = function (node, dedentFirstToken, dedentAmount, minimumIndent, options) {
            var dedenter = new SyntaxDedenter(dedentFirstToken, dedentAmount, minimumIndent, options);
            var result = node.accept(dedenter);

            if (dedenter.isAborted()) {
                return node;
            }

            return result;
        };
        return SyntaxDedenter;
    })(TypeScript.SyntaxRewriter);
    TypeScript.SyntaxDedenter = SyntaxDedenter;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxIndenter = (function (_super) {
        __extends(SyntaxIndenter, _super);
        function SyntaxIndenter(indentFirstToken, indentationAmount, options) {
            _super.call(this);
            this.indentationAmount = indentationAmount;
            this.options = options;
            this.lastTriviaWasNewLine = indentFirstToken;
            this.indentationTrivia = TypeScript.Indentation.indentationTrivia(this.indentationAmount, this.options);
        }
        SyntaxIndenter.prototype.visitToken = function (token) {
            if (token.width() === 0) {
                return token;
            }

            var result = token;
            if (this.lastTriviaWasNewLine) {
                result = token.withLeadingTrivia(this.indentTriviaList(token.leadingTrivia()));
            }

            this.lastTriviaWasNewLine = token.hasTrailingNewLine();
            return result;
        };

        SyntaxIndenter.prototype.indentTriviaList = function (triviaList) {
            var result = [];

            var indentNextTrivia = true;
            for (var i = 0, n = triviaList.count(); i < n; i++) {
                var trivia = triviaList.syntaxTriviaAt(i);

                var indentThisTrivia = indentNextTrivia;
                indentNextTrivia = false;

                switch (trivia.kind()) {
                    case 6 /* MultiLineCommentTrivia */:
                        this.indentMultiLineComment(trivia, indentThisTrivia, result);
                        continue;

                    case 7 /* SingleLineCommentTrivia */:
                    case 8 /* SkippedTokenTrivia */:
                        this.indentSingleLineOrSkippedText(trivia, indentThisTrivia, result);
                        continue;

                    case 4 /* WhitespaceTrivia */:
                        this.indentWhitespace(trivia, indentThisTrivia, result);
                        continue;

                    case 5 /* NewLineTrivia */:
                        result.push(trivia);
                        indentNextTrivia = true;
                        continue;

                    default:
                        throw TypeScript.Errors.invalidOperation();
                }
            }

            if (indentNextTrivia) {
                result.push(this.indentationTrivia);
            }

            return TypeScript.Syntax.triviaList(result);
        };

        SyntaxIndenter.prototype.indentSegment = function (segment) {
            var firstNonWhitespacePosition = TypeScript.Indentation.firstNonWhitespacePosition(segment);

            if (firstNonWhitespacePosition < segment.length && TypeScript.CharacterInfo.isLineTerminator(segment.charCodeAt(firstNonWhitespacePosition))) {
                return segment;
            }

            var firstNonWhitespaceColumn = TypeScript.Indentation.columnForPositionInString(segment, firstNonWhitespacePosition, this.options);

            var newFirstNonWhitespaceColumn = firstNonWhitespaceColumn + this.indentationAmount;

            var indentationString = TypeScript.Indentation.indentationString(newFirstNonWhitespaceColumn, this.options);

            return indentationString + segment.substring(firstNonWhitespacePosition);
        };

        SyntaxIndenter.prototype.indentWhitespace = function (trivia, indentThisTrivia, result) {
            if (!indentThisTrivia) {
                result.push(trivia);
                return;
            }

            var newIndentation = this.indentSegment(trivia.fullText());
            result.push(TypeScript.Syntax.whitespace(newIndentation));
        };

        SyntaxIndenter.prototype.indentSingleLineOrSkippedText = function (trivia, indentThisTrivia, result) {
            if (indentThisTrivia) {
                result.push(this.indentationTrivia);
            }

            result.push(trivia);
        };

        SyntaxIndenter.prototype.indentMultiLineComment = function (trivia, indentThisTrivia, result) {
            if (indentThisTrivia) {
                result.push(this.indentationTrivia);
            }

            var segments = TypeScript.Syntax.splitMultiLineCommentTriviaIntoMultipleLines(trivia);

            for (var i = 1; i < segments.length; i++) {
                segments[i] = this.indentSegment(segments[i]);
            }

            var newText = segments.join("");
            result.push(TypeScript.Syntax.multiLineComment(newText));
        };

        SyntaxIndenter.indentNode = function (node, indentFirstToken, indentAmount, options) {
            var indenter = new SyntaxIndenter(indentFirstToken, indentAmount, options);
            return node.accept(indenter);
        };

        SyntaxIndenter.indentNodes = function (nodes, indentFirstToken, indentAmount, options) {
            var indenter = new SyntaxIndenter(indentFirstToken, indentAmount, options);
            var result = TypeScript.ArrayUtilities.select(nodes, function (n) {
                return n.accept(indenter);
            });

            return result;
        };
        return SyntaxIndenter;
    })(TypeScript.SyntaxRewriter);
    TypeScript.SyntaxIndenter = SyntaxIndenter;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Syntax) {
        var VariableWidthTokenWithNoTrivia = (function () {
            function VariableWidthTokenWithNoTrivia(sourceText, fullStart, kind, textOrWidth) {
                this._sourceText = sourceText;
                this._fullStart = fullStart;
                this.tokenKind = kind;
                this._textOrWidth = textOrWidth;
            }
            VariableWidthTokenWithNoTrivia.prototype.clone = function () {
                return new VariableWidthTokenWithNoTrivia(this._sourceText, this._fullStart, this.tokenKind, this._textOrWidth);
            };

            VariableWidthTokenWithNoTrivia.prototype.isNode = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.isToken = function () {
                return true;
            };
            VariableWidthTokenWithNoTrivia.prototype.isList = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.isSeparatedList = function () {
                return false;
            };

            VariableWidthTokenWithNoTrivia.prototype.kind = function () {
                return this.tokenKind;
            };

            VariableWidthTokenWithNoTrivia.prototype.childCount = function () {
                return 0;
            };
            VariableWidthTokenWithNoTrivia.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange('index');
            };

            VariableWidthTokenWithNoTrivia.prototype.fullWidth = function () {
                return this.width();
            };
            VariableWidthTokenWithNoTrivia.prototype.start = function () {
                return this._fullStart;
            };
            VariableWidthTokenWithNoTrivia.prototype.end = function () {
                return this.start() + this.width();
            };

            VariableWidthTokenWithNoTrivia.prototype.width = function () {
                return typeof this._textOrWidth === 'number' ? this._textOrWidth : this._textOrWidth.length;
            };

            VariableWidthTokenWithNoTrivia.prototype.text = function () {
                if (typeof this._textOrWidth === 'number') {
                    this._textOrWidth = this._sourceText.substr(this.start(), this._textOrWidth, this.tokenKind === 11 /* IdentifierName */);
                }

                return this._textOrWidth;
            };

            VariableWidthTokenWithNoTrivia.prototype.fullText = function () {
                return this._sourceText.substr(this._fullStart, this.fullWidth(), false);
            };

            VariableWidthTokenWithNoTrivia.prototype.value = function () {
                if ((this)._value === undefined) {
                    (this)._value = Syntax.value(this);
                }

                return (this)._value;
            };

            VariableWidthTokenWithNoTrivia.prototype.valueText = function () {
                if ((this)._valueText === undefined) {
                    (this)._valueText = Syntax.valueText(this);
                }

                return (this)._valueText;
            };

            VariableWidthTokenWithNoTrivia.prototype.hasLeadingTrivia = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.hasLeadingComment = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.hasLeadingNewLine = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.hasLeadingSkippedText = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.leadingTriviaWidth = function () {
                return 0;
            };
            VariableWidthTokenWithNoTrivia.prototype.leadingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };

            VariableWidthTokenWithNoTrivia.prototype.hasTrailingTrivia = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.hasTrailingComment = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.hasTrailingNewLine = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.hasTrailingSkippedText = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.trailingTriviaWidth = function () {
                return 0;
            };
            VariableWidthTokenWithNoTrivia.prototype.trailingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };

            VariableWidthTokenWithNoTrivia.prototype.hasSkippedToken = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.toJSON = function (key) {
                return Syntax.tokenToJSON(this);
            };
            VariableWidthTokenWithNoTrivia.prototype.firstToken = function () {
                return this;
            };
            VariableWidthTokenWithNoTrivia.prototype.lastToken = function () {
                return this;
            };
            VariableWidthTokenWithNoTrivia.prototype.isTypeScriptSpecific = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.isIncrementallyUnusable = function () {
                return this.fullWidth() === 0 || TypeScript.SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
            };
            VariableWidthTokenWithNoTrivia.prototype.accept = function (visitor) {
                return visitor.visitToken(this);
            };
            VariableWidthTokenWithNoTrivia.prototype.realize = function () {
                return Syntax.realizeToken(this);
            };
            VariableWidthTokenWithNoTrivia.prototype.collectTextElements = function (elements) {
                collectTokenTextElements(this, elements);
            };

            VariableWidthTokenWithNoTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };

            VariableWidthTokenWithNoTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };

            VariableWidthTokenWithNoTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };
            return VariableWidthTokenWithNoTrivia;
        })();
        Syntax.VariableWidthTokenWithNoTrivia = VariableWidthTokenWithNoTrivia;

        var VariableWidthTokenWithLeadingTrivia = (function () {
            function VariableWidthTokenWithLeadingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, textOrWidth) {
                this._sourceText = sourceText;
                this._fullStart = fullStart;
                this.tokenKind = kind;
                this._leadingTriviaInfo = leadingTriviaInfo;
                this._textOrWidth = textOrWidth;
            }
            VariableWidthTokenWithLeadingTrivia.prototype.clone = function () {
                return new VariableWidthTokenWithLeadingTrivia(this._sourceText, this._fullStart, this.tokenKind, this._leadingTriviaInfo, this._textOrWidth);
            };

            VariableWidthTokenWithLeadingTrivia.prototype.isNode = function () {
                return false;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.isToken = function () {
                return true;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.isList = function () {
                return false;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.isSeparatedList = function () {
                return false;
            };

            VariableWidthTokenWithLeadingTrivia.prototype.kind = function () {
                return this.tokenKind;
            };

            VariableWidthTokenWithLeadingTrivia.prototype.childCount = function () {
                return 0;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange('index');
            };

            VariableWidthTokenWithLeadingTrivia.prototype.fullWidth = function () {
                return getTriviaWidth(this._leadingTriviaInfo) + this.width();
            };
            VariableWidthTokenWithLeadingTrivia.prototype.start = function () {
                return this._fullStart + getTriviaWidth(this._leadingTriviaInfo);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.end = function () {
                return this.start() + this.width();
            };

            VariableWidthTokenWithLeadingTrivia.prototype.width = function () {
                return typeof this._textOrWidth === 'number' ? this._textOrWidth : this._textOrWidth.length;
            };

            VariableWidthTokenWithLeadingTrivia.prototype.text = function () {
                if (typeof this._textOrWidth === 'number') {
                    this._textOrWidth = this._sourceText.substr(this.start(), this._textOrWidth, this.tokenKind === 11 /* IdentifierName */);
                }

                return this._textOrWidth;
            };

            VariableWidthTokenWithLeadingTrivia.prototype.fullText = function () {
                return this._sourceText.substr(this._fullStart, this.fullWidth(), false);
            };

            VariableWidthTokenWithLeadingTrivia.prototype.value = function () {
                if ((this)._value === undefined) {
                    (this)._value = Syntax.value(this);
                }

                return (this)._value;
            };

            VariableWidthTokenWithLeadingTrivia.prototype.valueText = function () {
                if ((this)._valueText === undefined) {
                    (this)._valueText = Syntax.valueText(this);
                }

                return (this)._valueText;
            };

            VariableWidthTokenWithLeadingTrivia.prototype.hasLeadingTrivia = function () {
                return true;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.hasLeadingComment = function () {
                return hasTriviaComment(this._leadingTriviaInfo);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.hasLeadingNewLine = function () {
                return hasTriviaNewLine(this._leadingTriviaInfo);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.hasLeadingSkippedText = function () {
                return false;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.leadingTriviaWidth = function () {
                return getTriviaWidth(this._leadingTriviaInfo);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.leadingTrivia = function () {
                return TypeScript.Scanner.scanTrivia(this._sourceText, this._fullStart, getTriviaWidth(this._leadingTriviaInfo), false);
            };

            VariableWidthTokenWithLeadingTrivia.prototype.hasTrailingTrivia = function () {
                return false;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.hasTrailingComment = function () {
                return false;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.hasTrailingNewLine = function () {
                return false;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.hasTrailingSkippedText = function () {
                return false;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.trailingTriviaWidth = function () {
                return 0;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.trailingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };

            VariableWidthTokenWithLeadingTrivia.prototype.hasSkippedToken = function () {
                return false;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.toJSON = function (key) {
                return Syntax.tokenToJSON(this);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.firstToken = function () {
                return this;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.lastToken = function () {
                return this;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.isTypeScriptSpecific = function () {
                return false;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.isIncrementallyUnusable = function () {
                return this.fullWidth() === 0 || TypeScript.SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.accept = function (visitor) {
                return visitor.visitToken(this);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.realize = function () {
                return Syntax.realizeToken(this);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.collectTextElements = function (elements) {
                collectTokenTextElements(this, elements);
            };

            VariableWidthTokenWithLeadingTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };

            VariableWidthTokenWithLeadingTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };

            VariableWidthTokenWithLeadingTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };
            return VariableWidthTokenWithLeadingTrivia;
        })();
        Syntax.VariableWidthTokenWithLeadingTrivia = VariableWidthTokenWithLeadingTrivia;

        var VariableWidthTokenWithTrailingTrivia = (function () {
            function VariableWidthTokenWithTrailingTrivia(sourceText, fullStart, kind, textOrWidth, trailingTriviaInfo) {
                this._sourceText = sourceText;
                this._fullStart = fullStart;
                this.tokenKind = kind;
                this._textOrWidth = textOrWidth;
                this._trailingTriviaInfo = trailingTriviaInfo;
            }
            VariableWidthTokenWithTrailingTrivia.prototype.clone = function () {
                return new VariableWidthTokenWithTrailingTrivia(this._sourceText, this._fullStart, this.tokenKind, this._textOrWidth, this._trailingTriviaInfo);
            };

            VariableWidthTokenWithTrailingTrivia.prototype.isNode = function () {
                return false;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.isToken = function () {
                return true;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.isList = function () {
                return false;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.isSeparatedList = function () {
                return false;
            };

            VariableWidthTokenWithTrailingTrivia.prototype.kind = function () {
                return this.tokenKind;
            };

            VariableWidthTokenWithTrailingTrivia.prototype.childCount = function () {
                return 0;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange('index');
            };

            VariableWidthTokenWithTrailingTrivia.prototype.fullWidth = function () {
                return this.width() + getTriviaWidth(this._trailingTriviaInfo);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.start = function () {
                return this._fullStart;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.end = function () {
                return this.start() + this.width();
            };

            VariableWidthTokenWithTrailingTrivia.prototype.width = function () {
                return typeof this._textOrWidth === 'number' ? this._textOrWidth : this._textOrWidth.length;
            };

            VariableWidthTokenWithTrailingTrivia.prototype.text = function () {
                if (typeof this._textOrWidth === 'number') {
                    this._textOrWidth = this._sourceText.substr(this.start(), this._textOrWidth, this.tokenKind === 11 /* IdentifierName */);
                }

                return this._textOrWidth;
            };

            VariableWidthTokenWithTrailingTrivia.prototype.fullText = function () {
                return this._sourceText.substr(this._fullStart, this.fullWidth(), false);
            };

            VariableWidthTokenWithTrailingTrivia.prototype.value = function () {
                if ((this)._value === undefined) {
                    (this)._value = Syntax.value(this);
                }

                return (this)._value;
            };

            VariableWidthTokenWithTrailingTrivia.prototype.valueText = function () {
                if ((this)._valueText === undefined) {
                    (this)._valueText = Syntax.valueText(this);
                }

                return (this)._valueText;
            };

            VariableWidthTokenWithTrailingTrivia.prototype.hasLeadingTrivia = function () {
                return false;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.hasLeadingComment = function () {
                return false;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.hasLeadingNewLine = function () {
                return false;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.hasLeadingSkippedText = function () {
                return false;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.leadingTriviaWidth = function () {
                return 0;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.leadingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };

            VariableWidthTokenWithTrailingTrivia.prototype.hasTrailingTrivia = function () {
                return true;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.hasTrailingComment = function () {
                return hasTriviaComment(this._trailingTriviaInfo);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.hasTrailingNewLine = function () {
                return hasTriviaNewLine(this._trailingTriviaInfo);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.hasTrailingSkippedText = function () {
                return false;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.trailingTriviaWidth = function () {
                return getTriviaWidth(this._trailingTriviaInfo);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.trailingTrivia = function () {
                return TypeScript.Scanner.scanTrivia(this._sourceText, this.end(), getTriviaWidth(this._trailingTriviaInfo), true);
            };

            VariableWidthTokenWithTrailingTrivia.prototype.hasSkippedToken = function () {
                return false;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.toJSON = function (key) {
                return Syntax.tokenToJSON(this);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.firstToken = function () {
                return this;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.lastToken = function () {
                return this;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.isTypeScriptSpecific = function () {
                return false;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.isIncrementallyUnusable = function () {
                return this.fullWidth() === 0 || TypeScript.SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.accept = function (visitor) {
                return visitor.visitToken(this);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.realize = function () {
                return Syntax.realizeToken(this);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.collectTextElements = function (elements) {
                collectTokenTextElements(this, elements);
            };

            VariableWidthTokenWithTrailingTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };

            VariableWidthTokenWithTrailingTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };

            VariableWidthTokenWithTrailingTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };
            return VariableWidthTokenWithTrailingTrivia;
        })();
        Syntax.VariableWidthTokenWithTrailingTrivia = VariableWidthTokenWithTrailingTrivia;

        var VariableWidthTokenWithLeadingAndTrailingTrivia = (function () {
            function VariableWidthTokenWithLeadingAndTrailingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, textOrWidth, trailingTriviaInfo) {
                this._sourceText = sourceText;
                this._fullStart = fullStart;
                this.tokenKind = kind;
                this._leadingTriviaInfo = leadingTriviaInfo;
                this._textOrWidth = textOrWidth;
                this._trailingTriviaInfo = trailingTriviaInfo;
            }
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.clone = function () {
                return new VariableWidthTokenWithLeadingAndTrailingTrivia(this._sourceText, this._fullStart, this.tokenKind, this._leadingTriviaInfo, this._textOrWidth, this._trailingTriviaInfo);
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isNode = function () {
                return false;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isToken = function () {
                return true;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isList = function () {
                return false;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isSeparatedList = function () {
                return false;
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.kind = function () {
                return this.tokenKind;
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.childCount = function () {
                return 0;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange('index');
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.fullWidth = function () {
                return getTriviaWidth(this._leadingTriviaInfo) + this.width() + getTriviaWidth(this._trailingTriviaInfo);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.start = function () {
                return this._fullStart + getTriviaWidth(this._leadingTriviaInfo);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.end = function () {
                return this.start() + this.width();
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.width = function () {
                return typeof this._textOrWidth === 'number' ? this._textOrWidth : this._textOrWidth.length;
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.text = function () {
                if (typeof this._textOrWidth === 'number') {
                    this._textOrWidth = this._sourceText.substr(this.start(), this._textOrWidth, this.tokenKind === 11 /* IdentifierName */);
                }

                return this._textOrWidth;
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.fullText = function () {
                return this._sourceText.substr(this._fullStart, this.fullWidth(), false);
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.value = function () {
                if ((this)._value === undefined) {
                    (this)._value = Syntax.value(this);
                }

                return (this)._value;
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.valueText = function () {
                if ((this)._valueText === undefined) {
                    (this)._valueText = Syntax.valueText(this);
                }

                return (this)._valueText;
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingTrivia = function () {
                return true;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingComment = function () {
                return hasTriviaComment(this._leadingTriviaInfo);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingNewLine = function () {
                return hasTriviaNewLine(this._leadingTriviaInfo);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingSkippedText = function () {
                return false;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.leadingTriviaWidth = function () {
                return getTriviaWidth(this._leadingTriviaInfo);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.leadingTrivia = function () {
                return TypeScript.Scanner.scanTrivia(this._sourceText, this._fullStart, getTriviaWidth(this._leadingTriviaInfo), false);
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingTrivia = function () {
                return true;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingComment = function () {
                return hasTriviaComment(this._trailingTriviaInfo);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingNewLine = function () {
                return hasTriviaNewLine(this._trailingTriviaInfo);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingSkippedText = function () {
                return false;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.trailingTriviaWidth = function () {
                return getTriviaWidth(this._trailingTriviaInfo);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.trailingTrivia = function () {
                return TypeScript.Scanner.scanTrivia(this._sourceText, this.end(), getTriviaWidth(this._trailingTriviaInfo), true);
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasSkippedToken = function () {
                return false;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.toJSON = function (key) {
                return Syntax.tokenToJSON(this);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.firstToken = function () {
                return this;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.lastToken = function () {
                return this;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isTypeScriptSpecific = function () {
                return false;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isIncrementallyUnusable = function () {
                return this.fullWidth() === 0 || TypeScript.SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.accept = function (visitor) {
                return visitor.visitToken(this);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.realize = function () {
                return Syntax.realizeToken(this);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.collectTextElements = function (elements) {
                collectTokenTextElements(this, elements);
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };
            return VariableWidthTokenWithLeadingAndTrailingTrivia;
        })();
        Syntax.VariableWidthTokenWithLeadingAndTrailingTrivia = VariableWidthTokenWithLeadingAndTrailingTrivia;

        var FixedWidthTokenWithNoTrivia = (function () {
            function FixedWidthTokenWithNoTrivia(kind) {
                this.tokenKind = kind;
            }
            FixedWidthTokenWithNoTrivia.prototype.clone = function () {
                return new FixedWidthTokenWithNoTrivia(this.tokenKind);
            };

            FixedWidthTokenWithNoTrivia.prototype.isNode = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.isToken = function () {
                return true;
            };
            FixedWidthTokenWithNoTrivia.prototype.isList = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.isSeparatedList = function () {
                return false;
            };

            FixedWidthTokenWithNoTrivia.prototype.kind = function () {
                return this.tokenKind;
            };

            FixedWidthTokenWithNoTrivia.prototype.childCount = function () {
                return 0;
            };
            FixedWidthTokenWithNoTrivia.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange('index');
            };

            FixedWidthTokenWithNoTrivia.prototype.fullWidth = function () {
                return this.width();
            };
            FixedWidthTokenWithNoTrivia.prototype.width = function () {
                return this.text().length;
            };
            FixedWidthTokenWithNoTrivia.prototype.text = function () {
                return TypeScript.SyntaxFacts.getText(this.tokenKind);
            };
            FixedWidthTokenWithNoTrivia.prototype.fullText = function () {
                return this.text();
            };

            FixedWidthTokenWithNoTrivia.prototype.value = function () {
                return Syntax.value(this);
            };
            FixedWidthTokenWithNoTrivia.prototype.valueText = function () {
                return Syntax.valueText(this);
            };
            FixedWidthTokenWithNoTrivia.prototype.hasLeadingTrivia = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.hasLeadingComment = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.hasLeadingNewLine = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.hasLeadingSkippedText = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.leadingTriviaWidth = function () {
                return 0;
            };
            FixedWidthTokenWithNoTrivia.prototype.leadingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };

            FixedWidthTokenWithNoTrivia.prototype.hasTrailingTrivia = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.hasTrailingComment = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.hasTrailingNewLine = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.hasTrailingSkippedText = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.trailingTriviaWidth = function () {
                return 0;
            };
            FixedWidthTokenWithNoTrivia.prototype.trailingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };

            FixedWidthTokenWithNoTrivia.prototype.hasSkippedToken = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.toJSON = function (key) {
                return Syntax.tokenToJSON(this);
            };
            FixedWidthTokenWithNoTrivia.prototype.firstToken = function () {
                return this;
            };
            FixedWidthTokenWithNoTrivia.prototype.lastToken = function () {
                return this;
            };
            FixedWidthTokenWithNoTrivia.prototype.isTypeScriptSpecific = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.isIncrementallyUnusable = function () {
                return this.fullWidth() === 0 || TypeScript.SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
            };
            FixedWidthTokenWithNoTrivia.prototype.accept = function (visitor) {
                return visitor.visitToken(this);
            };
            FixedWidthTokenWithNoTrivia.prototype.realize = function () {
                return Syntax.realizeToken(this);
            };
            FixedWidthTokenWithNoTrivia.prototype.collectTextElements = function (elements) {
                collectTokenTextElements(this, elements);
            };

            FixedWidthTokenWithNoTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };

            FixedWidthTokenWithNoTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };

            FixedWidthTokenWithNoTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };
            return FixedWidthTokenWithNoTrivia;
        })();
        Syntax.FixedWidthTokenWithNoTrivia = FixedWidthTokenWithNoTrivia;

        var FixedWidthTokenWithLeadingTrivia = (function () {
            function FixedWidthTokenWithLeadingTrivia(sourceText, fullStart, kind, leadingTriviaInfo) {
                this._sourceText = sourceText;
                this._fullStart = fullStart;
                this.tokenKind = kind;
                this._leadingTriviaInfo = leadingTriviaInfo;
            }
            FixedWidthTokenWithLeadingTrivia.prototype.clone = function () {
                return new FixedWidthTokenWithLeadingTrivia(this._sourceText, this._fullStart, this.tokenKind, this._leadingTriviaInfo);
            };

            FixedWidthTokenWithLeadingTrivia.prototype.isNode = function () {
                return false;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.isToken = function () {
                return true;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.isList = function () {
                return false;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.isSeparatedList = function () {
                return false;
            };

            FixedWidthTokenWithLeadingTrivia.prototype.kind = function () {
                return this.tokenKind;
            };

            FixedWidthTokenWithLeadingTrivia.prototype.childCount = function () {
                return 0;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange('index');
            };

            FixedWidthTokenWithLeadingTrivia.prototype.fullWidth = function () {
                return getTriviaWidth(this._leadingTriviaInfo) + this.width();
            };
            FixedWidthTokenWithLeadingTrivia.prototype.start = function () {
                return this._fullStart + getTriviaWidth(this._leadingTriviaInfo);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.end = function () {
                return this.start() + this.width();
            };

            FixedWidthTokenWithLeadingTrivia.prototype.width = function () {
                return this.text().length;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.text = function () {
                return TypeScript.SyntaxFacts.getText(this.tokenKind);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.fullText = function () {
                return this._sourceText.substr(this._fullStart, this.fullWidth(), false);
            };

            FixedWidthTokenWithLeadingTrivia.prototype.value = function () {
                return Syntax.value(this);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.valueText = function () {
                return Syntax.valueText(this);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.hasLeadingTrivia = function () {
                return true;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.hasLeadingComment = function () {
                return hasTriviaComment(this._leadingTriviaInfo);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.hasLeadingNewLine = function () {
                return hasTriviaNewLine(this._leadingTriviaInfo);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.hasLeadingSkippedText = function () {
                return false;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.leadingTriviaWidth = function () {
                return getTriviaWidth(this._leadingTriviaInfo);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.leadingTrivia = function () {
                return TypeScript.Scanner.scanTrivia(this._sourceText, this._fullStart, getTriviaWidth(this._leadingTriviaInfo), false);
            };

            FixedWidthTokenWithLeadingTrivia.prototype.hasTrailingTrivia = function () {
                return false;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.hasTrailingComment = function () {
                return false;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.hasTrailingNewLine = function () {
                return false;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.hasTrailingSkippedText = function () {
                return false;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.trailingTriviaWidth = function () {
                return 0;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.trailingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };

            FixedWidthTokenWithLeadingTrivia.prototype.hasSkippedToken = function () {
                return false;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.toJSON = function (key) {
                return Syntax.tokenToJSON(this);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.firstToken = function () {
                return this;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.lastToken = function () {
                return this;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.isTypeScriptSpecific = function () {
                return false;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.isIncrementallyUnusable = function () {
                return this.fullWidth() === 0 || TypeScript.SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.accept = function (visitor) {
                return visitor.visitToken(this);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.realize = function () {
                return Syntax.realizeToken(this);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.collectTextElements = function (elements) {
                collectTokenTextElements(this, elements);
            };

            FixedWidthTokenWithLeadingTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };

            FixedWidthTokenWithLeadingTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };

            FixedWidthTokenWithLeadingTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };
            return FixedWidthTokenWithLeadingTrivia;
        })();
        Syntax.FixedWidthTokenWithLeadingTrivia = FixedWidthTokenWithLeadingTrivia;

        var FixedWidthTokenWithTrailingTrivia = (function () {
            function FixedWidthTokenWithTrailingTrivia(sourceText, fullStart, kind, trailingTriviaInfo) {
                this._sourceText = sourceText;
                this._fullStart = fullStart;
                this.tokenKind = kind;
                this._trailingTriviaInfo = trailingTriviaInfo;
            }
            FixedWidthTokenWithTrailingTrivia.prototype.clone = function () {
                return new FixedWidthTokenWithTrailingTrivia(this._sourceText, this._fullStart, this.tokenKind, this._trailingTriviaInfo);
            };

            FixedWidthTokenWithTrailingTrivia.prototype.isNode = function () {
                return false;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.isToken = function () {
                return true;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.isList = function () {
                return false;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.isSeparatedList = function () {
                return false;
            };

            FixedWidthTokenWithTrailingTrivia.prototype.kind = function () {
                return this.tokenKind;
            };

            FixedWidthTokenWithTrailingTrivia.prototype.childCount = function () {
                return 0;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange('index');
            };

            FixedWidthTokenWithTrailingTrivia.prototype.fullWidth = function () {
                return this.width() + getTriviaWidth(this._trailingTriviaInfo);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.start = function () {
                return this._fullStart;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.end = function () {
                return this.start() + this.width();
            };

            FixedWidthTokenWithTrailingTrivia.prototype.width = function () {
                return this.text().length;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.text = function () {
                return TypeScript.SyntaxFacts.getText(this.tokenKind);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.fullText = function () {
                return this._sourceText.substr(this._fullStart, this.fullWidth(), false);
            };

            FixedWidthTokenWithTrailingTrivia.prototype.value = function () {
                return Syntax.value(this);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.valueText = function () {
                return Syntax.valueText(this);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.hasLeadingTrivia = function () {
                return false;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.hasLeadingComment = function () {
                return false;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.hasLeadingNewLine = function () {
                return false;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.hasLeadingSkippedText = function () {
                return false;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.leadingTriviaWidth = function () {
                return 0;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.leadingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };

            FixedWidthTokenWithTrailingTrivia.prototype.hasTrailingTrivia = function () {
                return true;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.hasTrailingComment = function () {
                return hasTriviaComment(this._trailingTriviaInfo);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.hasTrailingNewLine = function () {
                return hasTriviaNewLine(this._trailingTriviaInfo);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.hasTrailingSkippedText = function () {
                return false;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.trailingTriviaWidth = function () {
                return getTriviaWidth(this._trailingTriviaInfo);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.trailingTrivia = function () {
                return TypeScript.Scanner.scanTrivia(this._sourceText, this.end(), getTriviaWidth(this._trailingTriviaInfo), true);
            };

            FixedWidthTokenWithTrailingTrivia.prototype.hasSkippedToken = function () {
                return false;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.toJSON = function (key) {
                return Syntax.tokenToJSON(this);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.firstToken = function () {
                return this;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.lastToken = function () {
                return this;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.isTypeScriptSpecific = function () {
                return false;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.isIncrementallyUnusable = function () {
                return this.fullWidth() === 0 || TypeScript.SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.accept = function (visitor) {
                return visitor.visitToken(this);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.realize = function () {
                return Syntax.realizeToken(this);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.collectTextElements = function (elements) {
                collectTokenTextElements(this, elements);
            };

            FixedWidthTokenWithTrailingTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };

            FixedWidthTokenWithTrailingTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };

            FixedWidthTokenWithTrailingTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };
            return FixedWidthTokenWithTrailingTrivia;
        })();
        Syntax.FixedWidthTokenWithTrailingTrivia = FixedWidthTokenWithTrailingTrivia;

        var FixedWidthTokenWithLeadingAndTrailingTrivia = (function () {
            function FixedWidthTokenWithLeadingAndTrailingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, trailingTriviaInfo) {
                this._sourceText = sourceText;
                this._fullStart = fullStart;
                this.tokenKind = kind;
                this._leadingTriviaInfo = leadingTriviaInfo;
                this._trailingTriviaInfo = trailingTriviaInfo;
            }
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.clone = function () {
                return new FixedWidthTokenWithLeadingAndTrailingTrivia(this._sourceText, this._fullStart, this.tokenKind, this._leadingTriviaInfo, this._trailingTriviaInfo);
            };

            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isNode = function () {
                return false;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isToken = function () {
                return true;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isList = function () {
                return false;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isSeparatedList = function () {
                return false;
            };

            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.kind = function () {
                return this.tokenKind;
            };

            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.childCount = function () {
                return 0;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange('index');
            };

            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.fullWidth = function () {
                return getTriviaWidth(this._leadingTriviaInfo) + this.width() + getTriviaWidth(this._trailingTriviaInfo);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.start = function () {
                return this._fullStart + getTriviaWidth(this._leadingTriviaInfo);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.end = function () {
                return this.start() + this.width();
            };

            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.width = function () {
                return this.text().length;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.text = function () {
                return TypeScript.SyntaxFacts.getText(this.tokenKind);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.fullText = function () {
                return this._sourceText.substr(this._fullStart, this.fullWidth(), false);
            };

            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.value = function () {
                return Syntax.value(this);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.valueText = function () {
                return Syntax.valueText(this);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingTrivia = function () {
                return true;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingComment = function () {
                return hasTriviaComment(this._leadingTriviaInfo);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingNewLine = function () {
                return hasTriviaNewLine(this._leadingTriviaInfo);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingSkippedText = function () {
                return false;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.leadingTriviaWidth = function () {
                return getTriviaWidth(this._leadingTriviaInfo);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.leadingTrivia = function () {
                return TypeScript.Scanner.scanTrivia(this._sourceText, this._fullStart, getTriviaWidth(this._leadingTriviaInfo), false);
            };

            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingTrivia = function () {
                return true;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingComment = function () {
                return hasTriviaComment(this._trailingTriviaInfo);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingNewLine = function () {
                return hasTriviaNewLine(this._trailingTriviaInfo);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingSkippedText = function () {
                return false;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.trailingTriviaWidth = function () {
                return getTriviaWidth(this._trailingTriviaInfo);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.trailingTrivia = function () {
                return TypeScript.Scanner.scanTrivia(this._sourceText, this.end(), getTriviaWidth(this._trailingTriviaInfo), true);
            };

            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasSkippedToken = function () {
                return false;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.toJSON = function (key) {
                return Syntax.tokenToJSON(this);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.firstToken = function () {
                return this;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.lastToken = function () {
                return this;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isTypeScriptSpecific = function () {
                return false;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isIncrementallyUnusable = function () {
                return this.fullWidth() === 0 || TypeScript.SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.accept = function (visitor) {
                return visitor.visitToken(this);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.realize = function () {
                return Syntax.realizeToken(this);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.collectTextElements = function (elements) {
                collectTokenTextElements(this, elements);
            };

            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };

            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };

            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };
            return FixedWidthTokenWithLeadingAndTrailingTrivia;
        })();
        Syntax.FixedWidthTokenWithLeadingAndTrailingTrivia = FixedWidthTokenWithLeadingAndTrailingTrivia;

        function collectTokenTextElements(token, elements) {
            token.leadingTrivia().collectTextElements(elements);
            elements.push(token.text());
            token.trailingTrivia().collectTextElements(elements);
        }

        function fixedWidthToken(sourceText, fullStart, kind, leadingTriviaInfo, trailingTriviaInfo) {
            if (leadingTriviaInfo === 0) {
                if (trailingTriviaInfo === 0) {
                    return new FixedWidthTokenWithNoTrivia(kind);
                } else {
                    return new FixedWidthTokenWithTrailingTrivia(sourceText, fullStart, kind, trailingTriviaInfo);
                }
            } else if (trailingTriviaInfo === 0) {
                return new FixedWidthTokenWithLeadingTrivia(sourceText, fullStart, kind, leadingTriviaInfo);
            } else {
                return new FixedWidthTokenWithLeadingAndTrailingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, trailingTriviaInfo);
            }
        }
        Syntax.fixedWidthToken = fixedWidthToken;

        function variableWidthToken(sourceText, fullStart, kind, leadingTriviaInfo, width, trailingTriviaInfo) {
            if (leadingTriviaInfo === 0) {
                if (trailingTriviaInfo === 0) {
                    return new VariableWidthTokenWithNoTrivia(sourceText, fullStart, kind, width);
                } else {
                    return new VariableWidthTokenWithTrailingTrivia(sourceText, fullStart, kind, width, trailingTriviaInfo);
                }
            } else if (trailingTriviaInfo === 0) {
                return new VariableWidthTokenWithLeadingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, width);
            } else {
                return new VariableWidthTokenWithLeadingAndTrailingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, width, trailingTriviaInfo);
            }
        }
        Syntax.variableWidthToken = variableWidthToken;

        function getTriviaWidth(value) {
            return value >>> 2 /* TriviaFullWidthShift */;
        }

        function hasTriviaComment(value) {
            return (value & 2 /* TriviaCommentMask */) !== 0;
        }

        function hasTriviaNewLine(value) {
            return (value & 1 /* TriviaNewLineMask */) !== 0;
        }
    })(TypeScript.Syntax || (TypeScript.Syntax = {}));
    var Syntax = TypeScript.Syntax;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Syntax) {
        function realizeToken(token) {
            return new RealizedToken(token.tokenKind, token.leadingTrivia(), token.text(), token.value(), token.valueText(), token.trailingTrivia());
        }
        Syntax.realizeToken = realizeToken;

        function convertToIdentifierName(token) {
            TypeScript.Debug.assert(TypeScript.SyntaxFacts.isAnyKeyword(token.tokenKind));
            return new RealizedToken(11 /* IdentifierName */, token.leadingTrivia(), token.text(), token.text(), token.text(), token.trailingTrivia());
        }
        Syntax.convertToIdentifierName = convertToIdentifierName;

        function tokenToJSON(token) {
            var result = {};

            for (var name in TypeScript.SyntaxKind) {
                if (TypeScript.SyntaxKind[name] === token.kind()) {
                    result.kind = name;
                    break;
                }
            }

            result.width = token.width();
            if (token.fullWidth() !== token.width()) {
                result.fullWidth = token.fullWidth();
            }

            result.text = token.text();

            var value = token.value();
            if (value !== null) {
                result.value = value;
                result.valueText = token.valueText();
            }

            if (token.hasLeadingTrivia()) {
                result.hasLeadingTrivia = true;
            }

            if (token.hasLeadingComment()) {
                result.hasLeadingComment = true;
            }

            if (token.hasLeadingNewLine()) {
                result.hasLeadingNewLine = true;
            }

            if (token.hasLeadingSkippedText()) {
                result.hasLeadingSkippedText = true;
            }

            if (token.hasTrailingTrivia()) {
                result.hasTrailingTrivia = true;
            }

            if (token.hasTrailingComment()) {
                result.hasTrailingComment = true;
            }

            if (token.hasTrailingNewLine()) {
                result.hasTrailingNewLine = true;
            }

            if (token.hasTrailingSkippedText()) {
                result.hasTrailingSkippedText = true;
            }

            var trivia = token.leadingTrivia();
            if (trivia.count() > 0) {
                result.leadingTrivia = trivia;
            }

            trivia = token.trailingTrivia();
            if (trivia.count() > 0) {
                result.trailingTrivia = trivia;
            }

            return result;
        }
        Syntax.tokenToJSON = tokenToJSON;

        function value(token) {
            return value1(token.tokenKind, token.text());
        }
        Syntax.value = value;

        function hexValue(text, start, length) {
            var intChar = 0;
            for (var i = 0; i < length; i++) {
                var ch2 = text.charCodeAt(start + i);
                if (!TypeScript.CharacterInfo.isHexDigit(ch2)) {
                    break;
                }

                intChar = (intChar << 4) + TypeScript.CharacterInfo.hexValue(ch2);
            }

            return intChar;
        }

        var characterArray = [];

        function convertEscapes(text) {
            characterArray.length = 0;
            var result = "";

            for (var i = 0, n = text.length; i < n; i++) {
                var ch = text.charCodeAt(i);

                if (ch === 92 /* backslash */) {
                    i++;
                    if (i < n) {
                        ch = text.charCodeAt(i);
                        switch (ch) {
                            case 48 /* _0 */:
                                characterArray.push(0 /* nullCharacter */);
                                continue;

                            case 98 /* b */:
                                characterArray.push(8 /* backspace */);
                                continue;

                            case 102 /* f */:
                                characterArray.push(12 /* formFeed */);
                                continue;

                            case 110 /* n */:
                                characterArray.push(10 /* lineFeed */);
                                continue;

                            case 114 /* r */:
                                characterArray.push(13 /* carriageReturn */);
                                continue;

                            case 116 /* t */:
                                characterArray.push(9 /* tab */);
                                continue;

                            case 118 /* v */:
                                characterArray.push(11 /* verticalTab */);
                                continue;

                            case 120 /* x */:
                                characterArray.push(hexValue(text, i + 1, 2));
                                i += 2;
                                continue;

                            case 117 /* u */:
                                characterArray.push(hexValue(text, i + 1, 4));
                                i += 4;
                                continue;

                            default:
                        }
                    }
                }

                characterArray.push(ch);

                if (i && !(i % 1024)) {
                    result = result.concat(String.fromCharCode.apply(null, characterArray));
                    characterArray.length = 0;
                }
            }

            if (characterArray.length) {
                result = result.concat(String.fromCharCode.apply(null, characterArray));
            }

            return result;
        }

        function massageEscapes(text) {
            return text.indexOf("\\") >= 0 ? convertEscapes(text) : text;
        }

        function value1(kind, text) {
            if (kind === 11 /* IdentifierName */) {
                return massageEscapes(text);
            }

            switch (kind) {
                case 37 /* TrueKeyword */:
                    return true;
                case 24 /* FalseKeyword */:
                    return false;
                case 32 /* NullKeyword */:
                    return null;
            }

            if (TypeScript.SyntaxFacts.isAnyKeyword(kind) || TypeScript.SyntaxFacts.isAnyPunctuation(kind)) {
                return TypeScript.SyntaxFacts.getText(kind);
            }

            if (kind === 13 /* NumericLiteral */) {
                return parseFloat(text);
            } else if (kind === 14 /* StringLiteral */) {
                if (text.length > 1 && text.charCodeAt(text.length - 1) === text.charCodeAt(0)) {
                    return massageEscapes(text.substr(1, text.length - 2));
                } else {
                    return massageEscapes(text.substr(1));
                }
            } else if (kind === 12 /* RegularExpressionLiteral */) {
                try  {
                    var lastSlash = text.lastIndexOf("/");
                    var body = text.substring(1, lastSlash);
                    var flags = text.substring(lastSlash + 1);
                    return new RegExp(body, flags);
                } catch (e) {
                    return null;
                }
            } else if (kind === 10 /* EndOfFileToken */ || kind === 9 /* ErrorToken */) {
                return null;
            } else {
                throw TypeScript.Errors.invalidOperation();
            }
        }

        function valueText1(kind, text) {
            var value = value1(kind, text);
            return value === null ? "" : value.toString();
        }

        function valueText(token) {
            var value = token.value();
            return value === null ? "" : value.toString();
        }
        Syntax.valueText = valueText;

        var EmptyToken = (function () {
            function EmptyToken(kind) {
                this.tokenKind = kind;
            }
            EmptyToken.prototype.clone = function () {
                return new EmptyToken(this.tokenKind);
            };

            EmptyToken.prototype.kind = function () {
                return this.tokenKind;
            };

            EmptyToken.prototype.isToken = function () {
                return true;
            };
            EmptyToken.prototype.isNode = function () {
                return false;
            };
            EmptyToken.prototype.isList = function () {
                return false;
            };
            EmptyToken.prototype.isSeparatedList = function () {
                return false;
            };

            EmptyToken.prototype.childCount = function () {
                return 0;
            };

            EmptyToken.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            };

            EmptyToken.prototype.toJSON = function (key) {
                return tokenToJSON(this);
            };
            EmptyToken.prototype.accept = function (visitor) {
                return visitor.visitToken(this);
            };

            EmptyToken.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };

            EmptyToken.prototype.firstToken = function () {
                return this;
            };
            EmptyToken.prototype.lastToken = function () {
                return this;
            };
            EmptyToken.prototype.isTypeScriptSpecific = function () {
                return false;
            };

            EmptyToken.prototype.isIncrementallyUnusable = function () {
                return true;
            };

            EmptyToken.prototype.fullWidth = function () {
                return 0;
            };
            EmptyToken.prototype.width = function () {
                return 0;
            };
            EmptyToken.prototype.text = function () {
                return "";
            };
            EmptyToken.prototype.fullText = function () {
                return "";
            };
            EmptyToken.prototype.value = function () {
                return null;
            };
            EmptyToken.prototype.valueText = function () {
                return "";
            };

            EmptyToken.prototype.hasLeadingTrivia = function () {
                return false;
            };
            EmptyToken.prototype.hasLeadingComment = function () {
                return false;
            };
            EmptyToken.prototype.hasLeadingNewLine = function () {
                return false;
            };
            EmptyToken.prototype.hasLeadingSkippedText = function () {
                return false;
            };
            EmptyToken.prototype.leadingTriviaWidth = function () {
                return 0;
            };
            EmptyToken.prototype.hasTrailingTrivia = function () {
                return false;
            };
            EmptyToken.prototype.hasTrailingComment = function () {
                return false;
            };
            EmptyToken.prototype.hasTrailingNewLine = function () {
                return false;
            };
            EmptyToken.prototype.hasTrailingSkippedText = function () {
                return false;
            };
            EmptyToken.prototype.hasSkippedToken = function () {
                return false;
            };

            EmptyToken.prototype.trailingTriviaWidth = function () {
                return 0;
            };
            EmptyToken.prototype.leadingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };
            EmptyToken.prototype.trailingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };
            EmptyToken.prototype.realize = function () {
                return realizeToken(this);
            };
            EmptyToken.prototype.collectTextElements = function (elements) {
            };

            EmptyToken.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };

            EmptyToken.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };
            return EmptyToken;
        })();

        function emptyToken(kind) {
            return new EmptyToken(kind);
        }
        Syntax.emptyToken = emptyToken;

        var RealizedToken = (function () {
            function RealizedToken(tokenKind, leadingTrivia, text, value, valueText, trailingTrivia) {
                this.tokenKind = tokenKind;
                this._leadingTrivia = leadingTrivia;
                this._text = text;
                this._value = value;
                this._valueText = valueText;
                this._trailingTrivia = trailingTrivia;
            }
            RealizedToken.prototype.clone = function () {
                return new RealizedToken(this.tokenKind, this._leadingTrivia, this._text, this._value, this._valueText, this._trailingTrivia);
            };

            RealizedToken.prototype.kind = function () {
                return this.tokenKind;
            };
            RealizedToken.prototype.toJSON = function (key) {
                return tokenToJSON(this);
            };
            RealizedToken.prototype.firstToken = function () {
                return this;
            };
            RealizedToken.prototype.lastToken = function () {
                return this;
            };
            RealizedToken.prototype.isTypeScriptSpecific = function () {
                return false;
            };

            RealizedToken.prototype.isIncrementallyUnusable = function () {
                return true;
            };

            RealizedToken.prototype.accept = function (visitor) {
                return visitor.visitToken(this);
            };

            RealizedToken.prototype.childCount = function () {
                return 0;
            };

            RealizedToken.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            };

            RealizedToken.prototype.isToken = function () {
                return true;
            };
            RealizedToken.prototype.isNode = function () {
                return false;
            };
            RealizedToken.prototype.isList = function () {
                return false;
            };
            RealizedToken.prototype.isSeparatedList = function () {
                return false;
            };
            RealizedToken.prototype.isTrivia = function () {
                return false;
            };
            RealizedToken.prototype.isTriviaList = function () {
                return false;
            };

            RealizedToken.prototype.fullWidth = function () {
                return this._leadingTrivia.fullWidth() + this.width() + this._trailingTrivia.fullWidth();
            };
            RealizedToken.prototype.width = function () {
                return this.text().length;
            };

            RealizedToken.prototype.text = function () {
                return this._text;
            };
            RealizedToken.prototype.fullText = function () {
                return this._leadingTrivia.fullText() + this.text() + this._trailingTrivia.fullText();
            };

            RealizedToken.prototype.value = function () {
                return this._value;
            };
            RealizedToken.prototype.valueText = function () {
                return this._valueText;
            };

            RealizedToken.prototype.hasLeadingTrivia = function () {
                return this._leadingTrivia.count() > 0;
            };
            RealizedToken.prototype.hasLeadingComment = function () {
                return this._leadingTrivia.hasComment();
            };
            RealizedToken.prototype.hasLeadingNewLine = function () {
                return this._leadingTrivia.hasNewLine();
            };
            RealizedToken.prototype.hasLeadingSkippedText = function () {
                return this._leadingTrivia.hasSkippedToken();
            };
            RealizedToken.prototype.leadingTriviaWidth = function () {
                return this._leadingTrivia.fullWidth();
            };

            RealizedToken.prototype.hasTrailingTrivia = function () {
                return this._trailingTrivia.count() > 0;
            };
            RealizedToken.prototype.hasTrailingComment = function () {
                return this._trailingTrivia.hasComment();
            };
            RealizedToken.prototype.hasTrailingNewLine = function () {
                return this._trailingTrivia.hasNewLine();
            };
            RealizedToken.prototype.hasTrailingSkippedText = function () {
                return this._trailingTrivia.hasSkippedToken();
            };
            RealizedToken.prototype.trailingTriviaWidth = function () {
                return this._trailingTrivia.fullWidth();
            };

            RealizedToken.prototype.hasSkippedToken = function () {
                return this.hasLeadingSkippedText() || this.hasTrailingSkippedText();
            };

            RealizedToken.prototype.leadingTrivia = function () {
                return this._leadingTrivia;
            };
            RealizedToken.prototype.trailingTrivia = function () {
                return this._trailingTrivia;
            };

            RealizedToken.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };

            RealizedToken.prototype.collectTextElements = function (elements) {
                this.leadingTrivia().collectTextElements(elements);
                elements.push(this.text());
                this.trailingTrivia().collectTextElements(elements);
            };

            RealizedToken.prototype.withLeadingTrivia = function (leadingTrivia) {
                return new RealizedToken(this.tokenKind, leadingTrivia, this._text, this._value, this._valueText, this._trailingTrivia);
            };

            RealizedToken.prototype.withTrailingTrivia = function (trailingTrivia) {
                return new RealizedToken(this.tokenKind, this._leadingTrivia, this._text, this._value, this._valueText, trailingTrivia);
            };
            return RealizedToken;
        })();

        function token(kind, info) {
            if (typeof info === "undefined") { info = null; }
            var text = (info !== null && info.text !== undefined) ? info.text : TypeScript.SyntaxFacts.getText(kind);

            return new RealizedToken(kind, TypeScript.Syntax.triviaList(info === null ? null : info.leadingTrivia), text, value1(kind, text), valueText1(kind, text), TypeScript.Syntax.triviaList(info === null ? null : info.trailingTrivia));
        }
        Syntax.token = token;

        function identifier(text, info) {
            if (typeof info === "undefined") { info = null; }
            info = info || {};
            info.text = text;
            return token(11 /* IdentifierName */, info);
        }
        Syntax.identifier = identifier;
    })(TypeScript.Syntax || (TypeScript.Syntax = {}));
    var Syntax = TypeScript.Syntax;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxTokenReplacer = (function (_super) {
        __extends(SyntaxTokenReplacer, _super);
        function SyntaxTokenReplacer(token1, token2) {
            _super.call(this);
            this.token1 = token1;
            this.token2 = token2;
        }
        SyntaxTokenReplacer.prototype.visitToken = function (token) {
            if (token === this.token1) {
                var result = this.token2;
                this.token1 = null;
                this.token2 = null;

                return result;
            }

            return token;
        };

        SyntaxTokenReplacer.prototype.visitNode = function (node) {
            if (this.token1 === null) {
                return node;
            }

            return _super.prototype.visitNode.call(this, node);
        };

        SyntaxTokenReplacer.prototype.visitList = function (list) {
            if (this.token1 === null) {
                return list;
            }

            return _super.prototype.visitList.call(this, list);
        };

        SyntaxTokenReplacer.prototype.visitSeparatedList = function (list) {
            if (this.token1 === null) {
                return list;
            }

            return _super.prototype.visitSeparatedList.call(this, list);
        };
        return SyntaxTokenReplacer;
    })(TypeScript.SyntaxRewriter);
    TypeScript.SyntaxTokenReplacer = SyntaxTokenReplacer;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Syntax) {
        var SyntaxTrivia = (function () {
            function SyntaxTrivia(kind, textOrToken) {
                this._kind = kind;
                this._textOrToken = textOrToken;
            }
            SyntaxTrivia.prototype.toJSON = function (key) {
                var result = {};
                result.kind = TypeScript.SyntaxKind[this._kind];

                if (this.isSkippedToken()) {
                    result.skippedToken = this._textOrToken;
                } else {
                    result.text = this._textOrToken;
                }
                return result;
            };

            SyntaxTrivia.prototype.kind = function () {
                return this._kind;
            };

            SyntaxTrivia.prototype.fullWidth = function () {
                return this.fullText().length;
            };

            SyntaxTrivia.prototype.fullText = function () {
                return this.isSkippedToken() ? this.skippedToken().fullText() : this._textOrToken;
            };

            SyntaxTrivia.prototype.isWhitespace = function () {
                return this.kind() === 4 /* WhitespaceTrivia */;
            };

            SyntaxTrivia.prototype.isComment = function () {
                return this.kind() === 7 /* SingleLineCommentTrivia */ || this.kind() === 6 /* MultiLineCommentTrivia */;
            };

            SyntaxTrivia.prototype.isNewLine = function () {
                return this.kind() === 5 /* NewLineTrivia */;
            };

            SyntaxTrivia.prototype.isSkippedToken = function () {
                return this.kind() === 8 /* SkippedTokenTrivia */;
            };

            SyntaxTrivia.prototype.skippedToken = function () {
                TypeScript.Debug.assert(this.isSkippedToken());
                return this._textOrToken;
            };

            SyntaxTrivia.prototype.collectTextElements = function (elements) {
                elements.push(this.fullText());
            };
            return SyntaxTrivia;
        })();

        function trivia(kind, text) {
            return new SyntaxTrivia(kind, text);
        }
        Syntax.trivia = trivia;

        function skippedTokenTrivia(token) {
            TypeScript.Debug.assert(!token.hasLeadingTrivia());
            TypeScript.Debug.assert(!token.hasTrailingTrivia());
            TypeScript.Debug.assert(token.fullWidth() > 0);
            return new SyntaxTrivia(8 /* SkippedTokenTrivia */, token);
        }
        Syntax.skippedTokenTrivia = skippedTokenTrivia;

        function spaces(count) {
            return trivia(4 /* WhitespaceTrivia */, TypeScript.StringUtilities.repeat(" ", count));
        }
        Syntax.spaces = spaces;

        function whitespace(text) {
            return trivia(4 /* WhitespaceTrivia */, text);
        }
        Syntax.whitespace = whitespace;

        function multiLineComment(text) {
            return trivia(6 /* MultiLineCommentTrivia */, text);
        }
        Syntax.multiLineComment = multiLineComment;

        function singleLineComment(text) {
            return trivia(7 /* SingleLineCommentTrivia */, text);
        }
        Syntax.singleLineComment = singleLineComment;

        Syntax.spaceTrivia = spaces(1);
        Syntax.lineFeedTrivia = trivia(5 /* NewLineTrivia */, "\n");
        Syntax.carriageReturnTrivia = trivia(5 /* NewLineTrivia */, "\r");
        Syntax.carriageReturnLineFeedTrivia = trivia(5 /* NewLineTrivia */, "\r\n");

        function splitMultiLineCommentTriviaIntoMultipleLines(trivia) {
            var result = [];

            var triviaText = trivia.fullText();
            var currentIndex = 0;

            for (var i = 0; i < triviaText.length; i++) {
                var ch = triviaText.charCodeAt(i);

                var isCarriageReturnLineFeed = false;
                switch (ch) {
                    case 13 /* carriageReturn */:
                        if (i < triviaText.length - 1 && triviaText.charCodeAt(i + 1) === 10 /* lineFeed */) {
                            i++;
                        }

                    case 10 /* lineFeed */:
                    case 8233 /* paragraphSeparator */:
                    case 8232 /* lineSeparator */:
                        result.push(triviaText.substring(currentIndex, i + 1));

                        currentIndex = i + 1;
                        continue;
                }
            }

            result.push(triviaText.substring(currentIndex));
            return result;
        }
        Syntax.splitMultiLineCommentTriviaIntoMultipleLines = splitMultiLineCommentTriviaIntoMultipleLines;
    })(TypeScript.Syntax || (TypeScript.Syntax = {}));
    var Syntax = TypeScript.Syntax;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Syntax) {
        Syntax.emptyTriviaList = {
            kind: function () {
                return 3 /* TriviaList */;
            },
            count: function () {
                return 0;
            },
            syntaxTriviaAt: function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            },
            last: function () {
                throw TypeScript.Errors.argumentOutOfRange("index");
            },
            fullWidth: function () {
                return 0;
            },
            fullText: function () {
                return "";
            },
            hasComment: function () {
                return false;
            },
            hasNewLine: function () {
                return false;
            },
            hasSkippedToken: function () {
                return false;
            },
            toJSON: function (key) {
                return [];
            },
            collectTextElements: function (elements) {
            },
            toArray: function () {
                return [];
            },
            concat: function (trivia) {
                return trivia;
            }
        };

        function concatTrivia(list1, list2) {
            if (list1.count() === 0) {
                return list2;
            }

            if (list2.count() === 0) {
                return list1;
            }

            var trivia = list1.toArray();
            trivia.push.apply(trivia, list2.toArray());

            return triviaList(trivia);
        }

        function isComment(trivia) {
            return trivia.kind() === 6 /* MultiLineCommentTrivia */ || trivia.kind() === 7 /* SingleLineCommentTrivia */;
        }

        var SingletonSyntaxTriviaList = (function () {
            function SingletonSyntaxTriviaList(item) {
                this.item = item;
            }
            SingletonSyntaxTriviaList.prototype.kind = function () {
                return 3 /* TriviaList */;
            };

            SingletonSyntaxTriviaList.prototype.count = function () {
                return 1;
            };

            SingletonSyntaxTriviaList.prototype.syntaxTriviaAt = function (index) {
                if (index !== 0) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }

                return this.item;
            };

            SingletonSyntaxTriviaList.prototype.last = function () {
                return this.item;
            };

            SingletonSyntaxTriviaList.prototype.fullWidth = function () {
                return this.item.fullWidth();
            };

            SingletonSyntaxTriviaList.prototype.fullText = function () {
                return this.item.fullText();
            };

            SingletonSyntaxTriviaList.prototype.hasComment = function () {
                return isComment(this.item);
            };

            SingletonSyntaxTriviaList.prototype.hasNewLine = function () {
                return this.item.kind() === 5 /* NewLineTrivia */;
            };

            SingletonSyntaxTriviaList.prototype.hasSkippedToken = function () {
                return this.item.kind() === 8 /* SkippedTokenTrivia */;
            };

            SingletonSyntaxTriviaList.prototype.toJSON = function (key) {
                return [this.item];
            };

            SingletonSyntaxTriviaList.prototype.collectTextElements = function (elements) {
                (this.item).collectTextElements(elements);
            };

            SingletonSyntaxTriviaList.prototype.toArray = function () {
                return [this.item];
            };

            SingletonSyntaxTriviaList.prototype.concat = function (trivia) {
                return concatTrivia(this, trivia);
            };
            return SingletonSyntaxTriviaList;
        })();

        var NormalSyntaxTriviaList = (function () {
            function NormalSyntaxTriviaList(trivia) {
                this.trivia = trivia;
            }
            NormalSyntaxTriviaList.prototype.kind = function () {
                return 3 /* TriviaList */;
            };

            NormalSyntaxTriviaList.prototype.count = function () {
                return this.trivia.length;
            };

            NormalSyntaxTriviaList.prototype.syntaxTriviaAt = function (index) {
                if (index < 0 || index >= this.trivia.length) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }

                return this.trivia[index];
            };

            NormalSyntaxTriviaList.prototype.last = function () {
                return this.trivia[this.trivia.length - 1];
            };

            NormalSyntaxTriviaList.prototype.fullWidth = function () {
                return TypeScript.ArrayUtilities.sum(this.trivia, function (t) {
                    return t.fullWidth();
                });
            };

            NormalSyntaxTriviaList.prototype.fullText = function () {
                var result = "";

                for (var i = 0, n = this.trivia.length; i < n; i++) {
                    result += this.trivia[i].fullText();
                }

                return result;
            };

            NormalSyntaxTriviaList.prototype.hasComment = function () {
                for (var i = 0; i < this.trivia.length; i++) {
                    if (isComment(this.trivia[i])) {
                        return true;
                    }
                }

                return false;
            };

            NormalSyntaxTriviaList.prototype.hasNewLine = function () {
                for (var i = 0; i < this.trivia.length; i++) {
                    if (this.trivia[i].kind() === 5 /* NewLineTrivia */) {
                        return true;
                    }
                }

                return false;
            };

            NormalSyntaxTriviaList.prototype.hasSkippedToken = function () {
                for (var i = 0; i < this.trivia.length; i++) {
                    if (this.trivia[i].kind() === 8 /* SkippedTokenTrivia */) {
                        return true;
                    }
                }

                return false;
            };

            NormalSyntaxTriviaList.prototype.toJSON = function (key) {
                return this.trivia;
            };

            NormalSyntaxTriviaList.prototype.collectTextElements = function (elements) {
                for (var i = 0; i < this.trivia.length; i++) {
                    (this.trivia[i]).collectTextElements(elements);
                }
            };

            NormalSyntaxTriviaList.prototype.toArray = function () {
                return this.trivia.slice(0);
            };

            NormalSyntaxTriviaList.prototype.concat = function (trivia) {
                return concatTrivia(this, trivia);
            };
            return NormalSyntaxTriviaList;
        })();

        function triviaList(trivia) {
            if (trivia === undefined || trivia === null || trivia.length === 0) {
                return TypeScript.Syntax.emptyTriviaList;
            }

            if (trivia.length === 1) {
                return new SingletonSyntaxTriviaList(trivia[0]);
            }

            return new NormalSyntaxTriviaList(trivia);
        }
        Syntax.triviaList = triviaList;

        Syntax.spaceTriviaList = triviaList([TypeScript.Syntax.spaceTrivia]);
    })(TypeScript.Syntax || (TypeScript.Syntax = {}));
    var Syntax = TypeScript.Syntax;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxUtilities = (function () {
        function SyntaxUtilities() {
        }
        SyntaxUtilities.isAngleBracket = function (positionedElement) {
            var element = positionedElement.element();
            var parent = positionedElement.parentElement();
            if (parent !== null && (element.kind() === 81 /* LessThanToken */ || element.kind() === 82 /* GreaterThanToken */)) {
                switch (parent.kind()) {
                    case 227 /* TypeArgumentList */:
                    case 228 /* TypeParameterList */:
                    case 219 /* CastExpression */:
                        return true;
                }
            }

            return false;
        };

        SyntaxUtilities.getToken = function (list, kind) {
            for (var i = 0, n = list.childCount(); i < n; i++) {
                var token = list.childAt(i);
                if (token.tokenKind === kind) {
                    return token;
                }
            }

            return null;
        };

        SyntaxUtilities.containsToken = function (list, kind) {
            return SyntaxUtilities.getToken(list, kind) !== null;
        };

        SyntaxUtilities.hasExportKeyword = function (moduleElement) {
            switch (moduleElement.kind()) {
                case 130 /* ModuleDeclaration */:
                case 131 /* ClassDeclaration */:
                case 129 /* FunctionDeclaration */:
                case 147 /* VariableStatement */:
                case 132 /* EnumDeclaration */:
                case 128 /* InterfaceDeclaration */:
                    return SyntaxUtilities.containsToken((moduleElement).modifiers, 47 /* ExportKeyword */);
            }

            return false;
        };

        SyntaxUtilities.isAmbientDeclarationSyntax = function (positionNode) {
            if (!positionNode) {
                return false;
            }

            var node = positionNode.node();
            switch (node.kind()) {
                case 130 /* ModuleDeclaration */:
                case 131 /* ClassDeclaration */:
                case 129 /* FunctionDeclaration */:
                case 147 /* VariableStatement */:
                case 132 /* EnumDeclaration */:
                    if (SyntaxUtilities.containsToken((node).modifiers, 64 /* DeclareKeyword */)) {
                        return true;
                    }

                case 133 /* ImportDeclaration */:
                case 137 /* ConstructorDeclaration */:
                case 135 /* MemberFunctionDeclaration */:
                case 138 /* GetMemberAccessorDeclaration */:
                case 139 /* SetMemberAccessorDeclaration */:
                case 136 /* MemberVariableDeclaration */:
                    if (node.isClassElement() || node.isModuleElement()) {
                        return SyntaxUtilities.isAmbientDeclarationSyntax(positionNode.containingNode());
                    }

                case 243 /* EnumElement */:
                    return SyntaxUtilities.isAmbientDeclarationSyntax(positionNode.containingNode().containingNode());

                default:
                    return SyntaxUtilities.isAmbientDeclarationSyntax(positionNode.containingNode());
            }
        };
        return SyntaxUtilities;
    })();
    TypeScript.SyntaxUtilities = SyntaxUtilities;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxVisitor = (function () {
        function SyntaxVisitor() {
        }
        SyntaxVisitor.prototype.defaultVisit = function (node) {
            return null;
        };

        SyntaxVisitor.prototype.visitToken = function (token) {
            return this.defaultVisit(token);
        };

        SyntaxVisitor.prototype.visitSourceUnit = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitExternalModuleReference = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitModuleNameModuleReference = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitImportDeclaration = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitExportAssignment = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitClassDeclaration = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitInterfaceDeclaration = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitHeritageClause = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitModuleDeclaration = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitFunctionDeclaration = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitVariableStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitVariableDeclaration = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitVariableDeclarator = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitEqualsValueClause = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitPrefixUnaryExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitArrayLiteralExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitOmittedExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitParenthesizedExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitSimpleArrowFunctionExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitParenthesizedArrowFunctionExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitQualifiedName = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitTypeArgumentList = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitConstructorType = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitFunctionType = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitObjectType = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitArrayType = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitGenericType = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitTypeAnnotation = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitBlock = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitParameter = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitMemberAccessExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitPostfixUnaryExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitElementAccessExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitInvocationExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitArgumentList = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitBinaryExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitConditionalExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitConstructSignature = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitMethodSignature = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitIndexSignature = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitPropertySignature = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitCallSignature = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitParameterList = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitTypeParameterList = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitTypeParameter = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitConstraint = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitElseClause = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitIfStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitExpressionStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitConstructorDeclaration = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitMemberFunctionDeclaration = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitGetMemberAccessorDeclaration = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitSetMemberAccessorDeclaration = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitMemberVariableDeclaration = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitThrowStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitReturnStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitObjectCreationExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitSwitchStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitCaseSwitchClause = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitDefaultSwitchClause = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitBreakStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitContinueStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitForStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitForInStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitWhileStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitWithStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitEnumDeclaration = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitEnumElement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitCastExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitObjectLiteralExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitSimplePropertyAssignment = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitFunctionPropertyAssignment = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitGetAccessorPropertyAssignment = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitSetAccessorPropertyAssignment = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitFunctionExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitEmptyStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitTryStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitCatchClause = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitFinallyClause = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitLabeledStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitDoStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitTypeOfExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitDeleteExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitVoidExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitDebuggerStatement = function (node) {
            return this.defaultVisit(node);
        };
        return SyntaxVisitor;
    })();
    TypeScript.SyntaxVisitor = SyntaxVisitor;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxWalker = (function () {
        function SyntaxWalker() {
        }
        SyntaxWalker.prototype.visitToken = function (token) {
        };

        SyntaxWalker.prototype.visitNode = function (node) {
            node.accept(this);
        };

        SyntaxWalker.prototype.visitNodeOrToken = function (nodeOrToken) {
            if (nodeOrToken.isToken()) {
                this.visitToken(nodeOrToken);
            } else {
                this.visitNode(nodeOrToken);
            }
        };

        SyntaxWalker.prototype.visitOptionalToken = function (token) {
            if (token === null) {
                return;
            }

            this.visitToken(token);
        };

        SyntaxWalker.prototype.visitOptionalNode = function (node) {
            if (node === null) {
                return;
            }

            this.visitNode(node);
        };

        SyntaxWalker.prototype.visitOptionalNodeOrToken = function (nodeOrToken) {
            if (nodeOrToken === null) {
                return;
            }

            this.visitNodeOrToken(nodeOrToken);
        };

        SyntaxWalker.prototype.visitList = function (list) {
            for (var i = 0, n = list.childCount(); i < n; i++) {
                this.visitNodeOrToken(list.childAt(i));
            }
        };

        SyntaxWalker.prototype.visitSeparatedList = function (list) {
            for (var i = 0, n = list.childCount(); i < n; i++) {
                var item = list.childAt(i);
                this.visitNodeOrToken(item);
            }
        };

        SyntaxWalker.prototype.visitSourceUnit = function (node) {
            this.visitList(node.moduleElements);
            this.visitToken(node.endOfFileToken);
        };

        SyntaxWalker.prototype.visitExternalModuleReference = function (node) {
            this.visitToken(node.moduleOrRequireKeyword);
            this.visitToken(node.openParenToken);
            this.visitToken(node.stringLiteral);
            this.visitToken(node.closeParenToken);
        };

        SyntaxWalker.prototype.visitModuleNameModuleReference = function (node) {
            this.visitNodeOrToken(node.moduleName);
        };

        SyntaxWalker.prototype.visitImportDeclaration = function (node) {
            this.visitToken(node.importKeyword);
            this.visitToken(node.identifier);
            this.visitToken(node.equalsToken);
            this.visitNode(node.moduleReference);
            this.visitToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitExportAssignment = function (node) {
            this.visitToken(node.exportKeyword);
            this.visitToken(node.equalsToken);
            this.visitToken(node.identifier);
            this.visitToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitClassDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.classKeyword);
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.typeParameterList);
            this.visitList(node.heritageClauses);
            this.visitToken(node.openBraceToken);
            this.visitList(node.classElements);
            this.visitToken(node.closeBraceToken);
        };

        SyntaxWalker.prototype.visitInterfaceDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.interfaceKeyword);
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.typeParameterList);
            this.visitList(node.heritageClauses);
            this.visitNode(node.body);
        };

        SyntaxWalker.prototype.visitHeritageClause = function (node) {
            this.visitToken(node.extendsOrImplementsKeyword);
            this.visitSeparatedList(node.typeNames);
        };

        SyntaxWalker.prototype.visitModuleDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.moduleKeyword);
            this.visitOptionalNodeOrToken(node.moduleName);
            this.visitOptionalToken(node.stringLiteral);
            this.visitToken(node.openBraceToken);
            this.visitList(node.moduleElements);
            this.visitToken(node.closeBraceToken);
        };

        SyntaxWalker.prototype.visitFunctionDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.functionKeyword);
            this.visitToken(node.identifier);
            this.visitNode(node.callSignature);
            this.visitOptionalNode(node.block);
            this.visitOptionalToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitVariableStatement = function (node) {
            this.visitList(node.modifiers);
            this.visitNode(node.variableDeclaration);
            this.visitToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitVariableDeclaration = function (node) {
            this.visitToken(node.varKeyword);
            this.visitSeparatedList(node.variableDeclarators);
        };

        SyntaxWalker.prototype.visitVariableDeclarator = function (node) {
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.typeAnnotation);
            this.visitOptionalNode(node.equalsValueClause);
        };

        SyntaxWalker.prototype.visitEqualsValueClause = function (node) {
            this.visitToken(node.equalsToken);
            this.visitNodeOrToken(node.value);
        };

        SyntaxWalker.prototype.visitPrefixUnaryExpression = function (node) {
            this.visitToken(node.operatorToken);
            this.visitNodeOrToken(node.operand);
        };

        SyntaxWalker.prototype.visitArrayLiteralExpression = function (node) {
            this.visitToken(node.openBracketToken);
            this.visitSeparatedList(node.expressions);
            this.visitToken(node.closeBracketToken);
        };

        SyntaxWalker.prototype.visitOmittedExpression = function (node) {
        };

        SyntaxWalker.prototype.visitParenthesizedExpression = function (node) {
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.closeParenToken);
        };

        SyntaxWalker.prototype.visitSimpleArrowFunctionExpression = function (node) {
            this.visitToken(node.identifier);
            this.visitToken(node.equalsGreaterThanToken);
            this.visitNodeOrToken(node.body);
        };

        SyntaxWalker.prototype.visitParenthesizedArrowFunctionExpression = function (node) {
            this.visitNode(node.callSignature);
            this.visitToken(node.equalsGreaterThanToken);
            this.visitNodeOrToken(node.body);
        };

        SyntaxWalker.prototype.visitQualifiedName = function (node) {
            this.visitNodeOrToken(node.left);
            this.visitToken(node.dotToken);
            this.visitToken(node.right);
        };

        SyntaxWalker.prototype.visitTypeArgumentList = function (node) {
            this.visitToken(node.lessThanToken);
            this.visitSeparatedList(node.typeArguments);
            this.visitToken(node.greaterThanToken);
        };

        SyntaxWalker.prototype.visitConstructorType = function (node) {
            this.visitToken(node.newKeyword);
            this.visitOptionalNode(node.typeParameterList);
            this.visitNode(node.parameterList);
            this.visitToken(node.equalsGreaterThanToken);
            this.visitNodeOrToken(node.type);
        };

        SyntaxWalker.prototype.visitFunctionType = function (node) {
            this.visitOptionalNode(node.typeParameterList);
            this.visitNode(node.parameterList);
            this.visitToken(node.equalsGreaterThanToken);
            this.visitNodeOrToken(node.type);
        };

        SyntaxWalker.prototype.visitObjectType = function (node) {
            this.visitToken(node.openBraceToken);
            this.visitSeparatedList(node.typeMembers);
            this.visitToken(node.closeBraceToken);
        };

        SyntaxWalker.prototype.visitArrayType = function (node) {
            this.visitNodeOrToken(node.type);
            this.visitToken(node.openBracketToken);
            this.visitToken(node.closeBracketToken);
        };

        SyntaxWalker.prototype.visitGenericType = function (node) {
            this.visitNodeOrToken(node.name);
            this.visitNode(node.typeArgumentList);
        };

        SyntaxWalker.prototype.visitTypeAnnotation = function (node) {
            this.visitToken(node.colonToken);
            this.visitNodeOrToken(node.type);
        };

        SyntaxWalker.prototype.visitBlock = function (node) {
            this.visitToken(node.openBraceToken);
            this.visitList(node.statements);
            this.visitToken(node.closeBraceToken);
        };

        SyntaxWalker.prototype.visitParameter = function (node) {
            this.visitOptionalToken(node.dotDotDotToken);
            this.visitOptionalToken(node.publicOrPrivateKeyword);
            this.visitToken(node.identifier);
            this.visitOptionalToken(node.questionToken);
            this.visitOptionalNode(node.typeAnnotation);
            this.visitOptionalNode(node.equalsValueClause);
        };

        SyntaxWalker.prototype.visitMemberAccessExpression = function (node) {
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.dotToken);
            this.visitToken(node.name);
        };

        SyntaxWalker.prototype.visitPostfixUnaryExpression = function (node) {
            this.visitNodeOrToken(node.operand);
            this.visitToken(node.operatorToken);
        };

        SyntaxWalker.prototype.visitElementAccessExpression = function (node) {
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.openBracketToken);
            this.visitNodeOrToken(node.argumentExpression);
            this.visitToken(node.closeBracketToken);
        };

        SyntaxWalker.prototype.visitInvocationExpression = function (node) {
            this.visitNodeOrToken(node.expression);
            this.visitNode(node.argumentList);
        };

        SyntaxWalker.prototype.visitArgumentList = function (node) {
            this.visitOptionalNode(node.typeArgumentList);
            this.visitToken(node.openParenToken);
            this.visitSeparatedList(node.arguments);
            this.visitToken(node.closeParenToken);
        };

        SyntaxWalker.prototype.visitBinaryExpression = function (node) {
            this.visitNodeOrToken(node.left);
            this.visitToken(node.operatorToken);
            this.visitNodeOrToken(node.right);
        };

        SyntaxWalker.prototype.visitConditionalExpression = function (node) {
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.questionToken);
            this.visitNodeOrToken(node.whenTrue);
            this.visitToken(node.colonToken);
            this.visitNodeOrToken(node.whenFalse);
        };

        SyntaxWalker.prototype.visitConstructSignature = function (node) {
            this.visitToken(node.newKeyword);
            this.visitNode(node.callSignature);
        };

        SyntaxWalker.prototype.visitMethodSignature = function (node) {
            this.visitToken(node.propertyName);
            this.visitOptionalToken(node.questionToken);
            this.visitNode(node.callSignature);
        };

        SyntaxWalker.prototype.visitIndexSignature = function (node) {
            this.visitToken(node.openBracketToken);
            this.visitNode(node.parameter);
            this.visitToken(node.closeBracketToken);
            this.visitOptionalNode(node.typeAnnotation);
        };

        SyntaxWalker.prototype.visitPropertySignature = function (node) {
            this.visitToken(node.propertyName);
            this.visitOptionalToken(node.questionToken);
            this.visitOptionalNode(node.typeAnnotation);
        };

        SyntaxWalker.prototype.visitCallSignature = function (node) {
            this.visitOptionalNode(node.typeParameterList);
            this.visitNode(node.parameterList);
            this.visitOptionalNode(node.typeAnnotation);
        };

        SyntaxWalker.prototype.visitParameterList = function (node) {
            this.visitToken(node.openParenToken);
            this.visitSeparatedList(node.parameters);
            this.visitToken(node.closeParenToken);
        };

        SyntaxWalker.prototype.visitTypeParameterList = function (node) {
            this.visitToken(node.lessThanToken);
            this.visitSeparatedList(node.typeParameters);
            this.visitToken(node.greaterThanToken);
        };

        SyntaxWalker.prototype.visitTypeParameter = function (node) {
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.constraint);
        };

        SyntaxWalker.prototype.visitConstraint = function (node) {
            this.visitToken(node.extendsKeyword);
            this.visitNodeOrToken(node.type);
        };

        SyntaxWalker.prototype.visitElseClause = function (node) {
            this.visitToken(node.elseKeyword);
            this.visitNodeOrToken(node.statement);
        };

        SyntaxWalker.prototype.visitIfStatement = function (node) {
            this.visitToken(node.ifKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
            this.visitOptionalNode(node.elseClause);
        };

        SyntaxWalker.prototype.visitExpressionStatement = function (node) {
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitConstructorDeclaration = function (node) {
            this.visitToken(node.constructorKeyword);
            this.visitNode(node.parameterList);
            this.visitOptionalNode(node.block);
            this.visitOptionalToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitMemberFunctionDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.propertyName);
            this.visitNode(node.callSignature);
            this.visitOptionalNode(node.block);
            this.visitOptionalToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitGetMemberAccessorDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.getKeyword);
            this.visitToken(node.propertyName);
            this.visitNode(node.parameterList);
            this.visitOptionalNode(node.typeAnnotation);
            this.visitNode(node.block);
        };

        SyntaxWalker.prototype.visitSetMemberAccessorDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.setKeyword);
            this.visitToken(node.propertyName);
            this.visitNode(node.parameterList);
            this.visitNode(node.block);
        };

        SyntaxWalker.prototype.visitMemberVariableDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitNode(node.variableDeclarator);
            this.visitToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitThrowStatement = function (node) {
            this.visitToken(node.throwKeyword);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitReturnStatement = function (node) {
            this.visitToken(node.returnKeyword);
            this.visitOptionalNodeOrToken(node.expression);
            this.visitToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitObjectCreationExpression = function (node) {
            this.visitToken(node.newKeyword);
            this.visitNodeOrToken(node.expression);
            this.visitOptionalNode(node.argumentList);
        };

        SyntaxWalker.prototype.visitSwitchStatement = function (node) {
            this.visitToken(node.switchKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.closeParenToken);
            this.visitToken(node.openBraceToken);
            this.visitList(node.switchClauses);
            this.visitToken(node.closeBraceToken);
        };

        SyntaxWalker.prototype.visitCaseSwitchClause = function (node) {
            this.visitToken(node.caseKeyword);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.colonToken);
            this.visitList(node.statements);
        };

        SyntaxWalker.prototype.visitDefaultSwitchClause = function (node) {
            this.visitToken(node.defaultKeyword);
            this.visitToken(node.colonToken);
            this.visitList(node.statements);
        };

        SyntaxWalker.prototype.visitBreakStatement = function (node) {
            this.visitToken(node.breakKeyword);
            this.visitOptionalToken(node.identifier);
            this.visitToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitContinueStatement = function (node) {
            this.visitToken(node.continueKeyword);
            this.visitOptionalToken(node.identifier);
            this.visitToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitForStatement = function (node) {
            this.visitToken(node.forKeyword);
            this.visitToken(node.openParenToken);
            this.visitOptionalNode(node.variableDeclaration);
            this.visitOptionalNodeOrToken(node.initializer);
            this.visitToken(node.firstSemicolonToken);
            this.visitOptionalNodeOrToken(node.condition);
            this.visitToken(node.secondSemicolonToken);
            this.visitOptionalNodeOrToken(node.incrementor);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
        };

        SyntaxWalker.prototype.visitForInStatement = function (node) {
            this.visitToken(node.forKeyword);
            this.visitToken(node.openParenToken);
            this.visitOptionalNode(node.variableDeclaration);
            this.visitOptionalNodeOrToken(node.left);
            this.visitToken(node.inKeyword);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
        };

        SyntaxWalker.prototype.visitWhileStatement = function (node) {
            this.visitToken(node.whileKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
        };

        SyntaxWalker.prototype.visitWithStatement = function (node) {
            this.visitToken(node.withKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
        };

        SyntaxWalker.prototype.visitEnumDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.enumKeyword);
            this.visitToken(node.identifier);
            this.visitToken(node.openBraceToken);
            this.visitSeparatedList(node.enumElements);
            this.visitToken(node.closeBraceToken);
        };

        SyntaxWalker.prototype.visitEnumElement = function (node) {
            this.visitToken(node.propertyName);
            this.visitOptionalNode(node.equalsValueClause);
        };

        SyntaxWalker.prototype.visitCastExpression = function (node) {
            this.visitToken(node.lessThanToken);
            this.visitNodeOrToken(node.type);
            this.visitToken(node.greaterThanToken);
            this.visitNodeOrToken(node.expression);
        };

        SyntaxWalker.prototype.visitObjectLiteralExpression = function (node) {
            this.visitToken(node.openBraceToken);
            this.visitSeparatedList(node.propertyAssignments);
            this.visitToken(node.closeBraceToken);
        };

        SyntaxWalker.prototype.visitSimplePropertyAssignment = function (node) {
            this.visitToken(node.propertyName);
            this.visitToken(node.colonToken);
            this.visitNodeOrToken(node.expression);
        };

        SyntaxWalker.prototype.visitFunctionPropertyAssignment = function (node) {
            this.visitToken(node.propertyName);
            this.visitNode(node.callSignature);
            this.visitNode(node.block);
        };

        SyntaxWalker.prototype.visitGetAccessorPropertyAssignment = function (node) {
            this.visitToken(node.getKeyword);
            this.visitToken(node.propertyName);
            this.visitToken(node.openParenToken);
            this.visitToken(node.closeParenToken);
            this.visitOptionalNode(node.typeAnnotation);
            this.visitNode(node.block);
        };

        SyntaxWalker.prototype.visitSetAccessorPropertyAssignment = function (node) {
            this.visitToken(node.setKeyword);
            this.visitToken(node.propertyName);
            this.visitToken(node.openParenToken);
            this.visitNode(node.parameter);
            this.visitToken(node.closeParenToken);
            this.visitNode(node.block);
        };

        SyntaxWalker.prototype.visitFunctionExpression = function (node) {
            this.visitToken(node.functionKeyword);
            this.visitOptionalToken(node.identifier);
            this.visitNode(node.callSignature);
            this.visitNode(node.block);
        };

        SyntaxWalker.prototype.visitEmptyStatement = function (node) {
            this.visitToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitTryStatement = function (node) {
            this.visitToken(node.tryKeyword);
            this.visitNode(node.block);
            this.visitOptionalNode(node.catchClause);
            this.visitOptionalNode(node.finallyClause);
        };

        SyntaxWalker.prototype.visitCatchClause = function (node) {
            this.visitToken(node.catchKeyword);
            this.visitToken(node.openParenToken);
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.typeAnnotation);
            this.visitToken(node.closeParenToken);
            this.visitNode(node.block);
        };

        SyntaxWalker.prototype.visitFinallyClause = function (node) {
            this.visitToken(node.finallyKeyword);
            this.visitNode(node.block);
        };

        SyntaxWalker.prototype.visitLabeledStatement = function (node) {
            this.visitToken(node.identifier);
            this.visitToken(node.colonToken);
            this.visitNodeOrToken(node.statement);
        };

        SyntaxWalker.prototype.visitDoStatement = function (node) {
            this.visitToken(node.doKeyword);
            this.visitNodeOrToken(node.statement);
            this.visitToken(node.whileKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.closeParenToken);
            this.visitToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitTypeOfExpression = function (node) {
            this.visitToken(node.typeOfKeyword);
            this.visitNodeOrToken(node.expression);
        };

        SyntaxWalker.prototype.visitDeleteExpression = function (node) {
            this.visitToken(node.deleteKeyword);
            this.visitNodeOrToken(node.expression);
        };

        SyntaxWalker.prototype.visitVoidExpression = function (node) {
            this.visitToken(node.voidKeyword);
            this.visitNodeOrToken(node.expression);
        };

        SyntaxWalker.prototype.visitDebuggerStatement = function (node) {
            this.visitToken(node.debuggerKeyword);
            this.visitToken(node.semicolonToken);
        };
        return SyntaxWalker;
    })();
    TypeScript.SyntaxWalker = SyntaxWalker;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var PositionTrackingWalker = (function (_super) {
        __extends(PositionTrackingWalker, _super);
        function PositionTrackingWalker() {
            _super.apply(this, arguments);
            this._position = 0;
        }
        PositionTrackingWalker.prototype.visitToken = function (token) {
            this._position += token.fullWidth();
        };

        PositionTrackingWalker.prototype.position = function () {
            return this._position;
        };

        PositionTrackingWalker.prototype.skip = function (element) {
            this._position += element.fullWidth();
        };
        return PositionTrackingWalker;
    })(TypeScript.SyntaxWalker);
    TypeScript.PositionTrackingWalker = PositionTrackingWalker;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxInformationMap = (function (_super) {
        __extends(SyntaxInformationMap, _super);
        function SyntaxInformationMap(trackParents, trackPreviousToken) {
            _super.call(this);
            this.trackParents = trackParents;
            this.trackPreviousToken = trackPreviousToken;
            this.tokenToInformation = TypeScript.Collections.createHashTable(TypeScript.Collections.DefaultHashTableCapacity, TypeScript.Collections.identityHashCode);
            this.elementToPosition = TypeScript.Collections.createHashTable(TypeScript.Collections.DefaultHashTableCapacity, TypeScript.Collections.identityHashCode);
            this._previousToken = null;
            this._previousTokenInformation = null;
            this._currentPosition = 0;
            this._elementToParent = TypeScript.Collections.createHashTable(TypeScript.Collections.DefaultHashTableCapacity, TypeScript.Collections.identityHashCode);
            this._parentStack = [];
            this._parentStack.push(null);
        }
        SyntaxInformationMap.create = function (node, trackParents, trackPreviousToken) {
            var map = new SyntaxInformationMap(trackParents, trackPreviousToken);
            map.visitNode(node);
            return map;
        };

        SyntaxInformationMap.prototype.visitNode = function (node) {
            this.trackParents && this._elementToParent.add(node, TypeScript.ArrayUtilities.last(this._parentStack));
            this.elementToPosition.add(node, this._currentPosition);

            this.trackParents && this._parentStack.push(node);
            _super.prototype.visitNode.call(this, node);
            this.trackParents && this._parentStack.pop();
        };

        SyntaxInformationMap.prototype.visitToken = function (token) {
            this.trackParents && this._elementToParent.add(token, TypeScript.ArrayUtilities.last(this._parentStack));

            if (this.trackPreviousToken) {
                var tokenInformation = {
                    previousToken: this._previousToken,
                    nextToken: null
                };

                if (this._previousTokenInformation !== null) {
                    this._previousTokenInformation.nextToken = token;
                }

                this._previousToken = token;
                this._previousTokenInformation = tokenInformation;

                this.tokenToInformation.add(token, tokenInformation);
            }

            this.elementToPosition.add(token, this._currentPosition);
            this._currentPosition += token.fullWidth();
        };

        SyntaxInformationMap.prototype.parent = function (element) {
            return this._elementToParent.get(element);
        };

        SyntaxInformationMap.prototype.fullStart = function (element) {
            return this.elementToPosition.get(element);
        };

        SyntaxInformationMap.prototype.start = function (element) {
            return this.fullStart(element) + element.leadingTriviaWidth();
        };

        SyntaxInformationMap.prototype.end = function (element) {
            return this.start(element) + element.width();
        };

        SyntaxInformationMap.prototype.previousToken = function (token) {
            return this.tokenInformation(token).previousToken;
        };

        SyntaxInformationMap.prototype.tokenInformation = function (token) {
            return this.tokenToInformation.get(token);
        };

        SyntaxInformationMap.prototype.firstTokenInLineContainingToken = function (token) {
            var current = token;
            while (true) {
                var information = this.tokenInformation(current);
                if (this.isFirstTokenInLineWorker(information)) {
                    break;
                }

                current = information.previousToken;
            }

            return current;
        };

        SyntaxInformationMap.prototype.isFirstTokenInLine = function (token) {
            var information = this.tokenInformation(token);
            return this.isFirstTokenInLineWorker(information);
        };

        SyntaxInformationMap.prototype.isFirstTokenInLineWorker = function (information) {
            return information.previousToken === null || information.previousToken.hasTrailingNewLine();
        };
        return SyntaxInformationMap;
    })(TypeScript.SyntaxWalker);
    TypeScript.SyntaxInformationMap = SyntaxInformationMap;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxNodeInvariantsChecker = (function (_super) {
        __extends(SyntaxNodeInvariantsChecker, _super);
        function SyntaxNodeInvariantsChecker() {
            _super.apply(this, arguments);
            this.tokenTable = TypeScript.Collections.createHashTable(TypeScript.Collections.DefaultHashTableCapacity, TypeScript.Collections.identityHashCode);
        }
        SyntaxNodeInvariantsChecker.checkInvariants = function (node) {
            node.accept(new SyntaxNodeInvariantsChecker());
        };

        SyntaxNodeInvariantsChecker.prototype.visitToken = function (token) {
            this.tokenTable.add(token, token);
        };
        return SyntaxNodeInvariantsChecker;
    })(TypeScript.SyntaxWalker);
    TypeScript.SyntaxNodeInvariantsChecker = SyntaxNodeInvariantsChecker;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var DepthLimitedWalker = (function (_super) {
        __extends(DepthLimitedWalker, _super);
        function DepthLimitedWalker(maximumDepth) {
            _super.call(this);
            this._depth = 0;
            this._maximumDepth = 0;
            this._maximumDepth = maximumDepth;
        }
        DepthLimitedWalker.prototype.visitNode = function (node) {
            if (this._depth < this._maximumDepth) {
                this._depth++;
                _super.prototype.visitNode.call(this, node);
                this._depth--;
            } else {
                this.skip(node);
            }
        };
        return DepthLimitedWalker;
    })(TypeScript.PositionTrackingWalker);
    TypeScript.DepthLimitedWalker = DepthLimitedWalker;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Parser) {
        var ExpressionPrecedence;
        (function (ExpressionPrecedence) {
            ExpressionPrecedence[ExpressionPrecedence["CommaExpressionPrecedence"] = 1] = "CommaExpressionPrecedence";

            ExpressionPrecedence[ExpressionPrecedence["AssignmentExpressionPrecedence"] = 2] = "AssignmentExpressionPrecedence";

            ExpressionPrecedence[ExpressionPrecedence["ConditionalExpressionPrecedence"] = 3] = "ConditionalExpressionPrecedence";

            ExpressionPrecedence[ExpressionPrecedence["ArrowFunctionPrecedence"] = 4] = "ArrowFunctionPrecedence";

            ExpressionPrecedence[ExpressionPrecedence["LogicalOrExpressionPrecedence"] = 5] = "LogicalOrExpressionPrecedence";
            ExpressionPrecedence[ExpressionPrecedence["LogicalAndExpressionPrecedence"] = 6] = "LogicalAndExpressionPrecedence";
            ExpressionPrecedence[ExpressionPrecedence["BitwiseOrExpressionPrecedence"] = 7] = "BitwiseOrExpressionPrecedence";
            ExpressionPrecedence[ExpressionPrecedence["BitwiseExclusiveOrExpressionPrecedence"] = 8] = "BitwiseExclusiveOrExpressionPrecedence";
            ExpressionPrecedence[ExpressionPrecedence["BitwiseAndExpressionPrecedence"] = 9] = "BitwiseAndExpressionPrecedence";
            ExpressionPrecedence[ExpressionPrecedence["EqualityExpressionPrecedence"] = 10] = "EqualityExpressionPrecedence";
            ExpressionPrecedence[ExpressionPrecedence["RelationalExpressionPrecedence"] = 11] = "RelationalExpressionPrecedence";
            ExpressionPrecedence[ExpressionPrecedence["ShiftExpressionPrecdence"] = 12] = "ShiftExpressionPrecdence";
            ExpressionPrecedence[ExpressionPrecedence["AdditiveExpressionPrecedence"] = 13] = "AdditiveExpressionPrecedence";
            ExpressionPrecedence[ExpressionPrecedence["MultiplicativeExpressionPrecedence"] = 14] = "MultiplicativeExpressionPrecedence";

            ExpressionPrecedence[ExpressionPrecedence["UnaryExpressionPrecedence"] = 15] = "UnaryExpressionPrecedence";
        })(ExpressionPrecedence || (ExpressionPrecedence = {}));

        var ListParsingState;
        (function (ListParsingState) {
            ListParsingState[ListParsingState["SourceUnit_ModuleElements"] = 1 << 0] = "SourceUnit_ModuleElements";
            ListParsingState[ListParsingState["ClassDeclaration_ClassElements"] = 1 << 1] = "ClassDeclaration_ClassElements";
            ListParsingState[ListParsingState["ModuleDeclaration_ModuleElements"] = 1 << 2] = "ModuleDeclaration_ModuleElements";
            ListParsingState[ListParsingState["SwitchStatement_SwitchClauses"] = 1 << 3] = "SwitchStatement_SwitchClauses";
            ListParsingState[ListParsingState["SwitchClause_Statements"] = 1 << 4] = "SwitchClause_Statements";
            ListParsingState[ListParsingState["Block_Statements"] = 1 << 5] = "Block_Statements";
            ListParsingState[ListParsingState["TryBlock_Statements"] = 1 << 6] = "TryBlock_Statements";
            ListParsingState[ListParsingState["CatchBlock_Statements"] = 1 << 7] = "CatchBlock_Statements";
            ListParsingState[ListParsingState["EnumDeclaration_EnumElements"] = 1 << 8] = "EnumDeclaration_EnumElements";
            ListParsingState[ListParsingState["ObjectType_TypeMembers"] = 1 << 9] = "ObjectType_TypeMembers";
            ListParsingState[ListParsingState["ClassOrInterfaceDeclaration_HeritageClauses"] = 1 << 10] = "ClassOrInterfaceDeclaration_HeritageClauses";
            ListParsingState[ListParsingState["HeritageClause_TypeNameList"] = 1 << 11] = "HeritageClause_TypeNameList";
            ListParsingState[ListParsingState["VariableDeclaration_VariableDeclarators_AllowIn"] = 1 << 12] = "VariableDeclaration_VariableDeclarators_AllowIn";
            ListParsingState[ListParsingState["VariableDeclaration_VariableDeclarators_DisallowIn"] = 1 << 13] = "VariableDeclaration_VariableDeclarators_DisallowIn";
            ListParsingState[ListParsingState["ArgumentList_AssignmentExpressions"] = 1 << 14] = "ArgumentList_AssignmentExpressions";
            ListParsingState[ListParsingState["ObjectLiteralExpression_PropertyAssignments"] = 1 << 15] = "ObjectLiteralExpression_PropertyAssignments";
            ListParsingState[ListParsingState["ArrayLiteralExpression_AssignmentExpressions"] = 1 << 16] = "ArrayLiteralExpression_AssignmentExpressions";
            ListParsingState[ListParsingState["ParameterList_Parameters"] = 1 << 17] = "ParameterList_Parameters";
            ListParsingState[ListParsingState["TypeArgumentList_Types"] = 1 << 18] = "TypeArgumentList_Types";
            ListParsingState[ListParsingState["TypeParameterList_TypeParameters"] = 1 << 19] = "TypeParameterList_TypeParameters";

            ListParsingState[ListParsingState["FirstListParsingState"] = ListParsingState.SourceUnit_ModuleElements] = "FirstListParsingState";
            ListParsingState[ListParsingState["LastListParsingState"] = ListParsingState.TypeArgumentList_Types] = "LastListParsingState";
        })(ListParsingState || (ListParsingState = {}));

        var SyntaxCursor = (function () {
            function SyntaxCursor(sourceUnit) {
                this._elements = [];
                this._index = 0;
                this._pinCount = 0;
                sourceUnit.insertChildrenInto(this._elements, 0);
            }
            SyntaxCursor.prototype.isFinished = function () {
                return this._index === this._elements.length;
            };

            SyntaxCursor.prototype.currentElement = function () {
                if (this.isFinished()) {
                    return null;
                }

                return this._elements[this._index];
            };

            SyntaxCursor.prototype.currentNode = function () {
                var element = this.currentElement();
                return element !== null && element.isNode() ? element : null;
            };

            SyntaxCursor.prototype.moveToFirstChild = function () {
                if (this.isFinished()) {
                    return;
                }

                var element = this._elements[this._index];
                if (element.isToken()) {
                    return;
                }

                var node = element;

                this._elements.splice(this._index, 1);

                node.insertChildrenInto(this._elements, this._index);
            };

            SyntaxCursor.prototype.moveToNextSibling = function () {
                if (this.isFinished()) {
                    return;
                }

                if (this._pinCount > 0) {
                    this._index++;
                    return;
                }

                this._elements.shift();
            };

            SyntaxCursor.prototype.getAndPinCursorIndex = function () {
                this._pinCount++;
                return this._index;
            };

            SyntaxCursor.prototype.releaseAndUnpinCursorIndex = function (index) {
                this._pinCount--;
                if (this._pinCount === 0) {
                }
            };

            SyntaxCursor.prototype.rewindToPinnedCursorIndex = function (index) {
                this._index = index;
            };

            SyntaxCursor.prototype.pinCount = function () {
                return this._pinCount;
            };

            SyntaxCursor.prototype.moveToFirstToken = function () {
                var element;

                while (!this.isFinished()) {
                    element = this.currentElement();
                    if (element.isNode()) {
                        this.moveToFirstChild();
                        continue;
                    }

                    return;
                }
            };

            SyntaxCursor.prototype.currentToken = function () {
                this.moveToFirstToken();
                if (this.isFinished()) {
                    return null;
                }

                var element = this.currentElement();

                return element;
            };

            SyntaxCursor.prototype.peekToken = function (n) {
                this.moveToFirstToken();
                var pin = this.getAndPinCursorIndex();
                try  {
                    for (var i = 0; i < n; i++) {
                        this.moveToNextSibling();
                        this.moveToFirstToken();
                    }

                    return this.currentToken();
                } finally {
                    this.rewindToPinnedCursorIndex(pin);
                    this.releaseAndUnpinCursorIndex(pin);
                }
            };
            return SyntaxCursor;
        })();

        var NormalParserSource = (function () {
            function NormalParserSource(fileName, text, languageVersion) {
                this._previousToken = null;
                this._absolutePosition = 0;
                this._tokenDiagnostics = [];
                this.rewindPointPool = [];
                this.rewindPointPoolCount = 0;
                this.slidingWindow = new TypeScript.SlidingWindow(this, TypeScript.ArrayUtilities.createArray(32, null), null);
                this.scanner = new TypeScript.Scanner(fileName, text, languageVersion);
            }
            NormalParserSource.prototype.languageVersion = function () {
                return this.scanner.languageVersion();
            };

            NormalParserSource.prototype.currentNode = function () {
                return null;
            };

            NormalParserSource.prototype.moveToNextNode = function () {
                throw TypeScript.Errors.invalidOperation();
            };

            NormalParserSource.prototype.absolutePosition = function () {
                return this._absolutePosition;
            };

            NormalParserSource.prototype.previousToken = function () {
                return this._previousToken;
            };

            NormalParserSource.prototype.tokenDiagnostics = function () {
                return this._tokenDiagnostics;
            };

            NormalParserSource.prototype.getOrCreateRewindPoint = function () {
                if (this.rewindPointPoolCount === 0) {
                    return {};
                }

                this.rewindPointPoolCount--;
                var result = this.rewindPointPool[this.rewindPointPoolCount];
                this.rewindPointPool[this.rewindPointPoolCount] = null;
                return result;
            };

            NormalParserSource.prototype.getRewindPoint = function () {
                var slidingWindowIndex = this.slidingWindow.getAndPinAbsoluteIndex();

                var rewindPoint = this.getOrCreateRewindPoint();

                rewindPoint.slidingWindowIndex = slidingWindowIndex;
                rewindPoint.previousToken = this._previousToken;
                rewindPoint.absolutePosition = this._absolutePosition;

                rewindPoint.pinCount = this.slidingWindow.pinCount();

                return rewindPoint;
            };

            NormalParserSource.prototype.isPinned = function () {
                return this.slidingWindow.pinCount() > 0;
            };

            NormalParserSource.prototype.rewind = function (rewindPoint) {
                this.slidingWindow.rewindToPinnedIndex(rewindPoint.slidingWindowIndex);

                this._previousToken = rewindPoint.previousToken;
                this._absolutePosition = rewindPoint.absolutePosition;
            };

            NormalParserSource.prototype.releaseRewindPoint = function (rewindPoint) {
                this.slidingWindow.releaseAndUnpinAbsoluteIndex((rewindPoint).absoluteIndex);

                this.rewindPointPool[this.rewindPointPoolCount] = rewindPoint;
                this.rewindPointPoolCount++;
            };

            NormalParserSource.prototype.fetchMoreItems = function (allowRegularExpression, sourceIndex, window, destinationIndex, spaceAvailable) {
                window[destinationIndex] = this.scanner.scan(this._tokenDiagnostics, allowRegularExpression);
                return 1;
            };

            NormalParserSource.prototype.peekToken = function (n) {
                return this.slidingWindow.peekItemN(n);
            };

            NormalParserSource.prototype.moveToNextToken = function () {
                var currentToken = this.currentToken();
                this._absolutePosition += currentToken.fullWidth();
                this._previousToken = currentToken;

                this.slidingWindow.moveToNextItem();
            };

            NormalParserSource.prototype.currentToken = function () {
                return this.slidingWindow.currentItem(false);
            };

            NormalParserSource.prototype.removeDiagnosticsOnOrAfterPosition = function (position) {
                var tokenDiagnosticsLength = this._tokenDiagnostics.length;
                while (tokenDiagnosticsLength > 0) {
                    var diagnostic = this._tokenDiagnostics[tokenDiagnosticsLength - 1];
                    if (diagnostic.start() >= position) {
                        tokenDiagnosticsLength--;
                    } else {
                        break;
                    }
                }

                this._tokenDiagnostics.length = tokenDiagnosticsLength;
            };

            NormalParserSource.prototype.resetToPosition = function (absolutePosition, previousToken) {
                this._absolutePosition = absolutePosition;
                this._previousToken = previousToken;

                this.removeDiagnosticsOnOrAfterPosition(absolutePosition);

                this.slidingWindow.disgardAllItemsFromCurrentIndexOnwards();

                this.scanner.setAbsoluteIndex(absolutePosition);
            };

            NormalParserSource.prototype.currentTokenAllowingRegularExpression = function () {
                this.resetToPosition(this._absolutePosition, this._previousToken);

                var token = this.slidingWindow.currentItem(true);

                return token;
            };
            return NormalParserSource;
        })();

        var IncrementalParserSource = (function () {
            function IncrementalParserSource(oldSyntaxTree, textChangeRange, newText) {
                this._changeDelta = 0;
                var oldSourceUnit = oldSyntaxTree.sourceUnit();
                this._oldSourceUnitCursor = new SyntaxCursor(oldSourceUnit);

                this._changeRange = IncrementalParserSource.extendToAffectedRange(textChangeRange, oldSourceUnit);

                this._normalParserSource = new NormalParserSource(oldSyntaxTree.fileName(), newText, oldSyntaxTree.languageVersion());
            }
            IncrementalParserSource.extendToAffectedRange = function (changeRange, sourceUnit) {
                var maxLookahead = 1;

                var start = changeRange.span().start();

                for (var i = 0; start > 0 && i <= maxLookahead; i++) {
                    var token = sourceUnit.findToken(start);

                    var position = token.fullStart();

                    start = TypeScript.MathPrototype.max(0, position - 1);
                }

                var finalSpan = TypeScript.TextSpan.fromBounds(start, changeRange.span().end());
                var finalLength = changeRange.newLength() + (changeRange.span().start() - start);

                return new TypeScript.TextChangeRange(finalSpan, finalLength);
            };

            IncrementalParserSource.prototype.languageVersion = function () {
                return this._normalParserSource.languageVersion();
            };

            IncrementalParserSource.prototype.absolutePosition = function () {
                return this._normalParserSource.absolutePosition();
            };

            IncrementalParserSource.prototype.previousToken = function () {
                return this._normalParserSource.previousToken();
            };

            IncrementalParserSource.prototype.tokenDiagnostics = function () {
                return this._normalParserSource.tokenDiagnostics();
            };

            IncrementalParserSource.prototype.getRewindPoint = function () {
                var rewindPoint = this._normalParserSource.getRewindPoint();
                var oldSourceUnitCursorIndex = this._oldSourceUnitCursor.getAndPinCursorIndex();

                rewindPoint.changeDelta = this._changeDelta;
                rewindPoint.changeRange = this._changeRange;
                rewindPoint.oldSourceUnitCursorIndex = oldSourceUnitCursorIndex;

                return rewindPoint;
            };

            IncrementalParserSource.prototype.rewind = function (rewindPoint) {
                this._changeRange = rewindPoint.changeRange;
                this._changeDelta = rewindPoint.changeDelta;
                this._oldSourceUnitCursor.rewindToPinnedCursorIndex(rewindPoint.oldSourceUnitCursorIndex);

                this._normalParserSource.rewind(rewindPoint);
            };

            IncrementalParserSource.prototype.releaseRewindPoint = function (rewindPoint) {
                this._oldSourceUnitCursor.releaseAndUnpinCursorIndex(rewindPoint.oldSourceUnitCursorIndex);
                this._normalParserSource.releaseRewindPoint(rewindPoint);
            };

            IncrementalParserSource.prototype.canReadFromOldSourceUnit = function () {
                if (this._normalParserSource.isPinned()) {
                    return false;
                }

                if (this._changeRange !== null && this._changeRange.newSpan().intersectsWithPosition(this.absolutePosition())) {
                    return false;
                }

                this.syncCursorToNewTextIfBehind();

                return this._changeDelta === 0 && !this._oldSourceUnitCursor.isFinished();
            };

            IncrementalParserSource.prototype.currentNode = function () {
                if (this.canReadFromOldSourceUnit()) {
                    return this.tryGetNodeFromOldSourceUnit();
                }

                return null;
            };

            IncrementalParserSource.prototype.currentToken = function () {
                if (this.canReadFromOldSourceUnit()) {
                    var token = this.tryGetTokenFromOldSourceUnit();
                    if (token !== null) {
                        return token;
                    }
                }

                return this._normalParserSource.currentToken();
            };

            IncrementalParserSource.prototype.currentTokenAllowingRegularExpression = function () {
                return this._normalParserSource.currentTokenAllowingRegularExpression();
            };

            IncrementalParserSource.prototype.syncCursorToNewTextIfBehind = function () {
                while (true) {
                    if (this._oldSourceUnitCursor.isFinished()) {
                        break;
                    }

                    if (this._changeDelta >= 0) {
                        break;
                    }

                    var currentElement = this._oldSourceUnitCursor.currentElement();

                    if (currentElement.isNode() && (currentElement.fullWidth() > Math.abs(this._changeDelta))) {
                        this._oldSourceUnitCursor.moveToFirstChild();
                    } else {
                        this._oldSourceUnitCursor.moveToNextSibling();

                        this._changeDelta += currentElement.fullWidth();
                    }
                }
            };

            IncrementalParserSource.prototype.intersectsWithChangeRangeSpanInOriginalText = function (start, length) {
                return this._changeRange !== null && this._changeRange.span().intersectsWith(start, length);
            };

            IncrementalParserSource.prototype.tryGetNodeFromOldSourceUnit = function () {
                while (true) {
                    var node = this._oldSourceUnitCursor.currentNode();
                    if (node === null) {
                        return null;
                    }

                    if (!this.intersectsWithChangeRangeSpanInOriginalText(this.absolutePosition(), node.fullWidth())) {
                        if (!node.isIncrementallyUnusable()) {
                            return node;
                        }
                    }

                    this._oldSourceUnitCursor.moveToFirstChild();
                }
            };

            IncrementalParserSource.prototype.canReuseTokenFromOldSourceUnit = function (position, token) {
                if (token !== null) {
                    if (!this.intersectsWithChangeRangeSpanInOriginalText(position, token.fullWidth())) {
                        if (!token.isIncrementallyUnusable()) {
                            return true;
                        }
                    }
                }

                return false;
            };

            IncrementalParserSource.prototype.tryGetTokenFromOldSourceUnit = function () {
                var token = this._oldSourceUnitCursor.currentToken();

                return this.canReuseTokenFromOldSourceUnit(this.absolutePosition(), token) ? token : null;
            };

            IncrementalParserSource.prototype.peekToken = function (n) {
                if (this.canReadFromOldSourceUnit()) {
                    var token = this.tryPeekTokenFromOldSourceUnit(n);
                    if (token !== null) {
                        return token;
                    }
                }

                return this._normalParserSource.peekToken(n);
            };

            IncrementalParserSource.prototype.tryPeekTokenFromOldSourceUnit = function (n) {
                var currentPosition = this.absolutePosition();
                for (var i = 0; i < n; i++) {
                    var interimToken = this._oldSourceUnitCursor.peekToken(i);
                    if (!this.canReuseTokenFromOldSourceUnit(currentPosition, interimToken)) {
                        return null;
                    }

                    currentPosition += interimToken.fullWidth();
                }

                var token = this._oldSourceUnitCursor.peekToken(n);
                return this.canReuseTokenFromOldSourceUnit(currentPosition, token) ? token : null;
            };

            IncrementalParserSource.prototype.moveToNextNode = function () {
                var currentElement = this._oldSourceUnitCursor.currentElement();
                var currentNode = this._oldSourceUnitCursor.currentNode();

                this._oldSourceUnitCursor.moveToNextSibling();

                var absolutePosition = this.absolutePosition() + currentNode.fullWidth();
                var previousToken = currentNode.lastToken();
                this._normalParserSource.resetToPosition(absolutePosition, previousToken);

                if (this._changeRange !== null) {
                }
            };

            IncrementalParserSource.prototype.moveToNextToken = function () {
                var currentToken = this.currentToken();

                if (this._oldSourceUnitCursor.currentToken() === currentToken) {
                    this._oldSourceUnitCursor.moveToNextSibling();

                    var absolutePosition = this.absolutePosition() + currentToken.fullWidth();
                    var previousToken = currentToken;
                    this._normalParserSource.resetToPosition(absolutePosition, previousToken);

                    if (this._changeRange !== null) {
                    }
                } else {
                    this._changeDelta -= currentToken.fullWidth();

                    this._normalParserSource.moveToNextToken();

                    if (this._changeRange !== null) {
                        var changeRangeSpanInNewText = this._changeRange.newSpan();
                        if (this.absolutePosition() >= changeRangeSpanInNewText.end()) {
                            this._changeDelta += this._changeRange.newLength() - this._changeRange.span().length();
                            this._changeRange = null;
                        }
                    }
                }
            };
            return IncrementalParserSource;
        })();

        var ParserImpl = (function () {
            function ParserImpl(fileName, lineMap, source, parseOptions) {
                this.listParsingState = 0;
                this.isInStrictMode = false;
                this.diagnostics = [];
                this.factory = TypeScript.Syntax.normalModeFactory;
                this.mergeTokensStorage = [];
                this.arrayPool = [];
                this.fileName = fileName;
                this.lineMap = lineMap;
                this.source = source;
                this.parseOptions = parseOptions;
            }
            ParserImpl.prototype.getRewindPoint = function () {
                var rewindPoint = this.source.getRewindPoint();

                rewindPoint.diagnosticsCount = this.diagnostics.length;

                rewindPoint.isInStrictMode = this.isInStrictMode;
                rewindPoint.listParsingState = this.listParsingState;

                return rewindPoint;
            };

            ParserImpl.prototype.rewind = function (rewindPoint) {
                this.source.rewind(rewindPoint);

                this.diagnostics.length = rewindPoint.diagnosticsCount;
            };

            ParserImpl.prototype.releaseRewindPoint = function (rewindPoint) {
                this.source.releaseRewindPoint(rewindPoint);
            };

            ParserImpl.prototype.currentTokenStart = function () {
                return this.source.absolutePosition() + this.currentToken().leadingTriviaWidth();
            };

            ParserImpl.prototype.previousTokenStart = function () {
                if (this.previousToken() === null) {
                    return 0;
                }

                return this.source.absolutePosition() - this.previousToken().fullWidth() + this.previousToken().leadingTriviaWidth();
            };

            ParserImpl.prototype.previousTokenEnd = function () {
                if (this.previousToken() === null) {
                    return 0;
                }

                return this.previousTokenStart() + this.previousToken().width();
            };

            ParserImpl.prototype.currentNode = function () {
                var node = this.source.currentNode();

                if (node === null || node.parsedInStrictMode() !== this.isInStrictMode) {
                    return null;
                }

                return node;
            };

            ParserImpl.prototype.currentToken = function () {
                return this.source.currentToken();
            };

            ParserImpl.prototype.currentTokenAllowingRegularExpression = function () {
                return this.source.currentTokenAllowingRegularExpression();
            };

            ParserImpl.prototype.peekToken = function (n) {
                return this.source.peekToken(n);
            };

            ParserImpl.prototype.eatAnyToken = function () {
                var token = this.currentToken();
                this.moveToNextToken();
                return token;
            };

            ParserImpl.prototype.moveToNextToken = function () {
                this.source.moveToNextToken();
            };

            ParserImpl.prototype.previousToken = function () {
                return this.source.previousToken();
            };

            ParserImpl.prototype.eatNode = function () {
                var node = this.source.currentNode();
                this.source.moveToNextNode();
                return node;
            };

            ParserImpl.prototype.eatToken = function (kind) {
                var token = this.currentToken();
                if (token.tokenKind === kind) {
                    this.moveToNextToken();
                    return token;
                }

                return this.createMissingToken(kind, token);
            };

            ParserImpl.prototype.tryEatToken = function (kind) {
                if (this.currentToken().tokenKind === kind) {
                    return this.eatToken(kind);
                }

                return null;
            };

            ParserImpl.prototype.tryEatKeyword = function (kind) {
                if (this.currentToken().tokenKind === kind) {
                    return this.eatKeyword(kind);
                }

                return null;
            };

            ParserImpl.prototype.eatKeyword = function (kind) {
                var token = this.currentToken();
                if (token.tokenKind === kind) {
                    this.moveToNextToken();
                    return token;
                }

                return this.createMissingToken(kind, token);
            };

            ParserImpl.prototype.isIdentifier = function (token) {
                var tokenKind = token.tokenKind;

                if (tokenKind === 11 /* IdentifierName */) {
                    return true;
                }

                if (tokenKind >= 51 /* FirstFutureReservedStrictKeyword */) {
                    if (tokenKind <= 59 /* LastFutureReservedStrictKeyword */) {
                        return !this.isInStrictMode;
                    }

                    return tokenKind <= 70 /* LastTypeScriptKeyword */;
                }

                return false;
            };

            ParserImpl.prototype.eatIdentifierNameToken = function () {
                var token = this.currentToken();

                if (token.tokenKind === 11 /* IdentifierName */) {
                    this.moveToNextToken();
                    return token;
                }

                if (TypeScript.SyntaxFacts.isAnyKeyword(token.tokenKind)) {
                    this.moveToNextToken();
                    return TypeScript.Syntax.convertToIdentifierName(token);
                }

                return this.createMissingToken(11 /* IdentifierName */, token);
            };

            ParserImpl.prototype.eatIdentifierToken = function () {
                var token = this.currentToken();
                if (this.isIdentifier(token)) {
                    this.moveToNextToken();

                    if (token.tokenKind === 11 /* IdentifierName */) {
                        return token;
                    }

                    return TypeScript.Syntax.convertToIdentifierName(token);
                }

                return this.createMissingToken(11 /* IdentifierName */, token);
            };

            ParserImpl.prototype.canEatAutomaticSemicolon = function (allowWithoutNewLine) {
                var token = this.currentToken();

                if (token.tokenKind === 10 /* EndOfFileToken */) {
                    return true;
                }

                if (token.tokenKind === 72 /* CloseBraceToken */) {
                    return true;
                }

                if (allowWithoutNewLine) {
                    return true;
                }

                if (this.previousToken() !== null && this.previousToken().hasTrailingNewLine()) {
                    return true;
                }

                return false;
            };

            ParserImpl.prototype.canEatExplicitOrAutomaticSemicolon = function (allowWithoutNewline) {
                var token = this.currentToken();

                if (token.tokenKind === 79 /* SemicolonToken */) {
                    return true;
                }

                return this.canEatAutomaticSemicolon(allowWithoutNewline);
            };

            ParserImpl.prototype.eatExplicitOrAutomaticSemicolon = function (allowWithoutNewline) {
                var token = this.currentToken();

                if (token.tokenKind === 79 /* SemicolonToken */) {
                    return this.eatToken(79 /* SemicolonToken */);
                }

                if (this.canEatAutomaticSemicolon(allowWithoutNewline)) {
                    var semicolonToken = TypeScript.Syntax.emptyToken(79 /* SemicolonToken */);

                    if (!this.parseOptions.allowAutomaticSemicolonInsertion()) {
                        this.addDiagnostic(new TypeScript.SyntaxDiagnostic(this.fileName, this.previousTokenEnd(), 0, 11 /* Automatic_semicolon_insertion_not_allowed */, null));
                    }

                    return semicolonToken;
                }

                return this.eatToken(79 /* SemicolonToken */);
            };

            ParserImpl.prototype.isKeyword = function (kind) {
                if (kind >= TypeScript.SyntaxKind.FirstKeyword) {
                    if (kind <= 50 /* LastFutureReservedKeyword */) {
                        return true;
                    }

                    if (this.isInStrictMode) {
                        return kind <= 59 /* LastFutureReservedStrictKeyword */;
                    }
                }

                return false;
            };

            ParserImpl.prototype.createMissingToken = function (expectedKind, actual) {
                var diagnostic = this.getExpectedTokenDiagnostic(expectedKind, actual);
                this.addDiagnostic(diagnostic);

                return TypeScript.Syntax.emptyToken(expectedKind);
            };

            ParserImpl.prototype.getExpectedTokenDiagnostic = function (expectedKind, actual) {
                var token = this.currentToken();

                if (TypeScript.SyntaxFacts.isAnyKeyword(expectedKind) || TypeScript.SyntaxFacts.isAnyPunctuation(expectedKind)) {
                    return new TypeScript.SyntaxDiagnostic(this.fileName, this.currentTokenStart(), token.width(), 9 /* _0_expected */, [TypeScript.SyntaxFacts.getText(expectedKind)]);
                } else {
                    if (actual !== null && TypeScript.SyntaxFacts.isAnyKeyword(actual.tokenKind)) {
                        return new TypeScript.SyntaxDiagnostic(this.fileName, this.currentTokenStart(), token.width(), 10 /* Identifier_expected__0__is_a_keyword */, [TypeScript.SyntaxFacts.getText(actual.tokenKind)]);
                    } else {
                        return new TypeScript.SyntaxDiagnostic(this.fileName, this.currentTokenStart(), token.width(), 7 /* Identifier_expected */, null);
                    }
                }
            };

            ParserImpl.getPrecedence = function (expressionKind) {
                switch (expressionKind) {
                    case 172 /* CommaExpression */:
                        return 1 /* CommaExpressionPrecedence */;

                    case 173 /* AssignmentExpression */:
                    case 174 /* AddAssignmentExpression */:
                    case 175 /* SubtractAssignmentExpression */:
                    case 176 /* MultiplyAssignmentExpression */:
                    case 177 /* DivideAssignmentExpression */:
                    case 178 /* ModuloAssignmentExpression */:
                    case 179 /* AndAssignmentExpression */:
                    case 180 /* ExclusiveOrAssignmentExpression */:
                    case 181 /* OrAssignmentExpression */:
                    case 182 /* LeftShiftAssignmentExpression */:
                    case 183 /* SignedRightShiftAssignmentExpression */:
                    case 184 /* UnsignedRightShiftAssignmentExpression */:
                        return 2 /* AssignmentExpressionPrecedence */;

                    case 185 /* ConditionalExpression */:
                        return 3 /* ConditionalExpressionPrecedence */;

                    case 186 /* LogicalOrExpression */:
                        return 5 /* LogicalOrExpressionPrecedence */;

                    case 187 /* LogicalAndExpression */:
                        return 6 /* LogicalAndExpressionPrecedence */;

                    case 188 /* BitwiseOrExpression */:
                        return 7 /* BitwiseOrExpressionPrecedence */;

                    case 189 /* BitwiseExclusiveOrExpression */:
                        return 8 /* BitwiseExclusiveOrExpressionPrecedence */;

                    case 190 /* BitwiseAndExpression */:
                        return 9 /* BitwiseAndExpressionPrecedence */;

                    case 191 /* EqualsWithTypeConversionExpression */:
                    case 192 /* NotEqualsWithTypeConversionExpression */:
                    case 193 /* EqualsExpression */:
                    case 194 /* NotEqualsExpression */:
                        return 10 /* EqualityExpressionPrecedence */;

                    case 195 /* LessThanExpression */:
                    case 196 /* GreaterThanExpression */:
                    case 197 /* LessThanOrEqualExpression */:
                    case 198 /* GreaterThanOrEqualExpression */:
                    case 199 /* InstanceOfExpression */:
                    case 200 /* InExpression */:
                        return 11 /* RelationalExpressionPrecedence */;

                    case 201 /* LeftShiftExpression */:
                    case 202 /* SignedRightShiftExpression */:
                    case 203 /* UnsignedRightShiftExpression */:
                        return 12 /* ShiftExpressionPrecdence */;

                    case 207 /* AddExpression */:
                    case 208 /* SubtractExpression */:
                        return 13 /* AdditiveExpressionPrecedence */;

                    case 204 /* MultiplyExpression */:
                    case 205 /* DivideExpression */:
                    case 206 /* ModuloExpression */:
                        return 14 /* MultiplicativeExpressionPrecedence */;

                    case 163 /* PlusExpression */:
                    case 164 /* NegateExpression */:
                    case 165 /* BitwiseNotExpression */:
                    case 166 /* LogicalNotExpression */:
                    case 169 /* DeleteExpression */:
                    case 170 /* TypeOfExpression */:
                    case 171 /* VoidExpression */:
                    case 167 /* PreIncrementExpression */:
                    case 168 /* PreDecrementExpression */:
                        return 15 /* UnaryExpressionPrecedence */;
                }

                throw TypeScript.Errors.invalidOperation();
            };

            ParserImpl.prototype.addSkippedTokenAfterNodeOrToken = function (nodeOrToken, skippedToken) {
                if (nodeOrToken.isToken()) {
                    return this.addSkippedTokenAfterToken(nodeOrToken, skippedToken);
                } else if (nodeOrToken.isNode()) {
                    return this.addSkippedTokenAfterNode(nodeOrToken, skippedToken);
                } else {
                    throw TypeScript.Errors.invalidOperation();
                }
            };

            ParserImpl.prototype.addSkippedTokenAfterNode = function (node, skippedToken) {
                var oldToken = node.lastToken();
                var newToken = this.addSkippedTokenAfterToken(oldToken, skippedToken);

                return node.replaceToken(oldToken, newToken);
            };

            ParserImpl.prototype.addSkippedTokensBeforeNode = function (node, skippedTokens) {
                if (skippedTokens.length > 0) {
                    var oldToken = node.firstToken();
                    var newToken = this.addSkippedTokensBeforeToken(oldToken, skippedTokens);

                    return node.replaceToken(oldToken, newToken);
                }

                return node;
            };

            ParserImpl.prototype.addSkippedTokensBeforeToken = function (token, skippedTokens) {
                var leadingTrivia = [];
                for (var i = 0, n = skippedTokens.length; i < n; i++) {
                    this.addSkippedTokenToTriviaArray(leadingTrivia, skippedTokens[i]);
                }

                this.addTriviaTo(token.leadingTrivia(), leadingTrivia);

                this.returnArray(skippedTokens);
                return token.withLeadingTrivia(TypeScript.Syntax.triviaList(leadingTrivia));
            };

            ParserImpl.prototype.addSkippedTokensAfterToken = function (token, skippedTokens) {
                if (skippedTokens.length === 0) {
                    this.returnArray(skippedTokens);
                    return token;
                }

                var trailingTrivia = token.trailingTrivia().toArray();

                for (var i = 0, n = skippedTokens.length; i < n; i++) {
                    this.addSkippedTokenToTriviaArray(trailingTrivia, skippedTokens[i]);
                }

                this.returnArray(skippedTokens);
                return token.withTrailingTrivia(TypeScript.Syntax.triviaList(trailingTrivia));
            };

            ParserImpl.prototype.addSkippedTokenAfterToken = function (token, skippedToken) {
                var trailingTrivia = token.trailingTrivia().toArray();
                this.addSkippedTokenToTriviaArray(trailingTrivia, skippedToken);

                return token.withTrailingTrivia(TypeScript.Syntax.triviaList(trailingTrivia));
            };

            ParserImpl.prototype.addSkippedTokenToTriviaArray = function (array, skippedToken) {
                this.addTriviaTo(skippedToken.leadingTrivia(), array);

                var trimmedToken = skippedToken.withLeadingTrivia(TypeScript.Syntax.emptyTriviaList).withTrailingTrivia(TypeScript.Syntax.emptyTriviaList);
                array.push(TypeScript.Syntax.skippedTokenTrivia(trimmedToken));

                this.addTriviaTo(skippedToken.trailingTrivia(), array);
            };

            ParserImpl.prototype.addTriviaTo = function (list, array) {
                for (var i = 0, n = list.count(); i < n; i++) {
                    array.push(list.syntaxTriviaAt(i));
                }
            };

            ParserImpl.prototype.parseSyntaxTree = function (isDeclaration) {
                var sourceUnit = this.parseSourceUnit();

                var allDiagnostics = this.source.tokenDiagnostics().concat(this.diagnostics);
                allDiagnostics.sort(function (a, b) {
                    return a.start() - b.start();
                });

                return new TypeScript.SyntaxTree(sourceUnit, isDeclaration, allDiagnostics, this.fileName, this.lineMap, this.source.languageVersion(), this.parseOptions);
            };

            ParserImpl.prototype.setStrictMode = function (isInStrictMode) {
                this.isInStrictMode = isInStrictMode;
                this.factory = isInStrictMode ? TypeScript.Syntax.strictModeFactory : TypeScript.Syntax.normalModeFactory;
            };

            ParserImpl.prototype.parseSourceUnit = function () {
                var savedIsInStrictMode = this.isInStrictMode;

                var result = this.parseSyntaxList(1 /* SourceUnit_ModuleElements */, ParserImpl.updateStrictModeState);
                var moduleElements = result.list;

                this.setStrictMode(savedIsInStrictMode);

                var sourceUnit = this.factory.sourceUnit(moduleElements, this.currentToken());
                sourceUnit = this.addSkippedTokensBeforeNode(sourceUnit, result.skippedTokens);

                return sourceUnit;
            };

            ParserImpl.updateStrictModeState = function (parser, items) {
                if (!parser.isInStrictMode) {
                    for (var i = 0; i < items.length; i++) {
                        var item = items[i];
                        if (!TypeScript.SyntaxFacts.isDirectivePrologueElement(item)) {
                            return;
                        }
                    }

                    parser.setStrictMode(TypeScript.SyntaxFacts.isUseStrictDirective(items[items.length - 1]));
                }
            };

            ParserImpl.prototype.isModuleElement = function (inErrorRecovery) {
                if (this.currentNode() !== null && this.currentNode().isModuleElement()) {
                    return true;
                }

                return this.isImportDeclaration() || this.isExportAssignment() || this.isModuleDeclaration() || this.isInterfaceDeclaration() || this.isClassDeclaration() || this.isEnumDeclaration() || this.isStatement(inErrorRecovery);
            };

            ParserImpl.prototype.parseModuleElement = function () {
                if (this.currentNode() !== null && this.currentNode().isModuleElement()) {
                    return this.eatNode();
                }

                if (this.isImportDeclaration()) {
                    return this.parseImportDeclaration();
                } else if (this.isExportAssignment()) {
                    return this.parseExportAssignment();
                } else if (this.isModuleDeclaration()) {
                    return this.parseModuleDeclaration();
                } else if (this.isInterfaceDeclaration()) {
                    return this.parseInterfaceDeclaration();
                } else if (this.isClassDeclaration()) {
                    return this.parseClassDeclaration();
                } else if (this.isEnumDeclaration()) {
                    return this.parseEnumDeclaration();
                } else if (this.isStatement(false)) {
                    return this.parseStatement();
                } else {
                    throw TypeScript.Errors.invalidOperation();
                }
            };

            ParserImpl.prototype.isImportDeclaration = function () {
                return this.currentToken().tokenKind === 49 /* ImportKeyword */;
            };

            ParserImpl.prototype.parseImportDeclaration = function () {
                var importKeyword = this.eatKeyword(49 /* ImportKeyword */);
                var identifier = this.eatIdentifierToken();
                var equalsToken = this.eatToken(108 /* EqualsToken */);
                var moduleReference = this.parseModuleReference();
                var semicolonToken = this.eatExplicitOrAutomaticSemicolon(false);

                return this.factory.importDeclaration(importKeyword, identifier, equalsToken, moduleReference, semicolonToken);
            };

            ParserImpl.prototype.isExportAssignment = function () {
                return this.currentToken().tokenKind === 47 /* ExportKeyword */ && this.peekToken(1).tokenKind === 108 /* EqualsToken */;
            };

            ParserImpl.prototype.parseExportAssignment = function () {
                var exportKeyword = this.eatKeyword(47 /* ExportKeyword */);
                var equalsToken = this.eatToken(108 /* EqualsToken */);
                var identifier = this.eatIdentifierToken();
                var semicolonToken = this.eatExplicitOrAutomaticSemicolon(false);

                return this.factory.exportAssignment(exportKeyword, equalsToken, identifier, semicolonToken);
            };

            ParserImpl.prototype.parseModuleReference = function () {
                if (this.isExternalModuleReference()) {
                    return this.parseExternalModuleReference();
                } else {
                    return this.parseModuleNameModuleReference();
                }
            };

            ParserImpl.prototype.isExternalModuleReference = function () {
                var token0 = this.currentToken();
                if (token0.tokenKind === 66 /* ModuleKeyword */ || token0.tokenKind === 67 /* RequireKeyword */) {
                    return this.peekToken(1).tokenKind === 73 /* OpenParenToken */;
                }

                return false;
            };

            ParserImpl.prototype.parseExternalModuleReference = function () {
                var moduleOrRequireKeyword = this.eatAnyToken();
                var openParenToken = this.eatToken(73 /* OpenParenToken */);
                var stringLiteral = this.eatToken(14 /* StringLiteral */);
                var closeParenToken = this.eatToken(74 /* CloseParenToken */);

                return this.factory.externalModuleReference(moduleOrRequireKeyword, openParenToken, stringLiteral, closeParenToken);
            };

            ParserImpl.prototype.parseModuleNameModuleReference = function () {
                var name = this.parseName();
                return this.factory.moduleNameModuleReference(name);
            };

            ParserImpl.prototype.parseIdentifierName = function () {
                var identifierName = this.eatIdentifierNameToken();
                return identifierName;
            };

            ParserImpl.prototype.isName = function () {
                return this.isIdentifier(this.currentToken());
            };

            ParserImpl.prototype.tryParseTypeArgumentList = function (inExpression) {
                if (this.currentToken().kind() !== 81 /* LessThanToken */) {
                    return null;
                }

                var lessThanToken;
                var greaterThanToken;
                var result;
                var typeArguments;

                if (!inExpression) {
                    lessThanToken = this.eatToken(81 /* LessThanToken */);

                    result = this.parseSeparatedSyntaxList(262144 /* TypeArgumentList_Types */);
                    typeArguments = result.list;
                    lessThanToken = this.addSkippedTokensAfterToken(lessThanToken, result.skippedTokens);

                    greaterThanToken = this.eatToken(82 /* GreaterThanToken */);

                    return this.factory.typeArgumentList(lessThanToken, typeArguments, greaterThanToken);
                }

                var rewindPoint = this.getRewindPoint();
                try  {
                    lessThanToken = this.eatToken(81 /* LessThanToken */);

                    result = this.parseSeparatedSyntaxList(262144 /* TypeArgumentList_Types */);
                    typeArguments = result.list;
                    lessThanToken = this.addSkippedTokensAfterToken(lessThanToken, result.skippedTokens);

                    greaterThanToken = this.eatToken(82 /* GreaterThanToken */);

                    if (greaterThanToken.fullWidth() === 0 || !this.canFollowTypeArgumentListInExpression(this.currentToken().kind())) {
                        this.rewind(rewindPoint);
                        return null;
                    }

                    return this.factory.typeArgumentList(lessThanToken, typeArguments, greaterThanToken);
                } finally {
                    this.releaseRewindPoint(rewindPoint);
                }
            };

            ParserImpl.prototype.canFollowTypeArgumentListInExpression = function (kind) {
                switch (kind) {
                    case 73 /* OpenParenToken */:
                    case 77 /* DotToken */:

                    case 74 /* CloseParenToken */:
                    case 76 /* CloseBracketToken */:
                    case 107 /* ColonToken */:
                    case 79 /* SemicolonToken */:
                    case 80 /* CommaToken */:
                    case 106 /* QuestionToken */:
                    case 85 /* EqualsEqualsToken */:
                    case 88 /* EqualsEqualsEqualsToken */:
                    case 87 /* ExclamationEqualsToken */:
                    case 89 /* ExclamationEqualsEqualsToken */:
                    case 104 /* AmpersandAmpersandToken */:
                    case 105 /* BarBarToken */:
                    case 101 /* CaretToken */:
                    case 99 /* AmpersandToken */:
                    case 100 /* BarToken */:
                    case 72 /* CloseBraceToken */:
                    case 10 /* EndOfFileToken */:
                        return true;

                    default:
                        return false;
                }
            };

            ParserImpl.prototype.parseName = function () {
                var shouldContinue = this.isIdentifier(this.currentToken());
                var current = this.eatIdentifierToken();

                while (shouldContinue && this.currentToken().tokenKind === 77 /* DotToken */) {
                    var dotToken = this.eatToken(77 /* DotToken */);

                    var currentToken = this.currentToken();
                    var identifierName;

                    if (TypeScript.SyntaxFacts.isAnyKeyword(currentToken.tokenKind) && this.previousToken().hasTrailingNewLine() && !currentToken.hasTrailingNewLine() && TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(this.peekToken(1))) {
                        identifierName = this.createMissingToken(11 /* IdentifierName */, currentToken);
                    } else {
                        identifierName = this.eatIdentifierNameToken();
                    }

                    current = this.factory.qualifiedName(current, dotToken, identifierName);

                    shouldContinue = identifierName.fullWidth() > 0;
                }

                return current;
            };

            ParserImpl.prototype.isEnumDeclaration = function () {
                var index = this.modifierCount();

                if (index > 0 && this.peekToken(index).tokenKind === 46 /* EnumKeyword */) {
                    return true;
                }

                return this.currentToken().tokenKind === 46 /* EnumKeyword */ && this.isIdentifier(this.peekToken(1));
            };

            ParserImpl.prototype.parseEnumDeclaration = function () {
                var modifiers = this.parseModifiers();
                var enumKeyword = this.eatKeyword(46 /* EnumKeyword */);
                var identifier = this.eatIdentifierToken();

                var openBraceToken = this.eatToken(71 /* OpenBraceToken */);
                var enumElements = TypeScript.Syntax.emptySeparatedList;

                if (openBraceToken.width() > 0) {
                    var result = this.parseSeparatedSyntaxList(256 /* EnumDeclaration_EnumElements */);
                    enumElements = result.list;
                    openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);
                }

                var closeBraceToken = this.eatToken(72 /* CloseBraceToken */);

                return this.factory.enumDeclaration(modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken);
            };

            ParserImpl.prototype.isEnumElement = function (inErrorRecovery) {
                if (this.currentNode() !== null && this.currentNode().kind() === 243 /* EnumElement */) {
                    return true;
                }

                return this.isPropertyName(this.currentToken(), inErrorRecovery);
            };

            ParserImpl.prototype.parseEnumElement = function () {
                if (this.currentNode() !== null && this.currentNode().kind() === 243 /* EnumElement */) {
                    return this.eatNode();
                }

                var propertyName = this.eatPropertyName();
                var equalsValueClause = null;
                if (this.isEqualsValueClause(false)) {
                    equalsValueClause = this.parseEqualsValueClause(true);
                }

                return this.factory.enumElement(propertyName, equalsValueClause);
            };

            ParserImpl.isModifier = function (token) {
                switch (token.tokenKind) {
                    case 57 /* PublicKeyword */:
                    case 55 /* PrivateKeyword */:
                    case 58 /* StaticKeyword */:
                    case 47 /* ExportKeyword */:
                    case 64 /* DeclareKeyword */:
                        return true;

                    default:
                        return false;
                }
            };

            ParserImpl.prototype.modifierCount = function () {
                var modifierCount = 0;
                while (true) {
                    if (ParserImpl.isModifier(this.peekToken(modifierCount))) {
                        modifierCount++;
                        continue;
                    }

                    break;
                }

                return modifierCount;
            };

            ParserImpl.prototype.parseModifiers = function () {
                var tokens = this.getArray();

                while (true) {
                    if (ParserImpl.isModifier(this.currentToken())) {
                        tokens.push(this.eatAnyToken());
                        continue;
                    }

                    break;
                }

                var result = TypeScript.Syntax.list(tokens);

                this.returnZeroOrOneLengthArray(tokens);

                return result;
            };

            ParserImpl.prototype.isClassDeclaration = function () {
                var index = this.modifierCount();

                if (index > 0 && this.peekToken(index).tokenKind === 44 /* ClassKeyword */) {
                    return true;
                }

                return this.currentToken().tokenKind === 44 /* ClassKeyword */ && this.isIdentifier(this.peekToken(1));
            };

            ParserImpl.prototype.parseHeritageClauses = function () {
                var heritageClauses = TypeScript.Syntax.emptyList;

                if (this.isHeritageClause()) {
                    var result = this.parseSyntaxList(1024 /* ClassOrInterfaceDeclaration_HeritageClauses */);
                    heritageClauses = result.list;
                    TypeScript.Debug.assert(result.skippedTokens.length === 0);
                }

                return heritageClauses;
            };

            ParserImpl.prototype.parseClassDeclaration = function () {
                var modifiers = this.parseModifiers();

                var classKeyword = this.eatKeyword(44 /* ClassKeyword */);
                var identifier = this.eatIdentifierToken();
                var typeParameterList = this.parseOptionalTypeParameterList(false);
                var heritageClauses = this.parseHeritageClauses();
                var openBraceToken = this.eatToken(71 /* OpenBraceToken */);
                var classElements = TypeScript.Syntax.emptyList;

                if (openBraceToken.width() > 0) {
                    var result = this.parseSyntaxList(2 /* ClassDeclaration_ClassElements */);

                    classElements = result.list;
                    openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);
                }

                var closeBraceToken = this.eatToken(72 /* CloseBraceToken */);
                return this.factory.classDeclaration(modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken);
            };

            ParserImpl.prototype.isConstructorDeclaration = function () {
                return this.currentToken().tokenKind === 63 /* ConstructorKeyword */;
            };

            ParserImpl.isPublicOrPrivateKeyword = function (token) {
                return token.tokenKind === 57 /* PublicKeyword */ || token.tokenKind === 55 /* PrivateKeyword */;
            };

            ParserImpl.prototype.isMemberAccessorDeclaration = function (inErrorRecovery) {
                var index = this.modifierCount();

                if (this.peekToken(index).tokenKind !== 65 /* GetKeyword */ && this.peekToken(index).tokenKind !== 69 /* SetKeyword */) {
                    return false;
                }

                index++;
                return this.isPropertyName(this.peekToken(index), inErrorRecovery);
            };

            ParserImpl.prototype.parseMemberAccessorDeclaration = function () {
                var modifiers = this.parseModifiers();

                if (this.currentToken().tokenKind === 65 /* GetKeyword */) {
                    return this.parseGetMemberAccessorDeclaration(modifiers);
                } else if (this.currentToken().tokenKind === 69 /* SetKeyword */) {
                    return this.parseSetMemberAccessorDeclaration(modifiers);
                } else {
                    throw TypeScript.Errors.invalidOperation();
                }
            };

            ParserImpl.prototype.parseGetMemberAccessorDeclaration = function (modifiers) {
                var getKeyword = this.eatKeyword(65 /* GetKeyword */);
                var propertyName = this.eatPropertyName();
                var parameterList = this.parseParameterList();
                var typeAnnotation = this.parseOptionalTypeAnnotation(false);
                var block = this.parseBlock(false, false);

                return this.factory.getMemberAccessorDeclaration(modifiers, getKeyword, propertyName, parameterList, typeAnnotation, block);
            };

            ParserImpl.prototype.parseSetMemberAccessorDeclaration = function (modifiers) {
                var setKeyword = this.eatKeyword(69 /* SetKeyword */);
                var propertyName = this.eatPropertyName();
                var parameterList = this.parseParameterList();
                var block = this.parseBlock(false, false);

                return this.factory.setMemberAccessorDeclaration(modifiers, setKeyword, propertyName, parameterList, block);
            };

            ParserImpl.prototype.isClassElement = function (inErrorRecovery) {
                if (this.currentNode() !== null && this.currentNode().isClassElement()) {
                    return true;
                }

                return this.isConstructorDeclaration() || this.isMemberFunctionDeclaration(inErrorRecovery) || this.isMemberAccessorDeclaration(inErrorRecovery) || this.isMemberVariableDeclaration(inErrorRecovery) || this.isIndexSignature();
            };

            ParserImpl.prototype.parseConstructorDeclaration = function () {
                var constructorKeyword = this.eatKeyword(63 /* ConstructorKeyword */);
                var parameterList = this.parseParameterList();

                var semicolonToken = null;
                var block = null;

                if (this.isBlock()) {
                    block = this.parseBlock(false, true);
                } else {
                    semicolonToken = this.eatExplicitOrAutomaticSemicolon(false);
                }

                return this.factory.constructorDeclaration(constructorKeyword, parameterList, block, semicolonToken);
            };

            ParserImpl.prototype.isMemberFunctionDeclaration = function (inErrorRecovery) {
                var index = 0;

                while (true) {
                    var token = this.peekToken(index);
                    if (this.isPropertyName(token, inErrorRecovery) && this.isCallSignature(index + 1)) {
                        return true;
                    }

                    if (ParserImpl.isModifier(token)) {
                        index++;
                        continue;
                    }

                    return false;
                }
            };

            ParserImpl.prototype.parseMemberFunctionDeclaration = function () {
                var modifierArray = this.getArray();

                while (true) {
                    var currentToken = this.currentToken();
                    if (this.isPropertyName(currentToken, false) && this.isCallSignature(1)) {
                        break;
                    }

                    TypeScript.Debug.assert(ParserImpl.isModifier(currentToken));
                    modifierArray.push(this.eatAnyToken());
                }

                var modifiers = TypeScript.Syntax.list(modifierArray);
                this.returnZeroOrOneLengthArray(modifierArray);

                var propertyName = this.eatPropertyName();
                var callSignature = this.parseCallSignature(false);

                var newCallSignature = this.tryAddUnexpectedEqualsGreaterThanToken(callSignature);
                var parseBlockEvenWithNoOpenBrace = callSignature !== newCallSignature;
                callSignature = newCallSignature;

                var block = null;
                var semicolon = null;

                if (parseBlockEvenWithNoOpenBrace || this.isBlock()) {
                    block = this.parseBlock(parseBlockEvenWithNoOpenBrace, true);
                } else {
                    semicolon = this.eatExplicitOrAutomaticSemicolon(false);
                }

                return this.factory.memberFunctionDeclaration(modifiers, propertyName, callSignature, block, semicolon);
            };

            ParserImpl.prototype.isDefinitelyMemberVariablePropertyName = function (index) {
                if (TypeScript.SyntaxFacts.isAnyKeyword(this.peekToken(index).tokenKind)) {
                    switch (this.peekToken(index + 1).tokenKind) {
                        case 79 /* SemicolonToken */:
                        case 108 /* EqualsToken */:
                        case 107 /* ColonToken */:
                        case 72 /* CloseBraceToken */:
                        case 10 /* EndOfFileToken */:
                            return true;
                        default:
                            return false;
                    }
                } else {
                    return true;
                }
            };

            ParserImpl.prototype.isMemberVariableDeclaration = function (inErrorRecovery) {
                var index = 0;

                while (true) {
                    var token = this.peekToken(index);
                    if (this.isPropertyName(token, inErrorRecovery) && this.isDefinitelyMemberVariablePropertyName(index)) {
                        return true;
                    }

                    if (ParserImpl.isModifier(this.peekToken(index))) {
                        index++;
                        continue;
                    }

                    return false;
                }
            };

            ParserImpl.prototype.parseMemberVariableDeclaration = function () {
                var modifierArray = this.getArray();

                while (true) {
                    var currentToken = this.currentToken();
                    if (this.isPropertyName(currentToken, false) && this.isDefinitelyMemberVariablePropertyName(0)) {
                        break;
                    }

                    TypeScript.Debug.assert(ParserImpl.isModifier(currentToken));
                    modifierArray.push(this.eatAnyToken());
                }

                var modifiers = TypeScript.Syntax.list(modifierArray);
                this.returnZeroOrOneLengthArray(modifierArray);

                var variableDeclarator = this.parseVariableDeclarator(true, true);
                var semicolon = this.eatExplicitOrAutomaticSemicolon(false);

                return this.factory.memberVariableDeclaration(modifiers, variableDeclarator, semicolon);
            };

            ParserImpl.prototype.parseClassElement = function (inErrorRecovery) {
                if (this.currentNode() !== null && this.currentNode().isClassElement()) {
                    return this.eatNode();
                }

                if (this.isConstructorDeclaration()) {
                    return this.parseConstructorDeclaration();
                } else if (this.isMemberFunctionDeclaration(inErrorRecovery)) {
                    return this.parseMemberFunctionDeclaration();
                } else if (this.isMemberAccessorDeclaration(inErrorRecovery)) {
                    return this.parseMemberAccessorDeclaration();
                } else if (this.isMemberVariableDeclaration(inErrorRecovery)) {
                    return this.parseMemberVariableDeclaration();
                } else if (this.isIndexSignature()) {
                    return this.parseIndexSignature();
                } else {
                    throw TypeScript.Errors.invalidOperation();
                }
            };

            ParserImpl.prototype.tryAddUnexpectedEqualsGreaterThanToken = function (callSignature) {
                var token0 = this.currentToken();

                var hasEqualsGreaterThanToken = token0.tokenKind === 86 /* EqualsGreaterThanToken */;
                if (hasEqualsGreaterThanToken) {
                    var diagnostic = new TypeScript.SyntaxDiagnostic(this.fileName, this.currentTokenStart(), token0.width(), 16 /* Unexpected_token_ */, []);
                    this.addDiagnostic(diagnostic);

                    var token = this.eatAnyToken();
                    return this.addSkippedTokenAfterNode(callSignature, token0);
                }

                return callSignature;
            };

            ParserImpl.prototype.isFunctionDeclaration = function () {
                var index = this.modifierCount();
                return this.peekToken(index).tokenKind === 27 /* FunctionKeyword */;
            };

            ParserImpl.prototype.parseFunctionDeclaration = function () {
                var modifiers = this.parseModifiers();
                var functionKeyword = this.eatKeyword(27 /* FunctionKeyword */);
                var identifier = this.eatIdentifierToken();
                var callSignature = this.parseCallSignature(false);

                var newCallSignature = this.tryAddUnexpectedEqualsGreaterThanToken(callSignature);
                var parseBlockEvenWithNoOpenBrace = callSignature !== newCallSignature;
                callSignature = newCallSignature;

                var semicolonToken = null;
                var block = null;

                if (parseBlockEvenWithNoOpenBrace || this.isBlock()) {
                    block = this.parseBlock(parseBlockEvenWithNoOpenBrace, true);
                } else {
                    semicolonToken = this.eatExplicitOrAutomaticSemicolon(false);
                }

                return this.factory.functionDeclaration(modifiers, functionKeyword, identifier, callSignature, block, semicolonToken);
            };

            ParserImpl.prototype.isModuleDeclaration = function () {
                var index = this.modifierCount();

                if (index > 0 && this.peekToken(index).tokenKind === 66 /* ModuleKeyword */) {
                    return true;
                }

                if (this.currentToken().tokenKind === 66 /* ModuleKeyword */) {
                    var token1 = this.peekToken(1);
                    return this.isIdentifier(token1) || token1.tokenKind === 14 /* StringLiteral */;
                }

                return false;
            };

            ParserImpl.prototype.parseModuleDeclaration = function () {
                var modifiers = this.parseModifiers();
                var moduleKeyword = this.eatKeyword(66 /* ModuleKeyword */);

                var moduleName = null;
                var stringLiteral = null;

                if (this.currentToken().tokenKind === 14 /* StringLiteral */) {
                    stringLiteral = this.eatToken(14 /* StringLiteral */);
                } else {
                    moduleName = this.parseName();
                }

                var openBraceToken = this.eatToken(71 /* OpenBraceToken */);

                var moduleElements = TypeScript.Syntax.emptyList;
                if (openBraceToken.width() > 0) {
                    var result = this.parseSyntaxList(4 /* ModuleDeclaration_ModuleElements */);
                    moduleElements = result.list;
                    openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);
                }

                var closeBraceToken = this.eatToken(72 /* CloseBraceToken */);

                return this.factory.moduleDeclaration(modifiers, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken);
            };

            ParserImpl.prototype.isInterfaceDeclaration = function () {
                var index = this.modifierCount();

                if (index > 0 && this.peekToken(index).tokenKind === 52 /* InterfaceKeyword */) {
                    return true;
                }

                return this.currentToken().tokenKind === 52 /* InterfaceKeyword */ && this.isIdentifier(this.peekToken(1));
            };

            ParserImpl.prototype.parseInterfaceDeclaration = function () {
                var modifiers = this.parseModifiers();
                var interfaceKeyword = this.eatKeyword(52 /* InterfaceKeyword */);
                var identifier = this.eatIdentifierToken();
                var typeParameterList = this.parseOptionalTypeParameterList(false);
                var heritageClauses = this.parseHeritageClauses();

                var objectType = this.parseObjectType();
                return this.factory.interfaceDeclaration(modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, objectType);
            };

            ParserImpl.prototype.parseObjectType = function () {
                var openBraceToken = this.eatToken(71 /* OpenBraceToken */);

                var typeMembers = TypeScript.Syntax.emptySeparatedList;
                if (openBraceToken.width() > 0) {
                    var result = this.parseSeparatedSyntaxList(512 /* ObjectType_TypeMembers */);
                    typeMembers = result.list;
                    openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);
                }

                var closeBraceToken = this.eatToken(72 /* CloseBraceToken */);
                return this.factory.objectType(openBraceToken, typeMembers, closeBraceToken);
            };

            ParserImpl.prototype.isTypeMember = function (inErrorRecovery) {
                if (this.currentNode() !== null && this.currentNode().isTypeMember()) {
                    return true;
                }

                return this.isCallSignature(0) || this.isConstructSignature() || this.isIndexSignature() || this.isMethodSignature(inErrorRecovery) || this.isPropertySignature(inErrorRecovery);
            };

            ParserImpl.prototype.parseTypeMember = function () {
                if (this.currentNode() !== null && this.currentNode().isTypeMember()) {
                    return this.eatNode();
                }

                if (this.isCallSignature(0)) {
                    return this.parseCallSignature(false);
                } else if (this.isConstructSignature()) {
                    return this.parseConstructSignature();
                } else if (this.isIndexSignature()) {
                    return this.parseIndexSignature();
                } else if (this.isMethodSignature(false)) {
                    return this.parseMethodSignature();
                } else if (this.isPropertySignature(false)) {
                    return this.parsePropertySignature();
                } else {
                    throw TypeScript.Errors.invalidOperation();
                }
            };

            ParserImpl.prototype.parseConstructSignature = function () {
                var newKeyword = this.eatKeyword(31 /* NewKeyword */);
                var callSignature = this.parseCallSignature(false);

                return this.factory.constructSignature(newKeyword, callSignature);
            };

            ParserImpl.prototype.parseIndexSignature = function () {
                var openBracketToken = this.eatToken(75 /* OpenBracketToken */);
                var parameter = this.parseParameter();
                var closeBracketToken = this.eatToken(76 /* CloseBracketToken */);
                var typeAnnotation = this.parseOptionalTypeAnnotation(false);

                return this.factory.indexSignature(openBracketToken, parameter, closeBracketToken, typeAnnotation);
            };

            ParserImpl.prototype.parseMethodSignature = function () {
                var propertyName = this.eatPropertyName();
                var questionToken = this.tryEatToken(106 /* QuestionToken */);
                var callSignature = this.parseCallSignature(false);

                return this.factory.methodSignature(propertyName, questionToken, callSignature);
            };

            ParserImpl.prototype.parsePropertySignature = function () {
                var propertyName = this.eatPropertyName();
                var questionToken = this.tryEatToken(106 /* QuestionToken */);
                var typeAnnotation = this.parseOptionalTypeAnnotation(false);

                return this.factory.propertySignature(propertyName, questionToken, typeAnnotation);
            };

            ParserImpl.prototype.isCallSignature = function (tokenIndex) {
                var tokenKind = this.peekToken(tokenIndex).tokenKind;
                return tokenKind === 73 /* OpenParenToken */ || tokenKind === 81 /* LessThanToken */;
            };

            ParserImpl.prototype.isConstructSignature = function () {
                if (this.currentToken().tokenKind !== 31 /* NewKeyword */) {
                    return false;
                }

                var token1 = this.peekToken(1);
                return token1.tokenKind === 81 /* LessThanToken */ || token1.tokenKind === 73 /* OpenParenToken */;
            };

            ParserImpl.prototype.isIndexSignature = function () {
                return this.currentToken().tokenKind === 75 /* OpenBracketToken */;
            };

            ParserImpl.prototype.isMethodSignature = function (inErrorRecovery) {
                if (this.isPropertyName(this.currentToken(), inErrorRecovery)) {
                    if (this.isCallSignature(1)) {
                        return true;
                    }

                    if (this.peekToken(1).tokenKind === 106 /* QuestionToken */ && this.isCallSignature(2)) {
                        return true;
                    }
                }

                return false;
            };

            ParserImpl.prototype.isPropertySignature = function (inErrorRecovery) {
                var currentToken = this.currentToken();

                if (ParserImpl.isModifier(currentToken) && !currentToken.hasTrailingNewLine() && this.isPropertyName(this.peekToken(1), inErrorRecovery)) {
                    return false;
                }

                return this.isPropertyName(currentToken, inErrorRecovery);
            };

            ParserImpl.prototype.isHeritageClause = function () {
                var token0 = this.currentToken();
                return token0.tokenKind === 48 /* ExtendsKeyword */ || token0.tokenKind === 51 /* ImplementsKeyword */;
            };

            ParserImpl.prototype.isNotHeritageClauseTypeName = function () {
                if (this.currentToken().tokenKind === 51 /* ImplementsKeyword */ || this.currentToken().tokenKind === 48 /* ExtendsKeyword */) {
                    return this.isIdentifier(this.peekToken(1));
                }

                return false;
            };

            ParserImpl.prototype.isHeritageClauseTypeName = function () {
                if (this.isName()) {
                    return !this.isNotHeritageClauseTypeName();
                }

                return false;
            };

            ParserImpl.prototype.parseHeritageClause = function () {
                var extendsOrImplementsKeyword = this.eatAnyToken();
                TypeScript.Debug.assert(extendsOrImplementsKeyword.tokenKind === 48 /* ExtendsKeyword */ || extendsOrImplementsKeyword.tokenKind === 51 /* ImplementsKeyword */);

                var result = this.parseSeparatedSyntaxList(2048 /* HeritageClause_TypeNameList */);
                var typeNames = result.list;
                extendsOrImplementsKeyword = this.addSkippedTokensAfterToken(extendsOrImplementsKeyword, result.skippedTokens);

                return this.factory.heritageClause(extendsOrImplementsKeyword, typeNames);
            };

            ParserImpl.prototype.isStatement = function (inErrorRecovery) {
                if (this.currentNode() !== null && this.currentNode().isStatement()) {
                    return true;
                }

                switch (this.currentToken().tokenKind) {
                    case 57 /* PublicKeyword */:
                    case 55 /* PrivateKeyword */:
                    case 58 /* StaticKeyword */:
                        var token1 = this.peekToken(1);
                        if (TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(token1)) {
                            return false;
                        }
                }

                return this.isVariableStatement() || this.isLabeledStatement() || this.isFunctionDeclaration() || this.isIfStatement() || this.isBlock() || this.isExpressionStatement() || this.isReturnStatement() || this.isSwitchStatement() || this.isThrowStatement() || this.isBreakStatement() || this.isContinueStatement() || this.isForOrForInStatement() || this.isEmptyStatement(inErrorRecovery) || this.isWhileStatement() || this.isWithStatement() || this.isDoStatement() || this.isTryStatement() || this.isDebuggerStatement();
            };

            ParserImpl.prototype.parseStatement = function () {
                if (this.currentNode() !== null && this.currentNode().isStatement()) {
                    return this.eatNode();
                }

                if (this.isVariableStatement()) {
                    return this.parseVariableStatement();
                } else if (this.isLabeledStatement()) {
                    return this.parseLabeledStatement();
                } else if (this.isFunctionDeclaration()) {
                    return this.parseFunctionDeclaration();
                } else if (this.isIfStatement()) {
                    return this.parseIfStatement();
                } else if (this.isBlock()) {
                    return this.parseBlock(false, false);
                } else if (this.isReturnStatement()) {
                    return this.parseReturnStatement();
                } else if (this.isSwitchStatement()) {
                    return this.parseSwitchStatement();
                } else if (this.isThrowStatement()) {
                    return this.parseThrowStatement();
                } else if (this.isBreakStatement()) {
                    return this.parseBreakStatement();
                } else if (this.isContinueStatement()) {
                    return this.parseContinueStatement();
                } else if (this.isForOrForInStatement()) {
                    return this.parseForOrForInStatement();
                } else if (this.isEmptyStatement(false)) {
                    return this.parseEmptyStatement();
                } else if (this.isWhileStatement()) {
                    return this.parseWhileStatement();
                } else if (this.isWithStatement()) {
                    return this.parseWithStatement();
                } else if (this.isDoStatement()) {
                    return this.parseDoStatement();
                } else if (this.isTryStatement()) {
                    return this.parseTryStatement();
                } else if (this.isDebuggerStatement()) {
                    return this.parseDebuggerStatement();
                } else {
                    return this.parseExpressionStatement();
                }
            };

            ParserImpl.prototype.isDebuggerStatement = function () {
                return this.currentToken().tokenKind === 19 /* DebuggerKeyword */;
            };

            ParserImpl.prototype.parseDebuggerStatement = function () {
                var debuggerKeyword = this.eatKeyword(19 /* DebuggerKeyword */);
                var semicolonToken = this.eatExplicitOrAutomaticSemicolon(false);

                return this.factory.debuggerStatement(debuggerKeyword, semicolonToken);
            };

            ParserImpl.prototype.isDoStatement = function () {
                return this.currentToken().tokenKind === 22 /* DoKeyword */;
            };

            ParserImpl.prototype.parseDoStatement = function () {
                var doKeyword = this.eatKeyword(22 /* DoKeyword */);
                var statement = this.parseStatement();
                var whileKeyword = this.eatKeyword(42 /* WhileKeyword */);
                var openParenToken = this.eatToken(73 /* OpenParenToken */);
                var condition = this.parseExpression(true);
                var closeParenToken = this.eatToken(74 /* CloseParenToken */);

                var semicolonToken = this.eatExplicitOrAutomaticSemicolon(true);

                return this.factory.doStatement(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken);
            };

            ParserImpl.prototype.isLabeledStatement = function () {
                return this.isIdentifier(this.currentToken()) && this.peekToken(1).tokenKind === 107 /* ColonToken */;
            };

            ParserImpl.prototype.parseLabeledStatement = function () {
                var identifier = this.eatIdentifierToken();
                var colonToken = this.eatToken(107 /* ColonToken */);
                var statement = this.parseStatement();

                return this.factory.labeledStatement(identifier, colonToken, statement);
            };

            ParserImpl.prototype.isTryStatement = function () {
                return this.currentToken().tokenKind === 38 /* TryKeyword */;
            };

            ParserImpl.prototype.parseTryStatement = function () {
                var tryKeyword = this.eatKeyword(38 /* TryKeyword */);

                var savedListParsingState = this.listParsingState;
                this.listParsingState |= 64 /* TryBlock_Statements */;
                var block = this.parseBlock(false, false);
                this.listParsingState = savedListParsingState;

                var catchClause = null;
                if (this.isCatchClause()) {
                    catchClause = this.parseCatchClause();
                }

                var finallyClause = null;
                if (catchClause === null || this.isFinallyClause()) {
                    finallyClause = this.parseFinallyClause();
                }

                return this.factory.tryStatement(tryKeyword, block, catchClause, finallyClause);
            };

            ParserImpl.prototype.isCatchClause = function () {
                return this.currentToken().tokenKind === 17 /* CatchKeyword */;
            };

            ParserImpl.prototype.parseCatchClause = function () {
                var catchKeyword = this.eatKeyword(17 /* CatchKeyword */);
                var openParenToken = this.eatToken(73 /* OpenParenToken */);
                var identifier = this.eatIdentifierToken();
                var typeAnnotation = this.parseOptionalTypeAnnotation(false);
                var closeParenToken = this.eatToken(74 /* CloseParenToken */);

                var savedListParsingState = this.listParsingState;
                this.listParsingState |= 128 /* CatchBlock_Statements */;
                var block = this.parseBlock(false, false);
                this.listParsingState = savedListParsingState;

                return this.factory.catchClause(catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block);
            };

            ParserImpl.prototype.isFinallyClause = function () {
                return this.currentToken().tokenKind === 25 /* FinallyKeyword */;
            };

            ParserImpl.prototype.parseFinallyClause = function () {
                var finallyKeyword = this.eatKeyword(25 /* FinallyKeyword */);
                var block = this.parseBlock(false, false);

                return this.factory.finallyClause(finallyKeyword, block);
            };

            ParserImpl.prototype.isWithStatement = function () {
                return this.currentToken().tokenKind === 43 /* WithKeyword */;
            };

            ParserImpl.prototype.parseWithStatement = function () {
                var withKeyword = this.eatKeyword(43 /* WithKeyword */);
                var openParenToken = this.eatToken(73 /* OpenParenToken */);
                var condition = this.parseExpression(true);
                var closeParenToken = this.eatToken(74 /* CloseParenToken */);
                var statement = this.parseStatement();

                return this.factory.withStatement(withKeyword, openParenToken, condition, closeParenToken, statement);
            };

            ParserImpl.prototype.isWhileStatement = function () {
                return this.currentToken().tokenKind === 42 /* WhileKeyword */;
            };

            ParserImpl.prototype.parseWhileStatement = function () {
                var whileKeyword = this.eatKeyword(42 /* WhileKeyword */);
                var openParenToken = this.eatToken(73 /* OpenParenToken */);
                var condition = this.parseExpression(true);
                var closeParenToken = this.eatToken(74 /* CloseParenToken */);
                var statement = this.parseStatement();

                return this.factory.whileStatement(whileKeyword, openParenToken, condition, closeParenToken, statement);
            };

            ParserImpl.prototype.isEmptyStatement = function (inErrorRecovery) {
                if (inErrorRecovery) {
                    return false;
                }

                return this.currentToken().tokenKind === 79 /* SemicolonToken */;
            };

            ParserImpl.prototype.parseEmptyStatement = function () {
                var semicolonToken = this.eatToken(79 /* SemicolonToken */);
                return this.factory.emptyStatement(semicolonToken);
            };

            ParserImpl.prototype.isForOrForInStatement = function () {
                return this.currentToken().tokenKind === 26 /* ForKeyword */;
            };

            ParserImpl.prototype.parseForOrForInStatement = function () {
                var forKeyword = this.eatKeyword(26 /* ForKeyword */);
                var openParenToken = this.eatToken(73 /* OpenParenToken */);

                var currentToken = this.currentToken();
                if (currentToken.tokenKind === 40 /* VarKeyword */) {
                    return this.parseForOrForInStatementWithVariableDeclaration(forKeyword, openParenToken);
                } else if (currentToken.tokenKind === 79 /* SemicolonToken */) {
                    return this.parseForStatement(forKeyword, openParenToken);
                } else {
                    return this.parseForOrForInStatementWithInitializer(forKeyword, openParenToken);
                }
            };

            ParserImpl.prototype.parseForOrForInStatementWithVariableDeclaration = function (forKeyword, openParenToken) {
                var variableDeclaration = this.parseVariableDeclaration(false);

                if (this.currentToken().tokenKind === 29 /* InKeyword */) {
                    return this.parseForInStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, variableDeclaration, null);
                }

                return this.parseForStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, variableDeclaration, null);
            };

            ParserImpl.prototype.parseForInStatementWithVariableDeclarationOrInitializer = function (forKeyword, openParenToken, variableDeclaration, initializer) {
                var inKeyword = this.eatKeyword(29 /* InKeyword */);
                var expression = this.parseExpression(true);
                var closeParenToken = this.eatToken(74 /* CloseParenToken */);
                var statement = this.parseStatement();

                return this.factory.forInStatement(forKeyword, openParenToken, variableDeclaration, initializer, inKeyword, expression, closeParenToken, statement);
            };

            ParserImpl.prototype.parseForOrForInStatementWithInitializer = function (forKeyword, openParenToken) {
                var initializer = this.parseExpression(false);
                if (this.currentToken().tokenKind === 29 /* InKeyword */) {
                    return this.parseForInStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, null, initializer);
                } else {
                    return this.parseForStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, null, initializer);
                }
            };

            ParserImpl.prototype.parseForStatement = function (forKeyword, openParenToken) {
                var initializer = null;

                if (this.currentToken().tokenKind !== 79 /* SemicolonToken */ && this.currentToken().tokenKind !== 74 /* CloseParenToken */ && this.currentToken().tokenKind !== 10 /* EndOfFileToken */) {
                    initializer = this.parseExpression(false);
                }

                return this.parseForStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, null, initializer);
            };

            ParserImpl.prototype.parseForStatementWithVariableDeclarationOrInitializer = function (forKeyword, openParenToken, variableDeclaration, initializer) {
                var firstSemicolonToken = this.eatToken(79 /* SemicolonToken */);

                var condition = null;
                if (this.currentToken().tokenKind !== 79 /* SemicolonToken */ && this.currentToken().tokenKind !== 74 /* CloseParenToken */ && this.currentToken().tokenKind !== 10 /* EndOfFileToken */) {
                    condition = this.parseExpression(true);
                }

                var secondSemicolonToken = this.eatToken(79 /* SemicolonToken */);

                var incrementor = null;
                if (this.currentToken().tokenKind !== 74 /* CloseParenToken */ && this.currentToken().tokenKind !== 10 /* EndOfFileToken */) {
                    incrementor = this.parseExpression(true);
                }

                var closeParenToken = this.eatToken(74 /* CloseParenToken */);
                var statement = this.parseStatement();

                return this.factory.forStatement(forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement);
            };

            ParserImpl.prototype.isBreakStatement = function () {
                return this.currentToken().tokenKind === 15 /* BreakKeyword */;
            };

            ParserImpl.prototype.parseBreakStatement = function () {
                var breakKeyword = this.eatKeyword(15 /* BreakKeyword */);

                var identifier = null;
                if (!this.canEatExplicitOrAutomaticSemicolon(false)) {
                    if (this.isIdentifier(this.currentToken())) {
                        identifier = this.eatIdentifierToken();
                    }
                }

                var semicolon = this.eatExplicitOrAutomaticSemicolon(false);
                return this.factory.breakStatement(breakKeyword, identifier, semicolon);
            };

            ParserImpl.prototype.isContinueStatement = function () {
                return this.currentToken().tokenKind === 18 /* ContinueKeyword */;
            };

            ParserImpl.prototype.parseContinueStatement = function () {
                var continueKeyword = this.eatKeyword(18 /* ContinueKeyword */);

                var identifier = null;
                if (!this.canEatExplicitOrAutomaticSemicolon(false)) {
                    if (this.isIdentifier(this.currentToken())) {
                        identifier = this.eatIdentifierToken();
                    }
                }

                var semicolon = this.eatExplicitOrAutomaticSemicolon(false);
                return this.factory.continueStatement(continueKeyword, identifier, semicolon);
            };

            ParserImpl.prototype.isSwitchStatement = function () {
                return this.currentToken().tokenKind === 34 /* SwitchKeyword */;
            };

            ParserImpl.prototype.parseSwitchStatement = function () {
                var switchKeyword = this.eatKeyword(34 /* SwitchKeyword */);
                var openParenToken = this.eatToken(73 /* OpenParenToken */);
                var expression = this.parseExpression(true);
                var closeParenToken = this.eatToken(74 /* CloseParenToken */);

                var openBraceToken = this.eatToken(71 /* OpenBraceToken */);

                var switchClauses = TypeScript.Syntax.emptyList;
                if (openBraceToken.width() > 0) {
                    var result = this.parseSyntaxList(8 /* SwitchStatement_SwitchClauses */);
                    switchClauses = result.list;
                    openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);
                }

                var closeBraceToken = this.eatToken(72 /* CloseBraceToken */);
                return this.factory.switchStatement(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken);
            };

            ParserImpl.prototype.isCaseSwitchClause = function () {
                return this.currentToken().tokenKind === 16 /* CaseKeyword */;
            };

            ParserImpl.prototype.isDefaultSwitchClause = function () {
                return this.currentToken().tokenKind === 20 /* DefaultKeyword */;
            };

            ParserImpl.prototype.isSwitchClause = function () {
                if (this.currentNode() !== null && this.currentNode().isSwitchClause()) {
                    return true;
                }

                return this.isCaseSwitchClause() || this.isDefaultSwitchClause();
            };

            ParserImpl.prototype.parseSwitchClause = function () {
                if (this.currentNode() !== null && this.currentNode().isSwitchClause()) {
                    return this.eatNode();
                }

                if (this.isCaseSwitchClause()) {
                    return this.parseCaseSwitchClause();
                } else if (this.isDefaultSwitchClause()) {
                    return this.parseDefaultSwitchClause();
                } else {
                    throw TypeScript.Errors.invalidOperation();
                }
            };

            ParserImpl.prototype.parseCaseSwitchClause = function () {
                var caseKeyword = this.eatKeyword(16 /* CaseKeyword */);
                var expression = this.parseExpression(true);
                var colonToken = this.eatToken(107 /* ColonToken */);
                var statements = TypeScript.Syntax.emptyList;

                if (colonToken.fullWidth() > 0) {
                    var result = this.parseSyntaxList(16 /* SwitchClause_Statements */);
                    statements = result.list;
                    colonToken = this.addSkippedTokensAfterToken(colonToken, result.skippedTokens);
                }

                return this.factory.caseSwitchClause(caseKeyword, expression, colonToken, statements);
            };

            ParserImpl.prototype.parseDefaultSwitchClause = function () {
                var defaultKeyword = this.eatKeyword(20 /* DefaultKeyword */);
                var colonToken = this.eatToken(107 /* ColonToken */);
                var statements = TypeScript.Syntax.emptyList;

                if (colonToken.fullWidth() > 0) {
                    var result = this.parseSyntaxList(16 /* SwitchClause_Statements */);
                    statements = result.list;
                    colonToken = this.addSkippedTokensAfterToken(colonToken, result.skippedTokens);
                }

                return this.factory.defaultSwitchClause(defaultKeyword, colonToken, statements);
            };

            ParserImpl.prototype.isThrowStatement = function () {
                return this.currentToken().tokenKind === 36 /* ThrowKeyword */;
            };

            ParserImpl.prototype.parseThrowStatement = function () {
                var throwKeyword = this.eatKeyword(36 /* ThrowKeyword */);

                var expression = null;
                if (this.canEatExplicitOrAutomaticSemicolon(false)) {
                    var token = this.createMissingToken(11 /* IdentifierName */, null);
                    expression = token;
                } else {
                    expression = this.parseExpression(true);
                }

                var semicolonToken = this.eatExplicitOrAutomaticSemicolon(false);

                return this.factory.throwStatement(throwKeyword, expression, semicolonToken);
            };

            ParserImpl.prototype.isReturnStatement = function () {
                return this.currentToken().tokenKind === 33 /* ReturnKeyword */;
            };

            ParserImpl.prototype.parseReturnStatement = function () {
                var returnKeyword = this.eatKeyword(33 /* ReturnKeyword */);

                var expression = null;
                if (!this.canEatExplicitOrAutomaticSemicolon(false)) {
                    expression = this.parseExpression(true);
                }

                var semicolonToken = this.eatExplicitOrAutomaticSemicolon(false);

                return this.factory.returnStatement(returnKeyword, expression, semicolonToken);
            };

            ParserImpl.prototype.isExpressionStatement = function () {
                var currentToken = this.currentToken();

                var kind = currentToken.tokenKind;
                if (kind === 71 /* OpenBraceToken */ || kind === 27 /* FunctionKeyword */) {
                    return false;
                }

                return this.isExpression();
            };

            ParserImpl.prototype.isAssignmentOrOmittedExpression = function () {
                if (this.currentToken().tokenKind === 80 /* CommaToken */) {
                    return true;
                }

                return this.isExpression();
            };

            ParserImpl.prototype.parseAssignmentOrOmittedExpression = function () {
                if (this.currentToken().tokenKind === 80 /* CommaToken */) {
                    return this.factory.omittedExpression();
                }

                return this.parseAssignmentExpression(true);
            };

            ParserImpl.prototype.isExpression = function () {
                var currentToken = this.currentToken();
                var kind = currentToken.tokenKind;

                switch (kind) {
                    case 13 /* NumericLiteral */:
                    case 14 /* StringLiteral */:
                    case 12 /* RegularExpressionLiteral */:
                        return true;

                    case 75 /* OpenBracketToken */:
                    case 73 /* OpenParenToken */:
                        return true;

                    case 81 /* LessThanToken */:
                        return true;

                    case 94 /* PlusPlusToken */:
                    case 95 /* MinusMinusToken */:
                    case 90 /* PlusToken */:
                    case 91 /* MinusToken */:
                    case 103 /* TildeToken */:
                    case 102 /* ExclamationToken */:
                        return true;

                    case 71 /* OpenBraceToken */:
                        return true;

                    case 86 /* EqualsGreaterThanToken */:
                        return true;

                    case 119 /* SlashToken */:
                    case 120 /* SlashEqualsToken */:
                        return true;

                    case 50 /* SuperKeyword */:
                    case 35 /* ThisKeyword */:
                    case 37 /* TrueKeyword */:
                    case 24 /* FalseKeyword */:
                    case 32 /* NullKeyword */:
                        return true;

                    case 31 /* NewKeyword */:
                        return true;

                    case 21 /* DeleteKeyword */:
                    case 41 /* VoidKeyword */:
                    case 39 /* TypeOfKeyword */:
                        return true;

                    case 27 /* FunctionKeyword */:
                        return true;
                }

                if (this.isIdentifier(this.currentToken())) {
                    return true;
                }

                return false;
            };

            ParserImpl.prototype.parseExpressionStatement = function () {
                var expression = this.parseExpression(true);

                var semicolon = this.eatExplicitOrAutomaticSemicolon(false);

                return this.factory.expressionStatement(expression, semicolon);
            };

            ParserImpl.prototype.isIfStatement = function () {
                return this.currentToken().tokenKind === 28 /* IfKeyword */;
            };

            ParserImpl.prototype.parseIfStatement = function () {
                var ifKeyword = this.eatKeyword(28 /* IfKeyword */);
                var openParenToken = this.eatToken(73 /* OpenParenToken */);
                var condition = this.parseExpression(true);
                var closeParenToken = this.eatToken(74 /* CloseParenToken */);
                var statement = this.parseStatement();

                var elseClause = null;
                if (this.isElseClause()) {
                    elseClause = this.parseElseClause();
                }

                return this.factory.ifStatement(ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause);
            };

            ParserImpl.prototype.isElseClause = function () {
                return this.currentToken().tokenKind === 23 /* ElseKeyword */;
            };

            ParserImpl.prototype.parseElseClause = function () {
                var elseKeyword = this.eatKeyword(23 /* ElseKeyword */);
                var statement = this.parseStatement();

                return this.factory.elseClause(elseKeyword, statement);
            };

            ParserImpl.prototype.isVariableStatement = function () {
                var index = this.modifierCount();
                return this.peekToken(index).tokenKind === 40 /* VarKeyword */;
            };

            ParserImpl.prototype.parseVariableStatement = function () {
                var modifiers = this.parseModifiers();
                var variableDeclaration = this.parseVariableDeclaration(true);
                var semicolonToken = this.eatExplicitOrAutomaticSemicolon(false);

                return this.factory.variableStatement(modifiers, variableDeclaration, semicolonToken);
            };

            ParserImpl.prototype.parseVariableDeclaration = function (allowIn) {
                var varKeyword = this.eatKeyword(40 /* VarKeyword */);

                var listParsingState = allowIn ? 4096 /* VariableDeclaration_VariableDeclarators_AllowIn */ : 8192 /* VariableDeclaration_VariableDeclarators_DisallowIn */;

                var result = this.parseSeparatedSyntaxList(listParsingState);
                var variableDeclarators = result.list;
                varKeyword = this.addSkippedTokensAfterToken(varKeyword, result.skippedTokens);

                return this.factory.variableDeclaration(varKeyword, variableDeclarators);
            };

            ParserImpl.prototype.isVariableDeclarator = function () {
                if (this.currentNode() !== null && this.currentNode().kind() === 224 /* VariableDeclarator */) {
                    return true;
                }

                return this.isIdentifier(this.currentToken());
            };

            ParserImpl.prototype.canReuseVariableDeclaratorNode = function (node) {
                if (node === null || node.kind() !== 224 /* VariableDeclarator */) {
                    return false;
                }

                var variableDeclarator = node;
                return variableDeclarator.equalsValueClause === null;
            };

            ParserImpl.prototype.parseVariableDeclarator = function (allowIn, allowPropertyName) {
                if (this.canReuseVariableDeclaratorNode(this.currentNode())) {
                    return this.eatNode();
                }

                var propertyName = allowPropertyName ? this.eatPropertyName() : this.eatIdentifierToken();
                var equalsValueClause = null;
                var typeAnnotation = null;

                if (propertyName.width() > 0) {
                    typeAnnotation = this.parseOptionalTypeAnnotation(false);

                    if (this.isEqualsValueClause(false)) {
                        equalsValueClause = this.parseEqualsValueClause(allowIn);
                    }
                }

                return this.factory.variableDeclarator(propertyName, typeAnnotation, equalsValueClause);
            };

            ParserImpl.prototype.isColonValueClause = function () {
                return this.currentToken().tokenKind === 107 /* ColonToken */;
            };

            ParserImpl.prototype.isEqualsValueClause = function (inParameter) {
                var token0 = this.currentToken();
                if (token0.tokenKind === 108 /* EqualsToken */) {
                    return true;
                }

                if (!this.previousToken().hasTrailingNewLine()) {
                    if (token0.tokenKind === 86 /* EqualsGreaterThanToken */) {
                        return false;
                    }

                    if (token0.tokenKind === 71 /* OpenBraceToken */ && inParameter) {
                        return false;
                    }

                    return this.isExpression();
                }

                return false;
            };

            ParserImpl.prototype.parseEqualsValueClause = function (allowIn) {
                var equalsToken = this.eatToken(108 /* EqualsToken */);
                var value = this.parseAssignmentExpression(allowIn);

                return this.factory.equalsValueClause(equalsToken, value);
            };

            ParserImpl.prototype.parseExpression = function (allowIn) {
                return this.parseSubExpression(0, allowIn);
            };

            ParserImpl.prototype.parseAssignmentExpression = function (allowIn) {
                return this.parseSubExpression(2 /* AssignmentExpressionPrecedence */, allowIn);
            };

            ParserImpl.prototype.parseUnaryExpression = function () {
                var currentTokenKind = this.currentToken().tokenKind;
                if (TypeScript.SyntaxFacts.isPrefixUnaryExpressionOperatorToken(currentTokenKind)) {
                    var operatorKind = TypeScript.SyntaxFacts.getPrefixUnaryExpressionFromOperatorToken(currentTokenKind);

                    var operatorToken = this.eatAnyToken();

                    var operand = this.parseUnaryExpression();
                    return this.factory.prefixUnaryExpression(operatorKind, operatorToken, operand);
                } else {
                    return this.parseTerm(false);
                }
            };

            ParserImpl.prototype.parseSubExpression = function (precedence, allowIn) {
                var leftOperand = this.parseUnaryExpression();
                leftOperand = this.parseBinaryOrConditionalExpressions(precedence, allowIn, leftOperand);

                return leftOperand;
            };

            ParserImpl.prototype.parseBinaryOrConditionalExpressions = function (precedence, allowIn, leftOperand) {
                while (true) {
                    var token0 = this.currentToken();
                    var token0Kind = token0.tokenKind;

                    if (TypeScript.SyntaxFacts.isBinaryExpressionOperatorToken(token0Kind)) {
                        if (token0Kind === 29 /* InKeyword */ && !allowIn) {
                            break;
                        }

                        var mergedToken = this.tryMergeBinaryExpressionTokens();
                        var tokenKind = mergedToken === null ? token0Kind : mergedToken.syntaxKind;

                        var binaryExpressionKind = TypeScript.SyntaxFacts.getBinaryExpressionFromOperatorToken(tokenKind);
                        var newPrecedence = ParserImpl.getPrecedence(binaryExpressionKind);

                        if (newPrecedence < precedence) {
                            break;
                        }

                        if (newPrecedence === precedence && !this.isRightAssociative(binaryExpressionKind)) {
                            break;
                        }

                        var operatorToken = mergedToken === null ? token0 : TypeScript.Syntax.token(mergedToken.syntaxKind).withLeadingTrivia(token0.leadingTrivia()).withTrailingTrivia(this.peekToken(mergedToken.tokenCount - 1).trailingTrivia());

                        var skipCount = mergedToken === null ? 1 : mergedToken.tokenCount;
                        for (var i = 0; i < skipCount; i++) {
                            this.eatAnyToken();
                        }

                        leftOperand = this.factory.binaryExpression(binaryExpressionKind, leftOperand, operatorToken, this.parseSubExpression(newPrecedence, allowIn));
                        continue;
                    }

                    if (token0Kind === 106 /* QuestionToken */ && precedence <= 3 /* ConditionalExpressionPrecedence */) {
                        var questionToken = this.eatToken(106 /* QuestionToken */);

                        var whenTrueExpression = this.parseAssignmentExpression(allowIn);
                        var colon = this.eatToken(107 /* ColonToken */);

                        var whenFalseExpression = this.parseAssignmentExpression(allowIn);
                        leftOperand = this.factory.conditionalExpression(leftOperand, questionToken, whenTrueExpression, colon, whenFalseExpression);
                        continue;
                    }

                    break;
                }

                return leftOperand;
            };

            ParserImpl.prototype.tryMergeBinaryExpressionTokens = function () {
                var token0 = this.currentToken();

                if (token0.tokenKind === 82 /* GreaterThanToken */ && !token0.hasTrailingTrivia()) {
                    var storage = this.mergeTokensStorage;
                    storage[0] = 0 /* None */;
                    storage[1] = 0 /* None */;
                    storage[2] = 0 /* None */;

                    for (var i = 0; i < storage.length; i++) {
                        var nextToken = this.peekToken(i + 1);

                        if (!nextToken.hasLeadingTrivia()) {
                            storage[i] = nextToken.tokenKind;
                        }

                        if (nextToken.hasTrailingTrivia()) {
                            break;
                        }
                    }

                    if (storage[0] === 82 /* GreaterThanToken */) {
                        if (storage[1] === 82 /* GreaterThanToken */) {
                            if (storage[2] === 108 /* EqualsToken */) {
                                return { tokenCount: 4, syntaxKind: 115 /* GreaterThanGreaterThanGreaterThanEqualsToken */ };
                            } else {
                                return { tokenCount: 3, syntaxKind: 98 /* GreaterThanGreaterThanGreaterThanToken */ };
                            }
                        } else if (storage[1] === 108 /* EqualsToken */) {
                            return { tokenCount: 3, syntaxKind: 114 /* GreaterThanGreaterThanEqualsToken */ };
                        } else {
                            return { tokenCount: 2, syntaxKind: 97 /* GreaterThanGreaterThanToken */ };
                        }
                    } else if (storage[0] === 108 /* EqualsToken */) {
                        return { tokenCount: 2, syntaxKind: 84 /* GreaterThanEqualsToken */ };
                    }
                }

                return null;
            };

            ParserImpl.prototype.isRightAssociative = function (expressionKind) {
                switch (expressionKind) {
                    case 173 /* AssignmentExpression */:
                    case 174 /* AddAssignmentExpression */:
                    case 175 /* SubtractAssignmentExpression */:
                    case 176 /* MultiplyAssignmentExpression */:
                    case 177 /* DivideAssignmentExpression */:
                    case 178 /* ModuloAssignmentExpression */:
                    case 179 /* AndAssignmentExpression */:
                    case 180 /* ExclusiveOrAssignmentExpression */:
                    case 181 /* OrAssignmentExpression */:
                    case 182 /* LeftShiftAssignmentExpression */:
                    case 183 /* SignedRightShiftAssignmentExpression */:
                    case 184 /* UnsignedRightShiftAssignmentExpression */:
                        return true;
                    default:
                        return false;
                }
            };

            ParserImpl.prototype.parseTerm = function (inObjectCreation) {
                var term = this.parseTermWorker();
                if (term === null) {
                    return this.eatIdentifierToken();
                }

                return this.parsePostFixExpression(term, inObjectCreation);
            };

            ParserImpl.prototype.parsePostFixExpression = function (expression, inObjectCreation) {
                while (true) {
                    var currentTokenKind = this.currentToken().tokenKind;
                    switch (currentTokenKind) {
                        case 73 /* OpenParenToken */:
                            if (inObjectCreation) {
                                return expression;
                            }

                            expression = this.factory.invocationExpression(expression, this.parseArgumentList(null));
                            continue;

                        case 81 /* LessThanToken */:
                            if (inObjectCreation) {
                                return expression;
                            }

                            var argumentList = this.tryParseArgumentList();
                            if (argumentList !== null) {
                                expression = this.factory.invocationExpression(expression, argumentList);
                                continue;
                            }

                            break;

                        case 75 /* OpenBracketToken */:
                            expression = this.parseElementAccessExpression(expression, inObjectCreation);
                            continue;

                        case 94 /* PlusPlusToken */:
                        case 95 /* MinusMinusToken */:
                            if (this.previousToken() !== null && this.previousToken().hasTrailingNewLine()) {
                                break;
                            }

                            expression = this.factory.postfixUnaryExpression(TypeScript.SyntaxFacts.getPostfixUnaryExpressionFromOperatorToken(currentTokenKind), expression, this.eatAnyToken());
                            continue;

                        case 77 /* DotToken */:
                            expression = this.factory.memberAccessExpression(expression, this.eatToken(77 /* DotToken */), this.eatIdentifierNameToken());
                            continue;
                    }

                    return expression;
                }
            };

            ParserImpl.prototype.tryParseArgumentList = function () {
                var typeArgumentList = null;

                if (this.currentToken().tokenKind === 81 /* LessThanToken */) {
                    var rewindPoint = this.getRewindPoint();
                    try  {
                        typeArgumentList = this.tryParseTypeArgumentList(true);
                        var token0 = this.currentToken();

                        var isOpenParen = token0.tokenKind === 73 /* OpenParenToken */;
                        var isDot = token0.tokenKind === 77 /* DotToken */;
                        var isOpenParenOrDot = isOpenParen || isDot;
                        if (typeArgumentList === null || !isOpenParenOrDot) {
                            this.rewind(rewindPoint);
                            return null;
                        }

                        if (isDot) {
                            var diagnostic = new TypeScript.SyntaxDiagnostic(this.fileName, this.currentTokenStart(), token0.width(), 138 /* A_parameter_list_must_follow_a_generic_type_argument_list______expected */, null);
                            this.addDiagnostic(diagnostic);

                            return this.factory.argumentList(typeArgumentList, TypeScript.Syntax.emptyToken(73 /* OpenParenToken */), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.emptyToken(74 /* CloseParenToken */));
                        }
                    } finally {
                        this.releaseRewindPoint(rewindPoint);
                    }
                }

                if (this.currentToken().tokenKind === 73 /* OpenParenToken */) {
                    return this.parseArgumentList(typeArgumentList);
                }

                return null;
            };

            ParserImpl.prototype.parseArgumentList = function (typeArgumentList) {
                var openParenToken = this.eatToken(73 /* OpenParenToken */);
                var arguments = TypeScript.Syntax.emptySeparatedList;

                if (openParenToken.fullWidth() > 0) {
                    var result = this.parseSeparatedSyntaxList(16384 /* ArgumentList_AssignmentExpressions */);
                    arguments = result.list;
                    openParenToken = this.addSkippedTokensAfterToken(openParenToken, result.skippedTokens);
                }

                var closeParenToken = this.eatToken(74 /* CloseParenToken */);

                return this.factory.argumentList(typeArgumentList, openParenToken, arguments, closeParenToken);
            };

            ParserImpl.prototype.parseElementAccessExpression = function (expression, inObjectCreation) {
                var start = this.currentTokenStart();
                var openBracketToken = this.eatToken(75 /* OpenBracketToken */);
                var argumentExpression;

                if (this.currentToken().tokenKind === 76 /* CloseBracketToken */ && inObjectCreation) {
                    var end = this.currentTokenStart() + this.currentToken().width();
                    var diagnostic = new TypeScript.SyntaxDiagnostic(this.fileName, start, end - start, 137 /* _new_T____cannot_be_used_to_create_an_array__Use__new_Array_T_____instead */, null);
                    this.addDiagnostic(diagnostic);

                    argumentExpression = TypeScript.Syntax.emptyToken(11 /* IdentifierName */);
                } else {
                    argumentExpression = this.parseExpression(true);
                }

                var closeBracketToken = this.eatToken(76 /* CloseBracketToken */);

                return this.factory.elementAccessExpression(expression, openBracketToken, argumentExpression, closeBracketToken);
            };

            ParserImpl.prototype.parseTermWorker = function () {
                var currentToken = this.currentToken();

                if (currentToken.tokenKind === 86 /* EqualsGreaterThanToken */) {
                    return this.parseSimpleArrowFunctionExpression();
                }

                if (this.isIdentifier(currentToken)) {
                    if (this.isSimpleArrowFunctionExpression()) {
                        return this.parseSimpleArrowFunctionExpression();
                    } else {
                        var identifier = this.eatIdentifierToken();
                        return identifier;
                    }
                }

                var currentTokenKind = currentToken.tokenKind;
                switch (currentTokenKind) {
                    case 35 /* ThisKeyword */:
                        return this.parseThisExpression();

                    case 37 /* TrueKeyword */:
                    case 24 /* FalseKeyword */:
                        return this.parseLiteralExpression();

                    case 32 /* NullKeyword */:
                        return this.parseLiteralExpression();

                    case 31 /* NewKeyword */:
                        return this.parseObjectCreationExpression();

                    case 27 /* FunctionKeyword */:
                        return this.parseFunctionExpression();

                    case 50 /* SuperKeyword */:
                        return this.parseSuperExpression();

                    case 39 /* TypeOfKeyword */:
                        return this.parseTypeOfExpression();

                    case 21 /* DeleteKeyword */:
                        return this.parseDeleteExpression();

                    case 41 /* VoidKeyword */:
                        return this.parseVoidExpression();

                    case 13 /* NumericLiteral */:
                        return this.parseLiteralExpression();

                    case 12 /* RegularExpressionLiteral */:
                        return this.parseLiteralExpression();

                    case 14 /* StringLiteral */:
                        return this.parseLiteralExpression();

                    case 75 /* OpenBracketToken */:
                        return this.parseArrayLiteralExpression();

                    case 71 /* OpenBraceToken */:
                        return this.parseObjectLiteralExpression();

                    case 73 /* OpenParenToken */:
                        return this.parseParenthesizedOrArrowFunctionExpression();

                    case 81 /* LessThanToken */:
                        return this.parseCastOrArrowFunctionExpression();

                    case 119 /* SlashToken */:
                    case 120 /* SlashEqualsToken */:
                        var result = this.tryReparseDivideAsRegularExpression();
                        if (result !== null) {
                            return result;
                        }
                        break;
                }

                return null;
            };

            ParserImpl.prototype.tryReparseDivideAsRegularExpression = function () {
                var currentToken = this.currentToken();

                if (this.previousToken() !== null) {
                    var previousTokenKind = this.previousToken().tokenKind;
                    switch (previousTokenKind) {
                        case 11 /* IdentifierName */:
                            return null;

                        case 35 /* ThisKeyword */:
                        case 37 /* TrueKeyword */:
                        case 24 /* FalseKeyword */:
                            return null;

                        case 14 /* StringLiteral */:
                        case 13 /* NumericLiteral */:
                        case 12 /* RegularExpressionLiteral */:
                        case 94 /* PlusPlusToken */:
                        case 95 /* MinusMinusToken */:
                        case 76 /* CloseBracketToken */:
                        case 72 /* CloseBraceToken */:
                            return null;
                    }
                }

                currentToken = this.currentTokenAllowingRegularExpression();

                if (currentToken.tokenKind === 119 /* SlashToken */ || currentToken.tokenKind === 120 /* SlashEqualsToken */) {
                    return null;
                } else if (currentToken.tokenKind === 12 /* RegularExpressionLiteral */) {
                    return this.parseLiteralExpression();
                } else {
                    throw TypeScript.Errors.invalidOperation();
                }
            };

            ParserImpl.prototype.parseTypeOfExpression = function () {
                var typeOfKeyword = this.eatKeyword(39 /* TypeOfKeyword */);
                var expression = this.parseUnaryExpression();

                return this.factory.typeOfExpression(typeOfKeyword, expression);
            };

            ParserImpl.prototype.parseDeleteExpression = function () {
                var deleteKeyword = this.eatKeyword(21 /* DeleteKeyword */);
                var expression = this.parseUnaryExpression();

                return this.factory.deleteExpression(deleteKeyword, expression);
            };

            ParserImpl.prototype.parseVoidExpression = function () {
                var voidKeyword = this.eatKeyword(41 /* VoidKeyword */);
                var expression = this.parseUnaryExpression();

                return this.factory.voidExpression(voidKeyword, expression);
            };

            ParserImpl.prototype.parseSuperExpression = function () {
                var superKeyword = this.eatKeyword(50 /* SuperKeyword */);
                return superKeyword;
            };

            ParserImpl.prototype.parseFunctionExpression = function () {
                var functionKeyword = this.eatKeyword(27 /* FunctionKeyword */);
                var identifier = null;

                if (this.isIdentifier(this.currentToken())) {
                    identifier = this.eatIdentifierToken();
                }

                var callSignature = this.parseCallSignature(false);
                var block = this.parseBlock(false, true);

                return this.factory.functionExpression(functionKeyword, identifier, callSignature, block);
            };

            ParserImpl.prototype.parseObjectCreationExpression = function () {
                var newKeyword = this.eatKeyword(31 /* NewKeyword */);

                var expression = this.parseTerm(true);
                var argumentList = this.tryParseArgumentList();

                return this.factory.objectCreationExpression(newKeyword, expression, argumentList);
            };

            ParserImpl.prototype.parseCastOrArrowFunctionExpression = function () {
                var rewindPoint = this.getRewindPoint();
                try  {
                    var arrowFunction = this.tryParseArrowFunctionExpression();
                    if (arrowFunction !== null) {
                        return arrowFunction;
                    }

                    this.rewind(rewindPoint);
                    return this.parseCastExpression();
                } finally {
                    this.releaseRewindPoint(rewindPoint);
                }
            };

            ParserImpl.prototype.parseCastExpression = function () {
                var lessThanToken = this.eatToken(81 /* LessThanToken */);
                var type = this.parseType();
                var greaterThanToken = this.eatToken(82 /* GreaterThanToken */);
                var expression = this.parseUnaryExpression();

                return this.factory.castExpression(lessThanToken, type, greaterThanToken, expression);
            };

            ParserImpl.prototype.parseParenthesizedOrArrowFunctionExpression = function () {
                var result = this.tryParseArrowFunctionExpression();
                if (result !== null) {
                    return result;
                }

                var openParenToken = this.eatToken(73 /* OpenParenToken */);
                var expression = this.parseExpression(true);
                var closeParenToken = this.eatToken(74 /* CloseParenToken */);

                return this.factory.parenthesizedExpression(openParenToken, expression, closeParenToken);
            };

            ParserImpl.prototype.tryParseArrowFunctionExpression = function () {
                var tokenKind = this.currentToken().tokenKind;

                if (this.isDefinitelyArrowFunctionExpression()) {
                    return this.parseParenthesizedArrowFunctionExpression(false);
                }

                if (!this.isPossiblyArrowFunctionExpression()) {
                    return null;
                }

                var rewindPoint = this.getRewindPoint();
                try  {
                    var arrowFunction = this.parseParenthesizedArrowFunctionExpression(true);
                    if (arrowFunction === null) {
                        this.rewind(rewindPoint);
                    }
                    return arrowFunction;
                } finally {
                    this.releaseRewindPoint(rewindPoint);
                }
            };

            ParserImpl.prototype.parseParenthesizedArrowFunctionExpression = function (requireArrow) {
                var currentToken = this.currentToken();

                var callSignature = this.parseCallSignature(true);

                if (requireArrow && this.currentToken().tokenKind !== 86 /* EqualsGreaterThanToken */) {
                    return null;
                }

                var equalsGreaterThanToken = this.eatToken(86 /* EqualsGreaterThanToken */);
                var body = this.parseArrowFunctionBody();

                return this.factory.parenthesizedArrowFunctionExpression(callSignature, equalsGreaterThanToken, body);
            };

            ParserImpl.prototype.parseArrowFunctionBody = function () {
                if (this.isBlock()) {
                    return this.parseBlock(false, false);
                } else {
                    return this.parseAssignmentExpression(true);
                }
            };

            ParserImpl.prototype.isSimpleArrowFunctionExpression = function () {
                if (this.currentToken().tokenKind === 86 /* EqualsGreaterThanToken */) {
                    return true;
                }

                return this.isIdentifier(this.currentToken()) && this.peekToken(1).tokenKind === 86 /* EqualsGreaterThanToken */;
            };

            ParserImpl.prototype.parseSimpleArrowFunctionExpression = function () {
                var identifier = this.eatIdentifierToken();
                var equalsGreaterThanToken = this.eatToken(86 /* EqualsGreaterThanToken */);
                var body = this.parseArrowFunctionBody();

                return this.factory.simpleArrowFunctionExpression(identifier, equalsGreaterThanToken, body);
            };

            ParserImpl.prototype.isBlock = function () {
                return this.currentToken().tokenKind === 71 /* OpenBraceToken */;
            };

            ParserImpl.prototype.isDefinitelyArrowFunctionExpression = function () {
                var token0 = this.currentToken();
                if (token0.tokenKind !== 73 /* OpenParenToken */) {
                    return false;
                }

                var token1 = this.peekToken(1);
                var token2;

                if (token1.tokenKind === 74 /* CloseParenToken */) {
                    token2 = this.peekToken(2);
                    return token2.tokenKind === 107 /* ColonToken */ || token2.tokenKind === 86 /* EqualsGreaterThanToken */ || token2.tokenKind === 71 /* OpenBraceToken */;
                }

                if (token1.tokenKind === 78 /* DotDotDotToken */) {
                    return true;
                }

                if (!this.isIdentifier(token1)) {
                    return false;
                }

                token2 = this.peekToken(2);
                if (token2.tokenKind === 107 /* ColonToken */) {
                    return true;
                }

                var token3 = this.peekToken(3);
                if (token2.tokenKind === 106 /* QuestionToken */) {
                    if (token3.tokenKind === 107 /* ColonToken */ || token3.tokenKind === 74 /* CloseParenToken */ || token3.tokenKind === 80 /* CommaToken */) {
                        return true;
                    }
                }

                if (token2.tokenKind === 74 /* CloseParenToken */) {
                    if (token3.tokenKind === 86 /* EqualsGreaterThanToken */) {
                        return true;
                    }
                }

                return false;
            };

            ParserImpl.prototype.isPossiblyArrowFunctionExpression = function () {
                var token0 = this.currentToken();
                if (token0.tokenKind !== 73 /* OpenParenToken */) {
                    return true;
                }

                var token1 = this.peekToken(1);

                if (!this.isIdentifier(token1)) {
                    return false;
                }

                var token2 = this.peekToken(2);
                if (token2.tokenKind === 108 /* EqualsToken */) {
                    return true;
                }

                if (token2.tokenKind === 80 /* CommaToken */) {
                    return true;
                }

                if (token2.tokenKind === 74 /* CloseParenToken */) {
                    var token3 = this.peekToken(3);
                    if (token3.tokenKind === 107 /* ColonToken */) {
                        return true;
                    }
                }

                return false;
            };

            ParserImpl.prototype.parseObjectLiteralExpression = function () {
                var openBraceToken = this.eatToken(71 /* OpenBraceToken */);

                var result = this.parseSeparatedSyntaxList(32768 /* ObjectLiteralExpression_PropertyAssignments */);
                var propertyAssignments = result.list;
                openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);

                var closeBraceToken = this.eatToken(72 /* CloseBraceToken */);

                return this.factory.objectLiteralExpression(openBraceToken, propertyAssignments, closeBraceToken);
            };

            ParserImpl.prototype.parsePropertyAssignment = function () {
                if (this.isGetAccessorPropertyAssignment(false)) {
                    return this.parseGetAccessorPropertyAssignment();
                } else if (this.isSetAccessorPropertyAssignment(false)) {
                    return this.parseSetAccessorPropertyAssignment();
                } else if (this.isFunctionPropertyAssignment(false)) {
                    return this.parseFunctionPropertyAssignment();
                } else if (this.isSimplePropertyAssignment(false)) {
                    return this.parseSimplePropertyAssignment();
                } else {
                    throw TypeScript.Errors.invalidOperation();
                }
            };

            ParserImpl.prototype.isPropertyAssignment = function (inErrorRecovery) {
                return this.isGetAccessorPropertyAssignment(inErrorRecovery) || this.isSetAccessorPropertyAssignment(inErrorRecovery) || this.isFunctionPropertyAssignment(inErrorRecovery) || this.isSimplePropertyAssignment(inErrorRecovery);
            };

            ParserImpl.prototype.isGetAccessorPropertyAssignment = function (inErrorRecovery) {
                return this.currentToken().tokenKind === 65 /* GetKeyword */ && this.isPropertyName(this.peekToken(1), inErrorRecovery);
            };

            ParserImpl.prototype.parseGetAccessorPropertyAssignment = function () {
                var getKeyword = this.eatKeyword(65 /* GetKeyword */);
                var propertyName = this.eatPropertyName();
                var openParenToken = this.eatToken(73 /* OpenParenToken */);
                var closeParenToken = this.eatToken(74 /* CloseParenToken */);
                var typeAnnotation = this.parseOptionalTypeAnnotation(false);
                var block = this.parseBlock(false, true);

                return this.factory.getAccessorPropertyAssignment(getKeyword, propertyName, openParenToken, closeParenToken, typeAnnotation, block);
            };

            ParserImpl.prototype.isSetAccessorPropertyAssignment = function (inErrorRecovery) {
                return this.currentToken().tokenKind === 69 /* SetKeyword */ && this.isPropertyName(this.peekToken(1), inErrorRecovery);
            };

            ParserImpl.prototype.parseSetAccessorPropertyAssignment = function () {
                var setKeyword = this.eatKeyword(69 /* SetKeyword */);
                var propertyName = this.eatPropertyName();
                var openParenToken = this.eatToken(73 /* OpenParenToken */);
                var parameter = this.parseParameter();
                var closeParenToken = this.eatToken(74 /* CloseParenToken */);
                var block = this.parseBlock(false, true);

                return this.factory.setAccessorPropertyAssignment(setKeyword, propertyName, openParenToken, parameter, closeParenToken, block);
            };

            ParserImpl.prototype.eatPropertyName = function () {
                return TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(this.currentToken()) ? this.eatIdentifierNameToken() : this.eatAnyToken();
            };

            ParserImpl.prototype.isFunctionPropertyAssignment = function (inErrorRecovery) {
                return this.isPropertyName(this.currentToken(), inErrorRecovery) && this.isCallSignature(1);
            };

            ParserImpl.prototype.parseFunctionPropertyAssignment = function () {
                var propertyName = this.eatPropertyName();
                var callSignature = this.parseCallSignature(false);
                var block = this.parseBlock(false, true);

                return this.factory.functionPropertyAssignment(propertyName, callSignature, block);
            };

            ParserImpl.prototype.isSimplePropertyAssignment = function (inErrorRecovery) {
                return this.isPropertyName(this.currentToken(), inErrorRecovery);
            };

            ParserImpl.prototype.parseSimplePropertyAssignment = function () {
                var propertyName = this.eatPropertyName();
                var colonToken = this.eatToken(107 /* ColonToken */);
                var expression = this.parseAssignmentExpression(true);

                return this.factory.simplePropertyAssignment(propertyName, colonToken, expression);
            };

            ParserImpl.prototype.isPropertyName = function (token, inErrorRecovery) {
                if (TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(token)) {
                    if (inErrorRecovery) {
                        return this.isIdentifier(token);
                    } else {
                        return true;
                    }
                }

                switch (token.tokenKind) {
                    case 14 /* StringLiteral */:
                    case 13 /* NumericLiteral */:
                        return true;

                    default:
                        return false;
                }
            };

            ParserImpl.prototype.parseArrayLiteralExpression = function () {
                var openBracketToken = this.eatToken(75 /* OpenBracketToken */);

                var result = this.parseSeparatedSyntaxList(65536 /* ArrayLiteralExpression_AssignmentExpressions */);
                var expressions = result.list;
                openBracketToken = this.addSkippedTokensAfterToken(openBracketToken, result.skippedTokens);

                var closeBracketToken = this.eatToken(76 /* CloseBracketToken */);

                return this.factory.arrayLiteralExpression(openBracketToken, expressions, closeBracketToken);
            };

            ParserImpl.prototype.parseLiteralExpression = function () {
                return this.eatAnyToken();
            };

            ParserImpl.prototype.parseThisExpression = function () {
                var thisKeyword = this.eatKeyword(35 /* ThisKeyword */);
                return thisKeyword;
            };

            ParserImpl.prototype.parseBlock = function (parseBlockEvenWithNoOpenBrace, checkForStrictMode) {
                var openBraceToken = this.eatToken(71 /* OpenBraceToken */);

                var statements = TypeScript.Syntax.emptyList;

                if (parseBlockEvenWithNoOpenBrace || openBraceToken.width() > 0) {
                    var savedIsInStrictMode = this.isInStrictMode;

                    var processItems = checkForStrictMode ? ParserImpl.updateStrictModeState : null;
                    var result = this.parseSyntaxList(32 /* Block_Statements */, processItems);
                    statements = result.list;
                    openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);

                    this.setStrictMode(savedIsInStrictMode);
                }

                var closeBraceToken = this.eatToken(72 /* CloseBraceToken */);

                return this.factory.block(openBraceToken, statements, closeBraceToken);
            };

            ParserImpl.prototype.parseCallSignature = function (requireCompleteTypeParameterList) {
                var typeParameterList = this.parseOptionalTypeParameterList(requireCompleteTypeParameterList);
                var parameterList = this.parseParameterList();
                var typeAnnotation = this.parseOptionalTypeAnnotation(false);

                return this.factory.callSignature(typeParameterList, parameterList, typeAnnotation);
            };

            ParserImpl.prototype.parseOptionalTypeParameterList = function (requireCompleteTypeParameterList) {
                if (this.currentToken().tokenKind !== 81 /* LessThanToken */) {
                    return null;
                }

                var rewindPoint = this.getRewindPoint();
                try  {
                    var lessThanToken = this.eatToken(81 /* LessThanToken */);

                    var result = this.parseSeparatedSyntaxList(524288 /* TypeParameterList_TypeParameters */);
                    var typeParameterList = result.list;
                    lessThanToken = this.addSkippedTokensAfterToken(lessThanToken, result.skippedTokens);

                    var greaterThanToken = this.eatToken(82 /* GreaterThanToken */);

                    if (requireCompleteTypeParameterList && greaterThanToken.fullWidth() === 0) {
                        this.rewind(rewindPoint);
                        return null;
                    }

                    return this.factory.typeParameterList(lessThanToken, typeParameterList, greaterThanToken);
                } finally {
                    this.releaseRewindPoint(rewindPoint);
                }
            };

            ParserImpl.prototype.isTypeParameter = function () {
                return this.isIdentifier(this.currentToken());
            };

            ParserImpl.prototype.parseTypeParameter = function () {
                var identifier = this.eatIdentifierToken();
                var constraint = this.parseOptionalConstraint();

                return this.factory.typeParameter(identifier, constraint);
            };

            ParserImpl.prototype.parseOptionalConstraint = function () {
                if (this.currentToken().kind() !== 48 /* ExtendsKeyword */) {
                    return null;
                }

                var extendsKeyword = this.eatKeyword(48 /* ExtendsKeyword */);
                var type = this.parseType();

                return this.factory.constraint(extendsKeyword, type);
            };

            ParserImpl.prototype.parseParameterList = function () {
                var openParenToken = this.eatToken(73 /* OpenParenToken */);
                var parameters = TypeScript.Syntax.emptySeparatedList;

                if (openParenToken.width() > 0) {
                    var result = this.parseSeparatedSyntaxList(131072 /* ParameterList_Parameters */);
                    parameters = result.list;
                    openParenToken = this.addSkippedTokensAfterToken(openParenToken, result.skippedTokens);
                }

                var closeParenToken = this.eatToken(74 /* CloseParenToken */);
                return this.factory.parameterList(openParenToken, parameters, closeParenToken);
            };

            ParserImpl.prototype.isTypeAnnotation = function () {
                return this.currentToken().tokenKind === 107 /* ColonToken */;
            };

            ParserImpl.prototype.parseOptionalTypeAnnotation = function (allowStringLiteral) {
                return this.isTypeAnnotation() ? this.parseTypeAnnotation(allowStringLiteral) : null;
            };

            ParserImpl.prototype.parseTypeAnnotation = function (allowStringLiteral) {
                var colonToken = this.eatToken(107 /* ColonToken */);
                var type = allowStringLiteral && this.currentToken().tokenKind === 14 /* StringLiteral */ ? this.eatToken(14 /* StringLiteral */) : this.parseType();

                return this.factory.typeAnnotation(colonToken, type);
            };

            ParserImpl.prototype.isType = function () {
                return this.isPredefinedType() || this.isTypeLiteral() || this.isName();
            };

            ParserImpl.prototype.parseType = function () {
                var type = this.parseNonArrayType();

                while (this.currentToken().tokenKind === 75 /* OpenBracketToken */) {
                    var openBracketToken = this.eatToken(75 /* OpenBracketToken */);
                    var closeBracketToken = this.eatToken(76 /* CloseBracketToken */);

                    type = this.factory.arrayType(type, openBracketToken, closeBracketToken);
                }

                return type;
            };

            ParserImpl.prototype.parseNonArrayType = function () {
                if (this.isPredefinedType()) {
                    return this.parsePredefinedType();
                } else if (this.isTypeLiteral()) {
                    return this.parseTypeLiteral();
                } else {
                    return this.parseNameOrGenericType();
                }
            };

            ParserImpl.prototype.parseNameOrGenericType = function () {
                var name = this.parseName();
                var typeArgumentList = this.tryParseTypeArgumentList(false);

                return typeArgumentList === null ? name : this.factory.genericType(name, typeArgumentList);
            };

            ParserImpl.prototype.parseTypeLiteral = function () {
                if (this.isObjectType()) {
                    return this.parseObjectType();
                } else if (this.isFunctionType()) {
                    return this.parseFunctionType();
                } else if (this.isConstructorType()) {
                    return this.parseConstructorType();
                } else {
                    throw TypeScript.Errors.invalidOperation();
                }
            };

            ParserImpl.prototype.parseFunctionType = function () {
                var typeParameterList = this.parseOptionalTypeParameterList(false);
                var parameterList = this.parseParameterList();
                var equalsGreaterThanToken = this.eatToken(86 /* EqualsGreaterThanToken */);
                var returnType = this.parseType();

                return this.factory.functionType(typeParameterList, parameterList, equalsGreaterThanToken, returnType);
            };

            ParserImpl.prototype.parseConstructorType = function () {
                var newKeyword = this.eatKeyword(31 /* NewKeyword */);
                var parameterList = this.parseParameterList();
                var equalsGreaterThanToken = this.eatToken(86 /* EqualsGreaterThanToken */);
                var type = this.parseType();

                return this.factory.constructorType(newKeyword, null, parameterList, equalsGreaterThanToken, type);
            };

            ParserImpl.prototype.isTypeLiteral = function () {
                return this.isObjectType() || this.isFunctionType() || this.isConstructorType();
            };

            ParserImpl.prototype.isObjectType = function () {
                return this.currentToken().tokenKind === 71 /* OpenBraceToken */;
            };

            ParserImpl.prototype.isFunctionType = function () {
                var tokenKind = this.currentToken().tokenKind;
                return tokenKind === 73 /* OpenParenToken */ || tokenKind === 81 /* LessThanToken */;
            };

            ParserImpl.prototype.isConstructorType = function () {
                return this.currentToken().tokenKind === 31 /* NewKeyword */;
            };

            ParserImpl.prototype.parsePredefinedType = function () {
                return this.eatAnyToken();
            };

            ParserImpl.prototype.isPredefinedType = function () {
                switch (this.currentToken().tokenKind) {
                    case 60 /* AnyKeyword */:
                    case 68 /* NumberKeyword */:
                    case 61 /* BooleanKeyword */:
                    case 62 /* BoolKeyword */:
                    case 70 /* StringKeyword */:
                    case 41 /* VoidKeyword */:
                        return true;
                }

                return false;
            };

            ParserImpl.prototype.isParameter = function () {
                if (this.currentNode() !== null && this.currentNode().kind() === 242 /* Parameter */) {
                    return true;
                }

                var token = this.currentToken();
                if (token.tokenKind === 78 /* DotDotDotToken */) {
                    return true;
                }

                if (ParserImpl.isPublicOrPrivateKeyword(token)) {
                    return true;
                }

                return this.isIdentifier(token);
            };

            ParserImpl.prototype.parseParameter = function () {
                if (this.currentNode() !== null && this.currentNode().kind() === 242 /* Parameter */) {
                    return this.eatNode();
                }

                var dotDotDotToken = this.tryEatToken(78 /* DotDotDotToken */);

                var publicOrPrivateToken = null;
                if (ParserImpl.isPublicOrPrivateKeyword(this.currentToken())) {
                    publicOrPrivateToken = this.eatAnyToken();
                }

                var identifier = this.eatIdentifierToken();
                var questionToken = this.tryEatToken(106 /* QuestionToken */);
                var typeAnnotation = this.parseOptionalTypeAnnotation(true);

                var equalsValueClause = null;
                if (this.isEqualsValueClause(true)) {
                    equalsValueClause = this.parseEqualsValueClause(true);
                }

                return this.factory.parameter(dotDotDotToken, publicOrPrivateToken, identifier, questionToken, typeAnnotation, equalsValueClause);
            };

            ParserImpl.prototype.parseSyntaxList = function (currentListType, processItems) {
                if (typeof processItems === "undefined") { processItems = null; }
                var savedListParsingState = this.listParsingState;
                this.listParsingState |= currentListType;

                var result = this.parseSyntaxListWorker(currentListType, processItems);

                this.listParsingState = savedListParsingState;

                return result;
            };

            ParserImpl.prototype.parseSeparatedSyntaxList = function (currentListType) {
                var savedListParsingState = this.listParsingState;
                this.listParsingState |= currentListType;

                var result = this.parseSeparatedSyntaxListWorker(currentListType);

                this.listParsingState = savedListParsingState;

                return result;
            };

            ParserImpl.prototype.abortParsingListOrMoveToNextToken = function (currentListType, items, skippedTokens) {
                this.reportUnexpectedTokenDiagnostic(currentListType);

                for (var state = 262144 /* LastListParsingState */; state >= 1 /* FirstListParsingState */; state >>= 1) {
                    if ((this.listParsingState & state) !== 0) {
                        if (this.isExpectedListTerminator(state) || this.isExpectedListItem(state, true)) {
                            return true;
                        }
                    }
                }

                var skippedToken = this.currentToken();

                this.moveToNextToken();

                this.addSkippedTokenToList(items, skippedTokens, skippedToken);

                return false;
            };

            ParserImpl.prototype.addSkippedTokenToList = function (items, skippedTokens, skippedToken) {
                for (var i = items.length - 1; i >= 0; i--) {
                    var item = items[i];
                    var lastToken = item.lastToken();
                    if (lastToken.fullWidth() > 0) {
                        items[i] = this.addSkippedTokenAfterNodeOrToken(item, skippedToken);
                        return;
                    }
                }

                skippedTokens.push(skippedToken);
            };

            ParserImpl.prototype.tryParseExpectedListItem = function (currentListType, inErrorRecovery, items, processItems) {
                if (this.isExpectedListItem(currentListType, inErrorRecovery)) {
                    var item = this.parseExpectedListItem(currentListType);

                    items.push(item);

                    if (processItems !== null) {
                        processItems(this, items);
                    }
                }
            };

            ParserImpl.prototype.listIsTerminated = function (currentListType) {
                return this.isExpectedListTerminator(currentListType) || this.currentToken().tokenKind === 10 /* EndOfFileToken */;
            };

            ParserImpl.prototype.getArray = function () {
                if (this.arrayPool.length > 0) {
                    return this.arrayPool.pop();
                }

                return [];
            };

            ParserImpl.prototype.returnZeroOrOneLengthArray = function (array) {
                if (array.length <= 1) {
                    this.returnArray(array);
                }
            };

            ParserImpl.prototype.returnArray = function (array) {
                array.length = 0;
                this.arrayPool.push(array);
            };

            ParserImpl.prototype.parseSyntaxListWorker = function (currentListType, processItems) {
                var items = this.getArray();
                var skippedTokens = this.getArray();

                while (true) {
                    var oldItemsCount = items.length;
                    this.tryParseExpectedListItem(currentListType, false, items, processItems);

                    var newItemsCount = items.length;
                    if (newItemsCount === oldItemsCount) {
                        if (this.listIsTerminated(currentListType)) {
                            break;
                        }

                        var abort = this.abortParsingListOrMoveToNextToken(currentListType, items, skippedTokens);
                        if (abort) {
                            break;
                        }
                    }
                }

                var result = TypeScript.Syntax.list(items);

                this.returnZeroOrOneLengthArray(items);

                return { skippedTokens: skippedTokens, list: result };
            };

            ParserImpl.prototype.parseSeparatedSyntaxListWorker = function (currentListType) {
                var items = this.getArray();
                var skippedTokens = this.getArray();
                TypeScript.Debug.assert(items.length === 0);
                TypeScript.Debug.assert(skippedTokens.length === 0);
                TypeScript.Debug.assert(skippedTokens !== items);

                var separatorKind = this.separatorKind(currentListType);
                var allowAutomaticSemicolonInsertion = separatorKind === 79 /* SemicolonToken */;

                var inErrorRecovery = false;
                var listWasTerminated = false;
                while (true) {
                    var oldItemsCount = items.length;

                    this.tryParseExpectedListItem(currentListType, inErrorRecovery, items, null);

                    var newItemsCount = items.length;
                    if (newItemsCount === oldItemsCount) {
                        if (this.listIsTerminated(currentListType)) {
                            listWasTerminated = true;
                            break;
                        }

                        var abort = this.abortParsingListOrMoveToNextToken(currentListType, items, skippedTokens);
                        if (abort) {
                            break;
                        } else {
                            inErrorRecovery = true;
                            continue;
                        }
                    }

                    inErrorRecovery = false;

                    var currentToken = this.currentToken();
                    if (currentToken.tokenKind === separatorKind || currentToken.tokenKind === 80 /* CommaToken */) {
                        items.push(this.eatAnyToken());
                        continue;
                    }

                    if (this.listIsTerminated(currentListType)) {
                        listWasTerminated = true;
                        break;
                    }

                    if (allowAutomaticSemicolonInsertion && this.canEatAutomaticSemicolon(false)) {
                        items.push(this.eatExplicitOrAutomaticSemicolon(false));

                        continue;
                    }

                    items.push(this.eatToken(separatorKind));

                    inErrorRecovery = true;
                }

                var result = TypeScript.Syntax.separatedList(items);

                this.returnZeroOrOneLengthArray(items);

                return { skippedTokens: skippedTokens, list: result };
            };

            ParserImpl.prototype.separatorKind = function (currentListType) {
                switch (currentListType) {
                    case 2048 /* HeritageClause_TypeNameList */:
                    case 16384 /* ArgumentList_AssignmentExpressions */:
                    case 256 /* EnumDeclaration_EnumElements */:
                    case 4096 /* VariableDeclaration_VariableDeclarators_AllowIn */:
                    case 8192 /* VariableDeclaration_VariableDeclarators_DisallowIn */:
                    case 32768 /* ObjectLiteralExpression_PropertyAssignments */:
                    case 131072 /* ParameterList_Parameters */:
                    case 65536 /* ArrayLiteralExpression_AssignmentExpressions */:
                    case 262144 /* TypeArgumentList_Types */:
                    case 524288 /* TypeParameterList_TypeParameters */:
                        return 80 /* CommaToken */;

                    case 512 /* ObjectType_TypeMembers */:
                        return 79 /* SemicolonToken */;

                    case 1 /* SourceUnit_ModuleElements */:
                    case 1024 /* ClassOrInterfaceDeclaration_HeritageClauses */:
                    case 2 /* ClassDeclaration_ClassElements */:
                    case 4 /* ModuleDeclaration_ModuleElements */:
                    case 8 /* SwitchStatement_SwitchClauses */:
                    case 16 /* SwitchClause_Statements */:
                    case 32 /* Block_Statements */:
                    default:
                        throw TypeScript.Errors.notYetImplemented();
                }
            };

            ParserImpl.prototype.reportUnexpectedTokenDiagnostic = function (listType) {
                var token = this.currentToken();

                var diagnostic = new TypeScript.SyntaxDiagnostic(this.fileName, this.currentTokenStart(), token.width(), 12 /* Unexpected_token__0_expected */, [this.getExpectedListElementType(listType)]);
                this.addDiagnostic(diagnostic);
            };

            ParserImpl.prototype.addDiagnostic = function (diagnostic) {
                if (this.diagnostics.length > 0 && this.diagnostics[this.diagnostics.length - 1].start() === diagnostic.start()) {
                    return;
                }

                this.diagnostics.push(diagnostic);
            };

            ParserImpl.prototype.isExpectedListTerminator = function (currentListType) {
                switch (currentListType) {
                    case 1 /* SourceUnit_ModuleElements */:
                        return this.isExpectedSourceUnit_ModuleElementsTerminator();

                    case 1024 /* ClassOrInterfaceDeclaration_HeritageClauses */:
                        return this.isExpectedClassOrInterfaceDeclaration_HeritageClausesTerminator();

                    case 2 /* ClassDeclaration_ClassElements */:
                        return this.isExpectedClassDeclaration_ClassElementsTerminator();

                    case 4 /* ModuleDeclaration_ModuleElements */:
                        return this.isExpectedModuleDeclaration_ModuleElementsTerminator();

                    case 8 /* SwitchStatement_SwitchClauses */:
                        return this.isExpectedSwitchStatement_SwitchClausesTerminator();

                    case 16 /* SwitchClause_Statements */:
                        return this.isExpectedSwitchClause_StatementsTerminator();

                    case 32 /* Block_Statements */:
                        return this.isExpectedBlock_StatementsTerminator();

                    case 64 /* TryBlock_Statements */:
                        return this.isExpectedTryBlock_StatementsTerminator();

                    case 128 /* CatchBlock_Statements */:
                        return this.isExpectedCatchBlock_StatementsTerminator();

                    case 256 /* EnumDeclaration_EnumElements */:
                        return this.isExpectedEnumDeclaration_EnumElementsTerminator();

                    case 512 /* ObjectType_TypeMembers */:
                        return this.isExpectedObjectType_TypeMembersTerminator();

                    case 16384 /* ArgumentList_AssignmentExpressions */:
                        return this.isExpectedArgumentList_AssignmentExpressionsTerminator();

                    case 2048 /* HeritageClause_TypeNameList */:
                        return this.isExpectedHeritageClause_TypeNameListTerminator();

                    case 4096 /* VariableDeclaration_VariableDeclarators_AllowIn */:
                        return this.isExpectedVariableDeclaration_VariableDeclarators_AllowInTerminator();

                    case 8192 /* VariableDeclaration_VariableDeclarators_DisallowIn */:
                        return this.isExpectedVariableDeclaration_VariableDeclarators_DisallowInTerminator();

                    case 32768 /* ObjectLiteralExpression_PropertyAssignments */:
                        return this.isExpectedObjectLiteralExpression_PropertyAssignmentsTerminator();

                    case 131072 /* ParameterList_Parameters */:
                        return this.isExpectedParameterList_ParametersTerminator();

                    case 262144 /* TypeArgumentList_Types */:
                        return this.isExpectedTypeArgumentList_TypesTerminator();

                    case 524288 /* TypeParameterList_TypeParameters */:
                        return this.isExpectedTypeParameterList_TypeParametersTerminator();

                    case 65536 /* ArrayLiteralExpression_AssignmentExpressions */:
                        return this.isExpectedLiteralExpression_AssignmentExpressionsTerminator();

                    default:
                        throw TypeScript.Errors.invalidOperation();
                }
            };

            ParserImpl.prototype.isExpectedSourceUnit_ModuleElementsTerminator = function () {
                return this.currentToken().tokenKind === 10 /* EndOfFileToken */;
            };

            ParserImpl.prototype.isExpectedEnumDeclaration_EnumElementsTerminator = function () {
                return this.currentToken().tokenKind === 72 /* CloseBraceToken */;
            };

            ParserImpl.prototype.isExpectedModuleDeclaration_ModuleElementsTerminator = function () {
                return this.currentToken().tokenKind === 72 /* CloseBraceToken */;
            };

            ParserImpl.prototype.isExpectedObjectType_TypeMembersTerminator = function () {
                return this.currentToken().tokenKind === 72 /* CloseBraceToken */;
            };

            ParserImpl.prototype.isExpectedObjectLiteralExpression_PropertyAssignmentsTerminator = function () {
                return this.currentToken().tokenKind === 72 /* CloseBraceToken */;
            };

            ParserImpl.prototype.isExpectedLiteralExpression_AssignmentExpressionsTerminator = function () {
                return this.currentToken().tokenKind === 76 /* CloseBracketToken */;
            };

            ParserImpl.prototype.isExpectedTypeArgumentList_TypesTerminator = function () {
                var token = this.currentToken();
                if (token.tokenKind === 82 /* GreaterThanToken */) {
                    return true;
                }

                if (this.canFollowTypeArgumentListInExpression(token.tokenKind)) {
                    return true;
                }

                return false;
            };

            ParserImpl.prototype.isExpectedTypeParameterList_TypeParametersTerminator = function () {
                var token = this.currentToken();
                if (token.tokenKind === 82 /* GreaterThanToken */) {
                    return true;
                }

                if (token.tokenKind === 73 /* OpenParenToken */ || token.tokenKind === 71 /* OpenBraceToken */ || token.tokenKind === 48 /* ExtendsKeyword */ || token.tokenKind === 51 /* ImplementsKeyword */) {
                    return true;
                }

                return false;
            };

            ParserImpl.prototype.isExpectedParameterList_ParametersTerminator = function () {
                var token = this.currentToken();
                if (token.tokenKind === 74 /* CloseParenToken */) {
                    return true;
                }

                if (token.tokenKind === 71 /* OpenBraceToken */) {
                    return true;
                }

                if (token.tokenKind === 86 /* EqualsGreaterThanToken */) {
                    return true;
                }

                return false;
            };

            ParserImpl.prototype.isExpectedVariableDeclaration_VariableDeclarators_DisallowInTerminator = function () {
                if (this.currentToken().tokenKind === 79 /* SemicolonToken */ || this.currentToken().tokenKind === 74 /* CloseParenToken */) {
                    return true;
                }

                if (this.currentToken().tokenKind === 29 /* InKeyword */) {
                    return true;
                }

                return false;
            };

            ParserImpl.prototype.isExpectedVariableDeclaration_VariableDeclarators_AllowInTerminator = function () {
                if (this.previousToken().tokenKind === 80 /* CommaToken */) {
                    return false;
                }

                if (this.currentToken().tokenKind === 86 /* EqualsGreaterThanToken */) {
                    return true;
                }

                return this.canEatExplicitOrAutomaticSemicolon(false);
            };

            ParserImpl.prototype.isExpectedClassOrInterfaceDeclaration_HeritageClausesTerminator = function () {
                var token0 = this.currentToken();
                if (token0.tokenKind === 71 /* OpenBraceToken */ || token0.tokenKind === 72 /* CloseBraceToken */) {
                    return true;
                }

                return false;
            };

            ParserImpl.prototype.isExpectedHeritageClause_TypeNameListTerminator = function () {
                var token0 = this.currentToken();
                if (token0.tokenKind === 48 /* ExtendsKeyword */ || token0.tokenKind === 51 /* ImplementsKeyword */) {
                    return true;
                }

                if (this.isExpectedClassOrInterfaceDeclaration_HeritageClausesTerminator()) {
                    return true;
                }

                return false;
            };

            ParserImpl.prototype.isExpectedArgumentList_AssignmentExpressionsTerminator = function () {
                var token0 = this.currentToken();
                return token0.tokenKind === 74 /* CloseParenToken */ || token0.tokenKind === 79 /* SemicolonToken */;
            };

            ParserImpl.prototype.isExpectedClassDeclaration_ClassElementsTerminator = function () {
                return this.currentToken().tokenKind === 72 /* CloseBraceToken */;
            };

            ParserImpl.prototype.isExpectedSwitchStatement_SwitchClausesTerminator = function () {
                return this.currentToken().tokenKind === 72 /* CloseBraceToken */;
            };

            ParserImpl.prototype.isExpectedSwitchClause_StatementsTerminator = function () {
                return this.currentToken().tokenKind === 72 /* CloseBraceToken */ || this.isSwitchClause();
            };

            ParserImpl.prototype.isExpectedBlock_StatementsTerminator = function () {
                return this.currentToken().tokenKind === 72 /* CloseBraceToken */;
            };

            ParserImpl.prototype.isExpectedTryBlock_StatementsTerminator = function () {
                return this.currentToken().tokenKind === 17 /* CatchKeyword */ || this.currentToken().tokenKind === 25 /* FinallyKeyword */;
            };

            ParserImpl.prototype.isExpectedCatchBlock_StatementsTerminator = function () {
                return this.currentToken().tokenKind === 25 /* FinallyKeyword */;
            };

            ParserImpl.prototype.isExpectedListItem = function (currentListType, inErrorRecovery) {
                switch (currentListType) {
                    case 1 /* SourceUnit_ModuleElements */:
                        return this.isModuleElement(inErrorRecovery);

                    case 1024 /* ClassOrInterfaceDeclaration_HeritageClauses */:
                        return this.isHeritageClause();

                    case 2 /* ClassDeclaration_ClassElements */:
                        return this.isClassElement(inErrorRecovery);

                    case 4 /* ModuleDeclaration_ModuleElements */:
                        return this.isModuleElement(inErrorRecovery);

                    case 8 /* SwitchStatement_SwitchClauses */:
                        return this.isSwitchClause();

                    case 16 /* SwitchClause_Statements */:
                        return this.isStatement(inErrorRecovery);

                    case 32 /* Block_Statements */:
                        return this.isStatement(inErrorRecovery);

                    case 64 /* TryBlock_Statements */:
                    case 128 /* CatchBlock_Statements */:
                        return false;

                    case 256 /* EnumDeclaration_EnumElements */:
                        return this.isEnumElement(inErrorRecovery);

                    case 4096 /* VariableDeclaration_VariableDeclarators_AllowIn */:
                    case 8192 /* VariableDeclaration_VariableDeclarators_DisallowIn */:
                        return this.isVariableDeclarator();

                    case 512 /* ObjectType_TypeMembers */:
                        return this.isTypeMember(inErrorRecovery);

                    case 16384 /* ArgumentList_AssignmentExpressions */:
                        return this.isExpectedArgumentList_AssignmentExpression();

                    case 2048 /* HeritageClause_TypeNameList */:
                        return this.isHeritageClauseTypeName();

                    case 32768 /* ObjectLiteralExpression_PropertyAssignments */:
                        return this.isPropertyAssignment(inErrorRecovery);

                    case 131072 /* ParameterList_Parameters */:
                        return this.isParameter();

                    case 262144 /* TypeArgumentList_Types */:
                        return this.isType();

                    case 524288 /* TypeParameterList_TypeParameters */:
                        return this.isTypeParameter();

                    case 65536 /* ArrayLiteralExpression_AssignmentExpressions */:
                        return this.isAssignmentOrOmittedExpression();

                    default:
                        throw TypeScript.Errors.invalidOperation();
                }
            };

            ParserImpl.prototype.isExpectedArgumentList_AssignmentExpression = function () {
                if (this.isExpression()) {
                    return true;
                }

                if (this.currentToken().tokenKind === 80 /* CommaToken */) {
                    return true;
                }

                return false;
            };

            ParserImpl.prototype.parseExpectedListItem = function (currentListType) {
                switch (currentListType) {
                    case 1 /* SourceUnit_ModuleElements */:
                        return this.parseModuleElement();

                    case 1024 /* ClassOrInterfaceDeclaration_HeritageClauses */:
                        return this.parseHeritageClause();

                    case 2 /* ClassDeclaration_ClassElements */:
                        return this.parseClassElement(false);

                    case 4 /* ModuleDeclaration_ModuleElements */:
                        return this.parseModuleElement();

                    case 8 /* SwitchStatement_SwitchClauses */:
                        return this.parseSwitchClause();

                    case 16 /* SwitchClause_Statements */:
                        return this.parseStatement();

                    case 32 /* Block_Statements */:
                        return this.parseStatement();

                    case 256 /* EnumDeclaration_EnumElements */:
                        return this.parseEnumElement();

                    case 512 /* ObjectType_TypeMembers */:
                        return this.parseTypeMember();

                    case 16384 /* ArgumentList_AssignmentExpressions */:
                        return this.parseAssignmentExpression(true);

                    case 2048 /* HeritageClause_TypeNameList */:
                        return this.parseNameOrGenericType();

                    case 4096 /* VariableDeclaration_VariableDeclarators_AllowIn */:
                        return this.parseVariableDeclarator(true, false);

                    case 8192 /* VariableDeclaration_VariableDeclarators_DisallowIn */:
                        return this.parseVariableDeclarator(false, false);

                    case 32768 /* ObjectLiteralExpression_PropertyAssignments */:
                        return this.parsePropertyAssignment();

                    case 65536 /* ArrayLiteralExpression_AssignmentExpressions */:
                        return this.parseAssignmentOrOmittedExpression();

                    case 131072 /* ParameterList_Parameters */:
                        return this.parseParameter();

                    case 262144 /* TypeArgumentList_Types */:
                        return this.parseType();

                    case 524288 /* TypeParameterList_TypeParameters */:
                        return this.parseTypeParameter();

                    default:
                        throw TypeScript.Errors.invalidOperation();
                }
            };

            ParserImpl.prototype.getExpectedListElementType = function (currentListType) {
                switch (currentListType) {
                    case 1 /* SourceUnit_ModuleElements */:
                        return TypeScript.Strings.module__class__interface__enum__import_or_statement;

                    case 1024 /* ClassOrInterfaceDeclaration_HeritageClauses */:
                        return '{';

                    case 2 /* ClassDeclaration_ClassElements */:
                        return TypeScript.Strings.constructor__function__accessor_or_variable;

                    case 4 /* ModuleDeclaration_ModuleElements */:
                        return TypeScript.Strings.module__class__interface__enum__import_or_statement;

                    case 8 /* SwitchStatement_SwitchClauses */:
                        return TypeScript.Strings.case_or_default_clause;

                    case 16 /* SwitchClause_Statements */:
                        return TypeScript.Strings.statement;

                    case 32 /* Block_Statements */:
                        return TypeScript.Strings.statement;

                    case 4096 /* VariableDeclaration_VariableDeclarators_AllowIn */:
                    case 8192 /* VariableDeclaration_VariableDeclarators_DisallowIn */:
                        return TypeScript.Strings.identifier;

                    case 256 /* EnumDeclaration_EnumElements */:
                        return TypeScript.Strings.identifier;

                    case 512 /* ObjectType_TypeMembers */:
                        return TypeScript.Strings.call__construct__index__property_or_function_signature;

                    case 16384 /* ArgumentList_AssignmentExpressions */:
                        return TypeScript.Strings.expression;

                    case 2048 /* HeritageClause_TypeNameList */:
                        return TypeScript.Strings.type_name;

                    case 32768 /* ObjectLiteralExpression_PropertyAssignments */:
                        return TypeScript.Strings.property_or_accessor;

                    case 131072 /* ParameterList_Parameters */:
                        return TypeScript.Strings.parameter;

                    case 262144 /* TypeArgumentList_Types */:
                        return TypeScript.Strings.type;

                    case 524288 /* TypeParameterList_TypeParameters */:
                        return TypeScript.Strings.type_parameter;

                    case 65536 /* ArrayLiteralExpression_AssignmentExpressions */:
                        return TypeScript.Strings.expression;

                    default:
                        throw TypeScript.Errors.invalidOperation();
                }
            };
            return ParserImpl;
        })();

        function parse(fileName, text, isDeclaration, languageVersion, options) {
            var source = new NormalParserSource(fileName, text, languageVersion);

            return new ParserImpl(fileName, text.lineMap(), source, options).parseSyntaxTree(isDeclaration);
        }
        Parser.parse = parse;

        function incrementalParse(oldSyntaxTree, textChangeRange, newText) {
            if (textChangeRange.isUnchanged()) {
                return oldSyntaxTree;
            }

            var source = new IncrementalParserSource(oldSyntaxTree, textChangeRange, newText);

            return new ParserImpl(oldSyntaxTree.fileName(), newText.lineMap(), source, oldSyntaxTree.parseOptions()).parseSyntaxTree(oldSyntaxTree.isDeclaration());
        }
        Parser.incrementalParse = incrementalParse;
    })(TypeScript.Parser || (TypeScript.Parser = {}));
    var Parser = TypeScript.Parser;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxTree = (function () {
        function SyntaxTree(sourceUnit, isDeclaration, diagnostics, fileName, lineMap, languageVersion, parseOtions) {
            this._allDiagnostics = null;
            this._sourceUnit = sourceUnit;
            this._isDeclaration = isDeclaration;
            this._parserDiagnostics = diagnostics;
            this._fileName = fileName;
            this._lineMap = lineMap;
            this._languageVersion = languageVersion;
            this._parseOptions = parseOtions;
        }
        SyntaxTree.prototype.toJSON = function (key) {
            var result = {};

            result.isDeclaration = this._isDeclaration;
            result.languageVersion = TypeScript.LanguageVersion[this._languageVersion];
            result.parseOptions = this._parseOptions;

            if (this.diagnostics().length > 0) {
                result.diagnostics = this.diagnostics();
            }

            result.sourceUnit = this._sourceUnit;
            result.lineMap = this._lineMap;

            return result;
        };

        SyntaxTree.prototype.sourceUnit = function () {
            return this._sourceUnit;
        };

        SyntaxTree.prototype.isDeclaration = function () {
            return this._isDeclaration;
        };

        SyntaxTree.prototype.computeDiagnostics = function () {
            if (this._parserDiagnostics.length > 0) {
                return this._parserDiagnostics;
            }

            var diagnostics = [];
            this.sourceUnit().accept(new GrammarCheckerWalker(this, diagnostics));

            return diagnostics;
        };

        SyntaxTree.prototype.diagnostics = function () {
            if (this._allDiagnostics === null) {
                this._allDiagnostics = this.computeDiagnostics();
            }

            return this._allDiagnostics;
        };

        SyntaxTree.prototype.fileName = function () {
            return this._fileName;
        };

        SyntaxTree.prototype.lineMap = function () {
            return this._lineMap;
        };

        SyntaxTree.prototype.languageVersion = function () {
            return this._languageVersion;
        };

        SyntaxTree.prototype.parseOptions = function () {
            return this._parseOptions;
        };

        SyntaxTree.prototype.structuralEquals = function (tree) {
            return TypeScript.ArrayUtilities.sequenceEquals(this.diagnostics(), tree.diagnostics(), TypeScript.SyntaxDiagnostic.equals) && this.sourceUnit().structuralEquals(tree.sourceUnit());
        };
        return SyntaxTree;
    })();
    TypeScript.SyntaxTree = SyntaxTree;

    var GrammarCheckerWalker = (function (_super) {
        __extends(GrammarCheckerWalker, _super);
        function GrammarCheckerWalker(syntaxTree, diagnostics) {
            _super.call(this);
            this.syntaxTree = syntaxTree;
            this.diagnostics = diagnostics;
            this.inAmbientDeclaration = false;
            this.inBlock = false;
            this.currentConstructor = null;
        }
        GrammarCheckerWalker.prototype.childFullStart = function (parent, child) {
            return this.position() + TypeScript.Syntax.childOffset(parent, child);
        };

        GrammarCheckerWalker.prototype.childStart = function (parent, child) {
            return this.childFullStart(parent, child) + child.leadingTriviaWidth();
        };

        GrammarCheckerWalker.prototype.pushDiagnostic = function (start, length, diagnosticCode, args) {
            if (typeof args === "undefined") { args = null; }
            this.diagnostics.push(new TypeScript.SyntaxDiagnostic(this.syntaxTree.fileName(), start, length, diagnosticCode, args));
        };

        GrammarCheckerWalker.prototype.pushDiagnostic1 = function (elementFullStart, element, diagnosticCode, args) {
            if (typeof args === "undefined") { args = null; }
            this.diagnostics.push(new TypeScript.SyntaxDiagnostic(this.syntaxTree.fileName(), elementFullStart + element.leadingTriviaWidth(), element.width(), diagnosticCode, args));
        };

        GrammarCheckerWalker.prototype.visitCatchClause = function (node) {
            if (node.typeAnnotation) {
                this.pushDiagnostic(this.childStart(node, node.typeAnnotation), node.typeAnnotation.width(), 17 /* A_catch_clause_variable_cannot_have_a_type_annotation */);
            }

            _super.prototype.visitCatchClause.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkParameterListOrder = function (node) {
            var parameterFullStart = this.childFullStart(node, node.parameters);

            var seenOptionalParameter = false;
            var parameterCount = node.parameters.nonSeparatorCount();

            for (var i = 0, n = node.parameters.childCount(); i < n; i++) {
                var nodeOrToken = node.parameters.childAt(i);
                if (i % 2 === 0) {
                    var parameterIndex = i / 2;
                    var parameter = node.parameters.childAt(i);

                    if (parameter.dotDotDotToken) {
                        if (parameterIndex !== (parameterCount - 1)) {
                            this.pushDiagnostic1(parameterFullStart, parameter, 18 /* Rest_parameter_must_be_last_in_list */);
                            return true;
                        }

                        if (parameter.questionToken) {
                            this.pushDiagnostic1(parameterFullStart, parameter, 56 /* Rest_parameter_cannot_be_optional */);
                            return true;
                        }

                        if (parameter.equalsValueClause) {
                            this.pushDiagnostic1(parameterFullStart, parameter, 57 /* Rest_parameter_cannot_have_initializer */);
                            return true;
                        }
                    } else if (parameter.questionToken || parameter.equalsValueClause) {
                        seenOptionalParameter = true;

                        if (parameter.questionToken && parameter.equalsValueClause) {
                            this.pushDiagnostic1(parameterFullStart, parameter, 19 /* Parameter_cannot_have_question_mark_and_initializer */);
                            return true;
                        }
                    } else {
                        if (seenOptionalParameter) {
                            this.pushDiagnostic1(parameterFullStart, parameter, 20 /* Required_parameter_cannot_follow_optional_parameter */);
                            return true;
                        }
                    }
                }

                parameterFullStart += nodeOrToken.fullWidth();
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkParameterListAcessibilityModifiers = function (node) {
            if (this.currentConstructor !== null && this.currentConstructor.parameterList === node && this.currentConstructor.block && !this.inAmbientDeclaration) {
                return false;
            }

            var parameterFullStart = this.childFullStart(node, node.parameters);

            for (var i = 0, n = node.parameters.childCount(); i < n; i++) {
                var nodeOrToken = node.parameters.childAt(i);
                if (i % 2 === 0) {
                    var parameter = node.parameters.childAt(i);

                    if (parameter.publicOrPrivateKeyword) {
                        var keywordFullStart = parameterFullStart + TypeScript.Syntax.childOffset(parameter, parameter.publicOrPrivateKeyword);
                        this.pushDiagnostic1(keywordFullStart, parameter.publicOrPrivateKeyword, 43 /* Overload_and_ambient_signatures_cannot_specify_parameter_properties */);
                    }
                }

                parameterFullStart += nodeOrToken.fullWidth();
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkForTrailingSeparator = function (parent, list) {
            if (list.childCount() === 0 || list.childCount() % 2 === 1) {
                return false;
            }

            var currentElementFullStart = this.childFullStart(parent, list);

            for (var i = 0, n = list.childCount(); i < n; i++) {
                var child = list.childAt(i);
                if (i === n - 1) {
                    this.pushDiagnostic1(currentElementFullStart, child, 13 /* Trailing_separator_not_allowed */);
                }

                currentElementFullStart += child.fullWidth();
            }

            return true;
        };

        GrammarCheckerWalker.prototype.checkForAtLeastOneElement = function (parent, list, expected) {
            if (list.childCount() > 0) {
                return false;
            }

            var listFullStart = this.childFullStart(parent, list);
            var tokenAtStart = this.syntaxTree.sourceUnit().findToken(listFullStart);

            this.pushDiagnostic1(listFullStart, tokenAtStart.token(), 12 /* Unexpected_token__0_expected */, [expected]);

            return true;
        };

        GrammarCheckerWalker.prototype.visitParameterList = function (node) {
            if (this.checkParameterListAcessibilityModifiers(node) || this.checkParameterListOrder(node) || this.checkForTrailingSeparator(node, node.parameters)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitParameterList.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitHeritageClause = function (node) {
            if (this.checkForTrailingSeparator(node, node.typeNames) || this.checkForAtLeastOneElement(node, node.typeNames, TypeScript.Strings.type_name)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitHeritageClause.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitArgumentList = function (node) {
            if (this.checkForTrailingSeparator(node, node.arguments)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitArgumentList.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitVariableDeclaration = function (node) {
            if (this.checkForTrailingSeparator(node, node.variableDeclarators) || this.checkForAtLeastOneElement(node, node.variableDeclarators, TypeScript.Strings.identifier)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitVariableDeclaration.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitTypeArgumentList = function (node) {
            if (this.checkForTrailingSeparator(node, node.typeArguments) || this.checkForAtLeastOneElement(node, node.typeArguments, TypeScript.Strings.identifier)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitTypeArgumentList.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitTypeParameterList = function (node) {
            if (this.checkForTrailingSeparator(node, node.typeParameters) || this.checkForAtLeastOneElement(node, node.typeParameters, TypeScript.Strings.identifier)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitTypeParameterList.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkIndexSignatureParameter = function (node) {
            var parameterFullStart = this.childFullStart(node, node.parameter);
            var parameter = node.parameter;

            if (parameter.dotDotDotToken) {
                this.pushDiagnostic1(parameterFullStart, parameter, 21 /* Index_signatures_cannot_have_rest_parameters */);
                return true;
            } else if (parameter.publicOrPrivateKeyword) {
                this.pushDiagnostic1(parameterFullStart, parameter, 22 /* Index_signature_parameter_cannot_have_accessibility_modifiers */);
                return true;
            } else if (parameter.questionToken) {
                this.pushDiagnostic1(parameterFullStart, parameter, 23 /* Index_signature_parameter_cannot_have_a_question_mark */);
                return true;
            } else if (parameter.equalsValueClause) {
                this.pushDiagnostic1(parameterFullStart, parameter, 24 /* Index_signature_parameter_cannot_have_an_initializer */);
                return true;
            } else if (!parameter.typeAnnotation) {
                this.pushDiagnostic1(parameterFullStart, parameter, 26 /* Index_signature_parameter_must_have_a_type_annotation */);
                return true;
            } else if (parameter.typeAnnotation.type.kind() !== 70 /* StringKeyword */ && parameter.typeAnnotation.type.kind() !== 68 /* NumberKeyword */) {
                this.pushDiagnostic1(parameterFullStart, parameter, 27 /* Index_signature_parameter_type_must_be__string__or__number_ */);
                return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitIndexSignature = function (node) {
            if (this.checkIndexSignatureParameter(node)) {
                this.skip(node);
                return;
            }

            if (!node.typeAnnotation) {
                this.pushDiagnostic1(this.position(), node, 25 /* Index_signature_must_have_a_type_annotation */);
                this.skip(node);
                return;
            }

            _super.prototype.visitIndexSignature.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkClassDeclarationHeritageClauses = function (node) {
            var heritageClauseFullStart = this.childFullStart(node, node.heritageClauses);

            var seenExtendsClause = false;
            var seenImplementsClause = false;

            for (var i = 0, n = node.heritageClauses.childCount(); i < n; i++) {
                TypeScript.Debug.assert(i <= 2);
                var heritageClause = node.heritageClauses.childAt(i);

                if (heritageClause.extendsOrImplementsKeyword.tokenKind === 48 /* ExtendsKeyword */) {
                    if (seenExtendsClause) {
                        this.pushDiagnostic1(heritageClauseFullStart, heritageClause, 28 /* _extends__clause_already_seen */);
                        return true;
                    }

                    if (seenImplementsClause) {
                        this.pushDiagnostic1(heritageClauseFullStart, heritageClause, 29 /* _extends__clause_must_precede__implements__clause */);
                        return true;
                    }

                    if (heritageClause.typeNames.nonSeparatorCount() > 1) {
                        this.pushDiagnostic1(heritageClauseFullStart, heritageClause, 30 /* Class_can_only_extend_single_type */);
                        return true;
                    }

                    seenExtendsClause = true;
                } else {
                    TypeScript.Debug.assert(heritageClause.extendsOrImplementsKeyword.tokenKind === 51 /* ImplementsKeyword */);
                    if (seenImplementsClause) {
                        this.pushDiagnostic1(heritageClauseFullStart, heritageClause, 31 /* _implements__clause_already_seen */);
                        return true;
                    }

                    seenImplementsClause = true;
                }

                heritageClauseFullStart += heritageClause.fullWidth();
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkForDisallowedDeclareModifier = function (modifiers) {
            if (this.inAmbientDeclaration) {
                var declareToken = TypeScript.SyntaxUtilities.getToken(modifiers, 64 /* DeclareKeyword */);

                if (declareToken) {
                    this.pushDiagnostic1(this.childFullStart(modifiers, declareToken), declareToken, 41 /* _declare__modifier_not_allowed_for_code_already_in_an_ambient_context */);
                    return true;
                }
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkForRequiredDeclareModifier = function (moduleElement, typeKeyword, modifiers) {
            if (!this.inAmbientDeclaration && this.syntaxTree.isDeclaration()) {
                if (!TypeScript.SyntaxUtilities.containsToken(modifiers, 64 /* DeclareKeyword */)) {
                    this.pushDiagnostic1(this.childFullStart(moduleElement, typeKeyword), typeKeyword.firstToken(), 49 /* _declare__modifier_required_for_top_level_element */);
                    return true;
                }
            }
        };

        GrammarCheckerWalker.prototype.checkFunctionOverloads = function (node, moduleElements) {
            if (!this.inAmbientDeclaration && !this.syntaxTree.isDeclaration()) {
                var moduleElementFullStart = this.childFullStart(node, moduleElements);

                var inFunctionOverloadChain = false;
                var functionOverloadChainName = null;

                for (var i = 0, n = moduleElements.childCount(); i < n; i++) {
                    var moduleElement = moduleElements.childAt(i);
                    var lastElement = i === (n - 1);

                    if (inFunctionOverloadChain) {
                        if (moduleElement.kind() !== 129 /* FunctionDeclaration */) {
                            this.pushDiagnostic1(moduleElementFullStart, moduleElement.firstToken(), 44 /* Function_implementation_expected */);
                            return true;
                        }

                        var functionDeclaration = moduleElement;
                        if (functionDeclaration.identifier.valueText() !== functionOverloadChainName) {
                            var identifierFullStart = moduleElementFullStart + TypeScript.Syntax.childOffset(moduleElement, functionDeclaration.identifier);
                            this.pushDiagnostic1(identifierFullStart, functionDeclaration.identifier, 46 /* Function_overload_name_must_be__0_ */, [functionOverloadChainName]);
                            return true;
                        }
                    }

                    if (moduleElement.kind() === 129 /* FunctionDeclaration */) {
                        functionDeclaration = moduleElement;
                        if (!TypeScript.SyntaxUtilities.containsToken(functionDeclaration.modifiers, 64 /* DeclareKeyword */)) {
                            inFunctionOverloadChain = functionDeclaration.block === null;
                            functionOverloadChainName = functionDeclaration.identifier.valueText();

                            if (lastElement && inFunctionOverloadChain) {
                                this.pushDiagnostic1(moduleElementFullStart, moduleElement.firstToken(), 44 /* Function_implementation_expected */);
                                return true;
                            }
                        } else {
                            inFunctionOverloadChain = false;
                            functionOverloadChainName = "";
                        }
                    }

                    moduleElementFullStart += moduleElement.fullWidth();
                }
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkClassOverloads = function (node) {
            if (!this.inAmbientDeclaration && !TypeScript.SyntaxUtilities.containsToken(node.modifiers, 64 /* DeclareKeyword */)) {
                var classElementFullStart = this.childFullStart(node, node.classElements);

                var inFunctionOverloadChain = false;
                var inConstructorOverloadChain = false;

                var functionOverloadChainName = null;
                var memberFunctionDeclaration = null;

                for (var i = 0, n = node.classElements.childCount(); i < n; i++) {
                    var classElement = node.classElements.childAt(i);
                    var lastElement = i === (n - 1);

                    if (inFunctionOverloadChain) {
                        if (classElement.kind() !== 135 /* MemberFunctionDeclaration */) {
                            this.pushDiagnostic1(classElementFullStart, classElement.firstToken(), 44 /* Function_implementation_expected */);
                            return true;
                        }

                        memberFunctionDeclaration = classElement;
                        if (memberFunctionDeclaration.propertyName.valueText() !== functionOverloadChainName) {
                            var propertyNameFullStart = classElementFullStart + TypeScript.Syntax.childOffset(classElement, memberFunctionDeclaration.propertyName);
                            this.pushDiagnostic1(propertyNameFullStart, memberFunctionDeclaration.propertyName, 46 /* Function_overload_name_must_be__0_ */, [functionOverloadChainName]);
                            return true;
                        }
                    } else if (inConstructorOverloadChain) {
                        if (classElement.kind() !== 137 /* ConstructorDeclaration */) {
                            this.pushDiagnostic1(classElementFullStart, classElement.firstToken(), 45 /* Constructor_implementation_expected */);
                            return true;
                        }
                    }

                    if (classElement.kind() === 135 /* MemberFunctionDeclaration */) {
                        memberFunctionDeclaration = classElement;

                        inFunctionOverloadChain = memberFunctionDeclaration.block === null;
                        functionOverloadChainName = memberFunctionDeclaration.propertyName.valueText();

                        if (lastElement && inFunctionOverloadChain) {
                            this.pushDiagnostic1(classElementFullStart, classElement.firstToken(), 44 /* Function_implementation_expected */);
                            return true;
                        }
                    } else if (classElement.kind() === 137 /* ConstructorDeclaration */) {
                        var constructorDeclaration = classElement;

                        inConstructorOverloadChain = constructorDeclaration.block === null;
                        if (lastElement && inConstructorOverloadChain) {
                            this.pushDiagnostic1(classElementFullStart, classElement.firstToken(), 45 /* Constructor_implementation_expected */);
                            return true;
                        }
                    }

                    classElementFullStart += classElement.fullWidth();
                }
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkForReservedName = function (parent, name, code) {
            var nameFullStart = this.childFullStart(parent, name);
            var token;
            var tokenFullStart;

            var current = name;
            while (current !== null) {
                if (current.kind() === 122 /* QualifiedName */) {
                    var qualifiedName = current;
                    token = qualifiedName.right;
                    tokenFullStart = nameFullStart + this.childFullStart(qualifiedName, token);
                    current = qualifiedName.left;
                } else {
                    TypeScript.Debug.assert(current.kind() === 11 /* IdentifierName */);
                    token = current;
                    tokenFullStart = nameFullStart;
                    current = null;
                }

                switch (token.valueText()) {
                    case "any":
                    case "number":
                    case "bool":
                    case "string":
                    case "void":
                        this.pushDiagnostic(tokenFullStart + token.leadingTriviaWidth(), token.width(), code, [token.valueText()]);
                        return true;
                }
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitClassDeclaration = function (node) {
            if (this.checkForReservedName(node, node.identifier, 60 /* Class_name_cannot_be__0_ */) || this.checkForDisallowedDeclareModifier(node.modifiers) || this.checkForRequiredDeclareModifier(node, node.classKeyword, node.modifiers) || this.checkModuleElementModifiers(node.modifiers) || this.checkClassDeclarationHeritageClauses(node) || this.checkClassOverloads(node)) {
                this.skip(node);
                return;
            }

            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.syntaxTree.isDeclaration() || TypeScript.SyntaxUtilities.containsToken(node.modifiers, 64 /* DeclareKeyword */);
            _super.prototype.visitClassDeclaration.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };

        GrammarCheckerWalker.prototype.checkInterfaceDeclarationHeritageClauses = function (node) {
            var heritageClauseFullStart = this.childFullStart(node, node.heritageClauses);

            var seenExtendsClause = false;

            for (var i = 0, n = node.heritageClauses.childCount(); i < n; i++) {
                TypeScript.Debug.assert(i <= 1);
                var heritageClause = node.heritageClauses.childAt(i);

                if (heritageClause.extendsOrImplementsKeyword.tokenKind === 48 /* ExtendsKeyword */) {
                    if (seenExtendsClause) {
                        this.pushDiagnostic1(heritageClauseFullStart, heritageClause, 28 /* _extends__clause_already_seen */);
                        return true;
                    }

                    seenExtendsClause = true;
                } else {
                    TypeScript.Debug.assert(heritageClause.extendsOrImplementsKeyword.tokenKind === 51 /* ImplementsKeyword */);
                    this.pushDiagnostic1(heritageClauseFullStart, heritageClause, 36 /* Interface_declaration_cannot_have__implements__clause */);
                    return true;
                }

                heritageClauseFullStart += heritageClause.fullWidth();
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkInterfaceModifiers = function (modifiers) {
            var modifierFullStart = this.position();

            for (var i = 0, n = modifiers.childCount(); i < n; i++) {
                var modifier = modifiers.childAt(i);
                if (modifier.tokenKind === 64 /* DeclareKeyword */) {
                    this.pushDiagnostic1(modifierFullStart, modifier, 48 /* _declare__modifier_cannot_appear_on_an_interface_declaration */);
                    return true;
                }

                modifierFullStart += modifier.fullWidth();
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitInterfaceDeclaration = function (node) {
            if (this.checkForReservedName(node, node.identifier, 61 /* Interface_name_cannot_be__0_ */) || this.checkInterfaceModifiers(node.modifiers) || this.checkModuleElementModifiers(node.modifiers) || this.checkInterfaceDeclarationHeritageClauses(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitInterfaceDeclaration.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkClassElementModifiers = function (list) {
            var modifierFullStart = this.position();

            var seenAccessibilityModifier = false;
            var seenStaticModifier = false;

            for (var i = 0, n = list.childCount(); i < n; i++) {
                var modifier = list.childAt(i);
                if (modifier.tokenKind === 57 /* PublicKeyword */ || modifier.tokenKind === 55 /* PrivateKeyword */) {
                    if (seenAccessibilityModifier) {
                        this.pushDiagnostic1(modifierFullStart, modifier, 32 /* Accessibility_modifier_already_seen */);
                        return true;
                    }

                    if (seenStaticModifier) {
                        var previousToken = list.childAt(i - 1);
                        this.pushDiagnostic1(modifierFullStart, modifier, 33 /* _0__modifier_must_precede__1__modifier */, [modifier.text(), previousToken.text()]);
                        return true;
                    }

                    seenAccessibilityModifier = true;
                } else if (modifier.tokenKind === 58 /* StaticKeyword */) {
                    if (seenStaticModifier) {
                        this.pushDiagnostic1(modifierFullStart, modifier, 34 /* _0__modifier_already_seen */, [modifier.text()]);
                        return true;
                    }

                    seenStaticModifier = true;
                } else {
                    this.pushDiagnostic1(modifierFullStart, modifier, 35 /* _0__modifier_cannot_appear_on_a_class_element */, [modifier.text()]);
                    return true;
                }

                modifierFullStart += modifier.fullWidth();
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitMemberVariableDeclaration = function (node) {
            if (this.checkClassElementModifiers(node.modifiers)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitMemberVariableDeclaration.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitMemberFunctionDeclaration = function (node) {
            if (this.checkClassElementModifiers(node.modifiers)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitMemberFunctionDeclaration.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkGetMemberAccessorParameter = function (node) {
            var getKeywordFullStart = this.childFullStart(node, node.getKeyword);
            if (node.parameterList.parameters.childCount() !== 0) {
                this.pushDiagnostic1(getKeywordFullStart, node.getKeyword, 55 /* _get__accessor_cannot_have_parameters */);
                return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkEcmaScriptVersionIsAtLeast = function (parent, node, languageVersion, code) {
            if (this.syntaxTree.languageVersion() < languageVersion) {
                var nodeFullStart = this.childFullStart(parent, node);
                this.pushDiagnostic1(nodeFullStart, node, code);
                return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitGetMemberAccessorDeclaration = function (node) {
            if (this.checkEcmaScriptVersionIsAtLeast(node, node.getKeyword, 1 /* EcmaScript5 */, 59 /* Accessors_are_only_available_when_targeting_EcmaScript5_and_higher */) || this.checkClassElementModifiers(node.modifiers) || this.checkGetMemberAccessorParameter(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitGetMemberAccessorDeclaration.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkSetMemberAccessorParameter = function (node) {
            var setKeywordFullStart = this.childFullStart(node, node.setKeyword);
            if (node.parameterList.parameters.childCount() !== 1) {
                this.pushDiagnostic1(setKeywordFullStart, node.setKeyword, 50 /* _set__accessor_must_have_only_one_parameter */);
                return true;
            }

            var parameterListFullStart = this.childFullStart(node, node.parameterList);
            var parameterFullStart = parameterListFullStart + TypeScript.Syntax.childOffset(node.parameterList, node.parameterList.openParenToken);
            var parameter = node.parameterList.parameters.childAt(0);

            if (parameter.publicOrPrivateKeyword) {
                this.pushDiagnostic1(parameterFullStart, parameter, 51 /* _set__accessor_parameter_cannot_have_accessibility_modifier */);
                return true;
            }

            if (parameter.questionToken) {
                this.pushDiagnostic1(parameterFullStart, parameter, 52 /* _set__accessor_parameter_cannot_be_optional */);
                return true;
            }

            if (parameter.equalsValueClause) {
                this.pushDiagnostic1(parameterFullStart, parameter, 53 /* _set__accessor_parameter_cannot_have_initializer */);
                return true;
            }

            if (parameter.dotDotDotToken) {
                this.pushDiagnostic1(parameterFullStart, parameter, 54 /* _set__accessor_cannot_have_rest_parameter */);
                return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitSetMemberAccessorDeclaration = function (node) {
            if (this.checkEcmaScriptVersionIsAtLeast(node, node.setKeyword, 1 /* EcmaScript5 */, 59 /* Accessors_are_only_available_when_targeting_EcmaScript5_and_higher */) || this.checkClassElementModifiers(node.modifiers) || this.checkSetMemberAccessorParameter(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitSetMemberAccessorDeclaration.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitGetAccessorPropertyAssignment = function (node) {
            if (this.checkEcmaScriptVersionIsAtLeast(node, node.getKeyword, 1 /* EcmaScript5 */, 59 /* Accessors_are_only_available_when_targeting_EcmaScript5_and_higher */)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitGetAccessorPropertyAssignment.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitSetAccessorPropertyAssignment = function (node) {
            if (this.checkEcmaScriptVersionIsAtLeast(node, node.setKeyword, 1 /* EcmaScript5 */, 59 /* Accessors_are_only_available_when_targeting_EcmaScript5_and_higher */)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitSetAccessorPropertyAssignment.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitEnumDeclaration = function (node) {
            if (this.checkForReservedName(node, node.identifier, 62 /* Enum_name_cannot_be__0_ */) || this.checkForDisallowedDeclareModifier(node.modifiers) || this.checkForRequiredDeclareModifier(node, node.enumKeyword, node.modifiers) || this.checkModuleElementModifiers(node.modifiers), this.checkEnumElements(node)) {
                this.skip(node);
                return;
            }

            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.syntaxTree.isDeclaration() || TypeScript.SyntaxUtilities.containsToken(node.modifiers, 64 /* DeclareKeyword */);
            _super.prototype.visitEnumDeclaration.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };

        GrammarCheckerWalker.prototype.checkEnumElements = function (node) {
            var enumElementFullStart = this.childFullStart(node, node.enumElements);

            var seenComputedValue = false;
            for (var i = 0, n = node.enumElements.childCount(); i < n; i++) {
                var child = node.enumElements.childAt(i);

                if (i % 2 === 0) {
                    var enumElement = child;

                    if (!enumElement.equalsValueClause && seenComputedValue) {
                        this.pushDiagnostic1(enumElementFullStart, enumElement, 64 /* Enum_member_must_have_initializer */, null);
                        return true;
                    }

                    if (enumElement.equalsValueClause) {
                        var value = enumElement.equalsValueClause.value;
                        if (value.kind() !== 13 /* NumericLiteral */) {
                            seenComputedValue = true;
                        }
                    }
                }

                enumElementFullStart += child.fullWidth();
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitInvocationExpression = function (node) {
            if (node.expression.kind() === 50 /* SuperKeyword */ && node.argumentList.typeArgumentList !== null) {
                this.pushDiagnostic1(this.position(), node, 37 /* _super__invocation_cannot_have_type_arguments */);
            }

            _super.prototype.visitInvocationExpression.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkModuleElementModifiers = function (modifiers) {
            var modifierFullStart = this.position();
            var seenExportModifier = false;
            var seenDeclareModifier = false;

            for (var i = 0, n = modifiers.childCount(); i < n; i++) {
                var modifier = modifiers.childAt(i);
                if (modifier.tokenKind === 57 /* PublicKeyword */ || modifier.tokenKind === 55 /* PrivateKeyword */ || modifier.tokenKind === 58 /* StaticKeyword */) {
                    this.pushDiagnostic1(modifierFullStart, modifier, 47 /* _0__modifier_cannot_appear_on_a_module_element */, [modifier.text()]);
                    return true;
                }

                if (modifier.tokenKind === 64 /* DeclareKeyword */) {
                    if (seenDeclareModifier) {
                        this.pushDiagnostic1(modifierFullStart, modifier, 32 /* Accessibility_modifier_already_seen */);
                        return;
                    }

                    seenDeclareModifier = true;
                } else if (modifier.tokenKind === 47 /* ExportKeyword */) {
                    if (seenExportModifier) {
                        this.pushDiagnostic1(modifierFullStart, modifier, 34 /* _0__modifier_already_seen */, [modifier.text()]);
                        return;
                    }

                    if (seenDeclareModifier) {
                        this.pushDiagnostic1(modifierFullStart, modifier, 33 /* _0__modifier_must_precede__1__modifier */, [TypeScript.SyntaxFacts.getText(47 /* ExportKeyword */), TypeScript.SyntaxFacts.getText(64 /* DeclareKeyword */)]);
                        return;
                    }

                    seenExportModifier = true;
                }

                modifierFullStart += modifier.fullWidth();
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkForDisallowedImportDeclaration = function (node) {
            if (node.stringLiteral === null) {
                var currentElementFullStart = this.childFullStart(node, node.moduleElements);

                for (var i = 0, n = node.moduleElements.childCount(); i < n; i++) {
                    var child = node.moduleElements.childAt(i);
                    if (child.kind() === 133 /* ImportDeclaration */) {
                        var importDeclaration = child;
                        if (importDeclaration.moduleReference.kind() === 245 /* ExternalModuleReference */) {
                            this.pushDiagnostic1(currentElementFullStart, importDeclaration, 201 /* Import_declarations_in_an_internal_module_cannot_reference_an_external_module */, null);
                        }
                    }

                    currentElementFullStart += child.fullWidth();
                }
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitModuleDeclaration = function (node) {
            if (this.checkForReservedName(node, node.moduleName, 63 /* Module_name_cannot_be__0_ */) || this.checkForDisallowedDeclareModifier(node.modifiers) || this.checkForRequiredDeclareModifier(node, node.moduleKeyword, node.modifiers) || this.checkModuleElementModifiers(node.modifiers) || this.checkForDisallowedImportDeclaration(node) || this.checkForDisallowedExports(node, node.moduleElements) || this.checkForMultipleExportAssignments(node, node.moduleElements)) {
                this.skip(node);
                return;
            }

            if (!TypeScript.SyntaxUtilities.containsToken(node.modifiers, 64 /* DeclareKeyword */) && this.checkFunctionOverloads(node, node.moduleElements)) {
                this.skip(node);
                return;
            }

            if (node.stringLiteral && !this.inAmbientDeclaration && !TypeScript.SyntaxUtilities.containsToken(node.modifiers, 64 /* DeclareKeyword */)) {
                var stringLiteralFullStart = this.childFullStart(node, node.stringLiteral);
                this.pushDiagnostic1(stringLiteralFullStart, node.stringLiteral, 38 /* Non_ambient_modules_cannot_use_quoted_names */);
                this.skip(node);
                return;
            }

            if (!node.stringLiteral && this.checkForDisallowedExportAssignment(node)) {
                this.skip(node);
                return;
            }

            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.syntaxTree.isDeclaration() || TypeScript.SyntaxUtilities.containsToken(node.modifiers, 64 /* DeclareKeyword */);
            _super.prototype.visitModuleDeclaration.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };

        GrammarCheckerWalker.prototype.checkForDisallowedExports = function (node, moduleElements) {
            var seenExportedElement = false;
            for (var i = 0, n = moduleElements.childCount(); i < n; i++) {
                var child = moduleElements.childAt(i);

                if (TypeScript.SyntaxUtilities.hasExportKeyword(child)) {
                    seenExportedElement = true;
                    break;
                }
            }

            var moduleElementFullStart = this.childFullStart(node, moduleElements);
            if (seenExportedElement) {
                for (var i = 0, n = moduleElements.childCount(); i < n; i++) {
                    var child = moduleElements.childAt(i);

                    if (child.kind() === 134 /* ExportAssignment */) {
                        this.pushDiagnostic1(moduleElementFullStart, child, 67 /* Export_assignment_not_allowed_in_module_with_exported_element */);
                        return true;
                    }

                    moduleElementFullStart += child.fullWidth();
                }
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkForMultipleExportAssignments = function (node, moduleElements) {
            var moduleElementFullStart = this.childFullStart(node, moduleElements);
            var seenExportAssignment = false;
            var errorFound = false;
            for (var i = 0, n = moduleElements.childCount(); i < n; i++) {
                var child = moduleElements.childAt(i);
                if (child.kind() === 134 /* ExportAssignment */) {
                    if (seenExportAssignment) {
                        this.pushDiagnostic1(moduleElementFullStart, child, 68 /* Module_cannot_have_multiple_export_assignments */);
                        errorFound = true;
                    }
                    seenExportAssignment = true;
                }

                moduleElementFullStart += child.fullWidth();
            }

            return errorFound;
        };

        GrammarCheckerWalker.prototype.checkForDisallowedExportAssignment = function (node) {
            var moduleElementFullStart = this.childFullStart(node, node.moduleElements);

            for (var i = 0, n = node.moduleElements.childCount(); i < n; i++) {
                var child = node.moduleElements.childAt(i);

                if (child.kind() === 134 /* ExportAssignment */) {
                    this.pushDiagnostic1(moduleElementFullStart, child, 66 /* Export_assignments_cannot_be_used_in_internal_modules */);

                    return true;
                }

                moduleElementFullStart += child.fullWidth();
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitBlock = function (node) {
            if (this.inAmbientDeclaration || this.syntaxTree.isDeclaration()) {
                this.pushDiagnostic1(this.position(), node.firstToken(), 40 /* Implementations_are_not_allowed_in_ambient_contexts */);
                this.skip(node);
                return;
            }

            if (this.checkFunctionOverloads(node, node.statements)) {
                this.skip(node);
                return;
            }

            var savedInBlock = this.inBlock;
            this.inBlock = true;
            _super.prototype.visitBlock.call(this, node);
            this.inBlock = savedInBlock;
        };

        GrammarCheckerWalker.prototype.checkForStatementInAmbientContxt = function (node) {
            if (this.inAmbientDeclaration || this.syntaxTree.isDeclaration()) {
                this.pushDiagnostic1(this.position(), node.firstToken(), 39 /* Statements_are_not_allowed_in_ambient_contexts */);
                return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitBreakStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitBreakStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitContinueStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitContinueStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitDebuggerStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitDebuggerStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitDoStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitDoStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitEmptyStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitEmptyStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitExpressionStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitExpressionStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitForInStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitForInStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitForStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitForStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitIfStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitIfStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitLabeledStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitLabeledStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitReturnStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitReturnStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitSwitchStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitSwitchStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitThrowStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitThrowStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitTryStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitTryStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitWhileStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitWhileStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitWithStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitWithStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkForDisallowedModifiers = function (parent, modifiers) {
            if (this.inBlock && modifiers.childCount() > 0) {
                var modifierFullStart = this.childFullStart(parent, modifiers);
                this.pushDiagnostic1(modifierFullStart, modifiers.childAt(0), 58 /* Modifiers_cannot_appear_here */);
                return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitFunctionDeclaration = function (node) {
            if (this.checkForDisallowedDeclareModifier(node.modifiers) || this.checkForDisallowedModifiers(node, node.modifiers) || this.checkForRequiredDeclareModifier(node, node.functionKeyword, node.modifiers) || this.checkModuleElementModifiers(node.modifiers)) {
                this.skip(node);
                return;
            }

            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.syntaxTree.isDeclaration() || TypeScript.SyntaxUtilities.containsToken(node.modifiers, 64 /* DeclareKeyword */);
            _super.prototype.visitFunctionDeclaration.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };

        GrammarCheckerWalker.prototype.visitVariableStatement = function (node) {
            if (this.checkForDisallowedDeclareModifier(node.modifiers) || this.checkForDisallowedModifiers(node, node.modifiers) || this.checkForRequiredDeclareModifier(node, node.variableDeclaration, node.modifiers) || this.checkModuleElementModifiers(node.modifiers)) {
                this.skip(node);
                return;
            }

            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.syntaxTree.isDeclaration() || TypeScript.SyntaxUtilities.containsToken(node.modifiers, 64 /* DeclareKeyword */);
            _super.prototype.visitVariableStatement.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };

        GrammarCheckerWalker.prototype.checkListSeparators = function (parent, list, kind) {
            var currentElementFullStart = this.childFullStart(parent, list);

            for (var i = 0, n = list.childCount(); i < n; i++) {
                var child = list.childAt(i);
                if (i % 2 === 1 && child.kind() !== kind) {
                    this.pushDiagnostic1(currentElementFullStart, child, 9 /* _0_expected */, [TypeScript.SyntaxFacts.getText(kind)]);
                }

                currentElementFullStart += child.fullWidth();
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitObjectType = function (node) {
            if (this.checkListSeparators(node, node.typeMembers, 79 /* SemicolonToken */)) {
                this.skip(node);
                return;
            }

            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = true;
            _super.prototype.visitObjectType.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };

        GrammarCheckerWalker.prototype.visitArrayType = function (node) {
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = true;
            _super.prototype.visitArrayType.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };

        GrammarCheckerWalker.prototype.visitFunctionType = function (node) {
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = true;
            _super.prototype.visitFunctionType.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };

        GrammarCheckerWalker.prototype.visitConstructorType = function (node) {
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = true;
            _super.prototype.visitConstructorType.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };

        GrammarCheckerWalker.prototype.visitEqualsValueClause = function (node) {
            if (this.inAmbientDeclaration) {
                this.pushDiagnostic1(this.position(), node.firstToken(), 42 /* Initializers_are_not_allowed_in_ambient_contexts */);
                this.skip(node);
                return;
            }

            _super.prototype.visitEqualsValueClause.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitConstructorDeclaration = function (node) {
            var savedCurrentConstructor = this.currentConstructor;
            this.currentConstructor = node;
            _super.prototype.visitConstructorDeclaration.call(this, node);
            this.currentConstructor = savedCurrentConstructor;
        };

        GrammarCheckerWalker.prototype.visitSourceUnit = function (node) {
            if (this.checkFunctionOverloads(node, node.moduleElements) || this.checkForDisallowedExports(node, node.moduleElements) || this.checkForMultipleExportAssignments(node, node.moduleElements)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitSourceUnit.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitExternalModuleReference = function (node) {
            if (node.moduleOrRequireKeyword.tokenKind === 66 /* ModuleKeyword */ && !this.syntaxTree.parseOptions().allowModuleKeywordInExternalModuleReference()) {
                this.pushDiagnostic1(this.position(), node.moduleOrRequireKeyword, 65 /* _module_______is_deprecated__Use__require_______instead */);
                this.skip(node);
                return;
            }

            _super.prototype.visitExternalModuleReference.call(this, node);
        };
        return GrammarCheckerWalker;
    })(TypeScript.PositionTrackingWalker);
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var TextSpanWalker = (function (_super) {
        __extends(TextSpanWalker, _super);
        function TextSpanWalker(textSpan) {
            _super.call(this);
            this.textSpan = textSpan;
            this._position = 0;
        }
        TextSpanWalker.prototype.visitToken = function (token) {
            this._position += token.fullWidth();
        };

        TextSpanWalker.prototype.visitNode = function (node) {
            var nodeSpan = new TypeScript.TextSpan(this.position(), node.fullWidth());

            if (nodeSpan.intersectsWithTextSpan(this.textSpan)) {
                node.accept(this);
            } else {
                this._position += node.fullWidth();
            }
        };

        TextSpanWalker.prototype.position = function () {
            return this._position;
        };
        return TextSpanWalker;
    })(TypeScript.SyntaxWalker);
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Unicode = (function () {
        function Unicode() {
        }
        Unicode.lookupInUnicodeMap = function (code, map) {
            if (code < map[0]) {
                return false;
            }

            var lo = 0;
            var hi = map.length;
            var mid;

            while (lo + 1 < hi) {
                mid = lo + (hi - lo) / 2;

                mid -= mid % 2;
                if (map[mid] <= code && code <= map[mid + 1]) {
                    return true;
                }

                if (code < map[mid]) {
                    hi = mid;
                } else {
                    lo = mid + 2;
                }
            }

            return false;
        };

        Unicode.isIdentifierStart = function (code, languageVersion) {
            if (languageVersion === 0 /* EcmaScript3 */) {
                return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES3IdentifierStart);
            } else if (languageVersion === 1 /* EcmaScript5 */) {
                return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES5IdentifierStart);
            } else {
                throw TypeScript.Errors.argumentOutOfRange("languageVersion");
            }
        };

        Unicode.isIdentifierPart = function (code, languageVersion) {
            if (languageVersion === 0 /* EcmaScript3 */) {
                return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES3IdentifierPart);
            } else if (languageVersion === 1 /* EcmaScript5 */) {
                return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES5IdentifierPart);
            } else {
                throw TypeScript.Errors.argumentOutOfRange("languageVersion");
            }
        };
        Unicode.unicodeES3IdentifierStart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1569, 1594, 1600, 1610, 1649, 1747, 1749, 1749, 1765, 1766, 1786, 1788, 1808, 1808, 1810, 1836, 1920, 1957, 2309, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2784, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3294, 3294, 3296, 3297, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3424, 3425, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3805, 3840, 3840, 3904, 3911, 3913, 3946, 3976, 3979, 4096, 4129, 4131, 4135, 4137, 4138, 4176, 4181, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6067, 6176, 6263, 6272, 6312, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8319, 8319, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12346, 12353, 12436, 12445, 12446, 12449, 12538, 12540, 12542, 12549, 12588, 12593, 12686, 12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65138, 65140, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500];
        Unicode.unicodeES3IdentifierPart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 768, 846, 864, 866, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1155, 1158, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1425, 1441, 1443, 1465, 1467, 1469, 1471, 1471, 1473, 1474, 1476, 1476, 1488, 1514, 1520, 1522, 1569, 1594, 1600, 1621, 1632, 1641, 1648, 1747, 1749, 1756, 1759, 1768, 1770, 1773, 1776, 1788, 1808, 1836, 1840, 1866, 1920, 1968, 2305, 2307, 2309, 2361, 2364, 2381, 2384, 2388, 2392, 2403, 2406, 2415, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2492, 2494, 2500, 2503, 2504, 2507, 2509, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2562, 2562, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2649, 2652, 2654, 2654, 2662, 2676, 2689, 2691, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2784, 2790, 2799, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2876, 2883, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2913, 2918, 2927, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3031, 3031, 3047, 3055, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3134, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3168, 3169, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3262, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3297, 3302, 3311, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3390, 3395, 3398, 3400, 3402, 3405, 3415, 3415, 3424, 3425, 3430, 3439, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3805, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3946, 3953, 3972, 3974, 3979, 3984, 3991, 3993, 4028, 4038, 4038, 4096, 4129, 4131, 4135, 4137, 4138, 4140, 4146, 4150, 4153, 4160, 4169, 4176, 4185, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 4969, 4977, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6099, 6112, 6121, 6160, 6169, 6176, 6263, 6272, 6313, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8255, 8256, 8319, 8319, 8400, 8412, 8417, 8417, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12346, 12353, 12436, 12441, 12442, 12445, 12446, 12449, 12542, 12549, 12588, 12593, 12686, 12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65056, 65059, 65075, 65076, 65101, 65103, 65136, 65138, 65140, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65381, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500];

        Unicode.unicodeES5IdentifierStart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088, 2088, 2112, 2136, 2208, 2208, 2210, 2220, 2308, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2417, 2423, 2425, 2431, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000, 6016, 6067, 6103, 6103, 6108, 6108, 6176, 6263, 6272, 6312, 6314, 6314, 6320, 6389, 6400, 6428, 6480, 6509, 6512, 6516, 6528, 6571, 6593, 6599, 6656, 6678, 6688, 6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141, 7168, 7203, 7245, 7247, 7258, 7293, 7401, 7404, 7406, 7409, 7413, 7414, 7424, 7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11502, 11506, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538, 42539, 42560, 42606, 42623, 42647, 42656, 42735, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43009, 43011, 43013, 43015, 43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259, 43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43520, 43560, 43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43648, 43695, 43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739, 43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44002, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500];
        Unicode.unicodeES5IdentifierPart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 768, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1155, 1159, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1488, 1514, 1520, 1522, 1552, 1562, 1568, 1641, 1646, 1747, 1749, 1756, 1759, 1768, 1770, 1788, 1791, 1791, 1808, 1866, 1869, 1969, 1984, 2037, 2042, 2042, 2048, 2093, 2112, 2139, 2208, 2208, 2210, 2220, 2276, 2302, 2304, 2403, 2406, 2415, 2417, 2423, 2425, 2431, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2561, 2563, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2649, 2652, 2654, 2654, 2662, 2677, 2689, 2691, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2787, 2790, 2799, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2876, 2884, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2915, 2918, 2927, 2929, 2929, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3024, 3024, 3031, 3031, 3046, 3055, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3160, 3161, 3168, 3171, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3260, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3299, 3302, 3311, 3313, 3314, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3396, 3398, 3400, 3402, 3406, 3415, 3415, 3424, 3427, 3430, 3439, 3450, 3455, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3807, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3948, 3953, 3972, 3974, 3991, 3993, 4028, 4038, 4038, 4096, 4169, 4176, 4253, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4957, 4959, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5908, 5920, 5940, 5952, 5971, 5984, 5996, 5998, 6000, 6002, 6003, 6016, 6099, 6103, 6103, 6108, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6176, 6263, 6272, 6314, 6320, 6389, 6400, 6428, 6432, 6443, 6448, 6459, 6470, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6608, 6617, 6656, 6683, 6688, 6750, 6752, 6780, 6783, 6793, 6800, 6809, 6823, 6823, 6912, 6987, 6992, 7001, 7019, 7027, 7040, 7155, 7168, 7223, 7232, 7241, 7245, 7293, 7376, 7378, 7380, 7414, 7424, 7654, 7676, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8204, 8205, 8255, 8256, 8276, 8276, 8305, 8305, 8319, 8319, 8336, 8348, 8400, 8412, 8417, 8417, 8421, 8432, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11647, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11744, 11775, 11823, 11823, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12348, 12353, 12438, 12441, 12442, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42539, 42560, 42607, 42612, 42621, 42623, 42647, 42655, 42737, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43047, 43072, 43123, 43136, 43204, 43216, 43225, 43232, 43255, 43259, 43259, 43264, 43309, 43312, 43347, 43360, 43388, 43392, 43456, 43471, 43481, 43520, 43574, 43584, 43597, 43600, 43609, 43616, 43638, 43642, 43643, 43648, 43714, 43739, 43741, 43744, 43759, 43762, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44010, 44012, 44013, 44016, 44025, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65024, 65039, 65056, 65062, 65075, 65076, 65101, 65103, 65136, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500];
        return Unicode;
    })();
    TypeScript.Unicode = Unicode;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    function hasFlag(val, flag) {
        return (val & flag) !== 0;
    }
    TypeScript.hasFlag = hasFlag;

    function withoutFlag(val, flag) {
        return val & ~flag;
    }
    TypeScript.withoutFlag = withoutFlag;

    (function (ASTFlags) {
        ASTFlags[ASTFlags["None"] = 0] = "None";
        ASTFlags[ASTFlags["SingleLine"] = 1 << 1] = "SingleLine";
        ASTFlags[ASTFlags["OptionalName"] = 1 << 2] = "OptionalName";
        ASTFlags[ASTFlags["TypeReference"] = 1 << 3] = "TypeReference";
        ASTFlags[ASTFlags["EnumElement"] = 1 << 4] = "EnumElement";
        ASTFlags[ASTFlags["EnumMapElement"] = 1 << 5] = "EnumMapElement";
    })(TypeScript.ASTFlags || (TypeScript.ASTFlags = {}));
    var ASTFlags = TypeScript.ASTFlags;

    (function (DeclFlags) {
        DeclFlags[DeclFlags["None"] = 0] = "None";
        DeclFlags[DeclFlags["Exported"] = 1] = "Exported";
        DeclFlags[DeclFlags["Private"] = 1 << 1] = "Private";
        DeclFlags[DeclFlags["Public"] = 1 << 2] = "Public";
        DeclFlags[DeclFlags["Ambient"] = 1 << 3] = "Ambient";
        DeclFlags[DeclFlags["Static"] = 1 << 4] = "Static";
    })(TypeScript.DeclFlags || (TypeScript.DeclFlags = {}));
    var DeclFlags = TypeScript.DeclFlags;

    (function (ModuleFlags) {
        ModuleFlags[ModuleFlags["None"] = 0] = "None";
        ModuleFlags[ModuleFlags["Exported"] = 1] = "Exported";
        ModuleFlags[ModuleFlags["Private"] = 1 << 1] = "Private";
        ModuleFlags[ModuleFlags["Public"] = 1 << 2] = "Public";
        ModuleFlags[ModuleFlags["Ambient"] = 1 << 3] = "Ambient";
        ModuleFlags[ModuleFlags["Static"] = 1 << 4] = "Static";
        ModuleFlags[ModuleFlags["IsEnum"] = 1 << 7] = "IsEnum";
        ModuleFlags[ModuleFlags["IsWholeFile"] = 1 << 8] = "IsWholeFile";
        ModuleFlags[ModuleFlags["IsDynamic"] = 1 << 9] = "IsDynamic";
    })(TypeScript.ModuleFlags || (TypeScript.ModuleFlags = {}));
    var ModuleFlags = TypeScript.ModuleFlags;

    (function (VariableFlags) {
        VariableFlags[VariableFlags["None"] = 0] = "None";
        VariableFlags[VariableFlags["Exported"] = 1] = "Exported";
        VariableFlags[VariableFlags["Private"] = 1 << 1] = "Private";
        VariableFlags[VariableFlags["Public"] = 1 << 2] = "Public";
        VariableFlags[VariableFlags["Ambient"] = 1 << 3] = "Ambient";
        VariableFlags[VariableFlags["Static"] = 1 << 4] = "Static";
        VariableFlags[VariableFlags["Property"] = 1 << 8] = "Property";
        VariableFlags[VariableFlags["ClassProperty"] = 1 << 11] = "ClassProperty";
        VariableFlags[VariableFlags["Constant"] = 1 << 12] = "Constant";

        VariableFlags[VariableFlags["EnumElement"] = 1 << 13] = "EnumElement";
    })(TypeScript.VariableFlags || (TypeScript.VariableFlags = {}));
    var VariableFlags = TypeScript.VariableFlags;

    (function (FunctionFlags) {
        FunctionFlags[FunctionFlags["None"] = 0] = "None";
        FunctionFlags[FunctionFlags["Exported"] = 1] = "Exported";
        FunctionFlags[FunctionFlags["Private"] = 1 << 1] = "Private";
        FunctionFlags[FunctionFlags["Public"] = 1 << 2] = "Public";
        FunctionFlags[FunctionFlags["Ambient"] = 1 << 3] = "Ambient";
        FunctionFlags[FunctionFlags["Static"] = 1 << 4] = "Static";
        FunctionFlags[FunctionFlags["GetAccessor"] = 1 << 5] = "GetAccessor";
        FunctionFlags[FunctionFlags["SetAccessor"] = 1 << 6] = "SetAccessor";
        FunctionFlags[FunctionFlags["Signature"] = 1 << 7] = "Signature";
        FunctionFlags[FunctionFlags["Method"] = 1 << 8] = "Method";
        FunctionFlags[FunctionFlags["CallMember"] = 1 << 9] = "CallMember";
        FunctionFlags[FunctionFlags["ConstructMember"] = 1 << 10] = "ConstructMember";
        FunctionFlags[FunctionFlags["IsFatArrowFunction"] = 1 << 11] = "IsFatArrowFunction";
        FunctionFlags[FunctionFlags["IndexerMember"] = 1 << 12] = "IndexerMember";
        FunctionFlags[FunctionFlags["IsFunctionExpression"] = 1 << 13] = "IsFunctionExpression";
        FunctionFlags[FunctionFlags["IsFunctionProperty"] = 1 << 14] = "IsFunctionProperty";
    })(TypeScript.FunctionFlags || (TypeScript.FunctionFlags = {}));
    var FunctionFlags = TypeScript.FunctionFlags;

    function ToDeclFlags(fncOrVarOrModuleFlags) {
        return fncOrVarOrModuleFlags;
    }
    TypeScript.ToDeclFlags = ToDeclFlags;

    (function (TypeRelationshipFlags) {
        TypeRelationshipFlags[TypeRelationshipFlags["SuccessfulComparison"] = 0] = "SuccessfulComparison";
        TypeRelationshipFlags[TypeRelationshipFlags["RequiredPropertyIsMissing"] = 1 << 1] = "RequiredPropertyIsMissing";
        TypeRelationshipFlags[TypeRelationshipFlags["IncompatibleSignatures"] = 1 << 2] = "IncompatibleSignatures";
        TypeRelationshipFlags[TypeRelationshipFlags["SourceSignatureHasTooManyParameters"] = 3] = "SourceSignatureHasTooManyParameters";
        TypeRelationshipFlags[TypeRelationshipFlags["IncompatibleReturnTypes"] = 1 << 4] = "IncompatibleReturnTypes";
        TypeRelationshipFlags[TypeRelationshipFlags["IncompatiblePropertyTypes"] = 1 << 5] = "IncompatiblePropertyTypes";
        TypeRelationshipFlags[TypeRelationshipFlags["IncompatibleParameterTypes"] = 1 << 6] = "IncompatibleParameterTypes";
        TypeRelationshipFlags[TypeRelationshipFlags["InconsistantPropertyAccesibility"] = 1 << 7] = "InconsistantPropertyAccesibility";
    })(TypeScript.TypeRelationshipFlags || (TypeScript.TypeRelationshipFlags = {}));
    var TypeRelationshipFlags = TypeScript.TypeRelationshipFlags;

    (function (ModuleGenTarget) {
        ModuleGenTarget[ModuleGenTarget["Synchronous"] = 0] = "Synchronous";
        ModuleGenTarget[ModuleGenTarget["Asynchronous"] = 1] = "Asynchronous";
    })(TypeScript.ModuleGenTarget || (TypeScript.ModuleGenTarget = {}));
    var ModuleGenTarget = TypeScript.ModuleGenTarget;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (NodeType) {
        NodeType[NodeType["None"] = 0] = "None";
        NodeType[NodeType["List"] = 1] = "List";
        NodeType[NodeType["Script"] = 2] = "Script";

        NodeType[NodeType["TrueLiteral"] = 3] = "TrueLiteral";
        NodeType[NodeType["FalseLiteral"] = 4] = "FalseLiteral";
        NodeType[NodeType["StringLiteral"] = 5] = "StringLiteral";
        NodeType[NodeType["RegularExpressionLiteral"] = 6] = "RegularExpressionLiteral";
        NodeType[NodeType["NumericLiteral"] = 7] = "NumericLiteral";
        NodeType[NodeType["NullLiteral"] = 8] = "NullLiteral";

        NodeType[NodeType["TypeParameter"] = 9] = "TypeParameter";
        NodeType[NodeType["GenericType"] = 10] = "GenericType";
        NodeType[NodeType["TypeRef"] = 11] = "TypeRef";

        NodeType[NodeType["FunctionDeclaration"] = 12] = "FunctionDeclaration";
        NodeType[NodeType["ClassDeclaration"] = 13] = "ClassDeclaration";
        NodeType[NodeType["InterfaceDeclaration"] = 14] = "InterfaceDeclaration";
        NodeType[NodeType["ModuleDeclaration"] = 15] = "ModuleDeclaration";
        NodeType[NodeType["ImportDeclaration"] = 16] = "ImportDeclaration";
        NodeType[NodeType["VariableDeclarator"] = 17] = "VariableDeclarator";
        NodeType[NodeType["VariableDeclaration"] = 18] = "VariableDeclaration";
        NodeType[NodeType["Parameter"] = 19] = "Parameter";

        NodeType[NodeType["Name"] = 20] = "Name";
        NodeType[NodeType["ArrayLiteralExpression"] = 21] = "ArrayLiteralExpression";
        NodeType[NodeType["ObjectLiteralExpression"] = 22] = "ObjectLiteralExpression";
        NodeType[NodeType["OmittedExpression"] = 23] = "OmittedExpression";
        NodeType[NodeType["VoidExpression"] = 24] = "VoidExpression";
        NodeType[NodeType["CommaExpression"] = 25] = "CommaExpression";
        NodeType[NodeType["PlusExpression"] = 26] = "PlusExpression";
        NodeType[NodeType["NegateExpression"] = 27] = "NegateExpression";
        NodeType[NodeType["DeleteExpression"] = 28] = "DeleteExpression";
        NodeType[NodeType["ThisExpression"] = 29] = "ThisExpression";
        NodeType[NodeType["SuperExpression"] = 30] = "SuperExpression";
        NodeType[NodeType["InExpression"] = 31] = "InExpression";
        NodeType[NodeType["MemberAccessExpression"] = 32] = "MemberAccessExpression";
        NodeType[NodeType["InstanceOfExpression"] = 33] = "InstanceOfExpression";
        NodeType[NodeType["TypeOfExpression"] = 34] = "TypeOfExpression";
        NodeType[NodeType["ElementAccessExpression"] = 35] = "ElementAccessExpression";
        NodeType[NodeType["InvocationExpression"] = 36] = "InvocationExpression";
        NodeType[NodeType["ObjectCreationExpression"] = 37] = "ObjectCreationExpression";
        NodeType[NodeType["AssignmentExpression"] = 38] = "AssignmentExpression";
        NodeType[NodeType["AddAssignmentExpression"] = 39] = "AddAssignmentExpression";
        NodeType[NodeType["SubtractAssignmentExpression"] = 40] = "SubtractAssignmentExpression";
        NodeType[NodeType["DivideAssignmentExpression"] = 41] = "DivideAssignmentExpression";
        NodeType[NodeType["MultiplyAssignmentExpression"] = 42] = "MultiplyAssignmentExpression";
        NodeType[NodeType["ModuloAssignmentExpression"] = 43] = "ModuloAssignmentExpression";
        NodeType[NodeType["AndAssignmentExpression"] = 44] = "AndAssignmentExpression";
        NodeType[NodeType["ExclusiveOrAssignmentExpression"] = 45] = "ExclusiveOrAssignmentExpression";
        NodeType[NodeType["OrAssignmentExpression"] = 46] = "OrAssignmentExpression";
        NodeType[NodeType["LeftShiftAssignmentExpression"] = 47] = "LeftShiftAssignmentExpression";
        NodeType[NodeType["SignedRightShiftAssignmentExpression"] = 48] = "SignedRightShiftAssignmentExpression";
        NodeType[NodeType["UnsignedRightShiftAssignmentExpression"] = 49] = "UnsignedRightShiftAssignmentExpression";
        NodeType[NodeType["ConditionalExpression"] = 50] = "ConditionalExpression";
        NodeType[NodeType["LogicalOrExpression"] = 51] = "LogicalOrExpression";
        NodeType[NodeType["LogicalAndExpression"] = 52] = "LogicalAndExpression";
        NodeType[NodeType["BitwiseOrExpression"] = 53] = "BitwiseOrExpression";
        NodeType[NodeType["BitwiseExclusiveOrExpression"] = 54] = "BitwiseExclusiveOrExpression";
        NodeType[NodeType["BitwiseAndExpression"] = 55] = "BitwiseAndExpression";
        NodeType[NodeType["EqualsWithTypeConversionExpression"] = 56] = "EqualsWithTypeConversionExpression";
        NodeType[NodeType["NotEqualsWithTypeConversionExpression"] = 57] = "NotEqualsWithTypeConversionExpression";
        NodeType[NodeType["EqualsExpression"] = 58] = "EqualsExpression";
        NodeType[NodeType["NotEqualsExpression"] = 59] = "NotEqualsExpression";
        NodeType[NodeType["LessThanExpression"] = 60] = "LessThanExpression";
        NodeType[NodeType["LessThanOrEqualExpression"] = 61] = "LessThanOrEqualExpression";
        NodeType[NodeType["GreaterThanExpression"] = 62] = "GreaterThanExpression";
        NodeType[NodeType["GreaterThanOrEqualExpression"] = 63] = "GreaterThanOrEqualExpression";
        NodeType[NodeType["AddExpression"] = 64] = "AddExpression";
        NodeType[NodeType["SubtractExpression"] = 65] = "SubtractExpression";
        NodeType[NodeType["MultiplyExpression"] = 66] = "MultiplyExpression";
        NodeType[NodeType["DivideExpression"] = 67] = "DivideExpression";
        NodeType[NodeType["ModuloExpression"] = 68] = "ModuloExpression";
        NodeType[NodeType["LeftShiftExpression"] = 69] = "LeftShiftExpression";
        NodeType[NodeType["SignedRightShiftExpression"] = 70] = "SignedRightShiftExpression";
        NodeType[NodeType["UnsignedRightShiftExpression"] = 71] = "UnsignedRightShiftExpression";
        NodeType[NodeType["BitwiseNotExpression"] = 72] = "BitwiseNotExpression";
        NodeType[NodeType["LogicalNotExpression"] = 73] = "LogicalNotExpression";
        NodeType[NodeType["PreIncrementExpression"] = 74] = "PreIncrementExpression";
        NodeType[NodeType["PreDecrementExpression"] = 75] = "PreDecrementExpression";
        NodeType[NodeType["PostIncrementExpression"] = 76] = "PostIncrementExpression";
        NodeType[NodeType["PostDecrementExpression"] = 77] = "PostDecrementExpression";
        NodeType[NodeType["CastExpression"] = 78] = "CastExpression";
        NodeType[NodeType["ParenthesizedExpression"] = 79] = "ParenthesizedExpression";
        NodeType[NodeType["Member"] = 80] = "Member";

        NodeType[NodeType["Block"] = 81] = "Block";
        NodeType[NodeType["BreakStatement"] = 82] = "BreakStatement";
        NodeType[NodeType["ContinueStatement"] = 83] = "ContinueStatement";
        NodeType[NodeType["DebuggerStatement"] = 84] = "DebuggerStatement";
        NodeType[NodeType["DoStatement"] = 85] = "DoStatement";
        NodeType[NodeType["EmptyStatement"] = 86] = "EmptyStatement";
        NodeType[NodeType["ExportAssignment"] = 87] = "ExportAssignment";
        NodeType[NodeType["ExpressionStatement"] = 88] = "ExpressionStatement";
        NodeType[NodeType["ForInStatement"] = 89] = "ForInStatement";
        NodeType[NodeType["ForStatement"] = 90] = "ForStatement";
        NodeType[NodeType["IfStatement"] = 91] = "IfStatement";
        NodeType[NodeType["LabeledStatement"] = 92] = "LabeledStatement";
        NodeType[NodeType["ReturnStatement"] = 93] = "ReturnStatement";
        NodeType[NodeType["SwitchStatement"] = 94] = "SwitchStatement";
        NodeType[NodeType["ThrowStatement"] = 95] = "ThrowStatement";
        NodeType[NodeType["TryStatement"] = 96] = "TryStatement";
        NodeType[NodeType["VariableStatement"] = 97] = "VariableStatement";
        NodeType[NodeType["WhileStatement"] = 98] = "WhileStatement";
        NodeType[NodeType["WithStatement"] = 99] = "WithStatement";

        NodeType[NodeType["CaseClause"] = 100] = "CaseClause";
        NodeType[NodeType["CatchClause"] = 101] = "CatchClause";

        NodeType[NodeType["Comment"] = 102] = "Comment";
    })(TypeScript.NodeType || (TypeScript.NodeType = {}));
    var NodeType = TypeScript.NodeType;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var BlockIntrinsics = (function () {
        function BlockIntrinsics() {
            this.prototype = undefined;
            this.toString = undefined;
            this.toLocaleString = undefined;
            this.valueOf = undefined;
            this.hasOwnProperty = undefined;
            this.propertyIsEnumerable = undefined;
            this.isPrototypeOf = undefined;
            this["constructor"] = undefined;
        }
        return BlockIntrinsics;
    })();
    TypeScript.BlockIntrinsics = BlockIntrinsics;

    var StringHashTable = (function () {
        function StringHashTable() {
            this.itemCount = 0;
            this.table = (new BlockIntrinsics());
        }
        StringHashTable.prototype.getAllKeys = function () {
            var result = [];

            for (var k in this.table) {
                if (this.table[k] !== undefined) {
                    result.push(k);
                }
            }

            return result;
        };

        StringHashTable.prototype.add = function (key, data) {
            if (this.table[key] !== undefined) {
                return false;
            }

            this.table[key] = data;
            this.itemCount++;
            return true;
        };

        StringHashTable.prototype.addOrUpdate = function (key, data) {
            if (this.table[key] !== undefined) {
                this.table[key] = data;
                return false;
            }

            this.table[key] = data;
            this.itemCount++;
            return true;
        };

        StringHashTable.prototype.map = function (fn, context) {
            for (var k in this.table) {
                var data = this.table[k];

                if (data !== undefined) {
                    fn(k, this.table[k], context);
                }
            }
        };

        StringHashTable.prototype.every = function (fn, context) {
            for (var k in this.table) {
                var data = this.table[k];

                if (data !== undefined) {
                    if (!fn(k, this.table[k], context)) {
                        return false;
                    }
                }
            }

            return true;
        };

        StringHashTable.prototype.some = function (fn, context) {
            for (var k in this.table) {
                var data = this.table[k];

                if (data !== undefined) {
                    if (fn(k, this.table[k], context)) {
                        return true;
                    }
                }
            }

            return false;
        };

        StringHashTable.prototype.count = function () {
            return this.itemCount;
        };

        StringHashTable.prototype.lookup = function (key) {
            var data = this.table[key];
            return data === undefined ? null : data;
        };
        return StringHashTable;
    })();
    TypeScript.StringHashTable = StringHashTable;

    var IdentiferNameHashTable = (function (_super) {
        __extends(IdentiferNameHashTable, _super);
        function IdentiferNameHashTable() {
            _super.apply(this, arguments);
        }
        IdentiferNameHashTable.prototype.getAllKeys = function () {
            var result = [];

            _super.prototype.map.call(this, function (k, v, c) {
                if (v !== undefined) {
                    result.push(k.substring(1));
                }
            }, null);

            return result;
        };

        IdentiferNameHashTable.prototype.add = function (key, data) {
            return _super.prototype.add.call(this, "#" + key, data);
        };

        IdentiferNameHashTable.prototype.addOrUpdate = function (key, data) {
            return _super.prototype.addOrUpdate.call(this, "#" + key, data);
        };

        IdentiferNameHashTable.prototype.map = function (fn, context) {
            return _super.prototype.map.call(this, function (k, v, c) {
                return fn(k.substring(1), v, c);
            }, context);
        };

        IdentiferNameHashTable.prototype.every = function (fn, context) {
            return _super.prototype.every.call(this, function (k, v, c) {
                return fn(k.substring(1), v, c);
            }, context);
        };

        IdentiferNameHashTable.prototype.some = function (fn, context) {
            return _super.prototype.some.call(this, function (k, v, c) {
                return fn(k.substring(1), v, c);
            }, context);
        };

        IdentiferNameHashTable.prototype.lookup = function (key) {
            return _super.prototype.lookup.call(this, "#" + key);
        };
        return IdentiferNameHashTable;
    })(StringHashTable);
    TypeScript.IdentiferNameHashTable = IdentiferNameHashTable;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var ASTSpan = (function () {
        function ASTSpan() {
            this.minChar = -1;
            this.limChar = -1;
            this.trailingTriviaWidth = 0;
        }
        return ASTSpan;
    })();
    TypeScript.ASTSpan = ASTSpan;

    TypeScript.astID = 0;

    function structuralEqualsNotIncludingPosition(ast1, ast2) {
        return structuralEquals(ast1, ast2, false);
    }
    TypeScript.structuralEqualsNotIncludingPosition = structuralEqualsNotIncludingPosition;

    function structuralEqualsIncludingPosition(ast1, ast2) {
        return structuralEquals(ast1, ast2, true);
    }
    TypeScript.structuralEqualsIncludingPosition = structuralEqualsIncludingPosition;

    function structuralEquals(ast1, ast2, includingPosition) {
        if (ast1 === ast2) {
            return true;
        }

        return ast1 !== null && ast2 !== null && ast1.nodeType === ast2.nodeType && ast1.structuralEquals(ast2, includingPosition);
    }

    function astArrayStructuralEquals(array1, array2, includingPosition) {
        return TypeScript.ArrayUtilities.sequenceEquals(array1, array2, includingPosition ? structuralEqualsIncludingPosition : structuralEqualsNotIncludingPosition);
    }

    var AST = (function () {
        function AST(nodeType) {
            this.nodeType = nodeType;
            this.minChar = -1;
            this.limChar = -1;
            this.trailingTriviaWidth = 0;
            this._flags = 0 /* None */;
            this.typeCheckPhase = -1;
            this.astID = TypeScript.astID++;
            this.passCreated = TypeScript.CompilerDiagnostics.analysisPass;
            this.preComments = null;
            this.postComments = null;
            this.docComments = null;
        }
        AST.prototype.shouldEmit = function () {
            return true;
        };

        AST.prototype.isExpression = function () {
            return false;
        };
        AST.prototype.isStatementOrExpression = function () {
            return false;
        };

        AST.prototype.getFlags = function () {
            return this._flags;
        };

        AST.prototype.setFlags = function (flags) {
            this._flags = flags;
        };

        AST.prototype.getLength = function () {
            return this.limChar - this.minChar;
        };

        AST.prototype.getID = function () {
            return this.astID;
        };

        AST.prototype.isDeclaration = function () {
            return false;
        };

        AST.prototype.isStatement = function () {
            return false;
        };

        AST.prototype.emit = function (emitter) {
            emitter.emitComments(this, true);
            emitter.recordSourceMappingStart(this);
            this.emitWorker(emitter);
            emitter.recordSourceMappingEnd(this);
            emitter.emitComments(this, false);
        };

        AST.prototype.emitWorker = function (emitter) {
            throw new Error("please implement in derived class");
        };

        AST.prototype.getDocComments = function () {
            if (!this.isDeclaration() || !this.preComments || this.preComments.length === 0) {
                return [];
            }

            if (!this.docComments) {
                var preCommentsLength = this.preComments.length;
                var docComments = [];
                for (var i = preCommentsLength - 1; i >= 0; i--) {
                    if (this.preComments[i].isDocComment()) {
                        var prevDocComment = docComments.length > 0 ? docComments[docComments.length - 1] : null;
                        if (prevDocComment === null || (this.preComments[i].limLine === prevDocComment.minLine || this.preComments[i].limLine + 1 === prevDocComment.minLine)) {
                            docComments.push(this.preComments[i]);
                            continue;
                        }
                    }
                    break;
                }

                this.docComments = docComments.reverse();
            }

            return this.docComments;
        };

        AST.prototype.structuralEquals = function (ast, includingPosition) {
            if (includingPosition) {
                if (this.minChar !== ast.minChar || this.limChar !== ast.limChar) {
                    return false;
                }
            }

            return this._flags === ast._flags && astArrayStructuralEquals(this.preComments, ast.preComments, includingPosition) && astArrayStructuralEquals(this.postComments, ast.postComments, includingPosition);
        };
        return AST;
    })();
    TypeScript.AST = AST;

    var ASTList = (function (_super) {
        __extends(ASTList, _super);
        function ASTList() {
            _super.call(this, 1 /* List */);
            this.members = [];
        }
        ASTList.prototype.append = function (ast) {
            this.members[this.members.length] = ast;
            return this;
        };

        ASTList.prototype.emit = function (emitter) {
            emitter.recordSourceMappingStart(this);
            emitter.emitModuleElements(this);
            emitter.recordSourceMappingEnd(this);
        };

        ASTList.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && astArrayStructuralEquals(this.members, ast.members, includingPosition);
        };
        return ASTList;
    })(AST);
    TypeScript.ASTList = ASTList;

    var Expression = (function (_super) {
        __extends(Expression, _super);
        function Expression(nodeType) {
            _super.call(this, nodeType);
        }
        return Expression;
    })(AST);
    TypeScript.Expression = Expression;

    var Identifier = (function (_super) {
        __extends(Identifier, _super);
        function Identifier(actualText) {
            _super.call(this, 20 /* Name */);
            this.actualText = actualText;
            this.setText(actualText);
        }
        Identifier.prototype.setText = function (actualText) {
            this.actualText = actualText;
            this.text = actualText;
        };

        Identifier.prototype.isMissing = function () {
            return false;
        };

        Identifier.prototype.emit = function (emitter) {
            emitter.emitName(this, true);
        };

        Identifier.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this.text === ast.text && this.actualText === ast.actualText && this.isMissing() === ast.isMissing();
        };
        return Identifier;
    })(Expression);
    TypeScript.Identifier = Identifier;

    var MissingIdentifier = (function (_super) {
        __extends(MissingIdentifier, _super);
        function MissingIdentifier() {
            _super.call(this, "__missing");
        }
        MissingIdentifier.prototype.isMissing = function () {
            return true;
        };

        MissingIdentifier.prototype.emit = function (emitter) {
        };
        return MissingIdentifier;
    })(Identifier);
    TypeScript.MissingIdentifier = MissingIdentifier;

    var LiteralExpression = (function (_super) {
        __extends(LiteralExpression, _super);
        function LiteralExpression(nodeType) {
            _super.call(this, nodeType);
        }
        LiteralExpression.prototype.emitWorker = function (emitter) {
            switch (this.nodeType) {
                case 8 /* NullLiteral */:
                    emitter.writeToOutput("null");
                    break;
                case 4 /* FalseLiteral */:
                    emitter.writeToOutput("false");
                    break;
                case 3 /* TrueLiteral */:
                    emitter.writeToOutput("true");
                    break;
                default:
                    throw new Error("please implement in derived class");
            }
        };

        LiteralExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition);
        };
        return LiteralExpression;
    })(Expression);
    TypeScript.LiteralExpression = LiteralExpression;

    var ThisExpression = (function (_super) {
        __extends(ThisExpression, _super);
        function ThisExpression() {
            _super.call(this, 29 /* ThisExpression */);
        }
        ThisExpression.prototype.emitWorker = function (emitter) {
            if (emitter.thisFunctionDeclaration && (TypeScript.hasFlag(emitter.thisFunctionDeclaration.getFunctionFlags(), 2048 /* IsFatArrowFunction */))) {
                emitter.writeToOutput("_this");
            } else {
                emitter.writeToOutput("this");
            }
        };

        ThisExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition);
        };
        return ThisExpression;
    })(Expression);
    TypeScript.ThisExpression = ThisExpression;

    var SuperExpression = (function (_super) {
        __extends(SuperExpression, _super);
        function SuperExpression() {
            _super.call(this, 30 /* SuperExpression */);
        }
        SuperExpression.prototype.emitWorker = function (emitter) {
            emitter.emitSuperReference();
        };

        SuperExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition);
        };
        return SuperExpression;
    })(Expression);
    TypeScript.SuperExpression = SuperExpression;

    var ParenthesizedExpression = (function (_super) {
        __extends(ParenthesizedExpression, _super);
        function ParenthesizedExpression(expression) {
            _super.call(this, 79 /* ParenthesizedExpression */);
            this.expression = expression;
        }
        ParenthesizedExpression.prototype.emitWorker = function (emitter) {
            emitter.writeToOutput("(");
            this.expression.emit(emitter);
            emitter.writeToOutput(")");
        };

        ParenthesizedExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.expression, ast.expression, includingPosition);
        };
        return ParenthesizedExpression;
    })(Expression);
    TypeScript.ParenthesizedExpression = ParenthesizedExpression;

    var UnaryExpression = (function (_super) {
        __extends(UnaryExpression, _super);
        function UnaryExpression(nodeType, operand) {
            _super.call(this, nodeType);
            this.operand = operand;
            this.castTerm = null;
        }
        UnaryExpression.prototype.emitWorker = function (emitter) {
            switch (this.nodeType) {
                case 76 /* PostIncrementExpression */:
                    this.operand.emit(emitter);
                    emitter.writeToOutput("++");
                    break;
                case 73 /* LogicalNotExpression */:
                    emitter.writeToOutput("!");
                    this.operand.emit(emitter);
                    break;
                case 77 /* PostDecrementExpression */:
                    this.operand.emit(emitter);
                    emitter.writeToOutput("--");
                    break;
                case 22 /* ObjectLiteralExpression */:
                    emitter.emitObjectLiteral(this);
                    break;
                case 21 /* ArrayLiteralExpression */:
                    emitter.emitArrayLiteral(this);
                    break;
                case 72 /* BitwiseNotExpression */:
                    emitter.writeToOutput("~");
                    this.operand.emit(emitter);
                    break;
                case 27 /* NegateExpression */:
                    emitter.writeToOutput("-");
                    if (this.operand.nodeType === 27 /* NegateExpression */ || this.operand.nodeType === 75 /* PreDecrementExpression */) {
                        emitter.writeToOutput(" ");
                    }
                    this.operand.emit(emitter);
                    break;
                case 26 /* PlusExpression */:
                    emitter.writeToOutput("+");
                    if (this.operand.nodeType === 26 /* PlusExpression */ || this.operand.nodeType === 74 /* PreIncrementExpression */) {
                        emitter.writeToOutput(" ");
                    }
                    this.operand.emit(emitter);
                    break;
                case 74 /* PreIncrementExpression */:
                    emitter.writeToOutput("++");
                    this.operand.emit(emitter);
                    break;
                case 75 /* PreDecrementExpression */:
                    emitter.writeToOutput("--");
                    this.operand.emit(emitter);
                    break;
                case 34 /* TypeOfExpression */:
                    emitter.writeToOutput("typeof ");
                    this.operand.emit(emitter);
                    break;
                case 28 /* DeleteExpression */:
                    emitter.writeToOutput("delete ");
                    this.operand.emit(emitter);
                    break;
                case 24 /* VoidExpression */:
                    emitter.writeToOutput("void ");
                    this.operand.emit(emitter);
                    break;
                case 78 /* CastExpression */:
                    this.operand.emit(emitter);
                    break;
                default:
                    throw new Error("please implement in derived class");
            }
        };

        UnaryExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.castTerm, ast.castTerm, includingPosition) && structuralEquals(this.operand, ast.operand, includingPosition);
        };
        return UnaryExpression;
    })(Expression);
    TypeScript.UnaryExpression = UnaryExpression;

    var CallExpression = (function (_super) {
        __extends(CallExpression, _super);
        function CallExpression(nodeType, target, typeArguments, arguments) {
            _super.call(this, nodeType);
            this.target = target;
            this.typeArguments = typeArguments;
            this.arguments = arguments;
        }
        CallExpression.prototype.emitWorker = function (emitter) {
            if (this.nodeType === 37 /* ObjectCreationExpression */) {
                emitter.emitNew(this.target, this.arguments);
            } else {
                emitter.emitCall(this, this.target, this.arguments);
            }
        };

        CallExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.target, ast.target, includingPosition) && structuralEquals(this.typeArguments, ast.typeArguments, includingPosition) && structuralEquals(this.arguments, ast.arguments, includingPosition);
        };
        return CallExpression;
    })(Expression);
    TypeScript.CallExpression = CallExpression;

    var BinaryExpression = (function (_super) {
        __extends(BinaryExpression, _super);
        function BinaryExpression(nodeType, operand1, operand2) {
            _super.call(this, nodeType);
            this.operand1 = operand1;
            this.operand2 = operand2;
        }
        BinaryExpression.getTextForBinaryToken = function (nodeType) {
            switch (nodeType) {
                case 25 /* CommaExpression */:
                    return ",";
                case 38 /* AssignmentExpression */:
                    return "=";
                case 39 /* AddAssignmentExpression */:
                    return "+=";
                case 40 /* SubtractAssignmentExpression */:
                    return "-=";
                case 42 /* MultiplyAssignmentExpression */:
                    return "*=";
                case 41 /* DivideAssignmentExpression */:
                    return "/=";
                case 43 /* ModuloAssignmentExpression */:
                    return "%=";
                case 44 /* AndAssignmentExpression */:
                    return "&=";
                case 45 /* ExclusiveOrAssignmentExpression */:
                    return "^=";
                case 46 /* OrAssignmentExpression */:
                    return "|=";
                case 47 /* LeftShiftAssignmentExpression */:
                    return "<<=";
                case 48 /* SignedRightShiftAssignmentExpression */:
                    return ">>=";
                case 49 /* UnsignedRightShiftAssignmentExpression */:
                    return ">>>=";
                case 51 /* LogicalOrExpression */:
                    return "||";
                case 52 /* LogicalAndExpression */:
                    return "&&";
                case 53 /* BitwiseOrExpression */:
                    return "|";
                case 54 /* BitwiseExclusiveOrExpression */:
                    return "^";
                case 55 /* BitwiseAndExpression */:
                    return "&";
                case 56 /* EqualsWithTypeConversionExpression */:
                    return "==";
                case 57 /* NotEqualsWithTypeConversionExpression */:
                    return "!=";
                case 58 /* EqualsExpression */:
                    return "===";
                case 59 /* NotEqualsExpression */:
                    return "!==";
                case 60 /* LessThanExpression */:
                    return "<";
                case 62 /* GreaterThanExpression */:
                    return ">";
                case 61 /* LessThanOrEqualExpression */:
                    return "<=";
                case 63 /* GreaterThanOrEqualExpression */:
                    return ">=";
                case 33 /* InstanceOfExpression */:
                    return "instanceof";
                case 31 /* InExpression */:
                    return "in";
                case 69 /* LeftShiftExpression */:
                    return "<<";
                case 70 /* SignedRightShiftExpression */:
                    return ">>";
                case 71 /* UnsignedRightShiftExpression */:
                    return ">>>";
                case 66 /* MultiplyExpression */:
                    return "*";
                case 67 /* DivideExpression */:
                    return "/";
                case 68 /* ModuloExpression */:
                    return "%";
                case 64 /* AddExpression */:
                    return "+";
                case 65 /* SubtractExpression */:
                    return "-";
            }

            throw TypeScript.Errors.invalidOperation();
        };

        BinaryExpression.prototype.emitWorker = function (emitter) {
            switch (this.nodeType) {
                case 32 /* MemberAccessExpression */:
                    if (!emitter.tryEmitConstant(this)) {
                        this.operand1.emit(emitter);
                        emitter.writeToOutput(".");
                        emitter.emitName(this.operand2, false);
                    }
                    break;
                case 35 /* ElementAccessExpression */:
                    emitter.emitIndex(this.operand1, this.operand2);
                    break;

                case 80 /* Member */:
                    if (this.operand2.nodeType === 12 /* FunctionDeclaration */ && (this.operand2).isAccessor()) {
                        var funcDecl = this.operand2;
                        if (TypeScript.hasFlag(funcDecl.getFunctionFlags(), 32 /* GetAccessor */)) {
                            emitter.writeToOutput("get ");
                        } else {
                            emitter.writeToOutput("set ");
                        }
                        this.operand1.emit(emitter);
                    } else {
                        this.operand1.emit(emitter);
                        emitter.writeToOutputTrimmable(": ");
                    }
                    this.operand2.emit(emitter);
                    break;
                case 25 /* CommaExpression */:
                    this.operand1.emit(emitter);
                    emitter.writeToOutput(", ");
                    this.operand2.emit(emitter);
                    break;
                default: {
                    this.operand1.emit(emitter);
                    var binOp = BinaryExpression.getTextForBinaryToken(this.nodeType);
                    if (binOp === "instanceof") {
                        emitter.writeToOutput(" instanceof ");
                    } else if (binOp === "in") {
                        emitter.writeToOutput(" in ");
                    } else {
                        emitter.writeToOutputTrimmable(" " + binOp + " ");
                    }
                    this.operand2.emit(emitter);
                }
            }
        };

        BinaryExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.operand1, ast.operand1, includingPosition) && structuralEquals(this.operand2, ast.operand2, includingPosition);
        };
        return BinaryExpression;
    })(Expression);
    TypeScript.BinaryExpression = BinaryExpression;

    var ConditionalExpression = (function (_super) {
        __extends(ConditionalExpression, _super);
        function ConditionalExpression(operand1, operand2, operand3) {
            _super.call(this, 50 /* ConditionalExpression */);
            this.operand1 = operand1;
            this.operand2 = operand2;
            this.operand3 = operand3;
        }
        ConditionalExpression.prototype.emitWorker = function (emitter) {
            this.operand1.emit(emitter);
            emitter.writeToOutput(" ? ");
            this.operand2.emit(emitter);
            emitter.writeToOutput(" : ");
            this.operand3.emit(emitter);
        };

        ConditionalExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.operand1, ast.operand1, includingPosition) && structuralEquals(this.operand2, ast.operand2, includingPosition) && structuralEquals(this.operand3, ast.operand3, includingPosition);
        };
        return ConditionalExpression;
    })(Expression);
    TypeScript.ConditionalExpression = ConditionalExpression;

    var NumberLiteral = (function (_super) {
        __extends(NumberLiteral, _super);
        function NumberLiteral(value, text) {
            _super.call(this, 7 /* NumericLiteral */);
            this.value = value;
            this.text = text;
        }
        NumberLiteral.prototype.emitWorker = function (emitter) {
            emitter.writeToOutput(this.text);
        };

        NumberLiteral.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this.value === ast.value && this.text === ast.text;
        };
        return NumberLiteral;
    })(Expression);
    TypeScript.NumberLiteral = NumberLiteral;

    var RegexLiteral = (function (_super) {
        __extends(RegexLiteral, _super);
        function RegexLiteral(text) {
            _super.call(this, 6 /* RegularExpressionLiteral */);
            this.text = text;
        }
        RegexLiteral.prototype.emitWorker = function (emitter) {
            emitter.writeToOutput(this.text);
        };

        RegexLiteral.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this.text === ast.text;
        };
        return RegexLiteral;
    })(Expression);
    TypeScript.RegexLiteral = RegexLiteral;

    var StringLiteral = (function (_super) {
        __extends(StringLiteral, _super);
        function StringLiteral(actualText, text) {
            _super.call(this, 5 /* StringLiteral */);
            this.actualText = actualText;
            this.text = text;
        }
        StringLiteral.prototype.emitWorker = function (emitter) {
            emitter.writeToOutput(this.actualText);
        };

        StringLiteral.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this.actualText === ast.actualText;
        };
        return StringLiteral;
    })(Expression);
    TypeScript.StringLiteral = StringLiteral;

    var ImportDeclaration = (function (_super) {
        __extends(ImportDeclaration, _super);
        function ImportDeclaration(id, alias) {
            _super.call(this, 16 /* ImportDeclaration */);
            this.id = id;
            this.alias = alias;
            this.isDynamicImport = false;
        }
        ImportDeclaration.prototype.isStatementOrExpression = function () {
            return true;
        };

        ImportDeclaration.prototype.isDeclaration = function () {
            return true;
        };

        ImportDeclaration.prototype.emit = function (emitter) {
            if (emitter.importStatementShouldBeEmitted(this)) {
                var prevModAliasId = emitter.modAliasId;
                var prevFirstModAlias = emitter.firstModAlias;

                emitter.recordSourceMappingStart(this);
                emitter.emitComments(this, true);
                emitter.writeToOutput("var " + this.id.actualText + " = ");
                emitter.modAliasId = this.id.actualText;
                emitter.firstModAlias = this.firstAliasedModToString();
                var aliasAST = this.alias.nodeType === 11 /* TypeRef */ ? (this.alias).term : this.alias;

                emitter.emitJavascript(aliasAST, false);
                emitter.writeToOutput(";");

                emitter.emitComments(this, false);
                emitter.recordSourceMappingEnd(this);

                emitter.modAliasId = prevModAliasId;
                emitter.firstModAlias = prevFirstModAlias;
            }
        };

        ImportDeclaration.prototype.getAliasName = function (aliasAST) {
            if (typeof aliasAST === "undefined") { aliasAST = this.alias; }
            if (aliasAST.nodeType === 20 /* Name */) {
                return (aliasAST).actualText;
            } else {
                var dotExpr = aliasAST;
                return this.getAliasName(dotExpr.operand1) + "." + this.getAliasName(dotExpr.operand2);
            }
        };

        ImportDeclaration.prototype.firstAliasedModToString = function () {
            if (this.alias.nodeType === 20 /* Name */) {
                return (this.alias).actualText;
            } else {
                var dotExpr = this.alias;
                var firstMod = (dotExpr.term).operand1;
                return firstMod.actualText;
            }
        };

        ImportDeclaration.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.id, ast.id, includingPosition) && structuralEquals(this.alias, ast.alias, includingPosition);
        };
        return ImportDeclaration;
    })(AST);
    TypeScript.ImportDeclaration = ImportDeclaration;

    var ExportAssignment = (function (_super) {
        __extends(ExportAssignment, _super);
        function ExportAssignment(id) {
            _super.call(this, 87 /* ExportAssignment */);
            this.id = id;
        }
        ExportAssignment.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.id, ast.id, includingPosition);
        };

        ExportAssignment.prototype.emit = function (emitter) {
            emitter.setExportAssignmentIdentifier(this.id.actualText);
        };
        return ExportAssignment;
    })(AST);
    TypeScript.ExportAssignment = ExportAssignment;

    var BoundDecl = (function (_super) {
        __extends(BoundDecl, _super);
        function BoundDecl(id, nodeType) {
            _super.call(this, nodeType);
            this.id = id;
            this.init = null;
            this.isImplicitlyInitialized = false;
            this.typeExpr = null;
            this._varFlags = 0 /* None */;
        }
        BoundDecl.prototype.isDeclaration = function () {
            return true;
        };
        BoundDecl.prototype.isStatementOrExpression = function () {
            return true;
        };

        BoundDecl.prototype.getVarFlags = function () {
            return this._varFlags;
        };

        BoundDecl.prototype.setVarFlags = function (flags) {
            this._varFlags = flags;
        };

        BoundDecl.prototype.isProperty = function () {
            return TypeScript.hasFlag(this.getVarFlags(), 256 /* Property */);
        };

        BoundDecl.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this._varFlags === ast._varFlags && structuralEquals(this.init, ast.init, includingPosition) && structuralEquals(this.typeExpr, ast.typeExpr, includingPosition) && structuralEquals(this.id, ast.id, includingPosition);
        };
        return BoundDecl;
    })(AST);
    TypeScript.BoundDecl = BoundDecl;

    var VariableDeclarator = (function (_super) {
        __extends(VariableDeclarator, _super);
        function VariableDeclarator(id) {
            _super.call(this, id, 17 /* VariableDeclarator */);
        }
        VariableDeclarator.prototype.isExported = function () {
            return TypeScript.hasFlag(this.getVarFlags(), 1 /* Exported */);
        };

        VariableDeclarator.prototype.isStatic = function () {
            return TypeScript.hasFlag(this.getVarFlags(), 16 /* Static */);
        };

        VariableDeclarator.prototype.emit = function (emitter) {
            emitter.emitVariableDeclarator(this);
        };
        return VariableDeclarator;
    })(BoundDecl);
    TypeScript.VariableDeclarator = VariableDeclarator;

    var Parameter = (function (_super) {
        __extends(Parameter, _super);
        function Parameter(id) {
            _super.call(this, id, 19 /* Parameter */);
            this.isOptional = false;
        }
        Parameter.prototype.isOptionalArg = function () {
            return this.isOptional || this.init;
        };

        Parameter.prototype.emitWorker = function (emitter) {
            emitter.writeToOutput(this.id.actualText);
        };

        Parameter.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this.isOptional === ast.isOptional;
        };
        return Parameter;
    })(BoundDecl);
    TypeScript.Parameter = Parameter;

    var FunctionDeclaration = (function (_super) {
        __extends(FunctionDeclaration, _super);
        function FunctionDeclaration(name, block, isConstructor, typeArguments, arguments, nodeType) {
            _super.call(this, nodeType);
            this.name = name;
            this.block = block;
            this.isConstructor = isConstructor;
            this.typeArguments = typeArguments;
            this.arguments = arguments;
            this.hint = null;
            this._functionFlags = 0 /* None */;
            this.returnTypeAnnotation = null;
            this.variableArgList = false;
            this.classDecl = null;
        }
        FunctionDeclaration.prototype.isDeclaration = function () {
            return true;
        };

        FunctionDeclaration.prototype.getFunctionFlags = function () {
            return this._functionFlags;
        };

        FunctionDeclaration.prototype.setFunctionFlags = function (flags) {
            this._functionFlags = flags;
        };

        FunctionDeclaration.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this._functionFlags === ast._functionFlags && this.hint === ast.hint && this.variableArgList === ast.variableArgList && structuralEquals(this.name, ast.name, includingPosition) && structuralEquals(this.block, ast.block, includingPosition) && this.isConstructor === ast.isConstructor && structuralEquals(this.typeArguments, ast.typeArguments, includingPosition) && structuralEquals(this.arguments, ast.arguments, includingPosition);
        };

        FunctionDeclaration.prototype.shouldEmit = function () {
            return !TypeScript.hasFlag(this.getFunctionFlags(), 128 /* Signature */) && !TypeScript.hasFlag(this.getFunctionFlags(), 8 /* Ambient */);
        };

        FunctionDeclaration.prototype.emit = function (emitter) {
            emitter.emitFunction(this);
        };

        FunctionDeclaration.prototype.getNameText = function () {
            if (this.name) {
                return this.name.actualText;
            } else {
                return this.hint;
            }
        };

        FunctionDeclaration.prototype.isMethod = function () {
            return (this.getFunctionFlags() & 256 /* Method */) !== 0 /* None */;
        };

        FunctionDeclaration.prototype.isCallMember = function () {
            return TypeScript.hasFlag(this.getFunctionFlags(), 512 /* CallMember */);
        };
        FunctionDeclaration.prototype.isConstructMember = function () {
            return TypeScript.hasFlag(this.getFunctionFlags(), 1024 /* ConstructMember */);
        };
        FunctionDeclaration.prototype.isIndexerMember = function () {
            return TypeScript.hasFlag(this.getFunctionFlags(), 4096 /* IndexerMember */);
        };
        FunctionDeclaration.prototype.isSpecialFn = function () {
            return this.isCallMember() || this.isIndexerMember() || this.isConstructMember();
        };
        FunctionDeclaration.prototype.isAccessor = function () {
            return TypeScript.hasFlag(this.getFunctionFlags(), 32 /* GetAccessor */) || TypeScript.hasFlag(this.getFunctionFlags(), 64 /* SetAccessor */);
        };
        FunctionDeclaration.prototype.isGetAccessor = function () {
            return TypeScript.hasFlag(this.getFunctionFlags(), 32 /* GetAccessor */);
        };
        FunctionDeclaration.prototype.isSetAccessor = function () {
            return TypeScript.hasFlag(this.getFunctionFlags(), 64 /* SetAccessor */);
        };
        FunctionDeclaration.prototype.isStatic = function () {
            return TypeScript.hasFlag(this.getFunctionFlags(), 16 /* Static */);
        };

        FunctionDeclaration.prototype.isSignature = function () {
            return (this.getFunctionFlags() & 128 /* Signature */) !== 0 /* None */;
        };
        return FunctionDeclaration;
    })(AST);
    TypeScript.FunctionDeclaration = FunctionDeclaration;

    var Script = (function (_super) {
        __extends(Script, _super);
        function Script() {
            _super.call(this, 2 /* Script */);
            this.moduleElements = null;
            this.referencedFiles = [];
            this.requiresExtendsBlock = false;
            this.isDeclareFile = false;
            this.topLevelMod = null;
            this.containsUnicodeChar = false;
            this.containsUnicodeCharInComment = false;
        }
        Script.prototype.emit = function (emitter) {
            if (!this.isDeclareFile) {
                emitter.emitScriptElements(this, this.requiresExtendsBlock);
            }
        };

        Script.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.moduleElements, ast.moduleElements, includingPosition);
        };
        return Script;
    })(AST);
    TypeScript.Script = Script;

    var NamedDeclaration = (function (_super) {
        __extends(NamedDeclaration, _super);
        function NamedDeclaration(nodeType, name, members) {
            _super.call(this, nodeType);
            this.name = name;
            this.members = members;
        }
        NamedDeclaration.prototype.isDeclaration = function () {
            return true;
        };

        NamedDeclaration.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.name, ast.name, includingPosition) && structuralEquals(this.members, ast.members, includingPosition);
        };
        return NamedDeclaration;
    })(AST);
    TypeScript.NamedDeclaration = NamedDeclaration;

    var ModuleDeclaration = (function (_super) {
        __extends(ModuleDeclaration, _super);
        function ModuleDeclaration(name, members, endingToken) {
            _super.call(this, 15 /* ModuleDeclaration */, name, members);
            this.endingToken = endingToken;
            this._moduleFlags = 0 /* None */;
            this.amdDependencies = [];
            this.containsUnicodeChar = false;
            this.containsUnicodeCharInComment = false;

            this.prettyName = this.name.actualText;
        }
        ModuleDeclaration.prototype.getModuleFlags = function () {
            return this._moduleFlags;
        };

        ModuleDeclaration.prototype.setModuleFlags = function (flags) {
            this._moduleFlags = flags;
        };

        ModuleDeclaration.prototype.structuralEquals = function (ast, includePosition) {
            if (_super.prototype.structuralEquals.call(this, ast, includePosition)) {
                return this._moduleFlags === ast._moduleFlags;
            }

            return false;
        };

        ModuleDeclaration.prototype.isEnum = function () {
            return TypeScript.hasFlag(this.getModuleFlags(), 128 /* IsEnum */);
        };
        ModuleDeclaration.prototype.isWholeFile = function () {
            return TypeScript.hasFlag(this.getModuleFlags(), 256 /* IsWholeFile */);
        };

        ModuleDeclaration.prototype.shouldEmit = function () {
            if (TypeScript.hasFlag(this.getModuleFlags(), 8 /* Ambient */)) {
                return false;
            }

            if (TypeScript.hasFlag(this.getModuleFlags(), 128 /* IsEnum */)) {
                return true;
            }

            for (var i = 0, n = this.members.members.length; i < n; i++) {
                var member = this.members.members[i];

                if (member.nodeType === 15 /* ModuleDeclaration */) {
                    if ((member).shouldEmit()) {
                        return true;
                    }
                } else if (member.nodeType !== 14 /* InterfaceDeclaration */) {
                    return true;
                }
            }

            return false;
        };

        ModuleDeclaration.prototype.emit = function (emitter) {
            if (this.shouldEmit()) {
                emitter.emitComments(this, true);
                emitter.emitModule(this);
                emitter.emitComments(this, false);
            }
        };
        return ModuleDeclaration;
    })(NamedDeclaration);
    TypeScript.ModuleDeclaration = ModuleDeclaration;

    var TypeDeclaration = (function (_super) {
        __extends(TypeDeclaration, _super);
        function TypeDeclaration(nodeType, name, typeParameters, extendsList, implementsList, members) {
            _super.call(this, nodeType, name, members);
            this.typeParameters = typeParameters;
            this.extendsList = extendsList;
            this.implementsList = implementsList;
            this._varFlags = 0 /* None */;
        }
        TypeDeclaration.prototype.getVarFlags = function () {
            return this._varFlags;
        };

        TypeDeclaration.prototype.setVarFlags = function (flags) {
            this._varFlags = flags;
        };

        TypeDeclaration.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this._varFlags === ast._varFlags && structuralEquals(this.typeParameters, ast.typeParameters, includingPosition) && structuralEquals(this.extendsList, ast.extendsList, includingPosition) && structuralEquals(this.implementsList, ast.implementsList, includingPosition);
        };
        return TypeDeclaration;
    })(NamedDeclaration);
    TypeScript.TypeDeclaration = TypeDeclaration;

    var ClassDeclaration = (function (_super) {
        __extends(ClassDeclaration, _super);
        function ClassDeclaration(name, typeParameters, members, extendsList, implementsList) {
            _super.call(this, 13 /* ClassDeclaration */, name, typeParameters, extendsList, implementsList, members);
            this.constructorDecl = null;
            this.endingToken = null;
        }
        ClassDeclaration.prototype.shouldEmit = function () {
            return !TypeScript.hasFlag(this.getVarFlags(), 8 /* Ambient */);
        };

        ClassDeclaration.prototype.emit = function (emitter) {
            emitter.emitClass(this);
        };
        return ClassDeclaration;
    })(TypeDeclaration);
    TypeScript.ClassDeclaration = ClassDeclaration;

    var InterfaceDeclaration = (function (_super) {
        __extends(InterfaceDeclaration, _super);
        function InterfaceDeclaration(name, typeParameters, members, extendsList, implementsList) {
            _super.call(this, 14 /* InterfaceDeclaration */, name, typeParameters, extendsList, implementsList, members);
        }
        InterfaceDeclaration.prototype.shouldEmit = function () {
            return false;
        };
        return InterfaceDeclaration;
    })(TypeDeclaration);
    TypeScript.InterfaceDeclaration = InterfaceDeclaration;

    var Statement = (function (_super) {
        __extends(Statement, _super);
        function Statement(nodeType) {
            _super.call(this, nodeType);
        }
        Statement.prototype.isStatement = function () {
            return true;
        };

        Statement.prototype.isStatementOrExpression = function () {
            return true;
        };
        return Statement;
    })(AST);
    TypeScript.Statement = Statement;

    var ThrowStatement = (function (_super) {
        __extends(ThrowStatement, _super);
        function ThrowStatement(expression) {
            _super.call(this, 95 /* ThrowStatement */);
            this.expression = expression;
        }
        ThrowStatement.prototype.emitWorker = function (emitter) {
            emitter.writeToOutput("throw ");
            this.expression.emit(emitter);
            emitter.writeToOutput(";");
        };

        ThrowStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.expression, ast.expression, includingPosition);
        };
        return ThrowStatement;
    })(Statement);
    TypeScript.ThrowStatement = ThrowStatement;

    var ExpressionStatement = (function (_super) {
        __extends(ExpressionStatement, _super);
        function ExpressionStatement(expression) {
            _super.call(this, 88 /* ExpressionStatement */);
            this.expression = expression;
        }
        ExpressionStatement.prototype.emitWorker = function (emitter) {
            this.expression.emit(emitter);
            emitter.writeToOutput(";");
        };

        ExpressionStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.expression, ast.expression, includingPosition);
        };
        return ExpressionStatement;
    })(Statement);
    TypeScript.ExpressionStatement = ExpressionStatement;

    var LabeledStatement = (function (_super) {
        __extends(LabeledStatement, _super);
        function LabeledStatement(identifier, statement) {
            _super.call(this, 92 /* LabeledStatement */);
            this.identifier = identifier;
            this.statement = statement;
        }
        LabeledStatement.prototype.emitWorker = function (emitter) {
            emitter.recordSourceMappingStart(this.identifier);
            emitter.writeToOutput(this.identifier.actualText);
            emitter.recordSourceMappingEnd(this.identifier);
            emitter.writeLineToOutput(":");
            emitter.emitJavascript(this.statement, true);
        };

        LabeledStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.identifier, ast.identifier, includingPosition) && structuralEquals(this.statement, ast.statement, includingPosition);
        };
        return LabeledStatement;
    })(Statement);
    TypeScript.LabeledStatement = LabeledStatement;

    var VariableDeclaration = (function (_super) {
        __extends(VariableDeclaration, _super);
        function VariableDeclaration(declarators) {
            _super.call(this, 18 /* VariableDeclaration */);
            this.declarators = declarators;
        }
        VariableDeclaration.prototype.emit = function (emitter) {
            emitter.emitVariableDeclaration(this);
        };

        VariableDeclaration.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.declarators, ast.declarators, includingPosition);
        };
        return VariableDeclaration;
    })(AST);
    TypeScript.VariableDeclaration = VariableDeclaration;

    var VariableStatement = (function (_super) {
        __extends(VariableStatement, _super);
        function VariableStatement(declaration) {
            _super.call(this, 97 /* VariableStatement */);
            this.declaration = declaration;
        }
        VariableStatement.prototype.shouldEmit = function () {
            if (TypeScript.hasFlag(this.getFlags(), 32 /* EnumMapElement */)) {
                return false;
            }

            var varDecl = this.declaration.declarators.members[0];
            return !TypeScript.hasFlag(varDecl.getVarFlags(), 8 /* Ambient */) || varDecl.init !== null;
        };

        VariableStatement.prototype.emitWorker = function (emitter) {
            if (TypeScript.hasFlag(this.getFlags(), 16 /* EnumElement */)) {
                emitter.emitEnumElement(this.declaration.declarators.members[0]);
            } else {
                this.declaration.emit(emitter);
                emitter.writeToOutput(";");
            }
        };

        VariableStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.declaration, ast.declaration, includingPosition);
        };
        return VariableStatement;
    })(Statement);
    TypeScript.VariableStatement = VariableStatement;

    var Block = (function (_super) {
        __extends(Block, _super);
        function Block(statements) {
            _super.call(this, 81 /* Block */);
            this.statements = statements;
            this.closeBraceSpan = null;
        }
        Block.prototype.emitWorker = function (emitter) {
            emitter.writeLineToOutput(" {");
            emitter.indenter.increaseIndent();
            if (this.statements) {
                emitter.emitModuleElements(this.statements);
            }
            emitter.indenter.decreaseIndent();
            emitter.emitIndent();
            emitter.writeToOutput("}");
        };

        Block.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.statements, ast.statements, includingPosition);
        };
        return Block;
    })(Statement);
    TypeScript.Block = Block;

    var Jump = (function (_super) {
        __extends(Jump, _super);
        function Jump(nodeType) {
            _super.call(this, nodeType);
            this.target = null;
            this.resolvedTarget = null;
        }
        Jump.prototype.hasExplicitTarget = function () {
            return (this.target);
        };

        Jump.prototype.emitWorker = function (emitter) {
            if (this.nodeType === 82 /* BreakStatement */) {
                emitter.writeToOutput("break");
            } else {
                emitter.writeToOutput("continue");
            }
            if (this.hasExplicitTarget()) {
                emitter.writeToOutput(" " + this.target);
            }
            emitter.writeToOutput(";");
        };

        Jump.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this.target === ast.target;
        };
        return Jump;
    })(Statement);
    TypeScript.Jump = Jump;

    var WhileStatement = (function (_super) {
        __extends(WhileStatement, _super);
        function WhileStatement(cond, body) {
            _super.call(this, 98 /* WhileStatement */);
            this.cond = cond;
            this.body = body;
        }
        WhileStatement.prototype.emitWorker = function (emitter) {
            emitter.writeToOutput("while (");
            this.cond.emit(emitter);
            emitter.writeToOutput(")");
            emitter.emitBlockOrStatement(this.body);
        };

        WhileStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.cond, ast.cond, includingPosition) && structuralEquals(this.body, ast.body, includingPosition);
        };
        return WhileStatement;
    })(Statement);
    TypeScript.WhileStatement = WhileStatement;

    var DoStatement = (function (_super) {
        __extends(DoStatement, _super);
        function DoStatement(body, cond) {
            _super.call(this, 85 /* DoStatement */);
            this.body = body;
            this.cond = cond;
            this.whileSpan = null;
        }
        DoStatement.prototype.emitWorker = function (emitter) {
            emitter.writeToOutput("do");
            emitter.emitBlockOrStatement(this.body);
            emitter.recordSourceMappingStart(this.whileSpan);
            emitter.writeToOutput(" while");
            emitter.recordSourceMappingEnd(this.whileSpan);
            emitter.writeToOutput('(');
            this.cond.emit(emitter);
            emitter.writeToOutput(")");
            emitter.writeToOutput(";");
        };

        DoStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.body, ast.body, includingPosition) && structuralEquals(this.cond, ast.cond, includingPosition);
        };
        return DoStatement;
    })(Statement);
    TypeScript.DoStatement = DoStatement;

    var IfStatement = (function (_super) {
        __extends(IfStatement, _super);
        function IfStatement(cond, thenBod, elseBod) {
            _super.call(this, 91 /* IfStatement */);
            this.cond = cond;
            this.thenBod = thenBod;
            this.elseBod = elseBod;
            this.statement = new ASTSpan();
        }
        IfStatement.prototype.emitWorker = function (emitter) {
            emitter.recordSourceMappingStart(this.statement);
            emitter.writeToOutput("if (");
            this.cond.emit(emitter);
            emitter.writeToOutput(")");
            emitter.recordSourceMappingEnd(this.statement);

            emitter.emitBlockOrStatement(this.thenBod);

            if (this.elseBod) {
                if (this.elseBod.nodeType === 91 /* IfStatement */) {
                    emitter.writeToOutput(" else ");
                    this.elseBod.emit(emitter);
                } else {
                    emitter.writeToOutput(" else");
                    emitter.emitBlockOrStatement(this.elseBod);
                }
            }
        };

        IfStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.cond, ast.cond, includingPosition) && structuralEquals(this.thenBod, ast.thenBod, includingPosition) && structuralEquals(this.elseBod, ast.elseBod, includingPosition);
        };
        return IfStatement;
    })(Statement);
    TypeScript.IfStatement = IfStatement;

    var ReturnStatement = (function (_super) {
        __extends(ReturnStatement, _super);
        function ReturnStatement(returnExpression) {
            _super.call(this, 93 /* ReturnStatement */);
            this.returnExpression = returnExpression;
        }
        ReturnStatement.prototype.emitWorker = function (emitter) {
            if (this.returnExpression) {
                emitter.writeToOutput("return ");
                this.returnExpression.emit(emitter);
                emitter.writeToOutput(";");
            } else {
                emitter.writeToOutput("return;");
            }
        };

        ReturnStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.returnExpression, ast.returnExpression, includingPosition);
        };
        return ReturnStatement;
    })(Statement);
    TypeScript.ReturnStatement = ReturnStatement;

    var ForInStatement = (function (_super) {
        __extends(ForInStatement, _super);
        function ForInStatement(lval, obj, body) {
            _super.call(this, 89 /* ForInStatement */);
            this.lval = lval;
            this.obj = obj;
            this.body = body;
            this.statement = new ASTSpan();
        }
        ForInStatement.prototype.emitWorker = function (emitter) {
            emitter.recordSourceMappingStart(this.statement);
            emitter.writeToOutput("for (");
            this.lval.emit(emitter);
            emitter.writeToOutput(" in ");
            this.obj.emit(emitter);
            emitter.writeToOutput(")");
            emitter.recordSourceMappingEnd(this.statement);
            emitter.emitBlockOrStatement(this.body);
        };

        ForInStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.lval, ast.lval, includingPosition) && structuralEquals(this.obj, ast.obj, includingPosition) && structuralEquals(this.body, ast.body, includingPosition);
        };
        return ForInStatement;
    })(Statement);
    TypeScript.ForInStatement = ForInStatement;

    var ForStatement = (function (_super) {
        __extends(ForStatement, _super);
        function ForStatement(init, cond, incr, body) {
            _super.call(this, 90 /* ForStatement */);
            this.init = init;
            this.cond = cond;
            this.incr = incr;
            this.body = body;
        }
        ForStatement.prototype.emitWorker = function (emitter) {
            emitter.writeToOutput("for (");
            if (this.init) {
                if (this.init.nodeType !== 1 /* List */) {
                    this.init.emit(emitter);
                } else {
                    emitter.setInVarBlock((this.init).members.length);
                    emitter.emitCommaSeparatedList(this.init);
                }
            }

            emitter.writeToOutput("; ");
            emitter.emitJavascript(this.cond, false);
            emitter.writeToOutput("; ");
            emitter.emitJavascript(this.incr, false);
            emitter.writeToOutput(")");
            emitter.emitBlockOrStatement(this.body);
        };

        ForStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.init, ast.init, includingPosition) && structuralEquals(this.cond, ast.cond, includingPosition) && structuralEquals(this.incr, ast.incr, includingPosition) && structuralEquals(this.body, ast.body, includingPosition);
        };
        return ForStatement;
    })(Statement);
    TypeScript.ForStatement = ForStatement;

    var WithStatement = (function (_super) {
        __extends(WithStatement, _super);
        function WithStatement(expr, body) {
            _super.call(this, 99 /* WithStatement */);
            this.expr = expr;
            this.body = body;
        }
        WithStatement.prototype.emitWorker = function (emitter) {
            emitter.writeToOutput("with (");
            if (this.expr) {
                this.expr.emit(emitter);
            }

            emitter.writeToOutput(")");
            emitter.emitBlockOrStatement(this.body);
        };

        WithStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.expr, ast.expr, includingPosition) && structuralEquals(this.body, ast.body, includingPosition);
        };
        return WithStatement;
    })(Statement);
    TypeScript.WithStatement = WithStatement;

    var SwitchStatement = (function (_super) {
        __extends(SwitchStatement, _super);
        function SwitchStatement(val) {
            _super.call(this, 94 /* SwitchStatement */);
            this.val = val;
            this.defaultCase = null;
            this.statement = new ASTSpan();
        }
        SwitchStatement.prototype.emitWorker = function (emitter) {
            emitter.recordSourceMappingStart(this.statement);
            emitter.writeToOutput("switch (");
            this.val.emit(emitter);
            emitter.writeToOutput(")");
            emitter.recordSourceMappingEnd(this.statement);
            emitter.writeLineToOutput(" {");
            emitter.indenter.increaseIndent();

            var lastEmittedNode = null;
            for (var i = 0, n = this.caseList.members.length; i < n; i++) {
                var caseExpr = this.caseList.members[i];

                emitter.emitSpaceBetweenConstructs(lastEmittedNode, caseExpr);
                emitter.emitJavascript(caseExpr, true);

                lastEmittedNode = caseExpr;
            }
            emitter.indenter.decreaseIndent();
            emitter.emitIndent();
            emitter.writeToOutput("}");
        };

        SwitchStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.caseList, ast.caseList, includingPosition) && structuralEquals(this.val, ast.val, includingPosition);
        };
        return SwitchStatement;
    })(Statement);
    TypeScript.SwitchStatement = SwitchStatement;

    var CaseClause = (function (_super) {
        __extends(CaseClause, _super);
        function CaseClause() {
            _super.call(this, 100 /* CaseClause */);
            this.expr = null;
            this.colonSpan = new ASTSpan();
        }
        CaseClause.prototype.emitWorker = function (emitter) {
            if (this.expr) {
                emitter.writeToOutput("case ");
                this.expr.emit(emitter);
            } else {
                emitter.writeToOutput("default");
            }
            emitter.recordSourceMappingStart(this.colonSpan);
            emitter.writeToOutput(":");
            emitter.recordSourceMappingEnd(this.colonSpan);

            if (this.body.members.length === 1 && this.body.members[0].nodeType === 81 /* Block */) {
                this.body.members[0].emit(emitter);
                emitter.writeLineToOutput("");
            } else {
                emitter.writeLineToOutput("");
                emitter.indenter.increaseIndent();
                this.body.emit(emitter);
                emitter.indenter.decreaseIndent();
            }
        };

        CaseClause.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.expr, ast.expr, includingPosition) && structuralEquals(this.body, ast.body, includingPosition);
        };
        return CaseClause;
    })(AST);
    TypeScript.CaseClause = CaseClause;

    var TypeParameter = (function (_super) {
        __extends(TypeParameter, _super);
        function TypeParameter(name, constraint) {
            _super.call(this, 9 /* TypeParameter */);
            this.name = name;
            this.constraint = constraint;
        }
        TypeParameter.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.name, ast.name, includingPosition) && structuralEquals(this.constraint, ast.constraint, includingPosition);
        };
        return TypeParameter;
    })(AST);
    TypeScript.TypeParameter = TypeParameter;

    var GenericType = (function (_super) {
        __extends(GenericType, _super);
        function GenericType(name, typeArguments) {
            _super.call(this, 10 /* GenericType */);
            this.name = name;
            this.typeArguments = typeArguments;
        }
        GenericType.prototype.emit = function (emitter) {
            this.name.emit(emitter);
        };

        GenericType.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.name, ast.name, includingPosition) && structuralEquals(this.typeArguments, ast.typeArguments, includingPosition);
        };
        return GenericType;
    })(AST);
    TypeScript.GenericType = GenericType;

    var TypeReference = (function (_super) {
        __extends(TypeReference, _super);
        function TypeReference(term, arrayCount) {
            _super.call(this, 11 /* TypeRef */);
            this.term = term;
            this.arrayCount = arrayCount;
        }
        TypeReference.prototype.emit = function (emitter) {
            throw new Error("should not emit a type ref");
        };

        TypeReference.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.term, ast.term, includingPosition) && this.arrayCount === ast.arrayCount;
        };
        return TypeReference;
    })(AST);
    TypeScript.TypeReference = TypeReference;

    var TryStatement = (function (_super) {
        __extends(TryStatement, _super);
        function TryStatement(tryBody, catchClause, finallyBody) {
            _super.call(this, 96 /* TryStatement */);
            this.tryBody = tryBody;
            this.catchClause = catchClause;
            this.finallyBody = finallyBody;
        }
        TryStatement.prototype.emitWorker = function (emitter) {
            emitter.writeToOutput("try ");
            this.tryBody.emit(emitter);
            emitter.emitJavascript(this.catchClause, false);

            if (this.finallyBody) {
                emitter.writeToOutput(" finally");
                this.finallyBody.emit(emitter);
            }
        };

        TryStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.tryBody, ast.tryBody, includingPosition) && structuralEquals(this.catchClause, ast.catchClause, includingPosition) && structuralEquals(this.finallyBody, ast.finallyBody, includingPosition);
        };
        return TryStatement;
    })(Statement);
    TypeScript.TryStatement = TryStatement;

    var CatchClause = (function (_super) {
        __extends(CatchClause, _super);
        function CatchClause(param, body) {
            _super.call(this, 101 /* CatchClause */);
            this.param = param;
            this.body = body;
            this.statement = new ASTSpan();
        }
        CatchClause.prototype.emitWorker = function (emitter) {
            emitter.writeToOutput(" ");
            emitter.recordSourceMappingStart(this.statement);
            emitter.writeToOutput("catch (");
            this.param.id.emit(emitter);
            emitter.writeToOutput(")");
            emitter.recordSourceMappingEnd(this.statement);
            this.body.emit(emitter);
        };

        CatchClause.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.param, ast.param, includingPosition) && structuralEquals(this.body, ast.body, includingPosition);
        };
        return CatchClause;
    })(AST);
    TypeScript.CatchClause = CatchClause;

    var DebuggerStatement = (function (_super) {
        __extends(DebuggerStatement, _super);
        function DebuggerStatement() {
            _super.call(this, 84 /* DebuggerStatement */);
        }
        DebuggerStatement.prototype.emitWorker = function (emitter) {
            emitter.writeToOutput("debugger;");
        };
        return DebuggerStatement;
    })(Statement);
    TypeScript.DebuggerStatement = DebuggerStatement;

    var OmittedExpression = (function (_super) {
        __extends(OmittedExpression, _super);
        function OmittedExpression() {
            _super.call(this, 23 /* OmittedExpression */);
        }
        OmittedExpression.prototype.emitWorker = function (emitter) {
        };

        OmittedExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition);
        };
        return OmittedExpression;
    })(Expression);
    TypeScript.OmittedExpression = OmittedExpression;

    var EmptyStatement = (function (_super) {
        __extends(EmptyStatement, _super);
        function EmptyStatement() {
            _super.call(this, 86 /* EmptyStatement */);
        }
        EmptyStatement.prototype.emitWorker = function (emitter) {
            emitter.writeToOutput(";");
        };

        EmptyStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition);
        };
        return EmptyStatement;
    })(Statement);
    TypeScript.EmptyStatement = EmptyStatement;

    var Comment = (function (_super) {
        __extends(Comment, _super);
        function Comment(content, isBlockComment, endsLine) {
            _super.call(this, 102 /* Comment */);
            this.content = content;
            this.isBlockComment = isBlockComment;
            this.endsLine = endsLine;
            this.text = null;
            this.docCommentText = null;
        }
        Comment.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this.minLine === ast.minLine && this.content === ast.content && this.isBlockComment === ast.isBlockComment && this.endsLine === ast.endsLine;
        };

        Comment.prototype.getText = function () {
            if (this.text === null) {
                if (this.isBlockComment) {
                    this.text = this.content.split("\n");
                    for (var i = 0; i < this.text.length; i++) {
                        this.text[i] = this.text[i].replace(/^\s+|\s+$/g, '');
                    }
                } else {
                    this.text = [(this.content.replace(/^\s+|\s+$/g, ''))];
                }
            }

            return this.text;
        };

        Comment.prototype.isDocComment = function () {
            if (this.isBlockComment) {
                return this.content.charAt(2) === "*" && this.content.charAt(3) !== "/";
            }

            return false;
        };

        Comment.prototype.getDocCommentTextValue = function () {
            if (this.docCommentText === null) {
                this.docCommentText = Comment.cleanJSDocComment(this.content);
            }

            return this.docCommentText;
        };

        Comment.consumeLeadingSpace = function (line, startIndex, maxSpacesToRemove) {
            var endIndex = line.length;
            if (maxSpacesToRemove !== undefined) {
                endIndex = TypeScript.min(startIndex + maxSpacesToRemove, endIndex);
            }

            for (; startIndex < endIndex; startIndex++) {
                var charCode = line.charCodeAt(startIndex);
                if (charCode !== 32 /* space */ && charCode !== 9 /* tab */) {
                    return startIndex;
                }
            }

            if (endIndex !== line.length) {
                return endIndex;
            }

            return -1;
        };

        Comment.isSpaceChar = function (line, index) {
            var length = line.length;
            if (index < length) {
                var charCode = line.charCodeAt(index);

                return charCode === 32 /* space */ || charCode === 9 /* tab */;
            }

            return index === length;
        };

        Comment.cleanDocCommentLine = function (line, jsDocStyleComment, jsDocLineSpaceToRemove) {
            var nonSpaceIndex = Comment.consumeLeadingSpace(line, 0);
            if (nonSpaceIndex !== -1) {
                var jsDocSpacesRemoved = nonSpaceIndex;
                if (jsDocStyleComment && line.charAt(nonSpaceIndex) === '*') {
                    var startIndex = nonSpaceIndex + 1;
                    nonSpaceIndex = Comment.consumeLeadingSpace(line, startIndex, jsDocLineSpaceToRemove);

                    if (nonSpaceIndex !== -1) {
                        jsDocSpacesRemoved = nonSpaceIndex - startIndex;
                    } else {
                        return null;
                    }
                }

                return {
                    minChar: nonSpaceIndex,
                    limChar: line.charAt(line.length - 1) === "\r" ? line.length - 1 : line.length,
                    jsDocSpacesRemoved: jsDocSpacesRemoved
                };
            }

            return null;
        };

        Comment.cleanJSDocComment = function (content, spacesToRemove) {
            var docCommentLines = [];
            content = content.replace("/**", "");
            if (content.length >= 2 && content.charAt(content.length - 1) === "/" && content.charAt(content.length - 2) === "*") {
                content = content.substring(0, content.length - 2);
            }
            var lines = content.split("\n");
            var inParamTag = false;
            for (var l = 0; l < lines.length; l++) {
                var line = lines[l];
                var cleanLinePos = Comment.cleanDocCommentLine(line, true, spacesToRemove);
                if (!cleanLinePos) {
                    continue;
                }

                var docCommentText = "";
                var prevPos = cleanLinePos.minChar;
                for (var i = line.indexOf("@", cleanLinePos.minChar); 0 <= i && i < cleanLinePos.limChar; i = line.indexOf("@", i + 1)) {
                    var wasInParamtag = inParamTag;

                    if (line.indexOf("param", i + 1) === i + 1 && Comment.isSpaceChar(line, i + 6)) {
                        if (!wasInParamtag) {
                            docCommentText += line.substring(prevPos, i);
                        }

                        prevPos = i;
                        inParamTag = true;
                    } else if (wasInParamtag) {
                        prevPos = i;
                        inParamTag = false;
                    }
                }

                if (!inParamTag) {
                    docCommentText += line.substring(prevPos, cleanLinePos.limChar);
                }

                var newCleanPos = Comment.cleanDocCommentLine(docCommentText, false);
                if (newCleanPos) {
                    if (spacesToRemove === undefined) {
                        spacesToRemove = cleanLinePos.jsDocSpacesRemoved;
                    }
                    docCommentLines.push(docCommentText);
                }
            }

            return docCommentLines.join("\n");
        };

        Comment.getDocCommentText = function (comments) {
            var docCommentText = [];
            for (var c = 0; c < comments.length; c++) {
                var commentText = comments[c].getDocCommentTextValue();
                if (commentText !== "") {
                    docCommentText.push(commentText);
                }
            }
            return docCommentText.join("\n");
        };

        Comment.getParameterDocCommentText = function (param, fncDocComments) {
            if (fncDocComments.length === 0 || !fncDocComments[0].isBlockComment) {
                return "";
            }

            for (var i = 0; i < fncDocComments.length; i++) {
                var commentContents = fncDocComments[i].content;
                for (var j = commentContents.indexOf("@param", 0); 0 <= j; j = commentContents.indexOf("@param", j)) {
                    j += 6;
                    if (!Comment.isSpaceChar(commentContents, j)) {
                        continue;
                    }

                    j = Comment.consumeLeadingSpace(commentContents, j);
                    if (j === -1) {
                        break;
                    }

                    if (commentContents.charCodeAt(j) === 123 /* openBrace */) {
                        j++;

                        var charCode = 0;
                        for (var curlies = 1; j < commentContents.length; j++) {
                            charCode = commentContents.charCodeAt(j);

                            if (charCode === 123 /* openBrace */) {
                                curlies++;
                                continue;
                            }

                            if (charCode === 125 /* closeBrace */) {
                                curlies--;
                                if (curlies === 0) {
                                    break;
                                } else {
                                    continue;
                                }
                            }

                            if (charCode === 64 /* at */) {
                                break;
                            }
                        }

                        if (j === commentContents.length) {
                            break;
                        }

                        if (charCode === 64 /* at */) {
                            continue;
                        }

                        j = Comment.consumeLeadingSpace(commentContents, j + 1);
                        if (j === -1) {
                            break;
                        }
                    }

                    if (param !== commentContents.substr(j, param.length) || !Comment.isSpaceChar(commentContents, j + param.length)) {
                        continue;
                    }

                    j = Comment.consumeLeadingSpace(commentContents, j + param.length);
                    if (j === -1) {
                        return "";
                    }

                    var endOfParam = commentContents.indexOf("@", j);
                    var paramHelpString = commentContents.substring(j, endOfParam < 0 ? commentContents.length : endOfParam);

                    var paramSpacesToRemove = undefined;
                    var paramLineIndex = commentContents.substring(0, j).lastIndexOf("\n") + 1;
                    if (paramLineIndex !== 0) {
                        if (paramLineIndex < j && commentContents.charAt(paramLineIndex + 1) === "\r") {
                            paramLineIndex++;
                        }
                    }
                    var startSpaceRemovalIndex = Comment.consumeLeadingSpace(commentContents, paramLineIndex);
                    if (startSpaceRemovalIndex !== j && commentContents.charAt(startSpaceRemovalIndex) === "*") {
                        paramSpacesToRemove = j - startSpaceRemovalIndex - 1;
                    }

                    return Comment.cleanJSDocComment(paramHelpString, paramSpacesToRemove);
                }
            }

            return "";
        };
        return Comment;
    })(AST);
    TypeScript.Comment = Comment;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var AstWalkOptions = (function () {
        function AstWalkOptions() {
            this.goChildren = true;
        }
        return AstWalkOptions;
    })();
    TypeScript.AstWalkOptions = AstWalkOptions;

    var AstWalker = (function () {
        function AstWalker(childrenWalkers, pre, post, options, state) {
            this.childrenWalkers = childrenWalkers;
            this.pre = pre;
            this.post = post;
            this.options = options;
            this.state = state;
        }
        AstWalker.prototype.walk = function (ast, parent) {
            var preAst = this.pre(ast, parent, this);
            if (preAst === undefined) {
                preAst = ast;
            }
            if (this.options.goChildren) {
                this.childrenWalkers[ast.nodeType](ast, parent, this);
            } else {
                this.options.goChildren = true;
            }

            if (this.post) {
                var postAst = this.post(preAst, parent, this);
                if (postAst === undefined) {
                    postAst = preAst;
                }
                return postAst;
            } else {
                return preAst;
            }
        };
        return AstWalker;
    })();

    var AstWalkerFactory = (function () {
        function AstWalkerFactory() {
            this.childrenWalkers = [];
            this.initChildrenWalkers();
        }
        AstWalkerFactory.prototype.walk = function (ast, pre, post, options, state) {
            return this.getWalker(pre, post, options, state).walk(ast, null);
        };

        AstWalkerFactory.prototype.getWalker = function (pre, post, options, state) {
            return this.getSlowWalker(pre, post, options, state);
        };

        AstWalkerFactory.prototype.getSlowWalker = function (pre, post, options, state) {
            if (!options) {
                options = new AstWalkOptions();
            }

            return new AstWalker(this.childrenWalkers, pre, post, options, state);
        };

        AstWalkerFactory.prototype.initChildrenWalkers = function () {
            this.childrenWalkers[0 /* None */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[86 /* EmptyStatement */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[23 /* OmittedExpression */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[3 /* TrueLiteral */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[4 /* FalseLiteral */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[29 /* ThisExpression */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[30 /* SuperExpression */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[5 /* StringLiteral */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[6 /* RegularExpressionLiteral */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[8 /* NullLiteral */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[21 /* ArrayLiteralExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[22 /* ObjectLiteralExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[24 /* VoidExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[25 /* CommaExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[26 /* PlusExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[27 /* NegateExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[28 /* DeleteExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[31 /* InExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[32 /* MemberAccessExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[33 /* InstanceOfExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[34 /* TypeOfExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[7 /* NumericLiteral */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[20 /* Name */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[9 /* TypeParameter */] = ChildrenWalkers.walkTypeParameterChildren;
            this.childrenWalkers[10 /* GenericType */] = ChildrenWalkers.walkGenericTypeChildren;
            this.childrenWalkers[11 /* TypeRef */] = ChildrenWalkers.walkTypeReferenceChildren;
            this.childrenWalkers[35 /* ElementAccessExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[36 /* InvocationExpression */] = ChildrenWalkers.walkCallExpressionChildren;
            this.childrenWalkers[37 /* ObjectCreationExpression */] = ChildrenWalkers.walkCallExpressionChildren;
            this.childrenWalkers[38 /* AssignmentExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[39 /* AddAssignmentExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[40 /* SubtractAssignmentExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[41 /* DivideAssignmentExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[42 /* MultiplyAssignmentExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[43 /* ModuloAssignmentExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[44 /* AndAssignmentExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[45 /* ExclusiveOrAssignmentExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[46 /* OrAssignmentExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[47 /* LeftShiftAssignmentExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[48 /* SignedRightShiftAssignmentExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[49 /* UnsignedRightShiftAssignmentExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[50 /* ConditionalExpression */] = ChildrenWalkers.walkTrinaryExpressionChildren;
            this.childrenWalkers[51 /* LogicalOrExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[52 /* LogicalAndExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[53 /* BitwiseOrExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[54 /* BitwiseExclusiveOrExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[55 /* BitwiseAndExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[56 /* EqualsWithTypeConversionExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[57 /* NotEqualsWithTypeConversionExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[58 /* EqualsExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[59 /* NotEqualsExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[60 /* LessThanExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[61 /* LessThanOrEqualExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[62 /* GreaterThanExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[63 /* GreaterThanOrEqualExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[64 /* AddExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[65 /* SubtractExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[66 /* MultiplyExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[67 /* DivideExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[68 /* ModuloExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[69 /* LeftShiftExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[70 /* SignedRightShiftExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[71 /* UnsignedRightShiftExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[72 /* BitwiseNotExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[73 /* LogicalNotExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[74 /* PreIncrementExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[75 /* PreDecrementExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[76 /* PostIncrementExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[77 /* PostDecrementExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[78 /* CastExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[79 /* ParenthesizedExpression */] = ChildrenWalkers.walkParenthesizedExpressionChildren;
            this.childrenWalkers[12 /* FunctionDeclaration */] = ChildrenWalkers.walkFuncDeclChildren;
            this.childrenWalkers[80 /* Member */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[17 /* VariableDeclarator */] = ChildrenWalkers.walkBoundDeclChildren;
            this.childrenWalkers[18 /* VariableDeclaration */] = ChildrenWalkers.walkVariableDeclarationChildren;
            this.childrenWalkers[19 /* Parameter */] = ChildrenWalkers.walkBoundDeclChildren;
            this.childrenWalkers[93 /* ReturnStatement */] = ChildrenWalkers.walkReturnStatementChildren;
            this.childrenWalkers[82 /* BreakStatement */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[83 /* ContinueStatement */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[95 /* ThrowStatement */] = ChildrenWalkers.walkThrowStatementChildren;
            this.childrenWalkers[90 /* ForStatement */] = ChildrenWalkers.walkForStatementChildren;
            this.childrenWalkers[89 /* ForInStatement */] = ChildrenWalkers.walkForInStatementChildren;
            this.childrenWalkers[91 /* IfStatement */] = ChildrenWalkers.walkIfStatementChildren;
            this.childrenWalkers[98 /* WhileStatement */] = ChildrenWalkers.walkWhileStatementChildren;
            this.childrenWalkers[85 /* DoStatement */] = ChildrenWalkers.walkDoStatementChildren;
            this.childrenWalkers[81 /* Block */] = ChildrenWalkers.walkBlockChildren;
            this.childrenWalkers[100 /* CaseClause */] = ChildrenWalkers.walkCaseClauseChildren;
            this.childrenWalkers[94 /* SwitchStatement */] = ChildrenWalkers.walkSwitchStatementChildren;
            this.childrenWalkers[96 /* TryStatement */] = ChildrenWalkers.walkTryStatementChildren;
            this.childrenWalkers[101 /* CatchClause */] = ChildrenWalkers.walkCatchClauseChildren;
            this.childrenWalkers[1 /* List */] = ChildrenWalkers.walkListChildren;
            this.childrenWalkers[2 /* Script */] = ChildrenWalkers.walkScriptChildren;
            this.childrenWalkers[13 /* ClassDeclaration */] = ChildrenWalkers.walkClassDeclChildren;
            this.childrenWalkers[14 /* InterfaceDeclaration */] = ChildrenWalkers.walkTypeDeclChildren;
            this.childrenWalkers[15 /* ModuleDeclaration */] = ChildrenWalkers.walkModuleDeclChildren;
            this.childrenWalkers[16 /* ImportDeclaration */] = ChildrenWalkers.walkImportDeclChildren;
            this.childrenWalkers[87 /* ExportAssignment */] = ChildrenWalkers.walkExportAssignmentChildren;
            this.childrenWalkers[99 /* WithStatement */] = ChildrenWalkers.walkWithStatementChildren;
            this.childrenWalkers[88 /* ExpressionStatement */] = ChildrenWalkers.walkExpressionStatementChildren;
            this.childrenWalkers[92 /* LabeledStatement */] = ChildrenWalkers.walkLabeledStatementChildren;
            this.childrenWalkers[97 /* VariableStatement */] = ChildrenWalkers.walkVariableStatementChildren;
            this.childrenWalkers[102 /* Comment */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[84 /* DebuggerStatement */] = ChildrenWalkers.walkNone;

            for (var e in TypeScript.NodeType) {
                if (TypeScript.NodeType.hasOwnProperty(e) && TypeScript.StringUtilities.isString(TypeScript.NodeType[e])) {
                    if (this.childrenWalkers[e] === undefined) {
                        throw new Error("initWalkers function is not up to date with enum content!");
                    }
                }
            }
        };
        return AstWalkerFactory;
    })();
    TypeScript.AstWalkerFactory = AstWalkerFactory;

    var globalAstWalkerFactory;

    function getAstWalkerFactory() {
        if (!globalAstWalkerFactory) {
            globalAstWalkerFactory = new AstWalkerFactory();
        }
        return globalAstWalkerFactory;
    }
    TypeScript.getAstWalkerFactory = getAstWalkerFactory;

    var ChildrenWalkers;
    (function (ChildrenWalkers) {
        function walkNone(preAst, parent, walker) {
        }
        ChildrenWalkers.walkNone = walkNone;

        function walkListChildren(preAst, parent, walker) {
            var len = preAst.members.length;

            for (var i = 0; i < len; i++) {
                preAst.members[i] = walker.walk(preAst.members[i], preAst);
            }
        }
        ChildrenWalkers.walkListChildren = walkListChildren;

        function walkThrowStatementChildren(preAst, parent, walker) {
            if (preAst.expression) {
                preAst.expression = walker.walk(preAst.expression, preAst);
            }
        }
        ChildrenWalkers.walkThrowStatementChildren = walkThrowStatementChildren;

        function walkUnaryExpressionChildren(preAst, parent, walker) {
            if (preAst.castTerm) {
                preAst.castTerm = walker.walk(preAst.castTerm, preAst);
            }
            if (preAst.operand) {
                preAst.operand = walker.walk(preAst.operand, preAst);
            }
        }
        ChildrenWalkers.walkUnaryExpressionChildren = walkUnaryExpressionChildren;

        function walkParenthesizedExpressionChildren(preAst, parent, walker) {
            if (preAst.expression) {
                preAst.expression = walker.walk(preAst.expression, preAst);
            }
        }
        ChildrenWalkers.walkParenthesizedExpressionChildren = walkParenthesizedExpressionChildren;

        function walkBinaryExpressionChildren(preAst, parent, walker) {
            if (preAst.operand1) {
                preAst.operand1 = walker.walk(preAst.operand1, preAst);
            }
            if (preAst.operand2) {
                preAst.operand2 = walker.walk(preAst.operand2, preAst);
            }
        }
        ChildrenWalkers.walkBinaryExpressionChildren = walkBinaryExpressionChildren;

        function walkTypeParameterChildren(preAst, parent, walker) {
            if (preAst.name) {
                preAst.name = walker.walk(preAst.name, preAst);
            }

            if (preAst.constraint) {
                preAst.constraint = walker.walk(preAst.constraint, preAst);
            }
        }
        ChildrenWalkers.walkTypeParameterChildren = walkTypeParameterChildren;

        function walkGenericTypeChildren(preAst, parent, walker) {
            if (preAst.name) {
                preAst.name = walker.walk(preAst.name, preAst);
            }

            if (preAst.typeArguments) {
                preAst.typeArguments = walker.walk(preAst.typeArguments, preAst);
            }
        }
        ChildrenWalkers.walkGenericTypeChildren = walkGenericTypeChildren;

        function walkTypeReferenceChildren(preAst, parent, walker) {
            if (preAst.term) {
                preAst.term = walker.walk(preAst.term, preAst);
            }
        }
        ChildrenWalkers.walkTypeReferenceChildren = walkTypeReferenceChildren;

        function walkCallExpressionChildren(preAst, parent, walker) {
            preAst.target = walker.walk(preAst.target, preAst);

            if (preAst.typeArguments) {
                preAst.typeArguments = walker.walk(preAst.typeArguments, preAst);
            }

            if (preAst.arguments) {
                preAst.arguments = walker.walk(preAst.arguments, preAst);
            }
        }
        ChildrenWalkers.walkCallExpressionChildren = walkCallExpressionChildren;

        function walkTrinaryExpressionChildren(preAst, parent, walker) {
            if (preAst.operand1) {
                preAst.operand1 = walker.walk(preAst.operand1, preAst);
            }
            if (preAst.operand2) {
                preAst.operand2 = walker.walk(preAst.operand2, preAst);
            }
            if (preAst.operand3) {
                preAst.operand3 = walker.walk(preAst.operand3, preAst);
            }
        }
        ChildrenWalkers.walkTrinaryExpressionChildren = walkTrinaryExpressionChildren;

        function walkFuncDeclChildren(preAst, parent, walker) {
            if (preAst.name) {
                preAst.name = walker.walk(preAst.name, preAst);
            }
            if (preAst.typeArguments) {
                preAst.typeArguments = walker.walk(preAst.typeArguments, preAst);
            }
            if (preAst.arguments) {
                preAst.arguments = walker.walk(preAst.arguments, preAst);
            }
            if (preAst.returnTypeAnnotation) {
                preAst.returnTypeAnnotation = walker.walk(preAst.returnTypeAnnotation, preAst);
            }
            if (preAst.block) {
                preAst.block = walker.walk(preAst.block, preAst);
            }
        }
        ChildrenWalkers.walkFuncDeclChildren = walkFuncDeclChildren;

        function walkBoundDeclChildren(preAst, parent, walker) {
            if (preAst.id) {
                preAst.id = walker.walk(preAst.id, preAst);
            }
            if (preAst.init) {
                preAst.init = walker.walk(preAst.init, preAst);
            }
            if (preAst.typeExpr) {
                preAst.typeExpr = walker.walk(preAst.typeExpr, preAst);
            }
        }
        ChildrenWalkers.walkBoundDeclChildren = walkBoundDeclChildren;

        function walkReturnStatementChildren(preAst, parent, walker) {
            if (preAst.returnExpression) {
                preAst.returnExpression = walker.walk(preAst.returnExpression, preAst);
            }
        }
        ChildrenWalkers.walkReturnStatementChildren = walkReturnStatementChildren;

        function walkForStatementChildren(preAst, parent, walker) {
            if (preAst.init) {
                preAst.init = walker.walk(preAst.init, preAst);
            }

            if (preAst.cond) {
                preAst.cond = walker.walk(preAst.cond, preAst);
            }

            if (preAst.incr) {
                preAst.incr = walker.walk(preAst.incr, preAst);
            }

            if (preAst.body) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }
        ChildrenWalkers.walkForStatementChildren = walkForStatementChildren;

        function walkForInStatementChildren(preAst, parent, walker) {
            preAst.lval = walker.walk(preAst.lval, preAst);
            preAst.obj = walker.walk(preAst.obj, preAst);

            if (preAst.body) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }
        ChildrenWalkers.walkForInStatementChildren = walkForInStatementChildren;

        function walkIfStatementChildren(preAst, parent, walker) {
            preAst.cond = walker.walk(preAst.cond, preAst);
            if (preAst.thenBod) {
                preAst.thenBod = walker.walk(preAst.thenBod, preAst);
            }
            if (preAst.elseBod) {
                preAst.elseBod = walker.walk(preAst.elseBod, preAst);
            }
        }
        ChildrenWalkers.walkIfStatementChildren = walkIfStatementChildren;

        function walkWhileStatementChildren(preAst, parent, walker) {
            preAst.cond = walker.walk(preAst.cond, preAst);
            if (preAst.body) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }
        ChildrenWalkers.walkWhileStatementChildren = walkWhileStatementChildren;

        function walkDoStatementChildren(preAst, parent, walker) {
            preAst.cond = walker.walk(preAst.cond, preAst);
            if (preAst.body) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }
        ChildrenWalkers.walkDoStatementChildren = walkDoStatementChildren;

        function walkBlockChildren(preAst, parent, walker) {
            if (preAst.statements) {
                preAst.statements = walker.walk(preAst.statements, preAst);
            }
        }
        ChildrenWalkers.walkBlockChildren = walkBlockChildren;

        function walkVariableDeclarationChildren(preAst, parent, walker) {
            if (preAst.declarators) {
                preAst.declarators = walker.walk(preAst.declarators, preAst);
            }
        }
        ChildrenWalkers.walkVariableDeclarationChildren = walkVariableDeclarationChildren;

        function walkCaseClauseChildren(preAst, parent, walker) {
            if (preAst.expr) {
                preAst.expr = walker.walk(preAst.expr, preAst);
            }

            if (preAst.body) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }
        ChildrenWalkers.walkCaseClauseChildren = walkCaseClauseChildren;

        function walkSwitchStatementChildren(preAst, parent, walker) {
            if (preAst.val) {
                preAst.val = walker.walk(preAst.val, preAst);
            }

            if (preAst.caseList) {
                preAst.caseList = walker.walk(preAst.caseList, preAst);
            }
        }
        ChildrenWalkers.walkSwitchStatementChildren = walkSwitchStatementChildren;

        function walkTryStatementChildren(preAst, parent, walker) {
            if (preAst.tryBody) {
                preAst.tryBody = walker.walk(preAst.tryBody, preAst);
            }
            if (preAst.catchClause) {
                preAst.catchClause = walker.walk(preAst.catchClause, preAst);
            }
            if (preAst.finallyBody) {
                preAst.finallyBody = walker.walk(preAst.finallyBody, preAst);
            }
        }
        ChildrenWalkers.walkTryStatementChildren = walkTryStatementChildren;

        function walkCatchClauseChildren(preAst, parent, walker) {
            if (preAst.param) {
                preAst.param = walker.walk(preAst.param, preAst);
            }

            if (preAst.body) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }
        ChildrenWalkers.walkCatchClauseChildren = walkCatchClauseChildren;

        function walkRecordChildren(preAst, parent, walker) {
            preAst.name = walker.walk(preAst.name, preAst);
            if (preAst.members) {
                preAst.members = walker.walk(preAst.members, preAst);
            }
        }
        ChildrenWalkers.walkRecordChildren = walkRecordChildren;

        function walkNamedTypeChildren(preAst, parent, walker) {
            walkRecordChildren(preAst, parent, walker);
        }
        ChildrenWalkers.walkNamedTypeChildren = walkNamedTypeChildren;

        function walkClassDeclChildren(preAst, parent, walker) {
            walkNamedTypeChildren(preAst, parent, walker);

            if (preAst.typeParameters) {
                preAst.typeParameters = walker.walk(preAst.typeParameters, preAst);
            }

            if (preAst.extendsList) {
                preAst.extendsList = walker.walk(preAst.extendsList, preAst);
            }

            if (preAst.implementsList) {
                preAst.implementsList = walker.walk(preAst.implementsList, preAst);
            }
        }
        ChildrenWalkers.walkClassDeclChildren = walkClassDeclChildren;

        function walkScriptChildren(preAst, parent, walker) {
            if (preAst.moduleElements) {
                preAst.moduleElements = walker.walk(preAst.moduleElements, preAst);
            }
        }
        ChildrenWalkers.walkScriptChildren = walkScriptChildren;

        function walkTypeDeclChildren(preAst, parent, walker) {
            walkNamedTypeChildren(preAst, parent, walker);

            if (preAst.typeParameters) {
                preAst.typeParameters = walker.walk(preAst.typeParameters, preAst);
            }

            if (preAst.extendsList) {
                preAst.extendsList = walker.walk(preAst.extendsList, preAst);
            }

            if (preAst.implementsList) {
                preAst.implementsList = walker.walk(preAst.implementsList, preAst);
            }
        }
        ChildrenWalkers.walkTypeDeclChildren = walkTypeDeclChildren;

        function walkModuleDeclChildren(preAst, parent, walker) {
            walkRecordChildren(preAst, parent, walker);
        }
        ChildrenWalkers.walkModuleDeclChildren = walkModuleDeclChildren;

        function walkImportDeclChildren(preAst, parent, walker) {
            if (preAst.id) {
                preAst.id = walker.walk(preAst.id, preAst);
            }
            if (preAst.alias) {
                preAst.alias = walker.walk(preAst.alias, preAst);
            }
        }
        ChildrenWalkers.walkImportDeclChildren = walkImportDeclChildren;

        function walkExportAssignmentChildren(preAst, parent, walker) {
            if (preAst.id) {
                preAst.id = walker.walk(preAst.id, preAst);
            }
        }
        ChildrenWalkers.walkExportAssignmentChildren = walkExportAssignmentChildren;

        function walkWithStatementChildren(preAst, parent, walker) {
            if (preAst.expr) {
                preAst.expr = walker.walk(preAst.expr, preAst);
            }

            if (preAst.body) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }
        ChildrenWalkers.walkWithStatementChildren = walkWithStatementChildren;

        function walkExpressionStatementChildren(preAst, parent, walker) {
            preAst.expression = walker.walk(preAst.expression, preAst);
        }
        ChildrenWalkers.walkExpressionStatementChildren = walkExpressionStatementChildren;

        function walkLabeledStatementChildren(preAst, parent, walker) {
            preAst.identifier = walker.walk(preAst.identifier, preAst);
            preAst.statement = walker.walk(preAst.statement, preAst);
        }
        ChildrenWalkers.walkLabeledStatementChildren = walkLabeledStatementChildren;

        function walkVariableStatementChildren(preAst, parent, walker) {
            preAst.declaration = walker.walk(preAst.declaration, preAst);
        }
        ChildrenWalkers.walkVariableStatementChildren = walkVariableStatementChildren;
    })(ChildrenWalkers || (ChildrenWalkers = {}));
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (AstWalkerWithDetailCallback) {
        function walk(script, callback) {
            var pre = function (cur, parent) {
                walker.options.goChildren = AstWalkerCallback(true, cur, callback);
                return cur;
            };

            var post = function (cur, parent) {
                AstWalkerCallback(false, cur, callback);
                return cur;
            };

            var walker = TypeScript.getAstWalkerFactory().getWalker(pre, post);
            walker.walk(script, null);
        }
        AstWalkerWithDetailCallback.walk = walk;

        function AstWalkerCallback(pre, ast, callback) {
            var nodeType = ast.nodeType;
            var callbackString = TypeScript.NodeType[nodeType] + "Callback";
            if (callback[callbackString]) {
                return callback[callbackString](pre, ast);
            }

            if (callback.DefaultCallback) {
                return callback.DefaultCallback(pre, ast);
            }

            return true;
        }
    })(TypeScript.AstWalkerWithDetailCallback || (TypeScript.AstWalkerWithDetailCallback = {}));
    var AstWalkerWithDetailCallback = TypeScript.AstWalkerWithDetailCallback;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    function max(a, b) {
        return a >= b ? a : b;
    }
    TypeScript.max = max;

    function min(a, b) {
        return a <= b ? a : b;
    }
    TypeScript.min = min;

    var AstPath = (function () {
        function AstPath() {
            this.asts = [];
            this.top = -1;
        }
        AstPath.reverseIndexOf = function (items, index) {
            return (items === null || items.length <= index) ? null : items[items.length - index - 1];
        };

        AstPath.prototype.clone = function () {
            var clone = new AstPath();
            clone.asts = this.asts.map(function (value) {
                return value;
            });
            clone.top = this.top;
            return clone;
        };

        AstPath.prototype.pop = function () {
            var head = this.ast();
            this.up();

            while (this.asts.length > this.count()) {
                this.asts.pop();
            }
            return head;
        };

        AstPath.prototype.push = function (ast) {
            while (this.asts.length > this.count()) {
                this.asts.pop();
            }
            this.top = this.asts.length;
            this.asts.push(ast);
        };

        AstPath.prototype.up = function () {
            if (this.top <= -1)
                throw new Error("Invalid call to 'up'");
            this.top--;
        };

        AstPath.prototype.down = function () {
            if (this.top === this.ast.length - 1)
                throw new Error("Invalid call to 'down'");
            this.top++;
        };

        AstPath.prototype.nodeType = function () {
            if (this.ast() === null)
                return 0 /* None */;
            return this.ast().nodeType;
        };

        AstPath.prototype.ast = function () {
            return AstPath.reverseIndexOf(this.asts, this.asts.length - (this.top + 1));
        };

        AstPath.prototype.parent = function () {
            return AstPath.reverseIndexOf(this.asts, this.asts.length - this.top);
        };

        AstPath.prototype.count = function () {
            return this.top + 1;
        };

        AstPath.prototype.get = function (index) {
            return this.asts[index];
        };

        AstPath.prototype.isNameOfClass = function () {
            if (this.ast() === null || this.parent() === null)
                return false;

            return (this.ast().nodeType === 20 /* Name */) && (this.parent().nodeType === 13 /* ClassDeclaration */) && ((this.parent()).name === this.ast());
        };

        AstPath.prototype.isNameOfInterface = function () {
            if (this.ast() === null || this.parent() === null)
                return false;

            return (this.ast().nodeType === 20 /* Name */) && (this.parent().nodeType === 14 /* InterfaceDeclaration */) && ((this.parent()).name === this.ast());
        };

        AstPath.prototype.isNameOfArgument = function () {
            if (this.ast() === null || this.parent() === null)
                return false;

            return (this.ast().nodeType === 20 /* Name */) && (this.parent().nodeType === 19 /* Parameter */) && ((this.parent()).id === this.ast());
        };

        AstPath.prototype.isNameOfVariable = function () {
            if (this.ast() === null || this.parent() === null)
                return false;

            return (this.ast().nodeType === 20 /* Name */) && (this.parent().nodeType === 17 /* VariableDeclarator */) && ((this.parent()).id === this.ast());
        };

        AstPath.prototype.isNameOfModule = function () {
            if (this.ast() === null || this.parent() === null)
                return false;

            return (this.ast().nodeType === 20 /* Name */) && (this.parent().nodeType === 15 /* ModuleDeclaration */) && ((this.parent()).name === this.ast());
        };

        AstPath.prototype.isNameOfFunction = function () {
            if (this.ast() === null || this.parent() === null)
                return false;

            return (this.ast().nodeType === 20 /* Name */) && (this.parent().nodeType === 12 /* FunctionDeclaration */) && ((this.parent()).name === this.ast());
        };

        AstPath.prototype.isBodyOfFunction = function () {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === 12 /* FunctionDeclaration */ && (this.asts[this.top - 1]).block === this.asts[this.top - 0];
        };

        AstPath.prototype.isArgumentListOfFunction = function () {
            return this.count() >= 2 && this.asts[this.top - 0].nodeType === 1 /* List */ && this.asts[this.top - 1].nodeType === 12 /* FunctionDeclaration */ && (this.asts[this.top - 1]).arguments === this.asts[this.top - 0];
        };

        AstPath.prototype.isTargetOfCall = function () {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === 36 /* InvocationExpression */ && (this.asts[this.top - 1]).target === this.asts[this.top];
        };

        AstPath.prototype.isTargetOfNew = function () {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType === 37 /* ObjectCreationExpression */ && (this.asts[this.top - 1]).target === this.asts[this.top];
        };

        AstPath.prototype.isInClassImplementsList = function () {
            if (this.ast() === null || this.parent() === null)
                return false;

            return (this.parent().nodeType === 13 /* ClassDeclaration */) && (this.isMemberOfList((this.parent()).implementsList, this.ast()));
        };

        AstPath.prototype.isInInterfaceExtendsList = function () {
            if (this.ast() === null || this.parent() === null)
                return false;

            return (this.parent().nodeType === 14 /* InterfaceDeclaration */) && (this.isMemberOfList((this.parent()).extendsList, this.ast()));
        };

        AstPath.prototype.isMemberOfMemberAccessExpression = function () {
            if (this.count() > 1 && this.parent().nodeType === 32 /* MemberAccessExpression */ && (this.parent()).operand2 === this.asts[this.top]) {
                return true;
            }

            return false;
        };

        AstPath.prototype.isCallExpression = function () {
            return this.count() >= 1 && (this.asts[this.top - 0].nodeType === 36 /* InvocationExpression */ || this.asts[this.top - 0].nodeType === 37 /* ObjectCreationExpression */);
        };

        AstPath.prototype.isCallExpressionTarget = function () {
            if (this.count() < 2) {
                return false;
            }

            var current = this.top;

            var nodeType = this.asts[current].nodeType;
            if (nodeType === 29 /* ThisExpression */ || nodeType === 30 /* SuperExpression */ || nodeType === 20 /* Name */) {
                current--;
            }

            while (current >= 0) {
                if (current < this.top && this.asts[current].nodeType === 32 /* MemberAccessExpression */ && (this.asts[current]).operand2 === this.asts[current + 1]) {
                    current--;
                    continue;
                }

                break;
            }

            return current < this.top && (this.asts[current].nodeType === 36 /* InvocationExpression */ || this.asts[current].nodeType === 37 /* ObjectCreationExpression */) && this.asts[current + 1] === (this.asts[current]).target;
        };

        AstPath.prototype.isDeclaration = function () {
            if (this.ast() !== null) {
                switch (this.ast().nodeType) {
                    case 13 /* ClassDeclaration */:
                    case 14 /* InterfaceDeclaration */:
                    case 15 /* ModuleDeclaration */:
                    case 12 /* FunctionDeclaration */:
                    case 17 /* VariableDeclarator */:
                        return true;
                }
            }

            return false;
        };

        AstPath.prototype.isMemberOfList = function (list, item) {
            if (list && list.members) {
                for (var i = 0, n = list.members.length; i < n; i++) {
                    if (list.members[i] === item) {
                        return true;
                    }
                }
            }

            return false;
        };
        return AstPath;
    })();
    TypeScript.AstPath = AstPath;

    function isValidAstNode(ast) {
        if (ast === null)
            return false;

        if (ast.minChar === -1 || ast.limChar === -1)
            return false;

        return true;
    }
    TypeScript.isValidAstNode = isValidAstNode;

    var AstPathContext = (function () {
        function AstPathContext() {
            this.path = new TypeScript.AstPath();
        }
        return AstPathContext;
    })();
    TypeScript.AstPathContext = AstPathContext;

    (function (GetAstPathOptions) {
        GetAstPathOptions[GetAstPathOptions["Default"] = 0] = "Default";
        GetAstPathOptions[GetAstPathOptions["EdgeInclusive"] = 1] = "EdgeInclusive";

        GetAstPathOptions[GetAstPathOptions["DontPruneSearchBasedOnPosition"] = 1 << 1] = "DontPruneSearchBasedOnPosition";
    })(TypeScript.GetAstPathOptions || (TypeScript.GetAstPathOptions = {}));
    var GetAstPathOptions = TypeScript.GetAstPathOptions;

    function getAstPathToPosition(script, pos, useTrailingTriviaAsLimChar, options) {
        if (typeof useTrailingTriviaAsLimChar === "undefined") { useTrailingTriviaAsLimChar = true; }
        if (typeof options === "undefined") { options = 0 /* Default */; }
        var lookInComments = function (comments) {
            if (comments && comments.length > 0) {
                for (var i = 0; i < comments.length; i++) {
                    var minChar = comments[i].minChar;
                    var limChar = comments[i].limChar + (useTrailingTriviaAsLimChar ? comments[i].trailingTriviaWidth : 0);
                    if (!comments[i].isBlockComment) {
                        limChar++;
                    }
                    if (pos >= minChar && pos < limChar) {
                        ctx.path.push(comments[i]);
                    }
                }
            }
        };

        var pre = function (cur, parent, walker) {
            if (isValidAstNode(cur)) {
                var inclusive = TypeScript.hasFlag(options, 1 /* EdgeInclusive */) || cur.nodeType === 20 /* Name */ || cur.nodeType === 32 /* MemberAccessExpression */ || cur.nodeType === 11 /* TypeRef */ || pos === script.limChar + script.trailingTriviaWidth;

                var minChar = cur.minChar;
                var limChar = cur.limChar + (useTrailingTriviaAsLimChar ? cur.trailingTriviaWidth : 0) + (inclusive ? 1 : 0);
                if (pos >= minChar && pos < limChar) {
                    var previous = ctx.path.ast();
                    if (previous === null || (cur.minChar >= previous.minChar && (cur.limChar + (useTrailingTriviaAsLimChar ? cur.trailingTriviaWidth : 0)) <= (previous.limChar + (useTrailingTriviaAsLimChar ? previous.trailingTriviaWidth : 0)))) {
                        ctx.path.push(cur);
                    } else {
                    }
                }

                if (pos < limChar) {
                    lookInComments(cur.preComments);
                }
                if (pos >= minChar) {
                    lookInComments(cur.postComments);
                }

                if (!TypeScript.hasFlag(options, 2 /* DontPruneSearchBasedOnPosition */)) {
                    walker.options.goChildren = (minChar <= pos && pos <= limChar);
                }
            }
            return cur;
        };

        var ctx = new AstPathContext();
        TypeScript.getAstWalkerFactory().walk(script, pre, null, null, ctx);
        return ctx.path;
    }
    TypeScript.getAstPathToPosition = getAstPathToPosition;

    function walkAST(ast, callback) {
        var pre = function (cur, parent, walker) {
            var path = walker.state;
            path.push(cur);
            callback(path, walker);
            return cur;
        };
        var post = function (cur, parent, walker) {
            var path = walker.state;
            path.pop();
            return cur;
        };

        var path = new AstPath();
        TypeScript.getAstWalkerFactory().walk(ast, pre, post, null, path);
    }
    TypeScript.walkAST = walkAST;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Base64Format = (function () {
        function Base64Format() {
        }
        Base64Format.encode = function (inValue) {
            if (inValue < 64) {
                return Base64Format.encodedValues.charAt(inValue);
            }
            throw TypeError(inValue + ": not a 64 based value");
        };

        Base64Format.decodeChar = function (inChar) {
            if (inChar.length === 1) {
                return Base64Format.encodedValues.indexOf(inChar);
            } else {
                throw TypeError('"' + inChar + '" must have length 1');
            }
        };
        Base64Format.encodedValues = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        return Base64Format;
    })();

    var Base64VLQFormat = (function () {
        function Base64VLQFormat() {
        }
        Base64VLQFormat.encode = function (inValue) {
            if (inValue < 0) {
                inValue = ((-inValue) << 1) + 1;
            } else {
                inValue = inValue << 1;
            }

            var encodedStr = "";
            do {
                var currentDigit = inValue & 31;
                inValue = inValue >> 5;
                if (inValue > 0) {
                    currentDigit = currentDigit | 32;
                }
                encodedStr = encodedStr + Base64Format.encode(currentDigit);
            } while(inValue > 0);

            return encodedStr;
        };

        Base64VLQFormat.decode = function (inString) {
            var result = 0;
            var negative = false;

            var shift = 0;
            for (var i = 0; i < inString.length; i++) {
                var byte = Base64Format.decodeChar(inString[i]);
                if (i === 0) {
                    if ((byte & 1) === 1) {
                        negative = true;
                    }
                    result = (byte >> 1) & 15;
                } else {
                    result = result | ((byte & 31) << shift);
                }

                shift += (i === 0) ? 4 : 5;

                if ((byte & 32) === 32) {
                } else {
                    return { value: negative ? -(result) : result, rest: inString.substr(i + 1) };
                }
            }

            throw new Error('Base64 value "' + inString + '" finished with a continuation bit');
        };
        return Base64VLQFormat;
    })();
    TypeScript.Base64VLQFormat = Base64VLQFormat;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SourceMapPosition = (function () {
        function SourceMapPosition() {
        }
        return SourceMapPosition;
    })();
    TypeScript.SourceMapPosition = SourceMapPosition;

    var SourceMapping = (function () {
        function SourceMapping() {
            this.start = new SourceMapPosition();
            this.end = new SourceMapPosition();
            this.nameIndex = -1;
            this.childMappings = [];
        }
        return SourceMapping;
    })();
    TypeScript.SourceMapping = SourceMapping;

    var SourceMapper = (function () {
        function SourceMapper(tsFileName, jsFileName, sourceMapFileName, jsFile, sourceMapOut, emitFullPathOfSourceMap) {
            this.sourceMapFileName = sourceMapFileName;
            this.jsFile = jsFile;
            this.sourceMapOut = sourceMapOut;
            this.sourceMappings = [];
            this.currentMappings = [];
            this.names = [];
            this.currentNameIndex = [];
            this.currentMappings.push(this.sourceMappings);

            jsFileName = TypeScript.switchToForwardSlashes(jsFileName);
            this.jsFileName = TypeScript.getPrettyName(jsFileName, false, true);

            var removalIndex = jsFileName.lastIndexOf(this.jsFileName);
            var fixedPath = jsFileName.substring(0, removalIndex);

            if (emitFullPathOfSourceMap) {
                if (jsFileName.indexOf("://") === -1) {
                    jsFileName = "file:///" + jsFileName;
                }
                this.jsFileName = jsFileName;
            }

            this.tsFileName = TypeScript.getRelativePathToFixedPath(fixedPath, tsFileName);
        }
        SourceMapper.emitSourceMapping = function (allSourceMappers) {
            var sourceMapper = allSourceMappers[0];
            sourceMapper.jsFile.WriteLine("//@ sourceMappingURL=" + sourceMapper.jsFileName + SourceMapper.MapFileExtension);

            var sourceMapOut = sourceMapper.sourceMapOut;
            var mappingsString = "";
            var tsFiles = [];

            var prevEmittedColumn = 0;
            var prevEmittedLine = 0;
            var prevSourceColumn = 0;
            var prevSourceLine = 0;
            var prevSourceIndex = 0;
            var prevNameIndex = 0;
            var namesList = [];
            var namesCount = 0;
            var emitComma = false;

            var recordedPosition = null;
            for (var sourceMapperIndex = 0; sourceMapperIndex < allSourceMappers.length; sourceMapperIndex++) {
                sourceMapper = allSourceMappers[sourceMapperIndex];

                var currentSourceIndex = tsFiles.length;
                tsFiles.push(sourceMapper.tsFileName);

                if (sourceMapper.names.length > 0) {
                    namesList.push.apply(namesList, sourceMapper.names);
                }

                var recordSourceMapping = function (mappedPosition, nameIndex) {
                    if (recordedPosition !== null && recordedPosition.emittedColumn === mappedPosition.emittedColumn && recordedPosition.emittedLine === mappedPosition.emittedLine) {
                        return;
                    }

                    if (prevEmittedLine !== mappedPosition.emittedLine) {
                        while (prevEmittedLine < mappedPosition.emittedLine) {
                            prevEmittedColumn = 0;
                            mappingsString = mappingsString + ";";
                            prevEmittedLine++;
                        }
                        emitComma = false;
                    } else if (emitComma) {
                        mappingsString = mappingsString + ",";
                    }

                    mappingsString = mappingsString + TypeScript.Base64VLQFormat.encode(mappedPosition.emittedColumn - prevEmittedColumn);
                    prevEmittedColumn = mappedPosition.emittedColumn;

                    mappingsString = mappingsString + TypeScript.Base64VLQFormat.encode(currentSourceIndex - prevSourceIndex);
                    prevSourceIndex = currentSourceIndex;

                    mappingsString = mappingsString + TypeScript.Base64VLQFormat.encode(mappedPosition.sourceLine - 1 - prevSourceLine);
                    prevSourceLine = mappedPosition.sourceLine - 1;

                    mappingsString = mappingsString + TypeScript.Base64VLQFormat.encode(mappedPosition.sourceColumn - prevSourceColumn);
                    prevSourceColumn = mappedPosition.sourceColumn;

                    if (nameIndex >= 0) {
                        mappingsString = mappingsString + TypeScript.Base64VLQFormat.encode(namesCount + nameIndex - prevNameIndex);
                        prevNameIndex = namesCount + nameIndex;
                    }

                    emitComma = true;
                    recordedPosition = mappedPosition;
                };

                var recordSourceMappingSiblings = function (sourceMappings) {
                    for (var i = 0; i < sourceMappings.length; i++) {
                        var sourceMapping = sourceMappings[i];
                        recordSourceMapping(sourceMapping.start, sourceMapping.nameIndex);
                        recordSourceMappingSiblings(sourceMapping.childMappings);
                        recordSourceMapping(sourceMapping.end, sourceMapping.nameIndex);
                    }
                };

                recordSourceMappingSiblings(sourceMapper.sourceMappings);
                namesCount = namesCount + sourceMapper.names.length;
            }

            sourceMapOut.Write(JSON.stringify({
                version: 3,
                file: sourceMapper.jsFileName,
                sources: tsFiles,
                names: namesList,
                mappings: mappingsString
            }));

            sourceMapOut.Close();
        };
        SourceMapper.MapFileExtension = ".map";
        return SourceMapper;
    })();
    TypeScript.SourceMapper = SourceMapper;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (EmitContainer) {
        EmitContainer[EmitContainer["Prog"] = 0] = "Prog";
        EmitContainer[EmitContainer["Module"] = 1] = "Module";
        EmitContainer[EmitContainer["DynamicModule"] = 2] = "DynamicModule";
        EmitContainer[EmitContainer["Class"] = 3] = "Class";
        EmitContainer[EmitContainer["Constructor"] = 4] = "Constructor";
        EmitContainer[EmitContainer["Function"] = 5] = "Function";
        EmitContainer[EmitContainer["Args"] = 6] = "Args";
        EmitContainer[EmitContainer["Interface"] = 7] = "Interface";
    })(TypeScript.EmitContainer || (TypeScript.EmitContainer = {}));
    var EmitContainer = TypeScript.EmitContainer;

    var EmitState = (function () {
        function EmitState() {
            this.column = 0;
            this.line = 0;
            this.container = 0 /* Prog */;
        }
        return EmitState;
    })();
    TypeScript.EmitState = EmitState;

    var EmitOptions = (function () {
        function EmitOptions(compilationSettings) {
            this.compilationSettings = compilationSettings;
            this.ioHost = null;
            this.outputMany = true;
            this.commonDirectoryPath = "";
        }
        EmitOptions.prototype.mapOutputFileName = function (fileName, extensionChanger) {
            if (this.outputMany) {
                var updatedFileName = fileName;
                if (this.compilationSettings.outputOption !== "") {
                    updatedFileName = fileName.replace(this.commonDirectoryPath, "");
                    updatedFileName = this.compilationSettings.outputOption + updatedFileName;
                }
                return extensionChanger(updatedFileName, false);
            } else {
                return extensionChanger(this.compilationSettings.outputOption, true);
            }
        };
        return EmitOptions;
    })();
    TypeScript.EmitOptions = EmitOptions;

    var Indenter = (function () {
        function Indenter() {
            this.indentAmt = 0;
        }
        Indenter.prototype.increaseIndent = function () {
            this.indentAmt += Indenter.indentStep;
        };

        Indenter.prototype.decreaseIndent = function () {
            this.indentAmt -= Indenter.indentStep;
        };

        Indenter.prototype.getIndent = function () {
            var indentString = Indenter.indentStrings[this.indentAmt];
            if (indentString === undefined) {
                indentString = "";
                for (var i = 0; i < this.indentAmt; i = i + Indenter.indentStep) {
                    indentString += Indenter.indentStepString;
                }
                Indenter.indentStrings[this.indentAmt] = indentString;
            }
            return indentString;
        };
        Indenter.indentStep = 4;
        Indenter.indentStepString = "    ";
        Indenter.indentStrings = [];
        return Indenter;
    })();
    TypeScript.Indenter = Indenter;

    var Emitter = (function () {
        function Emitter(emittingFileName, outfile, emitOptions, semanticInfoChain) {
            this.emittingFileName = emittingFileName;
            this.outfile = outfile;
            this.emitOptions = emitOptions;
            this.semanticInfoChain = semanticInfoChain;
            this.globalThisCapturePrologueEmitted = false;
            this.extendsPrologueEmitted = false;
            this.thisClassNode = null;
            this.thisFunctionDeclaration = null;
            this.moduleName = "";
            this.emitState = new EmitState();
            this.indenter = new Indenter();
            this.modAliasId = null;
            this.firstModAlias = null;
            this.allSourceMappers = [];
            this.sourceMapper = null;
            this.captureThisStmtString = "var _this = this;";
            this.varListCountStack = [0];
            this.pullTypeChecker = null;
            this.declStack = [];
            this.resolvingContext = new TypeScript.PullTypeResolutionContext();
            this.exportAssignmentIdentifier = null;
            this.document = null;
            TypeScript.globalSemanticInfoChain = semanticInfoChain;
            TypeScript.globalBinder.semanticInfoChain = semanticInfoChain;
            this.pullTypeChecker = new TypeScript.PullTypeChecker(emitOptions.compilationSettings, semanticInfoChain);
        }
        Emitter.prototype.pushDecl = function (decl) {
            if (decl) {
                this.declStack[this.declStack.length] = decl;
            }
        };

        Emitter.prototype.popDecl = function (decl) {
            if (decl) {
                this.declStack.length--;
            }
        };

        Emitter.prototype.getEnclosingDecl = function () {
            var declStackLen = this.declStack.length;
            var enclosingDecl = declStackLen > 0 ? this.declStack[declStackLen - 1] : null;
            return enclosingDecl;
        };

        Emitter.prototype.setTypeCheckerUnit = function (fileName) {
            if (!this.pullTypeChecker.resolver) {
                this.pullTypeChecker.setUnit(fileName);
                return;
            }

            this.pullTypeChecker.resolver.setUnitPath(fileName);
        };

        Emitter.prototype.setExportAssignmentIdentifier = function (id) {
            this.exportAssignmentIdentifier = id;
        };

        Emitter.prototype.getExportAssignmentIdentifier = function () {
            return this.exportAssignmentIdentifier;
        };

        Emitter.prototype.setDocument = function (document) {
            this.document = document;
        };

        Emitter.prototype.importStatementShouldBeEmitted = function (importDeclAST, unitPath) {
            if (!importDeclAST.isDynamicImport) {
                return true;
            }

            var importDecl = this.semanticInfoChain.getDeclForAST(importDeclAST, this.document.fileName);
            var pullSymbol = importDecl.getSymbol();
            return pullSymbol.getIsUsedAsValue();
        };

        Emitter.prototype.setSourceMappings = function (mapper) {
            this.allSourceMappers.push(mapper);
            this.sourceMapper = mapper;
        };

        Emitter.prototype.writeToOutput = function (s) {
            this.outfile.Write(s);

            this.emitState.column += s.length;
        };

        Emitter.prototype.writeToOutputTrimmable = function (s) {
            if (this.emitOptions.compilationSettings.minWhitespace) {
                s = s.replace(/[\s]*/g, '');
            }
            this.writeToOutput(s);
        };

        Emitter.prototype.writeLineToOutput = function (s) {
            if (this.emitOptions.compilationSettings.minWhitespace) {
                this.writeToOutput(s);
                var c = s.charCodeAt(s.length - 1);
                if (!((c === 32 /* space */) || (c === 59 /* semicolon */) || (c === 91 /* openBracket */))) {
                    this.writeToOutput(' ');
                }
            } else {
                this.outfile.WriteLine(s);
                this.emitState.column = 0;
                this.emitState.line++;
            }
        };

        Emitter.prototype.writeCaptureThisStatement = function (ast) {
            this.emitIndent();
            this.recordSourceMappingStart(ast);
            this.writeToOutput(this.captureThisStmtString);
            this.recordSourceMappingEnd(ast);
            this.writeLineToOutput("");
        };

        Emitter.prototype.setInVarBlock = function (count) {
            this.varListCountStack[this.varListCountStack.length - 1] = count;
        };

        Emitter.prototype.setContainer = function (c) {
            var temp = this.emitState.container;
            this.emitState.container = c;
            return temp;
        };

        Emitter.prototype.getIndentString = function () {
            if (this.emitOptions.compilationSettings.minWhitespace) {
                return "";
            } else {
                return this.indenter.getIndent();
            }
        };

        Emitter.prototype.emitIndent = function () {
            this.writeToOutput(this.getIndentString());
        };

        Emitter.prototype.emitCommentInPlace = function (comment) {
            var text = comment.getText();
            var hadNewLine = false;

            if (comment.isBlockComment) {
                if (this.emitState.column === 0) {
                    this.emitIndent();
                }
                this.recordSourceMappingStart(comment);
                this.writeToOutput(text[0]);

                if (text.length > 1 || comment.endsLine) {
                    for (var i = 1; i < text.length; i++) {
                        this.writeLineToOutput("");
                        this.emitIndent();
                        this.writeToOutput(text[i]);
                    }
                    this.recordSourceMappingEnd(comment);
                    this.writeLineToOutput("");
                    hadNewLine = true;
                } else {
                    this.recordSourceMappingEnd(comment);
                }
            } else {
                if (this.emitState.column === 0) {
                    this.emitIndent();
                }
                this.recordSourceMappingStart(comment);
                this.writeToOutput(text[0]);
                this.recordSourceMappingEnd(comment);
                this.writeLineToOutput("");
                hadNewLine = true;
            }

            if (hadNewLine) {
                this.emitIndent();
            } else {
                this.writeToOutput(" ");
            }
        };

        Emitter.prototype.emitComments = function (ast, pre) {
            var comments = pre ? ast.preComments : ast.postComments;

            if (this.emitOptions.compilationSettings.emitComments && comments && comments.length !== 0) {
                for (var i = 0; i < comments.length; i++) {
                    this.emitCommentInPlace(comments[i]);
                }
            }
        };

        Emitter.prototype.emitObjectLiteral = function (objectLiteral) {
            var useNewLines = !TypeScript.hasFlag(objectLiteral.getFlags(), 2 /* SingleLine */);

            this.writeToOutput("{");
            var list = objectLiteral.operand;
            if (list.members.length > 0) {
                if (useNewLines) {
                    this.writeLineToOutput("");
                } else {
                    this.writeToOutput(" ");
                }

                this.indenter.increaseIndent();
                this.emitCommaSeparatedList(list, useNewLines);
                this.indenter.decreaseIndent();
                if (useNewLines) {
                    this.emitIndent();
                } else {
                    this.writeToOutput(" ");
                }
            }
            this.writeToOutput("}");
        };

        Emitter.prototype.emitArrayLiteral = function (arrayLiteral) {
            var useNewLines = !TypeScript.hasFlag(arrayLiteral.getFlags(), 2 /* SingleLine */);

            this.writeToOutput("[");
            var list = arrayLiteral.operand;
            if (list.members.length > 0) {
                if (useNewLines) {
                    this.writeLineToOutput("");
                }

                this.indenter.increaseIndent();
                this.emitCommaSeparatedList(list, useNewLines);
                this.indenter.decreaseIndent();
                if (useNewLines) {
                    this.emitIndent();
                }
            }
            this.writeToOutput("]");
        };

        Emitter.prototype.emitNew = function (target, args) {
            this.writeToOutput("new ");
            if (target.nodeType === 11 /* TypeRef */) {
                var typeRef = target;
                if (typeRef.arrayCount) {
                    this.writeToOutput("Array()");
                } else {
                    typeRef.term.emit(this);
                    this.writeToOutput("()");
                }
            } else {
                target.emit(this);
                this.recordSourceMappingStart(args);
                this.writeToOutput("(");
                this.emitCommaSeparatedList(args);
                this.writeToOutput(")");
                this.recordSourceMappingEnd(args);
            }
        };

        Emitter.prototype.getVarDeclFromIdentifier = function (boundDeclInfo) {
            TypeScript.CompilerDiagnostics.assert(boundDeclInfo.boundDecl && boundDeclInfo.boundDecl.init && boundDeclInfo.boundDecl.init.nodeType === 20 /* Name */, "The init expression of bound declaration when emitting as constant has to be indentifier");

            var init = boundDeclInfo.boundDecl.init;
            var ident = init;

            this.setTypeCheckerUnit(this.document.fileName);
            var pullSymbol = this.resolvingContext.resolvingTypeReference ? this.pullTypeChecker.resolver.resolveTypeNameExpression(ident, boundDeclInfo.pullDecl.getParentDecl(), this.resolvingContext).symbol : this.pullTypeChecker.resolver.resolveNameExpression(ident, boundDeclInfo.pullDecl.getParentDecl(), this.resolvingContext).symbol;
            if (pullSymbol) {
                var pullDecls = pullSymbol.getDeclarations();
                if (pullDecls.length === 1) {
                    var pullDecl = pullDecls[0];
                    var ast = this.semanticInfoChain.getASTForDecl(pullDecl);
                    if (ast && ast.nodeType === 17 /* VariableDeclarator */) {
                        return { boundDecl: ast, pullDecl: pullDecl };
                    }
                }
            }

            return null;
        };

        Emitter.prototype.getConstantValue = function (boundDeclInfo) {
            var init = boundDeclInfo.boundDecl.init;
            if (init) {
                if (init.nodeType === 7 /* NumericLiteral */) {
                    var numLit = init;
                    return numLit.value;
                } else if (init.nodeType === 69 /* LeftShiftExpression */) {
                    var binop = init;
                    if (binop.operand1.nodeType === 7 /* NumericLiteral */ && binop.operand2.nodeType === 7 /* NumericLiteral */) {
                        return (binop.operand1).value << (binop.operand2).value;
                    }
                } else if (init.nodeType === 20 /* Name */) {
                    var varDeclInfo = this.getVarDeclFromIdentifier(boundDeclInfo);
                    if (varDeclInfo) {
                        return this.getConstantValue(varDeclInfo);
                    }
                }
            }

            return null;
        };

        Emitter.prototype.getConstantDecl = function (dotExpr) {
            this.setTypeCheckerUnit(this.document.fileName);
            var pullSymbol = this.pullTypeChecker.resolver.resolveDottedNameExpression(dotExpr, this.getEnclosingDecl(), this.resolvingContext).symbol;
            if (pullSymbol && pullSymbol.hasFlag(524288 /* Constant */)) {
                var pullDecls = pullSymbol.getDeclarations();
                if (pullDecls.length === 1) {
                    var pullDecl = pullDecls[0];
                    var ast = this.semanticInfoChain.getASTForDecl(pullDecl);
                    if (ast && ast.nodeType === 17 /* VariableDeclarator */) {
                        return { boundDecl: ast, pullDecl: pullDecl };
                    }
                }
            }

            return null;
        };

        Emitter.prototype.tryEmitConstant = function (dotExpr) {
            if (!this.emitOptions.compilationSettings.propagateConstants) {
                return false;
            }
            var propertyName = dotExpr.operand2;
            var boundDeclInfo = this.getConstantDecl(dotExpr);
            if (boundDeclInfo) {
                var value = this.getConstantValue(boundDeclInfo);
                if (value !== null) {
                    this.writeToOutput(value.toString());
                    var comment = " /* ";
                    comment += propertyName.actualText;
                    comment += " */";
                    this.writeToOutput(comment);
                    return true;
                }
            }

            return false;
        };

        Emitter.prototype.emitCall = function (callNode, target, args) {
            if (!this.emitSuperCall(callNode)) {
                if (target.nodeType === 12 /* FunctionDeclaration */) {
                    this.writeToOutput("(");
                }
                if (callNode.target.nodeType === 30 /* SuperExpression */ && this.emitState.container === 4 /* Constructor */) {
                    this.writeToOutput("_super.call");
                } else {
                    this.emitJavascript(target, false);
                }
                if (target.nodeType === 12 /* FunctionDeclaration */) {
                    this.writeToOutput(")");
                }
                this.recordSourceMappingStart(args);
                this.writeToOutput("(");
                if (callNode.target.nodeType === 30 /* SuperExpression */ && this.emitState.container === 4 /* Constructor */) {
                    this.writeToOutput("this");
                    if (args && args.members.length) {
                        this.writeToOutput(", ");
                    }
                }
                this.emitCommaSeparatedList(args);
                this.writeToOutput(")");
                this.recordSourceMappingEnd(args);
            }
        };

        Emitter.prototype.emitInnerFunction = function (funcDecl, printName, includePreComments) {
            if (typeof includePreComments === "undefined") { includePreComments = true; }
            var pullDecl = this.semanticInfoChain.getDeclForAST(funcDecl, this.document.fileName);
            this.pushDecl(pullDecl);

            var shouldParenthesize = false;

            if (includePreComments) {
                this.emitComments(funcDecl, true);
            }

            if (shouldParenthesize) {
                this.writeToOutput("(");
            }
            this.recordSourceMappingStart(funcDecl);
            var accessorSymbol = funcDecl.isAccessor() ? TypeScript.PullHelpers.getAccessorSymbol(funcDecl, this.semanticInfoChain, this.document.fileName) : null;
            var container = accessorSymbol ? accessorSymbol.getContainer() : null;
            var containerKind = container ? container.getKind() : 0 /* None */;
            if (!(funcDecl.isAccessor() && containerKind !== 8 /* Class */ && containerKind !== 33554432 /* ConstructorType */)) {
                this.writeToOutput("function ");
            }

            if (funcDecl.isConstructor) {
                this.writeToOutput(this.thisClassNode.name.actualText);
            }

            if (printName) {
                var id = funcDecl.getNameText();
                if (id && !funcDecl.isAccessor()) {
                    if (funcDecl.name) {
                        this.recordSourceMappingStart(funcDecl.name);
                    }
                    this.writeToOutput(id);
                    if (funcDecl.name) {
                        this.recordSourceMappingEnd(funcDecl.name);
                    }
                }
            }

            this.writeToOutput("(");
            var argsLen = 0;
            if (funcDecl.arguments) {
                this.emitComments(funcDecl.arguments, true);

                var tempContainer = this.setContainer(6 /* Args */);
                argsLen = funcDecl.arguments.members.length;
                var printLen = argsLen;
                if (funcDecl.variableArgList) {
                    printLen--;
                }
                for (var i = 0; i < printLen; i++) {
                    var arg = funcDecl.arguments.members[i];
                    arg.emit(this);

                    if (i < (printLen - 1)) {
                        this.writeToOutput(", ");
                    }
                }
                this.setContainer(tempContainer);

                this.emitComments(funcDecl.arguments, false);
            }
            this.writeLineToOutput(") {");

            if (funcDecl.isConstructor) {
                this.recordSourceMappingNameStart("constructor");
            } else if (funcDecl.isGetAccessor()) {
                this.recordSourceMappingNameStart("get_" + funcDecl.getNameText());
            } else if (funcDecl.isSetAccessor()) {
                this.recordSourceMappingNameStart("set_" + funcDecl.getNameText());
            } else {
                this.recordSourceMappingNameStart(funcDecl.getNameText());
            }
            this.indenter.increaseIndent();

            this.emitDefaultValueAssignments(funcDecl);
            this.emitRestParameterInitializer(funcDecl);

            if (this.shouldCaptureThis(funcDecl)) {
                this.writeCaptureThisStatement(funcDecl);
            }

            if (funcDecl.isConstructor) {
                this.emitConstructorStatements(funcDecl);
            } else {
                this.emitModuleElements(funcDecl.block.statements);
            }

            this.indenter.decreaseIndent();
            this.emitIndent();
            this.recordSourceMappingStart(funcDecl.block.closeBraceSpan);
            this.writeToOutput("}");

            this.recordSourceMappingNameEnd();
            this.recordSourceMappingEnd(funcDecl.block.closeBraceSpan);
            this.recordSourceMappingEnd(funcDecl);

            if (shouldParenthesize) {
                this.writeToOutput(")");
            }

            this.recordSourceMappingEnd(funcDecl);

            this.emitComments(funcDecl, false);

            this.popDecl(pullDecl);
        };

        Emitter.prototype.emitDefaultValueAssignments = function (funcDecl) {
            var n = funcDecl.arguments.members.length;
            if (funcDecl.variableArgList) {
                n--;
            }

            for (var i = 0; i < n; i++) {
                var arg = funcDecl.arguments.members[i];
                if (arg.init) {
                    this.emitIndent();
                    this.recordSourceMappingStart(arg);
                    this.writeToOutput("if (typeof " + arg.id.actualText + " === \"undefined\") { ");
                    this.recordSourceMappingStart(arg.id);
                    this.writeToOutput(arg.id.actualText);
                    this.recordSourceMappingEnd(arg.id);
                    this.writeToOutput(" = ");
                    this.emitJavascript(arg.init, false);
                    this.writeLineToOutput("; }");
                    this.recordSourceMappingEnd(arg);
                }
            }
        };

        Emitter.prototype.emitRestParameterInitializer = function (funcDecl) {
            if (funcDecl.variableArgList) {
                var n = funcDecl.arguments.members.length;
                var lastArg = funcDecl.arguments.members[n - 1];
                this.emitIndent();
                this.recordSourceMappingStart(lastArg);
                this.writeToOutput("var ");
                this.recordSourceMappingStart(lastArg.id);
                this.writeToOutput(lastArg.id.actualText);
                this.recordSourceMappingEnd(lastArg.id);
                this.writeLineToOutput(" = [];");
                this.recordSourceMappingEnd(lastArg);
                this.emitIndent();
                this.writeToOutput("for (");
                this.recordSourceMappingStart(lastArg);
                this.writeToOutput("var _i = 0;");
                this.recordSourceMappingEnd(lastArg);
                this.writeToOutput(" ");
                this.recordSourceMappingStart(lastArg);
                this.writeToOutput("_i < (arguments.length - " + (n - 1) + ")");
                this.recordSourceMappingEnd(lastArg);
                this.writeToOutput("; ");
                this.recordSourceMappingStart(lastArg);
                this.writeToOutput("_i++");
                this.recordSourceMappingEnd(lastArg);
                this.writeLineToOutput(") {");
                this.indenter.increaseIndent();
                this.emitIndent();

                this.recordSourceMappingStart(lastArg);
                this.writeToOutput(lastArg.id.actualText + "[_i] = arguments[_i + " + (n - 1) + "];");
                this.recordSourceMappingEnd(lastArg);
                this.writeLineToOutput("");
                this.indenter.decreaseIndent();
                this.emitIndent();
                this.writeLineToOutput("}");
            }
        };

        Emitter.prototype.getImportDecls = function (fileName) {
            var semanticInfo = this.semanticInfoChain.getUnit(this.document.fileName);
            var result = [];

            var queue = semanticInfo.getTopLevelDecls();

            while (queue.length > 0) {
                var decl = queue.shift();

                if (decl.getKind() & 256 /* TypeAlias */) {
                    var importStatementAST = semanticInfo.getASTForDecl(decl);
                    if (importStatementAST.alias.nodeType === 20 /* Name */) {
                        var text = (importStatementAST.alias).actualText;
                        if (TypeScript.isQuoted(text)) {
                            var symbol = decl.getSymbol();
                            var typeSymbol = symbol && symbol.getType();
                            if (typeSymbol && typeSymbol !== this.semanticInfoChain.anyTypeSymbol && !typeSymbol.isError()) {
                                result.push(decl);
                            }
                        }
                    }
                }

                queue = queue.concat(decl.getChildDecls());
            }

            return result;
        };

        Emitter.prototype.getModuleImportAndDependencyList = function (moduleDecl) {
            var importList = "";
            var dependencyList = "";

            var semanticInfo = this.semanticInfoChain.getUnit(this.document.fileName);
            var importDecls = this.getImportDecls(this.document.fileName);

            if (importDecls.length) {
                for (var i = 0; i < importDecls.length; i++) {
                    var importStatementDecl = importDecls[i];
                    var importStatementSymbol = importStatementDecl.getSymbol();
                    var importStatementAST = semanticInfo.getASTForDecl(importStatementDecl);

                    if (importStatementSymbol.getIsUsedAsValue()) {
                        if (i <= importDecls.length - 1) {
                            dependencyList += ", ";
                            importList += ", ";
                        }

                        importList += "__" + importStatementDecl.getName() + "__";
                        dependencyList += importStatementAST.firstAliasedModToString();
                    }
                }
            }

            for (var i = 0; i < moduleDecl.amdDependencies.length; i++) {
                dependencyList += ", \"" + moduleDecl.amdDependencies[i] + "\"";
            }

            return {
                importList: importList,
                dependencyList: dependencyList
            };
        };

        Emitter.prototype.shouldCaptureThis = function (ast) {
            if (ast.nodeType === 2 /* Script */) {
                var scriptDecl = this.semanticInfoChain.getUnit(this.document.fileName).getTopLevelDecls()[0];
                return (scriptDecl.getFlags() & 262144 /* MustCaptureThis */) === 262144 /* MustCaptureThis */;
            }

            var decl = this.semanticInfoChain.getDeclForAST(ast, this.document.fileName);
            if (decl) {
                return (decl.getFlags() & 262144 /* MustCaptureThis */) === 262144 /* MustCaptureThis */;
            }

            return false;
        };

        Emitter.prototype.emitModule = function (moduleDecl) {
            var pullDecl = this.semanticInfoChain.getDeclForAST(moduleDecl, this.document.fileName);
            this.pushDecl(pullDecl);

            var modName = moduleDecl.name.actualText;
            if (TypeScript.isTSFile(modName)) {
                moduleDecl.name.setText(modName.substring(0, modName.length - 3));
            }

            var isDynamicMod = TypeScript.hasFlag(moduleDecl.getModuleFlags(), 512 /* IsDynamic */);
            var prevOutFile = this.outfile;
            var prevOutFileName = this.emittingFileName;
            var prevAllSourceMappers = this.allSourceMappers;
            var prevSourceMapper = this.sourceMapper;
            var prevColumn = this.emitState.column;
            var prevLine = this.emitState.line;
            var temp = this.setContainer(1 /* Module */);
            var svModuleName = this.moduleName;
            var isExported = TypeScript.hasFlag(moduleDecl.getModuleFlags(), 1 /* Exported */);
            var isWholeFile = TypeScript.hasFlag(moduleDecl.getModuleFlags(), 256 /* IsWholeFile */);
            this.moduleName = moduleDecl.name.actualText;

            if (isDynamicMod) {
                this.setExportAssignmentIdentifier(null);
                this.setContainer(2 /* DynamicModule */);

                this.recordSourceMappingStart(moduleDecl);
                if (this.emitOptions.compilationSettings.moduleGenTarget === 1 /* Asynchronous */) {
                    var dependencyList = "[\"require\", \"exports\"";
                    var importList = "require, exports";

                    var importAndDependencyList = this.getModuleImportAndDependencyList(moduleDecl);
                    importList += importAndDependencyList.importList;
                    dependencyList += importAndDependencyList.dependencyList + "]";

                    this.writeLineToOutput("define(" + dependencyList + "," + " function(" + importList + ") {");
                }
            } else {
                if (!isExported) {
                    this.recordSourceMappingStart(moduleDecl);
                    this.writeToOutput("var ");
                    this.recordSourceMappingStart(moduleDecl.name);
                    this.writeToOutput(this.moduleName);
                    this.recordSourceMappingEnd(moduleDecl.name);
                    this.writeLineToOutput(";");
                    this.recordSourceMappingEnd(moduleDecl);
                    this.emitIndent();
                }

                this.writeToOutput("(");
                this.recordSourceMappingStart(moduleDecl);
                this.writeToOutput("function (");
                this.recordSourceMappingStart(moduleDecl.name);
                this.writeToOutput(this.moduleName);
                this.recordSourceMappingEnd(moduleDecl.name);
                this.writeLineToOutput(") {");
            }

            if (!isWholeFile) {
                this.recordSourceMappingNameStart(this.moduleName);
            }

            if (!isDynamicMod || this.emitOptions.compilationSettings.moduleGenTarget === 1 /* Asynchronous */) {
                this.indenter.increaseIndent();
            }

            if (this.shouldCaptureThis(moduleDecl)) {
                this.writeCaptureThisStatement(moduleDecl);
            }

            this.emitModuleElements(moduleDecl.members);
            if (!isDynamicMod || this.emitOptions.compilationSettings.moduleGenTarget === 1 /* Asynchronous */) {
                this.indenter.decreaseIndent();
            }
            this.emitIndent();

            if (isDynamicMod) {
                var exportAssignmentIdentifier = this.getExportAssignmentIdentifier();
                var exportAssignmentValueSymbol = (pullDecl.getSymbol()).getExportAssignedValueSymbol();

                if (this.emitOptions.compilationSettings.moduleGenTarget === 1 /* Asynchronous */) {
                    if (exportAssignmentIdentifier && exportAssignmentValueSymbol && !(exportAssignmentValueSymbol.getKind() & TypeScript.PullElementKind.SomeTypeReference)) {
                        this.indenter.increaseIndent();
                        this.emitIndent();
                        this.writeLineToOutput("return " + exportAssignmentIdentifier + ";");
                        this.indenter.decreaseIndent();
                    }
                    this.writeToOutput("});");
                } else if (exportAssignmentIdentifier && exportAssignmentValueSymbol && !(exportAssignmentValueSymbol.getKind() & TypeScript.PullElementKind.SomeTypeReference)) {
                    this.emitIndent();
                    this.writeLineToOutput("module.exports = " + exportAssignmentIdentifier + ";");
                }

                if (!isWholeFile) {
                    this.recordSourceMappingNameEnd();
                }
                this.recordSourceMappingEnd(moduleDecl);

                if (this.outfile !== prevOutFile) {
                    this.emitSourceMapsAndClose();
                    if (prevSourceMapper !== null) {
                        this.allSourceMappers = prevAllSourceMappers;
                        this.sourceMapper = prevSourceMapper;
                        this.emitState.column = prevColumn;
                        this.emitState.line = prevLine;
                    }
                    this.outfile = prevOutFile;
                    this.emittingFileName = prevOutFileName;
                }
            } else {
                var parentIsDynamic = temp === 2 /* DynamicModule */;
                this.recordSourceMappingStart(moduleDecl.endingToken);
                if (temp === 0 /* Prog */ && isExported) {
                    this.writeToOutput("}");
                    if (!isWholeFile) {
                        this.recordSourceMappingNameEnd();
                    }
                    this.recordSourceMappingEnd(moduleDecl.endingToken);
                    this.writeToOutput(")(this." + this.moduleName + " || (this." + this.moduleName + " = {}));");
                } else if (isExported || temp === 0 /* Prog */) {
                    var dotMod = svModuleName !== "" ? (parentIsDynamic ? "exports" : svModuleName) + "." : svModuleName;
                    this.writeToOutput("}");
                    if (!isWholeFile) {
                        this.recordSourceMappingNameEnd();
                    }
                    this.recordSourceMappingEnd(moduleDecl.endingToken);
                    this.writeToOutput(")(" + dotMod + this.moduleName + " || (" + dotMod + this.moduleName + " = {}));");
                } else if (!isExported && temp !== 0 /* Prog */) {
                    this.writeToOutput("}");
                    if (!isWholeFile) {
                        this.recordSourceMappingNameEnd();
                    }
                    this.recordSourceMappingEnd(moduleDecl.endingToken);
                    this.writeToOutput(")(" + this.moduleName + " || (" + this.moduleName + " = {}));");
                } else {
                    this.writeToOutput("}");
                    if (!isWholeFile) {
                        this.recordSourceMappingNameEnd();
                    }
                    this.recordSourceMappingEnd(moduleDecl.endingToken);
                    this.writeToOutput(")();");
                }

                this.recordSourceMappingEnd(moduleDecl);
                if (temp !== 0 /* Prog */ && isExported) {
                    this.recordSourceMappingStart(moduleDecl);
                    if (parentIsDynamic) {
                        this.writeLineToOutput("");
                        this.emitIndent();
                        this.writeToOutput("var " + this.moduleName + " = exports." + this.moduleName + ";");
                    } else {
                        this.writeLineToOutput("");
                        this.emitIndent();
                        this.writeToOutput("var " + this.moduleName + " = " + svModuleName + "." + this.moduleName + ";");
                    }
                    this.recordSourceMappingEnd(moduleDecl);
                }
            }

            this.setContainer(temp);
            this.moduleName = svModuleName;

            this.popDecl(pullDecl);
        };

        Emitter.prototype.emitEnumElement = function (varDecl) {
            this.writeToOutput(this.moduleName);
            this.writeToOutput('[');
            this.writeToOutput(this.moduleName);
            this.writeToOutput('["');
            this.writeToOutput(varDecl.id.text);
            this.writeToOutput('"] = ');
            varDecl.init.emit(this);
            this.writeToOutput('] = "');
            this.writeToOutput(varDecl.id.text);
            this.writeToOutput('";');
        };

        Emitter.prototype.emitIndex = function (operand1, operand2) {
            operand1.emit(this);
            this.writeToOutput("[");
            operand2.emit(this);
            this.writeToOutput("]");
        };

        Emitter.prototype.emitFunction = function (funcDecl) {
            if (TypeScript.hasFlag(funcDecl.getFunctionFlags(), 128 /* Signature */)) {
                return;
            }
            var temp;
            var tempFnc = this.thisFunctionDeclaration;
            this.thisFunctionDeclaration = funcDecl;

            if (funcDecl.isConstructor) {
                temp = this.setContainer(4 /* Constructor */);
            } else {
                temp = this.setContainer(5 /* Function */);
            }

            var funcName = funcDecl.getNameText();

            if (((temp !== 4 /* Constructor */) || ((funcDecl.getFunctionFlags() & 256 /* Method */) === 0 /* None */))) {
                this.recordSourceMappingStart(funcDecl);
                this.emitInnerFunction(funcDecl, (funcDecl.name && !funcDecl.name.isMissing()));
            }
            this.setContainer(temp);
            this.thisFunctionDeclaration = tempFnc;

            if (!TypeScript.hasFlag(funcDecl.getFunctionFlags(), 128 /* Signature */)) {
                if (TypeScript.hasFlag(funcDecl.getFunctionFlags(), 16 /* Static */)) {
                    if (this.thisClassNode) {
                        this.writeLineToOutput("");
                        if (funcDecl.isAccessor()) {
                            this.emitPropertyAccessor(funcDecl, this.thisClassNode.name.actualText, false);
                        } else {
                            this.emitIndent();
                            this.recordSourceMappingStart(funcDecl);
                            this.writeToOutput(this.thisClassNode.name.actualText + "." + funcName + " = " + funcName + ";");
                            this.recordSourceMappingEnd(funcDecl);
                        }
                    }
                } else if ((this.emitState.container === 1 /* Module */ || this.emitState.container === 2 /* DynamicModule */) && TypeScript.hasFlag(funcDecl.getFunctionFlags(), 1 /* Exported */)) {
                    this.writeLineToOutput("");
                    this.emitIndent();
                    var modName = this.emitState.container === 1 /* Module */ ? this.moduleName : "exports";
                    this.recordSourceMappingStart(funcDecl);
                    this.writeToOutput(modName + "." + funcName + " = " + funcName + ";");
                    this.recordSourceMappingEnd(funcDecl);
                }
            }
        };

        Emitter.prototype.emitAmbientVarDecl = function (varDecl) {
            if (varDecl.init) {
                this.emitComments(varDecl, true);
                this.recordSourceMappingStart(varDecl);
                this.recordSourceMappingStart(varDecl.id);
                this.writeToOutput(varDecl.id.actualText);
                this.recordSourceMappingEnd(varDecl.id);
                this.writeToOutput(" = ");
                this.emitJavascript(varDecl.init, false);
                this.recordSourceMappingEnd(varDecl);
                this.emitComments(varDecl, false);
            }
        };

        Emitter.prototype.varListCount = function () {
            return this.varListCountStack[this.varListCountStack.length - 1];
        };

        Emitter.prototype.emitVarDeclVar = function () {
            if (this.varListCount() >= 0) {
                this.writeToOutput("var ");
                this.setInVarBlock(-this.varListCount());
            }
            return true;
        };

        Emitter.prototype.onEmitVar = function () {
            if (this.varListCount() > 0) {
                this.setInVarBlock(this.varListCount() - 1);
            } else if (this.varListCount() < 0) {
                this.setInVarBlock(this.varListCount() + 1);
            }
        };

        Emitter.prototype.emitVariableDeclaration = function (declaration) {
            var varDecl = declaration.declarators.members[0];

            var symbolAndDiagnostics = this.semanticInfoChain.getSymbolAndDiagnosticsForAST(varDecl, this.document.fileName);
            var symbol = symbolAndDiagnostics && symbolAndDiagnostics.symbol;

            var parentSymbol = symbol ? symbol.getContainer() : null;
            var parentKind = parentSymbol ? parentSymbol.getKind() : 0 /* None */;
            var inClass = parentKind === 8 /* Class */;

            this.emitComments(declaration, true);
            this.recordSourceMappingStart(declaration);
            this.setInVarBlock(declaration.declarators.members.length);

            var isAmbientWithoutInit = TypeScript.hasFlag(varDecl.getVarFlags(), 8 /* Ambient */) && varDecl.init === null;
            if (!isAmbientWithoutInit) {
                for (var i = 0, n = declaration.declarators.members.length; i < n; i++) {
                    var declarator = declaration.declarators.members[i];

                    if (i > 0) {
                        if (inClass) {
                            this.writeToOutputTrimmable(";");
                        } else {
                            this.writeToOutputTrimmable(", ");
                        }
                    }

                    declarator.emit(this);
                }
            }

            this.recordSourceMappingEnd(declaration);
            this.emitComments(declaration, false);
        };

        Emitter.prototype.emitVariableDeclarator = function (varDecl) {
            var pullDecl = this.semanticInfoChain.getDeclForAST(varDecl, this.document.fileName);
            this.pushDecl(pullDecl);
            if ((varDecl.getVarFlags() & 8 /* Ambient */) === 8 /* Ambient */) {
                this.emitAmbientVarDecl(varDecl);
                this.onEmitVar();
            } else {
                this.emitComments(varDecl, true);
                this.recordSourceMappingStart(varDecl);

                var symbolAndDiagnostics = this.semanticInfoChain.getSymbolAndDiagnosticsForAST(varDecl, this.document.fileName);
                var symbol = symbolAndDiagnostics && symbolAndDiagnostics.symbol;
                var parentSymbol = symbol ? symbol.getContainer() : null;
                var parentKind = parentSymbol ? parentSymbol.getKind() : 0 /* None */;
                var associatedParentSymbol = parentSymbol ? parentSymbol.getAssociatedContainerType() : null;
                var associatedParentSymbolKind = associatedParentSymbol ? associatedParentSymbol.getKind() : 0 /* None */;
                if (parentKind === 8 /* Class */) {
                    if (this.emitState.container !== 6 /* Args */) {
                        if (varDecl.isStatic()) {
                            this.writeToOutput(parentSymbol.getName() + ".");
                        } else {
                            this.writeToOutput("this.");
                        }
                    }
                } else if (parentKind === 64 /* Enum */ || parentKind === 32 /* DynamicModule */ || associatedParentSymbolKind === 4 /* Container */ || associatedParentSymbolKind === 32 /* DynamicModule */ || associatedParentSymbolKind === 64 /* Enum */) {
                    if (!varDecl.isExported() && !varDecl.isProperty()) {
                        this.emitVarDeclVar();
                    } else {
                        if (this.emitState.container === 2 /* DynamicModule */) {
                            this.writeToOutput("exports.");
                        } else {
                            this.writeToOutput(this.moduleName + ".");
                        }
                    }
                } else {
                    this.emitVarDeclVar();
                }

                this.recordSourceMappingStart(varDecl.id);
                this.writeToOutput(varDecl.id.actualText);
                this.recordSourceMappingEnd(varDecl.id);
                var hasInitializer = (varDecl.init !== null);
                if (hasInitializer) {
                    this.writeToOutputTrimmable(" = ");

                    this.varListCountStack.push(0);
                    varDecl.init.emit(this);
                    this.varListCountStack.pop();
                }

                if (parentKind === 8 /* Class */) {
                    if (this.emitState.container !== 6 /* Args */) {
                        this.writeToOutput(";");
                    }
                }

                this.onEmitVar();

                this.recordSourceMappingEnd(varDecl);
                this.emitComments(varDecl, false);
            }
            this.popDecl(pullDecl);
        };

        Emitter.prototype.symbolIsUsedInItsEnclosingContainer = function (symbol, dynamic) {
            if (typeof dynamic === "undefined") { dynamic = false; }
            var symDecls = symbol.getDeclarations();

            if (symDecls.length) {
                var enclosingDecl = this.getEnclosingDecl();
                if (enclosingDecl) {
                    var parentDecl = symDecls[0].getParentDecl();
                    if (parentDecl) {
                        var symbolDeclarationEnclosingContainer = parentDecl;
                        var enclosingContainer = enclosingDecl;

                        while (symbolDeclarationEnclosingContainer) {
                            if (symbolDeclarationEnclosingContainer.getKind() === (dynamic ? 32 /* DynamicModule */ : 4 /* Container */)) {
                                break;
                            }
                            symbolDeclarationEnclosingContainer = symbolDeclarationEnclosingContainer.getParentDecl();
                        }

                        if (symbolDeclarationEnclosingContainer) {
                            while (enclosingContainer) {
                                if (enclosingContainer.getKind() === (dynamic ? 32 /* DynamicModule */ : 4 /* Container */)) {
                                    break;
                                }

                                enclosingContainer = enclosingContainer.getParentDecl();
                            }
                        }

                        if (symbolDeclarationEnclosingContainer && enclosingContainer) {
                            var same = symbolDeclarationEnclosingContainer === enclosingContainer;

                            if (!same && symbol.hasFlag(32768 /* InitializedModule */)) {
                                same = symbolDeclarationEnclosingContainer === enclosingContainer.getParentDecl();
                            }

                            return same;
                        }
                    }
                }
            }

            return false;
        };

        Emitter.prototype.emitName = function (name, addThis) {
            this.emitComments(name, true);
            this.recordSourceMappingStart(name);
            if (!name.isMissing()) {
                this.setTypeCheckerUnit(this.document.fileName);
                var pullSymbolAndDiagnostics = this.resolvingContext.resolvingTypeReference ? this.pullTypeChecker.resolver.resolveTypeNameExpression(name, this.getEnclosingDecl(), this.resolvingContext) : this.pullTypeChecker.resolver.resolveNameExpression(name, this.getEnclosingDecl(), this.resolvingContext);
                var pullSymbol = pullSymbolAndDiagnostics.symbol;
                var pullSymbolAlias = pullSymbolAndDiagnostics.symbolAlias;
                var pullSymbolKind = pullSymbol.getKind();
                var isLocalAlias = pullSymbolAlias && (pullSymbolAlias.getDeclarations()[0].getParentDecl() == this.getEnclosingDecl());
                if (addThis && (this.emitState.container !== 6 /* Args */) && pullSymbol) {
                    var pullSymbolContainer = pullSymbol.getContainer();

                    if (pullSymbolContainer) {
                        var pullSymbolContainerKind = pullSymbolContainer.getKind();

                        if (pullSymbolContainerKind === 8 /* Class */) {
                            if (pullSymbol.hasFlag(16 /* Static */)) {
                                this.writeToOutput(pullSymbolContainer.getName() + ".");
                            } else if (pullSymbolKind === 4096 /* Property */) {
                                this.emitThis();
                                this.writeToOutput(".");
                            }
                        } else if (pullSymbolContainerKind === 4 /* Container */ || pullSymbolContainerKind === 64 /* Enum */ || pullSymbolContainer.hasFlag(32768 /* InitializedModule */ | 131072 /* InitializedEnum */)) {
                            if (pullSymbolKind === 4096 /* Property */ || pullSymbolKind === 67108864 /* EnumMember */) {
                                this.writeToOutput(pullSymbolContainer.getName() + ".");
                            } else if (pullSymbol.hasFlag(1 /* Exported */) && pullSymbolKind === 1024 /* Variable */ && !pullSymbol.hasFlag(32768 /* InitializedModule */ | 131072 /* InitializedEnum */)) {
                                this.writeToOutput(pullSymbolContainer.getName() + ".");
                            } else if (pullSymbol.hasFlag(1 /* Exported */) && !this.symbolIsUsedInItsEnclosingContainer(pullSymbol)) {
                                this.writeToOutput(pullSymbolContainer.getName() + ".");
                            }
                        } else if (pullSymbolContainerKind === 32 /* DynamicModule */ || pullSymbolContainer.hasFlag(65536 /* InitializedDynamicModule */)) {
                            if (pullSymbolKind === 4096 /* Property */) {
                                this.writeToOutput("exports.");
                            } else if (pullSymbol.hasFlag(1 /* Exported */) && !isLocalAlias && !pullSymbol.hasFlag(TypeScript.PullElementFlags.ImplicitVariable) && pullSymbol.getKind() !== 32768 /* ConstructorMethod */ && pullSymbol.getKind() !== 8 /* Class */ && pullSymbol.getKind() !== 64 /* Enum */) {
                                this.writeToOutput("exports.");
                            }
                        } else if (pullSymbolKind === 4096 /* Property */) {
                            if (pullSymbolContainer.getKind() === 8 /* Class */) {
                                this.emitThis();
                                this.writeToOutput(".");
                            }
                        } else {
                            var pullDecls = pullSymbol.getDeclarations();
                            var emitContainerName = true;
                            for (var i = 0; i < pullDecls.length; i++) {
                                if (pullDecls[i].getScriptName() === this.document.fileName) {
                                    emitContainerName = false;
                                }
                            }
                            if (emitContainerName) {
                                this.writeToOutput(pullSymbolContainer.getName() + ".");
                            }
                        }
                    }
                }

                if (pullSymbol && pullSymbolKind === 32 /* DynamicModule */) {
                    if (this.emitOptions.compilationSettings.moduleGenTarget === 1 /* Asynchronous */) {
                        this.writeToOutput("__" + this.modAliasId + "__");
                    } else {
                        var moduleDecl = this.semanticInfoChain.getASTForSymbol(pullSymbol, this.document.fileName);
                        var modPath = name.actualText;
                        var isAmbient = pullSymbol.hasFlag(8 /* Ambient */);
                        modPath = isAmbient ? modPath : this.firstModAlias ? this.firstModAlias : TypeScript.quoteBaseName(modPath);
                        modPath = isAmbient ? modPath : (!TypeScript.isRelative(TypeScript.stripQuotes(modPath)) ? TypeScript.quoteStr("./" + TypeScript.stripQuotes(modPath)) : modPath);
                        this.writeToOutput("require(" + modPath + ")");
                    }
                } else {
                    this.writeToOutput(name.actualText);
                }
            }

            this.recordSourceMappingEnd(name);
            this.emitComments(name, false);
        };

        Emitter.prototype.recordSourceMappingNameStart = function (name) {
            if (this.sourceMapper) {
                var finalName = name;
                if (!name) {
                    finalName = "";
                } else if (this.sourceMapper.currentNameIndex.length > 0) {
                    finalName = this.sourceMapper.names[this.sourceMapper.currentNameIndex[this.sourceMapper.currentNameIndex.length - 1]] + "." + name;
                }

                this.sourceMapper.names.push(finalName);
                this.sourceMapper.currentNameIndex.push(this.sourceMapper.names.length - 1);
            }
        };

        Emitter.prototype.recordSourceMappingNameEnd = function () {
            if (this.sourceMapper) {
                this.sourceMapper.currentNameIndex.pop();
            }
        };

        Emitter.prototype.recordSourceMappingStart = function (ast) {
            if (this.sourceMapper && TypeScript.isValidAstNode(ast)) {
                var lineCol = { line: -1, character: -1 };
                var sourceMapping = new TypeScript.SourceMapping();
                sourceMapping.start.emittedColumn = this.emitState.column;
                sourceMapping.start.emittedLine = this.emitState.line;

                var lineMap = this.document.lineMap;
                lineMap.fillLineAndCharacterFromPosition(ast.minChar, lineCol);
                sourceMapping.start.sourceColumn = lineCol.character;
                sourceMapping.start.sourceLine = lineCol.line + 1;
                lineMap.fillLineAndCharacterFromPosition(ast.limChar, lineCol);
                sourceMapping.end.sourceColumn = lineCol.character;
                sourceMapping.end.sourceLine = lineCol.line + 1;
                if (this.sourceMapper.currentNameIndex.length > 0) {
                    sourceMapping.nameIndex = this.sourceMapper.currentNameIndex[this.sourceMapper.currentNameIndex.length - 1];
                }

                var siblings = this.sourceMapper.currentMappings[this.sourceMapper.currentMappings.length - 1];
                siblings.push(sourceMapping);
                this.sourceMapper.currentMappings.push(sourceMapping.childMappings);
            }
        };

        Emitter.prototype.recordSourceMappingEnd = function (ast) {
            if (this.sourceMapper && TypeScript.isValidAstNode(ast)) {
                this.sourceMapper.currentMappings.pop();

                var siblings = this.sourceMapper.currentMappings[this.sourceMapper.currentMappings.length - 1];
                var sourceMapping = siblings[siblings.length - 1];

                sourceMapping.end.emittedColumn = this.emitState.column;
                sourceMapping.end.emittedLine = this.emitState.line;
            }
        };

        Emitter.prototype.emitSourceMapsAndClose = function () {
            if (this.sourceMapper !== null) {
                TypeScript.SourceMapper.emitSourceMapping(this.allSourceMappers);
            }

            try  {
                this.outfile.Close();
            } catch (e) {
                Emitter.throwEmitterError(e);
            }
        };

        Emitter.prototype.emitParameterPropertyAndMemberVariableAssignments = function () {
            var constructorDecl = this.thisClassNode.constructorDecl;

            if (constructorDecl && constructorDecl.arguments) {
                for (var i = 0, n = constructorDecl.arguments.members.length; i < n; i++) {
                    var arg = constructorDecl.arguments.members[i];
                    if ((arg.getVarFlags() & 256 /* Property */) !== 0 /* None */) {
                        this.emitIndent();
                        this.recordSourceMappingStart(arg);
                        this.recordSourceMappingStart(arg.id);
                        this.writeToOutput("this." + arg.id.actualText);
                        this.recordSourceMappingEnd(arg.id);
                        this.writeToOutput(" = ");
                        this.recordSourceMappingStart(arg.id);
                        this.writeToOutput(arg.id.actualText);
                        this.recordSourceMappingEnd(arg.id);
                        this.writeLineToOutput(";");
                        this.recordSourceMappingEnd(arg);
                    }
                }
            }

            for (var i = 0, n = this.thisClassNode.members.members.length; i < n; i++) {
                if (this.thisClassNode.members.members[i].nodeType === 17 /* VariableDeclarator */) {
                    var varDecl = this.thisClassNode.members.members[i];
                    if (!TypeScript.hasFlag(varDecl.getVarFlags(), 16 /* Static */) && varDecl.init) {
                        this.emitIndent();
                        this.emitVariableDeclarator(varDecl);
                        this.writeLineToOutput("");
                    }
                }
            }
        };

        Emitter.prototype.emitCommaSeparatedList = function (list, startLine) {
            if (typeof startLine === "undefined") { startLine = false; }
            if (list === null) {
                return;
            } else {
                for (var i = 0, n = list.members.length; i < n; i++) {
                    var emitNode = list.members[i];
                    this.emitJavascript(emitNode, startLine);

                    if (i < (n - 1)) {
                        this.writeToOutput(startLine ? "," : ", ");
                    }

                    if (startLine) {
                        this.writeLineToOutput("");
                    }
                }
            }
        };

        Emitter.prototype.emitModuleElements = function (list) {
            if (list === null) {
                return;
            }

            this.emitComments(list, true);
            var lastEmittedNode = null;

            for (var i = 0, n = list.members.length; i < n; i++) {
                var node = list.members[i];

                if (node.shouldEmit()) {
                    this.emitSpaceBetweenConstructs(lastEmittedNode, node);

                    this.emitJavascript(node, true);
                    this.writeLineToOutput("");

                    lastEmittedNode = node;
                }
            }

            this.emitComments(list, false);
        };

        Emitter.prototype.isDirectivePrologueElement = function (node) {
            if (node.nodeType === 88 /* ExpressionStatement */) {
                var exprStatement = node;
                return exprStatement.expression.nodeType === 5 /* StringLiteral */;
            }

            return false;
        };

        Emitter.prototype.emitSpaceBetweenConstructs = function (node1, node2) {
            if (node1 === null || node2 === null) {
                return;
            }

            if (node1.minChar === -1 || node1.limChar === -1 || node2.minChar === -1 || node2.limChar === -1) {
                return;
            }

            var lineMap = this.document.lineMap;
            var node1EndLine = lineMap.getLineNumberFromPosition(node1.limChar);
            var node2StartLine = lineMap.getLineNumberFromPosition(node2.minChar);

            if ((node2StartLine - node1EndLine) > 1) {
                this.writeLineToOutput("");
            }
        };

        Emitter.prototype.emitScriptElements = function (script, requiresExtendsBlock) {
            var list = script.moduleElements;
            this.emitComments(list, true);

            for (var i = 0, n = list.members.length; i < n; i++) {
                var node = list.members[i];

                if (!this.isDirectivePrologueElement(node)) {
                    break;
                }

                this.emitJavascript(node, true);
                this.writeLineToOutput("");
            }

            this.emitPrologue(script, requiresExtendsBlock);
            var lastEmittedNode = null;

            for (; i < n; i++) {
                var node = list.members[i];

                if (node.shouldEmit()) {
                    this.emitSpaceBetweenConstructs(lastEmittedNode, node);

                    this.emitJavascript(node, true);
                    this.writeLineToOutput("");

                    lastEmittedNode = node;
                }
            }

            this.emitComments(list, false);
        };

        Emitter.prototype.emitConstructorStatements = function (funcDecl) {
            var list = funcDecl.block.statements;

            if (list === null) {
                return;
            }

            this.emitComments(list, true);

            var emitPropertyAssignmentsAfterSuperCall = this.thisClassNode.extendsList && this.thisClassNode.extendsList.members.length > 0;
            var propertyAssignmentIndex = emitPropertyAssignmentsAfterSuperCall ? 1 : 0;
            var lastEmittedNode = null;

            for (var i = 0, n = list.members.length; i < n; i++) {
                if (i === propertyAssignmentIndex) {
                    this.emitParameterPropertyAndMemberVariableAssignments();
                }

                var node = list.members[i];

                if (node.shouldEmit()) {
                    this.emitSpaceBetweenConstructs(lastEmittedNode, node);

                    this.emitJavascript(node, true);
                    this.writeLineToOutput("");

                    lastEmittedNode = node;
                }
            }

            if (i === propertyAssignmentIndex) {
                this.emitParameterPropertyAndMemberVariableAssignments();
            }

            this.emitComments(list, false);
        };

        Emitter.prototype.emitJavascript = function (ast, startLine) {
            if (ast === null) {
                return;
            }

            if (startLine && this.indenter.indentAmt > 0) {
                this.emitIndent();
            }

            ast.emit(this);
        };

        Emitter.prototype.emitPropertyAccessor = function (funcDecl, className, isProto) {
            if (!TypeScript.hasFlag(funcDecl.getFunctionFlags(), 32 /* GetAccessor */)) {
                var accessorSymbol = TypeScript.PullHelpers.getAccessorSymbol(funcDecl, this.semanticInfoChain, this.document.fileName);
                if (accessorSymbol.getGetter()) {
                    return;
                }
            }

            this.emitIndent();
            this.recordSourceMappingStart(funcDecl);
            this.writeLineToOutput("Object.defineProperty(" + className + (isProto ? ".prototype, \"" : ", \"") + funcDecl.name.actualText + "\"" + ", {");
            this.indenter.increaseIndent();

            var accessors = TypeScript.PullHelpers.getGetterAndSetterFunction(funcDecl, this.semanticInfoChain, this.document.fileName);
            if (accessors.getter) {
                this.emitIndent();
                this.recordSourceMappingStart(accessors.getter);
                this.writeToOutput("get: ");
                this.emitInnerFunction(accessors.getter, false);
                this.writeLineToOutput(",");
            }

            if (accessors.setter) {
                this.emitIndent();
                this.recordSourceMappingStart(accessors.setter);
                this.writeToOutput("set: ");
                this.emitInnerFunction(accessors.setter, false);
                this.writeLineToOutput(",");
            }

            this.emitIndent();
            this.writeLineToOutput("enumerable: true,");
            this.emitIndent();
            this.writeLineToOutput("configurable: true");
            this.indenter.decreaseIndent();
            this.emitIndent();
            this.writeLineToOutput("});");
            this.recordSourceMappingEnd(funcDecl);
        };

        Emitter.prototype.emitPrototypeMember = function (funcDecl, className) {
            if (funcDecl.isAccessor()) {
                this.emitPropertyAccessor(funcDecl, className, true);
            } else {
                this.emitIndent();
                this.recordSourceMappingStart(funcDecl);
                this.emitComments(funcDecl, true);
                this.writeToOutput(className + ".prototype." + funcDecl.getNameText() + " = ");
                this.emitInnerFunction(funcDecl, false, false);
                this.writeLineToOutput(";");
            }
        };

        Emitter.prototype.emitClass = function (classDecl) {
            var pullDecl = this.semanticInfoChain.getDeclForAST(classDecl, this.document.fileName);
            this.pushDecl(pullDecl);

            var svClassNode = this.thisClassNode;
            this.thisClassNode = classDecl;
            var className = classDecl.name.actualText;
            this.emitComments(classDecl, true);
            var temp = this.setContainer(3 /* Class */);

            this.recordSourceMappingStart(classDecl);
            this.writeToOutput("var " + className);

            var hasBaseClass = classDecl.extendsList && classDecl.extendsList.members.length;
            var baseNameDecl = null;
            var baseName = null;
            var varDecl = null;

            if (hasBaseClass) {
                this.writeLineToOutput(" = (function (_super) {");
            } else {
                this.writeLineToOutput(" = (function () {");
            }

            this.recordSourceMappingNameStart(className);
            this.indenter.increaseIndent();

            if (hasBaseClass) {
                baseNameDecl = classDecl.extendsList.members[0];
                baseName = baseNameDecl.nodeType === 36 /* InvocationExpression */ ? (baseNameDecl).target : baseNameDecl;
                this.emitIndent();
                this.writeLineToOutput("__extends(" + className + ", _super);");
            }

            this.emitIndent();

            var constrDecl = classDecl.constructorDecl;

            if (constrDecl) {
                constrDecl.emit(this);
                this.writeLineToOutput("");
            } else {
                this.recordSourceMappingStart(classDecl);

                this.indenter.increaseIndent();
                this.writeLineToOutput("function " + classDecl.name.actualText + "() {");
                this.recordSourceMappingNameStart("constructor");
                if (hasBaseClass) {
                    this.emitIndent();
                    this.writeLineToOutput("_super.apply(this, arguments);");
                }

                this.emitParameterPropertyAndMemberVariableAssignments();

                this.indenter.decreaseIndent();
                this.emitIndent();
                this.writeLineToOutput("}");

                this.recordSourceMappingNameEnd();
                this.recordSourceMappingEnd(classDecl);
            }

            this.emitClassMembers(classDecl);

            this.emitIndent();
            this.recordSourceMappingStart(classDecl.endingToken);
            this.writeLineToOutput("return " + className + ";");
            this.recordSourceMappingEnd(classDecl.endingToken);
            this.indenter.decreaseIndent();
            this.emitIndent();
            this.recordSourceMappingStart(classDecl.endingToken);
            this.writeToOutput("}");
            this.recordSourceMappingNameEnd();
            this.recordSourceMappingEnd(classDecl.endingToken);
            this.recordSourceMappingStart(classDecl);
            this.writeToOutput(")(");
            if (hasBaseClass) {
                this.resolvingContext.resolvingTypeReference = true;
                this.emitJavascript(baseName, false);
                this.resolvingContext.resolvingTypeReference = false;
            }
            this.writeToOutput(");");
            this.recordSourceMappingEnd(classDecl);

            if ((temp === 1 /* Module */ || temp === 2 /* DynamicModule */) && TypeScript.hasFlag(classDecl.getVarFlags(), 1 /* Exported */)) {
                this.writeLineToOutput("");
                this.emitIndent();
                var modName = temp === 1 /* Module */ ? this.moduleName : "exports";
                this.recordSourceMappingStart(classDecl);
                this.writeToOutput(modName + "." + className + " = " + className + ";");
                this.recordSourceMappingEnd(classDecl);
            }

            this.recordSourceMappingEnd(classDecl);
            this.emitComments(classDecl, false);
            this.setContainer(temp);
            this.thisClassNode = svClassNode;

            this.popDecl(pullDecl);
        };

        Emitter.prototype.emitClassMembers = function (classDecl) {
            var lastEmittedMember = null;

            for (var i = 0, n = classDecl.members.members.length; i < n; i++) {
                var memberDecl = classDecl.members.members[i];

                if (memberDecl.nodeType === 12 /* FunctionDeclaration */) {
                    var fn = memberDecl;

                    if (TypeScript.hasFlag(fn.getFunctionFlags(), 256 /* Method */) && !fn.isSignature()) {
                        this.emitSpaceBetweenConstructs(lastEmittedMember, fn);

                        if (!TypeScript.hasFlag(fn.getFunctionFlags(), 16 /* Static */)) {
                            this.emitPrototypeMember(fn, classDecl.name.actualText);
                        } else {
                            if (fn.isAccessor()) {
                                this.emitPropertyAccessor(fn, this.thisClassNode.name.actualText, false);
                            } else {
                                this.emitIndent();
                                this.recordSourceMappingStart(fn);
                                this.writeToOutput(classDecl.name.actualText + "." + fn.name.actualText + " = ");
                                this.emitInnerFunction(fn, false);
                                this.writeLineToOutput(";");
                            }
                        }

                        lastEmittedMember = fn;
                    }
                }
            }

            for (var i = 0, n = classDecl.members.members.length; i < n; i++) {
                var memberDecl = classDecl.members.members[i];

                if (memberDecl.nodeType === 17 /* VariableDeclarator */) {
                    var varDecl = memberDecl;

                    if (TypeScript.hasFlag(varDecl.getVarFlags(), 16 /* Static */) && varDecl.init) {
                        this.emitSpaceBetweenConstructs(lastEmittedMember, varDecl);

                        this.emitIndent();
                        this.recordSourceMappingStart(varDecl);
                        this.writeToOutput(classDecl.name.actualText + "." + varDecl.id.actualText + " = ");
                        varDecl.init.emit(this);

                        this.writeLineToOutput(";");
                        this.recordSourceMappingEnd(varDecl);

                        lastEmittedMember = varDecl;
                    }
                }
            }
        };

        Emitter.prototype.emitPrologue = function (script, requiresExtendsBlock) {
            if (!this.extendsPrologueEmitted) {
                if (requiresExtendsBlock) {
                    this.extendsPrologueEmitted = true;
                    this.writeLineToOutput("var __extends = this.__extends || function (d, b) {");
                    this.writeLineToOutput("    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];");
                    this.writeLineToOutput("    function __() { this.constructor = d; }");
                    this.writeLineToOutput("    __.prototype = b.prototype;");
                    this.writeLineToOutput("    d.prototype = new __();");
                    this.writeLineToOutput("};");
                }
            }

            if (!this.globalThisCapturePrologueEmitted) {
                if (this.shouldCaptureThis(script)) {
                    this.globalThisCapturePrologueEmitted = true;
                    this.writeLineToOutput(this.captureThisStmtString);
                }
            }
        };

        Emitter.prototype.emitSuperReference = function () {
            this.writeToOutput("_super.prototype");
        };

        Emitter.prototype.emitSuperCall = function (callEx) {
            if (callEx.target.nodeType === 32 /* MemberAccessExpression */) {
                var dotNode = callEx.target;
                if (dotNode.operand1.nodeType === 30 /* SuperExpression */) {
                    dotNode.emit(this);
                    this.writeToOutput(".call(");
                    this.emitThis();
                    if (callEx.arguments && callEx.arguments.members.length > 0) {
                        this.writeToOutput(", ");
                        this.emitCommaSeparatedList(callEx.arguments);
                    }
                    this.writeToOutput(")");
                    return true;
                }
            }
            return false;
        };

        Emitter.prototype.emitThis = function () {
            if (this.thisFunctionDeclaration && !this.thisFunctionDeclaration.isMethod() && (!this.thisFunctionDeclaration.isConstructor)) {
                this.writeToOutput("_this");
            } else {
                this.writeToOutput("this");
            }
        };

        Emitter.prototype.emitBlockOrStatement = function (node) {
            if (node.nodeType === 81 /* Block */) {
                node.emit(this);
            } else {
                this.writeLineToOutput("");
                this.indenter.increaseIndent();
                this.emitJavascript(node, true);
                this.indenter.decreaseIndent();
            }
        };

        Emitter.throwEmitterError = function (e) {
            var error = new Error(e.message);
            error.isEmitterError = true;
            throw error;
        };

        Emitter.handleEmitterError = function (fileName, e) {
            if ((e).isEmitterError === true) {
                return [new TypeScript.Diagnostic(fileName, 0, 0, 275 /* Emit_Error__0 */, [e.message])];
            }

            throw e;
        };
        return Emitter;
    })();
    TypeScript.Emitter = Emitter;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var MemberName = (function () {
        function MemberName() {
            this.prefix = "";
            this.suffix = "";
        }
        MemberName.prototype.isString = function () {
            return false;
        };
        MemberName.prototype.isArray = function () {
            return false;
        };
        MemberName.prototype.isMarker = function () {
            return !this.isString() && !this.isArray();
        };

        MemberName.prototype.toString = function () {
            return MemberName.memberNameToString(this);
        };

        MemberName.memberNameToString = function (memberName, markerInfo, markerBaseLength) {
            if (typeof markerBaseLength === "undefined") { markerBaseLength = 0; }
            var result = memberName.prefix;

            if (memberName.isString()) {
                result += (memberName).text;
            } else if (memberName.isArray()) {
                var ar = memberName;
                for (var index = 0; index < ar.entries.length; index++) {
                    if (ar.entries[index].isMarker()) {
                        if (markerInfo) {
                            markerInfo.push(markerBaseLength + result.length);
                        }
                        continue;
                    }

                    result += MemberName.memberNameToString(ar.entries[index], markerInfo, markerBaseLength + result.length);
                    result += ar.delim;
                }
            }

            result += memberName.suffix;
            return result;
        };

        MemberName.create = function (arg1, arg2, arg3) {
            if (typeof arg1 === "string") {
                return new MemberNameString(arg1);
            } else {
                var result = new MemberNameArray();
                if (arg2)
                    result.prefix = arg2;
                if (arg3)
                    result.suffix = arg3;
                result.entries.push(arg1);
                return result;
            }
        };
        return MemberName;
    })();
    TypeScript.MemberName = MemberName;

    var MemberNameString = (function (_super) {
        __extends(MemberNameString, _super);
        function MemberNameString(text) {
            _super.call(this);
            this.text = text;
        }
        MemberNameString.prototype.isString = function () {
            return true;
        };
        return MemberNameString;
    })(MemberName);
    TypeScript.MemberNameString = MemberNameString;

    var MemberNameArray = (function (_super) {
        __extends(MemberNameArray, _super);
        function MemberNameArray() {
            _super.call(this);
            this.delim = "";
            this.entries = [];
        }
        MemberNameArray.prototype.isArray = function () {
            return true;
        };

        MemberNameArray.prototype.add = function (entry) {
            this.entries.push(entry);
        };

        MemberNameArray.prototype.addAll = function (entries) {
            for (var i = 0; i < entries.length; i++) {
                this.entries.push(entries[i]);
            }
        };
        return MemberNameArray;
    })(MemberName);
    TypeScript.MemberNameArray = MemberNameArray;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    function stripQuotes(str) {
        return str.replace(/"/g, "").replace(/'/g, "");
    }
    TypeScript.stripQuotes = stripQuotes;

    function isSingleQuoted(str) {
        return str.indexOf("'") !== -1;
    }
    TypeScript.isSingleQuoted = isSingleQuoted;

    function isQuoted(str) {
        return str.indexOf("\"") !== -1 || isSingleQuoted(str);
    }
    TypeScript.isQuoted = isQuoted;

    function quoteStr(str) {
        return "\"" + str + "\"";
    }
    TypeScript.quoteStr = quoteStr;

    function swapQuotes(str) {
        if (str.indexOf("\"") !== -1) {
            str = str.replace("\"", "'");
            str = str.replace("\"", "'");
        } else {
            str = str.replace("'", "\"");
            str = str.replace("'", "\"");
        }

        return str;
    }
    TypeScript.swapQuotes = swapQuotes;

    function switchToForwardSlashes(path) {
        return path.replace(/\\/g, "/");
    }
    TypeScript.switchToForwardSlashes = switchToForwardSlashes;

    function trimModName(modName) {
        if (modName.length > 5 && modName.substring(modName.length - 5, modName.length) === ".d.ts") {
            return modName.substring(0, modName.length - 5);
        }
        if (modName.length > 3 && modName.substring(modName.length - 3, modName.length) === ".ts") {
            return modName.substring(0, modName.length - 3);
        }

        if (modName.length > 3 && modName.substring(modName.length - 3, modName.length) === ".js") {
            return modName.substring(0, modName.length - 3);
        }

        return modName;
    }
    TypeScript.trimModName = trimModName;

    function getDeclareFilePath(fname) {
        return isTSFile(fname) ? changePathToDTS(fname) : changePathToDTS(fname);
    }
    TypeScript.getDeclareFilePath = getDeclareFilePath;

    function isFileOfExtension(fname, ext) {
        var invariantFname = fname.toLocaleUpperCase();
        var invariantExt = ext.toLocaleUpperCase();
        var extLength = invariantExt.length;
        return invariantFname.length > extLength && invariantFname.substring(invariantFname.length - extLength, invariantFname.length) === invariantExt;
    }

    function isJSFile(fname) {
        return isFileOfExtension(fname, ".js");
    }
    TypeScript.isJSFile = isJSFile;

    function isTSFile(fname) {
        return isFileOfExtension(fname, ".ts");
    }
    TypeScript.isTSFile = isTSFile;

    function isDTSFile(fname) {
        return isFileOfExtension(fname, ".d.ts");
    }
    TypeScript.isDTSFile = isDTSFile;

    function getPrettyName(modPath, quote, treatAsFileName) {
        if (typeof quote === "undefined") { quote = true; }
        if (typeof treatAsFileName === "undefined") { treatAsFileName = false; }
        var modName = treatAsFileName ? switchToForwardSlashes(modPath) : trimModName(stripQuotes(modPath));
        var components = this.getPathComponents(modName);
        return components.length ? (quote ? quoteStr(components[components.length - 1]) : components[components.length - 1]) : modPath;
    }
    TypeScript.getPrettyName = getPrettyName;

    function getPathComponents(path) {
        return path.split("/");
    }
    TypeScript.getPathComponents = getPathComponents;

    function getRelativePathToFixedPath(fixedModFilePath, absoluteModPath) {
        absoluteModPath = switchToForwardSlashes(absoluteModPath);

        var modComponents = this.getPathComponents(absoluteModPath);
        var fixedModComponents = this.getPathComponents(fixedModFilePath);

        var joinStartIndex = 0;
        for (; joinStartIndex < modComponents.length && joinStartIndex < fixedModComponents.length; joinStartIndex++) {
            if (fixedModComponents[joinStartIndex] !== modComponents[joinStartIndex]) {
                break;
            }
        }

        if (joinStartIndex !== 0) {
            var relativePath = "";
            var relativePathComponents = modComponents.slice(joinStartIndex, modComponents.length);
            for (; joinStartIndex < fixedModComponents.length; joinStartIndex++) {
                if (fixedModComponents[joinStartIndex] !== "") {
                    relativePath = relativePath + "../";
                }
            }

            return relativePath + relativePathComponents.join("/");
        }

        return absoluteModPath;
    }
    TypeScript.getRelativePathToFixedPath = getRelativePathToFixedPath;

    function quoteBaseName(modPath) {
        var modName = trimModName(stripQuotes(modPath));
        var path = getRootFilePath(modName);
        if (path === "") {
            return modPath;
        } else {
            var components = modName.split(path);
            var fileIndex = components.length > 1 ? 1 : 0;
            return quoteStr(components[fileIndex]);
        }
    }
    TypeScript.quoteBaseName = quoteBaseName;

    function changePathToDTS(modPath) {
        return trimModName(stripQuotes(modPath)) + ".d.ts";
    }
    TypeScript.changePathToDTS = changePathToDTS;

    function isRelative(path) {
        return path.charAt(0) === ".";
    }
    TypeScript.isRelative = isRelative;
    function isRooted(path) {
        return path.charAt(0) === "\\" || path.charAt(0) === "/" || (path.indexOf(":\\") !== -1) || (path.indexOf(":/") !== -1);
    }
    TypeScript.isRooted = isRooted;

    function getRootFilePath(outFname) {
        if (outFname === "") {
            return outFname;
        } else {
            var isPath = outFname.indexOf("/") !== -1;
            return isPath ? filePath(outFname) : "";
        }
    }
    TypeScript.getRootFilePath = getRootFilePath;

    function filePathComponents(fullPath) {
        fullPath = switchToForwardSlashes(fullPath);
        var components = getPathComponents(fullPath);
        return components.slice(0, components.length - 1);
    }
    TypeScript.filePathComponents = filePathComponents;

    function filePath(fullPath) {
        var path = filePathComponents(fullPath);
        return path.join("/") + "/";
    }
    TypeScript.filePath = filePath;

    function normalizePath(path) {
        if (/^\\\\[^\\]/.test(path)) {
            path = "file:" + path;
        }
        var parts = this.getPathComponents(switchToForwardSlashes(path));
        var normalizedParts = [];

        for (var i = 0; i < parts.length; i++) {
            var part = parts[i];
            if (part === ".") {
                continue;
            }

            if (normalizedParts.length > 0 && TypeScript.ArrayUtilities.last(normalizedParts) !== ".." && part === "..") {
                normalizedParts.pop();
                continue;
            }

            normalizedParts.push(part);
        }

        return normalizedParts.join("/");
    }
    TypeScript.normalizePath = normalizePath;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SourceUnit = (function () {
        function SourceUnit(path, fileInformation) {
            this.path = path;
            this.fileInformation = fileInformation;
            this.referencedFiles = null;
            this.lineStarts = null;
        }
        SourceUnit.prototype.getText = function (start, end) {
            return this.fileInformation.contents().substring(start, end);
        };

        SourceUnit.prototype.getLength = function () {
            return this.fileInformation.contents().length;
        };

        SourceUnit.prototype.getLineStartPositions = function () {
            if (this.lineStarts === null) {
                this.lineStarts = TypeScript.LineMap.fromString(this.fileInformation.contents()).lineStarts();
            }

            return this.lineStarts;
        };

        SourceUnit.prototype.getTextChangeRangeSinceVersion = function (scriptVersion) {
            throw TypeScript.Errors.notYetImplemented();
        };
        return SourceUnit;
    })();
    TypeScript.SourceUnit = SourceUnit;

    var CompilationEnvironment = (function () {
        function CompilationEnvironment(compilationSettings, ioHost) {
            this.compilationSettings = compilationSettings;
            this.ioHost = ioHost;
            this.code = [];
            this.inputFileNameToOutputFileName = new TypeScript.StringHashTable();
        }
        CompilationEnvironment.prototype.getSourceUnit = function (path) {
            var normalizedPath = TypeScript.switchToForwardSlashes(path.toUpperCase());
            for (var i = 0, n = this.code.length; i < n; i++) {
                var sourceUnit = this.code[i];
                var soruceUnitNormalizedPath = TypeScript.switchToForwardSlashes(sourceUnit.path.toUpperCase());
                if (normalizedPath === soruceUnitNormalizedPath) {
                    return sourceUnit;
                }
            }

            return null;
        };
        return CompilationEnvironment;
    })();
    TypeScript.CompilationEnvironment = CompilationEnvironment;

    var CodeResolver = (function () {
        function CodeResolver(environment) {
            this.environment = environment;
            this.visited = {};
        }
        CodeResolver.prototype.resolveCode = function (referencePath, parentPath, performSearch, resolutionDispatcher) {
            var resolvedFile = { fileInformation: null, path: referencePath };

            var ioHost = this.environment.ioHost;

            var isRelativePath = TypeScript.isRelative(referencePath);
            var isRootedPath = isRelativePath ? false : TypeScript.isRooted(referencePath);
            var normalizedPath = isRelativePath ? ioHost.resolvePath(parentPath + "/" + referencePath) : (isRootedPath || !parentPath || performSearch ? referencePath : parentPath + "/" + referencePath);

            if (!TypeScript.isTSFile(normalizedPath)) {
                normalizedPath += ".ts";
            }

            normalizedPath = TypeScript.switchToForwardSlashes(TypeScript.stripQuotes(normalizedPath));
            var absoluteModuleID = this.environment.compilationSettings.useCaseSensitiveFileResolution ? normalizedPath : normalizedPath.toLocaleUpperCase();

            if (!this.visited[absoluteModuleID]) {
                if (isRelativePath || isRootedPath || !performSearch) {
                    try  {
                        TypeScript.CompilerDiagnostics.debugPrint("   Reading code from " + normalizedPath);

                        try  {
                            resolvedFile.fileInformation = ioHost.readFile(normalizedPath);
                        } catch (err1) {
                            if (TypeScript.isTSFile(normalizedPath)) {
                                normalizedPath = TypeScript.changePathToDTS(normalizedPath);
                                TypeScript.CompilerDiagnostics.debugPrint("   Reading code from " + normalizedPath);
                                resolvedFile.fileInformation = ioHost.readFile(normalizedPath);
                            }
                        }
                        TypeScript.CompilerDiagnostics.debugPrint("   Found code at " + normalizedPath);

                        resolvedFile.path = normalizedPath;
                        this.visited[absoluteModuleID] = true;
                    } catch (err4) {
                        TypeScript.CompilerDiagnostics.debugPrint("   Did not find code for " + referencePath);

                        return false;
                    }
                } else {
                    try  {
                        resolvedFile = ioHost.findFile(parentPath, normalizedPath);

                        if (!resolvedFile) {
                            if (TypeScript.isTSFile(normalizedPath)) {
                                normalizedPath = TypeScript.changePathToDTS(normalizedPath);
                                resolvedFile = ioHost.findFile(parentPath, normalizedPath);
                            }
                        }
                    } catch (e) {
                        TypeScript.CompilerDiagnostics.debugPrint("   Did not find code for " + normalizedPath);

                        return false;
                    }

                    if (resolvedFile) {
                        resolvedFile.path = TypeScript.switchToForwardSlashes(TypeScript.stripQuotes(resolvedFile.path));
                        TypeScript.CompilerDiagnostics.debugPrint(referencePath + " resolved to: " + resolvedFile.path);
                        resolvedFile.fileInformation = resolvedFile.fileInformation;
                        this.visited[absoluteModuleID] = true;
                    } else {
                        TypeScript.CompilerDiagnostics.debugPrint("Could not find " + referencePath);
                    }
                }

                if (resolvedFile && resolvedFile.fileInformation !== null) {
                    var rootDir = ioHost.dirName(resolvedFile.path);
                    var sourceUnit = new SourceUnit(resolvedFile.path, resolvedFile.fileInformation);
                    var preProcessedFileInfo = TypeScript.preProcessFile(resolvedFile.path, sourceUnit, this.environment.compilationSettings);
                    var resolvedFilePath = ioHost.resolvePath(resolvedFile.path);
                    var resolutionResult;

                    sourceUnit.referencedFiles = preProcessedFileInfo.referencedFiles;

                    for (var i = 0; i < preProcessedFileInfo.referencedFiles.length; i++) {
                        var fileReference = preProcessedFileInfo.referencedFiles[i];

                        normalizedPath = TypeScript.isRooted(fileReference.path) ? fileReference.path : rootDir + "/" + fileReference.path;
                        normalizedPath = ioHost.resolvePath(normalizedPath);

                        if (resolvedFilePath === normalizedPath) {
                            resolutionDispatcher.errorReporter.addDiagnostic(new TypeScript.Diagnostic(normalizedPath, fileReference.position, fileReference.length, 270 /* A_file_cannot_have_a_reference_itself */, null));
                            continue;
                        }

                        resolutionResult = this.resolveCode(fileReference.path, rootDir, false, resolutionDispatcher);

                        if (!resolutionResult) {
                            resolutionDispatcher.errorReporter.addDiagnostic(new TypeScript.Diagnostic(resolvedFilePath, fileReference.position, fileReference.length, 271 /* Cannot_resolve_referenced_file___0_ */, [fileReference.path]));
                        }
                    }

                    for (var i = 0; i < preProcessedFileInfo.importedFiles.length; i++) {
                        var fileImport = preProcessedFileInfo.importedFiles[i];

                        resolutionResult = this.resolveCode(fileImport.path, rootDir, true, resolutionDispatcher);

                        if (!resolutionResult) {
                            resolutionDispatcher.errorReporter.addDiagnostic(new TypeScript.Diagnostic(resolvedFilePath, fileImport.position, fileImport.length, 272 /* Cannot_resolve_imported_file___0_ */, [fileImport.path]));
                        }
                    }

                    resolutionDispatcher.postResolution(sourceUnit.path, sourceUnit);
                }
            }
            return true;
        };
        return CodeResolver;
    })();
    TypeScript.CodeResolver = CodeResolver;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var CompilationSettings = (function () {
        function CompilationSettings() {
            this.propagateConstants = false;
            this.minWhitespace = false;
            this.emitComments = false;
            this.watch = false;
            this.exec = false;
            this.resolve = true;
            this.disallowBool = false;
            this.allowAutomaticSemicolonInsertion = true;
            this.allowModuleKeywordInExternalModuleReference = true;
            this.useDefaultLib = true;
            this.codeGenTarget = 0 /* EcmaScript3 */;
            this.moduleGenTarget = 0 /* Synchronous */;
            this.outputOption = "";
            this.mapSourceFiles = false;
            this.emitFullSourceMapPath = false;
            this.generateDeclarationFiles = false;
            this.useCaseSensitiveFileResolution = false;
            this.gatherDiagnostics = false;
            this.updateTC = false;
            this.implicitAny = false;
        }
        return CompilationSettings;
    })();
    TypeScript.CompilationSettings = CompilationSettings;

    function getFileReferenceFromReferencePath(comment) {
        var referencesRegEx = /^(\/\/\/\s*<reference\s+path=)('|")(.+?)\2\s*(static=('|")(.+?)\2\s*)*\/>/gim;
        var match = referencesRegEx.exec(comment);

        if (match) {
            var path = TypeScript.normalizePath(match[3]);
            var adjustedPath = TypeScript.normalizePath(path);

            var isResident = match.length >= 7 && match[6] === "true";
            if (isResident) {
                TypeScript.CompilerDiagnostics.debugPrint(path + " is resident");
            }
            return {
                line: 0,
                character: 0,
                position: 0,
                length: 0,
                path: TypeScript.switchToForwardSlashes(adjustedPath),
                isResident: isResident
            };
        } else {
            return null;
        }
    }

    function getImplicitImport(comment) {
        var implicitImportRegEx = /^(\/\/\/\s*<implicit-import\s*)*\/>/gim;
        var match = implicitImportRegEx.exec(comment);

        if (match) {
            return true;
        }

        return false;
    }
    TypeScript.getImplicitImport = getImplicitImport;

    function getReferencedFiles(fileName, sourceText) {
        var preProcessInfo = preProcessFile(fileName, sourceText, null, false);
        return preProcessInfo.referencedFiles;
    }
    TypeScript.getReferencedFiles = getReferencedFiles;

    var scannerWindow = TypeScript.ArrayUtilities.createArray(2048, 0);
    var scannerDiagnostics = [];

    function processImports(lineMap, scanner, token, importedFiles) {
        var position = 0;
        var lineChar = { line: -1, character: -1 };

        while (token.tokenKind !== 10 /* EndOfFileToken */) {
            if (token.tokenKind === 49 /* ImportKeyword */) {
                var importStart = position + token.leadingTriviaWidth();
                token = scanner.scan(scannerDiagnostics, false);

                if (TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(token)) {
                    token = scanner.scan(scannerDiagnostics, false);

                    if (token.tokenKind === 108 /* EqualsToken */) {
                        token = scanner.scan(scannerDiagnostics, false);

                        if (token.tokenKind === 66 /* ModuleKeyword */ || token.tokenKind === 67 /* RequireKeyword */) {
                            token = scanner.scan(scannerDiagnostics, false);

                            if (token.tokenKind === 73 /* OpenParenToken */) {
                                var afterOpenParenPosition = scanner.absoluteIndex();
                                token = scanner.scan(scannerDiagnostics, false);

                                lineMap.fillLineAndCharacterFromPosition(importStart, lineChar);

                                if (token.tokenKind === 14 /* StringLiteral */) {
                                    var ref = {
                                        line: lineChar.line,
                                        character: lineChar.character,
                                        position: afterOpenParenPosition + token.leadingTriviaWidth(),
                                        length: token.width(),
                                        path: TypeScript.stripQuotes(TypeScript.switchToForwardSlashes(token.text())),
                                        isResident: false
                                    };
                                    importedFiles.push(ref);
                                }
                            }
                        }
                    }
                }
            }

            position = scanner.absoluteIndex();
            token = scanner.scan(scannerDiagnostics, false);
        }
    }

    function processTripleSlashDirectives(lineMap, firstToken, settings, referencedFiles) {
        var leadingTrivia = firstToken.leadingTrivia();

        var position = 0;
        var lineChar = { line: -1, character: -1 };
        var noDefaultLib = false;

        for (var i = 0, n = leadingTrivia.count(); i < n; i++) {
            var trivia = leadingTrivia.syntaxTriviaAt(i);

            if (trivia.kind() === 7 /* SingleLineCommentTrivia */) {
                var triviaText = trivia.fullText();
                var referencedCode = getFileReferenceFromReferencePath(triviaText);

                if (referencedCode) {
                    lineMap.fillLineAndCharacterFromPosition(position, lineChar);
                    referencedCode.position = position;
                    referencedCode.length = trivia.fullWidth();
                    referencedCode.line = lineChar.line;
                    referencedCode.character = lineChar.character;

                    referencedFiles.push(referencedCode);
                }

                if (settings) {
                    var isNoDefaultLibRegex = /^(\/\/\/\s*<reference\s+no-default-lib=)('|")(.+?)\2\s*\/>/gim;
                    var isNoDefaultLibMatch = isNoDefaultLibRegex.exec(triviaText);
                    if (isNoDefaultLibMatch) {
                        noDefaultLib = (isNoDefaultLibMatch[3] === "true");
                    }
                }
            }

            position += trivia.fullWidth();
        }

        return { noDefaultLib: noDefaultLib };
    }

    function preProcessFile(fileName, sourceText, settings, readImportFiles) {
        if (typeof readImportFiles === "undefined") { readImportFiles = true; }
        settings = settings || new CompilationSettings();
        var text = TypeScript.SimpleText.fromScriptSnapshot(sourceText);
        var scanner = new TypeScript.Scanner(fileName, text, settings.codeGenTarget, scannerWindow);

        var firstToken = scanner.scan(scannerDiagnostics, false);

        var importedFiles = [];
        if (readImportFiles) {
            processImports(text.lineMap(), scanner, firstToken, importedFiles);
        }

        var referencedFiles = [];
        var properties = processTripleSlashDirectives(text.lineMap(), firstToken, settings, referencedFiles);

        scannerDiagnostics.length = 0;
        return { settings: settings, referencedFiles: referencedFiles, importedFiles: importedFiles, isLibFile: properties.noDefaultLib };
    }
    TypeScript.preProcessFile = preProcessFile;

    function getParseOptions(settings) {
        return new TypeScript.ParseOptions(settings.allowAutomaticSemicolonInsertion, settings.allowModuleKeywordInExternalModuleReference);
    }
    TypeScript.getParseOptions = getParseOptions;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var TextWriter = (function () {
        function TextWriter(ioHost, path, writeByteOrderMark) {
            this.ioHost = ioHost;
            this.path = path;
            this.writeByteOrderMark = writeByteOrderMark;
            this.contents = "";
            this.onNewLine = true;
        }
        TextWriter.prototype.Write = function (s) {
            this.contents += s;
            this.onNewLine = false;
        };

        TextWriter.prototype.WriteLine = function (s) {
            this.contents += s;
            this.contents += "\r\n";
            this.onNewLine = true;
        };

        TextWriter.prototype.Close = function () {
            try  {
                this.ioHost.writeFile(this.path, this.contents, this.writeByteOrderMark);
            } catch (e) {
                TypeScript.Emitter.throwEmitterError(e);
            }
        };
        return TextWriter;
    })();
    TypeScript.TextWriter = TextWriter;

    var DeclarationEmitter = (function () {
        function DeclarationEmitter(emittingFileName, semanticInfoChain, emitOptions, writeByteOrderMark) {
            this.emittingFileName = emittingFileName;
            this.semanticInfoChain = semanticInfoChain;
            this.emitOptions = emitOptions;
            this.writeByteOrderMark = writeByteOrderMark;
            this.fileName = null;
            this.declFile = null;
            this.indenter = new TypeScript.Indenter();
            this.declarationContainerStack = [];
            this.isDottedModuleName = [];
            this.ignoreCallbackAst = null;
            this.singleDeclFile = null;
            this.varListCount = 0;
            this.declFile = new TextWriter(emitOptions.ioHost, emittingFileName, writeByteOrderMark);
        }
        DeclarationEmitter.prototype.widenType = function (type) {
            if (type === this.semanticInfoChain.undefinedTypeSymbol || type === this.semanticInfoChain.nullTypeSymbol) {
                return this.semanticInfoChain.anyTypeSymbol;
            }

            return type;
        };

        DeclarationEmitter.prototype.close = function () {
            try  {
                this.declFile.Close();
            } catch (e) {
                TypeScript.Emitter.throwEmitterError(e);
            }
        };

        DeclarationEmitter.prototype.emitDeclarations = function (script) {
            TypeScript.AstWalkerWithDetailCallback.walk(script, this);
        };

        DeclarationEmitter.prototype.getAstDeclarationContainer = function () {
            return this.declarationContainerStack[this.declarationContainerStack.length - 1];
        };

        DeclarationEmitter.prototype.emitDottedModuleName = function () {
            return (this.isDottedModuleName.length === 0) ? false : this.isDottedModuleName[this.isDottedModuleName.length - 1];
        };

        DeclarationEmitter.prototype.getIndentString = function (declIndent) {
            if (typeof declIndent === "undefined") { declIndent = false; }
            if (this.emitOptions.compilationSettings.minWhitespace) {
                return "";
            } else {
                return this.indenter.getIndent();
            }
        };

        DeclarationEmitter.prototype.emitIndent = function () {
            this.declFile.Write(this.getIndentString());
        };

        DeclarationEmitter.prototype.canEmitSignature = function (declFlags, declAST, canEmitGlobalAmbientDecl, useDeclarationContainerTop) {
            if (typeof canEmitGlobalAmbientDecl === "undefined") { canEmitGlobalAmbientDecl = true; }
            if (typeof useDeclarationContainerTop === "undefined") { useDeclarationContainerTop = true; }
            var container;
            if (useDeclarationContainerTop) {
                container = this.getAstDeclarationContainer();
            } else {
                container = this.declarationContainerStack[this.declarationContainerStack.length - 2];
            }

            if (container.nodeType === 15 /* ModuleDeclaration */ && !TypeScript.hasFlag(declFlags, 1 /* Exported */)) {
                var declSymbol = this.semanticInfoChain.getSymbolAndDiagnosticsForAST(declAST, this.fileName).symbol;
                return declSymbol && declSymbol.isExternallyVisible();
            }

            if (!canEmitGlobalAmbientDecl && container.nodeType === 2 /* Script */ && TypeScript.hasFlag(declFlags, 8 /* Ambient */)) {
                return false;
            }

            return true;
        };

        DeclarationEmitter.prototype.canEmitPrePostAstSignature = function (declFlags, astWithPrePostCallback, preCallback) {
            if (this.ignoreCallbackAst) {
                TypeScript.CompilerDiagnostics.assert(this.ignoreCallbackAst !== astWithPrePostCallback, "Ignore Callback AST mismatch");
                this.ignoreCallbackAst = null;
                return false;
            } else if (preCallback && !this.canEmitSignature(declFlags, astWithPrePostCallback, true, preCallback)) {
                this.ignoreCallbackAst = astWithPrePostCallback;
                return false;
            }

            return true;
        };

        DeclarationEmitter.prototype.getDeclFlagsString = function (declFlags, typeString) {
            var result = this.getIndentString();

            if (TypeScript.hasFlag(declFlags, 16 /* Static */)) {
                if (TypeScript.hasFlag(declFlags, 2 /* Private */)) {
                    result += "private ";
                }
                result += "static ";
            } else {
                if (TypeScript.hasFlag(declFlags, 2 /* Private */)) {
                    result += "private ";
                } else if (TypeScript.hasFlag(declFlags, 4 /* Public */)) {
                    result += "public ";
                } else {
                    var emitDeclare = !TypeScript.hasFlag(declFlags, 1 /* Exported */);

                    var container = this.getAstDeclarationContainer();
                    if (container.nodeType === 15 /* ModuleDeclaration */ && TypeScript.hasFlag((container).getModuleFlags(), 256 /* IsWholeFile */) && TypeScript.hasFlag(declFlags, 1 /* Exported */)) {
                        result += "export ";
                        emitDeclare = true;
                    }

                    if (emitDeclare && typeString !== "interface") {
                        result += "declare ";
                    }

                    result += typeString + " ";
                }
            }

            return result;
        };

        DeclarationEmitter.prototype.emitDeclFlags = function (declFlags, typeString) {
            this.declFile.Write(this.getDeclFlagsString(declFlags, typeString));
        };

        DeclarationEmitter.prototype.canEmitTypeAnnotationSignature = function (declFlag) {
            if (typeof declFlag === "undefined") { declFlag = 0 /* None */; }
            return !TypeScript.hasFlag(declFlag, 2 /* Private */);
        };

        DeclarationEmitter.prototype.pushDeclarationContainer = function (ast) {
            this.declarationContainerStack.push(ast);
        };

        DeclarationEmitter.prototype.popDeclarationContainer = function (ast) {
            TypeScript.CompilerDiagnostics.assert(ast !== this.getAstDeclarationContainer(), 'Declaration container mismatch');
            this.declarationContainerStack.pop();
        };

        DeclarationEmitter.prototype.emitTypeNamesMember = function (memberName, emitIndent) {
            if (typeof emitIndent === "undefined") { emitIndent = false; }
            if (memberName.prefix === "{ ") {
                if (emitIndent) {
                    this.emitIndent();
                }

                this.declFile.WriteLine("{");
                this.indenter.increaseIndent();
                emitIndent = true;
            } else if (memberName.prefix !== "") {
                if (emitIndent) {
                    this.emitIndent();
                }

                this.declFile.Write(memberName.prefix);
                emitIndent = false;
            }

            if (memberName.isString()) {
                if (emitIndent) {
                    this.emitIndent();
                }

                this.declFile.Write((memberName).text);
            } else if (memberName.isArray()) {
                var ar = memberName;
                for (var index = 0; index < ar.entries.length; index++) {
                    this.emitTypeNamesMember(ar.entries[index], emitIndent);
                    if (ar.delim === "; ") {
                        this.declFile.WriteLine(";");
                    }
                }
            }

            if (memberName.suffix === "}") {
                this.indenter.decreaseIndent();
                this.emitIndent();
                this.declFile.Write(memberName.suffix);
            } else {
                this.declFile.Write(memberName.suffix);
            }
        };

        DeclarationEmitter.prototype.emitTypeSignature = function (type) {
            var declarationContainerAst = this.getAstDeclarationContainer();
            var declarationContainerDecl = this.semanticInfoChain.getDeclForAST(declarationContainerAst, this.fileName);
            var declarationPullSymbol = declarationContainerDecl.getSymbol();
            var typeNameMembers = type.getScopedNameEx(declarationPullSymbol);
            this.emitTypeNamesMember(typeNameMembers);
        };

        DeclarationEmitter.prototype.emitComment = function (comment) {
            var text = comment.getText();
            if (this.declFile.onNewLine) {
                this.emitIndent();
            } else if (!comment.isBlockComment) {
                this.declFile.WriteLine("");
                this.emitIndent();
            }

            this.declFile.Write(text[0]);

            for (var i = 1; i < text.length; i++) {
                this.declFile.WriteLine("");
                this.emitIndent();
                this.declFile.Write(text[i]);
            }

            if (comment.endsLine || !comment.isBlockComment) {
                this.declFile.WriteLine("");
            } else {
                this.declFile.Write(" ");
            }
        };

        DeclarationEmitter.prototype.emitDeclarationComments = function (astOrSymbol, endLine) {
            if (typeof endLine === "undefined") { endLine = true; }
            if (!this.emitOptions.compilationSettings.emitComments) {
                return;
            }

            var declComments = astOrSymbol.getDocComments();
            this.writeDeclarationComments(declComments, endLine);
        };

        DeclarationEmitter.prototype.writeDeclarationComments = function (declComments, endLine) {
            if (typeof endLine === "undefined") { endLine = true; }
            if (declComments.length > 0) {
                for (var i = 0; i < declComments.length; i++) {
                    this.emitComment(declComments[i]);
                }

                if (endLine) {
                    if (!this.declFile.onNewLine) {
                        this.declFile.WriteLine("");
                    }
                } else {
                    if (this.declFile.onNewLine) {
                        this.emitIndent();
                    }
                }
            }
        };

        DeclarationEmitter.prototype.emitTypeOfBoundDecl = function (boundDecl) {
            var decl = this.semanticInfoChain.getDeclForAST(boundDecl, this.fileName);
            var pullSymbol = decl.getSymbol();
            var type = this.widenType(pullSymbol.getType());
            if (!type) {
                return;
            }

            if (boundDecl.typeExpr || (boundDecl.init && type !== this.semanticInfoChain.anyTypeSymbol)) {
                this.declFile.Write(": ");
                this.emitTypeSignature(type);
            }
        };

        DeclarationEmitter.prototype.VariableDeclaratorCallback = function (pre, varDecl) {
            if (pre && this.canEmitSignature(TypeScript.ToDeclFlags(varDecl.getVarFlags()), varDecl, false)) {
                var interfaceMember = (this.getAstDeclarationContainer().nodeType === 14 /* InterfaceDeclaration */);
                this.emitDeclarationComments(varDecl);
                if (!interfaceMember) {
                    if (this.varListCount >= 0) {
                        this.emitDeclFlags(TypeScript.ToDeclFlags(varDecl.getVarFlags()), "var");
                        this.varListCount = -this.varListCount;
                    }

                    this.declFile.Write(varDecl.id.actualText);
                } else {
                    this.emitIndent();
                    this.declFile.Write(varDecl.id.actualText);
                    if (TypeScript.hasFlag(varDecl.id.getFlags(), 4 /* OptionalName */)) {
                        this.declFile.Write("?");
                    }
                }

                if (this.canEmitTypeAnnotationSignature(TypeScript.ToDeclFlags(varDecl.getVarFlags()))) {
                    this.emitTypeOfBoundDecl(varDecl);
                }

                if (this.varListCount > 0) {
                    this.varListCount--;
                } else if (this.varListCount < 0) {
                    this.varListCount++;
                }

                if (this.varListCount < 0) {
                    this.declFile.Write(", ");
                } else {
                    this.declFile.WriteLine(";");
                }
            }
            return false;
        };

        DeclarationEmitter.prototype.BlockCallback = function (pre, block) {
            return false;
        };

        DeclarationEmitter.prototype.VariableStatementCallback = function (pre, variableDeclaration) {
            return true;
        };

        DeclarationEmitter.prototype.VariableDeclarationCallback = function (pre, variableDeclaration) {
            if (pre) {
                this.varListCount = variableDeclaration.declarators.members.length;
            } else {
                this.varListCount = 0;
            }
            return true;
        };

        DeclarationEmitter.prototype.emitArgDecl = function (argDecl, funcDecl) {
            this.indenter.increaseIndent();

            this.emitDeclarationComments(argDecl, false);
            this.declFile.Write(argDecl.id.actualText);
            if (argDecl.isOptionalArg()) {
                this.declFile.Write("?");
            }

            this.indenter.decreaseIndent();

            if (this.canEmitTypeAnnotationSignature(TypeScript.ToDeclFlags(funcDecl.getFunctionFlags()))) {
                this.emitTypeOfBoundDecl(argDecl);
            }
        };

        DeclarationEmitter.prototype.isOverloadedCallSignature = function (funcDecl) {
            var functionDecl = this.semanticInfoChain.getDeclForAST(funcDecl, this.fileName);
            var funcSymbol = functionDecl.getSymbol();
            var funcTypeSymbol = funcSymbol.getType();
            var signatures = funcTypeSymbol.getCallSignatures();
            return signatures && signatures.length > 1;
        };

        DeclarationEmitter.prototype.FunctionDeclarationCallback = function (pre, funcDecl) {
            if (!pre) {
                return false;
            }

            if (funcDecl.isAccessor()) {
                return this.emitPropertyAccessorSignature(funcDecl);
            }

            var isInterfaceMember = (this.getAstDeclarationContainer().nodeType === 14 /* InterfaceDeclaration */);

            var funcSymbol = this.semanticInfoChain.getSymbolAndDiagnosticsForAST(funcDecl, this.fileName).symbol;
            var funcTypeSymbol = funcSymbol.getType();
            if (funcDecl.block) {
                var constructSignatures = funcTypeSymbol.getConstructSignatures();
                if (constructSignatures && constructSignatures.length > 1) {
                    return false;
                } else if (this.isOverloadedCallSignature(funcDecl)) {
                    return false;
                }
            } else if (!isInterfaceMember && TypeScript.hasFlag(funcDecl.getFunctionFlags(), 2 /* Private */) && this.isOverloadedCallSignature(funcDecl)) {
                var callSignatures = funcTypeSymbol.getCallSignatures();
                TypeScript.Debug.assert(callSignatures && callSignatures.length > 1);
                var firstSignature = callSignatures[0].isDefinition() ? callSignatures[1] : callSignatures[0];
                var firstSignatureDecl = firstSignature.getDeclarations()[0];
                var firstFuncDecl = this.semanticInfoChain.getASTForDecl(firstSignatureDecl);
                if (firstFuncDecl !== funcDecl) {
                    return false;
                }
            }

            if (!this.canEmitSignature(TypeScript.ToDeclFlags(funcDecl.getFunctionFlags()), funcDecl, false)) {
                return false;
            }

            var funcSignature = this.semanticInfoChain.getDeclForAST(funcDecl, this.fileName).getSignatureSymbol();
            this.emitDeclarationComments(funcDecl);
            if (funcDecl.isConstructor) {
                this.emitIndent();
                this.declFile.Write("constructor");
                this.emitTypeParameters(funcDecl.typeArguments, funcSignature);
            } else {
                var id = funcDecl.getNameText();
                if (!isInterfaceMember) {
                    this.emitDeclFlags(TypeScript.ToDeclFlags(funcDecl.getFunctionFlags()), "function");
                    if (id !== "__missing" || !funcDecl.name || !funcDecl.name.isMissing()) {
                        this.declFile.Write(id);
                    } else if (funcDecl.isConstructMember()) {
                        this.declFile.Write("new");
                    }

                    this.emitTypeParameters(funcDecl.typeArguments, funcSignature);
                } else {
                    this.emitIndent();
                    if (funcDecl.isConstructMember()) {
                        this.declFile.Write("new");
                        this.emitTypeParameters(funcDecl.typeArguments, funcSignature);
                    } else if (!funcDecl.isCallMember() && !funcDecl.isIndexerMember()) {
                        this.declFile.Write(id);
                        this.emitTypeParameters(funcDecl.typeArguments, funcSignature);
                        if (TypeScript.hasFlag(funcDecl.name.getFlags(), 4 /* OptionalName */)) {
                            this.declFile.Write("? ");
                        }
                    } else {
                        this.emitTypeParameters(funcDecl.typeArguments, funcSignature);
                    }
                }
            }

            if (!funcDecl.isIndexerMember()) {
                this.declFile.Write("(");
            } else {
                this.declFile.Write("[");
            }

            if (funcDecl.arguments) {
                var argsLen = funcDecl.arguments.members.length;
                if (funcDecl.variableArgList) {
                    argsLen--;
                }

                for (var i = 0; i < argsLen; i++) {
                    var argDecl = funcDecl.arguments.members[i];
                    this.emitArgDecl(argDecl, funcDecl);
                    if (i < (argsLen - 1)) {
                        this.declFile.Write(", ");
                    }
                }
            }

            if (funcDecl.variableArgList) {
                var lastArg = funcDecl.arguments.members[funcDecl.arguments.members.length - 1];
                if (funcDecl.arguments.members.length > 1) {
                    this.declFile.Write(", ...");
                } else {
                    this.declFile.Write("...");
                }

                this.emitArgDecl(lastArg, funcDecl);
            }

            if (!funcDecl.isIndexerMember()) {
                this.declFile.Write(")");
            } else {
                this.declFile.Write("]");
            }

            if (!funcDecl.isConstructor && this.canEmitTypeAnnotationSignature(TypeScript.ToDeclFlags(funcDecl.getFunctionFlags()))) {
                var returnType = funcSignature.getReturnType();
                if (funcDecl.returnTypeAnnotation || (returnType && returnType !== this.semanticInfoChain.anyTypeSymbol)) {
                    this.declFile.Write(": ");
                    this.emitTypeSignature(returnType);
                }
            }

            this.declFile.WriteLine(";");

            return false;
        };

        DeclarationEmitter.prototype.emitBaseExpression = function (bases, index) {
            var baseTypeAndDiagnostics = this.semanticInfoChain.getSymbolAndDiagnosticsForAST(bases.members[index], this.fileName);
            var baseType = baseTypeAndDiagnostics && baseTypeAndDiagnostics.symbol;
            this.emitTypeSignature(baseType);
        };

        DeclarationEmitter.prototype.emitBaseList = function (typeDecl, useExtendsList) {
            var bases = useExtendsList ? typeDecl.extendsList : typeDecl.implementsList;
            if (bases && (bases.members.length > 0)) {
                var qual = useExtendsList ? "extends" : "implements";
                this.declFile.Write(" " + qual + " ");
                var basesLen = bases.members.length;
                for (var i = 0; i < basesLen; i++) {
                    if (i > 0) {
                        this.declFile.Write(", ");
                    }
                    this.emitBaseExpression(bases, i);
                }
            }
        };

        DeclarationEmitter.prototype.emitAccessorDeclarationComments = function (funcDecl) {
            if (!this.emitOptions.compilationSettings.emitComments) {
                return;
            }

            var accessors = TypeScript.PullHelpers.getGetterAndSetterFunction(funcDecl, this.semanticInfoChain, this.fileName);
            var comments = [];
            if (accessors.getter) {
                comments = comments.concat(accessors.getter.getDocComments());
            }
            if (accessors.setter) {
                comments = comments.concat(accessors.setter.getDocComments());
            }
            this.writeDeclarationComments(comments);
        };

        DeclarationEmitter.prototype.emitPropertyAccessorSignature = function (funcDecl) {
            var accessorSymbol = TypeScript.PullHelpers.getAccessorSymbol(funcDecl, this.semanticInfoChain, this.fileName);
            if (!TypeScript.hasFlag(funcDecl.getFunctionFlags(), 32 /* GetAccessor */) && accessorSymbol.getGetter()) {
                return false;
            }

            this.emitAccessorDeclarationComments(funcDecl);
            this.emitDeclFlags(TypeScript.ToDeclFlags(funcDecl.getFunctionFlags()), "var");
            this.declFile.Write(funcDecl.name.actualText);
            if (this.canEmitTypeAnnotationSignature(TypeScript.ToDeclFlags(funcDecl.getFunctionFlags()))) {
                this.declFile.Write(" : ");
                var type = accessorSymbol.getType();
                this.emitTypeSignature(type);
            }
            this.declFile.WriteLine(";");

            return false;
        };

        DeclarationEmitter.prototype.emitClassMembersFromConstructorDefinition = function (funcDecl) {
            if (funcDecl.arguments) {
                var argsLen = funcDecl.arguments.members.length;
                if (funcDecl.variableArgList) {
                    argsLen--;
                }

                for (var i = 0; i < argsLen; i++) {
                    var argDecl = funcDecl.arguments.members[i];
                    if (TypeScript.hasFlag(argDecl.getVarFlags(), 256 /* Property */)) {
                        this.emitDeclarationComments(argDecl);
                        this.emitDeclFlags(TypeScript.ToDeclFlags(argDecl.getVarFlags()), "var");
                        this.declFile.Write(argDecl.id.actualText);

                        if (this.canEmitTypeAnnotationSignature(TypeScript.ToDeclFlags(argDecl.getVarFlags()))) {
                            this.emitTypeOfBoundDecl(argDecl);
                        }
                        this.declFile.WriteLine(";");
                    }
                }
            }
        };

        DeclarationEmitter.prototype.ClassDeclarationCallback = function (pre, classDecl) {
            if (!this.canEmitPrePostAstSignature(TypeScript.ToDeclFlags(classDecl.getVarFlags()), classDecl, pre)) {
                return false;
            }

            if (pre) {
                var className = classDecl.name.actualText;
                this.emitDeclarationComments(classDecl);
                this.emitDeclFlags(TypeScript.ToDeclFlags(classDecl.getVarFlags()), "class");
                this.declFile.Write(className);
                this.pushDeclarationContainer(classDecl);
                this.emitTypeParameters(classDecl.typeParameters);
                this.emitBaseList(classDecl, true);
                this.emitBaseList(classDecl, false);
                this.declFile.WriteLine(" {");

                this.indenter.increaseIndent();
                if (classDecl.constructorDecl) {
                    this.emitClassMembersFromConstructorDefinition(classDecl.constructorDecl);
                }
            } else {
                this.indenter.decreaseIndent();
                this.popDeclarationContainer(classDecl);

                this.emitIndent();
                this.declFile.WriteLine("}");
            }

            return true;
        };

        DeclarationEmitter.prototype.emitTypeParameters = function (typeParams, funcSignature) {
            if (!typeParams || !typeParams.members.length) {
                return;
            }

            this.declFile.Write("<");
            var containerAst = this.getAstDeclarationContainer();
            var containerDecl = this.semanticInfoChain.getDeclForAST(containerAst, this.fileName);
            var containerSymbol = containerDecl.getSymbol();
            var typars;
            if (funcSignature) {
                typars = funcSignature.getTypeParameters();
            } else {
                typars = containerSymbol.getTypeArguments();
                if (!typars || !typars.length) {
                    typars = containerSymbol.getTypeParameters();
                }
            }

            for (var i = 0; i < typars.length; i++) {
                if (i) {
                    this.declFile.Write(", ");
                }

                var memberName = typars[i].getScopedNameEx(containerSymbol, true);
                this.emitTypeNamesMember(memberName);
            }

            this.declFile.Write(">");
        };

        DeclarationEmitter.prototype.InterfaceDeclarationCallback = function (pre, interfaceDecl) {
            if (!this.canEmitPrePostAstSignature(TypeScript.ToDeclFlags(interfaceDecl.getVarFlags()), interfaceDecl, pre)) {
                return false;
            }

            if (pre) {
                var interfaceName = interfaceDecl.name.actualText;
                this.emitDeclarationComments(interfaceDecl);
                this.emitDeclFlags(TypeScript.ToDeclFlags(interfaceDecl.getVarFlags()), "interface");
                this.declFile.Write(interfaceName);
                this.pushDeclarationContainer(interfaceDecl);
                this.emitTypeParameters(interfaceDecl.typeParameters);
                this.emitBaseList(interfaceDecl, true);
                this.declFile.WriteLine(" {");

                this.indenter.increaseIndent();
            } else {
                this.indenter.decreaseIndent();
                this.popDeclarationContainer(interfaceDecl);

                this.emitIndent();
                this.declFile.WriteLine("}");
            }

            return true;
        };

        DeclarationEmitter.prototype.ImportDeclarationCallback = function (pre, importDeclAST) {
            if (pre) {
                var importDecl = this.semanticInfoChain.getDeclForAST(importDeclAST, this.fileName);
                var importSymbol = importDecl.getSymbol();
                if (importSymbol.getTypeUsedExternally() || TypeScript.PullContainerTypeSymbol.usedAsSymbol(importSymbol.getContainer(), importSymbol)) {
                    this.emitDeclarationComments(importDeclAST);
                    this.emitIndent();
                    this.declFile.Write("import ");

                    this.declFile.Write(importDeclAST.id.actualText + " = ");
                    if (importDeclAST.isDynamicImport) {
                        this.declFile.WriteLine("require(" + importDeclAST.getAliasName() + ");");
                    } else {
                        this.declFile.WriteLine(importDeclAST.getAliasName() + ";");
                    }
                }
            }

            return false;
        };

        DeclarationEmitter.prototype.emitEnumSignature = function (moduleDecl) {
            if (!this.canEmitSignature(TypeScript.ToDeclFlags(moduleDecl.getModuleFlags()), moduleDecl)) {
                return false;
            }

            this.emitDeclarationComments(moduleDecl);
            this.emitDeclFlags(TypeScript.ToDeclFlags(moduleDecl.getModuleFlags()), "enum");
            this.declFile.WriteLine(moduleDecl.name.actualText + " {");

            this.indenter.increaseIndent();
            var membersLen = moduleDecl.members.members.length;
            for (var j = 0; j < membersLen; j++) {
                var memberDecl = moduleDecl.members.members[j];
                if (memberDecl.nodeType === 97 /* VariableStatement */ && !TypeScript.hasFlag(memberDecl.getFlags(), 32 /* EnumMapElement */)) {
                    var variableStatement = memberDecl;
                    this.emitDeclarationComments(memberDecl);
                    this.emitIndent();
                    this.declFile.WriteLine((variableStatement.declaration.declarators.members[0]).id.actualText + ",");
                }
            }
            this.indenter.decreaseIndent();

            this.emitIndent();
            this.declFile.WriteLine("}");

            return false;
        };

        DeclarationEmitter.prototype.ModuleDeclarationCallback = function (pre, moduleDecl) {
            if (TypeScript.hasFlag(moduleDecl.getModuleFlags(), 256 /* IsWholeFile */)) {
                if (TypeScript.hasFlag(moduleDecl.getModuleFlags(), 512 /* IsDynamic */)) {
                    if (pre) {
                        if (!this.emitOptions.outputMany) {
                            this.singleDeclFile = this.declFile;
                            TypeScript.CompilerDiagnostics.assert(this.indenter.indentAmt === 0, "Indent has to be 0 when outputing new file");

                            var declareFileName = this.emitOptions.mapOutputFileName(this.fileName, TypeScript.TypeScriptCompiler.mapToDTSFileName);
                            var useUTF8InOutputfile = moduleDecl.containsUnicodeChar || (this.emitOptions.compilationSettings.emitComments && moduleDecl.containsUnicodeCharInComment);

                            this.declFile = new TextWriter(this.emitOptions.ioHost, declareFileName, this.writeByteOrderMark);
                        }
                        this.pushDeclarationContainer(moduleDecl);
                    } else {
                        if (!this.emitOptions.outputMany) {
                            TypeScript.CompilerDiagnostics.assert(this.singleDeclFile !== this.declFile, "singleDeclFile cannot be null as we are going to revert back to it");
                            TypeScript.CompilerDiagnostics.assert(this.indenter.indentAmt === 0, "Indent has to be 0 when outputing new file");

                            try  {
                                this.declFile.Close();
                            } catch (e) {
                                TypeScript.Emitter.throwEmitterError(e);
                            }

                            this.declFile = this.singleDeclFile;
                        }

                        this.popDeclarationContainer(moduleDecl);
                    }
                }

                return true;
            }

            if (moduleDecl.isEnum()) {
                if (pre) {
                    this.emitEnumSignature(moduleDecl);
                }
                return false;
            }

            if (!this.canEmitPrePostAstSignature(TypeScript.ToDeclFlags(moduleDecl.getModuleFlags()), moduleDecl, pre)) {
                return false;
            }

            if (pre) {
                if (this.emitDottedModuleName()) {
                    this.dottedModuleEmit += ".";
                } else {
                    this.dottedModuleEmit = this.getDeclFlagsString(TypeScript.ToDeclFlags(moduleDecl.getModuleFlags()), "module");
                }

                this.dottedModuleEmit += moduleDecl.name.actualText;

                var isCurrentModuleDotted = (moduleDecl.members.members.length === 1 && moduleDecl.members.members[0].nodeType === 15 /* ModuleDeclaration */ && !(moduleDecl.members.members[0]).isEnum() && TypeScript.hasFlag((moduleDecl.members.members[0]).getModuleFlags(), 1 /* Exported */));

                var moduleDeclComments = moduleDecl.getDocComments();
                isCurrentModuleDotted = isCurrentModuleDotted && (moduleDeclComments === null || moduleDeclComments.length === 0);

                this.isDottedModuleName.push(isCurrentModuleDotted);
                this.pushDeclarationContainer(moduleDecl);

                if (!isCurrentModuleDotted) {
                    this.emitDeclarationComments(moduleDecl);
                    this.declFile.Write(this.dottedModuleEmit);
                    this.declFile.WriteLine(" {");
                    this.indenter.increaseIndent();
                }
            } else {
                if (!this.emitDottedModuleName()) {
                    this.indenter.decreaseIndent();
                    this.emitIndent();
                    this.declFile.WriteLine("}");
                }

                this.popDeclarationContainer(moduleDecl);
                this.isDottedModuleName.pop();
            }

            return true;
        };

        DeclarationEmitter.prototype.ExportAssignmentCallback = function (pre, ast) {
            if (pre) {
                this.emitIndent();
                this.declFile.Write("export = ");
                this.declFile.Write((ast).id.actualText);
                this.declFile.WriteLine(";");
            }

            return false;
        };

        DeclarationEmitter.prototype.ScriptCallback = function (pre, script) {
            if (pre) {
                if (this.emitOptions.outputMany) {
                    for (var i = 0; i < script.referencedFiles.length; i++) {
                        var referencePath = script.referencedFiles[i].path;
                        var declareFileName;
                        if (TypeScript.isRooted(referencePath)) {
                            declareFileName = this.emitOptions.mapOutputFileName(referencePath, TypeScript.TypeScriptCompiler.mapToDTSFileName);
                        } else {
                            declareFileName = TypeScript.getDeclareFilePath(script.referencedFiles[i].path);
                        }
                        this.declFile.WriteLine('/// <reference path="' + declareFileName + '" />');
                    }
                }
                this.pushDeclarationContainer(script);
            } else {
                this.popDeclarationContainer(script);
            }
            return true;
        };

        DeclarationEmitter.prototype.DefaultCallback = function (pre, ast) {
            return !ast.isStatement();
        };
        return DeclarationEmitter;
    })();
    TypeScript.DeclarationEmitter = DeclarationEmitter;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var BloomFilter = (function () {
        function BloomFilter(expectedCount) {
            var m = Math.max(1, BloomFilter.computeM(expectedCount));
            var k = Math.max(1, BloomFilter.computeK(expectedCount));
            ;

            var sizeInEvenBytes = (m + 7) & ~7;

            this.bitArray = [];
            for (var i = 0, len = sizeInEvenBytes; i < len; i++) {
                this.bitArray[i] = false;
            }
            this.hashFunctionCount = k;
        }
        BloomFilter.computeM = function (expectedCount) {
            var p = BloomFilter.falsePositiveProbability;
            var n = expectedCount;

            var numerator = n * Math.log(p);
            var denominator = Math.log(1.0 / Math.pow(2.0, Math.log(2.0)));
            return Math.ceil(numerator / denominator);
        };

        BloomFilter.computeK = function (expectedCount) {
            var n = expectedCount;
            var m = BloomFilter.computeM(expectedCount);

            var temp = Math.log(2.0) * m / n;
            return Math.round(temp);
        };

        BloomFilter.prototype.computeHash = function (key, seed) {
            var m = 0x5bd1e995;
            var r = 24;

            var numberOfCharsLeft = key.length;
            var h = Math.abs(seed ^ numberOfCharsLeft);

            var index = 0;
            while (numberOfCharsLeft >= 2) {
                var c1 = this.getCharacter(key, index);
                var c2 = this.getCharacter(key, index + 1);

                var k = Math.abs(c1 | (c2 << 16));

                k = TypeScript.IntegerUtilities.integerMultiplyLow32Bits(k, m);
                k ^= k >> r;
                k = TypeScript.IntegerUtilities.integerMultiplyLow32Bits(k, m);

                h = TypeScript.IntegerUtilities.integerMultiplyLow32Bits(h, m);
                h ^= k;

                index += 2;
                numberOfCharsLeft -= 2;
            }

            if (numberOfCharsLeft == 1) {
                h ^= this.getCharacter(key, index);
                h = TypeScript.IntegerUtilities.integerMultiplyLow32Bits(h, m);
            }

            h ^= h >> 13;
            h = TypeScript.IntegerUtilities.integerMultiplyLow32Bits(h, m);
            h ^= h >> 15;

            return Math.round(h);
        };

        BloomFilter.prototype.getCharacter = function (key, index) {
            return key.charCodeAt(index);
        };

        BloomFilter.prototype.addKeys = function (keys) {
            for (var name in keys) {
                this.add(name);
            }
        };

        BloomFilter.prototype.add = function (value) {
            for (var i = 0; i < this.hashFunctionCount; i++) {
                var hash = this.computeHash(value, i);
                hash = hash % this.bitArray.length;
                this.bitArray[Math.abs(hash)] = true;
            }
        };

        BloomFilter.prototype.probablyContains = function (value) {
            for (var i = 0; i < this.hashFunctionCount; i++) {
                var hash = this.computeHash(value, i);
                hash = hash % this.bitArray.length;
                if (!this.bitArray[Math.abs(hash)]) {
                    return false;
                }
            }

            return true;
        };

        BloomFilter.prototype.isEquivalent = function (filter) {
            return BloomFilter.isEquivalent(this.bitArray, filter.bitArray) && this.hashFunctionCount == filter.hashFunctionCount;
        };

        BloomFilter.isEquivalent = function (array1, array2) {
            if (array1.length != array2.length) {
                return false;
            }

            for (var i = 0; i < array1.length; i++) {
                if (array1[i] != array2[i]) {
                    return false;
                }
            }

            return true;
        };
        BloomFilter.falsePositiveProbability = 0.0001;
        return BloomFilter;
    })();
    TypeScript.BloomFilter = BloomFilter;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var IdentifierWalker = (function (_super) {
        __extends(IdentifierWalker, _super);
        function IdentifierWalker(list) {
            _super.call(this);
            this.list = list;
        }
        IdentifierWalker.prototype.visitToken = function (token) {
            this.list[token.text()] = true;
        };
        return IdentifierWalker;
    })(TypeScript.SyntaxWalker);
    TypeScript.IdentifierWalker = IdentifierWalker;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var DataMap = (function () {
        function DataMap() {
            this.map = {};
        }
        DataMap.prototype.link = function (id, data) {
            this.map[id] = data;
        };

        DataMap.prototype.unlink = function (id) {
            this.map[id] = undefined;
        };

        DataMap.prototype.read = function (id) {
            return this.map[id];
        };

        DataMap.prototype.flush = function () {
            this.map = {};
        };

        DataMap.prototype.unpatch = function () {
            return null;
        };
        return DataMap;
    })();
    TypeScript.DataMap = DataMap;

    var PatchedDataMap = (function (_super) {
        __extends(PatchedDataMap, _super);
        function PatchedDataMap(parent) {
            _super.call(this);
            this.parent = parent;
            this.diffs = {};
        }
        PatchedDataMap.prototype.link = function (id, data) {
            this.diffs[id] = data;
        };

        PatchedDataMap.prototype.unlink = function (id) {
            this.diffs[id] = undefined;
        };

        PatchedDataMap.prototype.read = function (id) {
            var data = this.diffs[id];

            if (data) {
                return data;
            }

            return this.parent.read(id);
        };

        PatchedDataMap.prototype.flush = function () {
            this.diffs = {};
        };

        PatchedDataMap.prototype.unpatch = function () {
            this.flush();
            return this.parent;
        };
        return PatchedDataMap;
    })(DataMap);
    TypeScript.PatchedDataMap = PatchedDataMap;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (PullElementFlags) {
        PullElementFlags[PullElementFlags["None"] = 0] = "None";
        PullElementFlags[PullElementFlags["Exported"] = 1] = "Exported";
        PullElementFlags[PullElementFlags["Private"] = 1 << 1] = "Private";
        PullElementFlags[PullElementFlags["Public"] = 1 << 2] = "Public";
        PullElementFlags[PullElementFlags["Ambient"] = 1 << 3] = "Ambient";
        PullElementFlags[PullElementFlags["Static"] = 1 << 4] = "Static";
        PullElementFlags[PullElementFlags["GetAccessor"] = 1 << 5] = "GetAccessor";
        PullElementFlags[PullElementFlags["SetAccessor"] = 1 << 6] = "SetAccessor";
        PullElementFlags[PullElementFlags["Optional"] = 1 << 7] = "Optional";
        PullElementFlags[PullElementFlags["Call"] = 1 << 8] = "Call";
        PullElementFlags[PullElementFlags["Constructor"] = 1 << 9] = "Constructor";
        PullElementFlags[PullElementFlags["Index"] = 1 << 10] = "Index";
        PullElementFlags[PullElementFlags["Signature"] = 1 << 11] = "Signature";
        PullElementFlags[PullElementFlags["Enum"] = 1 << 12] = "Enum";
        PullElementFlags[PullElementFlags["FatArrow"] = 1 << 13] = "FatArrow";

        PullElementFlags[PullElementFlags["ClassConstructorVariable"] = 1 << 14] = "ClassConstructorVariable";
        PullElementFlags[PullElementFlags["InitializedModule"] = 1 << 15] = "InitializedModule";
        PullElementFlags[PullElementFlags["InitializedDynamicModule"] = 1 << 16] = "InitializedDynamicModule";
        PullElementFlags[PullElementFlags["InitializedEnum"] = 1 << 17] = "InitializedEnum";

        PullElementFlags[PullElementFlags["MustCaptureThis"] = 1 << 18] = "MustCaptureThis";
        PullElementFlags[PullElementFlags["Constant"] = 1 << 19] = "Constant";

        PullElementFlags[PullElementFlags["ExpressionElement"] = 1 << 20] = "ExpressionElement";

        PullElementFlags[PullElementFlags["DeclaredInAWithBlock"] = 1 << 21] = "DeclaredInAWithBlock";

        PullElementFlags[PullElementFlags["ImplicitVariable"] = PullElementFlags.ClassConstructorVariable | PullElementFlags.InitializedModule | PullElementFlags.InitializedDynamicModule | PullElementFlags.InitializedEnum] = "ImplicitVariable";
        PullElementFlags[PullElementFlags["SomeInitializedModule"] = PullElementFlags.InitializedModule | PullElementFlags.InitializedDynamicModule | PullElementFlags.InitializedEnum] = "SomeInitializedModule";
    })(TypeScript.PullElementFlags || (TypeScript.PullElementFlags = {}));
    var PullElementFlags = TypeScript.PullElementFlags;

    (function (PullElementKind) {
        PullElementKind[PullElementKind["None"] = 0] = "None";
        PullElementKind[PullElementKind["Global"] = 0] = "Global";

        PullElementKind[PullElementKind["Script"] = 1] = "Script";
        PullElementKind[PullElementKind["Primitive"] = 1 << 1] = "Primitive";

        PullElementKind[PullElementKind["Container"] = 1 << 2] = "Container";
        PullElementKind[PullElementKind["Class"] = 1 << 3] = "Class";
        PullElementKind[PullElementKind["Interface"] = 1 << 4] = "Interface";
        PullElementKind[PullElementKind["DynamicModule"] = 1 << 5] = "DynamicModule";
        PullElementKind[PullElementKind["Enum"] = 1 << 6] = "Enum";
        PullElementKind[PullElementKind["Array"] = 1 << 7] = "Array";
        PullElementKind[PullElementKind["TypeAlias"] = 1 << 8] = "TypeAlias";
        PullElementKind[PullElementKind["ObjectLiteral"] = 1 << 9] = "ObjectLiteral";

        PullElementKind[PullElementKind["Variable"] = 1 << 10] = "Variable";
        PullElementKind[PullElementKind["Parameter"] = 1 << 11] = "Parameter";
        PullElementKind[PullElementKind["Property"] = 1 << 12] = "Property";
        PullElementKind[PullElementKind["TypeParameter"] = 1 << 13] = "TypeParameter";

        PullElementKind[PullElementKind["Function"] = 1 << 14] = "Function";
        PullElementKind[PullElementKind["ConstructorMethod"] = 1 << 15] = "ConstructorMethod";
        PullElementKind[PullElementKind["Method"] = 1 << 16] = "Method";
        PullElementKind[PullElementKind["FunctionExpression"] = 1 << 17] = "FunctionExpression";

        PullElementKind[PullElementKind["GetAccessor"] = 1 << 18] = "GetAccessor";
        PullElementKind[PullElementKind["SetAccessor"] = 1 << 19] = "SetAccessor";

        PullElementKind[PullElementKind["CallSignature"] = 1 << 20] = "CallSignature";
        PullElementKind[PullElementKind["ConstructSignature"] = 1 << 21] = "ConstructSignature";
        PullElementKind[PullElementKind["IndexSignature"] = 1 << 22] = "IndexSignature";

        PullElementKind[PullElementKind["ObjectType"] = 1 << 23] = "ObjectType";
        PullElementKind[PullElementKind["FunctionType"] = 1 << 24] = "FunctionType";
        PullElementKind[PullElementKind["ConstructorType"] = 1 << 25] = "ConstructorType";

        PullElementKind[PullElementKind["EnumMember"] = 1 << 26] = "EnumMember";
        PullElementKind[PullElementKind["ErrorType"] = 1 << 27] = "ErrorType";

        PullElementKind[PullElementKind["Expression"] = 1 << 28] = "Expression";

        PullElementKind[PullElementKind["WithBlock"] = 1 << 29] = "WithBlock";
        PullElementKind[PullElementKind["CatchBlock"] = 1 << 30] = "CatchBlock";

        PullElementKind[PullElementKind["All"] = PullElementKind.Script | PullElementKind.Global | PullElementKind.Primitive | PullElementKind.Container | PullElementKind.Class | PullElementKind.Interface | PullElementKind.DynamicModule | PullElementKind.Enum | PullElementKind.Array | PullElementKind.TypeAlias | PullElementKind.ObjectLiteral | PullElementKind.Variable | PullElementKind.Parameter | PullElementKind.Property | PullElementKind.TypeParameter | PullElementKind.Function | PullElementKind.ConstructorMethod | PullElementKind.Method | PullElementKind.FunctionExpression | PullElementKind.GetAccessor | PullElementKind.SetAccessor | PullElementKind.CallSignature | PullElementKind.ConstructSignature | PullElementKind.IndexSignature | PullElementKind.ObjectType | PullElementKind.FunctionType | PullElementKind.ConstructorType | PullElementKind.EnumMember | PullElementKind.ErrorType | PullElementKind.Expression | PullElementKind.WithBlock | PullElementKind.CatchBlock] = "All";

        PullElementKind[PullElementKind["SomeFunction"] = PullElementKind.Function | PullElementKind.ConstructorMethod | PullElementKind.Method | PullElementKind.FunctionExpression | PullElementKind.GetAccessor | PullElementKind.SetAccessor | PullElementKind.CallSignature | PullElementKind.ConstructSignature | PullElementKind.IndexSignature] = "SomeFunction";

        PullElementKind[PullElementKind["SomeValue"] = PullElementKind.Variable | PullElementKind.Parameter | PullElementKind.Property | PullElementKind.EnumMember | PullElementKind.SomeFunction] = "SomeValue";

        PullElementKind[PullElementKind["SomeType"] = PullElementKind.Script | PullElementKind.Global | PullElementKind.Primitive | PullElementKind.Class | PullElementKind.Interface | PullElementKind.Enum | PullElementKind.Array | PullElementKind.ObjectType | PullElementKind.FunctionType | PullElementKind.ConstructorType | PullElementKind.TypeParameter | PullElementKind.ErrorType] = "SomeType";

        PullElementKind[PullElementKind["AcceptableAlias"] = PullElementKind.Variable | PullElementKind.SomeFunction | PullElementKind.Class | PullElementKind.Interface | PullElementKind.Enum | PullElementKind.Container | PullElementKind.ObjectType | PullElementKind.FunctionType | PullElementKind.ConstructorType] = "AcceptableAlias";

        PullElementKind[PullElementKind["SomeContainer"] = PullElementKind.Container | PullElementKind.DynamicModule | PullElementKind.TypeAlias] = "SomeContainer";

        PullElementKind[PullElementKind["SomeBlock"] = PullElementKind.WithBlock | PullElementKind.CatchBlock] = "SomeBlock";

        PullElementKind[PullElementKind["SomeSignature"] = PullElementKind.CallSignature | PullElementKind.ConstructSignature | PullElementKind.IndexSignature] = "SomeSignature";

        PullElementKind[PullElementKind["SomeAccessor"] = PullElementKind.GetAccessor | PullElementKind.SetAccessor] = "SomeAccessor";

        PullElementKind[PullElementKind["SomeTypeReference"] = PullElementKind.Interface | PullElementKind.ObjectType | PullElementKind.FunctionType | PullElementKind.ConstructorType] = "SomeTypeReference";

        PullElementKind[PullElementKind["SomeLHS"] = PullElementKind.Variable | PullElementKind.Property | PullElementKind.Parameter | PullElementKind.SetAccessor | PullElementKind.Method] = "SomeLHS";

        PullElementKind[PullElementKind["InterfaceTypeExtension"] = PullElementKind.Interface | PullElementKind.Class | PullElementKind.Enum] = "InterfaceTypeExtension";
        PullElementKind[PullElementKind["ClassTypeExtension"] = PullElementKind.Interface | PullElementKind.Class] = "ClassTypeExtension";
        PullElementKind[PullElementKind["EnumTypeExtension"] = PullElementKind.Interface | PullElementKind.Enum] = "EnumTypeExtension";
    })(TypeScript.PullElementKind || (TypeScript.PullElementKind = {}));
    var PullElementKind = TypeScript.PullElementKind;

    (function (SymbolLinkKind) {
        SymbolLinkKind[SymbolLinkKind["TypedAs"] = 0] = "TypedAs";
        SymbolLinkKind[SymbolLinkKind["ContextuallyTypedAs"] = 1] = "ContextuallyTypedAs";
        SymbolLinkKind[SymbolLinkKind["ProvidesInferredType"] = 2] = "ProvidesInferredType";
        SymbolLinkKind[SymbolLinkKind["ArrayType"] = 3] = "ArrayType";

        SymbolLinkKind[SymbolLinkKind["ArrayOf"] = 4] = "ArrayOf";

        SymbolLinkKind[SymbolLinkKind["PublicMember"] = 5] = "PublicMember";
        SymbolLinkKind[SymbolLinkKind["PrivateMember"] = 6] = "PrivateMember";

        SymbolLinkKind[SymbolLinkKind["ConstructorMethod"] = 7] = "ConstructorMethod";

        SymbolLinkKind[SymbolLinkKind["Aliases"] = 8] = "Aliases";
        SymbolLinkKind[SymbolLinkKind["ExportAliases"] = 9] = "ExportAliases";

        SymbolLinkKind[SymbolLinkKind["ContainedBy"] = 10] = "ContainedBy";

        SymbolLinkKind[SymbolLinkKind["Extends"] = 11] = "Extends";
        SymbolLinkKind[SymbolLinkKind["Implements"] = 12] = "Implements";

        SymbolLinkKind[SymbolLinkKind["Parameter"] = 13] = "Parameter";
        SymbolLinkKind[SymbolLinkKind["ReturnType"] = 14] = "ReturnType";

        SymbolLinkKind[SymbolLinkKind["CallSignature"] = 15] = "CallSignature";
        SymbolLinkKind[SymbolLinkKind["ConstructSignature"] = 16] = "ConstructSignature";
        SymbolLinkKind[SymbolLinkKind["IndexSignature"] = 17] = "IndexSignature";

        SymbolLinkKind[SymbolLinkKind["TypeParameter"] = 18] = "TypeParameter";
        SymbolLinkKind[SymbolLinkKind["TypeArgument"] = 19] = "TypeArgument";
        SymbolLinkKind[SymbolLinkKind["TypeParameterSpecializedTo"] = 20] = "TypeParameterSpecializedTo";
        SymbolLinkKind[SymbolLinkKind["SpecializedTo"] = 21] = "SpecializedTo";

        SymbolLinkKind[SymbolLinkKind["TypeConstraint"] = 22] = "TypeConstraint";

        SymbolLinkKind[SymbolLinkKind["ContributesToExpression"] = 23] = "ContributesToExpression";

        SymbolLinkKind[SymbolLinkKind["GetterFunction"] = 24] = "GetterFunction";
        SymbolLinkKind[SymbolLinkKind["SetterFunction"] = 25] = "SetterFunction";
    })(TypeScript.SymbolLinkKind || (TypeScript.SymbolLinkKind = {}));
    var SymbolLinkKind = TypeScript.SymbolLinkKind;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.pullDeclID = 0;
    TypeScript.lastBoundPullDeclId = 0;

    var PullDecl = (function () {
        function PullDecl(declName, displayName, declType, declFlags, span, scriptName) {
            this.symbol = null;
            this.declGroups = new TypeScript.BlockIntrinsics();
            this.signatureSymbol = null;
            this.specializingSignatureSymbol = null;
            this.childDecls = [];
            this.typeParameters = [];
            this.childDeclTypeCache = new TypeScript.BlockIntrinsics();
            this.childDeclValueCache = new TypeScript.BlockIntrinsics();
            this.childDeclNamespaceCache = new TypeScript.BlockIntrinsics();
            this.childDeclTypeParameterCache = new TypeScript.BlockIntrinsics();
            this.declID = TypeScript.pullDeclID++;
            this.declFlags = 0 /* None */;
            this.diagnostics = null;
            this.parentDecl = null;
            this._parentPath = null;
            this._isBound = false;
            this.synthesizedValDecl = null;
            this.declName = declName;
            this.declType = declType;
            this.declFlags = declFlags;
            this.span = span;
            this.scriptName = scriptName;

            if (displayName !== this.declName) {
                this.declDisplayName = displayName;
            }
        }
        PullDecl.prototype.getDeclID = function () {
            return this.declID;
        };

        PullDecl.prototype.getName = function () {
            return this.declName;
        };
        PullDecl.prototype.getKind = function () {
            return this.declType;
        };

        PullDecl.prototype.getDisplayName = function () {
            return this.declDisplayName === undefined ? this.declName : this.declDisplayName;
        };

        PullDecl.prototype.setSymbol = function (symbol) {
            this.symbol = symbol;
        };

        PullDecl.prototype.ensureSymbolIsBound = function (bindSignatureSymbol) {
            if (typeof bindSignatureSymbol === "undefined") { bindSignatureSymbol = false; }
            if (!((bindSignatureSymbol && this.signatureSymbol) || this.symbol) && !this._isBound && this.declType != 1 /* Script */) {
                var prevUnit = TypeScript.globalBinder.semanticInfo;
                TypeScript.globalBinder.setUnit(this.scriptName);
                TypeScript.globalBinder.bindDeclToPullSymbol(this);
                if (prevUnit) {
                    TypeScript.globalBinder.setUnit(prevUnit.getPath());
                }
            }
        };

        PullDecl.prototype.getSymbol = function () {
            if (this.declType == 1 /* Script */) {
                return null;
            }

            this.ensureSymbolIsBound();

            return this.symbol;
        };

        PullDecl.prototype.hasSymbol = function () {
            return this.symbol != null;
        };

        PullDecl.prototype.setSignatureSymbol = function (signature) {
            this.signatureSymbol = signature;
        };
        PullDecl.prototype.getSignatureSymbol = function () {
            this.ensureSymbolIsBound(true);

            return this.signatureSymbol;
        };

        PullDecl.prototype.hasSignature = function () {
            return this.signatureSymbol != null;
        };

        PullDecl.prototype.setSpecializingSignatureSymbol = function (signature) {
            this.specializingSignatureSymbol = signature;
        };
        PullDecl.prototype.getSpecializingSignatureSymbol = function () {
            if (this.specializingSignatureSymbol) {
                return this.specializingSignatureSymbol;
            }

            return this.signatureSymbol;
        };

        PullDecl.prototype.getFlags = function () {
            return this.declFlags;
        };
        PullDecl.prototype.setFlags = function (flags) {
            this.declFlags = flags;
        };

        PullDecl.prototype.getSpan = function () {
            return this.span;
        };
        PullDecl.prototype.setSpan = function (span) {
            this.span = span;
        };

        PullDecl.prototype.getScriptName = function () {
            return this.scriptName;
        };

        PullDecl.prototype.setValueDecl = function (valDecl) {
            this.synthesizedValDecl = valDecl;
        };
        PullDecl.prototype.getValueDecl = function () {
            return this.synthesizedValDecl;
        };

        PullDecl.prototype.isEqual = function (other) {
            return (this.declName === other.declName) && (this.declType === other.declType) && (this.declFlags === other.declFlags) && (this.scriptName === other.scriptName) && (this.span.start() === other.span.start()) && (this.span.end() === other.span.end());
        };

        PullDecl.prototype.getParentDecl = function () {
            return this.parentDecl;
        };

        PullDecl.prototype.setParentDecl = function (parentDecl) {
            this.parentDecl = parentDecl;
        };

        PullDecl.prototype.addDiagnostic = function (diagnostic) {
            if (diagnostic) {
                if (!this.diagnostics) {
                    this.diagnostics = [];
                }

                this.diagnostics[this.diagnostics.length] = diagnostic;
            }
        };

        PullDecl.prototype.getDiagnostics = function () {
            return this.diagnostics;
        };

        PullDecl.prototype.setErrors = function (diagnostics) {
            if (diagnostics) {
                this.diagnostics = [];

                for (var i = 0; i < diagnostics.length; i++) {
                    diagnostics[i].adjustOffset(this.span.start());
                    this.diagnostics[this.diagnostics.length] = diagnostics[i];
                }
            }
        };

        PullDecl.prototype.resetErrors = function () {
            this.diagnostics = [];
        };

        PullDecl.prototype.getChildDeclCache = function (declKind) {
            return declKind === 8192 /* TypeParameter */ ? this.childDeclTypeParameterCache : TypeScript.hasFlag(declKind, TypeScript.PullElementKind.SomeContainer) ? this.childDeclNamespaceCache : TypeScript.hasFlag(declKind, TypeScript.PullElementKind.SomeType) ? this.childDeclTypeCache : this.childDeclValueCache;
        };

        PullDecl.prototype.addChildDecl = function (childDecl) {
            if (childDecl.getKind() === 8192 /* TypeParameter */) {
                this.typeParameters[this.typeParameters.length] = childDecl;
            } else {
                this.childDecls[this.childDecls.length] = childDecl;
            }

            var declName = childDecl.getName();
            var cache = this.getChildDeclCache(childDecl.getKind());
            var childrenOfName = cache[declName];
            if (!childrenOfName) {
                childrenOfName = [];
            }

            childrenOfName.push(childDecl);
            cache[declName] = childrenOfName;
        };

        PullDecl.prototype.searchChildDecls = function (declName, searchKind) {
            var cache = (searchKind & TypeScript.PullElementKind.SomeType) ? this.childDeclTypeCache : (searchKind & TypeScript.PullElementKind.SomeContainer) ? this.childDeclNamespaceCache : this.childDeclValueCache;

            var cacheVal = cache[declName];

            if (cacheVal) {
                return cacheVal;
            } else {
                if (searchKind & TypeScript.PullElementKind.SomeType) {
                    cacheVal = this.childDeclTypeParameterCache[declName];

                    if (cacheVal) {
                        return cacheVal;
                    }
                }

                return [];
            }
        };

        PullDecl.prototype.getChildDecls = function () {
            return this.childDecls;
        };
        PullDecl.prototype.getTypeParameters = function () {
            return this.typeParameters;
        };

        PullDecl.prototype.addVariableDeclToGroup = function (decl) {
            var declGroup = this.declGroups[decl.getName()];
            if (declGroup) {
                declGroup.addDecl(decl);
            } else {
                declGroup = new PullDeclGroup(decl.getName());
                declGroup.addDecl(decl);
                this.declGroups[decl.getName()] = declGroup;
            }
        };

        PullDecl.prototype.getVariableDeclGroups = function () {
            var declGroups = [];

            for (var declName in this.declGroups) {
                if (this.declGroups[declName]) {
                    declGroups[declGroups.length] = this.declGroups[declName].getDecls();
                }
            }

            return declGroups;
        };

        PullDecl.prototype.getParentPath = function () {
            return this._parentPath;
        };

        PullDecl.prototype.setParentPath = function (path) {
            this._parentPath = path;
        };

        PullDecl.prototype.setIsBound = function (isBinding) {
            this._isBound = isBinding;
        };

        PullDecl.prototype.isBound = function () {
            return this._isBound;
        };
        return PullDecl;
    })();
    TypeScript.PullDecl = PullDecl;

    var PullFunctionExpressionDecl = (function (_super) {
        __extends(PullFunctionExpressionDecl, _super);
        function PullFunctionExpressionDecl(expressionName, declFlags, span, scriptName) {
            _super.call(this, "", "", 131072 /* FunctionExpression */, declFlags, span, scriptName);
            this.functionExpressionName = expressionName;
        }
        PullFunctionExpressionDecl.prototype.getFunctionExpressionName = function () {
            return this.functionExpressionName;
        };
        return PullFunctionExpressionDecl;
    })(PullDecl);
    TypeScript.PullFunctionExpressionDecl = PullFunctionExpressionDecl;

    var PullDeclGroup = (function () {
        function PullDeclGroup(name) {
            this.name = name;
            this._decls = [];
        }
        PullDeclGroup.prototype.addDecl = function (decl) {
            if (decl.getName() === this.name) {
                this._decls[this._decls.length] = decl;
            }
        };

        PullDeclGroup.prototype.getDecls = function () {
            return this._decls;
        };
        return PullDeclGroup;
    })();
    TypeScript.PullDeclGroup = PullDeclGroup;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.pullSymbolID = 0;
    TypeScript.lastBoundPullSymbolID = 0;
    TypeScript.globalTyvarID = 0;

    var PullSymbol = (function () {
        function PullSymbol(name, declKind) {
            this.pullSymbolID = TypeScript.pullSymbolID++;
            this.outgoingLinks = new TypeScript.LinkList();
            this.incomingLinks = new TypeScript.LinkList();
            this.declarations = new TypeScript.LinkList();
            this.cachedPathIDs = {};
            this.cachedContainerLink = null;
            this.cachedTypeLink = null;
            this.cachedDeclarations = null;
            this.hasBeenResolved = false;
            this.isOptional = false;
            this.inResolution = false;
            this.isSynthesized = false;
            this.isBound = false;
            this.rebindingID = 0;
            this.isVarArg = false;
            this.isSpecialized = false;
            this.isBeingSpecialized = false;
            this.rootSymbol = null;
            this.typeChangeUpdateVersion = -1;
            this.addUpdateVersion = -1;
            this.removeUpdateVersion = -1;
            this.docComments = null;
            this.isPrinting = false;
            this.name = name;
            this.declKind = declKind;
        }
        PullSymbol.prototype.getSymbolID = function () {
            return this.pullSymbolID;
        };

        PullSymbol.prototype.isType = function () {
            return (this.declKind & TypeScript.PullElementKind.SomeType) != 0;
        };

        PullSymbol.prototype.isSignature = function () {
            return (this.declKind & TypeScript.PullElementKind.SomeSignature) != 0;
        };

        PullSymbol.prototype.isArray = function () {
            return (this.declKind & 128 /* Array */) != 0;
        };

        PullSymbol.prototype.isPrimitive = function () {
            return this.declKind === 2 /* Primitive */;
        };

        PullSymbol.prototype.isAccessor = function () {
            return false;
        };

        PullSymbol.prototype.isError = function () {
            return false;
        };

        PullSymbol.prototype.isAlias = function () {
            return false;
        };
        PullSymbol.prototype.isContainer = function () {
            return false;
        };

        PullSymbol.prototype.findAliasedType = function (decls) {
            for (var i = 0; i < decls.length; i++) {
                var childDecls = decls[i].getChildDecls();
                for (var j = 0; j < childDecls.length; j++) {
                    if (childDecls[j].getKind() === 256 /* TypeAlias */) {
                        var symbol = childDecls[j].getSymbol();
                        if (PullContainerTypeSymbol.usedAsSymbol(symbol, this)) {
                            return symbol;
                        }
                    }
                }
            }

            return null;
        };

        PullSymbol.prototype.getAliasedSymbol = function (scopeSymbol) {
            if (!scopeSymbol) {
                return null;
            }

            var scopePath = scopeSymbol.pathToRoot();
            if (scopePath.length && scopePath[scopePath.length - 1].getKind() === 32 /* DynamicModule */) {
                var decls = scopePath[scopePath.length - 1].getDeclarations();
                var symbol = this.findAliasedType(decls);
                return symbol;
            }

            return null;
        };

        PullSymbol.prototype.getName = function (scopeSymbol, useConstraintInName) {
            var symbol = this.getAliasedSymbol(scopeSymbol);
            if (symbol) {
                return symbol.getName();
            }

            return this.name;
        };

        PullSymbol.prototype.getDisplayName = function (scopeSymbol, useConstraintInName) {
            var symbol = this.getAliasedSymbol(scopeSymbol);
            if (symbol) {
                return symbol.getDisplayName();
            }

            return this.getDeclarations()[0].getDisplayName();
        };

        PullSymbol.prototype.getKind = function () {
            return this.declKind;
        };
        PullSymbol.prototype.setKind = function (declType) {
            this.declKind = declType;
        };

        PullSymbol.prototype.setIsOptional = function () {
            this.isOptional = true;
        };
        PullSymbol.prototype.getIsOptional = function () {
            return this.isOptional;
        };

        PullSymbol.prototype.getIsVarArg = function () {
            return this.isVarArg;
        };
        PullSymbol.prototype.setIsVarArg = function () {
            this.isVarArg = true;
        };

        PullSymbol.prototype.setIsSynthesized = function () {
            this.isSynthesized = true;
        };
        PullSymbol.prototype.getIsSynthesized = function () {
            return this.isSynthesized;
        };

        PullSymbol.prototype.setIsSpecialized = function () {
            this.isSpecialized = true;
            this.isBeingSpecialized = false;
        };
        PullSymbol.prototype.getIsSpecialized = function () {
            return this.isSpecialized;
        };
        PullSymbol.prototype.currentlyBeingSpecialized = function () {
            return this.isBeingSpecialized;
        };
        PullSymbol.prototype.setIsBeingSpecialized = function () {
            this.isBeingSpecialized = true;
        };
        PullSymbol.prototype.setValueIsBeingSpecialized = function (val) {
            this.isBeingSpecialized = val;
        };

        PullSymbol.prototype.getRootSymbol = function () {
            if (!this.rootSymbol) {
                return this;
            }
            return this.rootSymbol;
        };
        PullSymbol.prototype.setRootSymbol = function (symbol) {
            this.rootSymbol = symbol;
        };

        PullSymbol.prototype.setIsBound = function (rebindingID) {
            this.isBound = true;
            this.rebindingID = rebindingID;
        };

        PullSymbol.prototype.getRebindingID = function () {
            return this.rebindingID;
        };

        PullSymbol.prototype.getIsBound = function () {
            return this.isBound;
        };

        PullSymbol.prototype.addCacheID = function (cacheID) {
            if (!this.cachedPathIDs[cacheID]) {
                this.cachedPathIDs[cacheID] = true;
            }
        };

        PullSymbol.prototype.invalidateCachedIDs = function (cache) {
            for (var id in this.cachedPathIDs) {
                if (cache[id]) {
                    cache[id] = undefined;
                }
            }
        };

        PullSymbol.prototype.addDeclaration = function (decl) {
            TypeScript.Debug.assert(!!decl);

            if (this.rootSymbol) {
                return;
            }

            this.declarations.addItem(decl);

            if (!this.cachedDeclarations) {
                this.cachedDeclarations = [decl];
            } else {
                this.cachedDeclarations[this.cachedDeclarations.length] = decl;
            }
        };

        PullSymbol.prototype.getDeclarations = function () {
            if (this.rootSymbol) {
                return this.rootSymbol.getDeclarations();
            }

            if (!this.cachedDeclarations) {
                this.cachedDeclarations = [];
            }

            return this.cachedDeclarations;
        };

        PullSymbol.prototype.removeDeclaration = function (decl) {
            if (this.rootSymbol) {
                return;
            }

            this.declarations.remove(function (d) {
                return d === decl;
            });
            this.cachedDeclarations = this.declarations.find(function (d) {
                return d;
            });
        };

        PullSymbol.prototype.updateDeclarations = function (map, context) {
            if (this.rootSymbol) {
                return;
            }

            this.declarations.update(map, context);
        };

        PullSymbol.prototype.addOutgoingLink = function (linkTo, kind) {
            var link = new TypeScript.PullSymbolLink(this, linkTo, kind);
            this.outgoingLinks.addItem(link);
            linkTo.incomingLinks.addItem(link);

            return link;
        };

        PullSymbol.prototype.findOutgoingLinks = function (p) {
            return this.outgoingLinks.find(p);
        };

        PullSymbol.prototype.findIncomingLinks = function (p) {
            return this.incomingLinks.find(p);
        };

        PullSymbol.prototype.removeOutgoingLink = function (link) {
            if (link) {
                this.outgoingLinks.remove(function (p) {
                    return p === link;
                });

                if (link.end.incomingLinks) {
                    link.end.incomingLinks.remove(function (p) {
                        return p === link;
                    });
                }
            }
        };

        PullSymbol.prototype.updateOutgoingLinks = function (map, context) {
            if (this.outgoingLinks) {
                this.outgoingLinks.update(map, context);
            }
        };

        PullSymbol.prototype.updateIncomingLinks = function (map, context) {
            if (this.incomingLinks) {
                this.incomingLinks.update(map, context);
            }
        };

        PullSymbol.prototype.removeAllLinks = function () {
            var _this = this;
            this.updateOutgoingLinks(function (item) {
                return _this.removeOutgoingLink(item);
            }, null);
            this.updateIncomingLinks(function (item) {
                return item.start.removeOutgoingLink(item);
            }, null);
        };

        PullSymbol.prototype.setContainer = function (containerSymbol) {
            var link = this.addOutgoingLink(containerSymbol, 10 /* ContainedBy */);
            this.cachedContainerLink = link;

            containerSymbol.addContainedByLink(link);
        };

        PullSymbol.prototype.getContainer = function () {
            if (this.cachedContainerLink) {
                return this.cachedContainerLink.end;
            }

            if (this.getIsSpecialized()) {
                var specializations = this.findIncomingLinks(function (symbolLink) {
                    return symbolLink.kind == 21 /* SpecializedTo */;
                });
                if (specializations.length == 1) {
                    return specializations[0].start.getContainer();
                }
            }

            return null;
        };

        PullSymbol.prototype.unsetContainer = function () {
            if (this.cachedContainerLink) {
                this.removeOutgoingLink(this.cachedContainerLink);
            }

            this.invalidate();
        };

        PullSymbol.prototype.setType = function (typeRef) {
            if (this.cachedTypeLink) {
                this.unsetType();
            }

            this.cachedTypeLink = this.addOutgoingLink(typeRef, 0 /* TypedAs */);
        };

        PullSymbol.prototype.getType = function () {
            if (this.cachedTypeLink) {
                return this.cachedTypeLink.end;
            }

            return null;
        };

        PullSymbol.prototype.unsetType = function () {
            var foundType = false;

            if (this.cachedTypeLink) {
                this.removeOutgoingLink(this.cachedTypeLink);
                foundType = true;
            }

            if (foundType) {
                this.invalidate();
            }
        };

        PullSymbol.prototype.isTyped = function () {
            return this.getType() != null;
        };

        PullSymbol.prototype.setResolved = function () {
            this.hasBeenResolved = true;
            this.inResolution = false;
        };
        PullSymbol.prototype.isResolved = function () {
            return this.hasBeenResolved;
        };

        PullSymbol.prototype.startResolving = function () {
            this.inResolution = true;
        };
        PullSymbol.prototype.isResolving = function () {
            return this.inResolution;
        };

        PullSymbol.prototype.setUnresolved = function () {
            this.hasBeenResolved = false;
            this.isBound = false;
            this.inResolution = false;
        };

        PullSymbol.prototype.invalidate = function () {
            this.docComments = null;

            this.hasBeenResolved = false;
            this.isBound = false;

            this.declarations.update(function (pullDecl) {
                return pullDecl.resetErrors();
            }, null);
        };

        PullSymbol.prototype.hasFlag = function (flag) {
            var declarations = this.getDeclarations();
            for (var i = 0, n = declarations.length; i < n; i++) {
                if ((declarations[i].getFlags() & flag) !== 0 /* None */) {
                    return true;
                }
            }
            return false;
        };

        PullSymbol.prototype.allDeclsHaveFlag = function (flag) {
            var declarations = this.getDeclarations();
            for (var i = 0, n = declarations.length; i < n; i++) {
                if (!((declarations[i].getFlags() & flag) !== 0 /* None */)) {
                    return false;
                }
            }
            return true;
        };

        PullSymbol.prototype.pathToRoot = function () {
            var path = [];
            var node = this;
            while (node) {
                if (node.isType()) {
                    var associatedContainerSymbol = (node).getAssociatedContainerType();
                    if (associatedContainerSymbol) {
                        node = associatedContainerSymbol;
                    }
                }
                path[path.length] = node;
                node = node.getContainer();
            }
            return path;
        };

        PullSymbol.prototype.findCommonAncestorPath = function (b) {
            var aPath = this.pathToRoot();
            if (aPath.length === 1) {
                return aPath;
            }

            var bPath;
            if (b) {
                bPath = b.pathToRoot();
            } else {
                return aPath;
            }

            var commonNodeIndex = -1;
            for (var i = 0, aLen = aPath.length; i < aLen; i++) {
                var aNode = aPath[i];
                for (var j = 0, bLen = bPath.length; j < bLen; j++) {
                    var bNode = bPath[j];
                    if (aNode === bNode) {
                        var aDecl = null;
                        if (i > 0) {
                            var decls = aPath[i - 1].getDeclarations();
                            if (decls.length) {
                                aDecl = decls[0].getParentDecl();
                            }
                        }
                        var bDecl = null;
                        if (j > 0) {
                            var decls = bPath[j - 1].getDeclarations();
                            if (decls.length) {
                                bDecl = decls[0].getParentDecl();
                            }
                        }
                        if (!aDecl || !bDecl || aDecl == bDecl) {
                            commonNodeIndex = i;
                            break;
                        }
                    }
                }
                if (commonNodeIndex >= 0) {
                    break;
                }
            }

            if (commonNodeIndex >= 0) {
                return aPath.slice(0, commonNodeIndex);
            } else {
                return aPath;
            }
        };

        PullSymbol.prototype.toString = function (useConstraintInName) {
            var str = this.getNameAndTypeName();
            return str;
        };

        PullSymbol.prototype.getNamePartForFullName = function () {
            return this.getDisplayName(null, true);
        };

        PullSymbol.prototype.fullName = function (scopeSymbol) {
            var path = this.pathToRoot();
            var fullName = "";
            var aliasedSymbol = this.getAliasedSymbol(scopeSymbol);
            if (aliasedSymbol) {
                return aliasedSymbol.getDisplayName();
            }

            for (var i = 1; i < path.length; i++) {
                aliasedSymbol = path[i].getAliasedSymbol(scopeSymbol);
                if (aliasedSymbol) {
                    fullName = aliasedSymbol.getDisplayName() + "." + fullName;
                    break;
                } else {
                    var scopedName = path[i].getNamePartForFullName();
                    if (path[i].getKind() == 32 /* DynamicModule */ && !TypeScript.isQuoted(scopedName)) {
                        break;
                    }

                    if (scopedName === "") {
                        break;
                    }

                    fullName = scopedName + "." + fullName;
                }
            }

            fullName = fullName + this.getNamePartForFullName();
            return fullName;
        };

        PullSymbol.prototype.getScopedName = function (scopeSymbol, useConstraintInName) {
            var path = this.findCommonAncestorPath(scopeSymbol);
            var fullName = "";
            var aliasedSymbol = this.getAliasedSymbol(scopeSymbol);
            if (aliasedSymbol) {
                return aliasedSymbol.getDisplayName();
            }

            for (var i = 1; i < path.length; i++) {
                var kind = path[i].getKind();
                if (kind === 4 /* Container */ || kind === 32 /* DynamicModule */) {
                    aliasedSymbol = path[i].getAliasedSymbol(scopeSymbol);
                    if (aliasedSymbol) {
                        fullName = aliasedSymbol.getDisplayName() + "." + fullName;
                        break;
                    } else if (kind === 4 /* Container */) {
                        fullName = path[i].getDisplayName() + "." + fullName;
                    } else {
                        var displayName = path[i].getDisplayName();
                        if (TypeScript.isQuoted(displayName)) {
                            fullName = displayName + "." + fullName;
                        }
                        break;
                    }
                } else {
                    break;
                }
            }
            fullName = fullName + this.getDisplayName(scopeSymbol, useConstraintInName);
            return fullName;
        };

        PullSymbol.prototype.getScopedNameEx = function (scopeSymbol, useConstraintInName, getPrettyTypeName, getTypeParamMarkerInfo) {
            var name = this.getScopedName(scopeSymbol, useConstraintInName);
            return TypeScript.MemberName.create(name);
        };

        PullSymbol.prototype.getTypeName = function (scopeSymbol, getPrettyTypeName) {
            var memberName = this.getTypeNameEx(scopeSymbol, getPrettyTypeName);
            return memberName.toString();
        };

        PullSymbol.prototype.getTypeNameEx = function (scopeSymbol, getPrettyTypeName) {
            var type = this.getType();
            if (type) {
                var memberName = getPrettyTypeName ? this.getTypeNameForFunctionSignature("", scopeSymbol, getPrettyTypeName) : null;
                if (!memberName) {
                    memberName = type.getScopedNameEx(scopeSymbol, true, getPrettyTypeName);
                }

                return memberName;
            }
            return TypeScript.MemberName.create("");
        };

        PullSymbol.prototype.getTypeNameForFunctionSignature = function (prefix, scopeSymbol, getPrettyTypeName) {
            var type = this.getType();
            if (type && !type.isNamedTypeSymbol() && this.declKind != 4096 /* Property */ && this.declKind != 1024 /* Variable */ && this.declKind != 2048 /* Parameter */) {
                var signatures = type.getCallSignatures();
                var typeName = new TypeScript.MemberNameArray();
                var signatureName = PullSignatureSymbol.getSignaturesTypeNameEx(signatures, prefix, false, false, scopeSymbol, getPrettyTypeName);
                typeName.addAll(signatureName);
                return typeName;
            }

            return null;
        };

        PullSymbol.prototype.getNameAndTypeName = function (scopeSymbol) {
            var nameAndTypeName = this.getNameAndTypeNameEx(scopeSymbol);
            return nameAndTypeName.toString();
        };

        PullSymbol.prototype.getNameAndTypeNameEx = function (scopeSymbol) {
            var type = this.getType();
            var nameEx = this.getScopedNameEx(scopeSymbol);
            if (type) {
                var nameStr = nameEx.toString() + (this.getIsOptional() ? "?" : "");
                var memberName = this.getTypeNameForFunctionSignature(nameStr, scopeSymbol);
                if (!memberName) {
                    var typeNameEx = type.getScopedNameEx(scopeSymbol);
                    memberName = TypeScript.MemberName.create(typeNameEx, nameStr + ": ", "");
                }
                return memberName;
            }
            return nameEx;
        };

        PullSymbol.getTypeParameterString = function (typars, scopeSymbol, useContraintInName) {
            return PullSymbol.getTypeParameterStringEx(typars, scopeSymbol, undefined, useContraintInName).toString();
        };

        PullSymbol.getTypeParameterStringEx = function (typeParameters, scopeSymbol, getTypeParamMarkerInfo, useContraintInName) {
            var builder = new TypeScript.MemberNameArray();
            builder.prefix = "";

            if (typeParameters && typeParameters.length) {
                builder.add(TypeScript.MemberName.create("<"));

                for (var i = 0; i < typeParameters.length; i++) {
                    if (i) {
                        builder.add(TypeScript.MemberName.create(", "));
                    }

                    if (getTypeParamMarkerInfo) {
                        builder.add(new TypeScript.MemberName());
                    }

                    builder.add(typeParameters[i].getScopedNameEx(scopeSymbol, useContraintInName));

                    if (getTypeParamMarkerInfo) {
                        builder.add(new TypeScript.MemberName());
                    }
                }

                builder.add(TypeScript.MemberName.create(">"));
            }

            return builder;
        };

        PullSymbol.getIsExternallyVisible = function (symbol, fromIsExternallyVisibleSymbol, inIsExternallyVisibleSymbols) {
            if (inIsExternallyVisibleSymbols) {
                for (var i = 0; i < inIsExternallyVisibleSymbols.length; i++) {
                    if (inIsExternallyVisibleSymbols[i] === symbol) {
                        return true;
                    }
                }
            } else {
                inIsExternallyVisibleSymbols = [];
            }

            if (fromIsExternallyVisibleSymbol === symbol) {
                return true;
            }
            inIsExternallyVisibleSymbols = inIsExternallyVisibleSymbols.concat(fromIsExternallyVisibleSymbol);

            return symbol.isExternallyVisible(inIsExternallyVisibleSymbols);
        };

        PullSymbol.prototype.isExternallyVisible = function (inIsExternallyVisibleSymbols) {
            var kind = this.getKind();
            if (kind === 2 /* Primitive */) {
                return true;
            }

            if (this.isType()) {
                var associatedContainerSymbol = (this).getAssociatedContainerType();
                if (associatedContainerSymbol) {
                    return PullSymbol.getIsExternallyVisible(associatedContainerSymbol, this, inIsExternallyVisibleSymbols);
                }
            }

            if (this.hasFlag(2 /* Private */)) {
                return false;
            }

            var container = this.getContainer();
            if (container === null) {
                return true;
            }

            if (container.getKind() == 32 /* DynamicModule */ || (container.getAssociatedContainerType() && container.getAssociatedContainerType().getKind() == 32 /* DynamicModule */)) {
                var containerTypeSymbol = container.getKind() == 32 /* DynamicModule */ ? container : container.getAssociatedContainerType();
                if (PullContainerTypeSymbol.usedAsSymbol(containerTypeSymbol, this)) {
                    return true;
                }
            }

            if (!this.hasFlag(1 /* Exported */) && kind != 4096 /* Property */ && kind != 65536 /* Method */) {
                return false;
            }

            return PullSymbol.getIsExternallyVisible(container, this, inIsExternallyVisibleSymbols);
        };
        return PullSymbol;
    })();
    TypeScript.PullSymbol = PullSymbol;

    var PullExpressionSymbol = (function (_super) {
        __extends(PullExpressionSymbol, _super);
        function PullExpressionSymbol() {
            _super.call(this, "", 268435456 /* Expression */);
            this.contributingSymbols = [];
        }
        PullExpressionSymbol.prototype.addContributingSymbol = function (symbol) {
            var link = this.addOutgoingLink(symbol, 23 /* ContributesToExpression */);

            this.contributingSymbols[this.contributingSymbols.length] = symbol;
        };

        PullExpressionSymbol.prototype.getContributingSymbols = function () {
            return this.contributingSymbols;
        };
        return PullExpressionSymbol;
    })(PullSymbol);
    TypeScript.PullExpressionSymbol = PullExpressionSymbol;

    var PullSignatureSymbol = (function (_super) {
        __extends(PullSignatureSymbol, _super);
        function PullSignatureSymbol(kind) {
            _super.call(this, "", kind);
            this.parameterLinks = null;
            this.typeParameterLinks = null;
            this.returnTypeLink = null;
            this.hasOptionalParam = false;
            this.nonOptionalParamCount = 0;
            this.hasVarArgs = false;
            this.specializationCache = {};
            this.memberTypeParameterNameCache = null;
            this.hasAGenericParameter = false;
            this.stringConstantOverload = undefined;
        }
        PullSignatureSymbol.prototype.isDefinition = function () {
            return false;
        };

        PullSignatureSymbol.prototype.hasVariableParamList = function () {
            return this.hasVarArgs;
        };
        PullSignatureSymbol.prototype.setHasVariableParamList = function () {
            this.hasVarArgs = true;
        };

        PullSignatureSymbol.prototype.setHasGenericParameter = function () {
            this.hasAGenericParameter = true;
        };
        PullSignatureSymbol.prototype.hasGenericParameter = function () {
            return this.hasAGenericParameter;
        };

        PullSignatureSymbol.prototype.isGeneric = function () {
            return this.hasAGenericParameter || (this.typeParameterLinks && this.typeParameterLinks.length != 0);
        };

        PullSignatureSymbol.prototype.addParameter = function (parameter, isOptional) {
            if (typeof isOptional === "undefined") { isOptional = false; }
            if (!this.parameterLinks) {
                this.parameterLinks = [];
            }

            var link = this.addOutgoingLink(parameter, 13 /* Parameter */);
            this.parameterLinks[this.parameterLinks.length] = link;
            this.hasOptionalParam = isOptional;

            if (!isOptional) {
                this.nonOptionalParamCount++;
            }
        };

        PullSignatureSymbol.prototype.addSpecialization = function (signature, typeArguments) {
            if (typeArguments && typeArguments.length) {
                this.specializationCache[getIDForTypeSubstitutions(typeArguments)] = signature;
            }
        };

        PullSignatureSymbol.prototype.getSpecialization = function (typeArguments) {
            if (typeArguments) {
                var sig = this.specializationCache[getIDForTypeSubstitutions(typeArguments)];

                if (sig) {
                    return sig;
                }
            }

            return null;
        };

        PullSignatureSymbol.prototype.addTypeParameter = function (parameter) {
            if (!this.typeParameterLinks) {
                this.typeParameterLinks = [];
            }

            if (!this.memberTypeParameterNameCache) {
                this.memberTypeParameterNameCache = new TypeScript.BlockIntrinsics();
            }

            var link = this.addOutgoingLink(parameter, 18 /* TypeParameter */);
            this.typeParameterLinks[this.typeParameterLinks.length] = link;

            this.memberTypeParameterNameCache[link.end.getName()] = link.end;
        };

        PullSignatureSymbol.prototype.getNonOptionalParameterCount = function () {
            return this.nonOptionalParamCount;
        };

        PullSignatureSymbol.prototype.setReturnType = function (returnType) {
            if (returnType) {
                if (this.returnTypeLink) {
                    this.removeOutgoingLink(this.returnTypeLink);
                }
                this.returnTypeLink = this.addOutgoingLink(returnType, 14 /* ReturnType */);
            }
        };

        PullSignatureSymbol.prototype.getParameters = function () {
            var params = [];

            if (this.parameterLinks) {
                for (var i = 0; i < this.parameterLinks.length; i++) {
                    params[params.length] = this.parameterLinks[i].end;
                }
            }

            return params;
        };

        PullSignatureSymbol.prototype.getTypeParameters = function () {
            var params = [];

            if (this.typeParameterLinks) {
                for (var i = 0; i < this.typeParameterLinks.length; i++) {
                    params[params.length] = this.typeParameterLinks[i].end;
                }
            }

            return params;
        };

        PullSignatureSymbol.prototype.findTypeParameter = function (name) {
            var memberSymbol;

            if (!this.memberTypeParameterNameCache) {
                this.memberTypeParameterNameCache = new TypeScript.BlockIntrinsics();

                if (this.typeParameterLinks) {
                    for (var i = 0; i < this.typeParameterLinks.length; i++) {
                        this.memberTypeParameterNameCache[this.typeParameterLinks[i].end.getName()] = this.typeParameterLinks[i].end;
                    }
                }
            }

            memberSymbol = this.memberTypeParameterNameCache[name];

            return memberSymbol;
        };

        PullSignatureSymbol.prototype.removeParameter = function (parameterSymbol) {
            var paramLink;

            if (this.parameterLinks) {
                for (var i = 0; i < this.parameterLinks.length; i++) {
                    if (parameterSymbol === this.parameterLinks[i].end) {
                        paramLink = this.parameterLinks[i];
                        this.removeOutgoingLink(paramLink);
                        break;
                    }
                }
            }

            this.invalidate();
        };

        PullSignatureSymbol.prototype.mimicSignature = function (signature, resolver) {
            var typeParameters = signature.getTypeParameters();
            var typeParameter;

            if (typeParameters) {
                for (var i = 0; i < typeParameters.length; i++) {
                    this.addTypeParameter(typeParameters[i]);
                }
            }

            var parameters = signature.getParameters();
            var parameter;

            if (parameters) {
                for (var j = 0; j < parameters.length; j++) {
                    parameter = new PullSymbol(parameters[j].getName(), 2048 /* Parameter */);
                    parameter.setRootSymbol(parameters[j]);

                    if (parameters[j].getIsOptional()) {
                        parameter.setIsOptional();
                    }
                    if (parameters[j].getIsVarArg()) {
                        parameter.setIsVarArg();
                        this.setHasVariableParamList();
                    }
                    this.addParameter(parameter);
                }
            }

            var returnType = signature.getReturnType();

            if (!resolver.isTypeArgumentOrWrapper(returnType)) {
                this.setReturnType(returnType);
            }
        };

        PullSignatureSymbol.prototype.getReturnType = function () {
            if (this.returnTypeLink) {
                return this.returnTypeLink.end;
            } else {
                var rtl = this.findOutgoingLinks(function (p) {
                    return p.kind === 14 /* ReturnType */;
                });

                if (rtl.length) {
                    this.returnTypeLink = rtl[0];
                    return this.returnTypeLink.end;
                }

                return null;
            }
        };

        PullSignatureSymbol.prototype.parametersAreFixed = function () {
            if (!this.isGeneric()) {
                return true;
            }

            if (this.parameterLinks) {
                var paramType;
                for (var i = 0; i < this.parameterLinks.length; i++) {
                    paramType = this.parameterLinks[i].end.getType();

                    if (paramType && !paramType.isFixed()) {
                        return false;
                    }
                }
            }

            return true;
        };

        PullSignatureSymbol.prototype.isFixed = function () {
            if (!this.isGeneric()) {
                return true;
            }

            if (this.parameterLinks) {
                var parameterType = null;

                for (var i = 0; i < this.parameterLinks.length; i++) {
                    parameterType = this.parameterLinks[i].end.getType();

                    if (parameterType && !parameterType.isFixed()) {
                        return false;
                    }
                }
            }

            if (this.returnTypeLink) {
                var returnType = this.returnTypeLink.end;

                return returnType.isFixed();
            }

            return true;
        };

        PullSignatureSymbol.prototype.invalidate = function () {
            this.parameterLinks = this.findOutgoingLinks(function (psl) {
                return psl.kind === 13 /* Parameter */;
            });
            this.nonOptionalParamCount = 0;
            this.hasOptionalParam = false;
            this.hasAGenericParameter = false;
            this.stringConstantOverload = undefined;

            if (this.parameterLinks) {
                for (var i = 0; i < this.parameterLinks.length; i++) {
                    this.parameterLinks[i].end.invalidate();

                    if (!this.parameterLinks[i].end.getIsOptional()) {
                        this.nonOptionalParamCount++;
                    } else {
                        this.hasOptionalParam;
                        break;
                    }
                }
            }

            _super.prototype.invalidate.call(this);
        };

        PullSignatureSymbol.prototype.isStringConstantOverloadSignature = function () {
            if (this.stringConstantOverload === undefined) {
                var params = this.getParameters();
                this.stringConstantOverload = false;
                for (var i = 0; i < params.length; i++) {
                    var paramType = params[i].getType();
                    if (paramType && paramType.isPrimitive() && (paramType).isStringConstant()) {
                        this.stringConstantOverload = true;
                    }
                }
            }

            return this.stringConstantOverload;
        };

        PullSignatureSymbol.getSignatureTypeMemberName = function (candidateSignature, signatures, scopeSymbol) {
            var allMemberNames = new TypeScript.MemberNameArray();
            var signatureMemberName = PullSignatureSymbol.getSignaturesTypeNameEx(signatures, "", false, false, scopeSymbol, true, candidateSignature);
            allMemberNames.addAll(signatureMemberName);
            return allMemberNames;
        };

        PullSignatureSymbol.getSignaturesTypeNameEx = function (signatures, prefix, shortform, brackets, scopeSymbol, getPrettyTypeName, candidateSignature) {
            var result = [];
            var len = signatures.length;
            if (!getPrettyTypeName && len > 1) {
                shortform = false;
            }

            var foundDefinition = false;
            if (candidateSignature && candidateSignature.isDefinition() && len > 1) {
                candidateSignature = null;
            }

            for (var i = 0; i < len; i++) {
                if (len > 1 && signatures[i].isDefinition()) {
                    foundDefinition = true;
                    continue;
                }

                var signature = signatures[i];
                if (getPrettyTypeName && candidateSignature) {
                    signature = candidateSignature;
                }

                result.push(signature.getSignatureTypeNameEx(prefix, shortform, brackets, scopeSymbol));
                if (getPrettyTypeName) {
                    break;
                }
            }

            if (getPrettyTypeName && result.length && len > 1) {
                var lastMemberName = result[result.length - 1];
                for (var i = i + 1; i < len; i++) {
                    if (signatures[i].isDefinition()) {
                        foundDefinition = true;
                        break;
                    }
                }
                var overloadString = " (+ " + (foundDefinition ? len - 2 : len - 1) + " overload(s))";
                lastMemberName.add(TypeScript.MemberName.create(overloadString));
            }

            return result;
        };

        PullSignatureSymbol.prototype.toString = function (useConstraintInName) {
            var s = this.getSignatureTypeNameEx(this.getScopedNameEx().toString(), false, false, undefined, undefined, useConstraintInName).toString();
            return s;
        };

        PullSignatureSymbol.prototype.getSignatureTypeNameEx = function (prefix, shortform, brackets, scopeSymbol, getParamMarkerInfo, getTypeParamMarkerInfo) {
            var typeParamterBuilder = new TypeScript.MemberNameArray();

            typeParamterBuilder.add(PullSymbol.getTypeParameterStringEx(this.getTypeParameters(), scopeSymbol, getTypeParamMarkerInfo, true));

            if (brackets) {
                typeParamterBuilder.add(TypeScript.MemberName.create("["));
            } else {
                typeParamterBuilder.add(TypeScript.MemberName.create("("));
            }

            var builder = new TypeScript.MemberNameArray();
            builder.prefix = prefix;

            if (getTypeParamMarkerInfo) {
                builder.prefix = prefix;
                builder.addAll(typeParamterBuilder.entries);
            } else {
                builder.prefix = prefix + typeParamterBuilder.toString();
            }

            var params = this.getParameters();
            var paramLen = params.length;
            for (var i = 0; i < paramLen; i++) {
                var paramType = params[i].getType();
                var typeString = paramType ? ": " : "";
                var paramIsVarArg = params[i].getIsVarArg();
                var varArgPrefix = paramIsVarArg ? "..." : "";
                var optionalString = (!paramIsVarArg && params[i].getIsOptional()) ? "?" : "";
                if (getParamMarkerInfo) {
                    builder.add(new TypeScript.MemberName());
                }
                builder.add(TypeScript.MemberName.create(varArgPrefix + params[i].getScopedNameEx(scopeSymbol).toString() + optionalString + typeString));
                if (paramType) {
                    builder.add(paramType.getScopedNameEx(scopeSymbol));
                }
                if (getParamMarkerInfo) {
                    builder.add(new TypeScript.MemberName());
                }
                if (i < paramLen - 1) {
                    builder.add(TypeScript.MemberName.create(", "));
                }
            }

            if (shortform) {
                if (brackets) {
                    builder.add(TypeScript.MemberName.create("] => "));
                } else {
                    builder.add(TypeScript.MemberName.create(") => "));
                }
            } else {
                if (brackets) {
                    builder.add(TypeScript.MemberName.create("]: "));
                } else {
                    builder.add(TypeScript.MemberName.create("): "));
                }
            }

            var returnType = this.getReturnType();

            if (returnType) {
                builder.add(returnType.getScopedNameEx(scopeSymbol));
            } else {
                builder.add(TypeScript.MemberName.create("any"));
            }

            return builder;
        };
        return PullSignatureSymbol;
    })(PullSymbol);
    TypeScript.PullSignatureSymbol = PullSignatureSymbol;

    var PullTypeSymbol = (function (_super) {
        __extends(PullTypeSymbol, _super);
        function PullTypeSymbol() {
            _super.apply(this, arguments);
            this.memberLinks = null;
            this.typeParameterLinks = null;
            this.specializationLinks = null;
            this.containedByLinks = null;
            this.memberNameCache = null;
            this.memberTypeNameCache = null;
            this.memberTypeParameterNameCache = null;
            this.containedMemberCache = null;
            this.typeArguments = null;
            this.specializedTypeCache = null;
            this.memberCache = null;
            this.implementedTypeLinks = null;
            this.extendedTypeLinks = null;
            this.callSignatureLinks = null;
            this.constructSignatureLinks = null;
            this.indexSignatureLinks = null;
            this.arrayType = null;
            this.hasGenericSignature = false;
            this.hasGenericMember = false;
            this.knownBaseTypeCount = 0;
            this._hasBaseTypeConflict = false;
            this.invalidatedSpecializations = false;
            this.associatedContainerTypeSymbol = null;
            this.constructorMethod = null;
            this.hasDefaultConstructor = false;
        }
        PullTypeSymbol.prototype.getKnownBaseTypeCount = function () {
            return this.knownBaseTypeCount;
        };
        PullTypeSymbol.prototype.resetKnownBaseTypeCount = function () {
            this.knownBaseTypeCount = 0;
        };
        PullTypeSymbol.prototype.incrementKnownBaseCount = function () {
            this.knownBaseTypeCount++;
        };
        PullTypeSymbol.prototype.setHasBaseTypeConflict = function () {
            this._hasBaseTypeConflict = true;
        };
        PullTypeSymbol.prototype.hasBaseTypeConflict = function () {
            return this._hasBaseTypeConflict;
        };

        PullTypeSymbol.prototype.setUnresolved = function () {
            _super.prototype.setUnresolved.call(this);

            var specializations = this.getKnownSpecializations();

            for (var i = 0; i < specializations.length; i++) {
                specializations[i].setUnresolved();
            }
        };

        PullTypeSymbol.prototype.isType = function () {
            return true;
        };
        PullTypeSymbol.prototype.isClass = function () {
            return this.getKind() == 8 /* Class */ || (this.constructorMethod != null);
        };

        PullTypeSymbol.prototype.hasMembers = function () {
            var thisHasMembers = this.memberLinks && this.memberLinks.length != 0;

            if (thisHasMembers) {
                return true;
            }

            var parents = this.getExtendedTypes();

            for (var i = 0; i < parents.length; i++) {
                if (parents[i].hasMembers()) {
                    return true;
                }
            }

            return false;
        };
        PullTypeSymbol.prototype.isFunction = function () {
            return false;
        };
        PullTypeSymbol.prototype.isConstructor = function () {
            return false;
        };
        PullTypeSymbol.prototype.isTypeParameter = function () {
            return false;
        };
        PullTypeSymbol.prototype.isTypeVariable = function () {
            return false;
        };
        PullTypeSymbol.prototype.isError = function () {
            return false;
        };

        PullTypeSymbol.prototype.setHasGenericSignature = function () {
            this.hasGenericSignature = true;
        };
        PullTypeSymbol.prototype.getHasGenericSignature = function () {
            return this.hasGenericSignature;
        };

        PullTypeSymbol.prototype.setHasGenericMember = function () {
            this.hasGenericMember = true;
        };
        PullTypeSymbol.prototype.getHasGenericMember = function () {
            return this.hasGenericMember;
        };

        PullTypeSymbol.prototype.setAssociatedContainerType = function (type) {
            this.associatedContainerTypeSymbol = type;
        };

        PullTypeSymbol.prototype.getAssociatedContainerType = function () {
            return this.associatedContainerTypeSymbol;
        };

        PullTypeSymbol.prototype.getType = function () {
            return this;
        };

        PullTypeSymbol.prototype.getArrayType = function () {
            return this.arrayType;
        };

        PullTypeSymbol.prototype.getElementType = function () {
            var arrayOfLinks = this.findOutgoingLinks(function (link) {
                return link.kind === 4 /* ArrayOf */;
            });

            if (arrayOfLinks.length) {
                return arrayOfLinks[0].end;
            }

            return null;
        };
        PullTypeSymbol.prototype.setArrayType = function (arrayType) {
            this.arrayType = arrayType;

            arrayType.addOutgoingLink(this, 4 /* ArrayOf */);
        };

        PullTypeSymbol.prototype.addContainedByLink = function (containedByLink) {
            if (!this.containedByLinks) {
                this.containedByLinks = [];
            }

            if (!this.containedMemberCache) {
                this.containedMemberCache = new TypeScript.BlockIntrinsics();
            }

            this.containedByLinks[this.containedByLinks.length] = containedByLink;
            this.containedMemberCache[containedByLink.start.getName()] = containedByLink.start;
        };

        PullTypeSymbol.prototype.findContainedMember = function (name) {
            if (!this.containedByLinks) {
                this.containedByLinks = this.findIncomingLinks(function (psl) {
                    return psl.kind === 10 /* ContainedBy */;
                });
                this.containedMemberCache = new TypeScript.BlockIntrinsics();

                for (var i = 0; i < this.containedByLinks.length; i++) {
                    this.containedMemberCache[this.containedByLinks[i].start.getName()] = this.containedByLinks[i].start;
                }
            }

            return this.containedMemberCache[name];
        };

        PullTypeSymbol.prototype.addMember = function (memberSymbol, linkKind, doNotChangeContainer) {
            var link = this.addOutgoingLink(memberSymbol, linkKind);

            if (!doNotChangeContainer) {
                memberSymbol.setContainer(this);
            }

            if (!this.memberLinks) {
                this.memberLinks = [];
            }

            if (!this.memberCache || !this.memberNameCache) {
                this.populateMemberCache();
            }

            if (!memberSymbol.isType()) {
                this.memberLinks[this.memberLinks.length] = link;

                this.memberCache[this.memberCache.length] = memberSymbol;

                if (!this.memberNameCache) {
                    this.populateMemberCache();
                }
                this.memberNameCache[memberSymbol.getName()] = memberSymbol;
            } else {
                if ((memberSymbol).isTypeParameter()) {
                    if (!this.typeParameterLinks) {
                        this.typeParameterLinks = [];
                    }
                    if (!this.memberTypeParameterNameCache) {
                        this.memberTypeParameterNameCache = new TypeScript.BlockIntrinsics();
                    }
                    this.typeParameterLinks[this.typeParameterLinks.length] = link;
                    this.memberTypeParameterNameCache[memberSymbol.getName()] = memberSymbol;
                } else {
                    if (!this.memberTypeNameCache) {
                        this.memberTypeNameCache = new TypeScript.BlockIntrinsics();
                    }
                    this.memberLinks[this.memberLinks.length] = link;
                    this.memberTypeNameCache[memberSymbol.getName()] = memberSymbol;
                    this.memberCache[this.memberCache.length] = memberSymbol;
                }
            }
        };

        PullTypeSymbol.prototype.removeMember = function (memberSymbol) {
            var memberLink;
            var child;

            var links = (memberSymbol.isType() && (memberSymbol).isTypeParameter()) ? this.typeParameterLinks : this.memberLinks;

            if (links) {
                for (var i = 0; i < links.length; i++) {
                    if (memberSymbol === links[i].end) {
                        memberLink = links[i];
                        child = memberLink.end;
                        child.unsetContainer();
                        this.removeOutgoingLink(memberLink);
                        break;
                    }
                }
            }

            this.invalidate();
        };

        PullTypeSymbol.prototype.getMembers = function () {
            if (this.memberCache) {
                return this.memberCache;
            } else {
                var members = [];

                if (this.memberLinks) {
                    for (var i = 0; i < this.memberLinks.length; i++) {
                        members[members.length] = this.memberLinks[i].end;
                    }
                }

                if (members.length) {
                    this.memberCache = members;
                }

                return members;
            }
        };

        PullTypeSymbol.prototype.setHasDefaultConstructor = function (hasOne) {
            if (typeof hasOne === "undefined") { hasOne = true; }
            this.hasDefaultConstructor = hasOne;
        };

        PullTypeSymbol.prototype.getHasDefaultConstructor = function () {
            return this.hasDefaultConstructor;
        };

        PullTypeSymbol.prototype.getConstructorMethod = function () {
            return this.constructorMethod;
        };

        PullTypeSymbol.prototype.setConstructorMethod = function (constructorMethod) {
            this.constructorMethod = constructorMethod;
        };

        PullTypeSymbol.prototype.getTypeParameters = function () {
            var members = [];

            if (this.typeParameterLinks) {
                for (var i = 0; i < this.typeParameterLinks.length; i++) {
                    members[members.length] = this.typeParameterLinks[i].end;
                }
            }

            return members;
        };

        PullTypeSymbol.prototype.isGeneric = function () {
            return (this.typeParameterLinks && this.typeParameterLinks.length != 0) || this.hasGenericSignature || this.hasGenericMember || (this.typeArguments && this.typeArguments.length);
        };

        PullTypeSymbol.prototype.isFixed = function () {
            if (!this.isGeneric()) {
                return true;
            }

            if (this.typeParameterLinks && this.typeArguments) {
                if (!this.typeArguments.length || this.typeArguments.length < this.typeParameterLinks.length) {
                    return false;
                }

                for (var i = 0; i < this.typeArguments.length; i++) {
                    if (!this.typeArguments[i].isFixed()) {
                        return false;
                    }
                }

                return true;
            }

            return false;
        };

        PullTypeSymbol.prototype.addSpecialization = function (specializedVersionOfThisType, substitutingTypes) {
            if (!substitutingTypes || !substitutingTypes.length) {
                return;
            }

            if (!this.specializedTypeCache) {
                this.specializedTypeCache = new TypeScript.BlockIntrinsics();
            }

            if (!this.specializationLinks) {
                this.specializationLinks = [];
            }

            this.specializationLinks[this.specializationLinks.length] = this.addOutgoingLink(specializedVersionOfThisType, 21 /* SpecializedTo */);

            this.specializedTypeCache[getIDForTypeSubstitutions(substitutingTypes)] = specializedVersionOfThisType;
        };

        PullTypeSymbol.prototype.getSpecialization = function (substitutingTypes) {
            if (!substitutingTypes || !substitutingTypes.length) {
                return null;
            }

            if (!this.specializedTypeCache) {
                this.specializedTypeCache = new TypeScript.BlockIntrinsics();

                return null;
            }

            var specialization = this.specializedTypeCache[getIDForTypeSubstitutions(substitutingTypes)];

            if (!specialization) {
                return null;
            }

            return specialization;
        };

        PullTypeSymbol.prototype.getKnownSpecializations = function () {
            var specializations = [];

            if (this.specializedTypeCache) {
                for (var specializationID in this.specializedTypeCache) {
                    if (this.specializedTypeCache[specializationID]) {
                        specializations[specializations.length] = this.specializedTypeCache[specializationID];
                    }
                }
            }

            return specializations;
        };

        PullTypeSymbol.prototype.invalidateSpecializations = function () {
            if (this.invalidatedSpecializations) {
                return;
            }

            var specializations = this.getKnownSpecializations();

            for (var i = 0; i < specializations.length; i++) {
                specializations[i].invalidate();
            }

            if (this.specializationLinks && this.specializationLinks.length) {
                for (var i = 0; i < this.specializationLinks.length; i++) {
                    this.removeOutgoingLink(this.specializationLinks[i]);
                }
            }

            this.specializationLinks = null;

            this.specializedTypeCache = null;

            this.invalidatedSpecializations = true;
        };

        PullTypeSymbol.prototype.removeSpecialization = function (specializationType) {
            if (this.specializationLinks && this.specializationLinks.length) {
                for (var i = 0; i < this.specializationLinks.length; i++) {
                    if (this.specializationLinks[i].end === specializationType) {
                        this.removeOutgoingLink(this.specializationLinks[i]);
                        break;
                    }
                }
            }

            if (this.specializedTypeCache) {
                for (var specializationID in this.specializedTypeCache) {
                    if (this.specializedTypeCache[specializationID] === specializationType) {
                        this.specializedTypeCache[specializationID] = undefined;
                    }
                }
            }
        };

        PullTypeSymbol.prototype.getTypeArguments = function () {
            return this.typeArguments;
        };
        PullTypeSymbol.prototype.setTypeArguments = function (typeArgs) {
            this.typeArguments = typeArgs;
        };

        PullTypeSymbol.prototype.addCallSignature = function (callSignature) {
            if (!this.callSignatureLinks) {
                this.callSignatureLinks = [];
            }

            var link = this.addOutgoingLink(callSignature, 15 /* CallSignature */);
            this.callSignatureLinks[this.callSignatureLinks.length] = link;

            if (callSignature.isGeneric()) {
                this.hasGenericSignature = true;
            }
        };

        PullTypeSymbol.prototype.addCallSignatures = function (callSignatures) {
            if (!this.callSignatureLinks) {
                this.callSignatureLinks = [];
            }

            for (var i = 0; i < callSignatures.length; i++) {
                this.addCallSignature(callSignatures[i]);
            }
        };

        PullTypeSymbol.prototype.addConstructSignature = function (constructSignature) {
            if (!this.constructSignatureLinks) {
                this.constructSignatureLinks = [];
            }

            var link = this.addOutgoingLink(constructSignature, 16 /* ConstructSignature */);
            this.constructSignatureLinks[this.constructSignatureLinks.length] = link;

            if (constructSignature.isGeneric()) {
                this.hasGenericSignature = true;
            }
        };

        PullTypeSymbol.prototype.addConstructSignatures = function (constructSignatures) {
            if (!this.constructSignatureLinks) {
                this.constructSignatureLinks = [];
            }

            for (var i = 0; i < constructSignatures.length; i++) {
                this.addConstructSignature(constructSignatures[i]);
            }
        };

        PullTypeSymbol.prototype.addIndexSignature = function (indexSignature) {
            if (!this.indexSignatureLinks) {
                this.indexSignatureLinks = [];
            }

            var link = this.addOutgoingLink(indexSignature, 17 /* IndexSignature */);
            this.indexSignatureLinks[this.indexSignatureLinks.length] = link;

            if (indexSignature.isGeneric()) {
                this.hasGenericSignature = true;
            }
        };

        PullTypeSymbol.prototype.addIndexSignatures = function (indexSignatures) {
            if (!this.indexSignatureLinks) {
                this.indexSignatureLinks = [];
            }

            for (var i = 0; i < indexSignatures.length; i++) {
                this.addIndexSignature(indexSignatures[i]);
            }
        };

        PullTypeSymbol.prototype.hasOwnCallSignatures = function () {
            return !!this.callSignatureLinks;
        };

        PullTypeSymbol.prototype.getCallSignatures = function (collectBaseSignatures) {
            if (typeof collectBaseSignatures === "undefined") { collectBaseSignatures = true; }
            var members = [];

            if (this.callSignatureLinks) {
                for (var i = 0; i < this.callSignatureLinks.length; i++) {
                    members[members.length] = this.callSignatureLinks[i].end;
                }
            }

            if (collectBaseSignatures) {
                var extendedTypes = this.getExtendedTypes();

                for (var i = 0; i < extendedTypes.length; i++) {
                    if (extendedTypes[i].hasBase(this)) {
                        continue;
                    }
                    members = members.concat(extendedTypes[i].getCallSignatures());
                }
            }

            return members;
        };

        PullTypeSymbol.prototype.hasOwnConstructSignatures = function () {
            return !!this.constructSignatureLinks;
        };

        PullTypeSymbol.prototype.getConstructSignatures = function (collectBaseSignatures) {
            if (typeof collectBaseSignatures === "undefined") { collectBaseSignatures = true; }
            var members = [];

            if (this.constructSignatureLinks) {
                for (var i = 0; i < this.constructSignatureLinks.length; i++) {
                    members[members.length] = this.constructSignatureLinks[i].end;
                }
            }

            if (collectBaseSignatures) {
                if (!(this.getKind() == 33554432 /* ConstructorType */)) {
                    var extendedTypes = this.getExtendedTypes();

                    for (var i = 0; i < extendedTypes.length; i++) {
                        if (extendedTypes[i].hasBase(this)) {
                            continue;
                        }
                        members = members.concat(extendedTypes[i].getConstructSignatures());
                    }
                }
            }

            return members;
        };

        PullTypeSymbol.prototype.hasOwnIndexSignatures = function () {
            return !!this.indexSignatureLinks;
        };

        PullTypeSymbol.prototype.getIndexSignatures = function (collectBaseSignatures) {
            if (typeof collectBaseSignatures === "undefined") { collectBaseSignatures = true; }
            var members = [];

            if (this.indexSignatureLinks) {
                for (var i = 0; i < this.indexSignatureLinks.length; i++) {
                    members[members.length] = this.indexSignatureLinks[i].end;
                }
            }

            if (collectBaseSignatures) {
                var extendedTypes = this.getExtendedTypes();

                for (var i = 0; i < extendedTypes.length; i++) {
                    if (extendedTypes[i].hasBase(this)) {
                        continue;
                    }
                    members = members.concat(extendedTypes[i].getIndexSignatures());
                }
            }

            return members;
        };

        PullTypeSymbol.prototype.removeCallSignature = function (signature, invalidate) {
            if (typeof invalidate === "undefined") { invalidate = true; }
            var signatureLink;

            if (this.callSignatureLinks) {
                for (var i = 0; i < this.callSignatureLinks.length; i++) {
                    if (signature === this.callSignatureLinks[i].end) {
                        signatureLink = this.callSignatureLinks[i];
                        this.removeOutgoingLink(signatureLink);
                        break;
                    }
                }
            }

            if (invalidate) {
                this.invalidate();
            }
        };

        PullTypeSymbol.prototype.recomputeCallSignatures = function () {
            this.callSignatureLinks = this.findOutgoingLinks(function (psl) {
                return psl.kind === 15 /* CallSignature */;
            });
        };

        PullTypeSymbol.prototype.removeConstructSignature = function (signature, invalidate) {
            if (typeof invalidate === "undefined") { invalidate = true; }
            var signatureLink;

            if (this.constructSignatureLinks) {
                for (var i = 0; i < this.constructSignatureLinks.length; i++) {
                    if (signature === this.constructSignatureLinks[i].end) {
                        signatureLink = this.constructSignatureLinks[i];
                        this.removeOutgoingLink(signatureLink);
                        break;
                    }
                }
            }

            if (invalidate) {
                this.invalidate();
            }
        };

        PullTypeSymbol.prototype.recomputeConstructSignatures = function () {
            this.constructSignatureLinks = this.findOutgoingLinks(function (psl) {
                return psl.kind === 16 /* ConstructSignature */;
            });
        };

        PullTypeSymbol.prototype.removeIndexSignature = function (signature, invalidate) {
            if (typeof invalidate === "undefined") { invalidate = true; }
            var signatureLink;

            if (this.indexSignatureLinks) {
                for (var i = 0; i < this.indexSignatureLinks.length; i++) {
                    if (signature === this.indexSignatureLinks[i].end) {
                        signatureLink = this.indexSignatureLinks[i];
                        this.removeOutgoingLink(signatureLink);
                        break;
                    }
                }
            }

            if (invalidate) {
                this.invalidate();
            }
        };

        PullTypeSymbol.prototype.recomputeIndexSignatures = function () {
            this.indexSignatureLinks = this.findOutgoingLinks(function (psl) {
                return psl.kind === 17 /* IndexSignature */;
            });
        };

        PullTypeSymbol.prototype.addImplementedType = function (interfaceType) {
            if (!this.implementedTypeLinks) {
                this.implementedTypeLinks = [];
            }

            var link = this.addOutgoingLink(interfaceType, 12 /* Implements */);
            this.implementedTypeLinks[this.implementedTypeLinks.length] = link;
        };

        PullTypeSymbol.prototype.getImplementedTypes = function () {
            var members = [];

            if (this.implementedTypeLinks) {
                for (var i = 0; i < this.implementedTypeLinks.length; i++) {
                    members[members.length] = this.implementedTypeLinks[i].end;
                }
            }

            return members;
        };

        PullTypeSymbol.prototype.removeImplementedType = function (implementedType) {
            var typeLink;

            if (this.implementedTypeLinks) {
                for (var i = 0; i < this.implementedTypeLinks.length; i++) {
                    if (implementedType === this.implementedTypeLinks[i].end) {
                        typeLink = this.implementedTypeLinks[i];
                        this.removeOutgoingLink(typeLink);
                        break;
                    }
                }
            }

            this.invalidate();
        };

        PullTypeSymbol.prototype.addExtendedType = function (extendedType) {
            if (!this.extendedTypeLinks) {
                this.extendedTypeLinks = [];
            }

            var link = this.addOutgoingLink(extendedType, 11 /* Extends */);
            this.extendedTypeLinks[this.extendedTypeLinks.length] = link;
        };

        PullTypeSymbol.prototype.getExtendedTypes = function () {
            var members = [];

            if (this.extendedTypeLinks) {
                for (var i = 0; i < this.extendedTypeLinks.length; i++) {
                    members[members.length] = this.extendedTypeLinks[i].end;
                }
            }

            return members;
        };

        PullTypeSymbol.prototype.hasBase = function (potentialBase, origin) {
            if (typeof origin === "undefined") { origin = null; }
            if (this === potentialBase) {
                return true;
            }

            if (origin && (this === origin || this.getRootSymbol() === origin)) {
                return true;
            }

            if (!origin) {
                origin = this;
            }

            var extendedTypes = this.getExtendedTypes();

            for (var i = 0; i < extendedTypes.length; i++) {
                if (extendedTypes[i].hasBase(potentialBase, origin)) {
                    return true;
                }
            }

            var implementedTypes = this.getImplementedTypes();

            for (var i = 0; i < implementedTypes.length; i++) {
                if (implementedTypes[i].hasBase(potentialBase, origin)) {
                    return true;
                }
            }

            return false;
        };

        PullTypeSymbol.prototype.isValidBaseKind = function (baseType, isExtendedType) {
            if (baseType.isError()) {
                return false;
            }

            var thisIsClass = this.isClass();
            if (isExtendedType) {
                if (thisIsClass) {
                    return baseType.getKind() === 8 /* Class */;
                }
            } else {
                if (!thisIsClass) {
                    return false;
                }
            }

            return !!(baseType.getKind() & (16 /* Interface */ | 8 /* Class */ | 128 /* Array */));
        };

        PullTypeSymbol.prototype.removeExtendedType = function (extendedType) {
            var typeLink;

            if (this.extendedTypeLinks) {
                for (var i = 0; i < this.extendedTypeLinks.length; i++) {
                    if (extendedType === this.extendedTypeLinks[i].end) {
                        typeLink = this.extendedTypeLinks[i];
                        this.removeOutgoingLink(typeLink);
                        break;
                    }
                }
            }

            this.invalidate();
        };

        PullTypeSymbol.prototype.findMember = function (name, lookInParent) {
            if (typeof lookInParent === "undefined") { lookInParent = true; }
            var memberSymbol;

            if (!this.memberNameCache) {
                this.populateMemberCache();
            }

            memberSymbol = this.memberNameCache[name];

            if (!lookInParent) {
                return memberSymbol;
            } else if (memberSymbol) {
                return memberSymbol;
            }

            if (!memberSymbol && this.extendedTypeLinks) {
                for (var i = 0; i < this.extendedTypeLinks.length; i++) {
                    memberSymbol = (this.extendedTypeLinks[i].end).findMember(name);

                    if (memberSymbol) {
                        return memberSymbol;
                    }
                }
            }

            return this.findNestedType(name);
        };

        PullTypeSymbol.prototype.findNestedType = function (name, kind) {
            if (typeof kind === "undefined") { kind = 0 /* None */; }
            var memberSymbol;

            if (!this.memberTypeNameCache) {
                this.populateMemberTypeCache();
            }

            memberSymbol = this.memberTypeNameCache[name];

            if (memberSymbol && kind != 0 /* None */) {
                memberSymbol = ((memberSymbol.getKind() & kind) != 0) ? memberSymbol : null;
            }

            return memberSymbol;
        };

        PullTypeSymbol.prototype.populateMemberCache = function () {
            if (!this.memberNameCache || !this.memberCache) {
                this.memberNameCache = new TypeScript.BlockIntrinsics();
                this.memberCache = [];

                if (this.memberLinks) {
                    for (var i = 0; i < this.memberLinks.length; i++) {
                        this.memberNameCache[this.memberLinks[i].end.getName()] = this.memberLinks[i].end;
                        this.memberCache[this.memberCache.length] = this.memberLinks[i].end;
                    }
                }
            }
        };

        PullTypeSymbol.prototype.populateMemberTypeCache = function () {
            if (!this.memberTypeNameCache) {
                this.memberTypeNameCache = new TypeScript.BlockIntrinsics();

                var setAll = false;

                if (!this.memberCache) {
                    this.memberCache = [];
                    this.memberNameCache = new TypeScript.BlockIntrinsics();
                    setAll = true;
                }

                if (this.memberLinks) {
                    for (var i = 0; i < this.memberLinks.length; i++) {
                        if (this.memberLinks[i].end.isType()) {
                            this.memberTypeNameCache[this.memberLinks[i].end.getName()] = this.memberLinks[i].end;
                            this.memberCache[this.memberCache.length] = this.memberLinks[i].end;
                        } else if (setAll) {
                            this.memberNameCache[this.memberLinks[i].end.getName()] = this.memberLinks[i].end;
                            this.memberCache[this.memberCache.length] = this.memberLinks[i].end;
                        }
                    }
                }
            }
        };

        PullTypeSymbol.prototype.getAllMembers = function (searchDeclKind, includePrivate) {
            var allMembers = [];
            var i = 0;
            var j = 0;
            var m = 0;
            var n = 0;

            if (!this.memberCache) {
                this.populateMemberCache();
            }

            if (!this.memberTypeNameCache) {
                this.populateMemberTypeCache();
            }

            if (!this.memberNameCache) {
                this.populateMemberCache();
            }

            for (var i = 0, n = this.memberCache.length; i < n; i++) {
                var member = this.memberCache[i];
                if ((member.getKind() & searchDeclKind) && (includePrivate || !member.hasFlag(2 /* Private */))) {
                    allMembers[allMembers.length] = member;
                }
            }

            if (this.extendedTypeLinks) {
                for (var i = 0, n = this.extendedTypeLinks.length; i < n; i++) {
                    var extendedMembers = (this.extendedTypeLinks[i].end).getAllMembers(searchDeclKind, includePrivate);

                    for (var j = 0, m = extendedMembers.length; j < m; j++) {
                        var extendedMember = extendedMembers[j];
                        if (!this.memberNameCache[extendedMember.getName()]) {
                            allMembers[allMembers.length] = extendedMember;
                        }
                    }
                }
            }

            return allMembers;
        };

        PullTypeSymbol.prototype.findTypeParameter = function (name) {
            var memberSymbol;

            if (!this.memberTypeParameterNameCache) {
                this.memberTypeParameterNameCache = new TypeScript.BlockIntrinsics();

                if (this.typeParameterLinks) {
                    for (var i = 0; i < this.typeParameterLinks.length; i++) {
                        this.memberTypeParameterNameCache[this.typeParameterLinks[i].end.getName()] = this.typeParameterLinks[i].end;
                    }
                }
            }

            memberSymbol = this.memberTypeParameterNameCache[name];

            return memberSymbol;
        };

        PullTypeSymbol.prototype.cleanTypeParameters = function () {
            if (this.typeParameterLinks) {
                for (var i = 0; i < this.typeParameterLinks.length; i++) {
                    this.removeOutgoingLink(this.typeParameterLinks[i]);
                }
            }

            this.typeParameterLinks = null;
            this.memberTypeParameterNameCache = null;
        };

        PullTypeSymbol.prototype.setResolved = function () {
            this.invalidatedSpecializations = true;
            _super.prototype.setResolved.call(this);
        };

        PullTypeSymbol.prototype.invalidate = function () {
            if (this.constructorMethod) {
                this.constructorMethod.invalidate();
            }

            this.memberNameCache = null;
            this.memberCache = null;
            this.memberTypeNameCache = null;
            this.containedMemberCache = null;

            this.invalidatedSpecializations = false;

            this.containedByLinks = null;

            this.memberLinks = this.findOutgoingLinks(function (psl) {
                return psl.kind === 6 /* PrivateMember */ || psl.kind === 5 /* PublicMember */;
            });

            this.typeParameterLinks = this.findOutgoingLinks(function (psl) {
                return psl.kind === 18 /* TypeParameter */;
            });

            this.callSignatureLinks = this.findOutgoingLinks(function (psl) {
                return psl.kind === 15 /* CallSignature */;
            });

            this.constructSignatureLinks = this.findOutgoingLinks(function (psl) {
                return psl.kind === 16 /* ConstructSignature */;
            });

            this.indexSignatureLinks = this.findOutgoingLinks(function (psl) {
                return psl.kind === 17 /* IndexSignature */;
            });

            this.implementedTypeLinks = this.findOutgoingLinks(function (psl) {
                return psl.kind === 12 /* Implements */;
            });

            this.extendedTypeLinks = this.findOutgoingLinks(function (psl) {
                return psl.kind === 11 /* Extends */;
            });

            this.knownBaseTypeCount = 0;

            _super.prototype.invalidate.call(this);
        };

        PullTypeSymbol.prototype.getNamePartForFullName = function () {
            var name = _super.prototype.getNamePartForFullName.call(this);

            var typars = this.getTypeArguments();
            if (!typars || !typars.length) {
                typars = this.getTypeParameters();
            }

            var typarString = PullSymbol.getTypeParameterString(typars, this, true);
            return name + typarString;
        };

        PullTypeSymbol.prototype.getScopedName = function (scopeSymbol, useConstraintInName) {
            return this.getScopedNameEx(scopeSymbol, useConstraintInName).toString();
        };

        PullTypeSymbol.prototype.isNamedTypeSymbol = function () {
            var kind = this.getKind();
            if (kind === 2 /* Primitive */ || kind === 8 /* Class */ || kind === 4 /* Container */ || kind === 32 /* DynamicModule */ || kind === 256 /* TypeAlias */ || kind === 64 /* Enum */ || kind === 8192 /* TypeParameter */ || ((kind === 16 /* Interface */ || kind === 8388608 /* ObjectType */) && this.getName() != "")) {
                return true;
            }

            return false;
        };

        PullTypeSymbol.prototype.toString = function (useConstraintInName) {
            var s = this.getScopedNameEx(null, useConstraintInName).toString();
            return s;
        };

        PullTypeSymbol.prototype.getScopedNameEx = function (scopeSymbol, useConstraintInName, getPrettyTypeName, getTypeParamMarkerInfo) {
            if (!this.isNamedTypeSymbol()) {
                return this.getMemberTypeNameEx(true, scopeSymbol, getPrettyTypeName);
            }

            var builder = new TypeScript.MemberNameArray();
            builder.prefix = _super.prototype.getScopedName.call(this, scopeSymbol, useConstraintInName);

            var typars = this.getTypeArguments();
            if (!typars || !typars.length) {
                typars = this.getTypeParameters();
            }

            builder.add(PullSymbol.getTypeParameterStringEx(typars, this, getTypeParamMarkerInfo, useConstraintInName));

            return builder;
        };

        PullTypeSymbol.prototype.hasOnlyOverloadCallSignatures = function () {
            var members = this.getMembers();
            var callSignatures = this.getCallSignatures();
            var constructSignatures = this.getConstructSignatures();
            return members.length === 0 && constructSignatures.length === 0 && callSignatures.length > 1;
        };

        PullTypeSymbol.prototype.getMemberTypeNameEx = function (topLevel, scopeSymbol, getPrettyTypeName) {
            var members = this.getMembers();
            var callSignatures = this.getCallSignatures();
            var constructSignatures = this.getConstructSignatures();
            var indexSignatures = this.getIndexSignatures();

            if (members.length > 0 || callSignatures.length > 0 || constructSignatures.length > 0 || indexSignatures.length > 0) {
                var allMemberNames = new TypeScript.MemberNameArray();
                var curlies = !topLevel || indexSignatures.length != 0;
                var delim = "; ";
                for (var i = 0; i < members.length; i++) {
                    var memberTypeName = members[i].getNameAndTypeNameEx(scopeSymbol);

                    if (memberTypeName.isArray() && (memberTypeName).delim === delim) {
                        allMemberNames.addAll((memberTypeName).entries);
                    } else {
                        allMemberNames.add(memberTypeName);
                    }
                    curlies = true;
                }

                var getPrettyFunctionOverload = getPrettyTypeName && !curlies && this.hasOnlyOverloadCallSignatures();

                var signatureCount = callSignatures.length + constructSignatures.length + indexSignatures.length;
                if (signatureCount != 0 || members.length != 0) {
                    var useShortFormSignature = !curlies && (signatureCount === 1);
                    var signatureMemberName;

                    if (callSignatures.length > 0) {
                        signatureMemberName = PullSignatureSymbol.getSignaturesTypeNameEx(callSignatures, "", useShortFormSignature, false, scopeSymbol, getPrettyFunctionOverload);
                        allMemberNames.addAll(signatureMemberName);
                    }

                    if (constructSignatures.length > 0) {
                        signatureMemberName = PullSignatureSymbol.getSignaturesTypeNameEx(constructSignatures, "new", useShortFormSignature, false, scopeSymbol);
                        allMemberNames.addAll(signatureMemberName);
                    }

                    if (indexSignatures.length > 0) {
                        signatureMemberName = PullSignatureSymbol.getSignaturesTypeNameEx(indexSignatures, "", useShortFormSignature, true, scopeSymbol);
                        allMemberNames.addAll(signatureMemberName);
                    }

                    if ((curlies) || (!getPrettyFunctionOverload && (signatureCount > 1) && topLevel)) {
                        allMemberNames.prefix = "{ ";
                        allMemberNames.suffix = "}";
                        allMemberNames.delim = delim;
                    } else if (allMemberNames.entries.length > 1) {
                        allMemberNames.delim = delim;
                    }

                    return allMemberNames;
                }
            }

            return TypeScript.MemberName.create("{}");
        };

        PullTypeSymbol.prototype.isExternallyVisible = function (inIsExternallyVisibleSymbols) {
            var isVisible = _super.prototype.isExternallyVisible.call(this, inIsExternallyVisibleSymbols);
            if (isVisible) {
                var typars = this.getTypeArguments();
                if (!typars || !typars.length) {
                    typars = this.getTypeParameters();
                }

                if (typars) {
                    for (var i = 0; i < typars.length; i++) {
                        isVisible = PullSymbol.getIsExternallyVisible(typars[i], this, inIsExternallyVisibleSymbols);
                        if (!isVisible) {
                            break;
                        }
                    }
                }
            }

            return isVisible;
        };

        PullTypeSymbol.prototype.setType = function (type) {
            TypeScript.Debug.assert(false, "tried to set type of type");
        };
        return PullTypeSymbol;
    })(PullSymbol);
    TypeScript.PullTypeSymbol = PullTypeSymbol;

    var PullPrimitiveTypeSymbol = (function (_super) {
        __extends(PullPrimitiveTypeSymbol, _super);
        function PullPrimitiveTypeSymbol(name) {
            _super.call(this, name, 2 /* Primitive */);
        }
        PullPrimitiveTypeSymbol.prototype.isResolved = function () {
            return true;
        };

        PullPrimitiveTypeSymbol.prototype.isStringConstant = function () {
            return false;
        };

        PullPrimitiveTypeSymbol.prototype.isFixed = function () {
            return true;
        };

        PullPrimitiveTypeSymbol.prototype.invalidate = function () {
        };
        return PullPrimitiveTypeSymbol;
    })(PullTypeSymbol);
    TypeScript.PullPrimitiveTypeSymbol = PullPrimitiveTypeSymbol;

    var PullStringConstantTypeSymbol = (function (_super) {
        __extends(PullStringConstantTypeSymbol, _super);
        function PullStringConstantTypeSymbol(name) {
            _super.call(this, name);
        }
        PullStringConstantTypeSymbol.prototype.isStringConstant = function () {
            return true;
        };
        return PullStringConstantTypeSymbol;
    })(PullPrimitiveTypeSymbol);
    TypeScript.PullStringConstantTypeSymbol = PullStringConstantTypeSymbol;

    var PullErrorTypeSymbol = (function (_super) {
        __extends(PullErrorTypeSymbol, _super);
        function PullErrorTypeSymbol(diagnostic, delegateType, _data) {
            if (typeof _data === "undefined") { _data = null; }
            _super.call(this, "error");
            this.diagnostic = diagnostic;
            this.delegateType = delegateType;
            this._data = _data;
        }
        PullErrorTypeSymbol.prototype.isError = function () {
            return true;
        };

        PullErrorTypeSymbol.prototype.getDiagnostic = function () {
            return this.diagnostic;
        };

        PullErrorTypeSymbol.prototype.getName = function (scopeSymbol, useConstraintInName) {
            return this.delegateType.getName(scopeSymbol, useConstraintInName);
        };

        PullErrorTypeSymbol.prototype.getDisplayName = function (scopeSymbol, useConstraintInName) {
            return this.delegateType.getDisplayName(scopeSymbol, useConstraintInName);
        };

        PullErrorTypeSymbol.prototype.toString = function () {
            return this.delegateType.toString();
        };

        PullErrorTypeSymbol.prototype.isResolved = function () {
            return false;
        };

        PullErrorTypeSymbol.prototype.setData = function (data) {
            this._data = data;
        };

        PullErrorTypeSymbol.prototype.getData = function () {
            return this._data;
        };
        return PullErrorTypeSymbol;
    })(PullPrimitiveTypeSymbol);
    TypeScript.PullErrorTypeSymbol = PullErrorTypeSymbol;

    var PullClassTypeSymbol = (function (_super) {
        __extends(PullClassTypeSymbol, _super);
        function PullClassTypeSymbol(name) {
            _super.call(this, name, 8 /* Class */);
        }
        return PullClassTypeSymbol;
    })(PullTypeSymbol);
    TypeScript.PullClassTypeSymbol = PullClassTypeSymbol;

    var PullContainerTypeSymbol = (function (_super) {
        __extends(PullContainerTypeSymbol, _super);
        function PullContainerTypeSymbol(name, kind) {
            if (typeof kind === "undefined") { kind = 4 /* Container */; }
            _super.call(this, name, kind);
            this.instanceSymbol = null;
            this._exportAssignedValueSymbol = null;
            this._exportAssignedTypeSymbol = null;
            this._exportAssignedContainerSymbol = null;
        }
        PullContainerTypeSymbol.prototype.isContainer = function () {
            return true;
        };

        PullContainerTypeSymbol.prototype.setInstanceSymbol = function (symbol) {
            this.instanceSymbol = symbol;
        };

        PullContainerTypeSymbol.prototype.getInstanceSymbol = function () {
            return this.instanceSymbol;
        };

        PullContainerTypeSymbol.prototype.invalidate = function () {
            if (this.instanceSymbol) {
                this.instanceSymbol.invalidate();
            }

            _super.prototype.invalidate.call(this);
        };

        PullContainerTypeSymbol.prototype.setExportAssignedValueSymbol = function (symbol) {
            this._exportAssignedValueSymbol = symbol;
        };
        PullContainerTypeSymbol.prototype.getExportAssignedValueSymbol = function () {
            return this._exportAssignedValueSymbol;
        };

        PullContainerTypeSymbol.prototype.setExportAssignedTypeSymbol = function (type) {
            this._exportAssignedTypeSymbol = type;
        };
        PullContainerTypeSymbol.prototype.getExportAssignedTypeSymbol = function () {
            return this._exportAssignedTypeSymbol;
        };

        PullContainerTypeSymbol.prototype.setExportAssignedContainerSymbol = function (container) {
            this._exportAssignedContainerSymbol = container;
        };
        PullContainerTypeSymbol.prototype.getExportAssignedContainerSymbol = function () {
            return this._exportAssignedContainerSymbol;
        };

        PullContainerTypeSymbol.prototype.resetExportAssignedSymbols = function () {
            this._exportAssignedContainerSymbol = null;
            this._exportAssignedTypeSymbol = null;
            this._exportAssignedValueSymbol = null;
        };

        PullContainerTypeSymbol.usedAsSymbol = function (containerSymbol, symbol) {
            if (!containerSymbol || !containerSymbol.isContainer()) {
                return false;
            }

            if (containerSymbol.getType() == symbol) {
                return true;
            }

            var containerTypeSymbol = containerSymbol;
            var valueExportSymbol = containerTypeSymbol.getExportAssignedValueSymbol();
            var typeExportSymbol = containerTypeSymbol.getExportAssignedTypeSymbol();
            var containerExportSymbol = containerTypeSymbol.getExportAssignedContainerSymbol();
            if (valueExportSymbol || typeExportSymbol || containerExportSymbol) {
                return valueExportSymbol == symbol || typeExportSymbol == symbol || containerExportSymbol == symbol || PullContainerTypeSymbol.usedAsSymbol(containerExportSymbol, symbol);
            }

            return false;
        };
        return PullContainerTypeSymbol;
    })(PullTypeSymbol);
    TypeScript.PullContainerTypeSymbol = PullContainerTypeSymbol;

    var PullTypeAliasSymbol = (function (_super) {
        __extends(PullTypeAliasSymbol, _super);
        function PullTypeAliasSymbol(name) {
            _super.call(this, name, 256 /* TypeAlias */);
            this.typeAliasLink = null;
            this.isUsedAsValue = false;
            this.typeUsedExternally = false;
            this.retrievingExportAssignment = false;
        }
        PullTypeAliasSymbol.prototype.isAlias = function () {
            return true;
        };
        PullTypeAliasSymbol.prototype.isContainer = function () {
            return true;
        };

        PullTypeAliasSymbol.prototype.setAliasedType = function (type) {
            TypeScript.Debug.assert(!type.isError(), "Attempted to alias an error");
            if (this.typeAliasLink) {
                this.removeOutgoingLink(this.typeAliasLink);
            }

            this.typeAliasLink = this.addOutgoingLink(type, 8 /* Aliases */);
        };

        PullTypeAliasSymbol.prototype.getExportAssignedValueSymbol = function () {
            if (!this.typeAliasLink) {
                return null;
            }

            if (this.retrievingExportAssignment) {
                return null;
            }

            if (this.typeAliasLink.end.isContainer()) {
                this.retrievingExportAssignment = true;
                var sym = (this.typeAliasLink.end).getExportAssignedValueSymbol();
                this.retrievingExportAssignment = false;
                return sym;
            }

            return null;
        };

        PullTypeAliasSymbol.prototype.getExportAssignedTypeSymbol = function () {
            if (!this.typeAliasLink) {
                return null;
            }

            if (this.retrievingExportAssignment) {
                return null;
            }

            if (this.typeAliasLink.end.isContainer()) {
                this.retrievingExportAssignment = true;
                var sym = (this.typeAliasLink.end).getExportAssignedTypeSymbol();
                this.retrievingExportAssignment = false;
                return sym;
            }

            return null;
        };

        PullTypeAliasSymbol.prototype.getExportAssignedContainerSymbol = function () {
            if (!this.typeAliasLink) {
                return null;
            }

            if (this.retrievingExportAssignment) {
                return null;
            }

            if (this.typeAliasLink.end.isContainer()) {
                this.retrievingExportAssignment = true;
                var sym = (this.typeAliasLink.end).getExportAssignedContainerSymbol();
                this.retrievingExportAssignment = false;
                return sym;
            }

            return null;
        };

        PullTypeAliasSymbol.prototype.getType = function () {
            if (this.typeAliasLink) {
                return this.typeAliasLink.end;
            }

            return null;
        };

        PullTypeAliasSymbol.prototype.setType = function (type) {
            this.setAliasedType(type);
        };

        PullTypeAliasSymbol.prototype.setIsUsedAsValue = function () {
            this.isUsedAsValue = true;
        };

        PullTypeAliasSymbol.prototype.getIsUsedAsValue = function () {
            return this.isUsedAsValue;
        };

        PullTypeAliasSymbol.prototype.setIsTypeUsedExternally = function () {
            this.typeUsedExternally = true;
        };

        PullTypeAliasSymbol.prototype.getTypeUsedExternally = function () {
            return this.typeUsedExternally;
        };

        PullTypeAliasSymbol.prototype.getMembers = function () {
            if (this.typeAliasLink) {
                return (this.typeAliasLink.end).getMembers();
            }

            return [];
        };

        PullTypeAliasSymbol.prototype.getCallSignatures = function () {
            if (this.typeAliasLink) {
                return (this.typeAliasLink.end).getCallSignatures();
            }

            return [];
        };

        PullTypeAliasSymbol.prototype.getConstructSignatures = function () {
            if (this.typeAliasLink) {
                return (this.typeAliasLink.end).getConstructSignatures();
            }

            return [];
        };

        PullTypeAliasSymbol.prototype.getIndexSignatures = function () {
            if (this.typeAliasLink) {
                return (this.typeAliasLink.end).getIndexSignatures();
            }

            return [];
        };

        PullTypeAliasSymbol.prototype.findMember = function (name) {
            if (this.typeAliasLink) {
                return (this.typeAliasLink.end).findMember(name);
            }

            return null;
        };

        PullTypeAliasSymbol.prototype.findNestedType = function (name) {
            if (this.typeAliasLink) {
                return (this.typeAliasLink.end).findNestedType(name);
            }

            return null;
        };

        PullTypeAliasSymbol.prototype.getAllMembers = function (searchDeclKind, includePrivate) {
            if (this.typeAliasLink) {
                return (this.typeAliasLink.end).getAllMembers(searchDeclKind, includePrivate);
            }

            return [];
        };

        PullTypeAliasSymbol.prototype.invalidate = function () {
            this.isUsedAsValue = false;

            _super.prototype.invalidate.call(this);
        };
        return PullTypeAliasSymbol;
    })(PullTypeSymbol);
    TypeScript.PullTypeAliasSymbol = PullTypeAliasSymbol;

    var PullDefinitionSignatureSymbol = (function (_super) {
        __extends(PullDefinitionSignatureSymbol, _super);
        function PullDefinitionSignatureSymbol() {
            _super.apply(this, arguments);
        }
        PullDefinitionSignatureSymbol.prototype.isDefinition = function () {
            return true;
        };
        return PullDefinitionSignatureSymbol;
    })(PullSignatureSymbol);
    TypeScript.PullDefinitionSignatureSymbol = PullDefinitionSignatureSymbol;

    var PullFunctionTypeSymbol = (function (_super) {
        __extends(PullFunctionTypeSymbol, _super);
        function PullFunctionTypeSymbol() {
            _super.call(this, "", 16777216 /* FunctionType */);
            this.definitionSignature = null;
        }
        PullFunctionTypeSymbol.prototype.isFunction = function () {
            return true;
        };

        PullFunctionTypeSymbol.prototype.invalidate = function () {
            var callSignatures = this.getCallSignatures();

            if (callSignatures.length) {
                for (var i = 0; i < callSignatures.length; i++) {
                    callSignatures[i].invalidate();
                }
            }

            this.definitionSignature = null;

            _super.prototype.invalidate.call(this);
        };

        PullFunctionTypeSymbol.prototype.addSignature = function (signature) {
            this.addCallSignature(signature);

            if (signature.isDefinition()) {
                this.definitionSignature = signature;
            }
        };

        PullFunctionTypeSymbol.prototype.getDefinitionSignature = function () {
            return this.definitionSignature;
        };
        return PullFunctionTypeSymbol;
    })(PullTypeSymbol);
    TypeScript.PullFunctionTypeSymbol = PullFunctionTypeSymbol;

    var PullConstructorTypeSymbol = (function (_super) {
        __extends(PullConstructorTypeSymbol, _super);
        function PullConstructorTypeSymbol() {
            _super.call(this, "", 33554432 /* ConstructorType */);
            this.definitionSignature = null;
        }
        PullConstructorTypeSymbol.prototype.isFunction = function () {
            return true;
        };
        PullConstructorTypeSymbol.prototype.isConstructor = function () {
            return true;
        };

        PullConstructorTypeSymbol.prototype.invalidate = function () {
            this.definitionSignature = null;

            _super.prototype.invalidate.call(this);
        };

        PullConstructorTypeSymbol.prototype.addSignature = function (signature) {
            this.addConstructSignature(signature);

            if (signature.isDefinition()) {
                this.definitionSignature = signature;
            }
        };

        PullConstructorTypeSymbol.prototype.addTypeParameter = function (typeParameter, doNotChangeContainer) {
            this.addMember(typeParameter, 18 /* TypeParameter */, doNotChangeContainer);

            var constructSignatures = this.getConstructSignatures();

            for (var i = 0; i < constructSignatures.length; i++) {
                constructSignatures[i].addTypeParameter(typeParameter);
            }
        };

        PullConstructorTypeSymbol.prototype.getDefinitionSignature = function () {
            return this.definitionSignature;
        };
        return PullConstructorTypeSymbol;
    })(PullTypeSymbol);
    TypeScript.PullConstructorTypeSymbol = PullConstructorTypeSymbol;

    var PullTypeParameterSymbol = (function (_super) {
        __extends(PullTypeParameterSymbol, _super);
        function PullTypeParameterSymbol(name, _isFunctionTypeParameter) {
            _super.call(this, name, 8192 /* TypeParameter */);
            this._isFunctionTypeParameter = _isFunctionTypeParameter;
            this.constraintLink = null;
        }
        PullTypeParameterSymbol.prototype.isTypeParameter = function () {
            return true;
        };
        PullTypeParameterSymbol.prototype.isFunctionTypeParameter = function () {
            return this._isFunctionTypeParameter;
        };

        PullTypeParameterSymbol.prototype.isFixed = function () {
            return false;
        };

        PullTypeParameterSymbol.prototype.setConstraint = function (constraintType) {
            if (this.constraintLink) {
                this.removeOutgoingLink(this.constraintLink);
            }

            this.constraintLink = this.addOutgoingLink(constraintType, 22 /* TypeConstraint */);
        };

        PullTypeParameterSymbol.prototype.getConstraint = function () {
            if (this.constraintLink) {
                return this.constraintLink.end;
            }

            return null;
        };

        PullTypeParameterSymbol.prototype.isGeneric = function () {
            return true;
        };

        PullTypeParameterSymbol.prototype.fullName = function (scopeSymbol) {
            var name = this.getDisplayName(scopeSymbol);
            var container = this.getContainer();
            if (container) {
                var containerName = container.fullName(scopeSymbol);
                name = name + " in " + containerName;
            }

            return name;
        };

        PullTypeParameterSymbol.prototype.getName = function (scopeSymbol, useConstraintInName) {
            var name = _super.prototype.getName.call(this, scopeSymbol);

            if (this.isPrinting) {
                return name;
            }

            this.isPrinting = true;

            if (useConstraintInName && this.constraintLink) {
                name += " extends " + this.constraintLink.end.toString();
            }

            this.isPrinting = false;

            return name;
        };

        PullTypeParameterSymbol.prototype.getDisplayName = function (scopeSymbol, useConstraintInName) {
            var name = _super.prototype.getDisplayName.call(this, scopeSymbol, useConstraintInName);

            if (this.isPrinting) {
                return name;
            }

            this.isPrinting = true;

            if (useConstraintInName && this.constraintLink) {
                name += " extends " + this.constraintLink.end.toString();
            }

            this.isPrinting = false;

            return name;
        };

        PullTypeParameterSymbol.prototype.isExternallyVisible = function (inIsExternallyVisibleSymbols) {
            var constraint = this.getConstraint();
            if (constraint) {
                return PullSymbol.getIsExternallyVisible(constraint, this, inIsExternallyVisibleSymbols);
            }

            return true;
        };
        return PullTypeParameterSymbol;
    })(PullTypeSymbol);
    TypeScript.PullTypeParameterSymbol = PullTypeParameterSymbol;

    var PullTypeVariableSymbol = (function (_super) {
        __extends(PullTypeVariableSymbol, _super);
        function PullTypeVariableSymbol(name, isFunctionTypeParameter) {
            _super.call(this, name, isFunctionTypeParameter);
            this.tyvarID = TypeScript.globalTyvarID++;
        }
        PullTypeVariableSymbol.prototype.isTypeParameter = function () {
            return true;
        };
        PullTypeVariableSymbol.prototype.isTypeVariable = function () {
            return true;
        };
        return PullTypeVariableSymbol;
    })(PullTypeParameterSymbol);
    TypeScript.PullTypeVariableSymbol = PullTypeVariableSymbol;

    var PullAccessorSymbol = (function (_super) {
        __extends(PullAccessorSymbol, _super);
        function PullAccessorSymbol(name) {
            _super.call(this, name, 4096 /* Property */);
            this.getterSymbolLink = null;
            this.setterSymbolLink = null;
        }
        PullAccessorSymbol.prototype.isAccessor = function () {
            return true;
        };

        PullAccessorSymbol.prototype.setSetter = function (setter) {
            this.setterSymbolLink = this.addOutgoingLink(setter, 25 /* SetterFunction */);
        };

        PullAccessorSymbol.prototype.getSetter = function () {
            var setter = null;

            if (this.setterSymbolLink) {
                setter = this.setterSymbolLink.end;
            }

            return setter;
        };

        PullAccessorSymbol.prototype.removeSetter = function () {
            if (this.setterSymbolLink) {
                this.removeOutgoingLink(this.setterSymbolLink);
            }
        };

        PullAccessorSymbol.prototype.setGetter = function (getter) {
            this.getterSymbolLink = this.addOutgoingLink(getter, 24 /* GetterFunction */);
        };

        PullAccessorSymbol.prototype.getGetter = function () {
            var getter = null;

            if (this.getterSymbolLink) {
                getter = this.getterSymbolLink.end;
            }

            return getter;
        };

        PullAccessorSymbol.prototype.removeGetter = function () {
            if (this.getterSymbolLink) {
                this.removeOutgoingLink(this.getterSymbolLink);
            }
        };

        PullAccessorSymbol.prototype.invalidate = function () {
            if (this.getterSymbolLink) {
                this.getterSymbolLink.end.invalidate();
            }

            if (this.setterSymbolLink) {
                this.setterSymbolLink.end.invalidate();
            }

            _super.prototype.invalidate.call(this);
        };
        return PullAccessorSymbol;
    })(PullSymbol);
    TypeScript.PullAccessorSymbol = PullAccessorSymbol;

    var PullArrayTypeSymbol = (function (_super) {
        __extends(PullArrayTypeSymbol, _super);
        function PullArrayTypeSymbol() {
            _super.call(this, "Array", 128 /* Array */);
            this.elementType = null;
        }
        PullArrayTypeSymbol.prototype.isArray = function () {
            return true;
        };
        PullArrayTypeSymbol.prototype.getElementType = function () {
            return this.elementType;
        };
        PullArrayTypeSymbol.prototype.isGeneric = function () {
            return true;
        };

        PullArrayTypeSymbol.prototype.setElementType = function (type) {
            this.elementType = type;
        };

        PullArrayTypeSymbol.prototype.getScopedNameEx = function (scopeSymbol, useConstraintInName, getPrettyTypeName, getTypeParamMarkerInfo) {
            var elementMemberName = this.elementType ? (this.elementType.isArray() || this.elementType.isNamedTypeSymbol() ? this.elementType.getScopedNameEx(scopeSymbol, false, getPrettyTypeName, getTypeParamMarkerInfo) : this.elementType.getMemberTypeNameEx(false, scopeSymbol, getPrettyTypeName)) : TypeScript.MemberName.create("any");
            return TypeScript.MemberName.create(elementMemberName, "", "[]");
        };

        PullArrayTypeSymbol.prototype.getMemberTypeNameEx = function (topLevel, scopeSymbol, getPrettyTypeName) {
            var elementMemberName = this.elementType ? this.elementType.getMemberTypeNameEx(false, scopeSymbol, getPrettyTypeName) : TypeScript.MemberName.create("any");
            return TypeScript.MemberName.create(elementMemberName, "", "[]");
        };
        return PullArrayTypeSymbol;
    })(PullTypeSymbol);
    TypeScript.PullArrayTypeSymbol = PullArrayTypeSymbol;

    function specializeToArrayType(typeToReplace, typeToSpecializeTo, resolver, context) {
        var arrayInterfaceType = resolver.getCachedArrayType();

        if (!arrayInterfaceType || (arrayInterfaceType.getKind() & 16 /* Interface */) === 0) {
            return null;
        }

        if (arrayInterfaceType.isGeneric()) {
            var enclosingDecl = arrayInterfaceType.getDeclarations()[0];
            return specializeType(arrayInterfaceType, [typeToSpecializeTo], resolver, enclosingDecl, context);
        }

        if (typeToSpecializeTo.getArrayType()) {
            return typeToSpecializeTo.getArrayType();
        }

        var newArrayType = new PullArrayTypeSymbol();
        newArrayType.addDeclaration(arrayInterfaceType.getDeclarations()[0]);

        typeToSpecializeTo.setArrayType(newArrayType);
        newArrayType.addOutgoingLink(typeToSpecializeTo, 4 /* ArrayOf */);

        var field = null;
        var newField = null;
        var fieldType = null;

        var method = null;
        var methodType = null;
        var newMethod = null;
        var newMethodType = null;

        var signatures = null;
        var newSignature = null;

        var parameters = null;
        var newParameter = null;
        var parameterType = null;

        var returnType = null;
        var newReturnType = null;

        var members = arrayInterfaceType.getMembers();

        for (var i = 0; i < members.length; i++) {
            resolver.resolveDeclaredSymbol(members[i], null, context);

            if (members[i].getKind() === 65536 /* Method */) {
                method = members[i];

                resolver.resolveDeclaredSymbol(method, null, context);

                methodType = method.getType();

                newMethod = new PullSymbol(method.getName(), 65536 /* Method */);
                newMethodType = new PullFunctionTypeSymbol();
                newMethod.setType(newMethodType);

                newMethod.addDeclaration(method.getDeclarations()[0]);

                signatures = methodType.getCallSignatures();

                for (var j = 0; j < signatures.length; j++) {
                    newSignature = new PullSignatureSymbol(1048576 /* CallSignature */);
                    newSignature.addDeclaration(signatures[j].getDeclarations()[0]);

                    parameters = signatures[j].getParameters();
                    returnType = signatures[j].getReturnType();

                    if (returnType === typeToReplace) {
                        newSignature.setReturnType(typeToSpecializeTo);
                    } else {
                        newSignature.setReturnType(returnType);
                    }

                    for (var k = 0; k < parameters.length; k++) {
                        newParameter = new PullSymbol(parameters[k].getName(), parameters[k].getKind());

                        parameterType = parameters[k].getType();

                        if (parameterType === null) {
                            continue;
                        }

                        if (parameterType === typeToReplace) {
                            newParameter.setType(typeToSpecializeTo);
                        } else {
                            newParameter.setType(parameterType);
                        }

                        newSignature.addParameter(newParameter);
                    }

                    newMethodType.addSignature(newSignature);
                }

                newArrayType.addMember(newMethod, 5 /* PublicMember */);
            } else {
                field = members[i];

                newField = new PullSymbol(field.getName(), field.getKind());
                newField.addDeclaration(field.getDeclarations()[0]);

                fieldType = field.getType();

                if (fieldType === typeToReplace) {
                    newField.setType(typeToSpecializeTo);
                } else {
                    newField.setType(fieldType);
                }

                newArrayType.addMember(newField, 5 /* PublicMember */);
            }
        }
        newArrayType.addOutgoingLink(arrayInterfaceType, 3 /* ArrayType */);
        return newArrayType;
    }
    TypeScript.specializeToArrayType = specializeToArrayType;

    function typeWrapsTypeParameter(type, typeParameter) {
        if (type.isTypeParameter()) {
            return type == typeParameter;
        }

        var typeArguments = type.getTypeArguments();

        if (typeArguments) {
            for (var i = 0; i < typeArguments.length; i++) {
                if (typeWrapsTypeParameter(typeArguments[i], typeParameter)) {
                    return true;
                }
            }
        }

        return false;
    }
    TypeScript.typeWrapsTypeParameter = typeWrapsTypeParameter;

    function getRootType(typeToSpecialize) {
        var decl = typeToSpecialize.getDeclarations()[0];

        if (!typeToSpecialize.isGeneric()) {
            return typeToSpecialize;
        }

        return (typeToSpecialize.getKind() & (8 /* Class */ | 16 /* Interface */)) ? decl.getSymbol().getType() : typeToSpecialize;
    }
    TypeScript.getRootType = getRootType;

    TypeScript.nSpecializationsCreated = 0;
    TypeScript.nSpecializedSignaturesCreated = 0;

    function shouldSpecializeTypeParameterForTypeParameter(specialization, typeToSpecialize) {
        if (specialization == typeToSpecialize) {
            return false;
        }

        if (!(specialization.isTypeParameter() && typeToSpecialize.isTypeParameter())) {
            return true;
        }

        var parent = specialization.getDeclarations()[0].getParentDecl();
        var targetParent = typeToSpecialize.getDeclarations()[0].getParentDecl();

        if (parent == targetParent) {
            return true;
        }

        while (parent) {
            if (parent.getFlags() & 16 /* Static */) {
                return true;
            }

            if (parent == targetParent) {
                return false;
            }

            parent = parent.getParentDecl();
        }

        return true;
    }
    TypeScript.shouldSpecializeTypeParameterForTypeParameter = shouldSpecializeTypeParameterForTypeParameter;

    function specializeType(typeToSpecialize, typeArguments, resolver, enclosingDecl, context, ast) {
        if (typeToSpecialize.isPrimitive() || !typeToSpecialize.isGeneric()) {
            return typeToSpecialize;
        }

        var searchForExistingSpecialization = typeArguments != null;

        if (typeArguments === null || (context.specializingToAny && typeArguments.length)) {
            typeArguments = [];
        }

        if (typeToSpecialize.isTypeParameter()) {
            if (context.specializingToAny) {
                return resolver.semanticInfoChain.anyTypeSymbol;
            }

            var substitution = context.findSpecializationForType(typeToSpecialize);

            if (substitution != typeToSpecialize) {
                if (shouldSpecializeTypeParameterForTypeParameter(substitution, typeToSpecialize)) {
                    return substitution;
                }
            }

            if (typeArguments && typeArguments.length) {
                if (shouldSpecializeTypeParameterForTypeParameter(typeArguments[0], typeToSpecialize)) {
                    return typeArguments[0];
                }
            }

            return typeToSpecialize;
        }

        if (typeToSpecialize.isArray()) {
            if (typeToSpecialize.currentlyBeingSpecialized()) {
                return typeToSpecialize;
            }

            var newElementType = null;

            if (!context.specializingToAny) {
                var elementType = (typeToSpecialize).getElementType();

                newElementType = specializeType(elementType, typeArguments, resolver, enclosingDecl, context, ast);
            } else {
                newElementType = resolver.semanticInfoChain.anyTypeSymbol;
            }

            var newArrayType = specializeType(resolver.getCachedArrayType(), [newElementType], resolver, enclosingDecl, context);

            return newArrayType;
        }

        var typeParameters = typeToSpecialize.getTypeParameters();

        if (!context.specializingToAny && searchForExistingSpecialization && (typeParameters.length > typeArguments.length)) {
            searchForExistingSpecialization = false;
        }

        var newType = null;

        var newTypeDecl = typeToSpecialize.getDeclarations()[0];

        var rootType = getRootType(typeToSpecialize);

        var isArray = typeToSpecialize === resolver.getCachedArrayType() || typeToSpecialize.isArray();

        if (searchForExistingSpecialization || context.specializingToAny) {
            if (!typeArguments.length || context.specializingToAny) {
                for (var i = 0; i < typeParameters.length; i++) {
                    typeArguments[typeArguments.length] = resolver.semanticInfoChain.anyTypeSymbol;
                }
            }

            if (isArray) {
                newType = typeArguments[0].getArrayType();
            } else if (typeArguments.length) {
                newType = rootType.getSpecialization(typeArguments);
            }

            if (!newType && !typeParameters.length && context.specializingToAny) {
                newType = rootType.getSpecialization([resolver.semanticInfoChain.anyTypeSymbol]);
            }

            for (var i = 0; i < typeArguments.length; i++) {
                if (!typeArguments[i].isTypeParameter() && (typeArguments[i] == rootType || typeWrapsTypeParameter(typeArguments[i], typeParameters[i]))) {
                    declAST = resolver.semanticInfoChain.getASTForDecl(newTypeDecl);
                    if (declAST && typeArguments[i] != resolver.getCachedArrayType()) {
                        diagnostic = context.postError(enclosingDecl.getScriptName(), declAST.minChar, declAST.getLength(), 225 /* A_generic_type_may_not_reference_itself_with_its_own_type_parameters */, null, enclosingDecl, true);
                        return resolver.getNewErrorTypeSymbol(diagnostic);
                    } else {
                        return resolver.semanticInfoChain.anyTypeSymbol;
                    }
                }
            }
        } else {
            var knownTypeArguments = typeToSpecialize.getTypeArguments();
            var typesToReplace = knownTypeArguments ? knownTypeArguments : typeParameters;
            var diagnostic;
            var declAST;

            for (var i = 0; i < typesToReplace.length; i++) {
                if (!typesToReplace[i].isTypeParameter() && (typeArguments[i] == rootType || typeWrapsTypeParameter(typesToReplace[i], typeParameters[i]))) {
                    declAST = resolver.semanticInfoChain.getASTForDecl(newTypeDecl);
                    if (declAST && typeArguments[i] != resolver.getCachedArrayType()) {
                        diagnostic = context.postError(enclosingDecl.getScriptName(), declAST.minChar, declAST.getLength(), 225 /* A_generic_type_may_not_reference_itself_with_its_own_type_parameters */, null, enclosingDecl, true);
                        return resolver.getNewErrorTypeSymbol(diagnostic);
                    } else {
                        return resolver.semanticInfoChain.anyTypeSymbol;
                    }
                }

                substitution = specializeType(typesToReplace[i], null, resolver, enclosingDecl, context, ast);

                typeArguments[i] = substitution != null ? substitution : typesToReplace[i];
            }

            newType = rootType.getSpecialization(typeArguments);
        }

        var rootTypeParameters = rootType.getTypeParameters();

        if (rootTypeParameters.length && (rootTypeParameters.length == typeArguments.length)) {
            for (var i = 0; i < typeArguments.length; i++) {
                if (typeArguments[i] != rootTypeParameters[i]) {
                    break;
                }
            }

            if (i == rootTypeParameters.length) {
                return rootType;
            }
        }

        if (newType) {
            if (!newType.isResolved() && !newType.currentlyBeingSpecialized()) {
                typeToSpecialize.invalidateSpecializations();
            } else {
                return newType;
            }
        }

        var prevInSpecialization = context.inSpecialization;
        context.inSpecialization = true;

        TypeScript.nSpecializationsCreated++;

        newType = typeToSpecialize.isClass() ? new PullClassTypeSymbol(typeToSpecialize.getName()) : isArray ? new PullArrayTypeSymbol() : typeToSpecialize.isTypeParameter() ? new PullTypeVariableSymbol(typeToSpecialize.getName(), (typeToSpecialize).isFunctionTypeParameter()) : new PullTypeSymbol(typeToSpecialize.getName(), typeToSpecialize.getKind());
        newType.setRootSymbol(rootType);

        newType.setIsBeingSpecialized();

        newType.setTypeArguments(typeArguments);

        rootType.addSpecialization(newType, typeArguments);

        if (isArray) {
            (newType).setElementType(typeArguments[0]);
            typeArguments[0].setArrayType(newType);
        }

        if (typeToSpecialize.currentlyBeingSpecialized()) {
            return newType;
        }

        var prevCurrentlyBeingSpecialized = typeToSpecialize.currentlyBeingSpecialized();
        if (typeToSpecialize.getKind() == 33554432 /* ConstructorType */) {
            typeToSpecialize.setIsBeingSpecialized();
        }

        var typeReplacementMap = {};

        for (var i = 0; i < typeParameters.length; i++) {
            if (typeParameters[i] != typeArguments[i]) {
                typeReplacementMap[typeParameters[i].getSymbolID().toString()] = typeArguments[i];
            }
            newType.addMember(typeParameters[i], 18 /* TypeParameter */, true);
        }

        var extendedTypesToSpecialize = typeToSpecialize.getExtendedTypes();
        var typeDecl;
        var typeAST;
        var unitPath;
        var decls = typeToSpecialize.getDeclarations();

        if (extendedTypesToSpecialize.length) {
            for (var i = 0; i < decls.length; i++) {
                typeDecl = decls[i];
                typeAST = resolver.semanticInfoChain.getASTForDecl(typeDecl);

                if (typeAST.extendsList) {
                    unitPath = resolver.getUnitPath();
                    resolver.setUnitPath(typeDecl.getScriptName());
                    context.pushTypeSpecializationCache(typeReplacementMap);
                    var extendTypeSymbol = resolver.resolveTypeReference(new TypeScript.TypeReference(typeAST.extendsList.members[0], 0), typeDecl, context).symbol;
                    resolver.setUnitPath(unitPath);
                    context.popTypeSpecializationCache();

                    newType.addExtendedType(extendTypeSymbol);
                }
            }
        }

        var implementedTypesToSpecialize = typeToSpecialize.getImplementedTypes();

        if (implementedTypesToSpecialize.length) {
            for (var i = 0; i < decls.length; i++) {
                typeDecl = decls[i];
                typeAST = resolver.semanticInfoChain.getASTForDecl(typeDecl);

                if (typeAST.implementsList) {
                    unitPath = resolver.getUnitPath();
                    resolver.setUnitPath(typeDecl.getScriptName());
                    context.pushTypeSpecializationCache(typeReplacementMap);
                    var implementedTypeSymbol = resolver.resolveTypeReference(new TypeScript.TypeReference(typeAST.implementsList.members[0], 0), typeDecl, context).symbol;
                    resolver.setUnitPath(unitPath);
                    context.popTypeSpecializationCache();

                    newType.addImplementedType(implementedTypeSymbol);
                }
            }
        }

        var callSignatures = typeToSpecialize.getCallSignatures(false);
        var constructSignatures = typeToSpecialize.getConstructSignatures(false);
        var indexSignatures = typeToSpecialize.getIndexSignatures(false);
        var members = typeToSpecialize.getMembers();

        var newSignature;
        var signature;

        var decl = null;
        var declAST = null;
        var parameters;
        var newParameters;
        var returnType = null;
        var prevSpecializationSignature = null;

        for (var i = 0; i < callSignatures.length; i++) {
            signature = callSignatures[i];

            if (!signature.currentlyBeingSpecialized()) {
                context.pushTypeSpecializationCache(typeReplacementMap);

                decl = signature.getDeclarations()[0];
                unitPath = resolver.getUnitPath();
                resolver.setUnitPath(decl.getScriptName());

                newSignature = new PullSignatureSymbol(signature.getKind());
                TypeScript.nSpecializedSignaturesCreated++;
                newSignature.mimicSignature(signature, resolver);
                declAST = resolver.semanticInfoChain.getASTForDecl(decl);

                TypeScript.Debug.assert(declAST != null, "Call signature for type '" + typeToSpecialize.toString() + "' could not be specialized because of a stale declaration");

                prevSpecializationSignature = decl.getSpecializingSignatureSymbol();
                decl.setSpecializingSignatureSymbol(newSignature);
                resolver.resolveAST(declAST, false, newTypeDecl, context);
                decl.setSpecializingSignatureSymbol(prevSpecializationSignature);

                parameters = signature.getParameters();
                newParameters = newSignature.getParameters();

                for (var p = 0; p < parameters.length; p++) {
                    newParameters[p].setType(parameters[p].getType());
                }
                newSignature.setResolved();

                resolver.setUnitPath(unitPath);

                returnType = newSignature.getReturnType();

                if (!returnType) {
                    newSignature.setReturnType(signature.getReturnType());
                }

                signature.setIsBeingSpecialized();
                newSignature.setRootSymbol(signature);
                newSignature = specializeSignature(newSignature, true, typeReplacementMap, null, resolver, newTypeDecl, context);
                signature.setIsSpecialized();

                context.popTypeSpecializationCache();

                if (!newSignature) {
                    context.inSpecialization = prevInSpecialization;
                    typeToSpecialize.setValueIsBeingSpecialized(prevCurrentlyBeingSpecialized);
                    TypeScript.Debug.assert(false, "returning from call");
                    return resolver.semanticInfoChain.anyTypeSymbol;
                }
            } else {
                newSignature = signature;
            }

            newType.addCallSignature(newSignature);

            if (newSignature.hasGenericParameter()) {
                newType.setHasGenericSignature();
            }
        }

        for (var i = 0; i < constructSignatures.length; i++) {
            signature = constructSignatures[i];

            if (!signature.currentlyBeingSpecialized()) {
                context.pushTypeSpecializationCache(typeReplacementMap);

                decl = signature.getDeclarations()[0];
                unitPath = resolver.getUnitPath();
                resolver.setUnitPath(decl.getScriptName());

                newSignature = new PullSignatureSymbol(signature.getKind());
                TypeScript.nSpecializedSignaturesCreated++;
                newSignature.mimicSignature(signature, resolver);
                declAST = resolver.semanticInfoChain.getASTForDecl(decl);

                TypeScript.Debug.assert(declAST != null, "Construct signature for type '" + typeToSpecialize.toString() + "' could not be specialized because of a stale declaration");

                prevSpecializationSignature = decl.getSpecializingSignatureSymbol();
                decl.setSpecializingSignatureSymbol(newSignature);
                resolver.resolveAST(declAST, false, newTypeDecl, context);
                decl.setSpecializingSignatureSymbol(prevSpecializationSignature);

                parameters = signature.getParameters();
                newParameters = newSignature.getParameters();

                for (var p = 0; p < parameters.length; p++) {
                    newParameters[p].setType(parameters[p].getType());
                }
                newSignature.setResolved();

                resolver.setUnitPath(unitPath);

                returnType = newSignature.getReturnType();

                if (!returnType) {
                    newSignature.setReturnType(signature.getReturnType());
                }

                signature.setIsBeingSpecialized();
                newSignature.setRootSymbol(signature);
                newSignature = specializeSignature(newSignature, true, typeReplacementMap, null, resolver, newTypeDecl, context);
                signature.setIsSpecialized();

                context.popTypeSpecializationCache();

                if (!newSignature) {
                    context.inSpecialization = prevInSpecialization;
                    typeToSpecialize.setValueIsBeingSpecialized(prevCurrentlyBeingSpecialized);
                    TypeScript.Debug.assert(false, "returning from construct");
                    return resolver.semanticInfoChain.anyTypeSymbol;
                }
            } else {
                newSignature = signature;
            }

            newType.addConstructSignature(newSignature);

            if (newSignature.hasGenericParameter()) {
                newType.setHasGenericSignature();
            }
        }

        for (var i = 0; i < indexSignatures.length; i++) {
            signature = indexSignatures[i];

            if (!signature.currentlyBeingSpecialized()) {
                context.pushTypeSpecializationCache(typeReplacementMap);

                decl = signature.getDeclarations()[0];
                unitPath = resolver.getUnitPath();
                resolver.setUnitPath(decl.getScriptName());

                newSignature = new PullSignatureSymbol(signature.getKind());
                TypeScript.nSpecializedSignaturesCreated++;
                newSignature.mimicSignature(signature, resolver);
                declAST = resolver.semanticInfoChain.getASTForDecl(decl);

                TypeScript.Debug.assert(declAST != null, "Index signature for type '" + typeToSpecialize.toString() + "' could not be specialized because of a stale declaration");

                prevSpecializationSignature = decl.getSpecializingSignatureSymbol();
                decl.setSpecializingSignatureSymbol(newSignature);
                resolver.resolveAST(declAST, false, newTypeDecl, context);
                decl.setSpecializingSignatureSymbol(prevSpecializationSignature);

                parameters = signature.getParameters();
                newParameters = newSignature.getParameters();

                for (var p = 0; p < parameters.length; p++) {
                    newParameters[p].setType(parameters[p].getType());
                }
                newSignature.setResolved();

                resolver.setUnitPath(unitPath);

                returnType = newSignature.getReturnType();

                if (!returnType) {
                    newSignature.setReturnType(signature.getReturnType());
                }

                signature.setIsBeingSpecialized();
                newSignature.setRootSymbol(signature);
                newSignature = specializeSignature(newSignature, true, typeReplacementMap, null, resolver, newTypeDecl, context);
                signature.setIsSpecialized();

                context.popTypeSpecializationCache();

                if (!newSignature) {
                    context.inSpecialization = prevInSpecialization;
                    typeToSpecialize.setValueIsBeingSpecialized(prevCurrentlyBeingSpecialized);
                    TypeScript.Debug.assert(false, "returning from index");
                    return resolver.semanticInfoChain.anyTypeSymbol;
                }
            } else {
                newSignature = signature;
            }

            newType.addIndexSignature(newSignature);

            if (newSignature.hasGenericParameter()) {
                newType.setHasGenericSignature();
            }
        }

        var field = null;
        var newField = null;

        var fieldType = null;
        var newFieldType = null;
        var replacementType = null;

        var fieldSignatureSymbol = null;

        for (var i = 0; i < members.length; i++) {
            field = members[i];
            field.setIsBeingSpecialized();

            decls = field.getDeclarations();

            newField = new PullSymbol(field.getName(), field.getKind());

            newField.setRootSymbol(field);

            if (field.getIsOptional()) {
                newField.setIsOptional();
            }

            if (!field.isResolved()) {
                resolver.resolveDeclaredSymbol(field, newTypeDecl, context);
            }

            fieldType = field.getType();

            if (!fieldType) {
                fieldType = newType;
            }

            replacementType = typeReplacementMap[fieldType.getSymbolID().toString()];

            if (replacementType) {
                newField.setType(replacementType);
            } else {
                if (fieldType.isGeneric() && !fieldType.isFixed()) {
                    unitPath = resolver.getUnitPath();
                    resolver.setUnitPath(decls[0].getScriptName());

                    context.pushTypeSpecializationCache(typeReplacementMap);

                    newFieldType = specializeType(fieldType, !fieldType.getIsSpecialized() ? typeArguments : null, resolver, newTypeDecl, context, ast);

                    resolver.setUnitPath(unitPath);

                    context.popTypeSpecializationCache();

                    newField.setType(newFieldType);
                } else {
                    newField.setType(fieldType);
                }
            }
            field.setIsSpecialized();
            newType.addMember(newField, (field.hasFlag(2 /* Private */)) ? 6 /* PrivateMember */ : 5 /* PublicMember */);
        }

        if (typeToSpecialize.isClass()) {
            var constructorMethod = (typeToSpecialize).getConstructorMethod();

            if (!constructorMethod.isResolved()) {
                var prevIsSpecializingConstructorMethod = context.isSpecializingConstructorMethod;
                context.isSpecializingConstructorMethod = true;
                resolver.resolveDeclaredSymbol(constructorMethod, enclosingDecl, context);
                context.isSpecializingConstructorMethod = prevIsSpecializingConstructorMethod;
            }

            var newConstructorMethod = new PullSymbol(constructorMethod.getName(), 32768 /* ConstructorMethod */);
            var newConstructorType = specializeType(constructorMethod.getType(), typeArguments, resolver, newTypeDecl, context, ast);

            newConstructorMethod.setType(newConstructorType);

            var constructorDecls = constructorMethod.getDeclarations();

            newConstructorMethod.setRootSymbol(constructorMethod);

            (newType).setConstructorMethod(newConstructorMethod);
        }

        newType.setIsSpecialized();

        newType.setResolved();
        typeToSpecialize.setValueIsBeingSpecialized(prevCurrentlyBeingSpecialized);
        context.inSpecialization = prevInSpecialization;
        return newType;
    }
    TypeScript.specializeType = specializeType;

    function specializeSignature(signature, skipLocalTypeParameters, typeReplacementMap, typeArguments, resolver, enclosingDecl, context, ast) {
        if (signature.currentlyBeingSpecialized()) {
            return signature;
        }

        if (!signature.isResolved() && !signature.isResolving()) {
            resolver.resolveDeclaredSymbol(signature, enclosingDecl, context);
        }

        var newSignature = signature.getSpecialization(typeArguments);

        if (newSignature) {
            return newSignature;
        }

        signature.setIsBeingSpecialized();

        var prevInSpecialization = context.inSpecialization;
        context.inSpecialization = true;

        newSignature = new PullSignatureSymbol(signature.getKind());
        TypeScript.nSpecializedSignaturesCreated++;
        newSignature.setRootSymbol(signature);

        if (signature.hasVariableParamList()) {
            newSignature.setHasVariableParamList();
        }

        if (signature.hasGenericParameter()) {
            newSignature.setHasGenericParameter();
        }

        signature.addSpecialization(newSignature, typeArguments);

        var parameters = signature.getParameters();
        var typeParameters = signature.getTypeParameters();
        var returnType = signature.getReturnType();

        for (var i = 0; i < typeParameters.length; i++) {
            newSignature.addTypeParameter(typeParameters[i]);
        }

        if (signature.hasGenericParameter()) {
            newSignature.setHasGenericParameter();
        }

        var newParameter;
        var newParameterType;
        var newParameterElementType;
        var parameterType;
        var replacementParameterType;
        var localTypeParameters = new TypeScript.BlockIntrinsics();
        var localSkipMap = null;

        if (skipLocalTypeParameters) {
            for (var i = 0; i < typeParameters.length; i++) {
                localTypeParameters[typeParameters[i].getName()] = true;
                if (!localSkipMap) {
                    localSkipMap = {};
                }
                localSkipMap[typeParameters[i].getSymbolID().toString()] = typeParameters[i];
            }
        }

        context.pushTypeSpecializationCache(typeReplacementMap);

        if (skipLocalTypeParameters && localSkipMap) {
            context.pushTypeSpecializationCache(localSkipMap);
        }
        var newReturnType = (!localTypeParameters[returnType.getName()]) ? specializeType(returnType, null, resolver, enclosingDecl, context, ast) : returnType;
        if (skipLocalTypeParameters && localSkipMap) {
            context.popTypeSpecializationCache();
        }
        context.popTypeSpecializationCache();

        newSignature.setReturnType(newReturnType);

        for (var k = 0; k < parameters.length; k++) {
            newParameter = new PullSymbol(parameters[k].getName(), parameters[k].getKind());
            newParameter.setRootSymbol(parameters[k]);

            parameterType = parameters[k].getType();

            context.pushTypeSpecializationCache(typeReplacementMap);
            if (skipLocalTypeParameters && localSkipMap) {
                context.pushTypeSpecializationCache(localSkipMap);
            }
            newParameterType = !localTypeParameters[parameterType.getName()] ? specializeType(parameterType, null, resolver, enclosingDecl, context, ast) : parameterType;
            if (skipLocalTypeParameters && localSkipMap) {
                context.popTypeSpecializationCache();
            }
            context.popTypeSpecializationCache();

            if (parameters[k].getIsOptional()) {
                newParameter.setIsOptional();
            }

            if (parameters[k].getIsVarArg()) {
                newParameter.setIsVarArg();
                newSignature.setHasVariableParamList();
            }

            if (resolver.isTypeArgumentOrWrapper(newParameterType)) {
                newSignature.setHasGenericParameter();
            }

            newParameter.setType(newParameterType);
            newSignature.addParameter(newParameter, newParameter.getIsOptional());
        }

        signature.setIsSpecialized();

        context.inSpecialization = prevInSpecialization;

        return newSignature;
    }
    TypeScript.specializeSignature = specializeSignature;

    function getIDForTypeSubstitutions(types) {
        var substitution = "";

        for (var i = 0; i < types.length; i++) {
            substitution += types[i].getSymbolID().toString() + "#";
        }

        return substitution;
    }
    TypeScript.getIDForTypeSubstitutions = getIDForTypeSubstitutions;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var PullSymbolBindingContext = (function () {
        function PullSymbolBindingContext(semanticInfoChain, scriptName) {
            this.semanticInfoChain = semanticInfoChain;
            this.scriptName = scriptName;
            this.parentChain = [];
            this.declPath = [];
            this.reBindingAfterChange = false;
            this.startingDeclForRebind = TypeScript.pullDeclID;
            this.semanticInfo = this.semanticInfoChain.getUnit(this.scriptName);
        }
        PullSymbolBindingContext.prototype.getParent = function (n) {
            if (typeof n === "undefined") { n = 0; }
            return this.parentChain ? this.parentChain[this.parentChain.length - 1 - n] : null;
        };
        PullSymbolBindingContext.prototype.getDeclPath = function () {
            return this.declPath;
        };

        PullSymbolBindingContext.prototype.pushParent = function (parentDecl) {
            if (parentDecl) {
                this.parentChain[this.parentChain.length] = parentDecl;
                this.declPath[this.declPath.length] = parentDecl.getName();
            }
        };

        PullSymbolBindingContext.prototype.popParent = function () {
            if (this.parentChain.length) {
                this.parentChain.length--;
                this.declPath.length--;
            }
        };
        return PullSymbolBindingContext;
    })();
    TypeScript.PullSymbolBindingContext = PullSymbolBindingContext;

    TypeScript.time_in_findSymbol = 0;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var CandidateInferenceInfo = (function () {
        function CandidateInferenceInfo() {
            this.typeParameter = null;
            this.isFixed = false;
            this.inferenceCandidates = [];
        }
        CandidateInferenceInfo.prototype.addCandidate = function (candidate) {
            if (!this.isFixed) {
                this.inferenceCandidates[this.inferenceCandidates.length] = candidate;
            }
        };
        return CandidateInferenceInfo;
    })();
    TypeScript.CandidateInferenceInfo = CandidateInferenceInfo;

    var ArgumentInferenceContext = (function () {
        function ArgumentInferenceContext() {
            this.inferenceCache = {};
            this.candidateCache = {};
        }
        ArgumentInferenceContext.prototype.alreadyRelatingTypes = function (objectType, parameterType) {
            var comboID = objectType.getSymbolID().toString() + "#" + parameterType.getSymbolID().toString();

            if (this.inferenceCache[comboID]) {
                return true;
            } else {
                this.inferenceCache[comboID] = true;
                return false;
            }
        };

        ArgumentInferenceContext.prototype.resetRelationshipCache = function () {
            this.inferenceCache = {};
        };

        ArgumentInferenceContext.prototype.addInferenceRoot = function (param) {
            var info = this.candidateCache[param.getSymbolID().toString()];

            if (!info) {
                info = new CandidateInferenceInfo();
                info.typeParameter = param;
                this.candidateCache[param.getSymbolID().toString()] = info;
            }
        };

        ArgumentInferenceContext.prototype.getInferenceInfo = function (param) {
            return this.candidateCache[param.getSymbolID().toString()];
        };

        ArgumentInferenceContext.prototype.addCandidateForInference = function (param, candidate, fix) {
            var info = this.getInferenceInfo(param);

            if (info) {
                if (candidate) {
                    info.addCandidate(candidate);
                }

                if (!info.isFixed) {
                    info.isFixed = fix;
                }
            }
        };

        ArgumentInferenceContext.prototype.getInferenceCandidates = function () {
            var inferenceCandidates = [];
            var info;
            var val;

            for (var infoKey in this.candidateCache) {
                info = this.candidateCache[infoKey];

                for (var i = 0; i < info.inferenceCandidates.length; i++) {
                    val = {};
                    val[info.typeParameter.getSymbolID().toString()] = info.inferenceCandidates[i];
                    inferenceCandidates[inferenceCandidates.length] = val;
                }
            }

            return inferenceCandidates;
        };

        ArgumentInferenceContext.prototype.inferArgumentTypes = function (resolver, context) {
            var info = null;

            var collection;

            var bestCommonType;

            var results = [];

            var unfit = false;

            for (var infoKey in this.candidateCache) {
                info = this.candidateCache[infoKey];

                if (!info.inferenceCandidates.length) {
                    results[results.length] = { param: info.typeParameter, type: resolver.semanticInfoChain.anyTypeSymbol };
                    continue;
                }

                collection = {
                    getLength: function () {
                        return info.inferenceCandidates.length;
                    },
                    setTypeAtIndex: function (index, type) {
                    },
                    getTypeAtIndex: function (index) {
                        return info.inferenceCandidates[index].getType();
                    }
                };

                bestCommonType = resolver.widenType(resolver.findBestCommonType(info.inferenceCandidates[0], null, collection, context, new TypeScript.TypeComparisonInfo()));

                if (!bestCommonType) {
                    unfit = true;
                } else {
                    for (var i = 0; i < results.length; i++) {
                        if (results[i].type == info.typeParameter) {
                            results[i].type = bestCommonType;
                        }
                    }
                }

                results[results.length] = { param: info.typeParameter, type: bestCommonType };
            }

            return { results: results, unfit: unfit };
        };
        return ArgumentInferenceContext;
    })();
    TypeScript.ArgumentInferenceContext = ArgumentInferenceContext;

    var PullContextualTypeContext = (function () {
        function PullContextualTypeContext(contextualType, provisional, substitutions) {
            this.contextualType = contextualType;
            this.provisional = provisional;
            this.substitutions = substitutions;
            this.provisionallyTypedSymbols = [];
            this.provisionalDiagnostic = [];
        }
        PullContextualTypeContext.prototype.recordProvisionallyTypedSymbol = function (symbol) {
            this.provisionallyTypedSymbols[this.provisionallyTypedSymbols.length] = symbol;
        };

        PullContextualTypeContext.prototype.invalidateProvisionallyTypedSymbols = function () {
            for (var i = 0; i < this.provisionallyTypedSymbols.length; i++) {
                this.provisionallyTypedSymbols[i].invalidate();
            }
        };

        PullContextualTypeContext.prototype.postDiagnostic = function (error) {
            this.provisionalDiagnostic[this.provisionalDiagnostic.length] = error;
        };

        PullContextualTypeContext.prototype.hadProvisionalErrors = function () {
            return this.provisionalDiagnostic.length > 0;
        };
        return PullContextualTypeContext;
    })();
    TypeScript.PullContextualTypeContext = PullContextualTypeContext;

    var PullTypeResolutionContext = (function () {
        function PullTypeResolutionContext() {
            this.contextStack = [];
            this.typeSpecializationStack = [];
            this.genericASTResolutionStack = [];
            this.resolvingTypeReference = false;
            this.resolvingNamespaceMemberAccess = false;
            this.resolveAggressively = false;
            this.canUseTypeSymbol = false;
            this.specializingToAny = false;
            this.specializingToObject = false;
            this.isResolvingClassExtendedType = false;
            this.isSpecializingSignatureAtCallSite = false;
            this.isSpecializingConstructorMethod = false;
            this.isComparingSpecializedSignatures = false;
            this.inSpecialization = false;
            this.suppressErrors = false;
            this.inBaseTypeResolution = false;
        }
        PullTypeResolutionContext.prototype.pushContextualType = function (type, provisional, substitutions) {
            this.contextStack.push(new PullContextualTypeContext(type, provisional, substitutions));
        };

        PullTypeResolutionContext.prototype.popContextualType = function () {
            var tc = this.contextStack.pop();

            tc.invalidateProvisionallyTypedSymbols();

            return tc;
        };

        PullTypeResolutionContext.prototype.findSubstitution = function (type) {
            var substitution = null;

            if (this.contextStack.length) {
                for (var i = this.contextStack.length - 1; i >= 0; i--) {
                    if (this.contextStack[i].substitutions) {
                        substitution = this.contextStack[i].substitutions[type.getSymbolID().toString()];

                        if (substitution) {
                            break;
                        }
                    }
                }
            }

            return substitution;
        };

        PullTypeResolutionContext.prototype.getContextualType = function () {
            var context = !this.contextStack.length ? null : this.contextStack[this.contextStack.length - 1];

            if (context) {
                var type = context.contextualType;

                if (!type) {
                    return null;
                }

                if (type.isTypeParameter() && (type).getConstraint()) {
                    type = (type).getConstraint();
                }

                var substitution = this.findSubstitution(type);

                return substitution ? substitution : type;
            }

            return null;
        };

        PullTypeResolutionContext.prototype.inProvisionalResolution = function () {
            return (!this.contextStack.length ? false : this.contextStack[this.contextStack.length - 1].provisional);
        };

        PullTypeResolutionContext.prototype.isInBaseTypeResolution = function () {
            return this.inBaseTypeResolution;
        };

        PullTypeResolutionContext.prototype.startBaseTypeResolution = function () {
            var wasInBaseTypeResoltion = this.inBaseTypeResolution;
            this.inBaseTypeResolution = true;
            return wasInBaseTypeResoltion;
        };

        PullTypeResolutionContext.prototype.doneBaseTypeResolution = function (wasInBaseTypeResolution) {
            this.inBaseTypeResolution = wasInBaseTypeResolution;
        };

        PullTypeResolutionContext.prototype.setTypeInContext = function (symbol, type) {
            var substitution = this.findSubstitution(type);

            symbol.setType(substitution ? substitution : type);

            if (this.contextStack.length && this.inProvisionalResolution()) {
                this.contextStack[this.contextStack.length - 1].recordProvisionallyTypedSymbol(symbol);
            }
        };

        PullTypeResolutionContext.prototype.pushTypeSpecializationCache = function (cache) {
            this.typeSpecializationStack[this.typeSpecializationStack.length] = cache;
        };

        PullTypeResolutionContext.prototype.popTypeSpecializationCache = function () {
            if (this.typeSpecializationStack.length) {
                this.typeSpecializationStack.length--;
            }
        };

        PullTypeResolutionContext.prototype.findSpecializationForType = function (type) {
            var specialization = null;

            for (var i = this.typeSpecializationStack.length - 1; i >= 0; i--) {
                specialization = (this.typeSpecializationStack[i])[type.getSymbolID().toString()];

                if (specialization) {
                    return specialization;
                }
            }

            return type;
        };

        PullTypeResolutionContext.prototype.postError = function (fileName, offset, length, diagnosticCode, arguments, enclosingDecl, addToDecl) {
            if (typeof arguments === "undefined") { arguments = null; }
            if (typeof enclosingDecl === "undefined") { enclosingDecl = null; }
            if (typeof addToDecl === "undefined") { addToDecl = false; }
            var diagnostic = new TypeScript.SemanticDiagnostic(fileName, offset, length, diagnosticCode, arguments);
            this.postDiagnostic(diagnostic, enclosingDecl, addToDecl);

            return diagnostic;
        };

        PullTypeResolutionContext.prototype.postDiagnostic = function (diagnostic, enclosingDecl, addToDecl) {
            if (this.inProvisionalResolution()) {
                (this.contextStack[this.contextStack.length - 1]).postDiagnostic(diagnostic);
            } else if (!this.suppressErrors && enclosingDecl && addToDecl) {
                enclosingDecl.addDiagnostic(diagnostic);
            }
        };

        PullTypeResolutionContext.prototype.startResolvingTypeArguments = function (ast) {
            this.genericASTResolutionStack[this.genericASTResolutionStack.length] = ast;
        };

        PullTypeResolutionContext.prototype.isResolvingTypeArguments = function (ast) {
            for (var i = 0; i < this.genericASTResolutionStack.length; i++) {
                if (this.genericASTResolutionStack[i].getID() === ast.getID()) {
                    return true;
                }
            }

            return false;
        };

        PullTypeResolutionContext.prototype.doneResolvingTypeArguments = function () {
            this.genericASTResolutionStack.length--;
        };
        return PullTypeResolutionContext;
    })();
    TypeScript.PullTypeResolutionContext = PullTypeResolutionContext;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SymbolAndDiagnostics = (function () {
        function SymbolAndDiagnostics(symbol, symbolAlias, diagnostics) {
            this.symbol = symbol;
            this.symbolAlias = symbolAlias;
            this.diagnostics = diagnostics;
        }
        SymbolAndDiagnostics.create = function (symbol, diagnostics) {
            return new SymbolAndDiagnostics(symbol, null, diagnostics);
        };

        SymbolAndDiagnostics.empty = function () {
            return SymbolAndDiagnostics._empty;
        };

        SymbolAndDiagnostics.fromSymbol = function (symbol) {
            return new SymbolAndDiagnostics(symbol, null, null);
        };

        SymbolAndDiagnostics.fromAlias = function (symbol, alias) {
            return new SymbolAndDiagnostics(symbol, alias, null);
        };

        SymbolAndDiagnostics.prototype.addDiagnostic = function (diagnostic) {
            TypeScript.Debug.assert(this !== SymbolAndDiagnostics._empty);

            if (this.diagnostics === null) {
                this.diagnostics = [];
            }

            this.diagnostics.push(diagnostic);
        };

        SymbolAndDiagnostics.prototype.withoutDiagnostics = function () {
            if (!this.diagnostics) {
                return this;
            }

            return SymbolAndDiagnostics.fromSymbol(this.symbol);
        };
        SymbolAndDiagnostics._empty = new SymbolAndDiagnostics(null, null, null);
        return SymbolAndDiagnostics;
    })();
    TypeScript.SymbolAndDiagnostics = SymbolAndDiagnostics;

    var PullResolutionDataCache = (function () {
        function PullResolutionDataCache() {
            this.cacheSize = 16;
            this.rdCache = [];
            this.nextUp = 0;
            for (var i = 0; i < this.cacheSize; i++) {
                this.rdCache[i] = {
                    actuals: [],
                    exactCandidates: [],
                    conversionCandidates: [],
                    id: i
                };
            }
        }
        PullResolutionDataCache.prototype.getResolutionData = function () {
            var rd = null;

            if (this.nextUp < this.cacheSize) {
                rd = this.rdCache[this.nextUp];
            }

            if (rd === null) {
                this.cacheSize++;
                rd = {
                    actuals: [],
                    exactCandidates: [],
                    conversionCandidates: [],
                    id: this.cacheSize
                };
                this.rdCache[this.cacheSize] = rd;
            }

            this.nextUp++;

            return rd;
        };

        PullResolutionDataCache.prototype.returnResolutionData = function (rd) {
            rd.actuals.length = 0;
            rd.exactCandidates.length = 0;
            rd.conversionCandidates.length = 0;

            this.nextUp = rd.id;
        };
        return PullResolutionDataCache;
    })();
    TypeScript.PullResolutionDataCache = PullResolutionDataCache;

    var PullAdditionalCallResolutionData = (function () {
        function PullAdditionalCallResolutionData() {
            this.targetSymbol = null;
            this.targetTypeSymbol = null;
            this.resolvedSignatures = null;
            this.candidateSignature = null;
            this.actualParametersContextTypeSymbols = null;
        }
        return PullAdditionalCallResolutionData;
    })();
    TypeScript.PullAdditionalCallResolutionData = PullAdditionalCallResolutionData;

    var PullAdditionalObjectLiteralResolutionData = (function () {
        function PullAdditionalObjectLiteralResolutionData() {
            this.membersContextTypeSymbols = null;
        }
        return PullAdditionalObjectLiteralResolutionData;
    })();
    TypeScript.PullAdditionalObjectLiteralResolutionData = PullAdditionalObjectLiteralResolutionData;

    var PullTypeResolver = (function () {
        function PullTypeResolver(compilationSettings, semanticInfoChain, unitPath) {
            this.compilationSettings = compilationSettings;
            this.semanticInfoChain = semanticInfoChain;
            this.unitPath = unitPath;
            this._cachedArrayInterfaceType = null;
            this._cachedNumberInterfaceType = null;
            this._cachedStringInterfaceType = null;
            this._cachedBooleanInterfaceType = null;
            this._cachedObjectInterfaceType = null;
            this._cachedFunctionInterfaceType = null;
            this._cachedIArgumentsInterfaceType = null;
            this._cachedRegExpInterfaceType = null;
            this.cachedFunctionArgumentsSymbol = null;
            this.assignableCache = {};
            this.subtypeCache = {};
            this.identicalCache = {};
            this.resolutionDataCache = new PullResolutionDataCache();
            this.currentUnit = null;
            this.cachedFunctionArgumentsSymbol = new TypeScript.PullSymbol("arguments", 1024 /* Variable */);
            this.cachedFunctionArgumentsSymbol.setType(this.cachedIArgumentsInterfaceType() ? this.cachedIArgumentsInterfaceType() : this.semanticInfoChain.anyTypeSymbol);
            this.cachedFunctionArgumentsSymbol.setResolved();

            var functionArgumentsDecl = new TypeScript.PullDecl("arguments", "arguments", 2048 /* Parameter */, 0 /* None */, new TypeScript.TextSpan(0, 0), unitPath);
            functionArgumentsDecl.setSymbol(this.cachedFunctionArgumentsSymbol);
            this.cachedFunctionArgumentsSymbol.addDeclaration(functionArgumentsDecl);

            this.currentUnit = this.semanticInfoChain.getUnit(unitPath);
        }
        PullTypeResolver.prototype.cleanCachedGlobals = function () {
            this._cachedArrayInterfaceType = null;
            this._cachedNumberInterfaceType = null;
            this._cachedStringInterfaceType = null;
            this._cachedBooleanInterfaceType = null;
            this._cachedObjectInterfaceType = null;
            this._cachedFunctionInterfaceType = null;
            this._cachedIArgumentsInterfaceType = null;
            this._cachedRegExpInterfaceType = null;
            this.cachedFunctionArgumentsSymbol = null;

            this.identicalCache = {};
            this.subtypeCache = {};
            this.assignableCache = {};
        };

        PullTypeResolver.prototype.cachedArrayInterfaceType = function () {
            if (!this._cachedArrayInterfaceType) {
                this._cachedArrayInterfaceType = this.getSymbolFromDeclPath("Array", [], 16 /* Interface */);
            }

            if (!this._cachedArrayInterfaceType) {
                this._cachedArrayInterfaceType = this.semanticInfoChain.anyTypeSymbol;
            }

            if (!this._cachedArrayInterfaceType.isResolved()) {
                this.resolveDeclaredSymbol(this._cachedArrayInterfaceType, null, new TypeScript.PullTypeResolutionContext());
            }

            return this._cachedArrayInterfaceType;
        };

        PullTypeResolver.prototype.getCachedArrayType = function () {
            return this.cachedArrayInterfaceType();
        };

        PullTypeResolver.prototype.cachedNumberInterfaceType = function () {
            if (!this._cachedNumberInterfaceType) {
                this._cachedNumberInterfaceType = this.getSymbolFromDeclPath("Number", [], 16 /* Interface */);
            }

            if (this._cachedNumberInterfaceType && !this._cachedNumberInterfaceType.isResolved()) {
                this.resolveDeclaredSymbol(this._cachedNumberInterfaceType, null, new TypeScript.PullTypeResolutionContext());
            }

            return this._cachedNumberInterfaceType;
        };

        PullTypeResolver.prototype.cachedStringInterfaceType = function () {
            if (!this._cachedStringInterfaceType) {
                this._cachedStringInterfaceType = this.getSymbolFromDeclPath("String", [], 16 /* Interface */);
            }

            if (this._cachedStringInterfaceType && !this._cachedStringInterfaceType.isResolved()) {
                this.resolveDeclaredSymbol(this._cachedStringInterfaceType, null, new TypeScript.PullTypeResolutionContext());
            }

            return this._cachedStringInterfaceType;
        };

        PullTypeResolver.prototype.cachedBooleanInterfaceType = function () {
            if (!this._cachedBooleanInterfaceType) {
                this._cachedBooleanInterfaceType = this.getSymbolFromDeclPath("Boolean", [], 16 /* Interface */);
            }

            if (this._cachedBooleanInterfaceType && !this._cachedBooleanInterfaceType.isResolved()) {
                this.resolveDeclaredSymbol(this._cachedBooleanInterfaceType, null, new TypeScript.PullTypeResolutionContext());
            }

            return this._cachedBooleanInterfaceType;
        };

        PullTypeResolver.prototype.cachedObjectInterfaceType = function () {
            if (!this._cachedObjectInterfaceType) {
                this._cachedObjectInterfaceType = this.getSymbolFromDeclPath("Object", [], 16 /* Interface */);
            }

            if (!this._cachedObjectInterfaceType) {
                this._cachedObjectInterfaceType = this.semanticInfoChain.anyTypeSymbol;
            }

            if (!this._cachedObjectInterfaceType.isResolved()) {
                this.resolveDeclaredSymbol(this._cachedObjectInterfaceType, null, new TypeScript.PullTypeResolutionContext());
            }

            return this._cachedObjectInterfaceType;
        };

        PullTypeResolver.prototype.cachedFunctionInterfaceType = function () {
            if (!this._cachedFunctionInterfaceType) {
                this._cachedFunctionInterfaceType = this.getSymbolFromDeclPath("Function", [], 16 /* Interface */);
            }

            if (this._cachedFunctionInterfaceType && !this._cachedFunctionInterfaceType.isResolved()) {
                this.resolveDeclaredSymbol(this._cachedFunctionInterfaceType, null, new TypeScript.PullTypeResolutionContext());
            }

            return this._cachedFunctionInterfaceType;
        };

        PullTypeResolver.prototype.cachedIArgumentsInterfaceType = function () {
            if (!this._cachedIArgumentsInterfaceType) {
                this._cachedIArgumentsInterfaceType = this.getSymbolFromDeclPath("IArguments", [], 16 /* Interface */);
            }

            if (this._cachedIArgumentsInterfaceType && !this._cachedIArgumentsInterfaceType.isResolved()) {
                this.resolveDeclaredSymbol(this._cachedIArgumentsInterfaceType, null, new TypeScript.PullTypeResolutionContext());
            }

            return this._cachedIArgumentsInterfaceType;
        };

        PullTypeResolver.prototype.cachedRegExpInterfaceType = function () {
            if (!this._cachedRegExpInterfaceType) {
                this._cachedRegExpInterfaceType = this.getSymbolFromDeclPath("RegExp", [], 16 /* Interface */);
            }

            if (!this._cachedRegExpInterfaceType.isResolved()) {
                this.resolveDeclaredSymbol(this._cachedRegExpInterfaceType, null, new TypeScript.PullTypeResolutionContext());
            }

            return this._cachedRegExpInterfaceType;
        };

        PullTypeResolver.prototype.getUnitPath = function () {
            return this.unitPath;
        };

        PullTypeResolver.prototype.setUnitPath = function (unitPath) {
            this.unitPath = unitPath;

            this.currentUnit = this.semanticInfoChain.getUnit(unitPath);
        };

        PullTypeResolver.prototype.getDeclForAST = function (ast) {
            return this.semanticInfoChain.getDeclForAST(ast, this.unitPath);
        };

        PullTypeResolver.prototype.getSymbolAndDiagnosticsForAST = function (ast) {
            return this.semanticInfoChain.getSymbolAndDiagnosticsForAST(ast, this.unitPath);
        };

        PullTypeResolver.prototype.setSymbolAndDiagnosticsForAST = function (ast, symbolAndDiagnostics, context) {
            if (context && (context.inProvisionalResolution() || context.inSpecialization)) {
                return;
            }

            this.semanticInfoChain.setSymbolAndDiagnosticsForAST(ast, symbolAndDiagnostics, this.unitPath);
        };

        PullTypeResolver.prototype.getASTForSymbol = function (symbol) {
            return this.semanticInfoChain.getASTForSymbol(symbol, this.unitPath);
        };

        PullTypeResolver.prototype.getASTForDecl = function (decl) {
            return this.semanticInfoChain.getASTForDecl(decl);
        };

        PullTypeResolver.prototype.getNewErrorTypeSymbol = function (diagnostic, data) {
            return new TypeScript.PullErrorTypeSymbol(diagnostic, this.semanticInfoChain.anyTypeSymbol, data);
        };

        PullTypeResolver.prototype.getEnclosingDecl = function (decl) {
            var declPath = TypeScript.getPathToDecl(decl);

            if (!declPath.length) {
                return null;
            } else if (declPath.length > 1 && declPath[declPath.length - 1] === decl) {
                return declPath[declPath.length - 2];
            } else {
                return declPath[declPath.length - 1];
            }
        };

        PullTypeResolver.prototype.getExportedMemberSymbol = function (symbol, parent) {
            if (!(symbol.getKind() & (65536 /* Method */ | 4096 /* Property */))) {
                var containerType = !parent.isContainer() ? parent.getAssociatedContainerType() : parent;

                if (containerType && containerType.isContainer() && !TypeScript.PullHelpers.symbolIsEnum(parent)) {
                    if (symbol.hasFlag(1 /* Exported */)) {
                        return symbol;
                    }

                    return null;
                }
            }

            return symbol;
        };

        PullTypeResolver.prototype.getMemberSymbol = function (symbolName, declSearchKind, parent, searchContainedMembers) {
            if (typeof searchContainedMembers === "undefined") { searchContainedMembers = false; }
            var member = null;

            if (declSearchKind & TypeScript.PullElementKind.SomeValue) {
                member = parent.findMember(symbolName);
            } else {
                member = parent.findNestedType(symbolName);
            }

            if (member) {
                return this.getExportedMemberSymbol(member, parent);
            }

            var containerType = parent.getAssociatedContainerType();

            if (containerType) {
                if (containerType.isClass()) {
                    return null;
                }

                parent = containerType;
            }

            if (declSearchKind & TypeScript.PullElementKind.SomeValue) {
                member = parent.findMember(symbolName);
            } else {
                member = parent.findNestedType(symbolName);
            }

            if (member) {
                return this.getExportedMemberSymbol(member, parent);
            }

            var typeDeclarations = parent.getDeclarations();
            var childDecls = null;

            for (var j = 0; j < typeDeclarations.length; j++) {
                childDecls = typeDeclarations[j].searchChildDecls(symbolName, declSearchKind);

                if (childDecls.length) {
                    return this.getExportedMemberSymbol(childDecls[0].getSymbol(), parent);
                }
            }
        };

        PullTypeResolver.prototype.getSymbolFromDeclPath = function (symbolName, declPath, declSearchKind) {
            var symbol = null;

            var decl = null;
            var childDecls;
            var declSymbol = null;
            var declMembers;
            var pathDeclKind;
            var valDecl = null;
            var kind;
            var instanceSymbol = null;
            var instanceType = null;
            var childSymbol = null;

            for (var i = declPath.length - 1; i >= 0; i--) {
                decl = declPath[i];
                pathDeclKind = decl.getKind();

                if (decl.getFlags() & 2097152 /* DeclaredInAWithBlock */) {
                    return this.semanticInfoChain.anyTypeSymbol;
                }

                if (pathDeclKind & (4 /* Container */ | 32 /* DynamicModule */)) {
                    childDecls = decl.searchChildDecls(symbolName, declSearchKind);

                    if (childDecls.length) {
                        return childDecls[0].getSymbol();
                    }

                    if (declSearchKind & TypeScript.PullElementKind.SomeValue) {
                        childDecls = decl.searchChildDecls(symbolName, declSearchKind);

                        if (childDecls.length) {
                            valDecl = childDecls[0];

                            if (valDecl) {
                                return valDecl.getSymbol();
                            }
                        }

                        instanceSymbol = (decl.getSymbol()).getInstanceSymbol();

                        if (instanceSymbol) {
                            instanceType = instanceSymbol.getType();

                            childSymbol = this.getMemberSymbol(symbolName, declSearchKind, instanceType);

                            if (childSymbol && (childSymbol.getKind() & declSearchKind)) {
                                return childSymbol;
                            }
                        }

                        childDecls = decl.searchChildDecls(symbolName, 256 /* TypeAlias */);

                        if (childDecls.length) {
                            var sym = childDecls[0].getSymbol();

                            if (sym.isAlias()) {
                                return sym;
                            }
                        }

                        valDecl = decl.getValueDecl();

                        if (valDecl) {
                            decl = valDecl;
                        }
                    }

                    declSymbol = decl.getSymbol().getType();

                    var childSymbol = this.getMemberSymbol(symbolName, declSearchKind, declSymbol);

                    if (childSymbol) {
                        return childSymbol;
                    }
                } else if ((declSearchKind & (TypeScript.PullElementKind.SomeType | TypeScript.PullElementKind.SomeContainer)) || !(pathDeclKind & 8 /* Class */)) {
                    var candidateSymbol = null;

                    if (pathDeclKind === 131072 /* FunctionExpression */ && symbolName === (decl).getFunctionExpressionName()) {
                        candidateSymbol = decl.getSymbol();
                    }

                    childDecls = decl.searchChildDecls(symbolName, declSearchKind);

                    if (childDecls.length) {
                        if (decl.getKind() & TypeScript.PullElementKind.SomeFunction) {
                            decl.ensureSymbolIsBound();
                        }
                        return childDecls[0].getSymbol();
                    }

                    if (candidateSymbol) {
                        return candidateSymbol;
                    }

                    if (declSearchKind & TypeScript.PullElementKind.SomeValue) {
                        childDecls = decl.searchChildDecls(symbolName, 256 /* TypeAlias */);

                        if (childDecls.length) {
                            var sym = childDecls[0].getSymbol();

                            if (sym.isAlias()) {
                                return sym;
                            }
                        }
                    }
                }
            }

            symbol = this.semanticInfoChain.findSymbol([symbolName], declSearchKind);

            return symbol;
        };

        PullTypeResolver.prototype.getVisibleDeclsFromDeclPath = function (declPath, declSearchKind) {
            var result = [];
            var decl = null;
            var childDecls;
            var pathDeclKind;
            var parameters;

            for (var i = declPath.length - 1; i >= 0; i--) {
                decl = declPath[i];
                pathDeclKind = decl.getKind();
                var declSymbol = decl.getSymbol();
                var declKind = decl.getKind();

                if (declKind !== 8 /* Class */ && declKind !== 16 /* Interface */) {
                    this.addFilteredDecls(decl.getChildDecls(), declSearchKind, result);
                }

                switch (declKind) {
                    case 4 /* Container */:
                    case 32 /* DynamicModule */:
                        if (declSymbol) {
                            var otherDecls = declSymbol.getDeclarations();
                            for (var j = 0, m = otherDecls.length; j < m; j++) {
                                var otherDecl = otherDecls[j];
                                if (otherDecl === decl) {
                                    continue;
                                }

                                var otherDeclChildren = otherDecl.getChildDecls();
                                for (var k = 0, s = otherDeclChildren.length; k < s; k++) {
                                    var otherDeclChild = otherDeclChildren[k];
                                    if ((otherDeclChild.getFlags() & 1 /* Exported */) && (otherDeclChild.getKind() & declSearchKind)) {
                                        result.push(otherDeclChild);
                                    }
                                }
                            }
                        }

                        break;

                    case 8 /* Class */:
                    case 16 /* Interface */:
                        if (declSymbol && declSymbol.isGeneric()) {
                            parameters = declSymbol.getTypeParameters();
                            for (var k = 0; k < parameters.length; k++) {
                                result.push(parameters[k].getDeclarations()[0]);
                            }
                        }

                        break;

                    case 131072 /* FunctionExpression */:
                        var functionExpressionName = (decl).getFunctionExpressionName();
                        if (declSymbol && functionExpressionName) {
                            result.push(declSymbol.getDeclarations()[0]);
                        }

                    case 16384 /* Function */:
                    case 32768 /* ConstructorMethod */:
                    case 65536 /* Method */:
                        if (declSymbol) {
                            var functionType = declSymbol.getType();
                            if (functionType.getHasGenericSignature()) {
                                var signatures = (pathDeclKind === 32768 /* ConstructorMethod */) ? functionType.getConstructSignatures() : functionType.getCallSignatures();
                                if (signatures && signatures.length) {
                                    for (var j = 0; j < signatures.length; j++) {
                                        var signature = signatures[j];
                                        if (signature.isGeneric()) {
                                            parameters = signature.getTypeParameters();
                                            for (var k = 0; k < parameters.length; k++) {
                                                result.push(parameters[k].getDeclarations()[0]);
                                            }
                                        }
                                    }
                                }
                            }
                        }

                        break;
                }
            }

            var units = this.semanticInfoChain.units;
            for (var i = 0, n = units.length; i < n; i++) {
                var unit = units[i];
                if (unit === this.currentUnit && declPath.length != 0) {
                    continue;
                }
                var topLevelDecls = unit.getTopLevelDecls();
                if (topLevelDecls.length) {
                    for (var j = 0, m = topLevelDecls.length; j < m; j++) {
                        var topLevelDecl = topLevelDecls[j];
                        if (topLevelDecl.getKind() === 1 /* Script */ || topLevelDecl.getKind() === 0 /* Global */) {
                            this.addFilteredDecls(topLevelDecl.getChildDecls(), declSearchKind, result);
                        }
                    }
                }
            }

            return result;
        };

        PullTypeResolver.prototype.addFilteredDecls = function (decls, declSearchKind, result) {
            if (decls.length) {
                for (var i = 0, n = decls.length; i < n; i++) {
                    var decl = decls[i];
                    if (decl.getKind() & declSearchKind) {
                        result.push(decl);
                    }
                }
            }
        };

        PullTypeResolver.prototype.getVisibleDecls = function (enclosingDecl, context) {
            var declPath = enclosingDecl !== null ? TypeScript.getPathToDecl(enclosingDecl) : [];

            if (enclosingDecl && !declPath.length) {
                declPath = [enclosingDecl];
            }

            var declSearchKind = TypeScript.PullElementKind.SomeType | TypeScript.PullElementKind.SomeContainer | TypeScript.PullElementKind.SomeValue;

            return this.getVisibleDeclsFromDeclPath(declPath, declSearchKind);
        };

        PullTypeResolver.prototype.getVisibleContextSymbols = function (enclosingDecl, context) {
            var contextualTypeSymbol = context.getContextualType();
            if (!contextualTypeSymbol || this.isAnyOrEquivalent(contextualTypeSymbol)) {
                return null;
            }

            var declSearchKind = TypeScript.PullElementKind.SomeType | TypeScript.PullElementKind.SomeContainer | TypeScript.PullElementKind.SomeValue;
            var members = contextualTypeSymbol.getAllMembers(declSearchKind, false);

            for (var i = 0; i < members.length; i++) {
                members[i].setUnresolved();
            }

            return members;
        };

        PullTypeResolver.prototype.getVisibleMembersFromExpression = function (expression, enclosingDecl, context) {
            var prevCanUseTypeSymbol = context.canUseTypeSymbol;
            context.canUseTypeSymbol = true;
            var lhs = this.resolveAST(expression, false, enclosingDecl, context).symbol;
            context.canUseTypeSymbol = prevCanUseTypeSymbol;
            var lhsType = lhs.getType();

            if (!lhsType) {
                return null;
            }

            if (this.isAnyOrEquivalent(lhsType)) {
                return null;
            }

            if (!lhsType.isResolved()) {
                this.resolveDeclaredSymbol(lhsType, enclosingDecl, context);
            }

            var includePrivate = false;
            var containerSymbol = lhsType;
            if (containerSymbol.getKind() === 33554432 /* ConstructorType */) {
                containerSymbol = containerSymbol.getConstructSignatures()[0].getReturnType();
            }

            if (containerSymbol && containerSymbol.isClass()) {
                var declPath = TypeScript.getPathToDecl(enclosingDecl);
                if (declPath && declPath.length) {
                    var declarations = containerSymbol.getDeclarations();
                    for (var i = 0, n = declarations.length; i < n; i++) {
                        var declaration = declarations[i];
                        if (declPath.indexOf(declaration) >= 0) {
                            includePrivate = true;
                            break;
                        }
                    }
                }
            }

            var declSearchKind = TypeScript.PullElementKind.SomeType | TypeScript.PullElementKind.SomeContainer | TypeScript.PullElementKind.SomeValue;

            var members = [];

            if (lhsType.isContainer()) {
                if ((lhsType).getExportAssignedContainerSymbol()) {
                    lhsType = (lhsType).getExportAssignedContainerSymbol();
                }
            }

            if (lhsType.isTypeParameter()) {
                var constraint = (lhsType).getConstraint();

                if (constraint) {
                    lhsType = constraint;
                    members = lhsType.getAllMembers(declSearchKind, false);
                }
            } else {
                if (lhs.getKind() == 67108864 /* EnumMember */) {
                    lhsType = this.semanticInfoChain.numberTypeSymbol;
                }

                if (lhsType === this.semanticInfoChain.numberTypeSymbol && this.cachedNumberInterfaceType()) {
                    lhsType = this.cachedNumberInterfaceType();
                } else if (lhsType === this.semanticInfoChain.stringTypeSymbol && this.cachedStringInterfaceType()) {
                    lhsType = this.cachedStringInterfaceType();
                } else if (lhsType === this.semanticInfoChain.booleanTypeSymbol && this.cachedBooleanInterfaceType()) {
                    lhsType = this.cachedBooleanInterfaceType();
                }

                if (!lhsType.isResolved()) {
                    var potentiallySpecializedType = this.resolveDeclaredSymbol(lhsType, enclosingDecl, context);

                    if (potentiallySpecializedType != lhsType) {
                        if (!lhs.isType()) {
                            context.setTypeInContext(lhs, potentiallySpecializedType);
                        }

                        lhsType = potentiallySpecializedType;
                    }
                }

                members = lhsType.getAllMembers(declSearchKind, includePrivate);

                if (lhsType.isContainer()) {
                    var associatedInstance = (lhsType).getInstanceSymbol();
                    if (associatedInstance) {
                        var instanceType = associatedInstance.getType();
                        if (!instanceType.isResolved()) {
                            this.resolveDeclaredSymbol(instanceType, enclosingDecl, context);
                        }
                        var instanceMembers = instanceType.getAllMembers(declSearchKind, includePrivate);
                        members = members.concat(instanceMembers);
                    }
                } else if (lhsType.isConstructor()) {
                    var prototypeStr = "prototype";
                    var prototypeSymbol = new TypeScript.PullSymbol(prototypeStr, 4096 /* Property */);
                    var parentDecl = lhsType.getDeclarations()[0];
                    var prototypeDecl = new TypeScript.PullDecl(prototypeStr, prototypeStr, parentDecl.getKind(), parentDecl.getFlags(), parentDecl.getSpan(), parentDecl.getScriptName());
                    this.currentUnit.addSynthesizedDecl(prototypeDecl);
                    prototypeDecl.setParentDecl(parentDecl);
                    prototypeSymbol.addDeclaration(prototypeDecl);

                    members.push(prototypeSymbol);
                } else {
                    var associatedContainerSymbol = lhsType.getAssociatedContainerType();
                    if (associatedContainerSymbol) {
                        var containerType = associatedContainerSymbol.getType();
                        if (!containerType.isResolved()) {
                            this.resolveDeclaredSymbol(containerType, enclosingDecl, context);
                        }
                        var containerMembers = containerType.getAllMembers(declSearchKind, includePrivate);
                        members = members.concat(containerMembers);
                    }
                }
            }

            if (lhsType.getCallSignatures().length && this.cachedFunctionInterfaceType()) {
                members = members.concat(this.cachedFunctionInterfaceType().getAllMembers(declSearchKind, false));
            }

            for (var i = 0; i < members.length; i++) {
                if (!members[i].isResolved()) {
                    this.resolveDeclaredSymbol(members[i], enclosingDecl, context);
                }
                members[i].setUnresolved();
            }

            return members;
        };

        PullTypeResolver.prototype.isAnyOrEquivalent = function (type) {
            return (type === this.semanticInfoChain.anyTypeSymbol) || type.isError();
        };

        PullTypeResolver.prototype.isNumberOrEquivalent = function (type) {
            return (type === this.semanticInfoChain.numberTypeSymbol) || (this.cachedNumberInterfaceType() && type === this.cachedNumberInterfaceType());
        };

        PullTypeResolver.prototype.isTypeArgumentOrWrapper = function (type) {
            if (!type) {
                return false;
            }

            if (!type.isGeneric()) {
                return false;
            }

            if (type.isTypeParameter()) {
                return true;
            }

            if (type.isArray()) {
                return this.isTypeArgumentOrWrapper((type).getElementType());
            }

            var typeArguments = type.getTypeArguments();

            if (typeArguments) {
                for (var i = 0; i < typeArguments.length; i++) {
                    if (this.isTypeArgumentOrWrapper(typeArguments[i])) {
                        return true;
                    }
                }
            } else {
                return true;
            }

            return false;
        };

        PullTypeResolver.prototype.isArrayOrEquivalent = function (type) {
            return (type.isArray() && (type).getElementType()) || type == this.cachedArrayInterfaceType();
        };

        PullTypeResolver.prototype.findTypeSymbolForDynamicModule = function (idText, currentFileName, search) {
            var originalIdText = idText;
            var symbol = search(idText);

            if (symbol === null) {
                if (!symbol) {
                    idText = TypeScript.swapQuotes(originalIdText);
                    symbol = search(idText);
                }

                if (!symbol) {
                    idText = TypeScript.stripQuotes(originalIdText) + ".ts";
                    symbol = search(idText);
                }

                if (!symbol) {
                    idText = TypeScript.stripQuotes(originalIdText) + ".d.ts";
                    symbol = search(idText);
                }

                if (!symbol && !TypeScript.isRelative(originalIdText)) {
                    idText = originalIdText;

                    var strippedIdText = TypeScript.stripQuotes(idText);

                    var path = TypeScript.getRootFilePath(TypeScript.switchToForwardSlashes(currentFileName));

                    while (symbol === null && path != "") {
                        idText = TypeScript.normalizePath(path + strippedIdText + ".ts");
                        symbol = search(idText);

                        if (symbol === null) {
                            idText = TypeScript.changePathToDTS(idText);
                            symbol = search(idText);
                        }

                        if (symbol === null) {
                            if (path === '/') {
                                path = '';
                            } else {
                                path = TypeScript.normalizePath(path + "..");
                                path = path && path != '/' ? path + '/' : path;
                            }
                        }
                    }
                }
            }

            return symbol;
        };

        PullTypeResolver.prototype.resolveDeclaredSymbol = function (symbol, enclosingDecl, context) {
            var savedResolvingTypeReference = context.resolvingTypeReference;
            context.resolvingTypeReference = false;

            var result = this.resolveDeclaredSymbolWorker(symbol, enclosingDecl, context);
            context.resolvingTypeReference = savedResolvingTypeReference;

            return result;
        };

        PullTypeResolver.prototype.resolveDeclaredSymbolWorker = function (symbol, enclosingDecl, context) {
            if (!symbol || symbol.isResolved()) {
                return symbol;
            }

            if (symbol.isResolving()) {
                if (!symbol.currentlyBeingSpecialized()) {
                    if (!symbol.isType()) {
                        symbol.setType(this.semanticInfoChain.anyTypeSymbol);
                    }

                    return symbol;
                }
            }

            var thisUnit = this.unitPath;

            var decls = symbol.getDeclarations();

            var ast = null;

            for (var i = 0; i < decls.length; i++) {
                var decl = decls[i];

                ast = this.semanticInfoChain.getASTForDecl(decl);

                if (!ast || ast.nodeType === 80 /* Member */) {
                    this.setUnitPath(thisUnit);
                    return symbol;
                }

                this.setUnitPath(decl.getScriptName());
                this.resolveAST(ast, false, enclosingDecl, context);
            }

            var typeArgs = symbol.isType() ? (symbol).getTypeArguments() : null;

            if (typeArgs && typeArgs.length) {
                var typeParameters = (symbol).getTypeParameters();
                var typeCache = {};

                for (var i = 0; i < typeParameters.length; i++) {
                    typeCache[typeParameters[i].getSymbolID().toString()] = typeArgs[i];
                }

                context.pushTypeSpecializationCache(typeCache);
                var rootType = TypeScript.getRootType(symbol.getType());

                var specializedSymbol = TypeScript.specializeType(rootType, typeArgs, this, enclosingDecl, context, ast);

                context.popTypeSpecializationCache();

                symbol = specializedSymbol;
            }

            this.setUnitPath(thisUnit);

            return symbol;
        };

        PullTypeResolver.prototype.resolveModuleDeclaration = function (ast, context) {
            var containerDecl = this.getDeclForAST(ast);
            var containerSymbol = containerDecl.getSymbol();

            if (containerSymbol.isResolved()) {
                return containerSymbol;
            }

            containerSymbol.setResolved();

            var containerDecls = containerSymbol.getDeclarations();

            for (var i = 0; i < containerDecls.length; i++) {
                var childDecls = containerDecls[i].getChildDecls();

                for (var j = 0; j < childDecls.length; j++) {
                    childDecls[j].ensureSymbolIsBound();
                }
            }

            if (containerDecl.getKind() != 64 /* Enum */) {
                var instanceSymbol = containerSymbol.getInstanceSymbol();

                if (instanceSymbol) {
                    this.resolveDeclaredSymbol(instanceSymbol, containerDecl.getParentDecl(), context);
                }

                var members = ast.members.members;

                for (var i = 0; i < members.length; i++) {
                    if (members[i].nodeType == 87 /* ExportAssignment */) {
                        this.resolveExportAssignmentStatement(members[i], containerDecl, context);
                        break;
                    }
                }
            }

            return containerSymbol;
        };

        PullTypeResolver.prototype.isTypeRefWithoutTypeArgs = function (typeRef) {
            if (typeRef.nodeType != 11 /* TypeRef */) {
                return false;
            }

            if (typeRef.term.nodeType == 20 /* Name */) {
                return true;
            } else if (typeRef.term.nodeType == 32 /* MemberAccessExpression */) {
                var binex = typeRef.term;

                if (binex.operand2.nodeType == 20 /* Name */) {
                    return true;
                }
            }

            return false;
        };

        PullTypeResolver.prototype.resolveReferenceTypeDeclaration = function (typeDeclAST, context) {
            var typeDecl = this.getDeclForAST(typeDeclAST);
            var enclosingDecl = this.getEnclosingDecl(typeDecl);
            var typeDeclSymbol = typeDecl.getSymbol();
            var typeDeclIsClass = typeDeclAST.nodeType === 13 /* ClassDeclaration */;
            var hasVisited = this.getSymbolAndDiagnosticsForAST(typeDeclAST) != null;
            var extendedTypes = [];
            var implementedTypes = [];

            if ((typeDeclSymbol.isResolved() && hasVisited) || (typeDeclSymbol.isResolving() && !context.isInBaseTypeResolution())) {
                return typeDeclSymbol;
            }

            var wasResolving = typeDeclSymbol.isResolving();
            typeDeclSymbol.startResolving();

            if (!typeDeclSymbol.isResolved()) {
                var typeDeclTypeParameters = typeDeclSymbol.getTypeParameters();
                for (var i = 0; i < typeDeclTypeParameters.length; i++) {
                    this.resolveDeclaredSymbol(typeDeclTypeParameters[i], typeDecl, context);
                }
            }

            var typeRefDecls = typeDeclSymbol.getDeclarations();

            for (var i = 0; i < typeRefDecls.length; i++) {
                var childDecls = typeRefDecls[i].getChildDecls();

                for (var j = 0; j < childDecls.length; j++) {
                    childDecls[j].ensureSymbolIsBound();
                }
            }

            var wasInBaseTypeResolution = context.startBaseTypeResolution();

            if (!typeDeclIsClass && !hasVisited) {
                typeDeclSymbol.resetKnownBaseTypeCount();
            }

            if (typeDeclAST.extendsList) {
                var savedIsResolvingClassExtendedType = context.isResolvingClassExtendedType;
                if (typeDeclIsClass) {
                    context.isResolvingClassExtendedType = true;
                }

                for (var i = typeDeclSymbol.getKnownBaseTypeCount(); i < typeDeclAST.extendsList.members.length; i = typeDeclSymbol.getKnownBaseTypeCount()) {
                    typeDeclSymbol.incrementKnownBaseCount();
                    var parentType = this.resolveTypeReference(new TypeScript.TypeReference(typeDeclAST.extendsList.members[i], 0), typeDecl, context).symbol;

                    if (typeDeclSymbol.isValidBaseKind(parentType, true)) {
                        var resolvedParentType = parentType;
                        extendedTypes[extendedTypes.length] = parentType;
                        if (parentType.isGeneric() && parentType.isResolved() && !parentType.getIsSpecialized()) {
                            parentType = this.specializeTypeToAny(parentType, enclosingDecl, context);
                            typeDecl.addDiagnostic(new TypeScript.Diagnostic(typeDecl.getScriptName(), typeDeclAST.minChar, typeDeclAST.getLength(), 239 /* Generic_type_references_must_include_all_type_arguments */));
                        }
                        if (!typeDeclSymbol.hasBase(parentType)) {
                            this.setSymbolAndDiagnosticsForAST(typeDeclAST.extendsList.members[i], SymbolAndDiagnostics.fromSymbol(resolvedParentType), context);
                            typeDeclSymbol.addExtendedType(parentType);

                            var specializations = typeDeclSymbol.getKnownSpecializations();

                            for (var j = 0; j < specializations.length; j++) {
                                specializations[j].addExtendedType(parentType);
                            }
                        }
                    }
                }

                context.isResolvingClassExtendedType = savedIsResolvingClassExtendedType;
            }

            if (!typeDeclSymbol.isResolved() && !wasResolving) {
                var baseTypeSymbols = typeDeclSymbol.getExtendedTypes();
                for (var i = 0; i < baseTypeSymbols.length; i++) {
                    var baseType = baseTypeSymbols[i];

                    for (var j = 0; j < extendedTypes.length; j++) {
                        if (baseType == extendedTypes[j]) {
                            break;
                        }
                    }

                    if (j == extendedTypes.length) {
                        typeDeclSymbol.removeExtendedType(baseType);
                    }
                }
            }

            if (typeDeclAST.implementsList && typeDeclIsClass) {
                var extendsCount = typeDeclAST.extendsList ? typeDeclAST.extendsList.members.length : 0;
                for (var i = typeDeclSymbol.getKnownBaseTypeCount(); ((i - extendsCount) >= 0) && ((i - extendsCount) < typeDeclAST.implementsList.members.length); i = typeDeclSymbol.getKnownBaseTypeCount()) {
                    typeDeclSymbol.incrementKnownBaseCount();
                    var implementedType = this.resolveTypeReference(new TypeScript.TypeReference(typeDeclAST.implementsList.members[i - extendsCount], 0), typeDecl, context).symbol;

                    if (typeDeclSymbol.isValidBaseKind(implementedType, false)) {
                        var resolvedImplementedType = implementedType;
                        implementedTypes[implementedTypes.length] = implementedType;
                        if (implementedType.isGeneric() && implementedType.isResolved() && !implementedType.getIsSpecialized()) {
                            implementedType = this.specializeTypeToAny(implementedType, enclosingDecl, context);
                            typeDecl.addDiagnostic(new TypeScript.Diagnostic(typeDecl.getScriptName(), typeDeclAST.minChar, typeDeclAST.getLength(), 239 /* Generic_type_references_must_include_all_type_arguments */));
                            this.setSymbolAndDiagnosticsForAST(typeDeclAST.implementsList.members[i - extendsCount], SymbolAndDiagnostics.fromSymbol(implementedType), context);
                            typeDeclSymbol.addImplementedType(implementedType);
                        } else if (!typeDeclSymbol.hasBase(implementedType)) {
                            this.setSymbolAndDiagnosticsForAST(typeDeclAST.implementsList.members[i - extendsCount], SymbolAndDiagnostics.fromSymbol(resolvedImplementedType), context);
                            typeDeclSymbol.addImplementedType(implementedType);
                        }
                    }
                }
            }

            if (!typeDeclSymbol.isResolved() && !wasResolving) {
                var baseTypeSymbols = typeDeclSymbol.getImplementedTypes();
                for (var i = 0; i < baseTypeSymbols.length; i++) {
                    var baseType = baseTypeSymbols[i];

                    for (var j = 0; j < implementedTypes.length; j++) {
                        if (baseType == implementedTypes[j]) {
                            break;
                        }
                    }

                    if (j == implementedTypes.length) {
                        typeDeclSymbol.removeImplementedType(baseType);
                    }
                }
            }

            context.doneBaseTypeResolution(wasInBaseTypeResolution);
            if (wasInBaseTypeResolution && (typeDeclAST.implementsList || typeDeclAST.extendsList)) {
                return typeDeclSymbol;
            }

            if (!typeDeclSymbol.isResolved()) {
                var typeDeclMembers = typeDeclSymbol.getMembers();
                for (var i = 0; i < typeDeclMembers.length; i++) {
                    this.resolveDeclaredSymbol(typeDeclMembers[i], typeDecl, context);
                }

                if (!typeDeclIsClass) {
                    var callSignatures = typeDeclSymbol.getCallSignatures();
                    for (var i = 0; i < callSignatures.length; i++) {
                        this.resolveDeclaredSymbol(callSignatures[i], typeDecl, context);
                    }

                    var constructSignatures = typeDeclSymbol.getConstructSignatures();
                    for (var i = 0; i < constructSignatures.length; i++) {
                        this.resolveDeclaredSymbol(constructSignatures[i], typeDecl, context);
                    }

                    var indexSignatures = typeDeclSymbol.getIndexSignatures();
                    for (var i = 0; i < indexSignatures.length; i++) {
                        this.resolveDeclaredSymbol(indexSignatures[i], typeDecl, context);
                    }
                }
            }

            this.setSymbolAndDiagnosticsForAST(typeDeclAST.name, SymbolAndDiagnostics.fromSymbol(typeDeclSymbol), context);
            this.setSymbolAndDiagnosticsForAST(typeDeclAST, SymbolAndDiagnostics.fromSymbol(typeDeclSymbol), context);

            typeDeclSymbol.setResolved();

            return typeDeclSymbol;
        };

        PullTypeResolver.prototype.resolveClassDeclaration = function (classDeclAST, context) {
            var classDecl = this.getDeclForAST(classDeclAST);
            var classDeclSymbol = classDecl.getSymbol();
            if (classDeclSymbol.isResolved()) {
                return classDeclSymbol;
            }

            this.resolveReferenceTypeDeclaration(classDeclAST, context);

            var constructorMethod = classDeclSymbol.getConstructorMethod();
            var extendedTypes = classDeclSymbol.getExtendedTypes();
            var parentType = extendedTypes.length ? extendedTypes[0] : null;

            if (constructorMethod) {
                var constructorTypeSymbol = constructorMethod.getType();

                var constructSignatures = constructorTypeSymbol.getConstructSignatures();

                if (!constructSignatures.length) {
                    var constructorSignature;

                    if (parentType) {
                        var parentClass = parentType;
                        var parentConstructor = parentClass.getConstructorMethod();
                        var parentConstructorType = parentConstructor.getType();
                        var parentConstructSignatures = parentConstructorType.getConstructSignatures();

                        var parentConstructSignature;
                        var parentParameters;
                        for (var i = 0; i < parentConstructSignatures.length; i++) {
                            parentConstructSignature = parentConstructSignatures[i];
                            parentParameters = parentConstructSignature.getParameters();

                            constructorSignature = parentConstructSignature.isDefinition() ? new TypeScript.PullDefinitionSignatureSymbol(2097152 /* ConstructSignature */) : new TypeScript.PullSignatureSymbol(2097152 /* ConstructSignature */);
                            constructorSignature.setReturnType(classDeclSymbol);

                            for (var j = 0; j < parentParameters.length; j++) {
                                constructorSignature.addParameter(parentParameters[j], parentParameters[j].getIsOptional());
                            }

                            var typeParameters = constructorTypeSymbol.getTypeParameters();

                            for (var j = 0; j < typeParameters.length; j++) {
                                constructorSignature.addTypeParameter(typeParameters[j]);
                            }

                            constructorTypeSymbol.addConstructSignature(constructorSignature);
                            constructorSignature.addDeclaration(classDecl);
                        }
                    } else {
                        constructorSignature = new TypeScript.PullSignatureSymbol(2097152 /* ConstructSignature */);
                        constructorSignature.setReturnType(classDeclSymbol);
                        constructorTypeSymbol.addConstructSignature(constructorSignature);
                        constructorSignature.addDeclaration(classDecl);

                        var typeParameters = constructorTypeSymbol.getTypeParameters();

                        for (var i = 0; i < typeParameters.length; i++) {
                            constructorSignature.addTypeParameter(typeParameters[i]);
                        }
                    }
                }

                if (!classDeclSymbol.isResolved()) {
                    return classDeclSymbol;
                }

                var constructorMembers = constructorTypeSymbol.getMembers();

                this.resolveDeclaredSymbol(constructorMethod, classDecl, context);

                for (var i = 0; i < constructorMembers.length; i++) {
                    this.resolveDeclaredSymbol(constructorMembers[i], classDecl, context);
                }

                if (parentType) {
                    var parentConstructorSymbol = (parentType).getConstructorMethod();
                    var parentConstructorTypeSymbol = parentConstructorSymbol.getType();

                    if (!constructorTypeSymbol.hasBase(parentConstructorTypeSymbol)) {
                        constructorTypeSymbol.addExtendedType(parentConstructorTypeSymbol);
                    }
                }
            }

            return classDeclSymbol;
        };

        PullTypeResolver.prototype.resolveInterfaceDeclaration = function (interfaceDeclAST, context) {
            var interfaceDecl = this.getDeclForAST(interfaceDeclAST);
            var interfaceDeclSymbol = interfaceDecl.getSymbol();

            this.resolveReferenceTypeDeclaration(interfaceDeclAST, context);
            return interfaceDeclSymbol;
        };

        PullTypeResolver.prototype.resolveImportDeclaration = function (importStatementAST, context) {
            var _this = this;
            var importDecl = this.getDeclForAST(importStatementAST);
            var enclosingDecl = this.getEnclosingDecl(importDecl);
            var importDeclSymbol = importDecl.getSymbol();

            var aliasName = importStatementAST.id.text;
            var aliasedType = null;

            if (importDeclSymbol.isResolved()) {
                return importDeclSymbol;
            }

            importDeclSymbol.startResolving();

            if (importStatementAST.alias.nodeType === 11 /* TypeRef */) {
                aliasedType = this.resolveTypeReference(importStatementAST.alias, enclosingDecl, context).symbol;
            } else if (importStatementAST.alias.nodeType === 20 /* Name */) {
                var text = (importStatementAST.alias).actualText;

                if (!TypeScript.isQuoted(text)) {
                    aliasedType = this.resolveTypeReference(new TypeScript.TypeReference(importStatementAST.alias, 0), enclosingDecl, context).symbol;
                } else {
                    var modPath = (importStatementAST.alias).actualText;
                    var declPath = TypeScript.getPathToDecl(enclosingDecl);

                    importStatementAST.isDynamicImport = true;

                    aliasedType = this.findTypeSymbolForDynamicModule(modPath, importDecl.getScriptName(), function (s) {
                        return _this.getSymbolFromDeclPath(s, declPath, TypeScript.PullElementKind.SomeContainer);
                    });

                    if (!aliasedType) {
                        importDecl.addDiagnostic(new TypeScript.SemanticDiagnostic(this.currentUnit.getPath(), importStatementAST.minChar, importStatementAST.getLength(), 140 /* Unable_to_resolve_external_module__0_ */, [text]));
                        aliasedType = this.semanticInfoChain.anyTypeSymbol;
                    }
                }
            }

            if (aliasedType) {
                if (!aliasedType.isContainer()) {
                    importDecl.addDiagnostic(new TypeScript.Diagnostic(this.currentUnit.getPath(), importStatementAST.minChar, importStatementAST.getLength(), 141 /* Module_cannot_be_aliased_to_a_non_module_type */));
                    aliasedType = this.semanticInfoChain.anyTypeSymbol;
                } else if ((aliasedType).getExportAssignedValueSymbol()) {
                    importDeclSymbol.setIsUsedAsValue();
                }

                importDeclSymbol.setAliasedType(aliasedType);
                importDeclSymbol.setResolved();

                this.semanticInfoChain.setSymbolAndDiagnosticsForAST(importStatementAST.alias, SymbolAndDiagnostics.fromSymbol(aliasedType), this.unitPath);
            }

            return importDeclSymbol;
        };

        PullTypeResolver.prototype.resolveExportAssignmentStatement = function (exportAssignmentAST, enclosingDecl, context) {
            var id = exportAssignmentAST.id.text;
            var valueSymbol = null;
            var typeSymbol = null;
            var containerSymbol = null;

            var parentSymbol = enclosingDecl.getSymbol();

            if (!parentSymbol.isType() && (parentSymbol).isContainer()) {
                enclosingDecl.addDiagnostic(new TypeScript.Diagnostic(enclosingDecl.getScriptName(), exportAssignmentAST.minChar, exportAssignmentAST.getLength(), 230 /* Export_assignments_may_only_be_used_in_External_modules */));
                return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.anyTypeSymbol);
            }

            var declPath = enclosingDecl !== null ? [enclosingDecl] : [];

            containerSymbol = this.getSymbolFromDeclPath(id, declPath, TypeScript.PullElementKind.SomeContainer);

            var acceptableAlias = true;

            if (containerSymbol) {
                acceptableAlias = (containerSymbol.getKind() & TypeScript.PullElementKind.AcceptableAlias) != 0;
            }

            if (!acceptableAlias && containerSymbol && containerSymbol.getKind() == 256 /* TypeAlias */) {
                if (!containerSymbol.isResolved()) {
                    this.resolveDeclaredSymbol(containerSymbol, enclosingDecl, context);
                }
                var aliasedType = (containerSymbol).getType();

                if (aliasedType.getKind() != 32 /* DynamicModule */) {
                    acceptableAlias = true;
                } else {
                    var aliasedAssignedValue = (containerSymbol).getExportAssignedValueSymbol();
                    var aliasedAssignedType = (containerSymbol).getExportAssignedTypeSymbol();
                    var aliasedAssignedContainer = (containerSymbol).getExportAssignedContainerSymbol();

                    if (aliasedAssignedValue || aliasedAssignedType || aliasedAssignedContainer) {
                        if (aliasedAssignedValue) {
                            valueSymbol = aliasedAssignedValue;
                        }
                        if (aliasedAssignedType) {
                            typeSymbol = aliasedAssignedType;
                        }
                        if (aliasedAssignedContainer) {
                            containerSymbol = aliasedAssignedContainer;
                        }
                        acceptableAlias = true;
                    }
                }
            }

            if (!acceptableAlias) {
                enclosingDecl.addDiagnostic(new TypeScript.Diagnostic(enclosingDecl.getScriptName(), exportAssignmentAST.minChar, exportAssignmentAST.getLength(), 231 /* Export_assignments_may_only_be_made_with_acceptable_kinds */));
                return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.voidTypeSymbol);
            }

            if (!valueSymbol) {
                valueSymbol = this.getSymbolFromDeclPath(id, declPath, TypeScript.PullElementKind.SomeValue);
            }
            if (!typeSymbol) {
                typeSymbol = this.getSymbolFromDeclPath(id, declPath, TypeScript.PullElementKind.SomeType);
            }

            if (!valueSymbol && !typeSymbol && !containerSymbol) {
                return SymbolAndDiagnostics.create(this.semanticInfoChain.voidTypeSymbol, [context.postError(enclosingDecl.getScriptName(), exportAssignmentAST.minChar, exportAssignmentAST.getLength(), 164 /* Could_not_find_symbol__0_ */, [id])]);
            }

            if (valueSymbol) {
                if (!valueSymbol.isResolved()) {
                    this.resolveDeclaredSymbol(valueSymbol, enclosingDecl, context);
                }
                (parentSymbol).setExportAssignedValueSymbol(valueSymbol);
            }
            if (typeSymbol) {
                if (!typeSymbol.isResolved()) {
                    this.resolveDeclaredSymbol(typeSymbol, enclosingDecl, context);
                }

                (parentSymbol).setExportAssignedTypeSymbol(typeSymbol);
            }
            if (containerSymbol) {
                if (!containerSymbol.isResolved()) {
                    this.resolveDeclaredSymbol(containerSymbol, enclosingDecl, context);
                }

                (parentSymbol).setExportAssignedContainerSymbol(containerSymbol);
            }

            return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.voidTypeSymbol);
        };

        PullTypeResolver.prototype.resolveFunctionTypeSignature = function (funcDeclAST, enclosingDecl, context) {
            var funcDeclSymbol = null;

            var functionDecl = this.getDeclForAST(funcDeclAST);

            if (!functionDecl || !functionDecl.hasSymbol()) {
                var semanticInfo = this.semanticInfoChain.getUnit(this.unitPath);
                var declCollectionContext = new TypeScript.DeclCollectionContext(semanticInfo);

                declCollectionContext.scriptName = this.unitPath;

                if (enclosingDecl) {
                    declCollectionContext.pushParent(enclosingDecl);
                }

                TypeScript.getAstWalkerFactory().walk(funcDeclAST, TypeScript.preCollectDecls, TypeScript.postCollectDecls, null, declCollectionContext);

                functionDecl = this.getDeclForAST(funcDeclAST);
                this.currentUnit.addSynthesizedDecl(functionDecl);

                var binder = new TypeScript.PullSymbolBinder(this.semanticInfoChain);
                binder.setUnit(this.unitPath);
                if (functionDecl.getKind() === 33554432 /* ConstructorType */) {
                    binder.bindConstructorTypeDeclarationToPullSymbol(functionDecl);
                } else {
                    binder.bindFunctionTypeDeclarationToPullSymbol(functionDecl);
                }
            }

            funcDeclSymbol = functionDecl.getSymbol();

            var signature = funcDeclSymbol.getKind() === 33554432 /* ConstructorType */ ? funcDeclSymbol.getConstructSignatures()[0] : funcDeclSymbol.getCallSignatures()[0];

            if (funcDeclAST.returnTypeAnnotation) {
                var returnTypeSymbol = this.resolveTypeReference(funcDeclAST.returnTypeAnnotation, enclosingDecl, context).symbol;

                signature.setReturnType(returnTypeSymbol);

                if (this.isTypeArgumentOrWrapper(returnTypeSymbol)) {
                    signature.setHasGenericParameter();

                    if (funcDeclSymbol) {
                        funcDeclSymbol.getType().setHasGenericSignature();
                    }
                }
            } else {
                signature.setReturnType(this.semanticInfoChain.anyTypeSymbol);
            }

            if (funcDeclAST.arguments) {
                for (var i = 0; i < funcDeclAST.arguments.members.length; i++) {
                    this.resolveFunctionTypeSignatureParameter(funcDeclAST.arguments.members[i], signature, enclosingDecl, context);
                }
            }

            if (funcDeclSymbol && signature.hasGenericParameter()) {
                funcDeclSymbol.getType().setHasGenericSignature();
            }

            if (signature.hasGenericParameter()) {
                if (funcDeclSymbol) {
                    funcDeclSymbol.getType().setHasGenericSignature();
                }
            }

            funcDeclSymbol.setResolved();

            return funcDeclSymbol;
        };

        PullTypeResolver.prototype.resolveFunctionTypeSignatureParameter = function (argDeclAST, signature, enclosingDecl, context) {
            var paramDecl = this.getDeclForAST(argDeclAST);
            var paramSymbol = paramDecl.getSymbol();

            if (argDeclAST.typeExpr) {
                var typeRef = this.resolveTypeReference(argDeclAST.typeExpr, enclosingDecl, context).symbol;

                if (paramSymbol.getIsVarArg() && !(typeRef.isArray() || typeRef == this.cachedArrayInterfaceType())) {
                    var diagnostic = context.postError(this.unitPath, argDeclAST.minChar, argDeclAST.getLength(), 228 /* Rest_parameters_must_be_array_types */, null, enclosingDecl);
                    typeRef = this.getNewErrorTypeSymbol(diagnostic);
                }

                context.setTypeInContext(paramSymbol, typeRef);

                if (this.isTypeArgumentOrWrapper(typeRef)) {
                    signature.setHasGenericParameter();
                }
            } else {
                if (paramSymbol.getIsVarArg() && paramSymbol.getType()) {
                    if (this.cachedArrayInterfaceType()) {
                        context.setTypeInContext(paramSymbol, TypeScript.specializeToArrayType(this.cachedArrayInterfaceType(), paramSymbol.getType(), this, context));
                    } else {
                        context.setTypeInContext(paramSymbol, paramSymbol.getType());
                    }
                } else {
                    context.setTypeInContext(paramSymbol, this.semanticInfoChain.anyTypeSymbol);
                }
            }

            paramSymbol.setResolved();
        };

        PullTypeResolver.prototype.resolveFunctionExpressionParameter = function (argDeclAST, contextParam, enclosingDecl, context) {
            var paramDecl = this.getDeclForAST(argDeclAST);
            var paramSymbol = paramDecl.getSymbol();

            if (argDeclAST.typeExpr) {
                var typeRef = this.resolveTypeReference(argDeclAST.typeExpr, enclosingDecl, context).symbol;

                if (paramSymbol.getIsVarArg() && !(typeRef.isArray() || typeRef == this.cachedArrayInterfaceType())) {
                    var diagnostic = context.postError(this.unitPath, argDeclAST.minChar, argDeclAST.getLength(), 228 /* Rest_parameters_must_be_array_types */, null, enclosingDecl);
                    typeRef = this.getNewErrorTypeSymbol(diagnostic);
                }

                context.setTypeInContext(paramSymbol, typeRef);
            } else {
                if (paramSymbol.getIsVarArg() && paramSymbol.getType()) {
                    if (this.cachedArrayInterfaceType()) {
                        context.setTypeInContext(paramSymbol, TypeScript.specializeToArrayType(this.cachedArrayInterfaceType(), paramSymbol.getType(), this, context));
                    } else {
                        context.setTypeInContext(paramSymbol, paramSymbol.getType());
                    }
                } else if (contextParam) {
                    context.setTypeInContext(paramSymbol, contextParam.getType());
                } else {
                    context.setTypeInContext(paramSymbol, this.semanticInfoChain.anyTypeSymbol);
                }
            }

            paramSymbol.setResolved();
        };

        PullTypeResolver.prototype.resolveInterfaceTypeReference = function (interfaceDeclAST, enclosingDecl, context) {
            var interfaceSymbol = null;

            var interfaceDecl = this.getDeclForAST(interfaceDeclAST);

            if (!interfaceDecl) {
                var semanticInfo = this.semanticInfoChain.getUnit(this.unitPath);
                var declCollectionContext = new TypeScript.DeclCollectionContext(semanticInfo);

                declCollectionContext.scriptName = this.unitPath;

                if (enclosingDecl) {
                    declCollectionContext.pushParent(enclosingDecl);
                }

                TypeScript.getAstWalkerFactory().walk(interfaceDeclAST, TypeScript.preCollectDecls, TypeScript.postCollectDecls, null, declCollectionContext);

                var interfaceDecl = this.getDeclForAST(interfaceDeclAST);
                this.currentUnit.addSynthesizedDecl(interfaceDecl);

                var binder = new TypeScript.PullSymbolBinder(this.semanticInfoChain);

                binder.setUnit(this.unitPath);
                binder.bindObjectTypeDeclarationToPullSymbol(interfaceDecl);
            }

            interfaceSymbol = interfaceDecl.getSymbol();

            if (interfaceDeclAST.members) {
                var memberDecl = null;
                var memberSymbol = null;
                var memberType = null;
                var typeMembers = interfaceDeclAST.members;

                for (var i = 0; i < typeMembers.members.length; i++) {
                    memberDecl = this.getDeclForAST(typeMembers.members[i]);
                    memberSymbol = (memberDecl.getKind() & TypeScript.PullElementKind.SomeSignature) ? memberDecl.getSignatureSymbol() : memberDecl.getSymbol();

                    this.resolveDeclaredSymbol(memberSymbol, enclosingDecl, context);

                    memberType = memberSymbol.getType();

                    if ((memberType && memberType.isGeneric()) || (memberSymbol.isSignature() && (memberSymbol).isGeneric())) {
                        interfaceSymbol.setHasGenericMember();
                    }
                }
            }

            interfaceSymbol.setResolved();

            return interfaceSymbol;
        };

        PullTypeResolver.prototype.resolveTypeReference = function (typeRef, enclosingDecl, context) {
            if (typeRef === null) {
                return null;
            }

            var symbolAndDiagnostics = this.getSymbolAndDiagnosticsForAST(typeRef);
            if (!symbolAndDiagnostics) {
                symbolAndDiagnostics = this.computeTypeReferenceSymbol(typeRef, enclosingDecl, context);

                if (!symbolAndDiagnostics.symbol.isGeneric()) {
                    this.setSymbolAndDiagnosticsForAST(typeRef, symbolAndDiagnostics, context);
                }
            }

            return symbolAndDiagnostics;
        };

        PullTypeResolver.prototype.computeTypeReferenceSymbol = function (typeRef, enclosingDecl, context) {
            var typeDeclSymbol = null;
            var diagnostic = null;
            var symbolAndDiagnostic = null;

            if (typeRef.term.nodeType === 20 /* Name */) {
                var prevResolvingTypeReference = context.resolvingTypeReference;
                context.resolvingTypeReference = true;
                symbolAndDiagnostic = this.resolveTypeNameExpression(typeRef.term, enclosingDecl, context);
                typeDeclSymbol = symbolAndDiagnostic.symbol;

                context.resolvingTypeReference = prevResolvingTypeReference;
            } else if (typeRef.term.nodeType === 12 /* FunctionDeclaration */) {
                typeDeclSymbol = this.resolveFunctionTypeSignature(typeRef.term, enclosingDecl, context);
            } else if (typeRef.term.nodeType === 14 /* InterfaceDeclaration */) {
                typeDeclSymbol = this.resolveInterfaceTypeReference(typeRef.term, enclosingDecl, context);
            } else if (typeRef.term.nodeType === 10 /* GenericType */) {
                symbolAndDiagnostic = this.resolveGenericTypeReference(typeRef.term, enclosingDecl, context);
                typeDeclSymbol = symbolAndDiagnostic.symbol;
            } else if (typeRef.term.nodeType === 32 /* MemberAccessExpression */) {
                var dottedName = typeRef.term;

                prevResolvingTypeReference = context.resolvingTypeReference;
                symbolAndDiagnostic = this.resolveDottedTypeNameExpression(dottedName, enclosingDecl, context);
                typeDeclSymbol = symbolAndDiagnostic.symbol;
                context.resolvingTypeReference = prevResolvingTypeReference;
            } else if (typeRef.term.nodeType === 5 /* StringLiteral */) {
                var stringConstantAST = typeRef.term;
                typeDeclSymbol = new TypeScript.PullStringConstantTypeSymbol(stringConstantAST.actualText);
                var decl = new TypeScript.PullDecl(stringConstantAST.actualText, stringConstantAST.actualText, typeDeclSymbol.getKind(), null, new TypeScript.TextSpan(stringConstantAST.minChar, stringConstantAST.getLength()), enclosingDecl.getScriptName());
                this.currentUnit.addSynthesizedDecl(decl);
                typeDeclSymbol.addDeclaration(decl);
            }

            if (!typeDeclSymbol) {
                return SymbolAndDiagnostics.create(this.getNewErrorTypeSymbol(null), [context.postError(this.unitPath, typeRef.term.minChar, typeRef.term.getLength(), 146 /* Unable_to_resolve_type */)]);
            }

            if (typeDeclSymbol.isError()) {
                return SymbolAndDiagnostics.fromSymbol(typeDeclSymbol);
            }

            if (typeRef.arrayCount) {
                var arraySymbol = typeDeclSymbol.getArrayType();

                if (!arraySymbol) {
                    if (!this.cachedArrayInterfaceType().isResolved()) {
                        this.resolveDeclaredSymbol(this.cachedArrayInterfaceType(), enclosingDecl, context);
                    }

                    if (typeDeclSymbol.isNamedTypeSymbol() && typeDeclSymbol.isGeneric() && !typeDeclSymbol.isTypeParameter() && typeDeclSymbol.isResolved() && !typeDeclSymbol.getIsSpecialized() && typeDeclSymbol.getTypeParameters().length && (typeDeclSymbol.getTypeArguments() == null && !this.isArrayOrEquivalent(typeDeclSymbol)) && this.isTypeRefWithoutTypeArgs(typeRef)) {
                        context.postError(this.unitPath, typeRef.minChar, typeRef.getLength(), 239 /* Generic_type_references_must_include_all_type_arguments */, null, enclosingDecl, true);
                        typeDeclSymbol = this.specializeTypeToAny(typeDeclSymbol, enclosingDecl, context);
                    }

                    arraySymbol = TypeScript.specializeToArrayType(this.semanticInfoChain.elementTypeSymbol, typeDeclSymbol, this, context);

                    if (!arraySymbol) {
                        arraySymbol = this.semanticInfoChain.anyTypeSymbol;
                    }
                }

                if (typeRef.arrayCount > 1) {
                    for (var arity = typeRef.arrayCount - 1; arity > 0; arity--) {
                        var existingArraySymbol = arraySymbol.getArrayType();

                        if (!existingArraySymbol) {
                            arraySymbol = TypeScript.specializeToArrayType(this.semanticInfoChain.elementTypeSymbol, arraySymbol, this, context);
                        } else {
                            arraySymbol = existingArraySymbol;
                        }
                    }
                }

                typeDeclSymbol = arraySymbol;
            }

            return SymbolAndDiagnostics.fromSymbol(typeDeclSymbol);
        };

        PullTypeResolver.prototype.resolveVariableDeclaration = function (varDecl, context, enclosingDecl) {
            var decl = this.getDeclForAST(varDecl);

            if (enclosingDecl && decl.getKind() == 2048 /* Parameter */) {
                enclosingDecl.ensureSymbolIsBound();
            }

            var declSymbol = decl.getSymbol();
            var declParameterSymbol = decl.getValueDecl() ? decl.getValueDecl().getSymbol() : null;

            if (declSymbol.isResolved()) {
                var declType = declSymbol.getType();
                var valDecl = decl.getValueDecl();

                if (valDecl) {
                    var valSymbol = valDecl.getSymbol();

                    if (valSymbol && !valSymbol.isResolved()) {
                        valSymbol.setType(declType);
                        valSymbol.setResolved();
                    }
                }

                return declType;
            }

            if (declSymbol.isResolving()) {
                if (!context.inSpecialization) {
                    declSymbol.setType(this.semanticInfoChain.anyTypeSymbol);
                    declSymbol.setResolved();
                    return declSymbol;
                }
            }

            declSymbol.startResolving();

            var wrapperDecl = this.getEnclosingDecl(decl);
            wrapperDecl = wrapperDecl ? wrapperDecl : enclosingDecl;

            var diagnostic = null;

            if (varDecl.typeExpr) {
                var typeExprSymbol = this.resolveTypeReference(varDecl.typeExpr, wrapperDecl, context).symbol;

                if (!typeExprSymbol) {
                    diagnostic = context.postError(this.unitPath, varDecl.minChar, varDecl.getLength(), 147 /* Unable_to_resolve_type_of__0_ */, [varDecl.id.actualText], decl);
                    declSymbol.setType(this.getNewErrorTypeSymbol(diagnostic));

                    if (declParameterSymbol) {
                        context.setTypeInContext(declParameterSymbol, this.semanticInfoChain.anyTypeSymbol);
                    }
                } else if (typeExprSymbol.isError()) {
                    context.setTypeInContext(declSymbol, typeExprSymbol);
                } else {
                    if (typeExprSymbol.isNamedTypeSymbol() && typeExprSymbol.isGeneric() && !typeExprSymbol.isTypeParameter() && typeExprSymbol.isResolved() && !typeExprSymbol.getIsSpecialized() && typeExprSymbol.getTypeParameters().length && (typeExprSymbol.getTypeArguments() == null && !this.isArrayOrEquivalent(typeExprSymbol)) && this.isTypeRefWithoutTypeArgs(varDecl.typeExpr)) {
                        context.postError(this.unitPath, varDecl.typeExpr.minChar, varDecl.typeExpr.getLength(), 239 /* Generic_type_references_must_include_all_type_arguments */, null, enclosingDecl, true);
                        typeExprSymbol = this.specializeTypeToAny(typeExprSymbol, enclosingDecl, context);
                    }

                    if (typeExprSymbol.isContainer()) {
                        var exportedTypeSymbol = (typeExprSymbol).getExportAssignedTypeSymbol();

                        if (exportedTypeSymbol) {
                            typeExprSymbol = exportedTypeSymbol;
                        } else {
                            var instanceSymbol = (typeExprSymbol.getType()).getInstanceSymbol();

                            if (!instanceSymbol || !TypeScript.PullHelpers.symbolIsEnum(instanceSymbol)) {
                                typeExprSymbol = this.getNewErrorTypeSymbol(diagnostic);
                            } else {
                                typeExprSymbol = instanceSymbol.getType();
                            }
                        }
                    } else if (declSymbol.getIsVarArg() && !(typeExprSymbol.isArray() || typeExprSymbol == this.cachedArrayInterfaceType())) {
                        var diagnostic = context.postError(this.unitPath, varDecl.minChar, varDecl.getLength(), 228 /* Rest_parameters_must_be_array_types */, null, enclosingDecl);
                        typeExprSymbol = this.getNewErrorTypeSymbol(diagnostic);
                    }

                    context.setTypeInContext(declSymbol, typeExprSymbol);

                    if (declParameterSymbol) {
                        declParameterSymbol.setType(typeExprSymbol);
                    }

                    if ((varDecl.nodeType === 19 /* Parameter */) && enclosingDecl && ((typeExprSymbol.isGeneric() && !typeExprSymbol.isArray()) || this.isTypeArgumentOrWrapper(typeExprSymbol))) {
                        var signature = enclosingDecl.getSpecializingSignatureSymbol();

                        if (signature) {
                            signature.setHasGenericParameter();
                        }
                    }
                }
            } else if (varDecl.init) {
                var initExprSymbolAndDiagnostics = this.resolveAST(varDecl.init, false, wrapperDecl, context);
                var initExprSymbol = initExprSymbolAndDiagnostics && initExprSymbolAndDiagnostics.symbol;

                if (!initExprSymbol) {
                    diagnostic = context.postError(this.unitPath, varDecl.minChar, varDecl.getLength(), 147 /* Unable_to_resolve_type_of__0_ */, [varDecl.id.actualText], decl);

                    context.setTypeInContext(declSymbol, this.getNewErrorTypeSymbol(diagnostic));

                    if (declParameterSymbol) {
                        context.setTypeInContext(declParameterSymbol, this.semanticInfoChain.anyTypeSymbol);
                    }
                } else {
                    context.setTypeInContext(declSymbol, this.widenType(initExprSymbol.getType()));
                    initExprSymbol.addOutgoingLink(declSymbol, 2 /* ProvidesInferredType */);

                    if (declParameterSymbol) {
                        context.setTypeInContext(declParameterSymbol, initExprSymbol.getType());
                        initExprSymbol.addOutgoingLink(declParameterSymbol, 2 /* ProvidesInferredType */);
                    }
                }
            } else if (declSymbol.getKind() === 4 /* Container */) {
                instanceSymbol = (declSymbol).getInstanceSymbol();
                var instanceType = instanceSymbol.getType();

                if (instanceType) {
                    context.setTypeInContext(declSymbol, instanceType);
                } else {
                    context.setTypeInContext(declSymbol, this.semanticInfoChain.anyTypeSymbol);
                }
            } else {
                var defaultType = this.semanticInfoChain.anyTypeSymbol;

                if (declSymbol.getIsVarArg()) {
                    defaultType = TypeScript.specializeToArrayType(this.cachedArrayInterfaceType(), defaultType, this, context);
                }

                context.setTypeInContext(declSymbol, defaultType);

                if (declParameterSymbol) {
                    declParameterSymbol.setType(defaultType);
                }
            }

            declSymbol.setResolved();

            if (declParameterSymbol) {
                declParameterSymbol.setResolved();
            }

            return declSymbol;
        };

        PullTypeResolver.prototype.resolveTypeParameterDeclaration = function (typeParameterAST, context) {
            var typeParameterDecl = this.getDeclForAST(typeParameterAST);
            var typeParameterSymbol = typeParameterDecl.getSymbol();

            if (typeParameterSymbol.isResolved() || typeParameterSymbol.isResolving()) {
                return typeParameterSymbol;
            }

            typeParameterSymbol.startResolving();

            if (typeParameterAST.constraint) {
                var enclosingDecl = this.getEnclosingDecl(typeParameterDecl);
                var constraintTypeSymbol = this.resolveTypeReference(typeParameterAST.constraint, enclosingDecl, context).symbol;

                if (constraintTypeSymbol.isNamedTypeSymbol() && constraintTypeSymbol.isGeneric() && !constraintTypeSymbol.isTypeParameter() && constraintTypeSymbol.getTypeParameters().length && (constraintTypeSymbol.getTypeArguments() == null && !this.isArrayOrEquivalent(constraintTypeSymbol)) && constraintTypeSymbol.isResolved() && this.isTypeRefWithoutTypeArgs(typeParameterAST.constraint)) {
                    context.postError(this.unitPath, typeParameterAST.constraint.minChar, typeParameterAST.constraint.getLength(), 239 /* Generic_type_references_must_include_all_type_arguments */, null, enclosingDecl, true);
                    constraintTypeSymbol = this.specializeTypeToAny(constraintTypeSymbol, enclosingDecl, context);
                }

                if (constraintTypeSymbol) {
                    typeParameterSymbol.setConstraint(constraintTypeSymbol);
                }
            }

            typeParameterSymbol.setResolved();

            return typeParameterSymbol;
        };

        PullTypeResolver.prototype.resolveFunctionBodyReturnTypes = function (funcDeclAST, signature, useContextualType, enclosingDecl, context) {
            var _this = this;
            var returnStatements = [];

            var enclosingDeclStack = [enclosingDecl];

            var preFindReturnExpressionTypes = function (ast, parent, walker) {
                var go = true;

                switch (ast.nodeType) {
                    case 12 /* FunctionDeclaration */:
                        go = false;
                        break;

                    case 93 /* ReturnStatement */:
                        var returnStatement = ast;
                        returnStatements[returnStatements.length] = { returnStatement: returnStatement, enclosingDecl: enclosingDeclStack[enclosingDeclStack.length - 1] };
                        go = false;
                        break;

                    case 101 /* CatchClause */:
                    case 99 /* WithStatement */:
                        enclosingDeclStack[enclosingDeclStack.length] = _this.getDeclForAST(ast);
                        break;

                    default:
                        break;
                }

                walker.options.goChildren = go;

                return ast;
            };

            var postFindReturnExpressionEnclosingDecls = function (ast, parent, walker) {
                switch (ast.nodeType) {
                    case 101 /* CatchClause */:
                    case 99 /* WithStatement */:
                        enclosingDeclStack.length--;
                        break;
                    default:
                        break;
                }

                walker.options.goChildren = true;

                return ast;
            };

            TypeScript.getAstWalkerFactory().walk(funcDeclAST.block, preFindReturnExpressionTypes, postFindReturnExpressionEnclosingDecls);

            if (!returnStatements.length) {
                signature.setReturnType(this.semanticInfoChain.voidTypeSymbol);
            } else {
                var returnExpressionSymbols = [];
                var returnType;

                for (var i = 0; i < returnStatements.length; i++) {
                    if (returnStatements[i].returnStatement.returnExpression) {
                        returnType = this.resolveAST(returnStatements[i].returnStatement.returnExpression, useContextualType, returnStatements[i].enclosingDecl, context).symbol.getType();

                        if (returnType.isError()) {
                            signature.setReturnType(returnType);
                            return;
                        }

                        returnExpressionSymbols[returnExpressionSymbols.length] = returnType;
                    }
                }

                if (!returnExpressionSymbols.length) {
                    signature.setReturnType(this.semanticInfoChain.voidTypeSymbol);
                } else {
                    var collection = {
                        getLength: function () {
                            return returnExpressionSymbols.length;
                        },
                        setTypeAtIndex: function (index, type) {
                        },
                        getTypeAtIndex: function (index) {
                            return returnExpressionSymbols[index].getType();
                        }
                    };

                    returnType = this.findBestCommonType(returnExpressionSymbols[0], null, collection, context, new TypeScript.TypeComparisonInfo());

                    if (useContextualType && returnType == this.semanticInfoChain.anyTypeSymbol) {
                        var contextualType = context.getContextualType();

                        if (contextualType) {
                            returnType = contextualType;
                        }
                    }

                    signature.setReturnType(returnType ? this.widenType(returnType) : this.semanticInfoChain.anyTypeSymbol);

                    if (this.isTypeArgumentOrWrapper(returnType)) {
                        var functionDecl = this.getDeclForAST(funcDeclAST);
                        var functionSymbol = functionDecl.getSymbol();

                        if (functionSymbol) {
                            functionSymbol.getType().setHasGenericSignature();
                        }
                    }

                    for (var i = 0; i < returnExpressionSymbols.length; i++) {
                        returnExpressionSymbols[i].addOutgoingLink(signature, 2 /* ProvidesInferredType */);
                    }
                }
            }
        };

        PullTypeResolver.prototype.resolveFunctionDeclaration = function (funcDeclAST, context) {
            var funcDecl = this.getDeclForAST(funcDeclAST);

            var funcSymbol = funcDecl.getSymbol();

            var signature = funcDecl.getSpecializingSignatureSymbol();

            var hadError = false;

            var isConstructor = funcDeclAST.isConstructor || TypeScript.hasFlag(funcDeclAST.getFunctionFlags(), 1024 /* ConstructMember */);

            if (signature) {
                if (signature.isResolved()) {
                    return funcSymbol;
                }

                if (isConstructor && !signature.isResolving()) {
                    var classAST = funcDeclAST.classDecl;

                    if (classAST) {
                        var classDecl = this.getDeclForAST(classAST);
                        var classSymbol = classDecl.getSymbol();

                        if (!classSymbol.isResolved() && !classSymbol.isResolving()) {
                            this.resolveDeclaredSymbol(classSymbol, this.getEnclosingDecl(classDecl), context);
                        }
                    }
                }

                var diagnostic;

                if (signature.isResolving()) {
                    if (funcDeclAST.returnTypeAnnotation) {
                        var returnTypeSymbol = this.resolveTypeReference(funcDeclAST.returnTypeAnnotation, funcDecl, context).symbol;
                        if (!returnTypeSymbol) {
                            diagnostic = context.postError(this.unitPath, funcDeclAST.returnTypeAnnotation.minChar, funcDeclAST.returnTypeAnnotation.getLength(), 197 /* Cannot_resolve_return_type_reference */, null, funcDecl);
                            signature.setReturnType(this.getNewErrorTypeSymbol(diagnostic));
                            hadError = true;
                        } else {
                            if (this.isTypeArgumentOrWrapper(returnTypeSymbol)) {
                                signature.setHasGenericParameter();
                                if (funcSymbol) {
                                    funcSymbol.getType().setHasGenericSignature();
                                }
                            }
                            signature.setReturnType(returnTypeSymbol);

                            if (isConstructor && returnTypeSymbol === this.semanticInfoChain.voidTypeSymbol) {
                                context.postError(this.unitPath, funcDeclAST.minChar, funcDeclAST.getLength(), 198 /* Constructors_cannot_have_a_return_type_of__void_ */, null, funcDecl, true);
                            }
                        }
                    } else {
                        signature.setReturnType(this.semanticInfoChain.anyTypeSymbol);
                    }

                    signature.setResolved();
                    return funcSymbol;
                }

                signature.startResolving();

                if (funcDeclAST.typeArguments) {
                    for (var i = 0; i < funcDeclAST.typeArguments.members.length; i++) {
                        this.resolveTypeParameterDeclaration(funcDeclAST.typeArguments.members[i], context);
                    }
                }

                if (funcDeclAST.arguments) {
                    for (var i = 0; i < funcDeclAST.arguments.members.length; i++) {
                        this.resolveVariableDeclaration(funcDeclAST.arguments.members[i], context, funcDecl);
                    }
                }

                if (signature.isGeneric()) {
                    if (funcSymbol) {
                        funcSymbol.getType().setHasGenericSignature();
                    }
                }

                if (funcDeclAST.returnTypeAnnotation) {
                    var prevReturnTypeSymbol = signature.getReturnType();

                    returnTypeSymbol = this.resolveTypeReference(funcDeclAST.returnTypeAnnotation, funcDecl, context).symbol;

                    if (!returnTypeSymbol) {
                        diagnostic = context.postError(this.unitPath, funcDeclAST.returnTypeAnnotation.minChar, funcDeclAST.returnTypeAnnotation.getLength(), 197 /* Cannot_resolve_return_type_reference */, null, funcDecl);
                        signature.setReturnType(this.getNewErrorTypeSymbol(diagnostic));

                        hadError = true;
                    } else if (!(this.isTypeArgumentOrWrapper(returnTypeSymbol) && prevReturnTypeSymbol && !this.isTypeArgumentOrWrapper(prevReturnTypeSymbol))) {
                        if (this.isTypeArgumentOrWrapper(returnTypeSymbol)) {
                            signature.setHasGenericParameter();

                            if (funcSymbol) {
                                funcSymbol.getType().setHasGenericSignature();
                            }
                        }

                        signature.setReturnType(returnTypeSymbol);

                        if (isConstructor && returnTypeSymbol === this.semanticInfoChain.voidTypeSymbol) {
                            context.postError(this.unitPath, funcDeclAST.minChar, funcDeclAST.getLength(), 198 /* Constructors_cannot_have_a_return_type_of__void_ */, null, funcDecl, true);
                        }
                    }
                } else if (!funcDeclAST.isConstructor) {
                    if (funcDeclAST.isSignature()) {
                        signature.setReturnType(this.semanticInfoChain.anyTypeSymbol);
                    } else {
                        this.resolveFunctionBodyReturnTypes(funcDeclAST, signature, false, funcDecl, context);
                    }
                }

                if (!hadError) {
                    signature.setResolved();
                }
            }

            return funcSymbol;
        };

        PullTypeResolver.prototype.resolveGetAccessorDeclaration = function (funcDeclAST, context) {
            var funcDecl = this.getDeclForAST(funcDeclAST);
            var accessorSymbol = funcDecl.getSymbol();

            var getterSymbol = accessorSymbol.getGetter();
            var getterTypeSymbol = getterSymbol.getType();

            var signature = getterTypeSymbol.getCallSignatures()[0];

            var hadError = false;
            var diagnostic;

            if (signature) {
                if (signature.isResolved()) {
                    return accessorSymbol;
                }

                if (signature.isResolving()) {
                    signature.setReturnType(this.semanticInfoChain.anyTypeSymbol);
                    signature.setResolved();

                    return accessorSymbol;
                }

                signature.startResolving();

                if (funcDeclAST.arguments) {
                    for (var i = 0; i < funcDeclAST.arguments.members.length; i++) {
                        this.resolveVariableDeclaration(funcDeclAST.arguments.members[i], context, funcDecl);
                    }
                }

                if (signature.hasGenericParameter()) {
                    if (getterSymbol) {
                        getterTypeSymbol.setHasGenericSignature();
                    }
                }

                if (funcDeclAST.returnTypeAnnotation) {
                    var returnTypeSymbol = this.resolveTypeReference(funcDeclAST.returnTypeAnnotation, funcDecl, context).symbol;

                    if (!returnTypeSymbol) {
                        diagnostic = context.postError(this.unitPath, funcDeclAST.returnTypeAnnotation.minChar, funcDeclAST.returnTypeAnnotation.getLength(), 197 /* Cannot_resolve_return_type_reference */, null, funcDecl);
                        signature.setReturnType(this.getNewErrorTypeSymbol(diagnostic));

                        hadError = true;
                    } else {
                        if (this.isTypeArgumentOrWrapper(returnTypeSymbol)) {
                            signature.setHasGenericParameter();

                            if (getterSymbol) {
                                getterTypeSymbol.setHasGenericSignature();
                            }
                        }

                        signature.setReturnType(returnTypeSymbol);
                    }
                } else {
                    if (funcDeclAST.isSignature()) {
                        signature.setReturnType(this.semanticInfoChain.anyTypeSymbol);
                    } else {
                        this.resolveFunctionBodyReturnTypes(funcDeclAST, signature, false, funcDecl, context);
                    }
                }

                if (!hadError) {
                    signature.setResolved();
                }
            }

            var accessorType = signature.getReturnType();

            var setter = accessorSymbol.getSetter();

            if (setter) {
                var setterType = setter.getType();
                var setterSig = setterType.getCallSignatures()[0];

                if (setterSig.isResolved()) {
                    var setterParameters = setterSig.getParameters();

                    if (setterParameters.length) {
                        var setterParameter = setterParameters[0];
                        var setterParameterType = setterParameter.getType();

                        if (!this.typesAreIdentical(accessorType, setterParameterType)) {
                            diagnostic = context.postError(this.unitPath, funcDeclAST.minChar, funcDeclAST.getLength(), 165 /* _get__and__set__accessor_must_have_the_same_type */, null, this.getEnclosingDecl(funcDecl));
                            accessorSymbol.setType(this.getNewErrorTypeSymbol(diagnostic));
                        }
                    }
                } else {
                    accessorSymbol.setType(accessorType);
                }
            } else {
                accessorSymbol.setType(accessorType);
            }

            return accessorSymbol;
        };

        PullTypeResolver.prototype.resolveSetAccessorDeclaration = function (funcDeclAST, context) {
            var funcDecl = this.getDeclForAST(funcDeclAST);
            var accessorSymbol = funcDecl.getSymbol();

            var setterSymbol = accessorSymbol.getSetter();
            var setterTypeSymbol = setterSymbol.getType();

            var signature = setterTypeSymbol.getCallSignatures()[0];

            var hadError = false;

            if (signature) {
                if (signature.isResolved()) {
                    return accessorSymbol;
                }

                if (signature.isResolving()) {
                    signature.setReturnType(this.semanticInfoChain.anyTypeSymbol);
                    signature.setResolved();

                    return accessorSymbol;
                }

                signature.startResolving();

                if (funcDeclAST.arguments) {
                    for (var i = 0; i < funcDeclAST.arguments.members.length; i++) {
                        this.resolveVariableDeclaration(funcDeclAST.arguments.members[i], context, funcDecl);
                    }
                }

                if (signature.hasGenericParameter()) {
                    if (setterSymbol) {
                        setterTypeSymbol.setHasGenericSignature();
                    }
                }

                if (!hadError) {
                    signature.setResolved();
                }
            }

            var parameters = signature.getParameters();

            var getter = accessorSymbol.getGetter();

            var accessorType = parameters.length ? parameters[0].getType() : getter ? getter.getType() : this.semanticInfoChain.undefinedTypeSymbol;

            if (getter) {
                var getterType = getter.getType();
                var getterSig = getterType.getCallSignatures()[0];

                if (accessorType == this.semanticInfoChain.undefinedTypeSymbol) {
                    accessorType = getterType;
                }

                if (getterSig.isResolved()) {
                    var getterReturnType = getterSig.getReturnType();

                    if (!this.typesAreIdentical(accessorType, getterReturnType)) {
                        if (this.isAnyOrEquivalent(accessorType)) {
                            accessorSymbol.setType(getterReturnType);
                            if (!accessorType.isError()) {
                                parameters[0].setType(getterReturnType);
                            }
                        } else {
                            var diagnostic = context.postError(this.unitPath, funcDeclAST.minChar, funcDeclAST.getLength(), 165 /* _get__and__set__accessor_must_have_the_same_type */, null, this.getEnclosingDecl(funcDecl));
                            accessorSymbol.setType(this.getNewErrorTypeSymbol(diagnostic));
                        }
                    }
                } else {
                    accessorSymbol.setType(accessorType);
                }
            } else {
                accessorSymbol.setType(accessorType);
            }

            return accessorSymbol;
        };

        PullTypeResolver.prototype.resolveAST = function (ast, inContextuallyTypedAssignment, enclosingDecl, context) {
            TypeScript.globalSemanticInfoChain = this.semanticInfoChain;

            if (TypeScript.globalBinder) {
                TypeScript.globalBinder.semanticInfoChain = this.semanticInfoChain;
            }

            switch (ast.nodeType) {
                case 101 /* CatchClause */:
                case 99 /* WithStatement */:
                case 2 /* Script */:
                    return SymbolAndDiagnostics.fromSymbol(null);

                case 15 /* ModuleDeclaration */:
                    return SymbolAndDiagnostics.fromSymbol(this.resolveModuleDeclaration(ast, context));

                case 14 /* InterfaceDeclaration */:
                    return SymbolAndDiagnostics.fromSymbol(this.resolveInterfaceDeclaration(ast, context));

                case 13 /* ClassDeclaration */:
                    return SymbolAndDiagnostics.fromSymbol(this.resolveClassDeclaration(ast, context));

                case 17 /* VariableDeclarator */:
                case 19 /* Parameter */:
                    return SymbolAndDiagnostics.fromSymbol(this.resolveVariableDeclaration(ast, context, enclosingDecl));

                case 9 /* TypeParameter */:
                    return SymbolAndDiagnostics.fromSymbol(this.resolveTypeParameterDeclaration(ast, context));

                case 16 /* ImportDeclaration */:
                    return SymbolAndDiagnostics.fromSymbol(this.resolveImportDeclaration(ast, context));

                case 22 /* ObjectLiteralExpression */:
                    return this.resolveObjectLiteralExpression(ast, inContextuallyTypedAssignment, enclosingDecl, context);

                case 10 /* GenericType */:
                    return this.resolveGenericTypeReference(ast, enclosingDecl, context);

                case 20 /* Name */:
                    if (context.resolvingTypeReference) {
                        return this.resolveTypeNameExpression(ast, enclosingDecl, context);
                    } else {
                        return this.resolveNameExpression(ast, enclosingDecl, context);
                    }

                case 32 /* MemberAccessExpression */:
                    if (context.resolvingTypeReference) {
                        return this.resolveDottedTypeNameExpression(ast, enclosingDecl, context);
                    } else {
                        return this.resolveDottedNameExpression(ast, enclosingDecl, context);
                    }

                case 10 /* GenericType */:
                    return this.resolveGenericTypeReference(ast, enclosingDecl, context);

                case 12 /* FunctionDeclaration */: {
                    var funcDecl = ast;

                    if (funcDecl.isGetAccessor()) {
                        return SymbolAndDiagnostics.fromSymbol(this.resolveGetAccessorDeclaration(funcDecl, context));
                    } else if (funcDecl.isSetAccessor()) {
                        return SymbolAndDiagnostics.fromSymbol(this.resolveSetAccessorDeclaration(funcDecl, context));
                    } else if (inContextuallyTypedAssignment || (funcDecl.getFunctionFlags() & 8192 /* IsFunctionExpression */) || (funcDecl.getFunctionFlags() & 2048 /* IsFatArrowFunction */) || (funcDecl.getFunctionFlags() & 16384 /* IsFunctionProperty */)) {
                        return SymbolAndDiagnostics.fromSymbol(this.resolveFunctionExpression(funcDecl, inContextuallyTypedAssignment, enclosingDecl, context));
                    } else {
                        return SymbolAndDiagnostics.fromSymbol(this.resolveFunctionDeclaration(funcDecl, context));
                    }
                }

                case 21 /* ArrayLiteralExpression */:
                    return this.resolveArrayLiteralExpression(ast, inContextuallyTypedAssignment, enclosingDecl, context);

                case 29 /* ThisExpression */:
                    return this.resolveThisExpression(ast, enclosingDecl, context);

                case 30 /* SuperExpression */:
                    return this.resolveSuperExpression(ast, enclosingDecl, context);

                case 36 /* InvocationExpression */:
                    return this.resolveCallExpression(ast, inContextuallyTypedAssignment, enclosingDecl, context);

                case 37 /* ObjectCreationExpression */:
                    return this.resolveNewExpression(ast, inContextuallyTypedAssignment, enclosingDecl, context);

                case 78 /* CastExpression */:
                    return this.resolveTypeAssertionExpression(ast, inContextuallyTypedAssignment, enclosingDecl, context);

                case 11 /* TypeRef */:
                    return this.resolveTypeReference(ast, enclosingDecl, context);

                case 87 /* ExportAssignment */:
                    return this.resolveExportAssignmentStatement(ast, enclosingDecl, context);

                case 7 /* NumericLiteral */:
                    return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.numberTypeSymbol);
                case 5 /* StringLiteral */:
                    return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.stringTypeSymbol);
                case 8 /* NullLiteral */:
                    return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.nullTypeSymbol);
                case 3 /* TrueLiteral */:
                case 4 /* FalseLiteral */:
                    return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.booleanTypeSymbol);
                case 24 /* VoidExpression */:
                    return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.voidTypeSymbol);

                case 38 /* AssignmentExpression */:
                    return this.resolveAssignmentStatement(ast, inContextuallyTypedAssignment, enclosingDecl, context);

                case 73 /* LogicalNotExpression */:
                case 57 /* NotEqualsWithTypeConversionExpression */:
                case 56 /* EqualsWithTypeConversionExpression */:
                case 58 /* EqualsExpression */:
                case 59 /* NotEqualsExpression */:
                case 60 /* LessThanExpression */:
                case 61 /* LessThanOrEqualExpression */:
                case 63 /* GreaterThanOrEqualExpression */:
                case 62 /* GreaterThanExpression */:
                    return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.booleanTypeSymbol);

                case 64 /* AddExpression */:
                case 39 /* AddAssignmentExpression */:
                    return this.resolveArithmeticExpression(ast, inContextuallyTypedAssignment, enclosingDecl, context);

                case 40 /* SubtractAssignmentExpression */:
                case 42 /* MultiplyAssignmentExpression */:
                case 41 /* DivideAssignmentExpression */:
                case 43 /* ModuloAssignmentExpression */:
                case 46 /* OrAssignmentExpression */:
                case 44 /* AndAssignmentExpression */:

                case 72 /* BitwiseNotExpression */:
                case 65 /* SubtractExpression */:
                case 66 /* MultiplyExpression */:
                case 67 /* DivideExpression */:
                case 68 /* ModuloExpression */:
                case 53 /* BitwiseOrExpression */:
                case 55 /* BitwiseAndExpression */:
                case 26 /* PlusExpression */:
                case 27 /* NegateExpression */:
                case 76 /* PostIncrementExpression */:
                case 74 /* PreIncrementExpression */:
                case 77 /* PostDecrementExpression */:
                case 75 /* PreDecrementExpression */:
                    return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.numberTypeSymbol);

                case 69 /* LeftShiftExpression */:
                case 70 /* SignedRightShiftExpression */:
                case 71 /* UnsignedRightShiftExpression */:
                case 47 /* LeftShiftAssignmentExpression */:
                case 48 /* SignedRightShiftAssignmentExpression */:
                case 49 /* UnsignedRightShiftAssignmentExpression */:
                    return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.numberTypeSymbol);

                case 35 /* ElementAccessExpression */:
                    return this.resolveIndexExpression(ast, inContextuallyTypedAssignment, enclosingDecl, context);

                case 51 /* LogicalOrExpression */:
                    return this.resolveLogicalOrExpression(ast, inContextuallyTypedAssignment, enclosingDecl, context);

                case 52 /* LogicalAndExpression */:
                    return this.resolveLogicalAndExpression(ast, inContextuallyTypedAssignment, enclosingDecl, context);

                case 34 /* TypeOfExpression */:
                    return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.stringTypeSymbol);

                case 95 /* ThrowStatement */:
                    return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.voidTypeSymbol);

                case 28 /* DeleteExpression */:
                    return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.booleanTypeSymbol);

                case 50 /* ConditionalExpression */:
                    return this.resolveConditionalExpression(ast, enclosingDecl, context);

                case 6 /* RegularExpressionLiteral */:
                    return this.resolveRegularExpressionLiteral();

                case 79 /* ParenthesizedExpression */:
                    return this.resolveParenthesizedExpression(ast, enclosingDecl, context);

                case 88 /* ExpressionStatement */:
                    return this.resolveExpressionStatement(ast, inContextuallyTypedAssignment, enclosingDecl, context);

                case 33 /* InstanceOfExpression */:
                    return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.booleanTypeSymbol);
            }

            return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.anyTypeSymbol);
        };

        PullTypeResolver.prototype.resolveRegularExpressionLiteral = function () {
            if (this.cachedRegExpInterfaceType()) {
                return SymbolAndDiagnostics.fromSymbol(this.cachedRegExpInterfaceType());
            } else {
                return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.anyTypeSymbol);
            }
        };

        PullTypeResolver.prototype.isNameOrMemberAccessExpression = function (ast) {
            var checkAST = ast;

            while (checkAST) {
                if (checkAST.nodeType === 88 /* ExpressionStatement */) {
                    checkAST = (checkAST).expression;
                } else if (checkAST.nodeType === 79 /* ParenthesizedExpression */) {
                    checkAST = (checkAST).expression;
                } else if (checkAST.nodeType === 20 /* Name */) {
                    return true;
                } else if (checkAST.nodeType === 32 /* MemberAccessExpression */) {
                    return true;
                } else {
                    return false;
                }
            }
        };

        PullTypeResolver.prototype.resolveNameSymbol = function (nameSymbol, context) {
            if (nameSymbol && !context.canUseTypeSymbol && nameSymbol != this.semanticInfoChain.undefinedTypeSymbol && nameSymbol != this.semanticInfoChain.nullTypeSymbol && (nameSymbol.isPrimitive() || !(nameSymbol.getKind() & TypeScript.PullElementKind.SomeValue))) {
                nameSymbol = null;
            }

            return nameSymbol;
        };

        PullTypeResolver.prototype.resolveNameExpression = function (nameAST, enclosingDecl, context) {
            var nameSymbolAndDiagnostics = this.getSymbolAndDiagnosticsForAST(nameAST);
            var foundCached = nameSymbolAndDiagnostics != null;

            if (!foundCached) {
                nameSymbolAndDiagnostics = this.computeNameExpression(nameAST, enclosingDecl, context);
            }

            var nameSymbol = nameSymbolAndDiagnostics.symbol;
            if (!nameSymbol.isResolved()) {
                this.resolveDeclaredSymbol(nameSymbol, enclosingDecl, context);
            }

            if (!foundCached && !this.isAnyOrEquivalent(nameSymbol.getType())) {
                this.setSymbolAndDiagnosticsForAST(nameAST, nameSymbolAndDiagnostics, context);
            }

            return nameSymbolAndDiagnostics;
        };

        PullTypeResolver.prototype.computeNameExpression = function (nameAST, enclosingDecl, context) {
            if (nameAST.isMissing()) {
                return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.anyTypeSymbol);
            }

            var id = nameAST.text;

            var declPath = enclosingDecl !== null ? TypeScript.getPathToDecl(enclosingDecl) : [];

            if (enclosingDecl && !declPath.length) {
                declPath = [enclosingDecl];
            }

            var aliasSymbol = null;
            var nameSymbol = this.getSymbolFromDeclPath(id, declPath, TypeScript.PullElementKind.SomeValue);

            if (!nameSymbol && id === "arguments" && enclosingDecl && (enclosingDecl.getKind() & TypeScript.PullElementKind.SomeFunction)) {
                nameSymbol = this.cachedFunctionArgumentsSymbol;

                if (this.cachedIArgumentsInterfaceType() && !this.cachedIArgumentsInterfaceType().isResolved()) {
                    this.resolveDeclaredSymbol(this.cachedIArgumentsInterfaceType(), enclosingDecl, context);
                }
            }

            if (!nameSymbol) {
                return SymbolAndDiagnostics.create(this.getNewErrorTypeSymbol(null, id), [context.postError(this.unitPath, nameAST.minChar, nameAST.getLength(), 164 /* Could_not_find_symbol__0_ */, [nameAST.actualText])]);
            }

            if (nameSymbol.isType() && nameSymbol.isAlias()) {
                aliasSymbol = nameSymbol;

                (aliasSymbol).setIsUsedAsValue();

                if (!nameSymbol.isResolved()) {
                    this.resolveDeclaredSymbol(nameSymbol, enclosingDecl, context);
                }

                var exportAssignmentSymbol = (nameSymbol).getExportAssignedValueSymbol();

                if (exportAssignmentSymbol) {
                    nameSymbol = exportAssignmentSymbol;
                } else {
                    aliasSymbol = null;
                }
            }

            return SymbolAndDiagnostics.fromAlias(nameSymbol, aliasSymbol);
        };

        PullTypeResolver.prototype.resolveDottedNameExpression = function (dottedNameAST, enclosingDecl, context) {
            var symbolAndDiagnostics = this.getSymbolAndDiagnosticsForAST(dottedNameAST);
            var foundCached = symbolAndDiagnostics != null;

            if (!foundCached) {
                symbolAndDiagnostics = this.computeDottedNameExpressionSymbol(dottedNameAST, enclosingDecl, context);
            }

            var symbol = symbolAndDiagnostics && symbolAndDiagnostics.symbol;
            if (symbol && !symbol.isResolved()) {
                this.resolveDeclaredSymbol(symbol, enclosingDecl, context);
            }

            if (!foundCached && !this.isAnyOrEquivalent(symbol.getType())) {
                this.setSymbolAndDiagnosticsForAST(dottedNameAST, symbolAndDiagnostics, context);
                this.setSymbolAndDiagnosticsForAST(dottedNameAST.operand2, symbolAndDiagnostics, context);
            }

            return symbolAndDiagnostics;
        };

        PullTypeResolver.prototype.isPrototypeMember = function (dottedNameAST, enclosingDecl, context) {
            var rhsName = (dottedNameAST.operand2).text;
            if (rhsName === "prototype") {
                var prevCanUseTypeSymbol = context.canUseTypeSymbol;
                context.canUseTypeSymbol = true;
                var lhsType = this.resolveAST(dottedNameAST.operand1, false, enclosingDecl, context).symbol.getType();
                context.canUseTypeSymbol = prevCanUseTypeSymbol;

                if (lhsType) {
                    if (lhsType.isClass() || lhsType.isConstructor()) {
                        return true;
                    } else {
                        var classInstanceType = lhsType.getAssociatedContainerType();

                        if (classInstanceType && classInstanceType.isClass()) {
                            return true;
                        }
                    }
                }
            }

            return false;
        };

        PullTypeResolver.prototype.computeDottedNameExpressionSymbol = function (dottedNameAST, enclosingDecl, context) {
            if ((dottedNameAST.operand2).isMissing()) {
                return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.anyTypeSymbol);
            }

            var rhsName = (dottedNameAST.operand2).text;
            var prevCanUseTypeSymbol = context.canUseTypeSymbol;
            context.canUseTypeSymbol = true;
            var lhs = this.resolveAST(dottedNameAST.operand1, false, enclosingDecl, context).symbol;
            context.canUseTypeSymbol = prevCanUseTypeSymbol;
            var lhsType = lhs.getType();

            if (lhs.isAlias()) {
                (lhs).setIsUsedAsValue();
            }

            if (this.isAnyOrEquivalent(lhsType)) {
                return SymbolAndDiagnostics.fromSymbol(lhsType);
            }

            if (!lhsType) {
                return SymbolAndDiagnostics.create(this.getNewErrorTypeSymbol(null), [context.postError(this.unitPath, dottedNameAST.operand2.minChar, dottedNameAST.operand2.getLength(), 162 /* Could_not_find_enclosing_symbol_for_dotted_name__0_ */, [(dottedNameAST.operand2).actualText])]);
            }

            if ((lhsType === this.semanticInfoChain.numberTypeSymbol || (lhs.getKind() == 67108864 /* EnumMember */)) && this.cachedNumberInterfaceType()) {
                lhsType = this.cachedNumberInterfaceType();
            } else if (lhsType === this.semanticInfoChain.stringTypeSymbol && this.cachedStringInterfaceType()) {
                lhsType = this.cachedStringInterfaceType();
            } else if (lhsType === this.semanticInfoChain.booleanTypeSymbol && this.cachedBooleanInterfaceType()) {
                lhsType = this.cachedBooleanInterfaceType();
            }

            if (!lhsType.isResolved()) {
                var potentiallySpecializedType = this.resolveDeclaredSymbol(lhsType, enclosingDecl, context);

                if (potentiallySpecializedType != lhsType) {
                    if (!lhs.isType()) {
                        context.setTypeInContext(lhs, potentiallySpecializedType);
                    }

                    lhsType = potentiallySpecializedType;
                }
            }

            if (lhsType.isContainer() && !lhsType.isAlias()) {
                var instanceSymbol = (lhsType).getInstanceSymbol();

                if (instanceSymbol) {
                    lhsType = instanceSymbol.getType();
                }
            }

            if (this.isPrototypeMember(dottedNameAST, enclosingDecl, context)) {
                if (lhsType.isClass()) {
                    return SymbolAndDiagnostics.fromSymbol(lhsType);
                } else {
                    var classInstanceType = lhsType.getAssociatedContainerType();

                    if (classInstanceType && classInstanceType.isClass()) {
                        return SymbolAndDiagnostics.fromSymbol(classInstanceType);
                    }
                }
            }

            if (lhsType.isTypeParameter()) {
                lhsType = this.substituteUpperBoundForType(lhsType);
            }

            var nameSymbol = null;
            if (!(lhs.isType() && (lhs).isClass() && this.isNameOrMemberAccessExpression(dottedNameAST.operand1)) && !nameSymbol) {
                nameSymbol = this.getMemberSymbol(rhsName, TypeScript.PullElementKind.SomeValue, lhsType);
                nameSymbol = this.resolveNameSymbol(nameSymbol, context);
            }

            if (!nameSymbol) {
                if (lhsType.isClass()) {
                    var staticType = (lhsType).getConstructorMethod().getType();

                    nameSymbol = this.getMemberSymbol(rhsName, TypeScript.PullElementKind.SomeValue, staticType);

                    if (!nameSymbol) {
                        nameSymbol = this.getMemberSymbol(rhsName, TypeScript.PullElementKind.SomeValue, lhsType);
                    }
                } else if ((lhsType.getCallSignatures().length || lhsType.getConstructSignatures().length) && this.cachedFunctionInterfaceType()) {
                    nameSymbol = this.getMemberSymbol(rhsName, TypeScript.PullElementKind.SomeValue, this.cachedFunctionInterfaceType());
                } else if (lhsType.isContainer()) {
                    var containerType = (lhsType.isAlias() ? (lhsType).getType() : lhsType);
                    var associatedInstance = containerType.getInstanceSymbol();

                    if (associatedInstance) {
                        var instanceType = associatedInstance.getType();

                        nameSymbol = this.getMemberSymbol(rhsName, TypeScript.PullElementKind.SomeValue, instanceType);
                    }
                } else {
                    var associatedType = lhsType.getAssociatedContainerType();

                    if (associatedType && !associatedType.isClass()) {
                        nameSymbol = this.getMemberSymbol(rhsName, TypeScript.PullElementKind.SomeValue, associatedType);
                    }
                }

                nameSymbol = this.resolveNameSymbol(nameSymbol, context);

                if (!nameSymbol && !lhsType.isPrimitive() && this.cachedObjectInterfaceType()) {
                    nameSymbol = this.getMemberSymbol(rhsName, TypeScript.PullElementKind.SomeValue, this.cachedObjectInterfaceType());
                }

                if (!nameSymbol) {
                    return SymbolAndDiagnostics.create(this.getNewErrorTypeSymbol(null, rhsName), [context.postError(this.unitPath, dottedNameAST.operand2.minChar, dottedNameAST.operand2.getLength(), 163 /* The_property__0__does_not_exist_on_value_of_type__1__ */, [(dottedNameAST.operand2).actualText, lhsType.getDisplayName()])]);
                }
            }

            return SymbolAndDiagnostics.fromSymbol(nameSymbol);
        };

        PullTypeResolver.prototype.resolveTypeNameExpression = function (nameAST, enclosingDecl, context) {
            var typeNameSymbolAndDiagnostics = this.getSymbolAndDiagnosticsForAST(nameAST);

            if (!typeNameSymbolAndDiagnostics || !typeNameSymbolAndDiagnostics.symbol.isType()) {
                typeNameSymbolAndDiagnostics = this.computeTypeNameExpression(nameAST, enclosingDecl, context);
                this.setSymbolAndDiagnosticsForAST(nameAST, typeNameSymbolAndDiagnostics, context);
            }

            var typeNameSymbol = typeNameSymbolAndDiagnostics && typeNameSymbolAndDiagnostics.symbol;
            if (!typeNameSymbol.isResolved()) {
                var savedResolvingNamespaceMemberAccess = context.resolvingNamespaceMemberAccess;
                context.resolvingNamespaceMemberAccess = false;
                this.resolveDeclaredSymbol(typeNameSymbol, enclosingDecl, context);
                context.resolvingNamespaceMemberAccess = savedResolvingNamespaceMemberAccess;
            }

            if (typeNameSymbol && !(typeNameSymbol.isTypeParameter() && (typeNameSymbol).isFunctionTypeParameter() && context.isSpecializingSignatureAtCallSite && !context.isSpecializingConstructorMethod)) {
                var substitution = context.findSpecializationForType(typeNameSymbol);

                if (typeNameSymbol.isTypeParameter() && (substitution != typeNameSymbol)) {
                    if (TypeScript.shouldSpecializeTypeParameterForTypeParameter(substitution, typeNameSymbol)) {
                        typeNameSymbol = substitution;
                    }
                }

                if (typeNameSymbol != typeNameSymbolAndDiagnostics.symbol) {
                    return SymbolAndDiagnostics.fromSymbol(typeNameSymbol);
                }
            }

            return typeNameSymbolAndDiagnostics;
        };

        PullTypeResolver.prototype.computeTypeNameExpression = function (nameAST, enclosingDecl, context) {
            if (nameAST.isMissing()) {
                return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.anyTypeSymbol);
            }

            var id = nameAST.text;

            if (id === "any") {
                return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.anyTypeSymbol);
            } else if (id === "string") {
                return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.stringTypeSymbol);
            } else if (id === "number") {
                return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.numberTypeSymbol);
            } else if (id === "bool") {
                if (this.compilationSettings.disallowBool && !this.currentUnit.getProperties().unitContainsBool) {
                    this.currentUnit.getProperties().unitContainsBool = true;
                    return SymbolAndDiagnostics.create(this.semanticInfoChain.booleanTypeSymbol, [context.postError(this.unitPath, nameAST.minChar, nameAST.getLength(), 167 /* Use_of_deprecated__bool__type__Use__boolean__instead */)]);
                } else {
                    return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.booleanTypeSymbol);
                }
            } else if (id === "boolean") {
                return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.booleanTypeSymbol);
            } else if (id === "void") {
                return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.voidTypeSymbol);
            } else {
                var declPath = enclosingDecl !== null ? TypeScript.getPathToDecl(enclosingDecl) : [];

                if (enclosingDecl && !declPath.length) {
                    declPath = [enclosingDecl];
                }

                var kindToCheckFirst = context.resolvingNamespaceMemberAccess ? TypeScript.PullElementKind.SomeContainer : TypeScript.PullElementKind.SomeType;
                var kindToCheckSecond = context.resolvingNamespaceMemberAccess ? TypeScript.PullElementKind.SomeType : TypeScript.PullElementKind.SomeContainer;

                var typeNameSymbol = this.getSymbolFromDeclPath(id, declPath, kindToCheckFirst);

                if (!typeNameSymbol) {
                    typeNameSymbol = this.getSymbolFromDeclPath(id, declPath, kindToCheckSecond);
                }

                if (!typeNameSymbol) {
                    return SymbolAndDiagnostics.create(this.getNewErrorTypeSymbol(null, id), [context.postError(this.unitPath, nameAST.minChar, nameAST.getLength(), 164 /* Could_not_find_symbol__0_ */, [nameAST.actualText])]);
                }

                if (typeNameSymbol.isAlias()) {
                    if (!typeNameSymbol.isResolved()) {
                        var savedResolvingNamespaceMemberAccess = context.resolvingNamespaceMemberAccess;
                        context.resolvingNamespaceMemberAccess = false;
                        this.resolveDeclaredSymbol(typeNameSymbol, enclosingDecl, context);
                        context.resolvingNamespaceMemberAccess = savedResolvingNamespaceMemberAccess;
                    }

                    var aliasedType = (typeNameSymbol).getType();

                    if (aliasedType && !aliasedType.isResolved()) {
                        this.resolveDeclaredSymbol(aliasedType, enclosingDecl, context);
                    }

                    var exportAssignmentSymbol = (typeNameSymbol).getExportAssignedTypeSymbol();

                    if (exportAssignmentSymbol) {
                        typeNameSymbol = exportAssignmentSymbol;
                    }
                }

                if (typeNameSymbol.isTypeParameter()) {
                    if (enclosingDecl && (enclosingDecl.getKind() & TypeScript.PullElementKind.SomeFunction) && (enclosingDecl.getFlags() & 16 /* Static */)) {
                        var parentDecl = typeNameSymbol.getDeclarations()[0].getParentDecl();

                        if (parentDecl.getKind() == 8 /* Class */) {
                            return SymbolAndDiagnostics.create(this.getNewErrorTypeSymbol(null), [context.postError(this.unitPath, nameAST.minChar, nameAST.getLength(), 226 /* Static_methods_cannot_reference_class_type_parameters */)]);
                        }
                    }
                }
            }

            return SymbolAndDiagnostics.fromSymbol(typeNameSymbol);
        };

        PullTypeResolver.prototype.addDiagnostic = function (diagnostics, diagnostic) {
            if (!diagnostics) {
                diagnostics = [];
            }

            diagnostics.push(diagnostic);
            return diagnostics;
        };

        PullTypeResolver.prototype.resolveGenericTypeReference = function (genericTypeAST, enclosingDecl, context) {
            var savedResolvingTypeReference = context.resolvingTypeReference;
            context.resolvingTypeReference = true;
            var genericTypeSymbol = this.resolveAST(genericTypeAST.name, false, enclosingDecl, context).symbol.getType();
            context.resolvingTypeReference = savedResolvingTypeReference;

            if (genericTypeSymbol.isError()) {
                return SymbolAndDiagnostics.fromSymbol(genericTypeSymbol);
            }

            if (!genericTypeSymbol.isResolving() && !genericTypeSymbol.isResolved()) {
                this.resolveDeclaredSymbol(genericTypeSymbol, enclosingDecl, context);
            }

            var typeArgs = [];

            if (!context.isResolvingTypeArguments(genericTypeAST)) {
                context.startResolvingTypeArguments(genericTypeAST);

                if (genericTypeAST.typeArguments && genericTypeAST.typeArguments.members.length) {
                    for (var i = 0; i < genericTypeAST.typeArguments.members.length; i++) {
                        var typeArg = this.resolveTypeReference(genericTypeAST.typeArguments.members[i], enclosingDecl, context).symbol;

                        if (typeArg.isNamedTypeSymbol() && typeArg.isGeneric() && !typeArg.isTypeParameter() && typeArg.isResolved() && !typeArg.getIsSpecialized() && typeArg.getTypeParameters().length && (typeArg.getTypeArguments() == null && !this.isArrayOrEquivalent(typeArg)) && this.isTypeRefWithoutTypeArgs(genericTypeAST.typeArguments.members[i])) {
                            context.postError(this.unitPath, genericTypeAST.typeArguments.members[i].minChar, genericTypeAST.typeArguments.members[i].getLength(), 239 /* Generic_type_references_must_include_all_type_arguments */, null, enclosingDecl, true);
                            typeArg = this.specializeTypeToAny(typeArg, enclosingDecl, context);
                        }

                        typeArgs[i] = context.findSpecializationForType(typeArg);
                    }
                }

                context.doneResolvingTypeArguments();
            }

            var typeParameters = genericTypeSymbol.getTypeParameters();

            if (typeArgs.length && typeArgs.length != typeParameters.length) {
                return SymbolAndDiagnostics.create(this.getNewErrorTypeSymbol(null), [context.postError(this.unitPath, genericTypeAST.minChar, genericTypeAST.getLength(), 159 /* Generic_type__0__requires_1_type_argument_s_ */, [genericTypeSymbol.toString(), genericTypeSymbol.getTypeParameters().length])]);
            }

            var specializedSymbol = TypeScript.specializeType(genericTypeSymbol, typeArgs, this, enclosingDecl, context, genericTypeAST);

            var typeConstraint = null;
            var upperBound = null;
            var diagnostics = null;

            for (var iArg = 0; (iArg < typeArgs.length) && (iArg < typeParameters.length); iArg++) {
                typeArg = typeArgs[iArg];
                typeConstraint = typeParameters[iArg].getConstraint();

                if (typeConstraint) {
                    if (typeConstraint.isTypeParameter()) {
                        for (var j = 0; j < typeParameters.length && j < typeArgs.length; j++) {
                            if (typeParameters[j] == typeConstraint) {
                                typeConstraint = typeArgs[j];
                            }
                        }
                    }

                    if (typeArg.isTypeParameter()) {
                        upperBound = (typeArg).getConstraint();

                        if (upperBound) {
                            typeArg = upperBound;
                        }
                    }

                    if (typeArg.isResolving()) {
                        return SymbolAndDiagnostics.fromSymbol(specializedSymbol);
                    }
                    if (!this.sourceIsAssignableToTarget(typeArg, typeConstraint, context)) {
                        diagnostics = this.addDiagnostic(diagnostics, context.postError(this.unitPath, genericTypeAST.minChar, genericTypeAST.getLength(), 155 /* Type__0__does_not_satisfy_the_constraint__1__for_type_parameter__2_ */, [typeArg.toString(true), typeConstraint.toString(true), typeParameters[iArg].toString(true)]));
                    }
                }
            }

            return SymbolAndDiagnostics.create(specializedSymbol, diagnostics);
        };

        PullTypeResolver.prototype.resolveDottedTypeNameExpression = function (dottedNameAST, enclosingDecl, context) {
            var symbolAndDiagnostics = this.getSymbolAndDiagnosticsForAST(dottedNameAST);
            if (!symbolAndDiagnostics) {
                symbolAndDiagnostics = this.computeDottedTypeNameExpression(dottedNameAST, enclosingDecl, context);
                this.setSymbolAndDiagnosticsForAST(dottedNameAST, symbolAndDiagnostics, context);
            }

            var symbol = symbolAndDiagnostics.symbol;
            if (!symbol.isResolved()) {
                this.resolveDeclaredSymbol(symbol, enclosingDecl, context);
            }

            return symbolAndDiagnostics;
        };

        PullTypeResolver.prototype.computeDottedTypeNameExpression = function (dottedNameAST, enclosingDecl, context) {
            if ((dottedNameAST.operand2).isMissing()) {
                return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.anyTypeSymbol);
            }

            var rhsName = (dottedNameAST.operand2).text;

            var savedResolvingTypeReference = context.resolvingTypeReference;
            var savedResolvingNamespaceMemberAccess = context.resolvingNamespaceMemberAccess;
            context.resolvingNamespaceMemberAccess = true;
            context.resolvingTypeReference = true;
            var lhs = this.resolveAST(dottedNameAST.operand1, false, enclosingDecl, context).symbol;
            context.resolvingTypeReference = savedResolvingTypeReference;
            context.resolvingNamespaceMemberAccess = savedResolvingNamespaceMemberAccess;

            var lhsType = lhs.getType();

            if (context.isResolvingClassExtendedType) {
                if (lhs.isAlias()) {
                    (lhs).setIsUsedAsValue();
                }
            }

            if (this.isAnyOrEquivalent(lhsType)) {
                return SymbolAndDiagnostics.fromSymbol(lhsType);
            }

            if (!lhsType) {
                return SymbolAndDiagnostics.create(this.getNewErrorTypeSymbol(null), [context.postError(this.unitPath, dottedNameAST.operand2.minChar, dottedNameAST.operand2.getLength(), 162 /* Could_not_find_enclosing_symbol_for_dotted_name__0_ */, [(dottedNameAST.operand2).actualText])]);
            }

            var childTypeSymbol = this.getMemberSymbol(rhsName, TypeScript.PullElementKind.SomeType, lhsType);

            if (!childTypeSymbol && lhsType.isContainer()) {
                var exportedContainer = (lhsType).getExportAssignedContainerSymbol();

                if (exportedContainer) {
                    childTypeSymbol = this.getMemberSymbol(rhsName, TypeScript.PullElementKind.SomeType, exportedContainer);
                }
            }

            if (!childTypeSymbol && enclosingDecl) {
                var parentDecl = enclosingDecl;

                while (parentDecl) {
                    if (parentDecl.getKind() & TypeScript.PullElementKind.SomeContainer) {
                        break;
                    }

                    parentDecl = parentDecl.getParentDecl();
                }

                if (parentDecl) {
                    var enclosingSymbolType = parentDecl.getSymbol().getType();

                    if (enclosingSymbolType === lhsType) {
                        childTypeSymbol = this.getMemberSymbol(rhsName, TypeScript.PullElementKind.SomeType, lhsType);
                    }
                }
            }

            if (!childTypeSymbol) {
                return SymbolAndDiagnostics.create(this.getNewErrorTypeSymbol(null, rhsName), [context.postError(this.unitPath, dottedNameAST.operand2.minChar, dottedNameAST.operand2.getLength(), 163 /* The_property__0__does_not_exist_on_value_of_type__1__ */, [(dottedNameAST.operand2).actualText, lhsType.getName()])]);
            }

            return SymbolAndDiagnostics.fromSymbol(childTypeSymbol);
        };

        PullTypeResolver.prototype.resolveFunctionExpression = function (funcDeclAST, inContextuallyTypedAssignment, enclosingDecl, context) {
            var funcDeclSymbol = null;
            var functionDecl = this.getDeclForAST(funcDeclAST);

            if (functionDecl && functionDecl.hasSymbol()) {
                funcDeclSymbol = functionDecl.getSymbol();
                if (funcDeclSymbol.isResolved()) {
                    return funcDeclSymbol;
                }
            }

            var shouldContextuallyType = inContextuallyTypedAssignment;

            var assigningFunctionTypeSymbol = null;
            var assigningFunctionSignature = null;

            if (funcDeclAST.returnTypeAnnotation) {
                shouldContextuallyType = false;
            }

            if (shouldContextuallyType && funcDeclAST.arguments) {
                for (var i = 0; i < funcDeclAST.arguments.members.length; i++) {
                    if ((funcDeclAST.arguments.members[i]).typeExpr) {
                        shouldContextuallyType = false;
                        break;
                    }
                }
            }

            if (shouldContextuallyType) {
                assigningFunctionTypeSymbol = context.getContextualType();

                if (assigningFunctionTypeSymbol) {
                    this.resolveDeclaredSymbol(assigningFunctionTypeSymbol, enclosingDecl, context);

                    if (assigningFunctionTypeSymbol) {
                        assigningFunctionSignature = assigningFunctionTypeSymbol.getCallSignatures()[0];
                    }
                }
            }

            var semanticInfo = this.semanticInfoChain.getUnit(this.unitPath);
            var declCollectionContext = new TypeScript.DeclCollectionContext(semanticInfo);

            declCollectionContext.scriptName = this.unitPath;

            if (enclosingDecl) {
                declCollectionContext.pushParent(enclosingDecl);
            }

            TypeScript.getAstWalkerFactory().walk(funcDeclAST, TypeScript.preCollectDecls, TypeScript.postCollectDecls, null, declCollectionContext);

            var functionDecl = this.getDeclForAST(funcDeclAST);
            this.currentUnit.addSynthesizedDecl(functionDecl);

            var binder = new TypeScript.PullSymbolBinder(this.semanticInfoChain);
            binder.setUnit(this.unitPath);
            binder.bindFunctionExpressionToPullSymbol(functionDecl);

            funcDeclSymbol = functionDecl.getSymbol();

            var signature = funcDeclSymbol.getType().getCallSignatures()[0];

            if (funcDeclAST.arguments) {
                var contextParams = [];
                var contextParam = null;

                if (assigningFunctionSignature) {
                    contextParams = assigningFunctionSignature.getParameters();
                }

                for (var i = 0; i < funcDeclAST.arguments.members.length; i++) {
                    if ((i < contextParams.length) && !contextParams[i].getIsVarArg()) {
                        contextParam = contextParams[i];
                    } else if (contextParams.length && contextParams[contextParams.length - 1].getIsVarArg()) {
                        contextParam = (contextParams[contextParams.length - 1].getType()).getElementType();
                    }

                    this.resolveFunctionExpressionParameter(funcDeclAST.arguments.members[i], contextParam, functionDecl, context);
                }
            }

            if (funcDeclAST.returnTypeAnnotation) {
                var returnTypeSymbol = this.resolveTypeReference(funcDeclAST.returnTypeAnnotation, functionDecl, context).symbol;

                signature.setReturnType(returnTypeSymbol);
            } else {
                if (assigningFunctionSignature) {
                    var returnType = assigningFunctionSignature.getReturnType();

                    if (returnType) {
                        context.pushContextualType(returnType, context.inProvisionalResolution(), null);

                        this.resolveFunctionBodyReturnTypes(funcDeclAST, signature, true, functionDecl, context);
                        context.popContextualType();
                    } else {
                        signature.setReturnType(this.semanticInfoChain.anyTypeSymbol);
                    }
                } else {
                    this.resolveFunctionBodyReturnTypes(funcDeclAST, signature, false, functionDecl, context);
                }
            }

            if (assigningFunctionTypeSymbol) {
                funcDeclSymbol.addOutgoingLink(assigningFunctionTypeSymbol, 1 /* ContextuallyTypedAs */);
            }

            funcDeclSymbol.setResolved();

            return funcDeclSymbol;
        };

        PullTypeResolver.prototype.resolveThisExpression = function (ast, enclosingDecl, context) {
            var symbolAndDiagnostics = this.getSymbolAndDiagnosticsForAST(ast);

            if (!symbolAndDiagnostics) {
                symbolAndDiagnostics = this.computeThisExpressionSymbol(ast, enclosingDecl, context);
                this.setSymbolAndDiagnosticsForAST(ast, symbolAndDiagnostics, context);
            }

            return symbolAndDiagnostics;
        };

        PullTypeResolver.prototype.computeThisExpressionSymbol = function (ast, enclosingDecl, context) {
            if (enclosingDecl) {
                var enclosingDeclKind = enclosingDecl.getKind();
                var diagnostics;

                if (enclosingDeclKind === 4 /* Container */) {
                    return SymbolAndDiagnostics.create(this.getNewErrorTypeSymbol(null), [context.postError(this.currentUnit.getPath(), ast.minChar, ast.getLength(), 176 /* _this__cannot_be_referenced_within_module_bodies */)]);
                } else if (!(enclosingDeclKind & (TypeScript.PullElementKind.SomeFunction | 1 /* Script */ | TypeScript.PullElementKind.SomeBlock))) {
                    return SymbolAndDiagnostics.create(this.getNewErrorTypeSymbol(null), [context.postError(this.currentUnit.getPath(), ast.minChar, ast.getLength(), 177 /* _this__must_only_be_used_inside_a_function_or_script_context */)]);
                } else {
                    var declPath = TypeScript.getPathToDecl(enclosingDecl);

                    if (declPath.length) {
                        for (var i = declPath.length - 1; i >= 0; i--) {
                            var decl = declPath[i];
                            var declKind = decl.getKind();
                            var declFlags = decl.getFlags();

                            if (declFlags & 16 /* Static */) {
                                break;
                            } else if (declKind === 131072 /* FunctionExpression */ && !TypeScript.hasFlag(declFlags, 8192 /* FatArrow */)) {
                                break;
                            } else if (declKind === 16384 /* Function */) {
                                break;
                            } else if (declKind === 8 /* Class */) {
                                var classSymbol = decl.getSymbol();
                                return SymbolAndDiagnostics.fromSymbol(classSymbol);
                            }
                        }
                    }
                }
            }

            return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.anyTypeSymbol);
        };

        PullTypeResolver.prototype.resolveSuperExpression = function (ast, enclosingDecl, context) {
            if (!enclosingDecl) {
                return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.anyTypeSymbol);
            }

            var declPath = enclosingDecl !== null ? TypeScript.getPathToDecl(enclosingDecl) : [];
            var classSymbol = null;

            if (declPath.length) {
                for (var i = declPath.length - 1; i >= 0; i--) {
                    var decl = declPath[i];
                    var declFlags = decl.getFlags();

                    if (decl.getKind() === 131072 /* FunctionExpression */ && !(declFlags & 8192 /* FatArrow */)) {
                        break;
                    } else if (declFlags & 16 /* Static */) {
                        break;
                    } else if (decl.getKind() === 8 /* Class */) {
                        classSymbol = decl.getSymbol();

                        break;
                    }
                }
            }

            if (classSymbol) {
                if (!classSymbol.isResolved()) {
                    this.resolveDeclaredSymbol(classSymbol, enclosingDecl, context);
                }

                var parents = classSymbol.getExtendedTypes();

                if (parents.length) {
                    return SymbolAndDiagnostics.fromSymbol(parents[0]);
                }
            }

            return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.anyTypeSymbol);
        };

        PullTypeResolver.prototype.resolveObjectLiteralExpression = function (expressionAST, inContextuallyTypedAssignment, enclosingDecl, context, additionalResults) {
            var symbolAndDiagnostics = this.getSymbolAndDiagnosticsForAST(expressionAST);

            if (!symbolAndDiagnostics || additionalResults) {
                symbolAndDiagnostics = this.computeObjectLiteralExpression(expressionAST, inContextuallyTypedAssignment, enclosingDecl, context, additionalResults);
                this.setSymbolAndDiagnosticsForAST(expressionAST, symbolAndDiagnostics, context);
            }

            return symbolAndDiagnostics;
        };

        PullTypeResolver.prototype.computeObjectLiteralExpression = function (expressionAST, inContextuallyTypedAssignment, enclosingDecl, context, additionalResults) {
            var objectLitAST = expressionAST;
            var span = TypeScript.TextSpan.fromBounds(objectLitAST.minChar, objectLitAST.limChar);

            var objectLitDecl = new TypeScript.PullDecl("", "", 512 /* ObjectLiteral */, 0 /* None */, span, this.unitPath);
            this.currentUnit.addSynthesizedDecl(objectLitDecl);

            if (enclosingDecl) {
                objectLitDecl.setParentDecl(enclosingDecl);
            }

            this.currentUnit.setDeclForAST(objectLitAST, objectLitDecl);
            this.currentUnit.setASTForDecl(objectLitDecl, objectLitAST);

            var typeSymbol = new TypeScript.PullTypeSymbol("", 16 /* Interface */);
            typeSymbol.addDeclaration(objectLitDecl);
            objectLitDecl.setSymbol(typeSymbol);

            var memberDecls = objectLitAST.operand;

            var contextualType = null;

            if (inContextuallyTypedAssignment) {
                contextualType = context.getContextualType();

                this.resolveDeclaredSymbol(contextualType, enclosingDecl, context);
            }

            if (memberDecls) {
                var binex;
                var memberSymbol;
                var assigningSymbol = null;
                var acceptedContextualType = false;

                if (additionalResults) {
                    additionalResults.membersContextTypeSymbols = [];
                }

                for (var i = 0, len = memberDecls.members.length; i < len; i++) {
                    binex = memberDecls.members[i];

                    var id = binex.operand1;
                    var text;
                    var actualText;

                    if (id.nodeType === 20 /* Name */) {
                        actualText = (id).actualText;
                        text = (id).text;
                    } else if (id.nodeType === 5 /* StringLiteral */) {
                        actualText = (id).actualText;
                        text = (id).text;
                    } else {
                        return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.anyTypeSymbol);
                    }

                    span = TypeScript.TextSpan.fromBounds(binex.minChar, binex.limChar);

                    var decl = new TypeScript.PullDecl(text, actualText, 4096 /* Property */, 4 /* Public */, span, this.unitPath);
                    this.currentUnit.addSynthesizedDecl(decl);

                    objectLitDecl.addChildDecl(decl);
                    decl.setParentDecl(objectLitDecl);

                    this.semanticInfoChain.getUnit(this.unitPath).setDeclForAST(binex, decl);
                    this.semanticInfoChain.getUnit(this.unitPath).setASTForDecl(decl, binex);

                    memberSymbol = new TypeScript.PullSymbol(text, 4096 /* Property */);

                    memberSymbol.addDeclaration(decl);
                    decl.setSymbol(memberSymbol);

                    if (contextualType) {
                        assigningSymbol = this.getMemberSymbol(text, TypeScript.PullElementKind.SomeValue, contextualType);

                        if (assigningSymbol) {
                            this.resolveDeclaredSymbol(assigningSymbol, enclosingDecl, context);

                            context.pushContextualType(assigningSymbol.getType(), context.inProvisionalResolution(), null);

                            acceptedContextualType = true;

                            if (additionalResults) {
                                additionalResults.membersContextTypeSymbols[i] = assigningSymbol.getType();
                            }
                        }
                    }

                    if (binex.operand2.nodeType === 12 /* FunctionDeclaration */) {
                        var funcDeclAST = binex.operand2;

                        if (funcDeclAST.isAccessor()) {
                            var semanticInfo = this.semanticInfoChain.getUnit(this.unitPath);
                            var declCollectionContext = new TypeScript.DeclCollectionContext(semanticInfo);

                            declCollectionContext.scriptName = this.unitPath;

                            declCollectionContext.pushParent(objectLitDecl);

                            TypeScript.getAstWalkerFactory().walk(funcDeclAST, TypeScript.preCollectDecls, TypeScript.postCollectDecls, null, declCollectionContext);

                            var functionDecl = this.getDeclForAST(funcDeclAST);
                            this.currentUnit.addSynthesizedDecl(functionDecl);

                            var binder = new TypeScript.PullSymbolBinder(this.semanticInfoChain);
                            binder.setUnit(this.unitPath);

                            if (funcDeclAST.isGetAccessor()) {
                                binder.bindGetAccessorDeclarationToPullSymbol(functionDecl);
                            } else {
                                binder.bindSetAccessorDeclarationToPullSymbol(functionDecl);
                            }
                        }
                    }

                    var memberExprType = this.resolveAST(binex.operand2, assigningSymbol != null, enclosingDecl, context).symbol;

                    if (acceptedContextualType) {
                        context.popContextualType();
                        acceptedContextualType = false;
                    }

                    context.setTypeInContext(memberSymbol, memberExprType.getType());

                    memberSymbol.setResolved();

                    this.setSymbolAndDiagnosticsForAST(binex.operand1, SymbolAndDiagnostics.fromSymbol(memberSymbol), context);

                    typeSymbol.addMember(memberSymbol, 5 /* PublicMember */);
                }
            }

            typeSymbol.setResolved();
            return SymbolAndDiagnostics.fromSymbol(typeSymbol);
        };

        PullTypeResolver.prototype.resolveArrayLiteralExpression = function (arrayLit, inContextuallyTypedAssignment, enclosingDecl, context) {
            var symbolAndDiagnostics = this.getSymbolAndDiagnosticsForAST(arrayLit);
            if (!symbolAndDiagnostics) {
                symbolAndDiagnostics = this.computeArrayLiteralExpressionSymbol(arrayLit, inContextuallyTypedAssignment, enclosingDecl, context);
                this.setSymbolAndDiagnosticsForAST(arrayLit, symbolAndDiagnostics, context);
            }

            return symbolAndDiagnostics;
        };

        PullTypeResolver.prototype.computeArrayLiteralExpressionSymbol = function (arrayLit, inContextuallyTypedAssignment, enclosingDecl, context) {
            var elements = arrayLit.operand;
            var elementType = this.semanticInfoChain.anyTypeSymbol;
            var elementTypes = [];
            var comparisonInfo = new TypeScript.TypeComparisonInfo();
            var contextualElementType = null;
            comparisonInfo.onlyCaptureFirstError = true;

            if (inContextuallyTypedAssignment) {
                var contextualType = context.getContextualType();

                this.resolveDeclaredSymbol(contextualType, enclosingDecl, context);

                if (contextualType && contextualType.isArray()) {
                    contextualElementType = contextualType.getElementType();
                }
            }

            if (elements) {
                if (inContextuallyTypedAssignment) {
                    context.pushContextualType(contextualElementType, context.inProvisionalResolution(), null);
                }

                for (var i = 0; i < elements.members.length; i++) {
                    elementTypes[elementTypes.length] = this.resolveAST(elements.members[i], inContextuallyTypedAssignment, enclosingDecl, context).symbol.getType();
                }

                if (inContextuallyTypedAssignment) {
                    context.popContextualType();
                }
            }

            if (contextualElementType && !contextualElementType.isTypeParameter()) {
                elementType = contextualElementType;

                for (var i = 0; i < elementTypes.length; i++) {
                    var comparisonInfo = new TypeScript.TypeComparisonInfo();
                    var currentElementType = elementTypes[i];
                    var currentElementAST = elements.members[i];
                    if (!this.sourceIsAssignableToTarget(currentElementType, contextualElementType, context, comparisonInfo)) {
                        var message;
                        if (comparisonInfo.message) {
                            message = context.postError(this.getUnitPath(), currentElementAST.minChar, currentElementAST.getLength(), 81 /* Cannot_convert__0__to__1__NL__2 */, [currentElementType.toString(), contextualElementType.toString(), comparisonInfo.message]);
                        } else {
                            message = context.postError(this.getUnitPath(), currentElementAST.minChar, currentElementAST.getLength(), 80 /* Cannot_convert__0__to__1_ */, [currentElementType.toString(), contextualElementType.toString()]);
                        }

                        return SymbolAndDiagnostics.create(this.getNewErrorTypeSymbol(null), [message]);
                    }
                }
            } else {
                if (elementTypes.length) {
                    elementType = elementTypes[0];
                } else if (contextualElementType) {
                    elementType = contextualElementType;
                }

                var collection = {
                    getLength: function () {
                        return elements.members.length;
                    },
                    setTypeAtIndex: function (index, type) {
                        elementTypes[index] = type;
                    },
                    getTypeAtIndex: function (index) {
                        return elementTypes[index];
                    }
                };

                elementType = this.findBestCommonType(elementType, null, collection, context, comparisonInfo);

                if (elementType === this.semanticInfoChain.undefinedTypeSymbol || elementType === this.semanticInfoChain.nullTypeSymbol) {
                    elementType = this.semanticInfoChain.anyTypeSymbol;
                }

                if (!elementType) {
                    elementType = this.semanticInfoChain.anyTypeSymbol;
                } else if (contextualType && !contextualType.isTypeParameter()) {
                    if (this.sourceIsAssignableToTarget(elementType, contextualType, context)) {
                        elementType = contextualType;
                    }
                }
            }

            var arraySymbol = elementType.getArrayType();

            if (!arraySymbol) {
                if (!this.cachedArrayInterfaceType().isResolved()) {
                    this.resolveDeclaredSymbol(this.cachedArrayInterfaceType(), enclosingDecl, context);
                }

                arraySymbol = TypeScript.specializeToArrayType(this.semanticInfoChain.elementTypeSymbol, elementType, this, context);

                if (!arraySymbol) {
                    arraySymbol = this.semanticInfoChain.anyTypeSymbol;
                }
            }

            return SymbolAndDiagnostics.fromSymbol(arraySymbol);
        };

        PullTypeResolver.prototype.resolveIndexExpression = function (callEx, inContextuallyTypedAssignment, enclosingDecl, context) {
            var symbolAndDiagnostics = this.getSymbolAndDiagnosticsForAST(callEx);
            if (!symbolAndDiagnostics) {
                symbolAndDiagnostics = this.computeIndexExpressionSymbol(callEx, inContextuallyTypedAssignment, enclosingDecl, context);
                this.setSymbolAndDiagnosticsForAST(callEx, symbolAndDiagnostics, context);
            }

            return symbolAndDiagnostics;
        };

        PullTypeResolver.prototype.computeIndexExpressionSymbol = function (callEx, inContextuallyTypedAssignment, enclosingDecl, context) {
            var targetSymbol = this.resolveAST(callEx.operand1, inContextuallyTypedAssignment, enclosingDecl, context).symbol;

            var targetTypeSymbol = targetSymbol.getType();

            if (this.isAnyOrEquivalent(targetTypeSymbol)) {
                return SymbolAndDiagnostics.fromSymbol(targetTypeSymbol);
            }

            var elementType = targetTypeSymbol.getElementType();

            var indexType = this.resolveAST(callEx.operand2, inContextuallyTypedAssignment, enclosingDecl, context).symbol.getType();

            var isNumberIndex = indexType === this.semanticInfoChain.numberTypeSymbol || TypeScript.PullHelpers.symbolIsEnum(indexType);

            if (elementType && isNumberIndex) {
                return SymbolAndDiagnostics.fromSymbol(elementType);
            }

            if (callEx.operand2.nodeType === 5 /* StringLiteral */ || callEx.operand2.nodeType === 7 /* NumericLiteral */) {
                var memberName = callEx.operand2.nodeType === 5 /* StringLiteral */ ? TypeScript.stripQuotes((callEx.operand2).actualText) : TypeScript.quoteStr((callEx.operand2).value.toString());

                var member = this.getMemberSymbol(memberName, TypeScript.PullElementKind.SomeValue, targetTypeSymbol);

                if (member) {
                    return SymbolAndDiagnostics.fromSymbol(member.getType());
                }
            }

            var signatures = targetTypeSymbol.getIndexSignatures();

            var stringSignature = null;
            var numberSignature = null;
            var signature = null;
            var paramSymbols;
            var paramType;

            for (var i = 0; i < signatures.length; i++) {
                if (stringSignature && numberSignature) {
                    break;
                }

                signature = signatures[i];

                paramSymbols = signature.getParameters();

                if (paramSymbols.length) {
                    paramType = paramSymbols[0].getType();

                    if (paramType === this.semanticInfoChain.stringTypeSymbol) {
                        stringSignature = signatures[i];
                        continue;
                    } else if (paramType === this.semanticInfoChain.numberTypeSymbol || paramType.getKind() === 64 /* Enum */) {
                        numberSignature = signatures[i];
                        continue;
                    }
                }
            }

            if (numberSignature && (isNumberIndex || indexType === this.semanticInfoChain.anyTypeSymbol)) {
                var returnType = numberSignature.getReturnType();

                if (!returnType) {
                    returnType = this.semanticInfoChain.anyTypeSymbol;
                }

                return SymbolAndDiagnostics.fromSymbol(returnType);
            } else if (stringSignature && (isNumberIndex || indexType === this.semanticInfoChain.anyTypeSymbol || indexType === this.semanticInfoChain.stringTypeSymbol)) {
                var returnType = stringSignature.getReturnType();

                if (!returnType) {
                    returnType = this.semanticInfoChain.anyTypeSymbol;
                }

                return SymbolAndDiagnostics.fromSymbol(returnType);
            } else if (isNumberIndex || indexType === this.semanticInfoChain.anyTypeSymbol || indexType === this.semanticInfoChain.stringTypeSymbol) {
                var returnType = this.semanticInfoChain.anyTypeSymbol;
                return SymbolAndDiagnostics.fromSymbol(returnType);
            } else {
                return SymbolAndDiagnostics.create(this.getNewErrorTypeSymbol(null), [context.postError(this.getUnitPath(), callEx.minChar, callEx.getLength(), 77 /* Value_of_type__0__is_not_indexable_by_type__1_ */, [targetTypeSymbol.toString(false), indexType.toString(false)])]);
            }
        };

        PullTypeResolver.prototype.resolveBitwiseOperator = function (expressionAST, inContextuallyTypedAssignment, enclosingDecl, context) {
            var binex = expressionAST;

            var leftType = this.resolveAST(binex.operand1, inContextuallyTypedAssignment, enclosingDecl, context).symbol.getType();
            var rightType = this.resolveAST(binex.operand2, inContextuallyTypedAssignment, enclosingDecl, context).symbol.getType();

            if (this.sourceIsSubtypeOfTarget(leftType, this.semanticInfoChain.numberTypeSymbol, context) && this.sourceIsSubtypeOfTarget(rightType, this.semanticInfoChain.numberTypeSymbol, context)) {
                return this.semanticInfoChain.numberTypeSymbol;
            } else if ((leftType === this.semanticInfoChain.booleanTypeSymbol) && (rightType === this.semanticInfoChain.booleanTypeSymbol)) {
                return this.semanticInfoChain.booleanTypeSymbol;
            } else if (this.isAnyOrEquivalent(leftType)) {
                if ((this.isAnyOrEquivalent(rightType) || (rightType === this.semanticInfoChain.numberTypeSymbol) || (rightType === this.semanticInfoChain.booleanTypeSymbol))) {
                    return this.semanticInfoChain.anyTypeSymbol;
                }
            } else if (this.isAnyOrEquivalent(rightType)) {
                if ((leftType === this.semanticInfoChain.numberTypeSymbol) || (leftType === this.semanticInfoChain.booleanTypeSymbol)) {
                    return this.semanticInfoChain.anyTypeSymbol;
                }
            }

            return this.semanticInfoChain.anyTypeSymbol;
        };

        PullTypeResolver.prototype.resolveArithmeticExpression = function (binex, inContextuallyTypedAssignment, enclosingDecl, context) {
            var leftType = this.resolveAST(binex.operand1, inContextuallyTypedAssignment, enclosingDecl, context).symbol.getType();
            var rightType = this.resolveAST(binex.operand2, inContextuallyTypedAssignment, enclosingDecl, context).symbol.getType();

            if (this.isNullOrUndefinedType(leftType)) {
                leftType = rightType;
            }
            if (this.isNullOrUndefinedType(rightType)) {
                rightType = leftType;
            }

            leftType = this.widenType(leftType);
            rightType = this.widenType(rightType);

            if (binex.nodeType === 64 /* AddExpression */ || binex.nodeType === 39 /* AddAssignmentExpression */) {
                if (leftType === this.semanticInfoChain.stringTypeSymbol || rightType === this.semanticInfoChain.stringTypeSymbol) {
                    return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.stringTypeSymbol);
                } else if (leftType === this.semanticInfoChain.numberTypeSymbol && rightType === this.semanticInfoChain.numberTypeSymbol) {
                    return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.numberTypeSymbol);
                } else if (this.sourceIsSubtypeOfTarget(leftType, this.semanticInfoChain.numberTypeSymbol, context) && this.sourceIsSubtypeOfTarget(rightType, this.semanticInfoChain.numberTypeSymbol, context)) {
                    return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.numberTypeSymbol);
                } else {
                    return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.anyTypeSymbol);
                }
            } else {
                if (leftType === this.semanticInfoChain.numberTypeSymbol && rightType === this.semanticInfoChain.numberTypeSymbol) {
                    return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.numberTypeSymbol);
                } else if (this.sourceIsSubtypeOfTarget(leftType, this.semanticInfoChain.numberTypeSymbol, context) && this.sourceIsSubtypeOfTarget(rightType, this.semanticInfoChain.numberTypeSymbol, context)) {
                    return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.numberTypeSymbol);
                } else if (this.isAnyOrEquivalent(leftType) || this.isAnyOrEquivalent(rightType)) {
                    return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.numberTypeSymbol);
                } else {
                    return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.anyTypeSymbol);
                }
            }
        };

        PullTypeResolver.prototype.resolveLogicalOrExpression = function (binex, inContextuallyTypedAssignment, enclosingDecl, context) {
            var symbolAndDiagnostics = this.getSymbolAndDiagnosticsForAST(binex);
            if (!symbolAndDiagnostics) {
                symbolAndDiagnostics = this.computeLogicalOrExpressionSymbol(binex, inContextuallyTypedAssignment, enclosingDecl, context);
                this.setSymbolAndDiagnosticsForAST(binex, symbolAndDiagnostics, context);
            }

            return symbolAndDiagnostics;
        };

        PullTypeResolver.prototype.computeLogicalOrExpressionSymbol = function (binex, inContextuallyTypedAssignment, enclosingDecl, context) {
            var leftType = this.resolveAST(binex.operand1, inContextuallyTypedAssignment, enclosingDecl, context).symbol.getType();
            var rightType = this.resolveAST(binex.operand2, inContextuallyTypedAssignment, enclosingDecl, context).symbol.getType();

            if (this.isAnyOrEquivalent(leftType) || this.isAnyOrEquivalent(rightType)) {
                return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.anyTypeSymbol);
            } else if (leftType === this.semanticInfoChain.booleanTypeSymbol) {
                if (rightType === this.semanticInfoChain.booleanTypeSymbol) {
                    return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.booleanTypeSymbol);
                } else {
                    return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.anyTypeSymbol);
                }
            } else if (leftType === this.semanticInfoChain.numberTypeSymbol) {
                if (rightType === this.semanticInfoChain.numberTypeSymbol) {
                    return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.numberTypeSymbol);
                } else {
                    return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.anyTypeSymbol);
                }
            } else if (leftType === this.semanticInfoChain.stringTypeSymbol) {
                if (rightType === this.semanticInfoChain.stringTypeSymbol) {
                    return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.stringTypeSymbol);
                } else {
                    return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.anyTypeSymbol);
                }
            } else if (this.sourceIsSubtypeOfTarget(leftType, rightType, context)) {
                return SymbolAndDiagnostics.fromSymbol(rightType);
            } else if (this.sourceIsSubtypeOfTarget(rightType, leftType, context)) {
                return SymbolAndDiagnostics.fromSymbol(leftType);
            }

            return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.anyTypeSymbol);
        };

        PullTypeResolver.prototype.resolveLogicalAndExpression = function (binex, inContextuallyTypedAssignment, enclosingDecl, context) {
            return SymbolAndDiagnostics.fromSymbol(this.resolveAST(binex.operand2, inContextuallyTypedAssignment, enclosingDecl, context).symbol.getType());
        };

        PullTypeResolver.prototype.resolveConditionalExpression = function (trinex, enclosingDecl, context) {
            var symbolAndDiagnostics = this.getSymbolAndDiagnosticsForAST(trinex);
            if (!symbolAndDiagnostics) {
                symbolAndDiagnostics = this.computeConditionalExpressionSymbol(trinex, enclosingDecl, context);
                this.setSymbolAndDiagnosticsForAST(trinex, symbolAndDiagnostics, context);
            }

            return symbolAndDiagnostics;
        };

        PullTypeResolver.prototype.computeConditionalExpressionSymbol = function (trinex, enclosingDecl, context) {
            var leftType = this.resolveAST(trinex.operand2, false, enclosingDecl, context).symbol.getType();
            var rightType = this.resolveAST(trinex.operand3, false, enclosingDecl, context).symbol.getType();

            var symbol = null;
            if (this.typesAreIdentical(leftType, rightType)) {
                symbol = leftType;
            } else if (this.sourceIsSubtypeOfTarget(leftType, rightType, context) || this.sourceIsSubtypeOfTarget(rightType, leftType, context)) {
                var collection = {
                    getLength: function () {
                        return 2;
                    },
                    setTypeAtIndex: function (index, type) {
                    },
                    getTypeAtIndex: function (index) {
                        return rightType;
                    }
                };

                var bestCommonType = this.findBestCommonType(leftType, null, collection, context);

                if (bestCommonType) {
                    symbol = bestCommonType;
                }
            }

            if (!symbol) {
                return SymbolAndDiagnostics.create(this.getNewErrorTypeSymbol(null), [context.postError(this.getUnitPath(), trinex.minChar, trinex.getLength(), 160 /* Type_of_conditional_expression_cannot_be_determined__Best_common_type_could_not_be_found_between__0__and__1_ */, [leftType.toString(false), rightType.toString(false)])]);
            }

            return SymbolAndDiagnostics.fromSymbol(symbol);
        };

        PullTypeResolver.prototype.resolveParenthesizedExpression = function (ast, enclosingDecl, context) {
            return this.resolveAST(ast.expression, false, enclosingDecl, context).withoutDiagnostics();
        };

        PullTypeResolver.prototype.resolveExpressionStatement = function (ast, inContextuallyTypedAssignment, enclosingDecl, context) {
            return this.resolveAST(ast.expression, inContextuallyTypedAssignment, enclosingDecl, context).withoutDiagnostics();
        };

        PullTypeResolver.prototype.resolveCallExpression = function (callEx, inContextuallyTypedAssignment, enclosingDecl, context, additionalResults) {
            if (additionalResults) {
                return this.computeCallExpressionSymbol(callEx, inContextuallyTypedAssignment, enclosingDecl, context, additionalResults);
            }

            var symbolAndDiagnostics = this.getSymbolAndDiagnosticsForAST(callEx);
            if (!symbolAndDiagnostics || !symbolAndDiagnostics.symbol.isResolved()) {
                symbolAndDiagnostics = this.computeCallExpressionSymbol(callEx, inContextuallyTypedAssignment, enclosingDecl, context, null);
                this.setSymbolAndDiagnosticsForAST(callEx, symbolAndDiagnostics, context);
            }

            return symbolAndDiagnostics;
        };

        PullTypeResolver.prototype.computeCallExpressionSymbol = function (callEx, inContextuallyTypedAssignment, enclosingDecl, context, additionalResults) {
            var targetSymbol = this.resolveAST(callEx.target, inContextuallyTypedAssignment, enclosingDecl, context).symbol;
            var targetAST = this.getLastIdentifierInTarget(callEx);

            var targetTypeSymbol = targetSymbol.getType();
            if (this.isAnyOrEquivalent(targetTypeSymbol)) {
                if (callEx.typeArguments) {
                    return SymbolAndDiagnostics.create(this.getNewErrorTypeSymbol(null), [context.postError(this.unitPath, targetAST.minChar, targetAST.getLength(), 223 /* Untyped_function_calls_may_not_accept_type_arguments */)]);
                }

                return SymbolAndDiagnostics.fromSymbol(this.semanticInfoChain.anyTypeSymbol);
            }

            var diagnostics = [];
            var isSuperCall = false;

            if (callEx.target.nodeType === 30 /* SuperExpression */) {
                isSuperCall = true;

                if (targetTypeSymbol.isClass()) {
                    targetSymbol = (targetTypeSymbol).getConstructorMethod();
                    targetTypeSymbol = targetSymbol.getType();
                } else {
                    diagnostics = this.addDiagnostic(diagnostics, context.postError(this.unitPath, targetAST.minChar, targetAST.getLength(), 158 /* Calls_to__super__are_only_valid_inside_a_class */));
                    return SymbolAndDiagnostics.create(this.getNewErrorTypeSymbol(null), diagnostics);
                }
            }

            var signatures = isSuperCall ? (targetTypeSymbol).getConstructSignatures() : (targetTypeSymbol).getCallSignatures();

            if (!signatures.length && (targetTypeSymbol.getKind() == 33554432 /* ConstructorType */)) {
                diagnostics = this.addDiagnostic(diagnostics, context.postError(this.unitPath, targetAST.minChar, targetAST.getLength(), 227 /* Value_of_type__0__is_not_callable__Did_you_mean_to_include__new___ */, [targetTypeSymbol.toString()]));
            }

            var typeArgs = null;
            var typeReplacementMap = null;
            var couldNotFindGenericOverload = false;
            var couldNotAssignToConstraint;

            if (callEx.typeArguments) {
                typeArgs = [];

                if (callEx.typeArguments && callEx.typeArguments.members.length) {
                    for (var i = 0; i < callEx.typeArguments.members.length; i++) {
                        var typeArg = this.resolveTypeReference(callEx.typeArguments.members[i], enclosingDecl, context).symbol;
                        typeArgs[i] = context.findSpecializationForType(typeArg);
                    }
                }
            } else if (isSuperCall && targetTypeSymbol.isGeneric()) {
                typeArgs = targetTypeSymbol.getTypeArguments();
            }

            if (targetTypeSymbol.isGeneric()) {
                var resolvedSignatures = [];
                var inferredTypeArgs;
                var specializedSignature;
                var typeParameters;
                var typeConstraint = null;
                var prevSpecializingToAny = context.specializingToAny;
                var prevSpecializing = context.isSpecializingSignatureAtCallSite;
                var beforeResolutionSignatures = signatures;
                var triedToInferTypeArgs;

                for (var i = 0; i < signatures.length; i++) {
                    typeParameters = signatures[i].getTypeParameters();
                    couldNotAssignToConstraint = false;
                    triedToInferTypeArgs = false;

                    if (signatures[i].isGeneric() && typeParameters.length && !signatures[i].isFixed()) {
                        if (typeArgs) {
                            inferredTypeArgs = typeArgs;
                        } else if (callEx.arguments) {
                            inferredTypeArgs = this.inferArgumentTypesForSignature(signatures[i], callEx.arguments, new TypeScript.TypeComparisonInfo(), enclosingDecl, context);
                            triedToInferTypeArgs = true;
                        }

                        if (inferredTypeArgs) {
                            typeReplacementMap = {};

                            if (inferredTypeArgs.length) {
                                if (inferredTypeArgs.length != typeParameters.length) {
                                    continue;
                                }

                                for (var j = 0; j < typeParameters.length; j++) {
                                    typeReplacementMap[typeParameters[j].getSymbolID().toString()] = inferredTypeArgs[j];
                                }
                                for (var j = 0; j < typeParameters.length; j++) {
                                    typeConstraint = typeParameters[j].getConstraint();

                                    if (typeConstraint) {
                                        if (typeConstraint.isTypeParameter()) {
                                            for (var k = 0; k < typeParameters.length && k < inferredTypeArgs.length; k++) {
                                                if (typeParameters[k] == typeConstraint) {
                                                    typeConstraint = inferredTypeArgs[k];
                                                }
                                            }
                                        }
                                        if (typeConstraint.isTypeParameter()) {
                                            context.pushTypeSpecializationCache(typeReplacementMap);
                                            typeConstraint = TypeScript.specializeType(typeConstraint, null, this, enclosingDecl, context);
                                            context.popTypeSpecializationCache();
                                        }
                                        context.isComparingSpecializedSignatures = true;
                                        if (!this.sourceIsAssignableToTarget(inferredTypeArgs[j], typeConstraint, context)) {
                                            diagnostics = this.addDiagnostic(diagnostics, context.postError(this.unitPath, targetAST.minChar, targetAST.getLength(), 155 /* Type__0__does_not_satisfy_the_constraint__1__for_type_parameter__2_ */, [inferredTypeArgs[j].toString(true), typeConstraint.toString(true), typeParameters[j].toString(true)]));
                                            couldNotAssignToConstraint = true;
                                        }
                                        context.isComparingSpecializedSignatures = false;

                                        if (couldNotAssignToConstraint) {
                                            break;
                                        }
                                    }
                                }
                            } else {
                                if (triedToInferTypeArgs) {
                                    if (signatures[i].parametersAreFixed()) {
                                        if (signatures[i].hasGenericParameter()) {
                                            context.specializingToAny = true;
                                        } else {
                                            resolvedSignatures[resolvedSignatures.length] = signatures[i];
                                        }
                                    } else {
                                        continue;
                                    }
                                }

                                context.specializingToAny = true;
                            }

                            if (couldNotAssignToConstraint) {
                                continue;
                            }

                            context.isSpecializingSignatureAtCallSite = true;
                            specializedSignature = TypeScript.specializeSignature(signatures[i], false, typeReplacementMap, inferredTypeArgs, this, enclosingDecl, context);

                            context.isSpecializingSignatureAtCallSite = prevSpecializing;
                            context.specializingToAny = prevSpecializingToAny;

                            if (specializedSignature) {
                                resolvedSignatures[resolvedSignatures.length] = specializedSignature;
                            }
                        }
                    } else {
                        if (!(callEx.typeArguments && callEx.typeArguments.members.length)) {
                            resolvedSignatures[resolvedSignatures.length] = signatures[i];
                        }
                    }
                }

                if (signatures.length && !resolvedSignatures.length) {
                    couldNotFindGenericOverload = true;
                }

                signatures = resolvedSignatures;
            }

            var errorCondition = null;

            if (!signatures.length) {
                if (additionalResults) {
                    additionalResults.targetSymbol = targetSymbol;
                    additionalResults.targetTypeSymbol = targetTypeSymbol;
                    additionalResults.resolvedSignatures = beforeResolutionSignatures;
                    additionalResults.candidateSignature = beforeResolutionSignatures && beforeResolutionSignatures.length ? beforeResolutionSignatures[0] : null;

                    additionalResults.actualParametersContextTypeSymbols = actualParametersContextTypeSymbols;
                }

                if (!couldNotFindGenericOverload) {
                    if (this.cachedFunctionInterfaceType() && this.sourceIsSubtypeOfTarget(targetTypeSymbol, this.cachedFunctionInterfaceType(), context)) {
                        return SymbolAndDiagnostics.create(this.semanticInfoChain.anyTypeSymbol, diagnostics);
                    }

                    diagnostics = this.addDiagnostic(diagnostics, context.postError(this.unitPath, callEx.minChar, callEx.getLength(), 157 /* Unable_to_invoke_type_with_no_call_signatures */));
                    errorCondition = this.getNewErrorTypeSymbol(null);
                } else {
                    diagnostics = this.addDiagnostic(diagnostics, context.postError(this.unitPath, callEx.minChar, callEx.getLength(), 156 /* Could_not_select_overload_for__call__expression */));
                    errorCondition = this.getNewErrorTypeSymbol(null);
                }

                return SymbolAndDiagnostics.create(errorCondition, diagnostics);
            }

            var signature = this.resolveOverloads(callEx, signatures, enclosingDecl, callEx.typeArguments != null, context, diagnostics);
            var useBeforeResolutionSignatures = signature == null;

            if (!signature) {
                diagnostics = this.addDiagnostic(diagnostics, context.postError(this.unitPath, targetAST.minChar, targetAST.getLength(), 156 /* Could_not_select_overload_for__call__expression */));

                errorCondition = this.getNewErrorTypeSymbol(null);

                if (!signatures.length) {
                    return SymbolAndDiagnostics.create(errorCondition, diagnostics);
                }

                signature = signatures[0];

                if (callEx.arguments) {
                    for (var k = 0, n = callEx.arguments.members.length; k < n; k++) {
                        var arg = callEx.arguments.members[k];
                        var argSymbolAndDiagnostics = this.getSymbolAndDiagnosticsForAST(arg);
                        var argSymbol = argSymbolAndDiagnostics && argSymbolAndDiagnostics.symbol;

                        if (argSymbol) {
                            var argType = argSymbol.getType();
                            if (arg.nodeType === 12 /* FunctionDeclaration */) {
                                if (!this.canApplyContextualTypeToFunction(argType, arg, true)) {
                                    continue;
                                }
                            }

                            argSymbol.invalidate();
                        }
                    }
                }
            }

            if (!signature.isGeneric() && callEx.typeArguments) {
                diagnostics = this.addDiagnostic(diagnostics, context.postError(this.unitPath, targetAST.minChar, targetAST.getLength(), 224 /* Non_generic_functions_may_not_accept_type_arguments */));
            }

            var returnType = signature.getReturnType();

            var actualParametersContextTypeSymbols = [];
            if (callEx.arguments) {
                var len = callEx.arguments.members.length;
                var params = signature.getParameters();
                var contextualType = null;
                var signatureDecl = signature.getDeclarations()[0];

                for (var i = 0; i < len; i++) {
                    if (params.length) {
                        if (i < params.length - 1 || (i < params.length && !signature.hasVariableParamList())) {
                            if (typeReplacementMap) {
                                context.pushTypeSpecializationCache(typeReplacementMap);
                            }
                            this.resolveDeclaredSymbol(params[i], signatureDecl, context);
                            if (typeReplacementMap) {
                                context.popTypeSpecializationCache();
                            }
                            contextualType = params[i].getType();
                        } else if (signature.hasVariableParamList()) {
                            contextualType = params[params.length - 1].getType();
                            if (contextualType.isArray()) {
                                contextualType = contextualType.getElementType();
                            }
                        }
                    }

                    if (contextualType) {
                        context.pushContextualType(contextualType, context.inProvisionalResolution(), null);
                        actualParametersContextTypeSymbols[i] = contextualType;
                    }

                    this.resolveAST(callEx.arguments.members[i], contextualType != null, enclosingDecl, context);

                    if (contextualType) {
                        context.popContextualType();
                        contextualType = null;
                    }
                }
            }

            if (additionalResults) {
                additionalResults.targetSymbol = targetSymbol;
                additionalResults.targetTypeSymbol = targetTypeSymbol;
                if (useBeforeResolutionSignatures && beforeResolutionSignatures) {
                    additionalResults.resolvedSignatures = beforeResolutionSignatures;
                    additionalResults.candidateSignature = beforeResolutionSignatures[0];
                } else {
                    additionalResults.resolvedSignatures = signatures;
                    additionalResults.candidateSignature = signature;
                }
                additionalResults.actualParametersContextTypeSymbols = actualParametersContextTypeSymbols;
            }

            if (errorCondition) {
                return SymbolAndDiagnostics.create(errorCondition, diagnostics);
            }

            if (!returnType) {
                returnType = this.semanticInfoChain.anyTypeSymbol;
            }

            return SymbolAndDiagnostics.fromSymbol(returnType);
        };

        PullTypeResolver.prototype.resolveNewExpression = function (callEx, inContextuallyTypedAssignment, enclosingDecl, context, additionalResults) {
            if (additionalResults) {
                return this.computeNewExpressionSymbol(callEx, inContextuallyTypedAssignment, enclosingDecl, context, additionalResults);
            }

            var symbolAndDiagnostics = this.getSymbolAndDiagnosticsForAST(callEx);
            if (!symbolAndDiagnostics || !symbolAndDiagnostics.symbol.isResolved()) {
                symbolAndDiagnostics = this.computeNewExpressionSymbol(callEx, inContextuallyTypedAssignment, enclosingDecl, context, null);
                this.setSymbolAndDiagnosticsForAST(callEx, symbolAndDiagnostics, context);
            }

            return symbolAndDiagnostics;
        };

        PullTypeResolver.prototype.computeNewExpressionSymbol = function (callEx, inContextuallyTypedAssignment, enclosingDecl, context, additionalResults) {
            var returnType = null;

            var targetSymbol = this.resolveAST(callEx.target, inContextuallyTypedAssignment, enclosingDecl, context).symbol;
            var targetTypeSymbol = targetSymbol.isType() ? targetSymbol : targetSymbol.getType();

            var targetAST = this.getLastIdentifierInTarget(callEx);

            if (targetTypeSymbol.isClass()) {
                targetTypeSymbol = (targetTypeSymbol).getConstructorMethod().getType();
            }

            var constructSignatures = targetTypeSymbol.getConstructSignatures();

            var typeArgs = null;
            var typeReplacementMap = null;
            var usedCallSignaturesInstead = false;
            var couldNotAssignToConstraint;

            if (this.isAnyOrEquivalent(targetTypeSymbol)) {
                return SymbolAndDiagnostics.fromSymbol(targetTypeSymbol);
            }

            if (!constructSignatures.length) {
                constructSignatures = targetTypeSymbol.getCallSignatures();
                usedCallSignaturesInstead = true;
            }

            var diagnostics = [];
            if (constructSignatures.length) {
                if (callEx.typeArguments) {
                    typeArgs = [];

                    if (callEx.typeArguments && callEx.typeArguments.members.length) {
                        for (var i = 0; i < callEx.typeArguments.members.length; i++) {
                            var typeArg = this.resolveTypeReference(callEx.typeArguments.members[i], enclosingDecl, context).symbol;
                            typeArgs[i] = context.findSpecializationForType(typeArg);
                        }
                    }
                }

                if (targetTypeSymbol.isGeneric()) {
                    var resolvedSignatures = [];
                    var inferredTypeArgs;
                    var specializedSignature;
                    var typeParameters;
                    var typeConstraint = null;
                    var prevSpecializingToAny = context.specializingToAny;
                    var prevIsSpecializing = context.isSpecializingSignatureAtCallSite = true;
                    var triedToInferTypeArgs;

                    for (var i = 0; i < constructSignatures.length; i++) {
                        couldNotAssignToConstraint = false;

                        if (constructSignatures[i].isGeneric() && !constructSignatures[i].isFixed()) {
                            if (typeArgs) {
                                inferredTypeArgs = typeArgs;
                            } else if (callEx.arguments) {
                                inferredTypeArgs = this.inferArgumentTypesForSignature(constructSignatures[i], callEx.arguments, new TypeScript.TypeComparisonInfo(), enclosingDecl, context);
                                triedToInferTypeArgs = true;
                            }

                            if (inferredTypeArgs) {
                                typeParameters = constructSignatures[i].getTypeParameters();

                                typeReplacementMap = {};

                                if (inferredTypeArgs.length) {
                                    if (inferredTypeArgs.length < typeParameters.length) {
                                        continue;
                                    }

                                    for (var j = 0; j < typeParameters.length; j++) {
                                        typeReplacementMap[typeParameters[j].getSymbolID().toString()] = inferredTypeArgs[j];
                                    }
                                    for (var j = 0; j < typeParameters.length; j++) {
                                        typeConstraint = typeParameters[j].getConstraint();

                                        if (typeConstraint) {
                                            if (typeConstraint.isTypeParameter()) {
                                                for (var k = 0; k < typeParameters.length && k < inferredTypeArgs.length; k++) {
                                                    if (typeParameters[k] == typeConstraint) {
                                                        typeConstraint = inferredTypeArgs[k];
                                                    }
                                                }
                                            }
                                            if (typeConstraint.isTypeParameter()) {
                                                context.pushTypeSpecializationCache(typeReplacementMap);
                                                typeConstraint = TypeScript.specializeType(typeConstraint, null, this, enclosingDecl, context);
                                                context.popTypeSpecializationCache();
                                            }

                                            context.isComparingSpecializedSignatures = true;
                                            if (!this.sourceIsAssignableToTarget(inferredTypeArgs[j], typeConstraint, context)) {
                                                diagnostics = this.addDiagnostic(diagnostics, context.postError(this.unitPath, targetAST.minChar, targetAST.getLength(), 155 /* Type__0__does_not_satisfy_the_constraint__1__for_type_parameter__2_ */, [inferredTypeArgs[j].toString(true), typeConstraint.toString(true), typeParameters[j].toString(true)]));
                                                couldNotAssignToConstraint = true;
                                            }
                                            context.isComparingSpecializedSignatures = false;

                                            if (couldNotAssignToConstraint) {
                                                break;
                                            }
                                        }
                                    }
                                } else {
                                    if (triedToInferTypeArgs) {
                                        if (constructSignatures[i].parametersAreFixed()) {
                                            if (constructSignatures[i].hasGenericParameter()) {
                                                context.specializingToAny = true;
                                            } else {
                                                resolvedSignatures[resolvedSignatures.length] = constructSignatures[i];
                                            }
                                        } else {
                                            continue;
                                        }
                                    }

                                    context.specializingToAny = true;
                                }

                                if (couldNotAssignToConstraint) {
                                    continue;
                                }

                                context.isSpecializingSignatureAtCallSite = true;
                                specializedSignature = TypeScript.specializeSignature(constructSignatures[i], false, typeReplacementMap, inferredTypeArgs, this, enclosingDecl, context);

                                context.specializingToAny = prevSpecializingToAny;
                                context.isSpecializingSignatureAtCallSite = prevIsSpecializing;

                                if (specializedSignature) {
                                    resolvedSignatures[resolvedSignatures.length] = specializedSignature;
                                }
                            }
                        } else {
                            if (!(callEx.typeArguments && callEx.typeArguments.members.length)) {
                                resolvedSignatures[resolvedSignatures.length] = constructSignatures[i];
                            }
                        }
                    }

                    constructSignatures = resolvedSignatures;
                }

                var signature = this.resolveOverloads(callEx, constructSignatures, enclosingDecl, callEx.typeArguments != null, context, diagnostics);

                if (additionalResults) {
                    additionalResults.targetSymbol = targetSymbol;
                    additionalResults.targetTypeSymbol = targetTypeSymbol;
                    additionalResults.resolvedSignatures = constructSignatures;
                    additionalResults.candidateSignature = signature;
                    additionalResults.actualParametersContextTypeSymbols = [];
                }

                if (!constructSignatures.length && diagnostics) {
                    var result = this.getNewErrorTypeSymbol(null);
                    return SymbolAndDiagnostics.create(result, diagnostics);
                }

                var errorCondition = null;

                if (!signature) {
                    diagnostics = this.addDiagnostic(diagnostics, context.postError(this.unitPath, targetAST.minChar, targetAST.getLength(), 154 /* Could_not_select_overload_for__new__expression */));

                    errorCondition = this.getNewErrorTypeSymbol(null);

                    if (!constructSignatures.length) {
                        return SymbolAndDiagnostics.create(errorCondition, diagnostics);
                    }

                    signature = constructSignatures[0];

                    if (callEx.arguments) {
                        for (var k = 0, n = callEx.arguments.members.length; k < n; k++) {
                            var arg = callEx.arguments.members[k];
                            var argSymbolAndDiagnostics = this.getSymbolAndDiagnosticsForAST(arg);
                            var argSymbol = argSymbolAndDiagnostics && argSymbolAndDiagnostics.symbol;

                            if (argSymbol) {
                                var argType = argSymbol.getType();
                                if (arg.nodeType === 12 /* FunctionDeclaration */) {
                                    if (!this.canApplyContextualTypeToFunction(argType, arg, true)) {
                                        continue;
                                    }
                                }

                                argSymbol.invalidate();
                            }
                        }
                    }
                }

                returnType = signature.getReturnType();

                if (returnType && !signature.isGeneric() && returnType.isGeneric() && !returnType.getIsSpecialized()) {
                    if (typeArgs && typeArgs.length) {
                        returnType = TypeScript.specializeType(returnType, typeArgs, this, enclosingDecl, context, callEx);
                    } else {
                        returnType = this.specializeTypeToAny(returnType, enclosingDecl, context);
                    }
                }

                if (usedCallSignaturesInstead) {
                    if (returnType != this.semanticInfoChain.voidTypeSymbol) {
                        diagnostics = this.addDiagnostic(diagnostics, context.postError(this.unitPath, targetAST.minChar, targetAST.getLength(), 153 /* Call_signatures_used_in_a__new__expression_must_have_a__void__return_type */));
                        return SymbolAndDiagnostics.create(this.getNewErrorTypeSymbol(null), diagnostics);
                    } else {
                        returnType = this.semanticInfoChain.anyTypeSymbol;
                    }
                }

                if (!returnType) {
                    returnType = signature.getReturnType();

                    if (!returnType) {
                        returnType = targetTypeSymbol;
                    }
                }

                var actualParametersContextTypeSymbols = [];
                if (callEx.arguments) {
                    var len = callEx.arguments.members.length;
                    var params = signature.getParameters();
                    var contextualType = null;
                    var signatureDecl = signature.getDeclarations()[0];

                    for (var i = 0; i < len; i++) {
                        if (params.length) {
                            if (i < params.length - 1 || (i < params.length && !signature.hasVariableParamList())) {
                                if (typeReplacementMap) {
                                    context.pushTypeSpecializationCache(typeReplacementMap);
                                }
                                this.resolveDeclaredSymbol(params[i], signatureDecl, context);
                                if (typeReplacementMap) {
                                    context.popTypeSpecializationCache();
                                }
                                contextualType = params[i].getType();
                            } else if (signature.hasVariableParamList()) {
                                contextualType = params[params.length - 1].getType();
                                if (contextualType.isArray()) {
                                    contextualType = contextualType.getElementType();
                                }
                            }
                        }

                        if (contextualType) {
                            context.pushContextualType(contextualType, context.inProvisionalResolution(), null);
                            actualParametersContextTypeSymbols[i] = contextualType;
                        }

                        this.resolveAST(callEx.arguments.members[i], contextualType != null, enclosingDecl, context);

                        if (contextualType) {
                            context.popContextualType();
                            contextualType = null;
                        }
                    }
                }

                if (additionalResults) {
                    additionalResults.targetSymbol = targetSymbol;
                    additionalResults.targetTypeSymbol = targetTypeSymbol;
                    additionalResults.resolvedSignatures = constructSignatures;
                    additionalResults.candidateSignature = signature;
                    additionalResults.actualParametersContextTypeSymbols = actualParametersContextTypeSymbols;
                }

                if (errorCondition) {
                    return SymbolAndDiagnostics.create(errorCondition, diagnostics);
                }

                if (!returnType) {
                    returnType = this.semanticInfoChain.anyTypeSymbol;
                }

                return SymbolAndDiagnostics.fromSymbol(returnType);
            } else if (targetTypeSymbol.isClass()) {
                return SymbolAndDiagnostics.fromSymbol(returnType);
            }

            diagnostics = this.addDiagnostic(diagnostics, context.postError(this.unitPath, targetAST.minChar, targetAST.getLength(), 152 /* Invalid__new__expression */));

            return SymbolAndDiagnostics.create(this.getNewErrorTypeSymbol(null), diagnostics);
        };

        PullTypeResolver.prototype.resolveTypeAssertionExpression = function (assertionExpression, inContextuallyTypedAssignment, enclosingDecl, context) {
            return this.resolveTypeReference(assertionExpression.castTerm, enclosingDecl, context);
        };

        PullTypeResolver.prototype.resolveAssignmentStatement = function (binex, inContextuallyTypedAssignment, enclosingDecl, context) {
            var symbolAndDiagnostics = this.getSymbolAndDiagnosticsForAST(binex);

            if (!symbolAndDiagnostics) {
                symbolAndDiagnostics = this.computeAssignmentStatementSymbol(binex, inContextuallyTypedAssignment, enclosingDecl, context);
                this.setSymbolAndDiagnosticsForAST(binex, symbolAndDiagnostics, context);
            }

            return symbolAndDiagnostics;
        };

        PullTypeResolver.prototype.computeAssignmentStatementSymbol = function (binex, inContextuallyTypedAssignment, enclosingDecl, context) {
            var leftType = this.resolveAST(binex.operand1, inContextuallyTypedAssignment, enclosingDecl, context).symbol.getType();

            context.pushContextualType(leftType, context.inProvisionalResolution(), null);
            this.resolveAST(binex.operand2, true, enclosingDecl, context);
            context.popContextualType();

            return SymbolAndDiagnostics.fromSymbol(leftType);
        };

        PullTypeResolver.prototype.resolveBoundDecls = function (decl, context) {
            if (!decl) {
                return;
            }

            switch (decl.getKind()) {
                case 1 /* Script */:
                    var childDecls = decl.getChildDecls();
                    for (var i = 0; i < childDecls.length; i++) {
                        this.resolveBoundDecls(childDecls[i], context);
                    }
                    break;
                case 32 /* DynamicModule */:
                case 4 /* Container */:
                case 64 /* Enum */:
                    var moduleDecl = this.semanticInfoChain.getASTForDecl(decl);
                    this.resolveModuleDeclaration(moduleDecl, context);
                    break;
                case 16 /* Interface */:
                    var interfaceDecl = this.semanticInfoChain.getASTForDecl(decl);
                    this.resolveInterfaceDeclaration(interfaceDecl, context);
                    break;
                case 8 /* Class */:
                    var classDecl = this.semanticInfoChain.getASTForDecl(decl);
                    this.resolveClassDeclaration(classDecl, context);
                    break;
                case 65536 /* Method */:
                case 16384 /* Function */:
                    var funcDecl = this.semanticInfoChain.getASTForDecl(decl);
                    this.resolveFunctionDeclaration(funcDecl, context);
                    break;
                case 262144 /* GetAccessor */:
                    funcDecl = this.semanticInfoChain.getASTForDecl(decl);
                    this.resolveGetAccessorDeclaration(funcDecl, context);
                    break;
                case 524288 /* SetAccessor */:
                    funcDecl = this.semanticInfoChain.getASTForDecl(decl);
                    this.resolveSetAccessorDeclaration(funcDecl, context);
                    break;
                case 4096 /* Property */:
                case 1024 /* Variable */:
                case 2048 /* Parameter */:
                    var varDecl = this.semanticInfoChain.getASTForDecl(decl);

                    if (varDecl) {
                        this.resolveVariableDeclaration(varDecl, context);
                    }
                    break;
            }
        };

        PullTypeResolver.prototype.mergeOrdered = function (a, b, context, comparisonInfo) {
            if (this.isAnyOrEquivalent(a) || this.isAnyOrEquivalent(b)) {
                return this.semanticInfoChain.anyTypeSymbol;
            } else if (a === b) {
                return a;
            } else if ((b === this.semanticInfoChain.nullTypeSymbol) && a != this.semanticInfoChain.nullTypeSymbol) {
                return a;
            } else if ((a === this.semanticInfoChain.nullTypeSymbol) && (b != this.semanticInfoChain.nullTypeSymbol)) {
                return b;
            } else if ((a === this.semanticInfoChain.voidTypeSymbol) && (b === this.semanticInfoChain.voidTypeSymbol || b === this.semanticInfoChain.undefinedTypeSymbol || b === this.semanticInfoChain.nullTypeSymbol)) {
                return a;
            } else if ((a === this.semanticInfoChain.voidTypeSymbol) && (b === this.semanticInfoChain.anyTypeSymbol)) {
                return b;
            } else if ((b === this.semanticInfoChain.undefinedTypeSymbol) && a != this.semanticInfoChain.voidTypeSymbol) {
                return a;
            } else if ((a === this.semanticInfoChain.undefinedTypeSymbol) && (b != this.semanticInfoChain.undefinedTypeSymbol)) {
                return b;
            } else if (a.isTypeParameter() && !b.isTypeParameter()) {
                return b;
            } else if (!a.isTypeParameter() && b.isTypeParameter()) {
                return a;
            } else if (a.isArray() && b.isArray()) {
                if (a.getElementType() === b.getElementType()) {
                    return a;
                } else {
                    var mergedET = this.mergeOrdered(a.getElementType(), b.getElementType(), context, comparisonInfo);
                    if (mergedET) {
                        var mergedArrayType = mergedET.getArrayType();

                        if (!mergedArrayType) {
                            mergedArrayType = TypeScript.specializeToArrayType(this.semanticInfoChain.elementTypeSymbol, mergedET, this, context);
                        }

                        return mergedArrayType;
                    }
                }
            } else if (this.sourceIsSubtypeOfTarget(a, b, context, comparisonInfo)) {
                return b;
            } else if (this.sourceIsSubtypeOfTarget(b, a, context, comparisonInfo)) {
                return a;
            }

            return null;
        };

        PullTypeResolver.prototype.widenType = function (type) {
            if (type === this.semanticInfoChain.undefinedTypeSymbol || type === this.semanticInfoChain.nullTypeSymbol || type.isError()) {
                return this.semanticInfoChain.anyTypeSymbol;
            }

            return type;
        };

        PullTypeResolver.prototype.isNullOrUndefinedType = function (type) {
            return type === this.semanticInfoChain.nullTypeSymbol || type === this.semanticInfoChain.undefinedTypeSymbol;
        };

        PullTypeResolver.prototype.canApplyContextualType = function (type) {
            if (!type) {
                return true;
            }

            var kind = type.getKind();

            if ((kind & 8388608 /* ObjectType */) != 0) {
                return true;
            }
            if ((kind & 16 /* Interface */) != 0) {
                return true;
            } else if ((kind & TypeScript.PullElementKind.SomeFunction) != 0) {
                return this.canApplyContextualTypeToFunction(type, this.semanticInfoChain.getASTForDecl(type.getDeclarations[0]), true);
            } else if ((kind & 128 /* Array */) != 0) {
                return true;
            } else if (type == this.semanticInfoChain.anyTypeSymbol || kind != 2 /* Primitive */) {
                return true;
            }

            return false;
        };

        PullTypeResolver.prototype.findBestCommonType = function (initialType, targetType, collection, context, comparisonInfo) {
            var len = collection.getLength();
            var nlastChecked = 0;
            var bestCommonType = initialType;

            if (targetType && this.canApplyContextualType(bestCommonType)) {
                if (bestCommonType) {
                    bestCommonType = this.mergeOrdered(bestCommonType, targetType, context);
                } else {
                    bestCommonType = targetType;
                }
            }

            var convergenceType = bestCommonType;

            while (nlastChecked < len) {
                for (var i = 0; i < len; i++) {
                    if (i === nlastChecked) {
                        continue;
                    }

                    if (convergenceType && (bestCommonType = this.mergeOrdered(convergenceType, collection.getTypeAtIndex(i), context, comparisonInfo))) {
                        convergenceType = bestCommonType;
                    }

                    if (bestCommonType === null || this.isAnyOrEquivalent(bestCommonType)) {
                        break;
                    } else if (targetType && !(bestCommonType.isTypeParameter() || targetType.isTypeParameter())) {
                        collection.setTypeAtIndex(i, targetType);
                    }
                }

                if (convergenceType && bestCommonType) {
                    break;
                }

                nlastChecked++;
                if (nlastChecked < len) {
                    convergenceType = collection.getTypeAtIndex(nlastChecked);
                }
            }

            if (!bestCommonType) {
                var emptyTypeDecl = new TypeScript.PullDecl("{}", "{}", 8388608 /* ObjectType */, 0 /* None */, new TypeScript.TextSpan(0, 0), this.currentUnit.getPath());
                var emptyType = new TypeScript.PullTypeSymbol("{}", 8388608 /* ObjectType */);

                emptyTypeDecl.setSymbol(emptyType);
                emptyType.addDeclaration(emptyTypeDecl);

                bestCommonType = emptyType;
            }

            return bestCommonType;
        };

        PullTypeResolver.prototype.typesAreIdentical = function (t1, t2, val) {
            if (t1 === t2) {
                return true;
            }

            if (!t1 || !t2) {
                return false;
            }

            if (val && t1.isPrimitive() && (t1).isStringConstant() && t2 === this.semanticInfoChain.stringTypeSymbol) {
                return (val.nodeType === 5 /* StringLiteral */) && (TypeScript.stripQuotes((val).actualText) === TypeScript.stripQuotes(t1.getName()));
            }

            if (val && t2.isPrimitive() && (t2).isStringConstant() && t2 === this.semanticInfoChain.stringTypeSymbol) {
                return (val.nodeType === 5 /* StringLiteral */) && (TypeScript.stripQuotes((val).actualText) === TypeScript.stripQuotes(t2.getName()));
            }

            if (t1.isPrimitive() && (t1).isStringConstant() && t2.isPrimitive() && (t2).isStringConstant()) {
                return TypeScript.stripQuotes(t1.getName()) === TypeScript.stripQuotes(t2.getName());
            }

            if (t1.isPrimitive() || t2.isPrimitive()) {
                return false;
            }

            if (t1.isClass()) {
                return false;
            }

            if (t1.isError() && t2.isError()) {
                return true;
            }

            if (t1.isTypeParameter()) {
                if (!t2.isTypeParameter()) {
                    return false;
                }

                var t1ParentDeclaration = t1.getDeclarations()[0].getParentDecl();
                var t2ParentDeclaration = t2.getDeclarations()[0].getParentDecl();

                if (t1ParentDeclaration === t2ParentDeclaration) {
                    return this.symbolsShareDeclaration(t1, t2);
                } else {
                    return true;
                }
            }

            var comboId = t2.getSymbolID().toString() + "#" + t1.getSymbolID().toString();

            if (this.identicalCache[comboId] != undefined) {
                return true;
            }

            if ((t1.getKind() & 64 /* Enum */) || (t2.getKind() & 64 /* Enum */)) {
                return t1.getAssociatedContainerType() === t2 || t2.getAssociatedContainerType() === t1;
            }

            if (t1.isArray() || t2.isArray()) {
                if (!(t1.isArray() && t2.isArray())) {
                    return false;
                }
                this.identicalCache[comboId] = false;
                var ret = this.typesAreIdentical(t1.getElementType(), t2.getElementType());
                if (ret) {
                    this.identicalCache[comboId] = true;
                } else {
                    this.identicalCache[comboId] = undefined;
                }

                return ret;
            }

            if (t1.isPrimitive() != t2.isPrimitive()) {
                return false;
            }

            this.identicalCache[comboId] = false;

            if (t1.hasMembers() && t2.hasMembers()) {
                var t1Members = t1.getMembers();
                var t2Members = t2.getMembers();

                if (t1Members.length != t2Members.length) {
                    this.identicalCache[comboId] = undefined;
                    return false;
                }

                var t1MemberSymbol = null;
                var t2MemberSymbol = null;

                var t1MemberType = null;
                var t2MemberType = null;

                for (var iMember = 0; iMember < t1Members.length; iMember++) {
                    t1MemberSymbol = t1Members[iMember];
                    t2MemberSymbol = this.getMemberSymbol(t1MemberSymbol.getName(), TypeScript.PullElementKind.SomeValue, t2);

                    if (!t2MemberSymbol || (t1MemberSymbol.getIsOptional() != t2MemberSymbol.getIsOptional())) {
                        this.identicalCache[comboId] = undefined;
                        return false;
                    }

                    t1MemberType = t1MemberSymbol.getType();
                    t2MemberType = t2MemberSymbol.getType();

                    if (t1MemberType && t2MemberType && (this.identicalCache[t2MemberType.getSymbolID().toString() + "#" + t1MemberType.getSymbolID().toString()] != undefined)) {
                        continue;
                    }

                    if (!this.typesAreIdentical(t1MemberType, t2MemberType)) {
                        this.identicalCache[comboId] = undefined;
                        return false;
                    }
                }
            } else if (t1.hasMembers() || t2.hasMembers()) {
                this.identicalCache[comboId] = undefined;
                return false;
            }

            var t1CallSigs = t1.getCallSignatures();
            var t2CallSigs = t2.getCallSignatures();

            var t1ConstructSigs = t1.getConstructSignatures();
            var t2ConstructSigs = t2.getConstructSignatures();

            var t1IndexSigs = t1.getIndexSignatures();
            var t2IndexSigs = t2.getIndexSignatures();

            if (!this.signatureGroupsAreIdentical(t1CallSigs, t2CallSigs)) {
                this.identicalCache[comboId] = undefined;
                return false;
            }

            if (!this.signatureGroupsAreIdentical(t1ConstructSigs, t2ConstructSigs)) {
                this.identicalCache[comboId] = undefined;
                return false;
            }

            if (!this.signatureGroupsAreIdentical(t1IndexSigs, t2IndexSigs)) {
                this.identicalCache[comboId] = undefined;
                return false;
            }

            this.identicalCache[comboId] = true;
            return true;
        };

        PullTypeResolver.prototype.signatureGroupsAreIdentical = function (sg1, sg2) {
            if (sg1 === sg2) {
                return true;
            }

            if (!sg1 || !sg2) {
                return false;
            }

            if (sg1.length != sg2.length) {
                return false;
            }

            var sig1 = null;
            var sig2 = null;
            var sigsMatch = false;

            for (var iSig1 = 0; iSig1 < sg1.length; iSig1++) {
                sig1 = sg1[iSig1];

                for (var iSig2 = 0; iSig2 < sg2.length; iSig2++) {
                    sig2 = sg2[iSig2];

                    if (this.signaturesAreIdentical(sig1, sig2)) {
                        sigsMatch = true;
                        break;
                    }
                }

                if (sigsMatch) {
                    sigsMatch = false;
                    continue;
                }

                return false;
            }

            return true;
        };

        PullTypeResolver.prototype.signaturesAreIdentical = function (s1, s2) {
            if (s1.hasVariableParamList() != s2.hasVariableParamList()) {
                return false;
            }

            if (s1.getNonOptionalParameterCount() != s2.getNonOptionalParameterCount()) {
                return false;
            }

            var s1Params = s1.getParameters();
            var s2Params = s2.getParameters();

            if (s1Params.length != s2Params.length) {
                return false;
            }

            if (!this.typesAreIdentical(s1.getReturnType(), s2.getReturnType())) {
                return false;
            }

            for (var iParam = 0; iParam < s1Params.length; iParam++) {
                if (!this.typesAreIdentical(s1Params[iParam].getType(), s2Params[iParam].getType())) {
                    return false;
                }
            }

            return true;
        };

        PullTypeResolver.prototype.substituteUpperBoundForType = function (type) {
            if (!type || !type.isTypeParameter()) {
                return type;
            }

            var constraint = (type).getConstraint();

            if (constraint) {
                return this.substituteUpperBoundForType(constraint);
            }

            if (this.cachedObjectInterfaceType()) {
                return this.cachedObjectInterfaceType();
            }

            return type;
        };

        PullTypeResolver.prototype.symbolsShareDeclaration = function (symbol1, symbol2) {
            var decls1 = symbol1.getDeclarations();
            var decls2 = symbol2.getDeclarations();

            if (decls1.length && decls2.length) {
                return decls1[0].isEqual(decls2[0]);
            }

            return false;
        };

        PullTypeResolver.prototype.sourceIsSubtypeOfTarget = function (source, target, context, comparisonInfo) {
            return this.sourceIsRelatableToTarget(source, target, false, this.subtypeCache, context, comparisonInfo);
        };

        PullTypeResolver.prototype.sourceMembersAreSubtypeOfTargetMembers = function (source, target, context, comparisonInfo) {
            return this.sourceMembersAreRelatableToTargetMembers(source, target, false, this.subtypeCache, context, comparisonInfo);
        };

        PullTypeResolver.prototype.sourcePropertyIsSubtypeOfTargetProperty = function (source, target, sourceProp, targetProp, context, comparisonInfo) {
            return this.sourcePropertyIsRelatableToTargetProperty(source, target, sourceProp, targetProp, false, this.subtypeCache, context, comparisonInfo);
        };

        PullTypeResolver.prototype.sourceCallSignaturesAreSubtypeOfTargetCallSignatures = function (source, target, context, comparisonInfo) {
            return this.sourceCallSignaturesAreRelatableToTargetCallSignatures(source, target, false, this.subtypeCache, context, comparisonInfo);
        };

        PullTypeResolver.prototype.sourceConstructSignaturesAreSubtypeOfTargetConstructSignatures = function (source, target, context, comparisonInfo) {
            return this.sourceConstructSignaturesAreRelatableToTargetConstructSignatures(source, target, false, this.subtypeCache, context, comparisonInfo);
        };

        PullTypeResolver.prototype.sourceIndexSignaturesAreSubtypeOfTargetIndexSignatures = function (source, target, context, comparisonInfo) {
            return this.sourceIndexSignaturesAreRelatableToTargetIndexSignatures(source, target, false, this.subtypeCache, context, comparisonInfo);
        };

        PullTypeResolver.prototype.typeIsSubtypeOfFunction = function (source, context) {
            var callSignatures = source.getCallSignatures();

            if (callSignatures.length) {
                return true;
            }

            var constructSignatures = source.getConstructSignatures();

            if (constructSignatures.length) {
                return true;
            }

            if (this.cachedFunctionInterfaceType()) {
                return this.sourceIsSubtypeOfTarget(source, this.cachedFunctionInterfaceType(), context);
            }

            return false;
        };

        PullTypeResolver.prototype.signatureGroupIsSubtypeOfTarget = function (sg1, sg2, context, comparisonInfo) {
            return this.signatureGroupIsRelatableToTarget(sg1, sg2, false, this.subtypeCache, context, comparisonInfo);
        };

        PullTypeResolver.prototype.signatureIsSubtypeOfTarget = function (s1, s2, context, comparisonInfo) {
            return this.signatureIsRelatableToTarget(s1, s2, false, this.subtypeCache, context, comparisonInfo);
        };

        PullTypeResolver.prototype.sourceIsAssignableToTarget = function (source, target, context, comparisonInfo, isInProvisionalResolution) {
            if (typeof isInProvisionalResolution === "undefined") { isInProvisionalResolution = false; }
            var cache = isInProvisionalResolution ? {} : this.assignableCache;
            return this.sourceIsRelatableToTarget(source, target, true, cache, context, comparisonInfo);
        };

        PullTypeResolver.prototype.signatureGroupIsAssignableToTarget = function (sg1, sg2, context, comparisonInfo) {
            return this.signatureGroupIsRelatableToTarget(sg1, sg2, true, this.assignableCache, context, comparisonInfo);
        };

        PullTypeResolver.prototype.signatureIsAssignableToTarget = function (s1, s2, context, comparisonInfo) {
            return this.signatureIsRelatableToTarget(s1, s2, true, this.assignableCache, context, comparisonInfo);
        };

        PullTypeResolver.prototype.sourceIsRelatableToTarget = function (source, target, assignableTo, comparisonCache, context, comparisonInfo) {
            if (source === target) {
                return true;
            }

            if (!(source && target)) {
                return true;
            }

            if (context.specializingToAny && (target.isTypeParameter() || source.isTypeParameter())) {
                return true;
            }

            if (context.specializingToObject) {
                if (target.isTypeParameter()) {
                    target = this.cachedObjectInterfaceType();
                }
                if (source.isTypeParameter()) {
                    target = this.cachedObjectInterfaceType();
                }
            }

            var sourceSubstitution = source;

            if (source == this.semanticInfoChain.stringTypeSymbol && this.cachedStringInterfaceType()) {
                if (!this.cachedStringInterfaceType().isResolved()) {
                    this.resolveDeclaredSymbol(this.cachedStringInterfaceType(), null, context);
                }
                sourceSubstitution = this.cachedStringInterfaceType();
            } else if (source == this.semanticInfoChain.numberTypeSymbol && this.cachedNumberInterfaceType()) {
                if (!this.cachedNumberInterfaceType().isResolved()) {
                    this.resolveDeclaredSymbol(this.cachedNumberInterfaceType(), null, context);
                }
                sourceSubstitution = this.cachedNumberInterfaceType();
            } else if (source == this.semanticInfoChain.booleanTypeSymbol && this.cachedBooleanInterfaceType()) {
                if (!this.cachedBooleanInterfaceType().isResolved()) {
                    this.resolveDeclaredSymbol(this.cachedBooleanInterfaceType(), null, context);
                }
                sourceSubstitution = this.cachedBooleanInterfaceType();
            } else if (TypeScript.PullHelpers.symbolIsEnum(source) && this.cachedNumberInterfaceType()) {
                sourceSubstitution = this.cachedNumberInterfaceType();
            } else if (source.isTypeParameter()) {
                sourceSubstitution = this.substituteUpperBoundForType(source);
            }

            var comboId = source.getSymbolID().toString() + "#" + target.getSymbolID().toString();

            if (comparisonCache[comboId] != undefined) {
                return true;
            }

            if (assignableTo) {
                if (this.isAnyOrEquivalent(source) || this.isAnyOrEquivalent(target)) {
                    return true;
                }

                if (source === this.semanticInfoChain.stringTypeSymbol && target.isPrimitive() && (target).isStringConstant()) {
                    return comparisonInfo && comparisonInfo.stringConstantVal && (comparisonInfo.stringConstantVal.nodeType === 5 /* StringLiteral */) && (TypeScript.stripQuotes((comparisonInfo.stringConstantVal).actualText) === TypeScript.stripQuotes(target.getName()));
                }
            } else {
                if (this.isAnyOrEquivalent(target)) {
                    return true;
                }

                if (target === this.semanticInfoChain.stringTypeSymbol && source.isPrimitive() && (source).isStringConstant()) {
                    return true;
                }
            }

            if (source.isPrimitive() && (source).isStringConstant() && target.isPrimitive() && (target).isStringConstant()) {
                return TypeScript.stripQuotes(source.getName()) === TypeScript.stripQuotes(target.getName());
            }

            if (source === this.semanticInfoChain.undefinedTypeSymbol) {
                return true;
            }

            if ((source === this.semanticInfoChain.nullTypeSymbol) && (target != this.semanticInfoChain.undefinedTypeSymbol && target != this.semanticInfoChain.voidTypeSymbol)) {
                return true;
            }

            if (target == this.semanticInfoChain.voidTypeSymbol) {
                if (source == this.semanticInfoChain.anyTypeSymbol || source == this.semanticInfoChain.undefinedTypeSymbol || source == this.semanticInfoChain.nullTypeSymbol) {
                    return true;
                }

                return false;
            } else if (source == this.semanticInfoChain.voidTypeSymbol) {
                if (target == this.semanticInfoChain.anyTypeSymbol) {
                    return true;
                }

                return false;
            }

            if (target === this.semanticInfoChain.numberTypeSymbol && TypeScript.PullHelpers.symbolIsEnum(source)) {
                return true;
            }

            if (source === this.semanticInfoChain.numberTypeSymbol && TypeScript.PullHelpers.symbolIsEnum(target)) {
                return true;
            }

            if (TypeScript.PullHelpers.symbolIsEnum(target) && TypeScript.PullHelpers.symbolIsEnum(source)) {
                return this.symbolsShareDeclaration(target, source);
            }

            if ((source.getKind() & 64 /* Enum */) || (target.getKind() & 64 /* Enum */)) {
                return false;
            }

            if (source.isArray() && target.isArray()) {
                comparisonCache[comboId] = false;
                var ret = this.sourceIsRelatableToTarget(source.getElementType(), target.getElementType(), assignableTo, comparisonCache, context, comparisonInfo);
                if (ret) {
                    comparisonCache[comboId] = true;
                } else {
                    comparisonCache[comboId] = undefined;
                }

                return ret;
            } else if (source.isArray() && target == this.cachedArrayInterfaceType()) {
                return true;
            } else if (target.isArray() && source == this.cachedArrayInterfaceType()) {
                return true;
            }

            if (source.isPrimitive() && target.isPrimitive()) {
                return false;
            } else if (source.isPrimitive() != target.isPrimitive()) {
                if (target.isPrimitive()) {
                    return false;
                }
            }

            if (target.isTypeParameter()) {
                if (source.isTypeParameter() && (source == sourceSubstitution)) {
                    var targetParentDeclaration = target.getDeclarations()[0].getParentDecl();
                    var sourceParentDeclaration = source.getDeclarations()[0].getParentDecl();

                    if (targetParentDeclaration !== sourceParentDeclaration) {
                        return this.symbolsShareDeclaration(target, source);
                    } else {
                        return true;
                    }
                } else {
                    if (context.isComparingSpecializedSignatures) {
                        target = this.substituteUpperBoundForType(target);
                    } else {
                        return false;
                    }
                }
            }

            comparisonCache[comboId] = false;

            if (sourceSubstitution.hasBase(target)) {
                comparisonCache[comboId] = true;
                return true;
            }

            if (this.cachedObjectInterfaceType() && target === this.cachedObjectInterfaceType()) {
                return true;
            }

            if (this.cachedFunctionInterfaceType() && (sourceSubstitution.getCallSignatures().length || sourceSubstitution.getConstructSignatures().length) && target === this.cachedFunctionInterfaceType()) {
                return true;
            }

            if (target.hasMembers() && !this.sourceMembersAreRelatableToTargetMembers(sourceSubstitution, target, assignableTo, comparisonCache, context, comparisonInfo)) {
                comparisonCache[comboId] = undefined;
                return false;
            }

            if (!this.sourceCallSignaturesAreRelatableToTargetCallSignatures(sourceSubstitution, target, assignableTo, comparisonCache, context, comparisonInfo)) {
                comparisonCache[comboId] = undefined;
                return false;
            }

            if (!this.sourceConstructSignaturesAreRelatableToTargetConstructSignatures(sourceSubstitution, target, assignableTo, comparisonCache, context, comparisonInfo)) {
                comparisonCache[comboId] = undefined;
                return false;
            }

            if (!this.sourceIndexSignaturesAreRelatableToTargetIndexSignatures(sourceSubstitution, target, assignableTo, comparisonCache, context, comparisonInfo)) {
                comparisonCache[comboId] = undefined;
                return false;
            }

            comparisonCache[comboId] = true;
            return true;
        };

        PullTypeResolver.prototype.sourceMembersAreRelatableToTargetMembers = function (source, target, assignableTo, comparisonCache, context, comparisonInfo) {
            var targetProps = target.getAllMembers(TypeScript.PullElementKind.SomeValue, true);

            for (var itargetProp = 0; itargetProp < targetProps.length; itargetProp++) {
                var targetProp = targetProps[itargetProp];
                var sourceProp = this.getMemberSymbol(targetProp.getName(), TypeScript.PullElementKind.SomeValue, source);

                if (!targetProp.isResolved()) {
                    this.resolveDeclaredSymbol(targetProp, null, context);
                }

                var targetPropType = targetProp.getType();

                if (!sourceProp) {
                    if (this.cachedObjectInterfaceType()) {
                        sourceProp = this.getMemberSymbol(targetProp.getName(), TypeScript.PullElementKind.SomeValue, this.cachedObjectInterfaceType());
                    }

                    if (!sourceProp) {
                        if (this.cachedFunctionInterfaceType() && (targetPropType.getCallSignatures().length || targetPropType.getConstructSignatures().length)) {
                            sourceProp = this.getMemberSymbol(targetProp.getName(), TypeScript.PullElementKind.SomeValue, this.cachedFunctionInterfaceType());
                        }

                        if (!sourceProp) {
                            if (!(targetProp.getIsOptional())) {
                                if (comparisonInfo) {
                                    comparisonInfo.flags |= 2 /* RequiredPropertyIsMissing */;
                                    comparisonInfo.addMessage(TypeScript.getDiagnosticMessage(240 /* Type__0__is_missing_property__1__from_type__2_ */, [source.toString(), targetProp.getScopedNameEx().toString(), target.toString()]));
                                }
                                return false;
                            }
                            continue;
                        }
                    }
                }

                if (!this.sourcePropertyIsRelatableToTargetProperty(source, target, sourceProp, targetProp, assignableTo, comparisonCache, context, comparisonInfo)) {
                    return false;
                }
            }

            return true;
        };

        PullTypeResolver.prototype.sourcePropertyIsRelatableToTargetProperty = function (source, target, sourceProp, targetProp, assignableTo, comparisonCache, context, comparisonInfo) {
            var targetPropIsPrivate = targetProp.hasFlag(2 /* Private */);
            var sourcePropIsPrivate = sourceProp.hasFlag(2 /* Private */);

            if (targetPropIsPrivate != sourcePropIsPrivate) {
                if (comparisonInfo) {
                    if (targetPropIsPrivate) {
                        comparisonInfo.addMessage(TypeScript.getDiagnosticMessage(244 /* Property__0__defined_as_public_in_type__1__is_defined_as_private_in_type__2_ */, [targetProp.getScopedNameEx().toString(), sourceProp.getContainer().toString(), targetProp.getContainer().toString()]));
                    } else {
                        comparisonInfo.addMessage(TypeScript.getDiagnosticMessage(243 /* Property__0__defined_as_private_in_type__1__is_defined_as_public_in_type__2_ */, [targetProp.getScopedNameEx().toString(), sourceProp.getContainer().toString(), targetProp.getContainer().toString()]));
                    }
                    comparisonInfo.flags |= 128 /* InconsistantPropertyAccesibility */;
                }
                return false;
            } else if (sourcePropIsPrivate && targetPropIsPrivate) {
                var targetDecl = targetProp.getDeclarations()[0];
                var sourceDecl = sourceProp.getDeclarations()[0];

                if (!targetDecl.isEqual(sourceDecl)) {
                    if (comparisonInfo) {
                        comparisonInfo.flags |= 128 /* InconsistantPropertyAccesibility */;
                        comparisonInfo.addMessage(TypeScript.getDiagnosticMessage(245 /* Types__0__and__1__define_property__2__as_private */, [sourceProp.getContainer().toString(), targetProp.getContainer().toString(), targetProp.getScopedNameEx().toString()]));
                    }
                    return false;
                }
            }

            if (!sourceProp.isResolved()) {
                this.resolveDeclaredSymbol(sourceProp, null, context);
            }

            var sourcePropType = sourceProp.getType();
            var targetPropType = targetProp.getType();

            if (targetPropType && sourcePropType && (comparisonCache[sourcePropType.getSymbolID().toString() + "#" + targetPropType.getSymbolID().toString()] != undefined)) {
                return true;
            }

            var comparisonInfoPropertyTypeCheck = null;
            if (comparisonInfo && !comparisonInfo.onlyCaptureFirstError) {
                comparisonInfoPropertyTypeCheck = new TypeScript.TypeComparisonInfo(comparisonInfo);
            }
            if (!this.sourceIsRelatableToTarget(sourcePropType, targetPropType, assignableTo, comparisonCache, context, comparisonInfoPropertyTypeCheck)) {
                if (comparisonInfo) {
                    comparisonInfo.flags |= 32 /* IncompatiblePropertyTypes */;
                    var message;
                    if (comparisonInfoPropertyTypeCheck && comparisonInfoPropertyTypeCheck.message) {
                        message = TypeScript.getDiagnosticMessage(242 /* Types_of_property__0__of_types__1__and__2__are_incompatible__NL__3 */, [targetProp.getScopedNameEx().toString(), source.toString(), target.toString(), comparisonInfoPropertyTypeCheck.message]);
                    } else {
                        message = TypeScript.getDiagnosticMessage(241 /* Types_of_property__0__of_types__1__and__2__are_incompatible */, [targetProp.getScopedNameEx().toString(), source.toString(), target.toString()]);
                    }
                    comparisonInfo.addMessage(message);
                }

                return false;
            }

            return true;
        };

        PullTypeResolver.prototype.sourceCallSignaturesAreRelatableToTargetCallSignatures = function (source, target, assignableTo, comparisonCache, context, comparisonInfo) {
            var targetCallSigs = target.getCallSignatures();

            if (targetCallSigs.length) {
                var comparisonInfoSignatuesTypeCheck = null;
                if (comparisonInfo && !comparisonInfo.onlyCaptureFirstError) {
                    comparisonInfoSignatuesTypeCheck = new TypeScript.TypeComparisonInfo(comparisonInfo);
                }

                var sourceCallSigs = source.getCallSignatures();
                if (!this.signatureGroupIsRelatableToTarget(sourceCallSigs, targetCallSigs, assignableTo, comparisonCache, context, comparisonInfoSignatuesTypeCheck)) {
                    if (comparisonInfo) {
                        var message;
                        if (sourceCallSigs.length && targetCallSigs.length) {
                            if (comparisonInfoSignatuesTypeCheck && comparisonInfoSignatuesTypeCheck.message) {
                                message = TypeScript.getDiagnosticMessage(247 /* Call_signatures_of_types__0__and__1__are_incompatible__NL__2 */, [source.toString(), target.toString(), comparisonInfoSignatuesTypeCheck.message]);
                            } else {
                                message = TypeScript.getDiagnosticMessage(246 /* Call_signatures_of_types__0__and__1__are_incompatible */, [source.toString(), target.toString()]);
                            }
                        } else {
                            var hasSig = targetCallSigs.length ? target.toString() : source.toString();
                            var lacksSig = !targetCallSigs.length ? target.toString() : source.toString();
                            message = TypeScript.getDiagnosticMessage(248 /* Type__0__requires_a_call_signature__but_Type__1__lacks_one */, [hasSig, lacksSig]);
                        }
                        comparisonInfo.flags |= 4 /* IncompatibleSignatures */;
                        comparisonInfo.addMessage(message);
                    }
                    return false;
                }
            }

            return true;
        };

        PullTypeResolver.prototype.sourceConstructSignaturesAreRelatableToTargetConstructSignatures = function (source, target, assignableTo, comparisonCache, context, comparisonInfo) {
            var targetConstructSigs = target.getConstructSignatures();
            if (targetConstructSigs.length) {
                var comparisonInfoSignatuesTypeCheck = null;
                if (comparisonInfo && !comparisonInfo.onlyCaptureFirstError) {
                    comparisonInfoSignatuesTypeCheck = new TypeScript.TypeComparisonInfo(comparisonInfo);
                }

                var sourceConstructSigs = source.getConstructSignatures();
                if (!this.signatureGroupIsRelatableToTarget(sourceConstructSigs, targetConstructSigs, assignableTo, comparisonCache, context, comparisonInfoSignatuesTypeCheck)) {
                    if (comparisonInfo) {
                        var message;
                        if (sourceConstructSigs.length && targetConstructSigs.length) {
                            if (comparisonInfoSignatuesTypeCheck && comparisonInfoSignatuesTypeCheck.message) {
                                message = TypeScript.getDiagnosticMessage(250 /* Construct_signatures_of_types__0__and__1__are_incompatible__NL__2 */, [source.toString(), target.toString(), comparisonInfoSignatuesTypeCheck.message]);
                            } else {
                                message = TypeScript.getDiagnosticMessage(249 /* Construct_signatures_of_types__0__and__1__are_incompatible */, [source.toString(), target.toString()]);
                            }
                        } else {
                            var hasSig = targetConstructSigs.length ? target.toString() : source.toString();
                            var lacksSig = !targetConstructSigs.length ? target.toString() : source.toString();
                            message = TypeScript.getDiagnosticMessage(251 /* Type__0__requires_a_construct_signature__but_Type__1__lacks_one */, [hasSig, lacksSig]);
                        }
                        comparisonInfo.flags |= 4 /* IncompatibleSignatures */;
                        comparisonInfo.addMessage(message);
                    }
                    return false;
                }
            }

            return true;
        };

        PullTypeResolver.prototype.sourceIndexSignaturesAreRelatableToTargetIndexSignatures = function (source, target, assignableTo, comparisonCache, context, comparisonInfo) {
            var targetIndexSigs = target.getIndexSignatures();

            if (targetIndexSigs.length) {
                var sourceIndexSigs = source.getIndexSignatures();

                var targetIndex = !targetIndexSigs.length && this.cachedObjectInterfaceType() ? this.cachedObjectInterfaceType().getIndexSignatures() : targetIndexSigs;
                var sourceIndex = !sourceIndexSigs.length && this.cachedObjectInterfaceType() ? this.cachedObjectInterfaceType().getIndexSignatures() : sourceIndexSigs;

                var sourceStringSig = null;
                var sourceNumberSig = null;

                var targetStringSig = null;
                var targetNumberSig = null;

                var params;

                for (var i = 0; i < targetIndex.length; i++) {
                    if (targetStringSig && targetNumberSig) {
                        break;
                    }

                    params = targetIndex[i].getParameters();

                    if (params.length) {
                        if (!targetStringSig && params[0].getType() === this.semanticInfoChain.stringTypeSymbol) {
                            targetStringSig = targetIndex[i];
                            continue;
                        } else if (!targetNumberSig && params[0].getType() === this.semanticInfoChain.numberTypeSymbol) {
                            targetNumberSig = targetIndex[i];
                            continue;
                        }
                    }
                }

                for (var i = 0; i < sourceIndex.length; i++) {
                    if (sourceStringSig && sourceNumberSig) {
                        break;
                    }

                    params = sourceIndex[i].getParameters();

                    if (params.length) {
                        if (!sourceStringSig && params[0].getType() === this.semanticInfoChain.stringTypeSymbol) {
                            sourceStringSig = sourceIndex[i];
                            continue;
                        } else if (!sourceNumberSig && params[0].getType() === this.semanticInfoChain.numberTypeSymbol) {
                            sourceNumberSig = sourceIndex[i];
                            continue;
                        }
                    }
                }

                var comparable = true;
                var comparisonInfoSignatuesTypeCheck = null;
                if (comparisonInfo && !comparisonInfo.onlyCaptureFirstError) {
                    comparisonInfoSignatuesTypeCheck = new TypeScript.TypeComparisonInfo(comparisonInfo);
                }

                if (targetStringSig) {
                    if (sourceStringSig) {
                        comparable = this.signatureIsAssignableToTarget(sourceStringSig, targetStringSig, context, comparisonInfoSignatuesTypeCheck);
                    } else {
                        comparable = false;
                    }
                }

                if (comparable && targetNumberSig) {
                    if (sourceNumberSig) {
                        comparable = this.signatureIsAssignableToTarget(sourceNumberSig, targetNumberSig, context, comparisonInfoSignatuesTypeCheck);
                    } else if (sourceStringSig) {
                        comparable = this.sourceIsAssignableToTarget(sourceStringSig.getReturnType(), targetNumberSig.getReturnType(), context, comparisonInfoSignatuesTypeCheck);
                    } else {
                        comparable = false;
                    }
                }

                if (!comparable) {
                    if (comparisonInfo) {
                        var message;
                        if (comparisonInfoSignatuesTypeCheck && comparisonInfoSignatuesTypeCheck.message) {
                            message = TypeScript.getDiagnosticMessage(253 /* Index_signatures_of_types__0__and__1__are_incompatible__NL__2 */, [source.toString(), target.toString(), comparisonInfoSignatuesTypeCheck.message]);
                        } else {
                            message = TypeScript.getDiagnosticMessage(252 /* Index_signatures_of_types__0__and__1__are_incompatible */, [source.toString(), target.toString()]);
                        }
                        comparisonInfo.flags |= 4 /* IncompatibleSignatures */;
                        comparisonInfo.addMessage(message);
                    }
                    return false;
                }
            }

            if (targetStringSig && !source.isNamedTypeSymbol() && source.hasMembers()) {
                var targetReturnType = targetStringSig.getReturnType();
                var sourceMembers = source.getMembers();

                for (var i = 0; i < sourceMembers.length; i++) {
                    if (!this.sourceIsRelatableToTarget(sourceMembers[i].getType(), targetReturnType, assignableTo, comparisonCache, context, comparisonInfo)) {
                        return false;
                    }
                }
            }

            return true;
        };

        PullTypeResolver.prototype.signatureGroupIsRelatableToTarget = function (sourceSG, targetSG, assignableTo, comparisonCache, context, comparisonInfo) {
            if (sourceSG === targetSG) {
                return true;
            }

            if (!(sourceSG.length && targetSG.length)) {
                return false;
            }

            var mSig = null;
            var nSig = null;
            var foundMatch = false;

            for (var iMSig = 0; iMSig < targetSG.length; iMSig++) {
                mSig = targetSG[iMSig];

                if (mSig.isStringConstantOverloadSignature()) {
                    continue;
                }

                for (var iNSig = 0; iNSig < sourceSG.length; iNSig++) {
                    nSig = sourceSG[iNSig];

                    if (nSig.isStringConstantOverloadSignature()) {
                        continue;
                    }

                    if (this.signatureIsRelatableToTarget(nSig, mSig, assignableTo, comparisonCache, context, comparisonInfo)) {
                        foundMatch = true;
                        break;
                    }
                }

                if (foundMatch) {
                    foundMatch = false;
                    continue;
                }
                return false;
            }

            return true;
        };

        PullTypeResolver.prototype.signatureIsRelatableToTarget = function (sourceSig, targetSig, assignableTo, comparisonCache, context, comparisonInfo) {
            var sourceParameters = sourceSig.getParameters();
            var targetParameters = targetSig.getParameters();

            if (!sourceParameters || !targetParameters) {
                return false;
            }

            var targetVarArgCount = targetSig.getNonOptionalParameterCount();
            var sourceVarArgCount = sourceSig.getNonOptionalParameterCount();

            if (sourceVarArgCount > targetVarArgCount && !targetSig.hasVariableParamList()) {
                if (comparisonInfo) {
                    comparisonInfo.flags |= 3 /* SourceSignatureHasTooManyParameters */;
                    comparisonInfo.addMessage(TypeScript.getDiagnosticMessage(254 /* Call_signature_expects__0__or_fewer_parameters */, [targetVarArgCount]));
                }
                return false;
            }

            var sourceReturnType = sourceSig.getReturnType();
            var targetReturnType = targetSig.getReturnType();

            var prevSpecializingToObject = context.specializingToObject;
            context.specializingToObject = true;

            if (targetReturnType != this.semanticInfoChain.voidTypeSymbol) {
                if (!this.sourceIsRelatableToTarget(sourceReturnType, targetReturnType, assignableTo, comparisonCache, context, comparisonInfo)) {
                    if (comparisonInfo) {
                        comparisonInfo.flags |= 16 /* IncompatibleReturnTypes */;
                    }
                    context.specializingToObject = prevSpecializingToObject;
                    return false;
                }
            }

            var len = (sourceVarArgCount < targetVarArgCount && (sourceSig.hasVariableParamList() || (sourceParameters.length > sourceVarArgCount))) ? targetVarArgCount : sourceVarArgCount;
            var sourceParamType = null;
            var targetParamType = null;
            var sourceParamName = "";
            var targetParamName = "";

            for (var iSource = 0, iTarget = 0; iSource < len; iSource++, iTarget++) {
                if (iSource < sourceParameters.length && (!sourceSig.hasVariableParamList() || iSource < sourceVarArgCount)) {
                    sourceParamType = sourceParameters[iSource].getType();
                    sourceParamName = sourceParameters[iSource].getName();
                } else if (iSource === sourceVarArgCount) {
                    sourceParamType = sourceParameters[iSource].getType();
                    if (sourceParamType.isArray()) {
                        sourceParamType = sourceParamType.getElementType();
                    }
                    sourceParamName = sourceParameters[iSource].getName();
                }

                if (iTarget < targetParameters.length && iTarget < targetVarArgCount) {
                    targetParamType = targetParameters[iTarget].getType();
                    targetParamName = targetParameters[iTarget].getName();
                } else if (targetSig.hasVariableParamList() && iTarget === targetVarArgCount) {
                    targetParamType = targetParameters[iTarget].getType();

                    if (targetParamType.isArray()) {
                        targetParamType = targetParamType.getElementType();
                    }
                    targetParamName = targetParameters[iTarget].getName();
                }

                if (sourceParamType && sourceParamType.isTypeParameter() && this.cachedObjectInterfaceType()) {
                    sourceParamType = this.cachedObjectInterfaceType();
                }
                if (targetParamType && targetParamType.isTypeParameter() && this.cachedObjectInterfaceType()) {
                    targetParamType = this.cachedObjectInterfaceType();
                }

                if (!(this.sourceIsRelatableToTarget(sourceParamType, targetParamType, assignableTo, comparisonCache, context, comparisonInfo) || this.sourceIsRelatableToTarget(targetParamType, sourceParamType, assignableTo, comparisonCache, context, comparisonInfo))) {
                    if (comparisonInfo) {
                        comparisonInfo.flags |= 64 /* IncompatibleParameterTypes */;
                    }
                    context.specializingToObject = prevSpecializingToObject;
                    return false;
                }
            }
            context.specializingToObject = prevSpecializingToObject;
            return true;
        };

        PullTypeResolver.prototype.resolveOverloads = function (application, group, enclosingDecl, haveTypeArgumentsAtCallSite, context, diagnostics) {
            var rd = this.resolutionDataCache.getResolutionData();
            var actuals = rd.actuals;
            var exactCandidates = rd.exactCandidates;
            var conversionCandidates = rd.conversionCandidates;
            var candidate = null;
            var hasOverloads = group.length > 1;
            var comparisonInfo = new TypeScript.TypeComparisonInfo();
            var args = null;
            var target = null;

            if (application.nodeType === 36 /* InvocationExpression */ || application.nodeType === 37 /* ObjectCreationExpression */) {
                var callEx = application;

                args = callEx.arguments;
                target = this.getLastIdentifierInTarget(callEx);

                if (callEx.arguments) {
                    var len = callEx.arguments.members.length;

                    for (var i = 0; i < len; i++) {
                        var argSym = this.resolveAST(callEx.arguments.members[i], false, enclosingDecl, context).symbol;
                        actuals[i] = argSym.getType();
                    }
                }
            } else if (application.nodeType === 35 /* ElementAccessExpression */) {
                var binExp = application;
                target = binExp.operand1;
                args = new TypeScript.ASTList();
                args.members[0] = binExp.operand2;
                var argSym = this.resolveAST(args.members[0], false, enclosingDecl, context).symbol;
                actuals[0] = argSym.getType();
            }

            var signature;
            var returnType;
            var candidateInfo;

            for (var j = 0, groupLen = group.length; j < groupLen; j++) {
                signature = group[j];
                if ((hasOverloads && signature.isDefinition()) || (haveTypeArgumentsAtCallSite && !signature.isGeneric())) {
                    continue;
                }

                returnType = signature.getReturnType();

                this.getCandidateSignatures(signature, actuals, args, exactCandidates, conversionCandidates, enclosingDecl, context, comparisonInfo);
            }
            if (exactCandidates.length === 0) {
                var applicableCandidates = this.getApplicableSignaturesFromCandidates(conversionCandidates, args, comparisonInfo, enclosingDecl, context);
                if (applicableCandidates.length > 0) {
                    candidateInfo = this.findMostApplicableSignature(applicableCandidates, args, enclosingDecl, context);

                    candidate = candidateInfo.sig;
                } else {
                    if (comparisonInfo.message) {
                        diagnostics.push(context.postError(this.unitPath, target.minChar, target.getLength(), 151 /* Supplied_parameters_do_not_match_any_signature_of_call_target__NL__0 */, [comparisonInfo.message]));
                    } else {
                        diagnostics.push(context.postError(this.unitPath, target.minChar, target.getLength(), 150 /* Supplied_parameters_do_not_match_any_signature_of_call_target */, null));
                    }
                }
            } else {
                if (exactCandidates.length > 1) {
                    var applicableSigs = [];
                    for (var i = 0; i < exactCandidates.length; i++) {
                        applicableSigs[i] = { signature: exactCandidates[i], hadProvisionalErrors: false };
                    }
                    candidateInfo = this.findMostApplicableSignature(applicableSigs, args, enclosingDecl, context);

                    candidate = candidateInfo.sig;
                } else {
                    candidate = exactCandidates[0];
                }
            }

            this.resolutionDataCache.returnResolutionData(rd);
            return candidate;
        };

        PullTypeResolver.prototype.getLastIdentifierInTarget = function (callEx) {
            return (callEx.target.nodeType === 32 /* MemberAccessExpression */) ? (callEx.target).operand2 : callEx.target;
        };

        PullTypeResolver.prototype.getCandidateSignatures = function (signature, actuals, args, exactCandidates, conversionCandidates, enclosingDecl, context, comparisonInfo) {
            var parameters = signature.getParameters();
            var lowerBound = signature.getNonOptionalParameterCount();
            var upperBound = parameters.length;
            var formalLen = lowerBound;
            var acceptable = false;

            if ((actuals.length >= lowerBound) && (signature.hasVariableParamList() || actuals.length <= upperBound)) {
                formalLen = (signature.hasVariableParamList() ? parameters.length : actuals.length);
                acceptable = true;
            }

            var repeatType = null;

            if (acceptable) {
                if (signature.hasVariableParamList()) {
                    formalLen -= 1;
                    repeatType = parameters[formalLen].getType();
                    repeatType = repeatType.getElementType();
                    acceptable = actuals.length >= (formalLen < lowerBound ? formalLen : lowerBound);
                }
                var len = actuals.length;

                var exact = acceptable;
                var convert = acceptable;

                var typeA;
                var typeB;

                for (var i = 0; i < len; i++) {
                    if (i < formalLen) {
                        typeA = parameters[i].getType();
                    } else {
                        typeA = repeatType;
                    }

                    typeB = actuals[i];

                    if (typeA && !typeA.isResolved()) {
                        this.resolveDeclaredSymbol(typeA, enclosingDecl, context);
                    }

                    if (typeB && !typeB.isResolved()) {
                        this.resolveDeclaredSymbol(typeB, enclosingDecl, context);
                    }

                    if (!typeA || !typeB || !(this.typesAreIdentical(typeA, typeB, args.members[i]))) {
                        exact = false;
                    }

                    comparisonInfo.stringConstantVal = args.members[i];

                    if (!this.sourceIsAssignableToTarget(typeB, typeA, context, comparisonInfo)) {
                        convert = false;
                    }

                    comparisonInfo.stringConstantVal = null;

                    if (!(exact || convert)) {
                        break;
                    }
                }
                if (exact) {
                    exactCandidates[exactCandidates.length] = signature;
                } else if (convert && (exactCandidates.length === 0)) {
                    conversionCandidates[conversionCandidates.length] = signature;
                }
            }
        };

        PullTypeResolver.prototype.getApplicableSignaturesFromCandidates = function (candidateSignatures, args, comparisonInfo, enclosingDecl, context) {
            var applicableSigs = [];
            var memberType = null;
            var miss = false;
            var cxt = null;
            var hadProvisionalErrors = false;

            var parameters;
            var signature;
            var argSym;

            for (var i = 0; i < candidateSignatures.length; i++) {
                miss = false;

                signature = candidateSignatures[i];
                parameters = signature.getParameters();

                for (var j = 0; j < args.members.length; j++) {
                    if (j >= parameters.length) {
                        continue;
                    }

                    if (!parameters[j].isResolved()) {
                        this.resolveDeclaredSymbol(parameters[j], enclosingDecl, context);
                    }

                    memberType = parameters[j].getType();

                    if (signature.hasVariableParamList() && (j >= signature.getNonOptionalParameterCount()) && memberType.isArray()) {
                        memberType = memberType.getElementType();
                    }

                    if (this.isAnyOrEquivalent(memberType)) {
                        continue;
                    } else if (args.members[j].nodeType === 12 /* FunctionDeclaration */) {
                        if (this.cachedFunctionInterfaceType() && memberType === this.cachedFunctionInterfaceType()) {
                            continue;
                        }

                        argSym = this.resolveFunctionExpression(args.members[j], false, enclosingDecl, context);

                        if (!this.canApplyContextualTypeToFunction(memberType, args.members[j], true)) {
                            if (this.canApplyContextualTypeToFunction(memberType, args.members[j], false)) {
                                if (!this.sourceIsAssignableToTarget(argSym.getType(), memberType, context, comparisonInfo, true)) {
                                    break;
                                }
                            } else {
                                break;
                            }
                        } else {
                            argSym.invalidate();
                            context.pushContextualType(memberType, true, null);

                            argSym = this.resolveFunctionExpression(args.members[j], true, enclosingDecl, context);

                            if (!this.sourceIsAssignableToTarget(argSym.getType(), memberType, context, comparisonInfo, true)) {
                                if (comparisonInfo) {
                                    comparisonInfo.setMessage(TypeScript.getDiagnosticMessage(255 /* Could_not_apply_type__0__to_argument__1__which_is_of_type__2_ */, [memberType.toString(), (j + 1), argSym.getTypeName()]));
                                }
                                miss = true;
                            }
                            argSym.invalidate();
                            cxt = context.popContextualType();
                            hadProvisionalErrors = cxt.hadProvisionalErrors();

                            if (miss) {
                                break;
                            }
                        }
                    } else if (args.members[j].nodeType === 22 /* ObjectLiteralExpression */) {
                        if (this.cachedObjectInterfaceType() && memberType === this.cachedObjectInterfaceType()) {
                            continue;
                        }

                        context.pushContextualType(memberType, true, null);
                        argSym = this.resolveObjectLiteralExpression(args.members[j], true, enclosingDecl, context).symbol;

                        if (!this.sourceIsAssignableToTarget(argSym.getType(), memberType, context, comparisonInfo, true)) {
                            if (comparisonInfo) {
                                comparisonInfo.setMessage(TypeScript.getDiagnosticMessage(255 /* Could_not_apply_type__0__to_argument__1__which_is_of_type__2_ */, [memberType.toString(), (j + 1), argSym.getTypeName()]));
                            }

                            miss = true;
                        }

                        argSym.invalidate();
                        cxt = context.popContextualType();
                        hadProvisionalErrors = cxt.hadProvisionalErrors();

                        if (miss) {
                            break;
                        }
                    } else if (args.members[j].nodeType === 21 /* ArrayLiteralExpression */) {
                        if (memberType === this.cachedArrayInterfaceType()) {
                            continue;
                        }

                        context.pushContextualType(memberType, true, null);
                        var argSym = this.resolveArrayLiteralExpression(args.members[j], true, enclosingDecl, context).symbol;

                        if (!this.sourceIsAssignableToTarget(argSym.getType(), memberType, context, comparisonInfo, true)) {
                            if (comparisonInfo) {
                                comparisonInfo.setMessage(TypeScript.getDiagnosticMessage(255 /* Could_not_apply_type__0__to_argument__1__which_is_of_type__2_ */, [memberType.toString(), (j + 1), argSym.getTypeName()]));
                            }
                            break;
                        }

                        argSym.invalidate();
                        cxt = context.popContextualType();

                        hadProvisionalErrors = cxt.hadProvisionalErrors();

                        if (miss) {
                            break;
                        }
                    }
                }

                if (j === args.members.length) {
                    applicableSigs[applicableSigs.length] = { signature: candidateSignatures[i], hadProvisionalErrors: hadProvisionalErrors };
                }

                hadProvisionalErrors = false;
            }

            return applicableSigs;
        };

        PullTypeResolver.prototype.findMostApplicableSignature = function (signatures, args, enclosingDecl, context) {
            if (signatures.length === 1) {
                return { sig: signatures[0].signature, ambiguous: false };
            }

            var best = signatures[0];
            var Q = null;

            var AType = null;
            var PType = null;
            var QType = null;

            var ambiguous = false;

            var bestParams;
            var qParams;

            for (var qSig = 1; qSig < signatures.length; qSig++) {
                Q = signatures[qSig];

                for (var i = 0; args && i < args.members.length; i++) {
                    var argSym = this.resolveAST(args.members[i], false, enclosingDecl, context).symbol;

                    AType = argSym.getType();

                    argSym.invalidate();

                    bestParams = best.signature.getParameters();
                    qParams = Q.signature.getParameters();

                    PType = i < bestParams.length ? bestParams[i].getType() : bestParams[bestParams.length - 1].getType().getElementType();
                    QType = i < qParams.length ? qParams[i].getType() : qParams[qParams.length - 1].getType().getElementType();

                    if (this.typesAreIdentical(PType, QType) && !(QType.isPrimitive() && (QType).isStringConstant())) {
                        continue;
                    } else if (PType.isPrimitive() && (PType).isStringConstant() && args.members[i].nodeType === 5 /* StringLiteral */ && TypeScript.stripQuotes((args.members[i]).actualText) === TypeScript.stripQuotes((PType).getName())) {
                        break;
                    } else if (QType.isPrimitive() && (QType).isStringConstant() && args.members[i].nodeType === 5 /* StringLiteral */ && TypeScript.stripQuotes((args.members[i]).actualText) === TypeScript.stripQuotes((QType).getName())) {
                        best = Q;
                    } else if (this.typesAreIdentical(AType, PType)) {
                        break;
                    } else if (this.typesAreIdentical(AType, QType)) {
                        best = Q;
                        break;
                    } else if (this.sourceIsSubtypeOfTarget(PType, QType, context)) {
                        break;
                    } else if (this.sourceIsSubtypeOfTarget(QType, PType, context)) {
                        best = Q;
                        break;
                    } else if (Q.hadProvisionalErrors) {
                        break;
                    } else if (best.hadProvisionalErrors) {
                        best = Q;
                        break;
                    }
                }

                if (!args || i === args.members.length) {
                    var collection = {
                        getLength: function () {
                            return 2;
                        },
                        setTypeAtIndex: function (index, type) {
                        },
                        getTypeAtIndex: function (index) {
                            return index ? Q.signature.getReturnType() : best.signature.getReturnType();
                        }
                    };
                    var bct = this.findBestCommonType(best.signature.getReturnType(), null, collection, context);
                    ambiguous = !bct;
                } else {
                    ambiguous = false;
                }
            }

            return { sig: best.signature, ambiguous: ambiguous };
        };

        PullTypeResolver.prototype.canApplyContextualTypeToFunction = function (candidateType, funcDecl, beStringent) {
            if (funcDecl.isMethod() || beStringent && funcDecl.returnTypeAnnotation) {
                return false;
            }

            beStringent = beStringent || (this.cachedFunctionInterfaceType() === candidateType);

            if (!beStringent) {
                return true;
            }
            var functionSymbol = this.getDeclForAST(funcDecl).getSymbol();
            var signature = functionSymbol.getType().getCallSignatures()[0];
            var parameters = signature.getParameters();
            var paramLen = parameters.length;

            for (var i = 0; i < paramLen; i++) {
                var param = parameters[i];
                var argDecl = this.getASTForDecl(param.getDeclarations()[0]);

                if (beStringent && argDecl.typeExpr) {
                    return false;
                }
            }

            if (candidateType.getConstructSignatures().length && candidateType.getCallSignatures().length) {
                return false;
            }

            var candidateSigs = candidateType.getConstructSignatures().length ? candidateType.getConstructSignatures() : candidateType.getCallSignatures();

            if (!candidateSigs || candidateSigs.length > 1) {
                return false;
            }

            return true;
        };

        PullTypeResolver.prototype.inferArgumentTypesForSignature = function (signature, args, comparisonInfo, enclosingDecl, context) {
            var cxt = null;
            var hadProvisionalErrors = false;

            var parameters = signature.getParameters();
            var typeParameters = signature.getTypeParameters();
            var argContext = new TypeScript.ArgumentInferenceContext();

            var parameterType = null;

            for (var i = 0; i < typeParameters.length; i++) {
                argContext.addInferenceRoot(typeParameters[i]);
            }

            var substitutions;
            var inferenceCandidates;
            var inferenceCandidate;

            for (var i = 0; i < args.members.length; i++) {
                if (i >= parameters.length) {
                    break;
                }

                parameterType = parameters[i].getType();

                if (signature.hasVariableParamList() && (i >= signature.getNonOptionalParameterCount() - 1) && parameterType.isArray()) {
                    parameterType = parameterType.getElementType();
                }

                inferenceCandidates = argContext.getInferenceCandidates();
                substitutions = {};

                if (inferenceCandidates.length) {
                    for (var j = 0; j < inferenceCandidates.length; j++) {
                        argContext.resetRelationshipCache();

                        inferenceCandidate = inferenceCandidates[j];

                        substitutions = inferenceCandidates[j];

                        context.pushContextualType(parameterType, true, substitutions);

                        var argSym = this.resolveAST(args.members[i], true, enclosingDecl, context).symbol;

                        this.relateTypeToTypeParameters(argSym.getType(), parameterType, false, argContext, enclosingDecl, context);

                        cxt = context.popContextualType();

                        argSym.invalidate();

                        hadProvisionalErrors = cxt.hadProvisionalErrors();
                    }
                } else {
                    context.pushContextualType(parameterType, true, {});
                    var argSym = this.resolveAST(args.members[i], true, enclosingDecl, context).symbol;

                    this.relateTypeToTypeParameters(argSym.getType(), parameterType, false, argContext, enclosingDecl, context);

                    cxt = context.popContextualType();

                    argSym.invalidate();

                    hadProvisionalErrors = cxt.hadProvisionalErrors();
                }
            }

            hadProvisionalErrors = false;

            var inferenceResults = argContext.inferArgumentTypes(this, context);

            if (inferenceResults.unfit) {
                return null;
            }

            var resultTypes = [];

            for (var i = 0; i < typeParameters.length; i++) {
                for (var j = 0; j < inferenceResults.results.length; j++) {
                    if (inferenceResults.results[j].param == typeParameters[i]) {
                        resultTypes[resultTypes.length] = inferenceResults.results[j].type;
                        break;
                    }
                }
            }

            if (!args.members.length && !resultTypes.length && typeParameters.length) {
                for (var i = 0; i < typeParameters.length; i++) {
                    resultTypes[resultTypes.length] = this.semanticInfoChain.anyTypeSymbol;
                }
            } else if (resultTypes.length && resultTypes.length < typeParameters.length) {
                for (var i = resultTypes.length; i < typeParameters.length; i++) {
                    resultTypes[i] = this.semanticInfoChain.anyTypeSymbol;
                }
            }

            return resultTypes;
        };

        PullTypeResolver.prototype.relateTypeToTypeParameters = function (expressionType, parameterType, shouldFix, argContext, enclosingDecl, context) {
            if (!expressionType || !parameterType) {
                return;
            }

            if (expressionType.isError()) {
                expressionType = this.semanticInfoChain.anyTypeSymbol;
            }

            if (parameterType === expressionType) {
                return;
            }

            if (parameterType.isTypeParameter()) {
                if (expressionType.isGeneric() && !expressionType.isFixed()) {
                    expressionType = this.specializeTypeToAny(expressionType, enclosingDecl, context);
                }
                argContext.addCandidateForInference(parameterType, expressionType, shouldFix);
                return;
            }
            var parameterDeclarations = parameterType.getDeclarations();
            var expressionDeclarations = expressionType.getDeclarations();
            if (!parameterType.isArray() && parameterDeclarations.length && expressionDeclarations.length && (parameterDeclarations[0].isEqual(expressionDeclarations[0]) || (expressionType.isGeneric() && parameterType.isGeneric() && this.sourceIsSubtypeOfTarget(expressionType, parameterType, context, null))) && expressionType.isGeneric()) {
                var typeParameters = parameterType.getIsSpecialized() ? parameterType.getTypeArguments() : parameterType.getTypeParameters();
                var typeArguments = expressionType.getTypeArguments();

                if (!typeArguments) {
                    typeParameters = parameterType.getTypeArguments();
                    typeArguments = expressionType.getIsSpecialized() ? expressionType.getTypeArguments() : expressionType.getTypeParameters();
                }

                if (typeParameters && typeArguments && typeParameters.length === typeArguments.length) {
                    for (var i = 0; i < typeParameters.length; i++) {
                        if (typeArguments[i] != typeParameters[i]) {
                            this.relateTypeToTypeParameters(typeArguments[i], typeParameters[i], true, argContext, enclosingDecl, context);
                        }
                    }
                }
            }

            var prevSpecializingToAny = context.specializingToAny;
            context.specializingToAny = true;

            if (!this.sourceIsAssignableToTarget(expressionType, parameterType, context)) {
                context.specializingToAny = prevSpecializingToAny;
                return;
            }
            context.specializingToAny = prevSpecializingToAny;

            if (expressionType.isArray() && parameterType.isArray()) {
                this.relateArrayTypeToTypeParameters(expressionType, parameterType, shouldFix, argContext, enclosingDecl, context);

                return;
            }

            this.relateObjectTypeToTypeParameters(expressionType, parameterType, shouldFix, argContext, enclosingDecl, context);
        };

        PullTypeResolver.prototype.relateFunctionSignatureToTypeParameters = function (expressionSignature, parameterSignature, argContext, enclosingDecl, context) {
            var expressionParams = expressionSignature.getParameters();
            var expressionReturnType = expressionSignature.getReturnType();

            var parameterParams = parameterSignature.getParameters();
            var parameterReturnType = parameterSignature.getReturnType();

            var len = parameterParams.length < expressionParams.length ? parameterParams.length : expressionParams.length;

            for (var i = 0; i < len; i++) {
                this.relateTypeToTypeParameters(expressionParams[i].getType(), parameterParams[i].getType(), true, argContext, enclosingDecl, context);
            }

            this.relateTypeToTypeParameters(expressionReturnType, parameterReturnType, false, argContext, enclosingDecl, context);
        };

        PullTypeResolver.prototype.relateObjectTypeToTypeParameters = function (objectType, parameterType, shouldFix, argContext, enclosingDecl, context) {
            var parameterTypeMembers = parameterType.getMembers();
            var parameterSignatures;
            var parameterSignature;

            var objectMember;
            var objectSignatures;

            if (argContext.alreadyRelatingTypes(objectType, parameterType)) {
                return;
            }

            var objectTypeArguments = objectType.getTypeArguments();
            var parameterTypeParameters = parameterType.getTypeParameters();

            if (objectTypeArguments && (objectTypeArguments.length === parameterTypeParameters.length)) {
                for (var i = 0; i < objectTypeArguments.length; i++) {
                    argContext.addCandidateForInference(parameterTypeParameters[i], objectTypeArguments[i], shouldFix);
                }
            }

            for (var i = 0; i < parameterTypeMembers.length; i++) {
                objectMember = this.getMemberSymbol(parameterTypeMembers[i].getName(), TypeScript.PullElementKind.SomeValue, objectType);

                if (objectMember) {
                    this.relateTypeToTypeParameters(objectMember.getType(), parameterTypeMembers[i].getType(), shouldFix, argContext, enclosingDecl, context);
                }
            }

            parameterSignatures = parameterType.getCallSignatures();
            objectSignatures = objectType.getCallSignatures();

            for (var i = 0; i < parameterSignatures.length; i++) {
                parameterSignature = parameterSignatures[i];

                for (var j = 0; j < objectSignatures.length; j++) {
                    this.relateFunctionSignatureToTypeParameters(objectSignatures[j], parameterSignature, argContext, enclosingDecl, context);
                }
            }

            parameterSignatures = parameterType.getConstructSignatures();
            objectSignatures = objectType.getConstructSignatures();

            for (var i = 0; i < parameterSignatures.length; i++) {
                parameterSignature = parameterSignatures[i];

                for (var j = 0; j < objectSignatures.length; j++) {
                    this.relateFunctionSignatureToTypeParameters(objectSignatures[j], parameterSignature, argContext, enclosingDecl, context);
                }
            }

            parameterSignatures = parameterType.getIndexSignatures();
            objectSignatures = objectType.getIndexSignatures();

            for (var i = 0; i < parameterSignatures.length; i++) {
                parameterSignature = parameterSignatures[i];

                for (var j = 0; j < objectSignatures.length; j++) {
                    this.relateFunctionSignatureToTypeParameters(objectSignatures[j], parameterSignature, argContext, enclosingDecl, context);
                }
            }
        };

        PullTypeResolver.prototype.relateArrayTypeToTypeParameters = function (argArrayType, parameterArrayType, shouldFix, argContext, enclosingDecl, context) {
            var argElement = argArrayType.getElementType();
            var paramElement = parameterArrayType.getElementType();

            this.relateTypeToTypeParameters(argElement, paramElement, shouldFix, argContext, enclosingDecl, context);
        };

        PullTypeResolver.prototype.specializeTypeToAny = function (typeToSpecialize, enclosingDecl, context) {
            var prevSpecialize = context.specializingToAny;

            context.specializingToAny = true;

            var rootType = TypeScript.getRootType(typeToSpecialize);

            var type = TypeScript.specializeType(rootType, [], this, enclosingDecl, context);

            context.specializingToAny = prevSpecialize;

            return type;
        };

        PullTypeResolver.prototype.specializeSignatureToAny = function (signatureToSpecialize, enclosingDecl, context) {
            var typeParameters = signatureToSpecialize.getTypeParameters();
            var typeReplacementMap = {};
            var typeArguments = [];

            for (var i = 0; i < typeParameters.length; i++) {
                typeArguments[i] = this.semanticInfoChain.anyTypeSymbol;
                typeReplacementMap[typeParameters[i].getSymbolID().toString()] = typeArguments[i];
            }
            if (!typeArguments.length) {
                typeArguments[0] = this.semanticInfoChain.anyTypeSymbol;
            }

            var prevSpecialize = context.specializingToAny;

            context.specializingToAny = true;

            var sig = TypeScript.specializeSignature(signatureToSpecialize, false, typeReplacementMap, typeArguments, this, enclosingDecl, context);
            context.specializingToAny = prevSpecialize;

            return sig;
        };
        return PullTypeResolver;
    })();
    TypeScript.PullTypeResolver = PullTypeResolver;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var PullTypeResolver2 = (function () {
        function PullTypeResolver2() {
        }
        return PullTypeResolver2;
    })();
    TypeScript.PullTypeResolver2 = PullTypeResolver2;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var TypeComparisonInfo = (function () {
        function TypeComparisonInfo(sourceComparisonInfo) {
            this.onlyCaptureFirstError = false;
            this.flags = 0 /* SuccessfulComparison */;
            this.message = "";
            this.stringConstantVal = null;
            this.indent = 1;
            if (sourceComparisonInfo) {
                this.flags = sourceComparisonInfo.flags;
                this.onlyCaptureFirstError = sourceComparisonInfo.onlyCaptureFirstError;
                this.stringConstantVal = sourceComparisonInfo.stringConstantVal;
                this.indent = sourceComparisonInfo.indent + 1;
            }
        }
        TypeComparisonInfo.prototype.addMessage = function (message) {
            if (!this.onlyCaptureFirstError && this.message) {
                this.message = TypeScript.getDiagnosticMessage(2 /* _0__NL__1_TB__2 */, [this.message, this.indent, message]);
            } else {
                this.message = TypeScript.getDiagnosticMessage(3 /* _0_TB__1 */, [this.indent, message]);
            }
        };

        TypeComparisonInfo.prototype.setMessage = function (message) {
            this.message = TypeScript.getDiagnosticMessage(3 /* _0_TB__1 */, [this.indent, message]);
        };
        return TypeComparisonInfo;
    })();
    TypeScript.TypeComparisonInfo = TypeComparisonInfo;

    var PullTypeCheckContext = (function () {
        function PullTypeCheckContext(compiler, script, scriptName) {
            this.compiler = compiler;
            this.script = script;
            this.scriptName = scriptName;
            this.enclosingDeclStack = [];
            this.enclosingDeclReturnStack = [];
            this.semanticInfo = null;
            this.inSuperConstructorCall = false;
            this.inSuperConstructorTarget = false;
            this.seenSuperConstructorCall = false;
            this.inConstructorArguments = false;
            this.inImportDeclaration = false;
        }
        PullTypeCheckContext.prototype.pushEnclosingDecl = function (decl) {
            this.enclosingDeclStack[this.enclosingDeclStack.length] = decl;
            this.enclosingDeclReturnStack[this.enclosingDeclReturnStack.length] = false;
        };

        PullTypeCheckContext.prototype.popEnclosingDecl = function () {
            this.enclosingDeclStack.length--;
            this.enclosingDeclReturnStack.length--;
        };

        PullTypeCheckContext.prototype.getEnclosingDecl = function (kind) {
            if (typeof kind === "undefined") { kind = TypeScript.PullElementKind.All; }
            for (var i = this.enclosingDeclStack.length - 1; i >= 0; i--) {
                var decl = this.enclosingDeclStack[i];
                if (decl.getKind() & kind) {
                    return decl;
                }
            }

            return null;
        };

        PullTypeCheckContext.prototype.getEnclosingNonLambdaDecl = function () {
            for (var i = this.enclosingDeclStack.length - 1; i >= 0; i--) {
                var decl = this.enclosingDeclStack[i];
                if (!(decl.getKind() === 131072 /* FunctionExpression */ && (decl.getFlags() & 8192 /* FatArrow */))) {
                    return decl;
                }
            }

            return null;
        };

        PullTypeCheckContext.prototype.getEnclosingClassDecl = function () {
            return this.getEnclosingDecl(8 /* Class */);
        };

        PullTypeCheckContext.prototype.getEnclosingDeclHasReturn = function () {
            return this.enclosingDeclReturnStack[this.enclosingDeclReturnStack.length - 1];
        };

        PullTypeCheckContext.prototype.setEnclosingDeclHasReturn = function () {
            return this.enclosingDeclReturnStack[this.enclosingDeclReturnStack.length - 1] = true;
        };
        return PullTypeCheckContext;
    })();
    TypeScript.PullTypeCheckContext = PullTypeCheckContext;

    var PullTypeChecker = (function () {
        function PullTypeChecker(compilationSettings, semanticInfoChain) {
            this.compilationSettings = compilationSettings;
            this.semanticInfoChain = semanticInfoChain;
            this.resolver = null;
            this.context = new TypeScript.PullTypeResolutionContext();
        }
        PullTypeChecker.prototype.setUnit = function (unitPath) {
            this.resolver = new TypeScript.PullTypeResolver(this.compilationSettings, this.semanticInfoChain, unitPath);
        };

        PullTypeChecker.prototype.getScriptDecl = function (fileName) {
            return this.semanticInfoChain.getUnit(fileName).getTopLevelDecls()[0];
        };

        PullTypeChecker.prototype.checkForResolutionError = function (typeSymbol, decl) {
            if (typeSymbol && typeSymbol.isError()) {
                decl.addDiagnostic((typeSymbol).getDiagnostic());
            }
        };

        PullTypeChecker.prototype.postError = function (offset, length, fileName, diagnosticCode, arguments, enclosingDecl) {
            enclosingDecl.addDiagnostic(new TypeScript.SemanticDiagnostic(fileName, offset, length, diagnosticCode, arguments));
        };

        PullTypeChecker.prototype.validateVariableDeclarationGroups = function (enclosingDecl, typeCheckContext) {
            var declGroups = enclosingDecl.getVariableDeclGroups();
            var decl;
            var firstSymbol;
            var symbol;
            var boundDeclAST;

            for (var i = 0; i < declGroups.length; i++) {
                for (var j = 0; j < declGroups[i].length; j++) {
                    decl = declGroups[i][j];
                    symbol = decl.getSymbol();
                    boundDeclAST = this.semanticInfoChain.getASTForDecl(decl);
                    this.resolver.resolveAST(boundDeclAST, false, enclosingDecl, this.context);
                    if (!j) {
                        firstSymbol = decl.getSymbol();

                        if (this.resolver.isAnyOrEquivalent(this.resolver.widenType(firstSymbol.getType()))) {
                            return;
                        }
                        continue;
                    }

                    if (!this.resolver.typesAreIdentical(symbol.getType(), firstSymbol.getType())) {
                        this.postError(boundDeclAST.minChar, boundDeclAST.getLength(), typeCheckContext.scriptName, 199 /* Subsequent_variable_declarations_must_have_the_same_type___Variable__0__must_be_of_type__1___but_here_has_type___2_ */, [symbol.getDisplayName(), firstSymbol.getType().toString(), symbol.getType().toString()], enclosingDecl);
                    }
                }
            }
        };

        PullTypeChecker.prototype.typeCheckAST = function (ast, typeCheckContext, inContextuallyTypedAssignment) {
            if (!ast) {
                return null;
            }

            if (ast.typeCheckPhase >= PullTypeChecker.globalPullTypeCheckPhase) {
                return null;
            } else {
                ast.typeCheckPhase = PullTypeChecker.globalPullTypeCheckPhase;
            }

            switch (ast.nodeType) {
                case 1 /* List */:
                    return this.typeCheckList(ast, typeCheckContext);

                case 17 /* VariableDeclarator */:
                case 19 /* Parameter */:
                    return this.typeCheckBoundDecl(ast, typeCheckContext);

                case 12 /* FunctionDeclaration */:
                    return this.typeCheckFunction(ast, typeCheckContext, inContextuallyTypedAssignment);

                case 13 /* ClassDeclaration */:
                    return this.typeCheckClass(ast, typeCheckContext);

                case 14 /* InterfaceDeclaration */:
                    return this.typeCheckInterface(ast, typeCheckContext);

                case 15 /* ModuleDeclaration */:
                    return this.typeCheckModule(ast, typeCheckContext);

                case 9 /* TypeParameter */:
                    return this.typeCheckTypeParameter(ast, typeCheckContext);

                case 16 /* ImportDeclaration */:
                    return this.typeCheckImportDeclaration(ast, typeCheckContext);

                case 38 /* AssignmentExpression */:
                    return this.typeCheckAssignment(ast, typeCheckContext);

                case 10 /* GenericType */:
                    return this.typeCheckGenericType(ast, typeCheckContext);

                case 22 /* ObjectLiteralExpression */:
                    return this.typeCheckObjectLiteral(ast, typeCheckContext, inContextuallyTypedAssignment);

                case 21 /* ArrayLiteralExpression */:
                    return this.typeCheckArrayLiteral(ast, typeCheckContext, inContextuallyTypedAssignment);

                case 29 /* ThisExpression */:
                    return this.typeCheckThisExpression(ast, typeCheckContext);

                case 30 /* SuperExpression */:
                    return this.typeCheckSuperExpression(ast, typeCheckContext);

                case 36 /* InvocationExpression */:
                    return this.typeCheckCallExpression(ast, typeCheckContext);

                case 37 /* ObjectCreationExpression */:
                    return this.typeCheckObjectCreationExpression(ast, typeCheckContext);

                case 78 /* CastExpression */:
                    return this.typeCheckTypeAssertion(ast, typeCheckContext);

                case 11 /* TypeRef */:
                    return this.typeCheckTypeReference(ast, typeCheckContext);

                case 87 /* ExportAssignment */:
                    return this.typeCheckExportAssignment(ast, typeCheckContext);

                case 57 /* NotEqualsWithTypeConversionExpression */:
                case 56 /* EqualsWithTypeConversionExpression */:
                case 58 /* EqualsExpression */:
                case 59 /* NotEqualsExpression */:
                case 60 /* LessThanExpression */:
                case 61 /* LessThanOrEqualExpression */:
                case 63 /* GreaterThanOrEqualExpression */:
                case 62 /* GreaterThanExpression */:
                    return this.typeCheckLogicalOperation(ast, typeCheckContext);

                case 25 /* CommaExpression */:
                    return this.typeCheckCommaExpression(ast, typeCheckContext);

                case 64 /* AddExpression */:
                case 39 /* AddAssignmentExpression */:
                    return this.typeCheckBinaryAdditionOperation(ast, typeCheckContext);

                case 65 /* SubtractExpression */:
                case 66 /* MultiplyExpression */:
                case 67 /* DivideExpression */:
                case 68 /* ModuloExpression */:
                case 53 /* BitwiseOrExpression */:
                case 55 /* BitwiseAndExpression */:
                case 69 /* LeftShiftExpression */:
                case 70 /* SignedRightShiftExpression */:
                case 71 /* UnsignedRightShiftExpression */:
                case 54 /* BitwiseExclusiveOrExpression */:
                case 45 /* ExclusiveOrAssignmentExpression */:
                case 47 /* LeftShiftAssignmentExpression */:
                case 48 /* SignedRightShiftAssignmentExpression */:
                case 49 /* UnsignedRightShiftAssignmentExpression */:
                case 40 /* SubtractAssignmentExpression */:
                case 42 /* MultiplyAssignmentExpression */:
                case 41 /* DivideAssignmentExpression */:
                case 43 /* ModuloAssignmentExpression */:
                case 46 /* OrAssignmentExpression */:
                case 44 /* AndAssignmentExpression */:
                    return this.typeCheckBinaryArithmeticOperation(ast, typeCheckContext);

                case 26 /* PlusExpression */:
                case 27 /* NegateExpression */:
                case 72 /* BitwiseNotExpression */:
                case 76 /* PostIncrementExpression */:
                case 74 /* PreIncrementExpression */:
                case 77 /* PostDecrementExpression */:
                case 75 /* PreDecrementExpression */:
                    return this.typeCheckUnaryArithmeticOperation(ast, typeCheckContext, inContextuallyTypedAssignment);

                case 35 /* ElementAccessExpression */:
                    return this.typeCheckElementAccessExpression(ast, typeCheckContext);

                case 73 /* LogicalNotExpression */:
                    return this.typeCheckLogicalNotExpression(ast, typeCheckContext, inContextuallyTypedAssignment);

                case 51 /* LogicalOrExpression */:
                case 52 /* LogicalAndExpression */:
                    return this.typeCheckLogicalAndOrExpression(ast, typeCheckContext);

                case 34 /* TypeOfExpression */:
                    return this.typeCheckTypeOf(ast, typeCheckContext);

                case 50 /* ConditionalExpression */:
                    return this.typeCheckConditionalExpression(ast, typeCheckContext);

                case 24 /* VoidExpression */:
                    return this.typeCheckVoidExpression(ast, typeCheckContext);

                case 95 /* ThrowStatement */:
                    return this.typeCheckThrowStatement(ast, typeCheckContext);

                case 28 /* DeleteExpression */:
                    return this.typeCheckDeleteExpression(ast, typeCheckContext);

                case 6 /* RegularExpressionLiteral */:
                    return this.typeCheckRegExpExpression(ast, typeCheckContext);

                case 31 /* InExpression */:
                    return this.typeCheckInExpression(ast, typeCheckContext);

                case 33 /* InstanceOfExpression */:
                    return this.typeCheckInstanceOfExpression(ast, typeCheckContext);

                case 79 /* ParenthesizedExpression */:
                    return this.typeCheckParenthesizedExpression(ast, typeCheckContext);

                case 90 /* ForStatement */:
                    return this.typeCheckForStatement(ast, typeCheckContext);

                case 89 /* ForInStatement */:
                    return this.typeCheckForInStatement(ast, typeCheckContext);

                case 98 /* WhileStatement */:
                    return this.typeCheckWhileStatement(ast, typeCheckContext);

                case 85 /* DoStatement */:
                    return this.typeCheckDoStatement(ast, typeCheckContext);

                case 91 /* IfStatement */:
                    return this.typeCheckIfStatement(ast, typeCheckContext);

                case 81 /* Block */:
                    return this.typeCheckBlock(ast, typeCheckContext);

                case 18 /* VariableDeclaration */:
                    return this.typeCheckVariableDeclaration(ast, typeCheckContext);

                case 97 /* VariableStatement */:
                    return this.typeCheckVariableStatement(ast, typeCheckContext);

                case 99 /* WithStatement */:
                    return this.typeCheckWithStatement(ast, typeCheckContext);

                case 96 /* TryStatement */:
                    return this.typeCheckTryStatement(ast, typeCheckContext);

                case 101 /* CatchClause */:
                    return this.typeCheckCatchClause(ast, typeCheckContext);

                case 93 /* ReturnStatement */:
                    return this.typeCheckReturnStatement(ast, typeCheckContext);

                case 20 /* Name */:
                    return this.typeCheckNameExpression(ast, typeCheckContext);

                case 32 /* MemberAccessExpression */:
                    return this.typeCheckMemberAccessExpression(ast, typeCheckContext);

                case 94 /* SwitchStatement */:
                    return this.typeCheckSwitchStatement(ast, typeCheckContext);

                case 88 /* ExpressionStatement */:
                    return this.typeCheckExpressionStatement(ast, typeCheckContext, inContextuallyTypedAssignment);

                case 100 /* CaseClause */:
                    return this.typeCheckCaseClause(ast, typeCheckContext);

                case 92 /* LabeledStatement */:
                    return this.typeCheckLabeledStatement(ast, typeCheckContext);

                case 7 /* NumericLiteral */:
                    return this.semanticInfoChain.numberTypeSymbol;

                case 5 /* StringLiteral */:
                    return this.semanticInfoChain.stringTypeSymbol;

                case 8 /* NullLiteral */:
                    return this.semanticInfoChain.nullTypeSymbol;

                case 3 /* TrueLiteral */:
                case 4 /* FalseLiteral */:
                    return this.semanticInfoChain.booleanTypeSymbol;

                case 9 /* TypeParameter */:
                    return this.typeCheckTypeParameter(ast, typeCheckContext);

                default:
                    break;
            }

            return null;
        };

        PullTypeChecker.prototype.typeCheckScript = function (script, scriptName, compiler) {
            var unit = this.semanticInfoChain.getUnit(scriptName);

            if (unit.getTypeChecked()) {
                return;
            }

            var typeCheckContext = new PullTypeCheckContext(compiler, script, scriptName);

            this.setUnit(scriptName);

            typeCheckContext.semanticInfo = typeCheckContext.compiler.semanticInfoChain.getUnit(typeCheckContext.scriptName);
            var scriptDecl = typeCheckContext.semanticInfo.getTopLevelDecls()[0];
            typeCheckContext.pushEnclosingDecl(scriptDecl);

            PullTypeChecker.globalPullTypeCheckPhase++;

            this.typeCheckAST(script.moduleElements, typeCheckContext, false);

            this.validateVariableDeclarationGroups(scriptDecl, typeCheckContext);

            typeCheckContext.popEnclosingDecl();

            unit.setTypeChecked();
        };

        PullTypeChecker.prototype.typeCheckList = function (list, typeCheckContext) {
            if (!list) {
                return null;
            }

            for (var i = 0; i < list.members.length; i++) {
                this.typeCheckAST(list.members[i], typeCheckContext, false);
            }
        };

        PullTypeChecker.prototype.reportDiagnostics = function (symbolAndDiagnostics, enclosingDecl) {
            if (symbolAndDiagnostics && symbolAndDiagnostics.diagnostics) {
                for (var i = 0, n = symbolAndDiagnostics.diagnostics.length; i < n; i++) {
                    this.context.postDiagnostic(symbolAndDiagnostics.diagnostics[i], enclosingDecl, true);
                }
            }
        };

        PullTypeChecker.prototype.resolveSymbolAndReportDiagnostics = function (ast, inContextuallyTypedAssignment, enclosingDecl) {
            var symbolAndDiagnostics = this.resolver.resolveAST(ast, inContextuallyTypedAssignment, enclosingDecl, this.context);

            this.reportDiagnostics(symbolAndDiagnostics, enclosingDecl);
            return symbolAndDiagnostics && symbolAndDiagnostics.symbol;
        };

        PullTypeChecker.prototype.typeCheckBoundDecl = function (ast, typeCheckContext) {
            var _this = this;
            var boundDeclAST = ast;

            var enclosingDecl = typeCheckContext.getEnclosingDecl();

            var typeExprSymbol = null;

            if (boundDeclAST.typeExpr) {
                typeExprSymbol = this.typeCheckAST(boundDeclAST.typeExpr, typeCheckContext, false);

                if (typeExprSymbol.isNamedTypeSymbol() && typeExprSymbol.isGeneric() && !typeExprSymbol.isTypeParameter() && !this.resolver.isArrayOrEquivalent(typeExprSymbol) && typeExprSymbol.isResolved() && typeExprSymbol.getTypeParameters().length && typeExprSymbol.getTypeArguments() == null && !typeExprSymbol.getIsSpecialized() && this.resolver.isTypeRefWithoutTypeArgs(boundDeclAST.typeExpr)) {
                    this.postError(boundDeclAST.typeExpr.minChar, boundDeclAST.typeExpr.getLength(), typeCheckContext.scriptName, 239 /* Generic_type_references_must_include_all_type_arguments */, null, enclosingDecl);
                    typeExprSymbol = this.resolver.specializeTypeToAny(typeExprSymbol, enclosingDecl, this.context);
                }
            }

            if (boundDeclAST.init) {
                if (typeExprSymbol) {
                    this.context.pushContextualType(typeExprSymbol, this.context.inProvisionalResolution(), null);
                }

                var initTypeSymbol = this.typeCheckAST(boundDeclAST.init, typeCheckContext, !!typeExprSymbol);

                if (typeExprSymbol) {
                    this.context.popContextualType();
                }

                if (typeExprSymbol && typeExprSymbol.isContainer()) {
                    var exportedTypeSymbol = (typeExprSymbol).getExportAssignedTypeSymbol();

                    if (exportedTypeSymbol) {
                        typeExprSymbol = exportedTypeSymbol;
                    } else {
                        var instanceTypeSymbol = (typeExprSymbol.getType()).getInstanceSymbol().getType();

                        if (!instanceTypeSymbol || !TypeScript.PullHelpers.symbolIsEnum(instanceTypeSymbol)) {
                            this.postError(boundDeclAST.minChar, boundDeclAST.getLength(), typeCheckContext.scriptName, 190 /* Tried_to_set_variable_type_to_module_type__0__ */, [typeExprSymbol.toString()], enclosingDecl);
                            typeExprSymbol = null;
                        } else {
                            typeExprSymbol = instanceTypeSymbol.getType();
                        }
                    }
                }

                if (initTypeSymbol && initTypeSymbol.isContainer()) {
                    instanceTypeSymbol = (initTypeSymbol.getType()).getInstanceSymbol().getType();

                    if (!instanceTypeSymbol) {
                        this.postError(boundDeclAST.minChar, boundDeclAST.getLength(), typeCheckContext.scriptName, 191 /* Tried_to_set_variable_type_to_uninitialized_module_type__0__ */, [initTypeSymbol.toString()], enclosingDecl);
                        initTypeSymbol = null;
                    } else {
                        initTypeSymbol = instanceTypeSymbol.getType();
                    }
                }

                if (initTypeSymbol && typeExprSymbol) {
                    var comparisonInfo = new TypeComparisonInfo();

                    var isAssignable = this.resolver.sourceIsAssignableToTarget(initTypeSymbol, typeExprSymbol, this.context, comparisonInfo);

                    if (!isAssignable) {
                        if (comparisonInfo.message) {
                            this.postError(boundDeclAST.minChar, boundDeclAST.getLength(), typeCheckContext.scriptName, 81 /* Cannot_convert__0__to__1__NL__2 */, [initTypeSymbol.toString(), typeExprSymbol.toString(), comparisonInfo.message], enclosingDecl);
                        } else {
                            this.postError(boundDeclAST.minChar, boundDeclAST.getLength(), typeCheckContext.scriptName, 80 /* Cannot_convert__0__to__1_ */, [initTypeSymbol.toString(), typeExprSymbol.toString()], enclosingDecl);
                        }
                    }
                }
            }

            var prevSupressErrors = this.context.suppressErrors;
            this.context.suppressErrors = true;
            var decl = this.resolver.getDeclForAST(boundDeclAST);

            var varTypeSymbol = this.resolveSymbolAndReportDiagnostics(boundDeclAST, false, enclosingDecl).getType();

            if (typeExprSymbol && typeExprSymbol.isContainer() && varTypeSymbol.isError()) {
                this.checkForResolutionError(varTypeSymbol, decl);
            }

            this.context.suppressErrors = prevSupressErrors;

            var declSymbol = decl.getSymbol();

            if (declSymbol.getKind() != 2048 /* Parameter */ && (declSymbol.getKind() != 4096 /* Property */ || declSymbol.getContainer().isNamedTypeSymbol())) {
                this.checkTypePrivacy(declSymbol, varTypeSymbol, typeCheckContext, function (typeSymbol) {
                    return _this.variablePrivacyErrorReporter(declSymbol, typeSymbol, typeCheckContext);
                });
            }

            return varTypeSymbol;
        };

        PullTypeChecker.prototype.typeCheckImportDeclaration = function (importDeclaration, typeCheckContext) {
            var result = this.resolveSymbolAndReportDiagnostics(importDeclaration, false, typeCheckContext.getEnclosingDecl());

            var savedInImportDeclaration = typeCheckContext.inImportDeclaration;
            typeCheckContext.inImportDeclaration = true;
            this.typeCheckAST(importDeclaration.alias, typeCheckContext, false);
            typeCheckContext.inImportDeclaration = savedInImportDeclaration;

            return result;
        };

        PullTypeChecker.prototype.typeCheckFunction = function (funcDeclAST, typeCheckContext, inContextuallyTypedAssignment) {
            if (funcDeclAST.isConstructor || TypeScript.hasFlag(funcDeclAST.getFunctionFlags(), 1024 /* ConstructMember */)) {
                return this.typeCheckConstructor(funcDeclAST, typeCheckContext, inContextuallyTypedAssignment);
            } else if (TypeScript.hasFlag(funcDeclAST.getFunctionFlags(), 4096 /* IndexerMember */)) {
                return this.typeCheckIndexer(funcDeclAST, typeCheckContext, inContextuallyTypedAssignment);
            } else if (funcDeclAST.isAccessor()) {
                return this.typeCheckAccessor(funcDeclAST, typeCheckContext, inContextuallyTypedAssignment);
            }

            var enclosingDecl = typeCheckContext.getEnclosingDecl();

            var functionSymbol = this.resolveSymbolAndReportDiagnostics(funcDeclAST, inContextuallyTypedAssignment, enclosingDecl);
            var functionDecl = typeCheckContext.semanticInfo.getDeclForAST(funcDeclAST);

            typeCheckContext.pushEnclosingDecl(functionDecl);

            this.typeCheckAST(funcDeclAST.typeArguments, typeCheckContext, inContextuallyTypedAssignment);
            this.typeCheckAST(funcDeclAST.arguments, typeCheckContext, inContextuallyTypedAssignment);
            this.typeCheckAST(funcDeclAST.returnTypeAnnotation, typeCheckContext, false);
            this.typeCheckAST(funcDeclAST.block, typeCheckContext, false);

            var hasReturn = typeCheckContext.getEnclosingDeclHasReturn();

            this.validateVariableDeclarationGroups(functionDecl, typeCheckContext);

            typeCheckContext.popEnclosingDecl();

            var functionSignature = functionDecl.getSignatureSymbol();

            var parameters = functionSignature.getParameters();

            if (parameters.length) {
                for (var i = 0; i < parameters.length; i++) {
                    this.checkForResolutionError(parameters[i].getType(), enclosingDecl);
                }
            }

            var returnType = functionSignature.getReturnType();

            this.checkForResolutionError(returnType, enclosingDecl);

            if (funcDeclAST.block && funcDeclAST.returnTypeAnnotation != null && !hasReturn) {
                var isVoidOrAny = this.resolver.isAnyOrEquivalent(returnType) || returnType === this.semanticInfoChain.voidTypeSymbol;

                if (!isVoidOrAny && !(funcDeclAST.block.statements.members.length > 0 && funcDeclAST.block.statements.members[0].nodeType === 95 /* ThrowStatement */)) {
                    var funcName = functionDecl.getDisplayName();
                    funcName = funcName ? "'" + funcName + "'" : "expression";

                    this.postError(funcDeclAST.returnTypeAnnotation.minChar, funcDeclAST.returnTypeAnnotation.getLength(), typeCheckContext.scriptName, 192 /* Function__0__declared_a_non_void_return_type__but_has_no_return_expression */, [funcName], typeCheckContext.getEnclosingDecl());
                }
            }

            this.typeCheckFunctionOverloads(funcDeclAST, typeCheckContext);
            this.checkFunctionTypePrivacy(funcDeclAST, inContextuallyTypedAssignment, typeCheckContext);

            return functionSymbol ? functionSymbol.getType() : null;
        };

        PullTypeChecker.prototype.typeCheckFunctionOverloads = function (funcDecl, typeCheckContext, signature, allSignatures) {
            if (!signature) {
                var functionSignatureInfo = TypeScript.PullHelpers.getSignatureForFuncDecl(funcDecl, typeCheckContext.semanticInfo);
                signature = functionSignatureInfo.signature;
                allSignatures = functionSignatureInfo.allSignatures;
            }
            var functionDeclaration = typeCheckContext.semanticInfo.getDeclForAST(funcDecl);
            var funcSymbol = functionDeclaration.getSymbol();

            var definitionSignature = null;
            for (var i = allSignatures.length - 1; i >= 0; i--) {
                if (allSignatures[i].isDefinition()) {
                    definitionSignature = allSignatures[i];
                    break;
                }
            }

            if (!signature.isDefinition()) {
                for (var i = 0; i < allSignatures.length; i++) {
                    if (allSignatures[i] === signature) {
                        break;
                    }

                    if (this.resolver.signaturesAreIdentical(allSignatures[i], signature)) {
                        if (funcDecl.isConstructor) {
                            this.postError(funcDecl.minChar, funcDecl.getLength(), typeCheckContext.scriptName, 210 /* Duplicate_constructor_overload_signature */, null, typeCheckContext.getEnclosingDecl());
                        } else if (funcDecl.isConstructMember()) {
                            this.postError(funcDecl.minChar, funcDecl.getLength(), typeCheckContext.scriptName, 212 /* Duplicate_overload_construct_signature */, null, typeCheckContext.getEnclosingDecl());
                        } else if (funcDecl.isCallMember()) {
                            this.postError(funcDecl.minChar, funcDecl.getLength(), typeCheckContext.scriptName, 211 /* Duplicate_overload_call_signature */, null, typeCheckContext.getEnclosingDecl());
                        } else {
                            this.postError(funcDecl.minChar, funcDecl.getLength(), typeCheckContext.scriptName, 209 /* Duplicate_overload_signature_for__0_ */, [funcSymbol.getScopedNameEx().toString()], typeCheckContext.getEnclosingDecl());
                        }

                        break;
                    }
                }
            }

            var isConstantOverloadSignature = signature.isStringConstantOverloadSignature();
            if (isConstantOverloadSignature) {
                if (signature.isDefinition()) {
                    this.postError(funcDecl.minChar, funcDecl.getLength(), typeCheckContext.scriptName, 229 /* Overload_signature_implementation_cannot_use_specialized_type */, null, typeCheckContext.getEnclosingDecl());
                } else {
                    var resolutionContext = new TypeScript.PullTypeResolutionContext();
                    var foundSubtypeSignature = false;
                    for (var i = 0; i < allSignatures.length; i++) {
                        if (allSignatures[i].isDefinition() || allSignatures[i] === signature) {
                            continue;
                        }

                        if (!allSignatures[i].isResolved()) {
                            this.resolver.resolveDeclaredSymbol(allSignatures[i], typeCheckContext.getEnclosingDecl(), resolutionContext);
                        }

                        if (allSignatures[i].isStringConstantOverloadSignature()) {
                            continue;
                        }

                        if (this.resolver.signatureIsSubtypeOfTarget(signature, allSignatures[i], resolutionContext)) {
                            foundSubtypeSignature = true;
                            break;
                        }
                    }

                    if (!foundSubtypeSignature) {
                        this.postError(funcDecl.minChar, funcDecl.getLength(), typeCheckContext.scriptName, 219 /* Specialized_overload_signature_is_not_subtype_of_any_non_specialized_signature */, null, typeCheckContext.getEnclosingDecl());
                    }
                }
            } else if (definitionSignature && definitionSignature != signature) {
                var comparisonInfo = new TypeComparisonInfo();
                var resolutionContext = new TypeScript.PullTypeResolutionContext();
                if (!definitionSignature.isResolved()) {
                    this.resolver.resolveDeclaredSymbol(definitionSignature, typeCheckContext.getEnclosingDecl(), resolutionContext);
                }

                if (!this.resolver.signatureIsAssignableToTarget(definitionSignature, signature, resolutionContext, comparisonInfo)) {
                    if (comparisonInfo.message) {
                        this.postError(funcDecl.minChar, funcDecl.getLength(), typeCheckContext.scriptName, 214 /* Overload_signature_is_not_compatible_with_function_definition__NL__0 */, [comparisonInfo.message], typeCheckContext.getEnclosingDecl());
                    } else {
                        this.postError(funcDecl.minChar, funcDecl.getLength(), typeCheckContext.scriptName, 213 /* Overload_signature_is_not_compatible_with_function_definition */, null, typeCheckContext.getEnclosingDecl());
                    }
                }
            }

            var signatureForVisibilityCheck = definitionSignature;
            if (!definitionSignature) {
                if (allSignatures[0] === signature) {
                    return;
                }
                signatureForVisibilityCheck = allSignatures[0];
            }

            if (!funcDecl.isConstructor && !funcDecl.isConstructMember() && signature != signatureForVisibilityCheck) {
                var errorCode;

                if (signatureForVisibilityCheck.hasFlag(2 /* Private */) != signature.hasFlag(2 /* Private */)) {
                    errorCode = 215 /* Overload_signatures_must_all_be_public_or_private */;
                } else if (signatureForVisibilityCheck.hasFlag(1 /* Exported */) != signature.hasFlag(1 /* Exported */)) {
                    errorCode = 216 /* Overload_signatures_must_all_be_exported_or_local */;
                } else if (signatureForVisibilityCheck.hasFlag(8 /* Ambient */) != signature.hasFlag(8 /* Ambient */)) {
                    errorCode = 217 /* Overload_signatures_must_all_be_ambient_or_non_ambient */;
                } else if (signatureForVisibilityCheck.hasFlag(128 /* Optional */) != signature.hasFlag(128 /* Optional */)) {
                    errorCode = 218 /* Overload_signatures_must_all_be_optional_or_required */;
                }

                if (errorCode) {
                    this.postError(funcDecl.minChar, funcDecl.getLength(), typeCheckContext.scriptName, errorCode, null, typeCheckContext.getEnclosingDecl());
                }
            }
        };

        PullTypeChecker.prototype.typeCheckTypeParameter = function (typeParameter, typeCheckContext) {
            if (typeParameter.constraint) {
                var constraintType = this.typeCheckAST(typeParameter.constraint, typeCheckContext, false);

                if (constraintType && !constraintType.isError() && constraintType.isPrimitive()) {
                    this.postError(typeParameter.constraint.minChar, typeParameter.constraint.getLength(), typeCheckContext.scriptName, 149 /* Type_parameter_constraint_cannot_be_a_primitive_type */, null, typeCheckContext.getEnclosingDecl());
                }
            }

            return this.resolveSymbolAndReportDiagnostics(typeParameter, false, typeCheckContext.getEnclosingDecl());
        };

        PullTypeChecker.prototype.typeCheckAccessor = function (ast, typeCheckContext, inContextuallyTypedAssignment) {
            var funcDeclAST = ast;

            var enclosingDecl = typeCheckContext.getEnclosingDecl();

            var accessorSymbol = this.resolveSymbolAndReportDiagnostics(ast, inContextuallyTypedAssignment, enclosingDecl);
            this.checkForResolutionError(accessorSymbol.getType(), enclosingDecl);

            var isGetter = TypeScript.hasFlag(funcDeclAST.getFunctionFlags(), 32 /* GetAccessor */);
            var isSetter = !isGetter;

            var getter = accessorSymbol.getGetter();
            var setter = accessorSymbol.getSetter();

            var functionDecl = typeCheckContext.semanticInfo.getDeclForAST(funcDeclAST);
            typeCheckContext.pushEnclosingDecl(functionDecl);

            this.typeCheckAST(funcDeclAST.arguments, typeCheckContext, inContextuallyTypedAssignment);

            this.typeCheckAST(funcDeclAST.block, typeCheckContext, false);

            var hasReturn = typeCheckContext.getEnclosingDeclHasReturn();

            this.validateVariableDeclarationGroups(functionDecl, typeCheckContext);

            typeCheckContext.popEnclosingDecl();

            var functionSignature = functionDecl.getSignatureSymbol();

            var parameters = functionSignature.getParameters();

            var returnType = functionSignature.getReturnType();

            this.checkForResolutionError(returnType, enclosingDecl);

            var funcNameAST = funcDeclAST.name;

            if (isGetter && !hasReturn) {
                if (!(funcDeclAST.block.statements.members.length > 0 && funcDeclAST.block.statements.members[0].nodeType === 95 /* ThrowStatement */)) {
                    this.postError(funcNameAST.minChar, funcNameAST.getLength(), typeCheckContext.scriptName, 193 /* Getters_must_return_a_value */, null, typeCheckContext.getEnclosingDecl());
                }
            }

            if (getter && setter) {
                var getterDecl = getter.getDeclarations()[0];
                var setterDecl = setter.getDeclarations()[0];

                var getterIsPrivate = getterDecl.getFlags() & 2 /* Private */;
                var setterIsPrivate = setterDecl.getFlags() & 2 /* Private */;

                if (getterIsPrivate != setterIsPrivate) {
                    this.postError(funcNameAST.minChar, funcNameAST.getLength(), typeCheckContext.scriptName, 194 /* Getter_and_setter_accessors_do_not_agree_in_visibility */, null, typeCheckContext.getEnclosingDecl());
                }
            }

            this.checkFunctionTypePrivacy(funcDeclAST, inContextuallyTypedAssignment, typeCheckContext);

            return null;
        };

        PullTypeChecker.prototype.typeCheckConstructor = function (funcDeclAST, typeCheckContext, inContextuallyTypedAssignment) {
            var enclosingDecl = typeCheckContext.getEnclosingDecl();

            var functionSymbol = this.resolveSymbolAndReportDiagnostics(funcDeclAST, inContextuallyTypedAssignment, enclosingDecl);

            var functionDecl = typeCheckContext.semanticInfo.getDeclForAST(funcDeclAST);
            typeCheckContext.pushEnclosingDecl(functionDecl);

            this.typeCheckAST(funcDeclAST.typeArguments, typeCheckContext, inContextuallyTypedAssignment);

            typeCheckContext.inConstructorArguments = true;
            this.typeCheckAST(funcDeclAST.arguments, typeCheckContext, inContextuallyTypedAssignment);
            typeCheckContext.inConstructorArguments = false;

            typeCheckContext.seenSuperConstructorCall = false;

            this.typeCheckAST(funcDeclAST.returnTypeAnnotation, typeCheckContext, false);

            this.typeCheckAST(funcDeclAST.block, typeCheckContext, false);

            this.validateVariableDeclarationGroups(functionDecl, typeCheckContext);

            typeCheckContext.popEnclosingDecl();

            var constructorSignature = functionDecl.getSignatureSymbol();

            var parameters = constructorSignature.getParameters();

            if (parameters.length) {
                for (var i = 0, n = parameters.length; i < n; i++) {
                    this.checkForResolutionError(parameters[i].getType(), enclosingDecl);
                }
            }

            this.checkForResolutionError(constructorSignature.getReturnType(), enclosingDecl);

            if (functionDecl.getSignatureSymbol() && functionDecl.getSignatureSymbol().isDefinition() && this.enclosingClassIsDerived(typeCheckContext)) {
                if (!typeCheckContext.seenSuperConstructorCall) {
                    this.postError(funcDeclAST.minChar, 11, typeCheckContext.scriptName, 173 /* Constructors_for_derived_classes_must_contain_a__super__call */, null, enclosingDecl);
                } else if (this.superCallMustBeFirstStatementInConstructor(functionDecl, enclosingDecl)) {
                    var firstStatement = this.getFirstStatementFromFunctionDeclAST(funcDeclAST);
                    if (!firstStatement || !this.isSuperCallNode(firstStatement)) {
                        this.postError(funcDeclAST.minChar, 11, typeCheckContext.scriptName, 172 /* A__super__call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_intialized_properties_or_has_parameter_properties */, null, enclosingDecl);
                    }
                }
            }

            this.typeCheckFunctionOverloads(funcDeclAST, typeCheckContext);
            this.checkFunctionTypePrivacy(funcDeclAST, inContextuallyTypedAssignment, typeCheckContext);
            return functionSymbol ? functionSymbol.getType() : null;
        };

        PullTypeChecker.prototype.typeCheckIndexer = function (ast, typeCheckContext, inContextuallyTypedAssignment) {
            var enclosingDecl = typeCheckContext.getEnclosingDecl();

            this.resolver.resolveAST(ast, inContextuallyTypedAssignment, enclosingDecl, this.context);

            var funcDeclAST = ast;

            var functionDecl = typeCheckContext.semanticInfo.getDeclForAST(funcDeclAST);
            typeCheckContext.pushEnclosingDecl(functionDecl);

            this.typeCheckAST(funcDeclAST.arguments, typeCheckContext, false);

            this.typeCheckAST(funcDeclAST.returnTypeAnnotation, typeCheckContext, false);

            typeCheckContext.popEnclosingDecl();

            var indexSignature = functionDecl.getSignatureSymbol();
            var parameters = indexSignature.getParameters();

            if (parameters.length) {
                var parameterType = null;

                for (var i = 0; i < parameters.length; i++) {
                    this.checkForResolutionError(parameters[i].getType(), enclosingDecl);
                }
            }

            this.checkForResolutionError(indexSignature.getReturnType(), enclosingDecl);
            this.checkFunctionTypePrivacy(funcDeclAST, inContextuallyTypedAssignment, typeCheckContext);

            var isNumericIndexer = parameters[0].getType() === this.semanticInfoChain.numberTypeSymbol;

            var allIndexSignatures = enclosingDecl.getSymbol().getType().getIndexSignatures();
            for (var i = 0; i < allIndexSignatures.length; i++) {
                if (!allIndexSignatures[i].isResolved()) {
                    this.resolver.resolveDeclaredSymbol(allIndexSignatures[i], allIndexSignatures[i].getDeclarations()[0].getParentDecl(), this.context);
                }
                if (allIndexSignatures[i].getParameters()[0].getType() !== parameters[0].getType()) {
                    var stringIndexSignature;
                    var numberIndexSignature;
                    if (isNumericIndexer) {
                        numberIndexSignature = indexSignature;
                        stringIndexSignature = allIndexSignatures[i];
                    } else {
                        numberIndexSignature = allIndexSignatures[i];
                        stringIndexSignature = indexSignature;

                        if (enclosingDecl.getSymbol() === numberIndexSignature.getDeclarations()[0].getParentDecl().getSymbol()) {
                            break;
                        }
                    }
                    var comparisonInfo = new TypeComparisonInfo();
                    var resolutionContext = new TypeScript.PullTypeResolutionContext();
                    if (!this.resolver.sourceIsSubtypeOfTarget(numberIndexSignature.getReturnType(), stringIndexSignature.getReturnType(), resolutionContext, comparisonInfo)) {
                        if (comparisonInfo.message) {
                            this.postError(funcDeclAST.minChar, funcDeclAST.getLength(), typeCheckContext.scriptName, 234 /* Numeric_indexer_type___0___must_be_a_subtype_of_string_indexer_type___1____NL__2 */, [numberIndexSignature.getReturnType().toString(), stringIndexSignature.getReturnType().toString(), comparisonInfo.message], typeCheckContext.getEnclosingDecl());
                        } else {
                            this.postError(funcDeclAST.minChar, funcDeclAST.getLength(), typeCheckContext.scriptName, 233 /* Numeric_indexer_type___0___must_be_a_subtype_of_string_indexer_type___1__ */, [numberIndexSignature.getReturnType().toString(), stringIndexSignature.getReturnType().toString()], typeCheckContext.getEnclosingDecl());
                        }
                    }
                    break;
                }
            }

            var allMembers = enclosingDecl.getSymbol().getType().getAllMembers(TypeScript.PullElementKind.All, true);
            for (var i = 0; i < allMembers.length; i++) {
                var name = allMembers[i].getName();
                if (name) {
                    if (!allMembers[i].isResolved()) {
                        this.resolver.resolveDeclaredSymbol(allMembers[i], allMembers[i].getDeclarations()[0].getParentDecl(), this.context);
                    }

                    if (enclosingDecl.getSymbol() !== allMembers[i].getContainer()) {
                        var isMemberNumeric = isFinite(+name);
                        if (isNumericIndexer === isMemberNumeric) {
                            this.checkThatMemberIsSubtypeOfIndexer(allMembers[i], indexSignature, funcDeclAST, typeCheckContext, isNumericIndexer);
                        }
                    }
                }
            }

            return null;
        };

        PullTypeChecker.prototype.typeCheckMembersAgainstIndexer = function (containerType, typeCheckContext) {
            var indexSignatures = containerType.getIndexSignatures();
            if (indexSignatures.length > 0) {
                var members = typeCheckContext.getEnclosingDecl().getChildDecls();
                for (var i = 0; i < members.length; i++) {
                    var member = members[i];
                    if (!member.getName() || member.getKind() & TypeScript.PullElementKind.SomeSignature) {
                        continue;
                    }

                    var isMemberNumeric = isFinite(+member.getName());
                    for (var j = 0; j < indexSignatures.length; j++) {
                        if (!indexSignatures[j].isResolved()) {
                            this.resolver.resolveDeclaredSymbol(indexSignatures[j], indexSignatures[j].getDeclarations()[0].getParentDecl(), this.context);
                        }
                        if ((indexSignatures[j].getParameters()[0].getType() === this.semanticInfoChain.numberTypeSymbol) === isMemberNumeric) {
                            this.checkThatMemberIsSubtypeOfIndexer(member.getSymbol(), indexSignatures[j], this.semanticInfoChain.getASTForDecl(member), typeCheckContext, isMemberNumeric);
                            break;
                        }
                    }
                }
            }
        };

        PullTypeChecker.prototype.checkThatMemberIsSubtypeOfIndexer = function (member, indexSignature, astForError, typeCheckContext, isNumeric) {
            var comparisonInfo = new TypeComparisonInfo();
            var resolutionContext = new TypeScript.PullTypeResolutionContext();
            if (!this.resolver.sourceIsSubtypeOfTarget(member.getType(), indexSignature.getReturnType(), resolutionContext, comparisonInfo)) {
                if (isNumeric) {
                    if (comparisonInfo.message) {
                        this.postError(astForError.minChar, astForError.getLength(), typeCheckContext.scriptName, 236 /* All_numerically_named_properties_must_be_subtypes_of_numeric_indexer_type___0____NL__1 */, [indexSignature.getReturnType().toString(), comparisonInfo.message], typeCheckContext.getEnclosingDecl());
                    } else {
                        this.postError(astForError.minChar, astForError.getLength(), typeCheckContext.scriptName, 235 /* All_numerically_named_properties_must_be_subtypes_of_numeric_indexer_type___0__ */, [indexSignature.getReturnType().toString()], typeCheckContext.getEnclosingDecl());
                    }
                } else {
                    if (comparisonInfo.message) {
                        this.postError(astForError.minChar, astForError.getLength(), typeCheckContext.scriptName, 238 /* All_named_properties_must_be_subtypes_of_string_indexer_type___0____NL__1 */, [indexSignature.getReturnType().toString(), comparisonInfo.message], typeCheckContext.getEnclosingDecl());
                    } else {
                        this.postError(astForError.minChar, astForError.getLength(), typeCheckContext.scriptName, 237 /* All_named_properties_must_be_subtypes_of_string_indexer_type___0__ */, [indexSignature.getReturnType().toString()], typeCheckContext.getEnclosingDecl());
                    }
                }
            }
        };

        PullTypeChecker.prototype.typeCheckIfTypeMemberPropertyOkToOverride = function (typeSymbol, extendedType, typeMember, extendedTypeMember, comparisonInfo) {
            if (!typeSymbol.isClass()) {
                return true;
            }

            var typeMemberKind = typeMember.getKind();
            var extendedMemberKind = extendedTypeMember.getKind();

            if (typeMemberKind === extendedMemberKind) {
                return true;
            }

            var errorCode;
            if (typeMemberKind === 4096 /* Property */) {
                if (typeMember.isAccessor()) {
                    errorCode = 256 /* Class__0__defines_instance_member_accessor__1___but_extended_class__2__defines_it_as_instance_member_function */;
                } else {
                    errorCode = 257 /* Class__0__defines_instance_member_property__1___but_extended_class__2__defines_it_as_instance_member_function */;
                }
            } else if (typeMemberKind === 65536 /* Method */) {
                if (extendedTypeMember.isAccessor()) {
                    errorCode = 258 /* Class__0__defines_instance_member_function__1___but_extended_class__2__defines_it_as_instance_member_accessor */;
                } else {
                    errorCode = 259 /* Class__0__defines_instance_member_function__1___but_extended_class__2__defines_it_as_instance_member_property */;
                }
            }

            var message = TypeScript.getDiagnosticMessage(errorCode, [typeSymbol.toString(), typeMember.getScopedNameEx().toString(), extendedType.toString()]);
            comparisonInfo.addMessage(message);
            return false;
        };

        PullTypeChecker.prototype.typeCheckIfTypeExtendsType = function (typeDecl, typeSymbol, extendedType, typeCheckContext) {
            var typeMembers = typeSymbol.getMembers();

            var resolutionContext = new TypeScript.PullTypeResolutionContext();
            var comparisonInfo = new TypeComparisonInfo();
            var foundError = false;

            for (var i = 0; i < typeMembers.length; i++) {
                var propName = typeMembers[i].getName();
                var extendedTypeProp = extendedType.findMember(propName);
                if (extendedTypeProp) {
                    foundError = !this.typeCheckIfTypeMemberPropertyOkToOverride(typeSymbol, extendedType, typeMembers[i], extendedTypeProp, comparisonInfo);

                    if (!foundError) {
                        foundError = !this.resolver.sourcePropertyIsSubtypeOfTargetProperty(typeSymbol, extendedType, typeMembers[i], extendedTypeProp, resolutionContext, comparisonInfo);
                    }

                    if (foundError) {
                        break;
                    }
                }
            }

            if (!foundError && typeSymbol.hasOwnCallSignatures()) {
                foundError = !this.resolver.sourceCallSignaturesAreSubtypeOfTargetCallSignatures(typeSymbol, extendedType, resolutionContext, comparisonInfo);
            }

            if (!foundError && typeSymbol.hasOwnConstructSignatures()) {
                foundError = !this.resolver.sourceConstructSignaturesAreSubtypeOfTargetConstructSignatures(typeSymbol, extendedType, resolutionContext, comparisonInfo);
            }

            if (!foundError && typeSymbol.hasOwnIndexSignatures()) {
                foundError = !this.resolver.sourceIndexSignaturesAreSubtypeOfTargetIndexSignatures(typeSymbol, extendedType, resolutionContext, comparisonInfo);
            }

            if (!foundError && typeSymbol.isClass()) {
                var typeConstructorType = (typeSymbol).getConstructorMethod().getType();
                var typeConstructorTypeMembers = typeConstructorType.getMembers();
                if (typeConstructorTypeMembers.length) {
                    var extendedConstructorType = (extendedType).getConstructorMethod().getType();
                    var comparisonInfoForPropTypeCheck = new TypeComparisonInfo(comparisonInfo);

                    for (var i = 0; i < typeConstructorTypeMembers.length; i++) {
                        var propName = typeConstructorTypeMembers[i].getName();
                        var extendedConstructorTypeProp = extendedConstructorType.findMember(propName);
                        if (extendedConstructorTypeProp) {
                            if (!extendedConstructorTypeProp.isResolved()) {
                                var extendedClassAst = typeCheckContext.semanticInfo.getASTForSymbol(extendedType);
                                var extendedClassDecl = typeCheckContext.semanticInfo.getDeclForAST(extendedClassAst);
                                this.resolver.resolveDeclaredSymbol(extendedConstructorTypeProp, extendedClassDecl, resolutionContext);
                            }

                            var typeConstructorTypePropType = typeConstructorTypeMembers[i].getType();
                            var extendedConstructorTypePropType = extendedConstructorTypeProp.getType();
                            if (!this.resolver.sourceIsSubtypeOfTarget(typeConstructorTypePropType, extendedConstructorTypePropType, resolutionContext, comparisonInfoForPropTypeCheck)) {
                                var propMessage;
                                if (comparisonInfoForPropTypeCheck.message) {
                                    propMessage = TypeScript.getDiagnosticMessage(261 /* Types_of_static_property__0__of_class__1__and_class__2__are_incompatible__NL__3 */, [extendedConstructorTypeProp.getScopedNameEx().toString(), typeSymbol.toString(), extendedType.toString(), comparisonInfoForPropTypeCheck.message]);
                                } else {
                                    propMessage = TypeScript.getDiagnosticMessage(260 /* Types_of_static_property__0__of_class__1__and_class__2__are_incompatible */, [extendedConstructorTypeProp.getScopedNameEx().toString(), typeSymbol.toString(), extendedType.toString()]);
                                }
                                comparisonInfo.addMessage(propMessage);
                                foundError = true;
                                break;
                            }
                        }
                    }
                }
            }

            if (foundError) {
                var errorCode;
                if (typeSymbol.isClass()) {
                    errorCode = 206 /* Class__0__cannot_extend_class__1__NL__2 */;
                } else {
                    if (extendedType.isClass()) {
                        errorCode = 207 /* Interface__0__cannot_extend_class__1__NL__2 */;
                    } else {
                        errorCode = 208 /* Interface__0__cannot_extend_interface__1__NL__2 */;
                    }
                }

                this.postError(typeDecl.name.minChar, typeDecl.name.getLength(), typeCheckContext.scriptName, errorCode, [typeSymbol.getScopedName(), extendedType.getScopedName(), comparisonInfo.message], typeCheckContext.getEnclosingDecl());
            }
        };

        PullTypeChecker.prototype.typeCheckIfClassImplementsType = function (classDecl, classSymbol, implementedType, typeCheckContext) {
            var resolutionContext = new TypeScript.PullTypeResolutionContext();
            var comparisonInfo = new TypeComparisonInfo();
            var foundError = !this.resolver.sourceMembersAreSubtypeOfTargetMembers(classSymbol, implementedType, resolutionContext, comparisonInfo);
            if (!foundError) {
                foundError = !this.resolver.sourceCallSignaturesAreSubtypeOfTargetCallSignatures(classSymbol, implementedType, resolutionContext, comparisonInfo);
                if (!foundError) {
                    foundError = !this.resolver.sourceConstructSignaturesAreSubtypeOfTargetConstructSignatures(classSymbol, implementedType, resolutionContext, comparisonInfo);
                    if (!foundError) {
                        foundError = !this.resolver.sourceIndexSignaturesAreSubtypeOfTargetIndexSignatures(classSymbol, implementedType, resolutionContext, comparisonInfo);
                    }
                }
            }

            if (foundError) {
                var errorCode = implementedType.isClass() ? 203 /* Class__0__declares_class__1__but_does_not_implement_it__NL__2 */ : 202 /* Class__0__declares_interface__1__but_does_not_implement_it__NL__2 */;

                this.postError(classDecl.name.minChar, classDecl.name.getLength(), typeCheckContext.scriptName, errorCode, [classSymbol.getScopedName(), implementedType.getScopedName(), comparisonInfo.message], typeCheckContext.getEnclosingDecl());
            }
        };

        PullTypeChecker.prototype.typeCheckBase = function (typeDeclAst, typeSymbol, baseDeclAST, isExtendedType, typeCheckContext) {
            var _this = this;
            var typeDecl = typeCheckContext.semanticInfo.getDeclForAST(typeDeclAst);
            var contextForBaseTypeResolution = new TypeScript.PullTypeResolutionContext();
            contextForBaseTypeResolution.isResolvingClassExtendedType = true;

            var baseType = this.typeCheckAST(new TypeScript.TypeReference(baseDeclAST, 0), typeCheckContext, false);
            contextForBaseTypeResolution.isResolvingClassExtendedType = false;

            var typeDeclIsClass = typeSymbol.isClass();

            if (!typeSymbol.isValidBaseKind(baseType, isExtendedType)) {
                if (baseType.isError()) {
                    var error = (baseType).getDiagnostic();
                    if (error) {
                        this.postError(baseDeclAST.minChar, baseDeclAST.getLength(), typeCheckContext.scriptName, error.diagnosticCode(), error.arguments(), typeCheckContext.getEnclosingDecl());
                    }
                } else if (isExtendedType) {
                    if (typeDeclIsClass) {
                        this.postError(baseDeclAST.minChar, baseDeclAST.getLength(), typeCheckContext.scriptName, 142 /* A_class_may_only_extend_another_class */, null, typeCheckContext.getEnclosingDecl());
                    } else {
                        this.postError(baseDeclAST.minChar, baseDeclAST.getLength(), typeCheckContext.scriptName, 144 /* An_interface_may_only_extend_another_class_or_interface */, null, typeCheckContext.getEnclosingDecl());
                    }
                } else {
                    this.postError(baseDeclAST.minChar, baseDeclAST.getLength(), typeCheckContext.scriptName, 143 /* A_class_may_only_implement_another_class_or_interface */, null, typeCheckContext.getEnclosingDecl());
                }
                return;
            }

            if ((baseType.getRootSymbol()).hasBase(typeSymbol.getRootSymbol())) {
                typeSymbol.setHasBaseTypeConflict();
                baseType.setHasBaseTypeConflict();

                this.postError(typeDeclAst.name.minChar, typeDeclAst.name.getLength(), typeCheckContext.scriptName, typeDeclIsClass ? 168 /* Class__0__is_recursively_referenced_as_a_base_type_of_itself */ : 169 /* Interface__0__is_recursively_referenced_as_a_base_type_of_itself */, [typeSymbol.getScopedName()], typeCheckContext.getEnclosingDecl());
                return;
            }

            if (isExtendedType) {
                this.typeCheckIfTypeExtendsType(typeDeclAst, typeSymbol, baseType, typeCheckContext);
            } else {
                this.typeCheckIfClassImplementsType(typeDeclAst, typeSymbol, baseType, typeCheckContext);
            }

            this.checkTypePrivacy(typeSymbol, baseType, typeCheckContext, function (errorTypeSymbol) {
                return _this.baseListPrivacyErrorReporter(typeDeclAst, typeSymbol, baseDeclAST, isExtendedType, errorTypeSymbol, typeCheckContext);
            });
        };

        PullTypeChecker.prototype.typeCheckBases = function (typeDeclAst, typeSymbol, typeCheckContext) {
            if (!typeDeclAst.extendsList && !typeDeclAst.implementsList) {
                return;
            }

            for (var i = 0; i < typeDeclAst.extendsList.members.length; i++) {
                this.typeCheckBase(typeDeclAst, typeSymbol, typeDeclAst.extendsList.members[i], true, typeCheckContext);
            }

            if (typeSymbol.isClass()) {
                for (var i = 0; i < typeDeclAst.implementsList.members.length; i++) {
                    this.typeCheckBase(typeDeclAst, typeSymbol, typeDeclAst.implementsList.members[i], false, typeCheckContext);
                }
            } else if (typeDeclAst.implementsList) {
                this.postError(typeDeclAst.implementsList.minChar, typeDeclAst.implementsList.getLength(), typeCheckContext.scriptName, 145 /* An_interface_cannot_implement_another_type */, null, typeCheckContext.getEnclosingDecl());
            }
        };

        PullTypeChecker.prototype.typeCheckClass = function (ast, typeCheckContext) {
            var classAST = ast;

            var classSymbol = this.resolveSymbolAndReportDiagnostics(ast, false, typeCheckContext.getEnclosingDecl()).getType();
            this.checkForResolutionError(classSymbol, typeCheckContext.getEnclosingDecl());

            this.typeCheckAST(classAST.typeParameters, typeCheckContext, false);

            var classDecl = typeCheckContext.semanticInfo.getDeclForAST(classAST);
            typeCheckContext.pushEnclosingDecl(classDecl);

            this.typeCheckAST(classAST.typeParameters, typeCheckContext, false);

            this.typeCheckBases(classAST, classSymbol, typeCheckContext);

            this.typeCheckAST(classAST.members, typeCheckContext, false);

            if (!classSymbol.hasBaseTypeConflict()) {
                this.typeCheckMembersAgainstIndexer(classSymbol, typeCheckContext);
            }

            typeCheckContext.popEnclosingDecl();

            return classSymbol;
        };

        PullTypeChecker.prototype.typeCheckInterface = function (ast, typeCheckContext) {
            var interfaceAST = ast;

            var interfaceType = this.resolveSymbolAndReportDiagnostics(ast, false, typeCheckContext.getEnclosingDecl()).getType();
            this.checkForResolutionError(interfaceType, typeCheckContext.getEnclosingDecl());

            var interfaceDecl = typeCheckContext.semanticInfo.getDeclForAST(interfaceAST);
            typeCheckContext.pushEnclosingDecl(interfaceDecl);

            this.typeCheckAST(interfaceAST.typeParameters, typeCheckContext, false);

            this.typeCheckBases(ast, interfaceType, typeCheckContext);

            this.typeCheckAST(interfaceAST.members, typeCheckContext, false);

            if (!interfaceType.hasBaseTypeConflict()) {
                this.typeCheckMembersAgainstIndexer(interfaceType, typeCheckContext);
            }

            typeCheckContext.popEnclosingDecl();

            return interfaceType;
        };

        PullTypeChecker.prototype.typeCheckModule = function (ast, typeCheckContext) {
            var moduleDeclAST = ast;
            var moduleType = this.resolveSymbolAndReportDiagnostics(ast, false, typeCheckContext.getEnclosingDecl());

            this.checkForResolutionError(moduleType, typeCheckContext.getEnclosingDecl());

            var moduleDecl = typeCheckContext.semanticInfo.getDeclForAST(moduleDeclAST);
            typeCheckContext.pushEnclosingDecl(moduleDecl);

            var modName = (moduleDeclAST.name).text;
            var isDynamic = TypeScript.isQuoted(modName) || TypeScript.hasFlag(moduleDeclAST.getModuleFlags(), 512 /* IsDynamic */);

            if (isDynamic && moduleDeclAST.members && moduleDeclAST.members.members) {
                for (var i = moduleDeclAST.members.members.length - 1; i >= 0; i--) {
                    if (moduleDeclAST.members.members[i] && moduleDeclAST.members.members[i].nodeType == 87 /* ExportAssignment */) {
                        this.typeCheckAST(moduleDeclAST.members.members[i], typeCheckContext, false);
                        break;
                    }
                }
            }
            this.typeCheckAST(moduleDeclAST.members, typeCheckContext, false);

            this.validateVariableDeclarationGroups(moduleDecl, typeCheckContext);

            typeCheckContext.popEnclosingDecl();

            return moduleType;
        };

        PullTypeChecker.prototype.checkAssignability = function (ast, source, target, typeCheckContext) {
            var comparisonInfo = new TypeComparisonInfo();

            var isAssignable = this.resolver.sourceIsAssignableToTarget(source, target, this.context, comparisonInfo);

            if (!isAssignable) {
                var enclosingDecl = typeCheckContext.getEnclosingDecl();
                if (comparisonInfo.message) {
                    this.postError(ast.minChar, ast.getLength(), typeCheckContext.scriptName, 81 /* Cannot_convert__0__to__1__NL__2 */, [source.toString(), target.toString(), comparisonInfo.message], enclosingDecl);
                } else {
                    this.postError(ast.minChar, ast.getLength(), typeCheckContext.scriptName, 80 /* Cannot_convert__0__to__1_ */, [source.toString(), target.toString()], enclosingDecl);
                }
            }
        };

        PullTypeChecker.prototype.isValidLHS = function (ast, expressionSymbol) {
            var expressionTypeSymbol = expressionSymbol.getType();

            if (ast.nodeType === 35 /* ElementAccessExpression */ || this.resolver.isAnyOrEquivalent(expressionTypeSymbol)) {
                return true;
            } else if (!expressionSymbol.isType() || expressionTypeSymbol.isArray()) {
                return ((expressionSymbol.getKind() & TypeScript.PullElementKind.SomeLHS) != 0) && !expressionSymbol.hasFlag(4096 /* Enum */);
            }

            return false;
        };

        PullTypeChecker.prototype.typeCheckAssignment = function (binaryExpression, typeCheckContext) {
            var enclosingDecl = typeCheckContext.getEnclosingDecl();

            this.typeCheckAST(binaryExpression.operand1, typeCheckContext, false);

            var leftExpr = this.resolveSymbolAndReportDiagnostics(binaryExpression.operand1, false, typeCheckContext.getEnclosingDecl());
            var leftType = leftExpr.getType();
            this.checkForResolutionError(leftType, enclosingDecl);
            leftType = this.resolver.widenType(leftExpr.getType());

            this.context.pushContextualType(leftType, this.context.inProvisionalResolution(), null);
            var rightType = this.resolver.widenType(this.typeCheckAST(binaryExpression.operand2, typeCheckContext, true));
            this.context.popContextualType();

            if (!this.isValidLHS(binaryExpression.operand1, leftExpr)) {
                this.postError(binaryExpression.operand1.minChar, binaryExpression.operand1.getLength(), typeCheckContext.scriptName, 195 /* Invalid_left_hand_side_of_assignment_expression */, null, enclosingDecl);
            }

            this.checkAssignability(binaryExpression.operand1, rightType, leftType, typeCheckContext);
            return rightType;
        };

        PullTypeChecker.prototype.typeCheckGenericType = function (genericType, typeCheckContext) {
            var savedResolvingTypeReference = this.context.resolvingTypeReference;
            this.context.resolvingTypeReference = true;
            this.typeCheckAST(genericType.name, typeCheckContext, false);
            this.context.resolvingTypeReference = savedResolvingTypeReference;

            this.typeCheckAST(genericType.typeArguments, typeCheckContext, false);

            return this.resolveSymbolAndReportDiagnostics(genericType, false, typeCheckContext.getEnclosingDecl()).getType();
        };

        PullTypeChecker.prototype.typeCheckObjectLiteral = function (ast, typeCheckContext, inContextuallyTypedAssignment) {
            var objectLitAST = ast;
            var enclosingDecl = typeCheckContext.getEnclosingDecl();

            var objectLitType = this.resolveSymbolAndReportDiagnostics(ast, inContextuallyTypedAssignment, enclosingDecl).getType();
            var memberDecls = objectLitAST.operand;

            var contextualType = this.context.getContextualType();
            var memberType;

            if (memberDecls) {
                var member = null;

                for (var i = 0; i < memberDecls.members.length; i++) {
                    var binex = memberDecls.members[i];

                    if (contextualType) {
                        var text;
                        if (binex.operand1.nodeType === 20 /* Name */) {
                            text = (binex.operand1).text;
                        } else if (binex.operand1.nodeType === 5 /* StringLiteral */) {
                            text = (binex.operand1).text;
                        }

                        member = contextualType.findMember(text);

                        if (member) {
                            this.context.pushContextualType(member.getType(), this.context.inProvisionalResolution(), null);
                        }
                    }

                    this.typeCheckAST(binex.operand2, typeCheckContext, member != null);

                    if (member) {
                        this.context.popContextualType();
                        member = null;
                    }
                }
            }

            this.checkForResolutionError(objectLitType, enclosingDecl);

            return objectLitType;
        };

        PullTypeChecker.prototype.typeCheckArrayLiteral = function (ast, typeCheckContext, inContextuallyTypedAssignment) {
            var arrayLiteralAST = ast;
            var enclosingDecl = typeCheckContext.getEnclosingDecl();

            var type = this.resolveSymbolAndReportDiagnostics(ast, inContextuallyTypedAssignment, enclosingDecl).getType();
            var memberASTs = arrayLiteralAST.operand;

            var contextualType = this.context.getContextualType();
            var contextualMemberType = null;
            if (contextualType && contextualType.isArray()) {
                contextualMemberType = contextualType.getElementType();
            }

            if (memberASTs && memberASTs.members && memberASTs.members.length) {
                var elementTypes = [];

                if (contextualMemberType) {
                    this.context.pushContextualType(contextualMemberType, this.context.inProvisionalResolution(), null);
                }

                for (var i = 0; i < memberASTs.members.length; i++) {
                    elementTypes[elementTypes.length] = this.typeCheckAST(memberASTs.members[i], typeCheckContext, false);
                }

                if (contextualMemberType) {
                    this.context.popContextualType();
                }
            }

            this.checkForResolutionError(type, enclosingDecl);

            return type;
        };

        PullTypeChecker.prototype.enclosingClassIsDerived = function (typeCheckContext) {
            var enclosingClass = typeCheckContext.getEnclosingDecl(8 /* Class */);

            if (enclosingClass) {
                var classSymbol = enclosingClass.getSymbol();
                if (classSymbol.getExtendedTypes().length > 0) {
                    return true;
                }
            }

            return false;
        };

        PullTypeChecker.prototype.isSuperCallNode = function (node) {
            if (node && node.nodeType === 88 /* ExpressionStatement */) {
                var expressionStatement = node;
                if (expressionStatement.expression && expressionStatement.expression.nodeType === 36 /* InvocationExpression */) {
                    var callExpression = expressionStatement.expression;
                    if (callExpression.target && callExpression.target.nodeType === 30 /* SuperExpression */) {
                        return true;
                    }
                }
            }
            return false;
        };

        PullTypeChecker.prototype.getFirstStatementFromFunctionDeclAST = function (funcDeclAST) {
            if (funcDeclAST.block && funcDeclAST.block.statements && funcDeclAST.block.statements.members) {
                return funcDeclAST.block.statements.members[0];
            }

            return null;
        };

        PullTypeChecker.prototype.superCallMustBeFirstStatementInConstructor = function (enclosingConstructor, enclosingClass) {
            if (enclosingConstructor && enclosingClass) {
                var classSymbol = enclosingClass.getSymbol();
                if (classSymbol.getExtendedTypes().length === 0) {
                    return false;
                }

                var classMembers = classSymbol.getMembers();
                for (var i = 0, n1 = classMembers.length; i < n1; i++) {
                    var member = classMembers[i];

                    if (member.getKind() === 4096 /* Property */) {
                        var declarations = member.getDeclarations();
                        for (var j = 0, n2 = declarations.length; j < n2; j++) {
                            var declaration = declarations[j];
                            var ast = this.semanticInfoChain.getASTForDecl(declaration);
                            if (ast.nodeType === 19 /* Parameter */) {
                                return true;
                            }

                            if (ast.nodeType === 17 /* VariableDeclarator */) {
                                var variableDeclarator = ast;
                                if (variableDeclarator.init) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            }

            return false;
        };

        PullTypeChecker.prototype.checkForThisOrSuperCaptureInArrowFunction = function (expression, typeCheckContext) {
            var enclosingDecl = typeCheckContext.getEnclosingDecl();

            var declPath = typeCheckContext.enclosingDeclStack;

            if (declPath.length) {
                var inFatArrow = false;
                for (var i = declPath.length - 1; i >= 0; i--) {
                    var decl = declPath[i];
                    var declKind = decl.getKind();
                    var declFlags = decl.getFlags();

                    if (declKind === 131072 /* FunctionExpression */ && TypeScript.hasFlag(declFlags, 8192 /* FatArrow */)) {
                        inFatArrow = true;
                        continue;
                    }

                    if (inFatArrow) {
                        if (declKind === 16384 /* Function */ || declKind === 65536 /* Method */ || declKind === 32768 /* ConstructorMethod */ || declKind === 262144 /* GetAccessor */ || declKind === 524288 /* SetAccessor */ || declKind === 131072 /* FunctionExpression */ || declKind === 8 /* Class */ || declKind === 4 /* Container */ || declKind === 32 /* DynamicModule */ || declKind === 1 /* Script */) {
                            decl.setFlags(decl.getFlags() | 262144 /* MustCaptureThis */);

                            if (declKind === 8 /* Class */) {
                                decl.getChildDecls().filter(function (d) {
                                    return d.getKind() === 32768 /* ConstructorMethod */;
                                }).map(function (d) {
                                    return d.setFlags(d.getFlags() | 262144 /* MustCaptureThis */);
                                });
                            }
                            break;
                        }
                    }
                }
            }
        };

        PullTypeChecker.prototype.typeCheckThisExpression = function (thisExpressionAST, typeCheckContext) {
            var enclosingDecl = typeCheckContext.getEnclosingDecl();
            var enclosingNonLambdaDecl = typeCheckContext.getEnclosingNonLambdaDecl();

            if (typeCheckContext.inSuperConstructorCall && this.superCallMustBeFirstStatementInConstructor(typeCheckContext.getEnclosingDecl(32768 /* ConstructorMethod */), typeCheckContext.getEnclosingDecl(8 /* Class */))) {
                this.postError(thisExpressionAST.minChar, thisExpressionAST.getLength(), typeCheckContext.scriptName, 166 /* _this__cannot_be_referenced_in_current_location */, null, enclosingDecl);
            } else if (enclosingNonLambdaDecl) {
                if (enclosingNonLambdaDecl.getKind() === 8 /* Class */) {
                    this.postError(thisExpressionAST.minChar, thisExpressionAST.getLength(), typeCheckContext.scriptName, 205 /* _this__cannot_be_referenced_in_initializers_in_a_class_body */, null, enclosingDecl);
                } else if (enclosingNonLambdaDecl.getKind() === 4 /* Container */ || enclosingNonLambdaDecl.getKind() === 32 /* DynamicModule */) {
                    this.postError(thisExpressionAST.minChar, thisExpressionAST.getLength(), typeCheckContext.scriptName, 176 /* _this__cannot_be_referenced_within_module_bodies */, null, enclosingDecl);
                } else if (typeCheckContext.inConstructorArguments) {
                    this.postError(thisExpressionAST.minChar, thisExpressionAST.getLength(), typeCheckContext.scriptName, 220 /* _this__cannot_be_referenced_in_constructor_arguments */, null, enclosingDecl);
                }
            }

            this.checkForThisOrSuperCaptureInArrowFunction(thisExpressionAST, typeCheckContext);

            return this.resolveSymbolAndReportDiagnostics(thisExpressionAST, false, enclosingDecl).getType();
        };

        PullTypeChecker.prototype.typeCheckSuperExpression = function (ast, typeCheckContext) {
            var enclosingDecl = typeCheckContext.getEnclosingDecl();
            var nonLambdaEnclosingDecl = typeCheckContext.getEnclosingNonLambdaDecl();
            var nonLambdaEnclosingDeclKind = nonLambdaEnclosingDecl.getKind();
            var inSuperConstructorTarget = typeCheckContext.inSuperConstructorTarget;

            if (inSuperConstructorTarget && enclosingDecl.getKind() !== 32768 /* ConstructorMethod */) {
                this.postError(ast.minChar, ast.getLength(), typeCheckContext.scriptName, 174 /* Super_calls_are_not_permitted_outside_constructors_or_in_local_functions_inside_constructors */, null, enclosingDecl);
            } else if ((nonLambdaEnclosingDeclKind !== 65536 /* Method */ && nonLambdaEnclosingDeclKind !== 262144 /* GetAccessor */ && nonLambdaEnclosingDeclKind !== 524288 /* SetAccessor */ && nonLambdaEnclosingDeclKind !== 32768 /* ConstructorMethod */) || ((nonLambdaEnclosingDecl.getFlags() & 16 /* Static */) !== 0)) {
                this.postError(ast.minChar, ast.getLength(), typeCheckContext.scriptName, 170 /* _super__property_access_is_permitted_only_in_a_constructor__instance_member_function__or_instance_member_accessor_of_a_derived_class */, null, enclosingDecl);
            } else if (!this.enclosingClassIsDerived(typeCheckContext)) {
                this.postError(ast.minChar, ast.getLength(), typeCheckContext.scriptName, 171 /* _super__cannot_be_referenced_in_non_derived_classes */, null, enclosingDecl);
            }

            this.checkForThisOrSuperCaptureInArrowFunction(ast, typeCheckContext);

            return this.resolveSymbolAndReportDiagnostics(ast, false, enclosingDecl).getType();
        };

        PullTypeChecker.prototype.typeCheckCallExpression = function (callExpression, typeCheckContext) {
            var enclosingDecl = typeCheckContext.getEnclosingDecl();
            var inSuperConstructorCall = (callExpression.target.nodeType === 30 /* SuperExpression */);

            var callResolutionData = new TypeScript.PullAdditionalCallResolutionData();
            var resultTypeAndDiagnostics = this.resolver.resolveCallExpression(callExpression, false, enclosingDecl, this.context, callResolutionData);
            this.reportDiagnostics(resultTypeAndDiagnostics, enclosingDecl);
            var resultType = resultTypeAndDiagnostics.symbol.getType();

            this.typeCheckAST(callExpression.typeArguments, typeCheckContext, false);

            if (!resultType.isError()) {
                var savedInSuperConstructorTarget = typeCheckContext.inSuperConstructorTarget;
                if (inSuperConstructorCall) {
                    typeCheckContext.inSuperConstructorTarget = true;
                }

                this.typeCheckAST(callExpression.target, typeCheckContext, false);

                typeCheckContext.inSuperConstructorTarget = savedInSuperConstructorTarget;
            }

            if (inSuperConstructorCall && enclosingDecl.getKind() === 32768 /* ConstructorMethod */) {
                typeCheckContext.seenSuperConstructorCall = true;
            }

            var savedInSuperConstructorCall = typeCheckContext.inSuperConstructorCall;
            if (inSuperConstructorCall) {
                typeCheckContext.inSuperConstructorCall = true;
            }

            var contextTypes = callResolutionData.actualParametersContextTypeSymbols;
            if (callExpression.arguments) {
                var argumentASTs = callExpression.arguments.members;
                for (var i = 0, n = argumentASTs.length; i < n; i++) {
                    var argumentAST = argumentASTs[i];

                    if (contextTypes && contextTypes[i]) {
                        this.context.pushContextualType(contextTypes[i], this.context.inProvisionalResolution(), null);
                    }

                    this.typeCheckAST(argumentAST, typeCheckContext, false);

                    if (contextTypes && contextTypes[i]) {
                        this.context.popContextualType();
                    }
                }
            }

            typeCheckContext.inSuperConstructorCall = savedInSuperConstructorCall;

            return resultType;
        };

        PullTypeChecker.prototype.typeCheckObjectCreationExpression = function (callExpression, typeCheckContext) {
            var enclosingDecl = typeCheckContext.getEnclosingDecl();

            var callResolutionData = new TypeScript.PullAdditionalCallResolutionData();
            var resultAndDiagnostics = this.resolver.resolveNewExpression(callExpression, false, enclosingDecl, this.context, callResolutionData);
            this.reportDiagnostics(resultAndDiagnostics, typeCheckContext.getEnclosingDecl());

            var result = resultAndDiagnostics.symbol.getType();

            this.typeCheckAST(callExpression.target, typeCheckContext, false);

            this.typeCheckAST(callExpression.typeArguments, typeCheckContext, false);

            var contextTypes = callResolutionData.actualParametersContextTypeSymbols;
            if (callExpression.arguments) {
                var argumentASTs = callExpression.arguments.members;
                for (var i = 0, n = argumentASTs.length; i < n; i++) {
                    var argumentAST = argumentASTs[i];

                    if (contextTypes && contextTypes[i]) {
                        this.context.pushContextualType(contextTypes[i], this.context.inProvisionalResolution(), null);
                    }

                    this.typeCheckAST(argumentAST, typeCheckContext, false);

                    if (contextTypes && contextTypes[i]) {
                        this.context.popContextualType();
                    }
                }
            }

            return result;
        };

        PullTypeChecker.prototype.typeCheckTypeAssertion = function (ast, typeCheckContext) {
            var enclosingDecl = typeCheckContext.getEnclosingDecl();

            var returnType = this.resolveSymbolAndReportDiagnostics(ast, false, enclosingDecl).getType();

            if (returnType.isError()) {
                var symbolName = (returnType).getData();
                this.postError(ast.minChar, ast.getLength(), typeCheckContext.scriptName, 164 /* Could_not_find_symbol__0_ */, [symbolName], typeCheckContext.getEnclosingDecl());
            }

            this.context.pushContextualType(returnType, this.context.inProvisionalResolution(), null);
            var exprType = this.typeCheckAST(ast.operand, typeCheckContext, true);
            this.context.popContextualType();

            var comparisonInfo = new TypeComparisonInfo();

            var isAssignable = this.resolver.sourceIsAssignableToTarget(returnType, exprType, this.context, comparisonInfo) || this.resolver.sourceIsAssignableToTarget(exprType, returnType, this.context, comparisonInfo);

            if (!isAssignable) {
                var message;
                if (comparisonInfo.message) {
                    this.postError(ast.minChar, ast.getLength(), typeCheckContext.scriptName, 81 /* Cannot_convert__0__to__1__NL__2 */, [exprType.toString(), returnType.toString(), comparisonInfo.message], typeCheckContext.getEnclosingDecl());
                } else {
                    this.postError(ast.minChar, ast.getLength(), typeCheckContext.scriptName, 80 /* Cannot_convert__0__to__1_ */, [exprType.toString(), returnType.toString()], typeCheckContext.getEnclosingDecl());
                }
            }

            return returnType;
        };

        PullTypeChecker.prototype.typeCheckLogicalOperation = function (binex, typeCheckContext) {
            var leftType = this.typeCheckAST(binex.operand1, typeCheckContext, false);
            var rightType = this.typeCheckAST(binex.operand2, typeCheckContext, false);

            var comparisonInfo = new TypeComparisonInfo();
            if (!this.resolver.sourceIsAssignableToTarget(leftType, rightType, this.context, comparisonInfo) && !this.resolver.sourceIsAssignableToTarget(rightType, leftType, this.context, comparisonInfo)) {
                this.postError(binex.minChar, binex.getLength(), typeCheckContext.scriptName, 78 /* Operator__0__cannot_be_applied_to_types__1__and__2_ */, [TypeScript.BinaryExpression.getTextForBinaryToken(binex.nodeType), leftType.toString(), rightType.toString()], typeCheckContext.getEnclosingDecl());
            }

            return this.resolveSymbolAndReportDiagnostics(binex, false, typeCheckContext.getEnclosingDecl()).getType();
        };

        PullTypeChecker.prototype.typeCheckLogicalAndOrExpression = function (binex, typeCheckContext) {
            this.typeCheckAST(binex.operand1, typeCheckContext, false);
            this.typeCheckAST(binex.operand2, typeCheckContext, false);

            return this.resolveSymbolAndReportDiagnostics(binex, false, typeCheckContext.getEnclosingDecl()).getType();
        };

        PullTypeChecker.prototype.typeCheckCommaExpression = function (binex, typeCheckContext) {
            this.typeCheckAST(binex.operand1, typeCheckContext, false);
            this.typeCheckAST(binex.operand2, typeCheckContext, false);

            return this.resolveSymbolAndReportDiagnostics(binex, false, typeCheckContext.getEnclosingDecl()).getType();
        };

        PullTypeChecker.prototype.typeCheckBinaryAdditionOperation = function (binaryExpression, typeCheckContext) {
            var enclosingDecl = typeCheckContext.getEnclosingDecl();

            this.resolveSymbolAndReportDiagnostics(binaryExpression, false, enclosingDecl).getType();

            var lhsType = this.typeCheckAST(binaryExpression.operand1, typeCheckContext, false);
            var rhsType = this.typeCheckAST(binaryExpression.operand2, typeCheckContext, false);

            if (TypeScript.PullHelpers.symbolIsEnum(lhsType)) {
                lhsType = this.semanticInfoChain.numberTypeSymbol;
            } else if (lhsType === this.semanticInfoChain.nullTypeSymbol || lhsType === this.semanticInfoChain.undefinedTypeSymbol) {
                if (rhsType != this.semanticInfoChain.nullTypeSymbol && rhsType != this.semanticInfoChain.undefinedTypeSymbol) {
                    lhsType = rhsType;
                } else {
                    lhsType = this.semanticInfoChain.anyTypeSymbol;
                }
            }

            if (TypeScript.PullHelpers.symbolIsEnum(rhsType)) {
                rhsType = this.semanticInfoChain.numberTypeSymbol;
            } else if (rhsType === this.semanticInfoChain.nullTypeSymbol || rhsType === this.semanticInfoChain.undefinedTypeSymbol) {
                if (lhsType != this.semanticInfoChain.nullTypeSymbol && lhsType != this.semanticInfoChain.undefinedTypeSymbol) {
                    rhsType = lhsType;
                } else {
                    rhsType = this.semanticInfoChain.anyTypeSymbol;
                }
            }

            var exprType = null;

            if (lhsType === this.semanticInfoChain.stringTypeSymbol || rhsType === this.semanticInfoChain.stringTypeSymbol) {
                exprType = this.semanticInfoChain.stringTypeSymbol;
            } else if (this.resolver.isAnyOrEquivalent(lhsType) || this.resolver.isAnyOrEquivalent(rhsType)) {
                exprType = this.semanticInfoChain.anyTypeSymbol;
            } else if (rhsType === this.semanticInfoChain.numberTypeSymbol && lhsType === this.semanticInfoChain.numberTypeSymbol) {
                exprType = this.semanticInfoChain.numberTypeSymbol;
            }

            if (exprType) {
                if (binaryExpression.nodeType === 39 /* AddAssignmentExpression */) {
                    var lhsExpression = this.resolveSymbolAndReportDiagnostics(binaryExpression.operand1, false, typeCheckContext.getEnclosingDecl());
                    if (!this.isValidLHS(binaryExpression.operand1, lhsExpression)) {
                        this.postError(binaryExpression.operand1.minChar, binaryExpression.operand1.getLength(), typeCheckContext.scriptName, 195 /* Invalid_left_hand_side_of_assignment_expression */, null, enclosingDecl);
                    }

                    this.checkAssignability(binaryExpression.operand1, exprType, lhsType, typeCheckContext);
                }
            } else {
                this.postError(binaryExpression.operand1.minChar, binaryExpression.operand1.getLength(), typeCheckContext.scriptName, 178 /* Invalid__addition__expression___types_do_not_agree */, null, typeCheckContext.getEnclosingDecl());
                exprType = this.semanticInfoChain.anyTypeSymbol;
            }

            return exprType;
        };

        PullTypeChecker.prototype.typeCheckBinaryArithmeticOperation = function (binaryExpression, typeCheckContext) {
            var enclosingDecl = typeCheckContext.getEnclosingDecl();

            this.resolveSymbolAndReportDiagnostics(binaryExpression, false, enclosingDecl).getType();

            var lhsType = this.typeCheckAST(binaryExpression.operand1, typeCheckContext, false);
            var rhsType = this.typeCheckAST(binaryExpression.operand2, typeCheckContext, false);

            var lhsIsFit = this.resolver.isAnyOrEquivalent(lhsType) || lhsType === this.semanticInfoChain.numberTypeSymbol || TypeScript.PullHelpers.symbolIsEnum(lhsType);
            var rhsIsFit = this.resolver.isAnyOrEquivalent(rhsType) || rhsType === this.semanticInfoChain.numberTypeSymbol || TypeScript.PullHelpers.symbolIsEnum(rhsType);

            if (!rhsIsFit) {
                this.postError(binaryExpression.operand1.minChar, binaryExpression.operand1.getLength(), typeCheckContext.scriptName, 179 /* The_right_hand_side_of_an_arithmetic_operation_must_be_of_type__any____number__or_an_enum_type */, null, typeCheckContext.getEnclosingDecl());
            }

            if (!lhsIsFit) {
                this.postError(binaryExpression.operand2.minChar, binaryExpression.operand2.getLength(), typeCheckContext.scriptName, 180 /* The_left_hand_side_of_an_arithmetic_operation_must_be_of_type__any____number__or_an_enum_type */, null, typeCheckContext.getEnclosingDecl());
            }

            if (rhsIsFit && lhsIsFit) {
                switch (binaryExpression.nodeType) {
                    case 47 /* LeftShiftAssignmentExpression */:
                    case 48 /* SignedRightShiftAssignmentExpression */:
                    case 49 /* UnsignedRightShiftAssignmentExpression */:
                    case 40 /* SubtractAssignmentExpression */:
                    case 42 /* MultiplyAssignmentExpression */:
                    case 41 /* DivideAssignmentExpression */:
                    case 43 /* ModuloAssignmentExpression */:
                    case 46 /* OrAssignmentExpression */:
                    case 44 /* AndAssignmentExpression */:
                    case 45 /* ExclusiveOrAssignmentExpression */:
                        var lhsExpression = this.resolveSymbolAndReportDiagnostics(binaryExpression.operand1, false, typeCheckContext.getEnclosingDecl());
                        if (!this.isValidLHS(binaryExpression.operand1, lhsExpression)) {
                            this.postError(binaryExpression.operand1.minChar, binaryExpression.operand1.getLength(), typeCheckContext.scriptName, 195 /* Invalid_left_hand_side_of_assignment_expression */, null, enclosingDecl);
                        }

                        this.checkAssignability(binaryExpression.operand1, rhsType, lhsType, typeCheckContext);
                        break;
                }
            }

            return this.semanticInfoChain.numberTypeSymbol;
        };

        PullTypeChecker.prototype.typeCheckLogicalNotExpression = function (unaryExpression, typeCheckContext, inContextuallyTypedAssignment) {
            this.typeCheckAST(unaryExpression.operand, typeCheckContext, inContextuallyTypedAssignment);
            return this.semanticInfoChain.booleanTypeSymbol;
        };

        PullTypeChecker.prototype.typeCheckUnaryArithmeticOperation = function (unaryExpression, typeCheckContext, inContextuallyTypedAssignment) {
            var operandType = this.typeCheckAST(unaryExpression.operand, typeCheckContext, inContextuallyTypedAssignment);

            switch (unaryExpression.nodeType) {
                case 26 /* PlusExpression */:
                case 27 /* NegateExpression */:
                case 72 /* BitwiseNotExpression */:
                    return this.semanticInfoChain.numberTypeSymbol;
            }

            var operandIsFit = this.resolver.isAnyOrEquivalent(operandType) || operandType === this.semanticInfoChain.numberTypeSymbol || TypeScript.PullHelpers.symbolIsEnum(operandType);

            if (!operandIsFit) {
                this.postError(unaryExpression.operand.minChar, unaryExpression.operand.getLength(), typeCheckContext.scriptName, 181 /* The_type_of_a_unary_arithmetic_operation_operand_must_be_of_type__any____number__or_an_enum_type */, null, typeCheckContext.getEnclosingDecl());
            }

            switch (unaryExpression.nodeType) {
                case 76 /* PostIncrementExpression */:
                case 74 /* PreIncrementExpression */:
                case 77 /* PostDecrementExpression */:
                case 75 /* PreDecrementExpression */:
                    var expression = this.resolveSymbolAndReportDiagnostics(unaryExpression.operand, false, typeCheckContext.getEnclosingDecl());
                    if (!this.isValidLHS(unaryExpression.operand, expression)) {
                        this.postError(unaryExpression.operand.minChar, unaryExpression.operand.getLength(), typeCheckContext.scriptName, 204 /* The_operand_of_an_increment_or_decrement_operator_must_be_a_variable__property_or_indexer */, null, typeCheckContext.getEnclosingDecl());
                    }

                    break;
            }

            return operandType;
        };

        PullTypeChecker.prototype.typeCheckElementAccessExpression = function (binaryExpression, typeCheckContext) {
            this.typeCheckAST(binaryExpression.operand1, typeCheckContext, false);
            this.typeCheckAST(binaryExpression.operand2, typeCheckContext, false);

            return this.resolveSymbolAndReportDiagnostics(binaryExpression, false, typeCheckContext.getEnclosingDecl()).getType();
        };

        PullTypeChecker.prototype.typeCheckTypeOf = function (ast, typeCheckContext) {
            this.typeCheckAST((ast).operand, typeCheckContext, false);

            return this.semanticInfoChain.stringTypeSymbol;
        };

        PullTypeChecker.prototype.typeCheckTypeReference = function (typeRef, typeCheckContext) {
            if (typeRef.term.nodeType === 12 /* FunctionDeclaration */) {
                this.typeCheckFunctionTypeSignature(typeRef.term, typeCheckContext.getEnclosingDecl(), typeCheckContext);
            } else if (typeRef.term.nodeType === 14 /* InterfaceDeclaration */) {
                this.typeCheckInterfaceTypeReference(typeRef.term, typeCheckContext.getEnclosingDecl(), typeCheckContext);
            } else {
                var savedResolvingTypeReference = this.context.resolvingTypeReference;
                this.context.resolvingTypeReference = true;
                var type = this.typeCheckAST(typeRef.term, typeCheckContext, false);

                if (type && !type.isError() && !typeCheckContext.inImportDeclaration) {
                    if ((type.getKind() & TypeScript.PullElementKind.SomeType) === 0) {
                        if (type.getKind() & TypeScript.PullElementKind.SomeContainer) {
                            this.postError(typeRef.minChar, typeRef.getLength(), typeCheckContext.scriptName, 262 /* Type_reference_cannot_refer_to_container__0_ */, [type.toString()], typeCheckContext.getEnclosingDecl());
                        } else {
                            this.postError(typeRef.minChar, typeRef.getLength(), typeCheckContext.scriptName, 263 /* Type_reference_must_refer_to_type */, null, typeCheckContext.getEnclosingDecl());
                        }
                    }
                }

                this.context.resolvingTypeReference = savedResolvingTypeReference;
            }

            return this.resolveSymbolAndReportDiagnostics(typeRef, false, typeCheckContext.getEnclosingDecl()).getType();
        };

        PullTypeChecker.prototype.typeCheckExportAssignment = function (ast, typeCheckContext) {
            return this.resolveSymbolAndReportDiagnostics(ast, false, typeCheckContext.getEnclosingDecl()).getType();
        };

        PullTypeChecker.prototype.typeCheckFunctionTypeSignature = function (funcDeclAST, enclosingDecl, typeCheckContext) {
            var funcDeclSymbolAndDiagnostics = this.resolver.getSymbolAndDiagnosticsForAST(funcDeclAST);
            var funcDeclSymbol = funcDeclSymbolAndDiagnostics && funcDeclSymbolAndDiagnostics.symbol;
            if (!funcDeclSymbol) {
                funcDeclSymbol = this.resolver.resolveFunctionTypeSignature(funcDeclAST, enclosingDecl, this.context);
            }
            var functionDecl = typeCheckContext.semanticInfo.getDeclForAST(funcDeclAST);

            typeCheckContext.pushEnclosingDecl(functionDecl);
            this.typeCheckAST(funcDeclAST.arguments, typeCheckContext, false);
            typeCheckContext.popEnclosingDecl();

            var functionSignature = funcDeclSymbol.getKind() === 33554432 /* ConstructorType */ ? funcDeclSymbol.getConstructSignatures()[0] : funcDeclSymbol.getCallSignatures()[0];
            var parameters = functionSignature.getParameters();
            for (var i = 0; i < parameters.length; i++) {
                this.checkForResolutionError(parameters[i].getType(), enclosingDecl);
            }

            if (funcDeclAST.returnTypeAnnotation) {
                var returnType = functionSignature.getReturnType();
                this.checkForResolutionError(returnType, enclosingDecl);
            }

            this.typeCheckFunctionOverloads(funcDeclAST, typeCheckContext, functionSignature, [functionSignature]);
            return funcDeclSymbol;
        };

        PullTypeChecker.prototype.typeCheckInterfaceTypeReference = function (interfaceAST, enclosingDecl, typeCheckContext) {
            var interfaceSymbolAndDiagnostics = this.resolver.getSymbolAndDiagnosticsForAST(interfaceAST);
            var interfaceSymbol = interfaceSymbolAndDiagnostics && interfaceSymbolAndDiagnostics.symbol;
            if (!interfaceSymbol) {
                interfaceSymbol = this.resolver.resolveInterfaceTypeReference(interfaceAST, enclosingDecl, this.context);
            }

            var interfaceDecl = typeCheckContext.semanticInfo.getDeclForAST(interfaceAST);
            typeCheckContext.pushEnclosingDecl(interfaceDecl);
            this.typeCheckAST(interfaceAST.members, typeCheckContext, false);
            this.typeCheckMembersAgainstIndexer(interfaceSymbol, typeCheckContext);
            typeCheckContext.popEnclosingDecl();

            return interfaceSymbol;
        };

        PullTypeChecker.prototype.typeCheckConditionalExpression = function (conditionalExpression, typeCheckContext) {
            this.typeCheckAST(conditionalExpression.operand1, typeCheckContext, false);
            this.typeCheckAST(conditionalExpression.operand2, typeCheckContext, false);
            this.typeCheckAST(conditionalExpression.operand3, typeCheckContext, false);

            return this.resolveSymbolAndReportDiagnostics(conditionalExpression, false, typeCheckContext.getEnclosingDecl()).getType();
        };

        PullTypeChecker.prototype.typeCheckThrowStatement = function (throwStatement, typeCheckContext) {
            this.typeCheckAST(throwStatement.expression, typeCheckContext, false);

            var type = this.resolveSymbolAndReportDiagnostics(throwStatement.expression, false, typeCheckContext.getEnclosingDecl()).getType();
            this.checkForResolutionError(type, typeCheckContext.getEnclosingDecl());
            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeChecker.prototype.typeCheckDeleteExpression = function (unaryExpression, typeCheckContext) {
            this.typeCheckAST(unaryExpression.operand, typeCheckContext, false);

            var enclosingDecl = typeCheckContext.getEnclosingDecl();
            var type = this.resolveSymbolAndReportDiagnostics(unaryExpression, false, enclosingDecl).getType();
            this.checkForResolutionError(type, enclosingDecl);

            return type;
        };

        PullTypeChecker.prototype.typeCheckVoidExpression = function (unaryExpression, typeCheckContext) {
            this.typeCheckAST(unaryExpression.operand, typeCheckContext, false);

            var enclosingDecl = typeCheckContext.getEnclosingDecl();
            var type = this.resolveSymbolAndReportDiagnostics(unaryExpression, false, enclosingDecl).getType();
            this.checkForResolutionError(type, enclosingDecl);

            return type;
        };

        PullTypeChecker.prototype.typeCheckRegExpExpression = function (ast, typeCheckContext) {
            var type = this.resolveSymbolAndReportDiagnostics(ast, false, typeCheckContext.getEnclosingDecl()).getType();
            this.checkForResolutionError(type, typeCheckContext.getEnclosingDecl());
            return type;
        };

        PullTypeChecker.prototype.typeCheckForStatement = function (forStatement, typeCheckContext) {
            this.typeCheckAST(forStatement.init, typeCheckContext, false);
            this.typeCheckAST(forStatement.cond, typeCheckContext, false);
            this.typeCheckAST(forStatement.body, typeCheckContext, false);

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeChecker.prototype.typeCheckForInStatement = function (ast, typeCheckContext) {
            var forInStatement = ast;

            var rhsType = this.resolver.widenType(this.typeCheckAST(forInStatement.obj, typeCheckContext, false));
            var lval = forInStatement.lval;

            if (lval.nodeType === 18 /* VariableDeclaration */) {
                var declaration = forInStatement.lval;
                var varDecl = declaration.declarators.members[0];

                if (varDecl.typeExpr) {
                    this.postError(lval.minChar, lval.getLength(), typeCheckContext.scriptName, 182 /* Variable_declarations_for_for_in_expressions_cannot_contain_a_type_annotation */, null, typeCheckContext.getEnclosingDecl());
                }
            }

            var varSym = this.resolveSymbolAndReportDiagnostics(forInStatement.lval, false, typeCheckContext.getEnclosingDecl());
            this.checkForResolutionError(varSym.getType(), typeCheckContext.getEnclosingDecl());

            var isStringOrNumber = varSym.getType() === this.semanticInfoChain.stringTypeSymbol || this.resolver.isAnyOrEquivalent(varSym.getType());

            var isValidRHS = rhsType && (this.resolver.isAnyOrEquivalent(rhsType) || !rhsType.isPrimitive());

            if (!isStringOrNumber) {
                this.postError(lval.minChar, lval.getLength(), typeCheckContext.scriptName, 183 /* Variable_declarations_for_for_in_expressions_must_be_of_types__string__or__any_ */, null, typeCheckContext.getEnclosingDecl());
            }

            if (!isValidRHS) {
                this.postError(forInStatement.obj.minChar, forInStatement.obj.getLength(), typeCheckContext.scriptName, 184 /* The_right_operand_of_a_for_in_expression_must_be_of_type__any____an_object_type_or_a_type_parameter */, null, typeCheckContext.getEnclosingDecl());
            }

            this.typeCheckAST(forInStatement.body, typeCheckContext, false);

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeChecker.prototype.typeCheckInExpression = function (binaryExpression, typeCheckContext) {
            var lhsType = this.resolver.widenType(this.typeCheckAST(binaryExpression.operand1, typeCheckContext, false));
            var rhsType = this.resolver.widenType(this.typeCheckAST(binaryExpression.operand2, typeCheckContext, false));

            var isStringAnyOrNumber = lhsType.getType() === this.semanticInfoChain.stringTypeSymbol || this.resolver.isAnyOrEquivalent(lhsType.getType()) || this.resolver.isNumberOrEquivalent(lhsType.getType());
            var isValidRHS = rhsType && (this.resolver.isAnyOrEquivalent(rhsType) || !rhsType.isPrimitive());

            if (!isStringAnyOrNumber) {
                this.postError(binaryExpression.operand1.minChar, binaryExpression.operand1.getLength(), typeCheckContext.scriptName, 185 /* The_left_hand_side_of_an__in__expression_must_be_of_types__string__or__any_ */, null, typeCheckContext.getEnclosingDecl());
            }

            if (!isValidRHS) {
                this.postError(binaryExpression.operand1.minChar, binaryExpression.operand1.getLength(), typeCheckContext.scriptName, 186 /* The_right_hand_side_of_an__in__expression_must_be_of_type__any___an_object_type_or_a_type_parameter */, null, typeCheckContext.getEnclosingDecl());
            }

            return this.semanticInfoChain.booleanTypeSymbol;
        };

        PullTypeChecker.prototype.typeCheckInstanceOfExpression = function (binaryExpression, typeCheckContext) {
            var lhsType = this.resolver.widenType(this.typeCheckAST(binaryExpression.operand1, typeCheckContext, false));
            var rhsType = this.typeCheckAST(binaryExpression.operand2, typeCheckContext, false);

            var isValidLHS = lhsType && (this.resolver.isAnyOrEquivalent(lhsType) || !lhsType.isPrimitive());
            var isValidRHS = rhsType && (this.resolver.isAnyOrEquivalent(rhsType) || rhsType.isClass() || this.resolver.typeIsSubtypeOfFunction(rhsType, this.context));

            if (!isValidLHS) {
                this.postError(binaryExpression.operand1.minChar, binaryExpression.operand1.getLength(), typeCheckContext.scriptName, 187 /* The_left_hand_side_of_an__instanceOf__expression_must_be_of_type__any___an_object_type_or_a_type_parameter */, null, typeCheckContext.getEnclosingDecl());
            }

            if (!isValidRHS) {
                this.postError(binaryExpression.operand1.minChar, binaryExpression.operand1.getLength(), typeCheckContext.scriptName, 188 /* The_right_hand_side_of_an__instanceOf__expression_must_be_of_type__any__or_a_subtype_of_the__Function__interface_type */, null, typeCheckContext.getEnclosingDecl());
            }

            return this.semanticInfoChain.booleanTypeSymbol;
        };

        PullTypeChecker.prototype.typeCheckParenthesizedExpression = function (parenthesizedExpression, typeCheckContext) {
            return this.typeCheckAST(parenthesizedExpression.expression, typeCheckContext, false);
        };

        PullTypeChecker.prototype.typeCheckWhileStatement = function (whileStatement, typeCheckContext) {
            this.typeCheckAST(whileStatement.cond, typeCheckContext, false);
            this.typeCheckAST(whileStatement.body, typeCheckContext, false);

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeChecker.prototype.typeCheckDoStatement = function (doStatement, typeCheckContext) {
            this.typeCheckAST(doStatement.cond, typeCheckContext, false);
            this.typeCheckAST(doStatement.body, typeCheckContext, false);

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeChecker.prototype.typeCheckIfStatement = function (ifStatement, typeCheckContext) {
            this.typeCheckAST(ifStatement.cond, typeCheckContext, false);
            this.typeCheckAST(ifStatement.thenBod, typeCheckContext, false);
            this.typeCheckAST(ifStatement.elseBod, typeCheckContext, false);

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeChecker.prototype.typeCheckBlock = function (block, typeCheckContext) {
            this.typeCheckAST(block.statements, typeCheckContext, false);

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeChecker.prototype.typeCheckVariableDeclaration = function (variableDeclaration, typeCheckContext) {
            this.typeCheckAST(variableDeclaration.declarators, typeCheckContext, false);

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeChecker.prototype.typeCheckVariableStatement = function (variableStatement, typeCheckContext) {
            this.typeCheckAST(variableStatement.declaration, typeCheckContext, false);

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeChecker.prototype.typeCheckWithStatement = function (withStatement, typeCheckContext) {
            this.postError(withStatement.expr.minChar, withStatement.expr.getLength(), typeCheckContext.scriptName, 200 /* All_symbols_within_a__with__block_will_be_resolved_to__any__ */, null, typeCheckContext.getEnclosingDecl());

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeChecker.prototype.typeCheckTryStatement = function (tryStatement, typeCheckContext) {
            this.typeCheckAST(tryStatement.tryBody, typeCheckContext, false);
            this.typeCheckAST(tryStatement.catchClause, typeCheckContext, false);
            this.typeCheckAST(tryStatement.finallyBody, typeCheckContext, false);

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeChecker.prototype.typeCheckCatchClause = function (catchClause, typeCheckContext) {
            var catchDecl = this.resolver.getDeclForAST(catchClause);

            typeCheckContext.pushEnclosingDecl(catchDecl);
            this.typeCheckAST(catchClause.body, typeCheckContext, false);
            typeCheckContext.popEnclosingDecl();

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeChecker.prototype.typeCheckReturnStatement = function (returnAST, typeCheckContext) {
            typeCheckContext.setEnclosingDeclHasReturn();

            var returnExpr = returnAST.returnExpression;
            var enclosingDecl = typeCheckContext.getEnclosingDecl();

            var inContextuallyTypedAssignment = false;
            var enclosingDeclAST;

            if (enclosingDecl.getKind() & TypeScript.PullElementKind.SomeFunction) {
                enclosingDeclAST = this.resolver.getASTForDecl(enclosingDecl);
                if (enclosingDeclAST.returnTypeAnnotation) {
                    var returnTypeAnnotationSymbol = this.resolver.resolveTypeReference(enclosingDeclAST.returnTypeAnnotation, enclosingDecl, this.context).symbol;
                    if (returnTypeAnnotationSymbol) {
                        inContextuallyTypedAssignment = true;
                        this.context.pushContextualType(returnTypeAnnotationSymbol, this.context.inProvisionalResolution(), null);
                    }
                } else {
                    var currentContextualType = this.context.getContextualType();
                    if (currentContextualType && currentContextualType.isFunction()) {
                        var currentContextualTypeSignatureSymbol = currentContextualType.getDeclarations()[0].getSignatureSymbol();
                        var currentContextualTypeReturnTypeSymbol = currentContextualTypeSignatureSymbol.getReturnType();
                        if (currentContextualTypeReturnTypeSymbol) {
                            inContextuallyTypedAssignment = true;
                            this.context.pushContextualType(currentContextualTypeReturnTypeSymbol, this.context.inProvisionalResolution(), null);
                        }
                    }
                }
            }

            var returnType = this.typeCheckAST(returnExpr, typeCheckContext, inContextuallyTypedAssignment);

            if (inContextuallyTypedAssignment) {
                this.context.popContextualType();
            }

            if (enclosingDecl.getKind() === 524288 /* SetAccessor */ && returnExpr) {
                this.postError(returnExpr.minChar, returnExpr.getLength(), typeCheckContext.scriptName, 189 /* Setters_cannot_return_a_value */, null, typeCheckContext.getEnclosingDecl());
            }

            if (enclosingDecl.getKind() & TypeScript.PullElementKind.SomeFunction) {
                enclosingDeclAST = this.resolver.getASTForDecl(enclosingDecl);

                if (enclosingDeclAST.returnTypeAnnotation) {
                    var signatureSymbol = enclosingDecl.getSignatureSymbol();
                    var sigReturnType = signatureSymbol.getReturnType();

                    if (returnType && sigReturnType) {
                        var comparisonInfo = new TypeComparisonInfo();
                        var upperBound = null;

                        if (returnType.isTypeParameter()) {
                            upperBound = (returnType).getConstraint();

                            if (upperBound) {
                                returnType = upperBound;
                            }
                        }

                        if (sigReturnType.isTypeParameter()) {
                            upperBound = (sigReturnType).getConstraint();

                            if (upperBound) {
                                sigReturnType = upperBound;
                            }
                        }

                        if (!returnType.isResolved()) {
                            this.resolver.resolveDeclaredSymbol(returnType, enclosingDecl, this.context);
                        }

                        if (!sigReturnType.isResolved()) {
                            this.resolver.resolveDeclaredSymbol(sigReturnType, enclosingDecl, this.context);
                        }

                        var isAssignable = this.resolver.sourceIsAssignableToTarget(returnType, sigReturnType, this.context, comparisonInfo);

                        if (!isAssignable) {
                            if (comparisonInfo.message) {
                                this.postError(returnExpr.minChar, returnExpr.getLength(), typeCheckContext.scriptName, 81 /* Cannot_convert__0__to__1__NL__2 */, [returnType.toString(), sigReturnType.toString(), comparisonInfo.message], enclosingDecl);
                            } else {
                                this.postError(returnExpr.minChar, returnExpr.getLength(), typeCheckContext.scriptName, 80 /* Cannot_convert__0__to__1_ */, [returnType.toString(), sigReturnType.toString()], enclosingDecl);
                            }
                        }
                    }
                }
            }

            return returnType;
        };

        PullTypeChecker.prototype.typeCheckNameExpression = function (ast, typeCheckContext) {
            var enclosingDecl = typeCheckContext.getEnclosingDecl();
            var type = this.resolveSymbolAndReportDiagnostics(ast, false, enclosingDecl).getType();
            this.checkForResolutionError(type, enclosingDecl);
            return type;
        };

        PullTypeChecker.prototype.checkForSuperMemberAccess = function (memberAccessExpression, typeCheckContext, resolvedName) {
            var enclosingDecl = typeCheckContext.getEnclosingDecl();
            if (resolvedName) {
                if (memberAccessExpression.operand1.nodeType === 30 /* SuperExpression */ && !resolvedName.isError() && resolvedName.getKind() !== 65536 /* Method */) {
                    this.postError(memberAccessExpression.operand2.minChar, memberAccessExpression.operand2.getLength(), typeCheckContext.scriptName, 232 /* Only_public_instance_methods_of_the_base_class_are_accessible_via_the_super_keyword */, [], enclosingDecl);
                    return true;
                }
            }

            return false;
        };

        PullTypeChecker.prototype.checkForPrivateMemberAccess = function (memberAccessExpression, typeCheckContext, expressionType, resolvedName) {
            var enclosingDecl = typeCheckContext.getEnclosingDecl();
            if (resolvedName) {
                if (resolvedName.hasFlag(2 /* Private */)) {
                    var memberContainer = resolvedName.getContainer();
                    if (memberContainer && memberContainer.getKind() === 33554432 /* ConstructorType */) {
                        memberContainer = memberContainer.getAssociatedContainerType();
                    }

                    if (memberContainer && memberContainer.isClass()) {
                        var containingClass = typeCheckContext.getEnclosingClassDecl();
                        if (!containingClass || containingClass.getSymbol() !== memberContainer) {
                            var name = memberAccessExpression.operand2;
                            this.postError(name.minChar, name.getLength(), typeCheckContext.scriptName, 175 /* _0_1__is_inaccessible */, [memberContainer.toString(false), name.actualText], enclosingDecl);
                            return true;
                        }
                    }
                }
            }

            return false;
        };

        PullTypeChecker.prototype.checkForStaticMemberAccess = function (memberAccessExpression, typeCheckContext, expressionType, resolvedName) {
            if (expressionType && resolvedName && !resolvedName.isError()) {
                if (expressionType.isClass() || expressionType.getKind() === 33554432 /* ConstructorType */) {
                    var name = memberAccessExpression.operand2;
                    var enclosingDecl = typeCheckContext.getEnclosingDecl();

                    if (resolvedName.hasFlag(16 /* Static */) || this.resolver.isPrototypeMember(memberAccessExpression, enclosingDecl, this.context)) {
                        if (expressionType.getKind() !== 33554432 /* ConstructorType */) {
                            var enclosingDecl = typeCheckContext.getEnclosingDecl();
                            this.postError(name.minChar, name.getLength(), typeCheckContext.scriptName, 221 /* Static_member_cannot_be_accessed_off_an_instance_variable */, null, enclosingDecl);
                            return true;
                        }
                    }
                }
            }

            return false;
        };

        PullTypeChecker.prototype.typeCheckMemberAccessExpression = function (memberAccessExpression, typeCheckContext) {
            var enclosingDecl = typeCheckContext.getEnclosingDecl();
            var resolvedName = this.resolveSymbolAndReportDiagnostics(memberAccessExpression, false, enclosingDecl);
            var type = resolvedName.getType();

            this.checkForResolutionError(type, enclosingDecl);
            var prevCanUseTypeSymbol = this.context.canUseTypeSymbol;
            this.context.canUseTypeSymbol = true;
            var expressionType = this.typeCheckAST(memberAccessExpression.operand1, typeCheckContext, false);
            this.context.canUseTypeSymbol = prevCanUseTypeSymbol;

            this.checkForSuperMemberAccess(memberAccessExpression, typeCheckContext, resolvedName) || this.checkForPrivateMemberAccess(memberAccessExpression, typeCheckContext, expressionType, resolvedName) || this.checkForStaticMemberAccess(memberAccessExpression, typeCheckContext, expressionType, resolvedName);

            return type;
        };

        PullTypeChecker.prototype.typeCheckSwitchStatement = function (switchStatement, typeCheckContext) {
            this.typeCheckAST(switchStatement.val, typeCheckContext, false);
            this.typeCheckAST(switchStatement.caseList, typeCheckContext, false);
            this.typeCheckAST(switchStatement.defaultCase, typeCheckContext, false);

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeChecker.prototype.typeCheckExpressionStatement = function (ast, typeCheckContext, inContextuallyTypedAssignment) {
            return this.typeCheckAST(ast.expression, typeCheckContext, inContextuallyTypedAssignment);
        };

        PullTypeChecker.prototype.typeCheckCaseClause = function (caseClause, typeCheckContext) {
            this.typeCheckAST(caseClause.expr, typeCheckContext, false);
            this.typeCheckAST(caseClause.body, typeCheckContext, false);

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeChecker.prototype.typeCheckLabeledStatement = function (labeledStatement, typeCheckContext) {
            return this.typeCheckAST(labeledStatement.statement, typeCheckContext, false);
        };

        PullTypeChecker.prototype.checkTypePrivacy = function (declSymbol, typeSymbol, typeCheckContext, privacyErrorReporter) {
            if (!typeSymbol || typeSymbol.getKind() === 2 /* Primitive */) {
                return;
            }

            if (typeSymbol.isArray()) {
                this.checkTypePrivacy(declSymbol, (typeSymbol).getElementType(), typeCheckContext, privacyErrorReporter);
                return;
            }

            if (!typeSymbol.isNamedTypeSymbol()) {
                var members = typeSymbol.getMembers();
                for (var i = 0; i < members.length; i++) {
                    this.checkTypePrivacy(declSymbol, members[i].getType(), typeCheckContext, privacyErrorReporter);
                }

                this.checkTypePrivacyOfSignatures(declSymbol, typeSymbol.getCallSignatures(), typeCheckContext, privacyErrorReporter);
                this.checkTypePrivacyOfSignatures(declSymbol, typeSymbol.getConstructSignatures(), typeCheckContext, privacyErrorReporter);
                this.checkTypePrivacyOfSignatures(declSymbol, typeSymbol.getIndexSignatures(), typeCheckContext, privacyErrorReporter);

                return;
            }

            if (declSymbol.isExternallyVisible()) {
                var typeSymbolIsVisible = typeSymbol.isExternallyVisible();

                if (typeSymbolIsVisible) {
                    var typeSymbolPath = typeSymbol.pathToRoot();
                    if (typeSymbolPath.length && typeSymbolPath[typeSymbolPath.length - 1].getKind() === 32 /* DynamicModule */) {
                        var declSymbolPath = declSymbol.pathToRoot();
                        if (declSymbolPath.length && declSymbolPath[declSymbolPath.length - 1] != typeSymbolPath[typeSymbolPath.length - 1]) {
                            typeSymbolIsVisible = false;
                            for (var i = typeSymbolPath.length - 1; i >= 0; i--) {
                                var aliasSymbol = typeSymbolPath[i].getAliasedSymbol(declSymbol);
                                if (aliasSymbol) {
                                    TypeScript.CompilerDiagnostics.assert(aliasSymbol.getKind() === 256 /* TypeAlias */, "dynamic module need to be referenced by type alias");
                                    (aliasSymbol).setIsTypeUsedExternally();
                                    typeSymbolIsVisible = true;
                                    break;
                                }
                            }
                        }
                    }
                }

                if (!typeSymbolIsVisible) {
                    privacyErrorReporter(typeSymbol);
                }
            }
        };

        PullTypeChecker.prototype.checkTypePrivacyOfSignatures = function (declSymbol, signatures, typeCheckContext, privacyErrorReporter) {
            for (var i = 0; i < signatures.length; i++) {
                var signature = signatures[i];
                if (signatures.length && signature.isDefinition()) {
                    continue;
                }

                var typeParams = signature.getTypeParameters();
                for (var j = 0; j < typeParams.length; j++) {
                    this.checkTypePrivacy(declSymbol, typeParams[j], typeCheckContext, privacyErrorReporter);
                }

                var params = signature.getParameters();
                for (var j = 0; j < params.length; j++) {
                    var paramType = params[j].getType();
                    this.checkTypePrivacy(declSymbol, paramType, typeCheckContext, privacyErrorReporter);
                }

                var returnType = signature.getReturnType();
                this.checkTypePrivacy(declSymbol, returnType, typeCheckContext, privacyErrorReporter);
            }
        };

        PullTypeChecker.prototype.baseListPrivacyErrorReporter = function (declAST, declSymbol, baseAst, isExtendedType, typeSymbol, typeCheckContext) {
            var decl = this.resolver.getDeclForAST(declAST);
            var enclosingDecl = typeCheckContext.getEnclosingDecl();
            var messageCode;
            var messageArguments;

            var typeSymbolName = typeSymbol.getScopedName();
            if (typeSymbol.isContainer()) {
                if (!TypeScript.isQuoted(typeSymbolName)) {
                    typeSymbolName = "'" + typeSymbolName + "'";
                }
                if (declAST.nodeType === 13 /* ClassDeclaration */) {
                    if (isExtendedType) {
                        messageCode = 90 /* Exported_class__0__extends_class_from_inaccessible_module__1_ */;
                        messageArguments = [declSymbol.getScopedName(), typeSymbolName];
                    } else {
                        messageCode = 91 /* Exported_class__0__implements_interface_from_inaccessible_module__1_ */;
                        messageArguments = [declSymbol.getScopedName(), typeSymbolName];
                    }
                } else {
                    messageCode = 92 /* Exported_interface__0__extends_interface_from_inaccessible_module__1_ */;
                    messageArguments = [declSymbol.getDisplayName(), typeSymbolName];
                }
            } else {
                if (declAST.nodeType === 13 /* ClassDeclaration */) {
                    if (isExtendedType) {
                        messageCode = 87 /* Exported_class__0__extends_private_class__1_ */;
                        messageArguments = [declSymbol.getScopedName(), typeSymbolName];
                    } else {
                        messageCode = 88 /* Exported_class__0__implements_private_interface__1_ */;
                        messageArguments = [declSymbol.getScopedName(), typeSymbolName];
                    }
                } else {
                    messageCode = 89 /* Exported_interface__0__extends_private_interface__1_ */;
                    messageArguments = [declSymbol.getDisplayName(), typeSymbolName];
                }
            }

            this.context.postError(typeCheckContext.scriptName, baseAst.minChar, baseAst.getLength(), messageCode, messageArguments, enclosingDecl, true);
        };

        PullTypeChecker.prototype.variablePrivacyErrorReporter = function (declSymbol, typeSymbol, typeCheckContext) {
            var declAST = this.resolver.getASTForSymbol(declSymbol);
            var enclosingDecl = typeCheckContext.getEnclosingDecl();

            var isProperty = declSymbol.getKind() === 4096 /* Property */;
            var isPropertyOfClass = false;
            var declParent = declSymbol.getContainer();
            if (declParent && (declParent.getKind() === 8 /* Class */ || declParent.getKind() === 32768 /* ConstructorMethod */)) {
                isPropertyOfClass = true;
            }

            var messageCode;
            var messageArguments;
            var typeSymbolName = typeSymbol.getScopedName();
            if (typeSymbol.isContainer()) {
                if (!TypeScript.isQuoted(typeSymbolName)) {
                    typeSymbolName = "'" + typeSymbolName + "'";
                }

                if (declSymbol.hasFlag(16 /* Static */)) {
                    messageCode = 97 /* Public_static_property__0__of__exported_class_is_using_inaccessible_module__1_ */;
                    messageArguments = [declSymbol.getScopedName(), typeSymbolName];
                } else if (isProperty) {
                    if (isPropertyOfClass) {
                        messageCode = 98 /* Public_property__0__of__exported_class_is_using_inaccessible_module__1_ */;
                        messageArguments = [declSymbol.getScopedName(), typeSymbolName];
                    } else {
                        messageCode = 99 /* Property__0__of__exported_interface_is_using_inaccessible_module__1_ */;
                        messageArguments = [declSymbol.getScopedName(), typeSymbolName];
                    }
                } else {
                    messageCode = 100 /* Exported_variable__0__is_using_inaccessible_module__1_ */;
                    messageArguments = [declSymbol.getScopedName(), typeSymbolName];
                }
            } else {
                if (declSymbol.hasFlag(16 /* Static */)) {
                    messageCode = 93 /* Public_static_property__0__of__exported_class_has_or_is_using_private_type__1_ */;
                    messageArguments = [declSymbol.getScopedName(), typeSymbolName];
                } else if (isProperty) {
                    if (isPropertyOfClass) {
                        messageCode = 94 /* Public_property__0__of__exported_class_has_or_is_using_private_type__1_ */;
                        messageArguments = [declSymbol.getScopedName(), typeSymbolName];
                    } else {
                        messageCode = 95 /* Property__0__of__exported_interface_has_or_is_using_private_type__1_ */;
                        messageArguments = [declSymbol.getScopedName(), typeSymbolName];
                    }
                } else {
                    messageCode = 96 /* Exported_variable__0__has_or_is_using_private_type__1_ */;
                    messageArguments = [declSymbol.getScopedName(), typeSymbolName];
                }
            }

            this.context.postError(typeCheckContext.scriptName, declAST.minChar, declAST.getLength(), messageCode, messageArguments, enclosingDecl, true);
        };

        PullTypeChecker.prototype.checkFunctionTypePrivacy = function (funcDeclAST, inContextuallyTypedAssignment, typeCheckContext) {
            var _this = this;
            if (inContextuallyTypedAssignment || (funcDeclAST.getFunctionFlags() & 8192 /* IsFunctionExpression */) || (funcDeclAST.getFunctionFlags() & 16384 /* IsFunctionProperty */)) {
                return;
            }

            var functionDecl = typeCheckContext.semanticInfo.getDeclForAST(funcDeclAST);
            var functionSymbol = functionDecl.getSymbol();
            ;
            var functionSignature;

            var isGetter = funcDeclAST.isGetAccessor();
            var isSetter = funcDeclAST.isSetAccessor();

            if (isGetter || isSetter) {
                var accessorSymbol = functionSymbol;
                functionSignature = (isGetter ? accessorSymbol.getGetter() : accessorSymbol.getSetter()).getType().getCallSignatures()[0];
            } else {
                if (!functionSymbol) {
                    var parentDecl = functionDecl.getParentDecl();
                    functionSymbol = parentDecl.getSymbol();
                    if (functionSymbol && functionSymbol.isType() && !(functionSymbol).isNamedTypeSymbol()) {
                        return;
                    }
                } else if (functionSymbol.getKind() == 65536 /* Method */ && !functionSymbol.getContainer().isNamedTypeSymbol()) {
                    return;
                }
                functionSignature = functionDecl.getSignatureSymbol();
            }

            if (!isGetter) {
                var funcParams = functionSignature.getParameters();
                for (var i = 0; i < funcParams.length; i++) {
                    this.checkTypePrivacy(functionSymbol, funcParams[i].getType(), typeCheckContext, function (typeSymbol) {
                        return _this.functionArgumentTypePrivacyErrorReporter(funcDeclAST, i, funcParams[i], typeSymbol, typeCheckContext);
                    });
                }
            }

            if (!isSetter) {
                this.checkTypePrivacy(functionSymbol, functionSignature.getReturnType(), typeCheckContext, function (typeSymbol) {
                    return _this.functionReturnTypePrivacyErrorReporter(funcDeclAST, functionSignature.getReturnType(), typeSymbol, typeCheckContext);
                });
            }
        };

        PullTypeChecker.prototype.functionArgumentTypePrivacyErrorReporter = function (declAST, argIndex, paramSymbol, typeSymbol, typeCheckContext) {
            var decl = this.resolver.getDeclForAST(declAST);
            var enclosingDecl = typeCheckContext.getEnclosingDecl();

            var isGetter = declAST.isAccessor() && TypeScript.hasFlag(declAST.getFunctionFlags(), 32 /* GetAccessor */);
            var isSetter = declAST.isAccessor() && TypeScript.hasFlag(declAST.getFunctionFlags(), 64 /* SetAccessor */);
            var isStatic = (decl.getFlags() & 16 /* Static */) === 16 /* Static */;
            var isMethod = decl.getKind() === 65536 /* Method */;
            var isMethodOfClass = false;
            var declParent = decl.getParentDecl();
            if (declParent && (declParent.getKind() === 8 /* Class */ || declParent.getKind() === 32768 /* ConstructorMethod */)) {
                isMethodOfClass = true;
            }

            var start = declAST.arguments.members[argIndex].minChar;
            var length = declAST.arguments.members[argIndex].getLength();

            var typeSymbolName = typeSymbol.getScopedName();
            if (typeSymbol.isContainer()) {
                if (!TypeScript.isQuoted(typeSymbolName)) {
                    typeSymbolName = "'" + typeSymbolName + "'";
                }

                if (declAST.isConstructor) {
                    this.context.postError(typeCheckContext.scriptName, start, length, 110 /* Parameter__0__of_constructor_from_exported_class_is_using_inaccessible_module__1_ */, [paramSymbol.getScopedName(), typeSymbolName], enclosingDecl, true);
                } else if (isSetter) {
                    if (isStatic) {
                        this.context.postError(typeCheckContext.scriptName, start, length, 111 /* Parameter__0__of_public_static_property_setter_from_exported_class_is_using_inaccessible_module__1_ */, [paramSymbol.getScopedName(), typeSymbolName], enclosingDecl, true);
                    } else {
                        this.context.postError(typeCheckContext.scriptName, start, length, 112 /* Parameter__0__of_public_property_setter_from_exported_class_is_using_inaccessible_module__1_ */, [paramSymbol.getScopedName(), typeSymbolName], enclosingDecl, true);
                    }
                } else if (declAST.isConstructMember()) {
                    this.context.postError(typeCheckContext.scriptName, start, length, 113 /* Parameter__0__of_constructor_signature_from_exported_interface_is_using_inaccessible_module__1_ */, [paramSymbol.getScopedName(), typeSymbolName], enclosingDecl, true);
                } else if (declAST.isCallMember()) {
                    this.context.postError(typeCheckContext.scriptName, start, length, 114 /* Parameter__0__of_call_signature_from_exported_interface_is_using_inaccessible_module__1_ */, [paramSymbol.getScopedName(), typeSymbolName], enclosingDecl, true);
                } else if (isMethod) {
                    if (isStatic) {
                        this.context.postError(typeCheckContext.scriptName, start, length, 115 /* Parameter__0__of_public_static_method_from_exported_class_is_using_inaccessible_module__1_ */, [paramSymbol.getScopedName(), typeSymbolName], enclosingDecl, true);
                    } else if (isMethodOfClass) {
                        this.context.postError(typeCheckContext.scriptName, start, length, 116 /* Parameter__0__of_public_method_from_exported_class_is_using_inaccessible_module__1_ */, [paramSymbol.getScopedName(), typeSymbolName], enclosingDecl, true);
                    } else {
                        this.context.postError(typeCheckContext.scriptName, start, length, 117 /* Parameter__0__of_method_from_exported_interface_is_using_inaccessible_module__1_ */, [paramSymbol.getScopedName(), typeSymbolName], enclosingDecl, true);
                    }
                } else if (!isGetter) {
                    this.context.postError(typeCheckContext.scriptName, start, length, 118 /* Parameter__0__of_exported_function_is_using_inaccessible_module__1_ */, [paramSymbol.getScopedName(), typeSymbolName], enclosingDecl, true);
                }
            } else {
                if (declAST.isConstructor) {
                    this.context.postError(typeCheckContext.scriptName, start, length, 101 /* Parameter__0__of_constructor_from_exported_class_has_or_is_using_private_type__1_ */, [paramSymbol.getScopedName(), typeSymbolName], enclosingDecl, true);
                } else if (isSetter) {
                    if (isStatic) {
                        this.context.postError(typeCheckContext.scriptName, start, length, 102 /* Parameter__0__of_public_static_property_setter_from_exported_class_has_or_is_using_private_type__1_ */, [paramSymbol.getScopedName(), typeSymbolName], enclosingDecl, true);
                    } else {
                        this.context.postError(typeCheckContext.scriptName, start, length, 103 /* Parameter__0__of_public_property_setter_from_exported_class_has_or_is_using_private_type__1_ */, [paramSymbol.getScopedName(), typeSymbolName], enclosingDecl, true);
                    }
                } else if (declAST.isConstructMember()) {
                    this.context.postError(typeCheckContext.scriptName, start, length, 104 /* Parameter__0__of_constructor_signature_from_exported_interface_has_or_is_using_private_type__1_ */, [paramSymbol.getScopedName(), typeSymbolName], enclosingDecl, true);
                } else if (declAST.isCallMember()) {
                    this.context.postError(typeCheckContext.scriptName, start, length, 105 /* Parameter__0__of_call_signature_from_exported_interface_has_or_is_using_private_type__1_ */, [paramSymbol.getScopedName(), typeSymbolName], enclosingDecl, true);
                } else if (isMethod) {
                    if (isStatic) {
                        this.context.postError(typeCheckContext.scriptName, start, length, 106 /* Parameter__0__of_public_static_method_from_exported_class_has_or_is_using_private_type__1_ */, [paramSymbol.getScopedName(), typeSymbolName], enclosingDecl, true);
                    } else if (isMethodOfClass) {
                        this.context.postError(typeCheckContext.scriptName, start, length, 107 /* Parameter__0__of_public_method_from_exported_class_has_or_is_using_private_type__1_ */, [paramSymbol.getScopedName(), typeSymbolName], enclosingDecl, true);
                    } else {
                        this.context.postError(typeCheckContext.scriptName, start, length, 108 /* Parameter__0__of_method_from_exported_interface_has_or_is_using_private_type__1_ */, [paramSymbol.getScopedName(), typeSymbolName], enclosingDecl, true);
                    }
                } else if (!isGetter && !declAST.isIndexerMember()) {
                    this.context.postError(typeCheckContext.scriptName, start, length, 109 /* Parameter__0__of_exported_function_has_or_is_using_private_type__1_ */, [paramSymbol.getScopedName(), typeSymbolName], enclosingDecl, true);
                }
            }
        };

        PullTypeChecker.prototype.functionReturnTypePrivacyErrorReporter = function (declAST, funcReturnType, typeSymbol, typeCheckContext) {
            var _this = this;
            var decl = this.resolver.getDeclForAST(declAST);
            var enclosingDecl = typeCheckContext.getEnclosingDecl();

            var isGetter = declAST.isAccessor() && TypeScript.hasFlag(declAST.getFunctionFlags(), 32 /* GetAccessor */);
            var isSetter = declAST.isAccessor() && TypeScript.hasFlag(declAST.getFunctionFlags(), 64 /* SetAccessor */);
            var isStatic = (decl.getFlags() & 16 /* Static */) === 16 /* Static */;
            var isMethod = decl.getKind() === 65536 /* Method */;
            var isMethodOfClass = false;
            var declParent = decl.getParentDecl();
            if (declParent && (declParent.getKind() === 8 /* Class */ || declParent.getKind() === 32768 /* ConstructorMethod */)) {
                isMethodOfClass = true;
            }

            var messageCode = null;
            var messageArguments;
            var typeSymbolName = typeSymbol.getScopedName();
            if (typeSymbol.isContainer()) {
                if (!TypeScript.isQuoted(typeSymbolName)) {
                    typeSymbolName = "'" + typeSymbolName + "'";
                }

                if (isGetter) {
                    if (isStatic) {
                        messageCode = 128 /* Return_type_of_public_static_property_getter_from_exported_class_is_using_inaccessible_module__0_ */;
                        messageArguments = [typeSymbolName];
                    } else {
                        messageCode = 129 /* Return_type_of_public_property_getter_from_exported_class_is_using_inaccessible_module__0_ */;
                        messageArguments = [typeSymbolName];
                    }
                } else if (declAST.isConstructMember()) {
                    messageCode = 130 /* Return_type_of_constructor_signature_from_exported_interface_is_using_inaccessible_module__0_ */;
                    messageArguments = [typeSymbolName];
                } else if (declAST.isCallMember()) {
                    messageCode = 131 /* Return_type_of_call_signature_from_exported_interface_is_using_inaccessible_module__0_ */;
                    messageArguments = [typeSymbolName];
                } else if (declAST.isIndexerMember()) {
                    messageCode = 132 /* Return_type_of_index_signature_from_exported_interface_is_using_inaccessible_module__0_ */;
                    messageArguments = [typeSymbolName];
                } else if (isMethod) {
                    if (isStatic) {
                        messageCode = 133 /* Return_type_of_public_static_method_from_exported_class_is_using_inaccessible_module__0_ */;
                        messageArguments = [typeSymbolName];
                    } else if (isMethodOfClass) {
                        messageCode = 134 /* Return_type_of_public_method_from_exported_class_is_using_inaccessible_module__0_ */;
                        messageArguments = [typeSymbolName];
                    } else {
                        messageCode = 135 /* Return_type_of_method_from_exported_interface_is_using_inaccessible_module__0_ */;
                        messageArguments = [typeSymbolName];
                    }
                } else if (!isSetter && !declAST.isConstructor) {
                    messageCode = 136 /* Return_type_of_exported_function_is_using_inaccessible_module__0_ */;
                    messageArguments = [typeSymbolName];
                }
            } else {
                if (isGetter) {
                    if (isStatic) {
                        messageCode = 119 /* Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_private_type__0_ */;
                        messageArguments = [typeSymbolName];
                    } else {
                        messageCode = 120 /* Return_type_of_public_property_getter_from_exported_class_has_or_is_using_private_type__0_ */;
                        messageArguments = [typeSymbolName];
                    }
                } else if (declAST.isConstructMember()) {
                    messageCode = 121 /* Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_type__0_ */;
                    messageArguments = [typeSymbolName];
                } else if (declAST.isCallMember()) {
                    messageCode = 122 /* Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_type__0_ */;
                    messageArguments = [typeSymbolName];
                } else if (declAST.isIndexerMember()) {
                    messageCode = 123 /* Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_type__0_ */;
                    messageArguments = [typeSymbolName];
                } else if (isMethod) {
                    if (isStatic) {
                        messageCode = 124 /* Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_type__0_ */;
                        messageArguments = [typeSymbolName];
                    } else if (isMethodOfClass) {
                        messageCode = 125 /* Return_type_of_public_method_from_exported_class_has_or_is_using_private_type__0_ */;
                        messageArguments = [typeSymbolName];
                    } else {
                        messageCode = 126 /* Return_type_of_method_from_exported_interface_has_or_is_using_private_type__0_ */;
                        messageArguments = [typeSymbolName];
                    }
                } else if (!isSetter && !declAST.isConstructor) {
                    messageCode = 127 /* Return_type_of_exported_function_has_or_is_using_private_type__0_ */;
                    messageArguments = [typeSymbolName];
                }
            }

            if (messageCode) {
                var reportOnFuncDecl = false;
                var contextForReturnTypeResolution = new TypeScript.PullTypeResolutionContext();
                if (declAST.returnTypeAnnotation) {
                    var returnExpressionSymbolAndDiagnostics = this.resolver.resolveTypeReference(declAST.returnTypeAnnotation, decl, contextForReturnTypeResolution);
                    var returnExpressionSymbol = returnExpressionSymbolAndDiagnostics && returnExpressionSymbolAndDiagnostics.symbol;
                    if (returnExpressionSymbol === funcReturnType) {
                        this.context.postError(typeCheckContext.scriptName, declAST.returnTypeAnnotation.minChar, declAST.returnTypeAnnotation.getLength(), messageCode, messageArguments, enclosingDecl, true);
                    }
                }

                if (declAST.block) {
                    var reportErrorOnReturnExpressions = function (ast, parent, walker) {
                        var go = true;
                        switch (ast.nodeType) {
                            case 12 /* FunctionDeclaration */:
                                go = false;
                                break;

                            case 93 /* ReturnStatement */:
                                var returnStatement = ast;
                                var returnExpressionSymbol = _this.resolver.resolveAST(returnStatement.returnExpression, false, decl, contextForReturnTypeResolution).symbol.getType();

                                if (returnExpressionSymbol === funcReturnType) {
                                    _this.context.postError(typeCheckContext.scriptName, returnStatement.minChar, returnStatement.getLength(), messageCode, messageArguments, enclosingDecl, true);
                                } else {
                                    reportOnFuncDecl = true;
                                }
                                go = false;
                                break;

                            default:
                                break;
                        }

                        walker.options.goChildren = go;
                        return ast;
                    };

                    TypeScript.getAstWalkerFactory().walk(declAST.block, reportErrorOnReturnExpressions);
                }

                if (reportOnFuncDecl) {
                    this.context.postError(typeCheckContext.scriptName, declAST.minChar, declAST.getLength(), messageCode, messageArguments, enclosingDecl, true);
                }
            }
        };
        PullTypeChecker.globalPullTypeCheckPhase = 0;
        return PullTypeChecker;
    })();
    TypeScript.PullTypeChecker = PullTypeChecker;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (PullDeclEdit) {
        PullDeclEdit[PullDeclEdit["NoChanges"] = 0] = "NoChanges";
        PullDeclEdit[PullDeclEdit["DeclAdded"] = 1] = "DeclAdded";
        PullDeclEdit[PullDeclEdit["DeclRemoved"] = 2] = "DeclRemoved";
        PullDeclEdit[PullDeclEdit["DeclChanged"] = 3] = "DeclChanged";
    })(TypeScript.PullDeclEdit || (TypeScript.PullDeclEdit = {}));
    var PullDeclEdit = TypeScript.PullDeclEdit;

    var PullDeclDiff = (function () {
        function PullDeclDiff(oldDecl, newDecl, kind) {
            this.oldDecl = oldDecl;
            this.newDecl = newDecl;
            this.kind = kind;
        }
        return PullDeclDiff;
    })();
    TypeScript.PullDeclDiff = PullDeclDiff;

    var PullDeclDiffer = (function () {
        function PullDeclDiffer(oldSemanticInfo, newSemanticInfo) {
            this.oldSemanticInfo = oldSemanticInfo;
            this.newSemanticInfo = newSemanticInfo;
            this.differences = [];
        }
        PullDeclDiffer.diffDecls = function (oldDecl, oldSemanticInfo, newDecl, newSemanticInfo) {
            var declDiffer = new PullDeclDiffer(oldSemanticInfo, newSemanticInfo);
            declDiffer.diff(oldDecl, newDecl);
            return declDiffer.differences;
        };

        PullDeclDiffer.prototype.diff = function (oldDecl, newDecl) {
            TypeScript.Debug.assert(oldDecl.getName() === newDecl.getName());
            TypeScript.Debug.assert(oldDecl.getKind() === newDecl.getKind());

            var oldAST = this.oldSemanticInfo.getASTForDecl(oldDecl);
            var newAST = this.newSemanticInfo.getASTForDecl(newDecl);
            TypeScript.Debug.assert(oldAST !== undefined);
            TypeScript.Debug.assert(newAST !== undefined);

            if (oldAST === newAST) {
                return;
            }

            this.diff1(oldDecl, newDecl, oldAST, newAST, oldDecl.childDeclTypeCache, newDecl.childDeclTypeCache);
            this.diff1(oldDecl, newDecl, oldAST, newAST, oldDecl.childDeclTypeParameterCache, newDecl.childDeclTypeParameterCache);
            this.diff1(oldDecl, newDecl, oldAST, newAST, oldDecl.childDeclValueCache, newDecl.childDeclValueCache);
            this.diff1(oldDecl, newDecl, oldAST, newAST, oldDecl.childDeclNamespaceCache, newDecl.childDeclNamespaceCache);

            if (!this.isEquivalent(oldAST, newAST)) {
                this.differences.push(new PullDeclDiff(oldDecl, newDecl, 3 /* DeclChanged */));
            }
        };

        PullDeclDiffer.prototype.diff1 = function (oldDecl, newDecl, oldAST, newAST, oldNameToDecls, newNameToDecls) {
            var oldChildrenOfName;
            var newChildrenOfName;
            var oldChild;
            var newChild;

            for (var name in oldNameToDecls) {
                oldChildrenOfName = oldNameToDecls[name] || PullDeclDiffer.emptyDeclArray;
                newChildrenOfName = newNameToDecls[name] || PullDeclDiffer.emptyDeclArray;

                for (var i = 0, n = oldChildrenOfName.length; i < n; i++) {
                    oldChild = oldChildrenOfName[i];

                    switch (oldChild.getKind()) {
                        case 131072 /* FunctionExpression */:
                        case 512 /* ObjectLiteral */:
                        case 8388608 /* ObjectType */:
                        case 16777216 /* FunctionType */:
                        case 33554432 /* ConstructorType */:
                            continue;
                    }

                    if (i < newChildrenOfName.length) {
                        newChild = newChildrenOfName[i];

                        if (oldChild.getKind() === newChild.getKind()) {
                            this.diff(oldChild, newChildrenOfName[i]);
                        } else {
                            this.differences.push(new PullDeclDiff(oldChild, null, 2 /* DeclRemoved */));
                            this.differences.push(new PullDeclDiff(oldDecl, newChild, 1 /* DeclAdded */));
                        }
                    } else {
                        this.differences.push(new PullDeclDiff(oldChild, null, 2 /* DeclRemoved */));
                    }
                }
            }

            for (var name in newNameToDecls) {
                oldChildrenOfName = oldNameToDecls[name] || PullDeclDiffer.emptyDeclArray;
                newChildrenOfName = newNameToDecls[name] || PullDeclDiffer.emptyDeclArray;

                for (var i = oldChildrenOfName.length, n = newChildrenOfName.length; i < n; i++) {
                    newChild = newChildrenOfName[i];
                    this.differences.push(new PullDeclDiff(oldDecl, newChild, 1 /* DeclAdded */));
                }
            }
        };

        PullDeclDiffer.prototype.isEquivalent = function (oldAST, newAST) {
            TypeScript.Debug.assert(oldAST !== null);
            TypeScript.Debug.assert(newAST !== null);
            TypeScript.Debug.assert(oldAST !== newAST);

            if (oldAST.nodeType !== newAST.nodeType || oldAST.getFlags() !== newAST.getFlags()) {
                return false;
            }

            switch (oldAST.nodeType) {
                case 16 /* ImportDeclaration */:
                    return this.importDeclarationIsEquivalent(oldAST, newAST);
                case 15 /* ModuleDeclaration */:
                    return this.moduleDeclarationIsEquivalent(oldAST, newAST);
                case 13 /* ClassDeclaration */:
                    return this.classDeclarationIsEquivalent(oldAST, newAST);
                case 14 /* InterfaceDeclaration */:
                    return this.interfaceDeclarationIsEquivalent(oldAST, newAST);
                case 19 /* Parameter */:
                    return this.argumentDeclarationIsEquivalent(oldAST, newAST);
                case 17 /* VariableDeclarator */:
                    return this.variableDeclarationIsEquivalent(oldAST, newAST);
                case 9 /* TypeParameter */:
                    return this.typeParameterIsEquivalent(oldAST, newAST);
                case 12 /* FunctionDeclaration */:
                    return this.functionDeclarationIsEquivalent(oldAST, newAST);
                case 101 /* CatchClause */:
                    return this.catchClauseIsEquivalent(oldAST, newAST);
                case 99 /* WithStatement */:
                    return this.withStatementIsEquivalent(oldAST, newAST);
                case 2 /* Script */:
                    return this.scriptIsEquivalent(oldAST, newAST);
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        PullDeclDiffer.prototype.importDeclarationIsEquivalent = function (decl1, decl2) {
            return TypeScript.structuralEqualsNotIncludingPosition(decl1.alias, decl2.alias);
        };

        PullDeclDiffer.prototype.typeDeclarationIsEquivalent = function (decl1, decl2) {
            return decl1.getVarFlags() === decl2.getVarFlags() && TypeScript.structuralEqualsNotIncludingPosition(decl1.typeParameters, decl2.typeParameters) && TypeScript.structuralEqualsNotIncludingPosition(decl1.extendsList, decl2.extendsList) && TypeScript.structuralEqualsNotIncludingPosition(decl1.implementsList, decl2.implementsList);
        };

        PullDeclDiffer.prototype.classDeclarationIsEquivalent = function (decl1, decl2) {
            return this.typeDeclarationIsEquivalent(decl1, decl2);
        };

        PullDeclDiffer.prototype.interfaceDeclarationIsEquivalent = function (decl1, decl2) {
            return this.typeDeclarationIsEquivalent(decl1, decl2);
        };

        PullDeclDiffer.prototype.typeParameterIsEquivalent = function (decl1, decl2) {
            return TypeScript.structuralEqualsNotIncludingPosition(decl1.constraint, decl2.constraint);
        };

        PullDeclDiffer.prototype.boundDeclarationIsEquivalent = function (decl1, decl2) {
            if (decl1.getVarFlags() === decl2.getVarFlags() && TypeScript.structuralEqualsNotIncludingPosition(decl1.typeExpr, decl2.typeExpr)) {
                if (decl1.typeExpr === null) {
                    return TypeScript.structuralEqualsNotIncludingPosition(decl1.init, decl2.init);
                } else {
                    return true;
                }
            }

            return false;
        };

        PullDeclDiffer.prototype.argumentDeclarationIsEquivalent = function (decl1, decl2) {
            return this.boundDeclarationIsEquivalent(decl1, decl2) && decl1.isOptional === decl2.isOptional;
        };

        PullDeclDiffer.prototype.variableDeclarationIsEquivalent = function (decl1, decl2) {
            return this.boundDeclarationIsEquivalent(decl1, decl2);
        };

        PullDeclDiffer.prototype.functionDeclarationIsEquivalent = function (decl1, decl2) {
            if (decl1.hint === decl2.hint && decl1.getFunctionFlags() === decl2.getFunctionFlags() && decl1.variableArgList === decl2.variableArgList && decl1.isConstructor === decl2.isConstructor && TypeScript.structuralEqualsNotIncludingPosition(decl1.returnTypeAnnotation, decl2.returnTypeAnnotation) && TypeScript.structuralEqualsNotIncludingPosition(decl1.typeArguments, decl2.typeArguments) && TypeScript.structuralEqualsNotIncludingPosition(decl1.arguments, decl2.arguments)) {
                if (decl1.returnTypeAnnotation === null) {
                    return TypeScript.structuralEqualsNotIncludingPosition(decl1.block, decl2.block);
                } else {
                    return true;
                }
            }

            return false;
        };

        PullDeclDiffer.prototype.catchClauseIsEquivalent = function (decl1, decl2) {
            return TypeScript.structuralEqualsNotIncludingPosition(decl1.param, decl2.param) && TypeScript.structuralEqualsNotIncludingPosition(decl1.body, decl2.body);
        };

        PullDeclDiffer.prototype.withStatementIsEquivalent = function (decl1, decl2) {
            return TypeScript.structuralEqualsNotIncludingPosition(decl1.expr, decl2.expr) && TypeScript.structuralEqualsNotIncludingPosition(decl1.body, decl2.body);
        };

        PullDeclDiffer.prototype.scriptIsEquivalent = function (decl1, decl2) {
            return true;
        };

        PullDeclDiffer.prototype.moduleDeclarationIsEquivalent = function (decl1, decl2) {
            return decl1.getModuleFlags() === decl2.getModuleFlags() && decl2.prettyName === decl2.prettyName && TypeScript.ArrayUtilities.sequenceEquals(decl1.amdDependencies, decl2.amdDependencies, TypeScript.StringUtilities.stringEquals);
        };
        PullDeclDiffer.emptyDeclArray = [];
        return PullDeclDiffer;
    })();
    TypeScript.PullDeclDiffer = PullDeclDiffer;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.declCacheHit = 0;
    TypeScript.declCacheMiss = 0;
    TypeScript.symbolCacheHit = 0;
    TypeScript.symbolCacheMiss = 0;

    var SemanticInfo = (function () {
        function SemanticInfo(compilationUnitPath) {
            this.topLevelDecls = [];
            this.topLevelSynthesizedDecls = [];
            this.astDeclMap = new TypeScript.DataMap();
            this.declASTMap = new TypeScript.DataMap();
            this.syntaxElementDeclMap = new TypeScript.DataMap();
            this.declSyntaxElementMap = new TypeScript.DataMap();
            this.astSymbolMap = new TypeScript.DataMap();
            this.symbolASTMap = new TypeScript.DataMap();
            this.syntaxElementSymbolMap = new TypeScript.DataMap();
            this.symbolSyntaxElementMap = new TypeScript.DataMap();
            this.properties = new SemanticInfoProperties();
            this.hasBeenTypeChecked = false;
            this.compilationUnitPath = compilationUnitPath;
        }
        SemanticInfo.prototype.addTopLevelDecl = function (decl) {
            this.topLevelDecls[this.topLevelDecls.length] = decl;
        };

        SemanticInfo.prototype.setTypeChecked = function () {
            this.hasBeenTypeChecked = true;
        };
        SemanticInfo.prototype.getTypeChecked = function () {
            return this.hasBeenTypeChecked;
        };
        SemanticInfo.prototype.invalidate = function () {
            this.astSymbolMap = new TypeScript.DataMap();
            this.symbolASTMap = new TypeScript.DataMap();
        };

        SemanticInfo.prototype.getTopLevelDecls = function () {
            return this.topLevelDecls;
        };

        SemanticInfo.prototype.getPath = function () {
            return this.compilationUnitPath;
        };

        SemanticInfo.prototype.addSynthesizedDecl = function (decl) {
            this.topLevelSynthesizedDecls[this.topLevelSynthesizedDecls.length] = decl;
        };
        SemanticInfo.prototype.getSynthesizedDecls = function () {
            return this.topLevelSynthesizedDecls;
        };

        SemanticInfo.prototype.getDeclForAST = function (ast) {
            return this.astDeclMap.read(ast.getID().toString());
        };

        SemanticInfo.prototype.setDeclForAST = function (ast, decl) {
            this.astDeclMap.link(ast.getID().toString(), decl);
        };

        SemanticInfo.prototype.getDeclKey = function (decl) {
            var decl1 = decl;

            if (!decl1.__declKey) {
                decl1.__declKey = decl.getDeclID().toString() + "-" + decl.getKind().toString();
            }

            return decl1.__declKey;
        };

        SemanticInfo.prototype.getASTForDecl = function (decl) {
            return this.declASTMap.read(this.getDeclKey(decl));
        };

        SemanticInfo.prototype.setASTForDecl = function (decl, ast) {
            this.declASTMap.link(this.getDeclKey(decl), ast);
        };

        SemanticInfo.prototype.setSymbolAndDiagnosticsForAST = function (ast, symbolAndDiagnostics) {
            this.astSymbolMap.link(ast.getID().toString(), symbolAndDiagnostics);
            this.symbolASTMap.link(symbolAndDiagnostics.symbol.getSymbolID().toString(), ast);
        };

        SemanticInfo.prototype.getSymbolAndDiagnosticsForAST = function (ast) {
            return this.astSymbolMap.read(ast.getID().toString());
        };

        SemanticInfo.prototype.getASTForSymbol = function (symbol) {
            return this.symbolASTMap.read(symbol.getSymbolID().toString());
        };

        SemanticInfo.prototype.getSyntaxElementForDecl = function (decl) {
            return this.declSyntaxElementMap.read(this.getDeclKey(decl));
        };

        SemanticInfo.prototype.setSyntaxElementForDecl = function (decl, syntaxElement) {
            this.declSyntaxElementMap.link(this.getDeclKey(decl), syntaxElement);
        };

        SemanticInfo.prototype.getDeclForSyntaxElement = function (syntaxElement) {
            return this.syntaxElementDeclMap.read(TypeScript.Collections.identityHashCode(syntaxElement).toString());
        };

        SemanticInfo.prototype.setDeclForSyntaxElement = function (syntaxElement, decl) {
            this.syntaxElementDeclMap.link(TypeScript.Collections.identityHashCode(syntaxElement).toString(), decl);
        };

        SemanticInfo.prototype.getSyntaxElementForSymbol = function (symbol) {
            return this.symbolSyntaxElementMap.read(symbol.getSymbolID().toString());
        };

        SemanticInfo.prototype.getSymbolForSyntaxElement = function (syntaxElement) {
            return this.syntaxElementSymbolMap.read(TypeScript.Collections.identityHashCode(syntaxElement).toString());
        };

        SemanticInfo.prototype.setSymbolForSyntaxElement = function (syntaxElement, symbol) {
            this.syntaxElementSymbolMap.link(TypeScript.Collections.identityHashCode(syntaxElement).toString(), symbol);
            this.symbolSyntaxElementMap.link(symbol.getSymbolID().toString(), syntaxElement);
        };

        SemanticInfo.prototype.getDiagnostics = function (semanticErrors) {
            for (var i = 0; i < this.topLevelDecls.length; i++) {
                TypeScript.getDiagnosticsFromEnclosingDecl(this.topLevelDecls[i], semanticErrors);
            }
        };

        SemanticInfo.prototype.getProperties = function () {
            return this.properties;
        };
        return SemanticInfo;
    })();
    TypeScript.SemanticInfo = SemanticInfo;

    var SemanticInfoProperties = (function () {
        function SemanticInfoProperties() {
            this.unitContainsBool = false;
        }
        return SemanticInfoProperties;
    })();
    TypeScript.SemanticInfoProperties = SemanticInfoProperties;

    var SemanticInfoChain = (function () {
        function SemanticInfoChain() {
            this.units = [new SemanticInfo("")];
            this.declCache = new TypeScript.BlockIntrinsics();
            this.symbolCache = new TypeScript.BlockIntrinsics();
            this.unitCache = new TypeScript.BlockIntrinsics();
            this.declSymbolMap = new TypeScript.DataMap();
            this.anyTypeSymbol = null;
            this.booleanTypeSymbol = null;
            this.numberTypeSymbol = null;
            this.stringTypeSymbol = null;
            this.nullTypeSymbol = null;
            this.undefinedTypeSymbol = null;
            this.elementTypeSymbol = null;
            this.voidTypeSymbol = null;
            if (TypeScript.globalBinder) {
                TypeScript.globalBinder.semanticInfoChain = this;
            }

            var globalDecl = this.getGlobalDecl();
            var globalInfo = this.units[0];
            globalInfo.addTopLevelDecl(globalDecl);
        }
        SemanticInfoChain.prototype.addPrimitiveType = function (name, globalDecl) {
            var span = new TypeScript.TextSpan(0, 0);
            var decl = new TypeScript.PullDecl(name, name, 2 /* Primitive */, 0 /* None */, span, "");
            var symbol = new TypeScript.PullPrimitiveTypeSymbol(name);

            symbol.addDeclaration(decl);
            decl.setSymbol(symbol);

            symbol.setResolved();

            if (globalDecl) {
                globalDecl.addChildDecl(decl);
            }

            return symbol;
        };

        SemanticInfoChain.prototype.addPrimitiveValue = function (name, type, globalDecl) {
            var span = new TypeScript.TextSpan(0, 0);
            var decl = new TypeScript.PullDecl(name, name, 1024 /* Variable */, 8 /* Ambient */, span, "");
            var symbol = new TypeScript.PullSymbol(name, 1024 /* Variable */);

            symbol.addDeclaration(decl);
            decl.setSymbol(symbol);
            symbol.setType(type);
            symbol.setResolved();

            globalDecl.addChildDecl(decl);
        };

        SemanticInfoChain.prototype.getGlobalDecl = function () {
            var span = new TypeScript.TextSpan(0, 0);
            var globalDecl = new TypeScript.PullDecl("", "", 0 /* Global */, 0 /* None */, span, "");

            this.anyTypeSymbol = this.addPrimitiveType("any", globalDecl);
            this.booleanTypeSymbol = this.addPrimitiveType("boolean", globalDecl);
            this.numberTypeSymbol = this.addPrimitiveType("number", globalDecl);
            this.stringTypeSymbol = this.addPrimitiveType("string", globalDecl);
            this.voidTypeSymbol = this.addPrimitiveType("void", globalDecl);
            this.elementTypeSymbol = this.addPrimitiveType("_element", globalDecl);

            this.nullTypeSymbol = this.addPrimitiveType("null", null);
            this.undefinedTypeSymbol = this.addPrimitiveType("undefined", null);
            this.addPrimitiveValue("undefined", this.undefinedTypeSymbol, globalDecl);
            this.addPrimitiveValue("null", this.nullTypeSymbol, globalDecl);

            return globalDecl;
        };

        SemanticInfoChain.prototype.addUnit = function (unit) {
            this.units[this.units.length] = unit;
            this.unitCache[unit.getPath()] = unit;
        };

        SemanticInfoChain.prototype.getUnit = function (compilationUnitPath) {
            for (var i = 0; i < this.units.length; i++) {
                if (this.units[i].getPath() === compilationUnitPath) {
                    return this.units[i];
                }
            }

            return null;
        };

        SemanticInfoChain.prototype.updateUnit = function (oldUnit, newUnit) {
            for (var i = 0; i < this.units.length; i++) {
                if (this.units[i].getPath() === oldUnit.getPath()) {
                    this.units[i] = newUnit;
                    this.unitCache[oldUnit.getPath()] = newUnit;
                    return;
                }
            }
        };

        SemanticInfoChain.prototype.collectAllTopLevelDecls = function () {
            var decls = [];
            var unitDecls;

            for (var i = 0; i < this.units.length; i++) {
                unitDecls = this.units[i].getTopLevelDecls();
                for (var j = 0; j < unitDecls.length; j++) {
                    decls[decls.length] = unitDecls[j];
                }
            }

            return decls;
        };

        SemanticInfoChain.prototype.collectAllSynthesizedDecls = function () {
            var decls = [];
            var synthDecls;

            for (var i = 0; i < this.units.length; i++) {
                synthDecls = this.units[i].getSynthesizedDecls();
                for (var j = 0; j < synthDecls.length; j++) {
                    decls[decls.length] = synthDecls[j];
                }
            }

            return decls;
        };

        SemanticInfoChain.prototype.getDeclPathCacheID = function (declPath, declKind) {
            var cacheID = "";

            for (var i = 0; i < declPath.length; i++) {
                cacheID += "#" + declPath[i];
            }

            return cacheID + "#" + declKind.toString();
        };

        SemanticInfoChain.prototype.findDecls = function (declPath, declKind) {
            var cacheID = this.getDeclPathCacheID(declPath, declKind);

            if (declPath.length) {
                var cachedDecls = this.declCache[cacheID];

                if (cachedDecls && cachedDecls.length) {
                    TypeScript.declCacheHit++;
                    return cachedDecls;
                }
            }

            TypeScript.declCacheMiss++;

            var declsToSearch = this.collectAllTopLevelDecls();

            var decls = [];
            var path;
            var foundDecls = [];
            var keepSearching = (declKind & 4 /* Container */) || (declKind & 16 /* Interface */);

            for (var i = 0; i < declPath.length; i++) {
                path = declPath[i];
                decls = [];

                for (var j = 0; j < declsToSearch.length; j++) {
                    foundDecls = declsToSearch[j].searchChildDecls(path, declKind);

                    for (var k = 0; k < foundDecls.length; k++) {
                        decls[decls.length] = foundDecls[k];
                    }

                    if (foundDecls.length && !keepSearching) {
                        break;
                    }
                }

                declsToSearch = decls;

                if (!declsToSearch) {
                    break;
                }
            }

            if (decls.length) {
                this.declCache[cacheID] = decls;
            }

            return decls;
        };

        SemanticInfoChain.prototype.findSymbol = function (declPath, declType) {
            var cacheID = this.getDeclPathCacheID(declPath, declType);

            if (declPath.length) {
                var cachedSymbol = this.symbolCache[cacheID];

                if (cachedSymbol) {
                    TypeScript.symbolCacheHit++;
                    return cachedSymbol;
                }
            }

            TypeScript.symbolCacheMiss++;

            var decls = this.findDecls(declPath, declType);
            var symbol = null;

            if (decls.length) {
                symbol = decls[0].getSymbol();

                if (symbol) {
                    this.symbolCache[cacheID] = symbol;

                    symbol.addCacheID(cacheID);
                }
            }

            return symbol;
        };

        SemanticInfoChain.prototype.cacheGlobalSymbol = function (symbol, kind) {
            var cacheID1 = this.getDeclPathCacheID([symbol.getName()], kind);
            var cacheID2 = this.getDeclPathCacheID([symbol.getName()], symbol.getKind());

            if (!this.symbolCache[cacheID1]) {
                this.symbolCache[cacheID1] = symbol;
                symbol.addCacheID(cacheID1);
            }

            if (!this.symbolCache[cacheID2]) {
                this.symbolCache[cacheID2] = symbol;
                symbol.addCacheID(cacheID2);
            }
        };

        SemanticInfoChain.prototype.cleanDecl = function (decl) {
            decl.setSymbol(null);
            decl.setSignatureSymbol(null);
            decl.setSpecializingSignatureSymbol(null);
            decl.setIsBound(false);

            var children = decl.getChildDecls();

            for (var i = 0; i < children.length; i++) {
                this.cleanDecl(children[i]);
            }

            var typeParameters = decl.getTypeParameters();

            for (var i = 0; i < typeParameters.length; i++) {
                this.cleanDecl(typeParameters[i]);
            }

            var valueDecl = decl.getValueDecl();

            if (valueDecl) {
                this.cleanDecl(valueDecl);
            }
        };

        SemanticInfoChain.prototype.cleanAllDecls = function () {
            var topLevelDecls = this.collectAllTopLevelDecls();

            for (var i = 1; i < topLevelDecls.length; i++) {
                this.cleanDecl(topLevelDecls[i]);
            }

            var synthesizedDecls = this.collectAllSynthesizedDecls();

            for (var i = 0; i < synthesizedDecls.length; i++) {
                this.cleanDecl(synthesizedDecls[i]);
            }
        };

        SemanticInfoChain.prototype.update = function () {
            this.declCache = new TypeScript.BlockIntrinsics();
            this.symbolCache = new TypeScript.BlockIntrinsics();
            this.units[0] = new SemanticInfo("");
            this.units[0].addTopLevelDecl(this.getGlobalDecl());
            this.cleanAllDecls();

            for (var unit in this.unitCache) {
                if (this.unitCache[unit]) {
                    this.unitCache[unit].invalidate();
                }
            }
        };

        SemanticInfoChain.prototype.invalidateUnit = function (compilationUnitPath) {
            var unit = this.unitCache[compilationUnitPath];
            if (unit) {
                unit.invalidate();
            }
        };

        SemanticInfoChain.prototype.getDeclForAST = function (ast, unitPath) {
            var unit = this.unitCache[unitPath];

            if (unit) {
                return unit.getDeclForAST(ast);
            }

            return null;
        };

        SemanticInfoChain.prototype.getASTForDecl = function (decl) {
            var unit = this.unitCache[decl.getScriptName()];

            if (unit) {
                return unit.getASTForDecl(decl);
            }

            return null;
        };

        SemanticInfoChain.prototype.getSymbolAndDiagnosticsForAST = function (ast, unitPath) {
            var unit = this.unitCache[unitPath];

            if (unit) {
                return unit.getSymbolAndDiagnosticsForAST(ast);
            }

            return null;
        };

        SemanticInfoChain.prototype.getASTForSymbol = function (symbol, unitPath) {
            var unit = this.unitCache[unitPath];

            if (unit) {
                return unit.getASTForSymbol(symbol);
            }

            return null;
        };

        SemanticInfoChain.prototype.setSymbolAndDiagnosticsForAST = function (ast, symbolAndDiagnostics, unitPath) {
            var unit = this.unitCache[unitPath];

            if (unit) {
                unit.setSymbolAndDiagnosticsForAST(ast, symbolAndDiagnostics);
            }
        };

        SemanticInfoChain.prototype.setSymbolForDecl = function (decl, symbol) {
            this.declSymbolMap.link(decl.getDeclID().toString(), symbol);
        };
        SemanticInfoChain.prototype.getSymbolForDecl = function (decl) {
            return this.declSymbolMap.read(decl.getDeclID().toString());
        };

        SemanticInfoChain.prototype.removeSymbolFromCache = function (symbol) {
            var path = [symbol.getName()];
            var kind = (symbol.getKind() & TypeScript.PullElementKind.SomeType) !== 0 ? TypeScript.PullElementKind.SomeType : TypeScript.PullElementKind.SomeValue;

            var kindID = this.getDeclPathCacheID(path, kind);
            var symID = this.getDeclPathCacheID(path, symbol.getKind());

            symbol.addCacheID(kindID);
            symbol.addCacheID(symID);

            symbol.invalidateCachedIDs(this.symbolCache);
        };

        SemanticInfoChain.prototype.postDiagnostics = function () {
            var errors = [];

            for (var i = 1; i < this.units.length; i++) {
                this.units[i].getDiagnostics(errors);
            }

            return errors;
        };
        return SemanticInfoChain;
    })();
    TypeScript.SemanticInfoChain = SemanticInfoChain;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var DeclCollectionContext = (function () {
        function DeclCollectionContext(semanticInfo, scriptName) {
            if (typeof scriptName === "undefined") { scriptName = ""; }
            this.semanticInfo = semanticInfo;
            this.scriptName = scriptName;
            this.parentChain = [];
            this.foundValueDecl = false;
        }
        DeclCollectionContext.prototype.getParent = function () {
            return this.parentChain ? this.parentChain[this.parentChain.length - 1] : null;
        };

        DeclCollectionContext.prototype.pushParent = function (parentDecl) {
            if (parentDecl) {
                this.parentChain[this.parentChain.length] = parentDecl;
            }
        };

        DeclCollectionContext.prototype.popParent = function () {
            this.parentChain.length--;
        };
        return DeclCollectionContext;
    })();
    TypeScript.DeclCollectionContext = DeclCollectionContext;

    function preCollectImportDecls(ast, parentAST, context) {
        var importDecl = ast;
        var declFlags = 0 /* None */;
        var span = TypeScript.TextSpan.fromBounds(importDecl.minChar, importDecl.limChar);

        var parent = context.getParent();

        if (parent && (parent.getKind() === 536870912 /* WithBlock */ || (parent.getFlags() & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.PullDecl(importDecl.id.text, importDecl.id.actualText, 256 /* TypeAlias */, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(ast, decl);
        context.semanticInfo.setASTForDecl(decl, ast);

        parent.addChildDecl(decl);
        decl.setParentDecl(parent);

        return false;
    }
    TypeScript.preCollectImportDecls = preCollectImportDecls;

    function preCollectModuleDecls(ast, parentAST, context) {
        var moduleDecl = ast;
        var declFlags = 0 /* None */;
        var modName = (moduleDecl.name).text;
        var isDynamic = TypeScript.isQuoted(modName) || TypeScript.hasFlag(moduleDecl.getModuleFlags(), 512 /* IsDynamic */);
        var kind = 4 /* Container */;

        if (TypeScript.hasFlag(moduleDecl.getModuleFlags(), 8 /* Ambient */)) {
            declFlags |= 8 /* Ambient */;
        }

        if (TypeScript.hasFlag(moduleDecl.getModuleFlags(), 1 /* Exported */)) {
            declFlags |= 1 /* Exported */;
        }

        if (TypeScript.hasFlag(moduleDecl.getModuleFlags(), 128 /* IsEnum */)) {
            declFlags |= (4096 /* Enum */ | 131072 /* InitializedEnum */);
            kind = 64 /* Enum */;
        } else {
            kind = isDynamic ? 32 /* DynamicModule */ : 4 /* Container */;
        }

        var span = TypeScript.TextSpan.fromBounds(moduleDecl.minChar, moduleDecl.limChar);

        var decl = new TypeScript.PullDecl(modName, (moduleDecl.name).actualText, kind, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(ast, decl);
        context.semanticInfo.setASTForDecl(decl, ast);

        var parent = context.getParent();
        parent.addChildDecl(decl);
        decl.setParentDecl(parent);

        context.pushParent(decl);

        return true;
    }
    TypeScript.preCollectModuleDecls = preCollectModuleDecls;

    function preCollectClassDecls(classDecl, parentAST, context) {
        var declFlags = 0 /* None */;
        var constructorDeclKind = 1024 /* Variable */;

        if (TypeScript.hasFlag(classDecl.getVarFlags(), 8 /* Ambient */)) {
            declFlags |= 8 /* Ambient */;
        }

        if (TypeScript.hasFlag(classDecl.getVarFlags(), 1 /* Exported */)) {
            declFlags |= 1 /* Exported */;
        }

        var span = TypeScript.TextSpan.fromBounds(classDecl.minChar, classDecl.limChar);

        var decl = new TypeScript.PullDecl(classDecl.name.text, classDecl.name.actualText, 8 /* Class */, declFlags, span, context.scriptName);

        var constructorDecl = new TypeScript.PullDecl(classDecl.name.text, classDecl.name.actualText, constructorDeclKind, declFlags | 16384 /* ClassConstructorVariable */, span, context.scriptName);

        decl.setValueDecl(constructorDecl);

        var parent = context.getParent();
        parent.addChildDecl(decl);
        parent.addChildDecl(constructorDecl);
        decl.setParentDecl(parent);
        constructorDecl.setParentDecl(parent);

        context.pushParent(decl);

        context.semanticInfo.setDeclForAST(classDecl, decl);
        context.semanticInfo.setASTForDecl(decl, classDecl);
        context.semanticInfo.setASTForDecl(constructorDecl, classDecl);

        return true;
    }
    TypeScript.preCollectClassDecls = preCollectClassDecls;

    function createObjectTypeDeclaration(interfaceDecl, context) {
        var declFlags = 0 /* None */;

        var span = TypeScript.TextSpan.fromBounds(interfaceDecl.minChar, interfaceDecl.limChar);

        var parent = context.getParent();

        if (parent && (parent.getKind() === 536870912 /* WithBlock */ || (parent.getFlags() & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.PullDecl("", "", 8388608 /* ObjectType */, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(interfaceDecl, decl);
        context.semanticInfo.setASTForDecl(decl, interfaceDecl);

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        return true;
    }
    TypeScript.createObjectTypeDeclaration = createObjectTypeDeclaration;

    function preCollectInterfaceDecls(interfaceDecl, parentAST, context) {
        var declFlags = 0 /* None */;

        if (interfaceDecl.getFlags() & 8 /* TypeReference */) {
            return createObjectTypeDeclaration(interfaceDecl, context);
        }

        if (TypeScript.hasFlag(interfaceDecl.getVarFlags(), 1 /* Exported */)) {
            declFlags |= 1 /* Exported */;
        }

        var span = TypeScript.TextSpan.fromBounds(interfaceDecl.minChar, interfaceDecl.limChar);

        var decl = new TypeScript.PullDecl(interfaceDecl.name.text, interfaceDecl.name.actualText, 16 /* Interface */, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(interfaceDecl, decl);
        context.semanticInfo.setASTForDecl(decl, interfaceDecl);

        var parent = context.getParent();

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        return true;
    }
    TypeScript.preCollectInterfaceDecls = preCollectInterfaceDecls;

    function preCollectParameterDecl(argDecl, parentAST, context) {
        var declFlags = 0 /* None */;

        if (TypeScript.hasFlag(argDecl.getVarFlags(), 2 /* Private */)) {
            declFlags |= 2 /* Private */;
        } else {
            declFlags |= 4 /* Public */;
        }

        if (TypeScript.hasFlag(argDecl.getFlags(), 4 /* OptionalName */) || TypeScript.hasFlag(argDecl.id.getFlags(), 4 /* OptionalName */)) {
            declFlags |= 128 /* Optional */;
        }

        var parent = context.getParent();

        if (parent && (parent.getKind() === 536870912 /* WithBlock */ || (parent.getFlags() & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var span = TypeScript.TextSpan.fromBounds(argDecl.minChar, argDecl.limChar);

        var decl = new TypeScript.PullDecl(argDecl.id.text, argDecl.id.actualText, 2048 /* Parameter */, declFlags, span, context.scriptName);

        parent.addChildDecl(decl);
        decl.setParentDecl(parent);

        if (TypeScript.hasFlag(argDecl.getVarFlags(), 256 /* Property */)) {
            var propDecl = new TypeScript.PullDecl(argDecl.id.text, argDecl.id.actualText, 4096 /* Property */, declFlags, span, context.scriptName);
            propDecl.setValueDecl(decl);
            context.parentChain[context.parentChain.length - 2].addChildDecl(propDecl);
            propDecl.setParentDecl(context.parentChain[context.parentChain.length - 2]);
            context.semanticInfo.setASTForDecl(decl, argDecl);
            context.semanticInfo.setASTForDecl(propDecl, argDecl);
            context.semanticInfo.setDeclForAST(argDecl, propDecl);
        } else {
            context.semanticInfo.setASTForDecl(decl, argDecl);
            context.semanticInfo.setDeclForAST(argDecl, decl);
        }

        if (argDecl.typeExpr && ((argDecl.typeExpr).term.nodeType === 14 /* InterfaceDeclaration */ || (argDecl.typeExpr).term.nodeType === 12 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            if (parent) {
                declCollectionContext.pushParent(parent);
            }

            declCollectionContext.scriptName = context.scriptName;

            TypeScript.getAstWalkerFactory().walk((argDecl.typeExpr).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return false;
    }
    TypeScript.preCollectParameterDecl = preCollectParameterDecl;

    function preCollectTypeParameterDecl(typeParameterDecl, parentAST, context) {
        var declFlags = 0 /* None */;

        var span = TypeScript.TextSpan.fromBounds(typeParameterDecl.minChar, typeParameterDecl.limChar);

        var parent = context.getParent();

        if (parent && (parent.getKind() === 536870912 /* WithBlock */ || (parent.getFlags() & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.PullDecl(typeParameterDecl.name.text, typeParameterDecl.name.actualText, 8192 /* TypeParameter */, declFlags, span, context.scriptName);
        context.semanticInfo.setASTForDecl(decl, typeParameterDecl);
        context.semanticInfo.setDeclForAST(typeParameterDecl, decl);

        parent.addChildDecl(decl);
        decl.setParentDecl(parent);

        if (typeParameterDecl.constraint && ((typeParameterDecl.constraint).term.nodeType === 14 /* InterfaceDeclaration */ || (typeParameterDecl.constraint).term.nodeType === 12 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            if (parent) {
                declCollectionContext.pushParent(parent);
            }

            declCollectionContext.scriptName = context.scriptName;

            TypeScript.getAstWalkerFactory().walk((typeParameterDecl.constraint).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }
    TypeScript.preCollectTypeParameterDecl = preCollectTypeParameterDecl;

    function createPropertySignature(propertyDecl, context) {
        var declFlags = 4 /* Public */;
        var parent = context.getParent();
        var declType = parent.getKind() === 64 /* Enum */ ? 67108864 /* EnumMember */ : 4096 /* Property */;

        if (TypeScript.hasFlag(propertyDecl.id.getFlags(), 4 /* OptionalName */)) {
            declFlags |= 128 /* Optional */;
        }

        if (TypeScript.hasFlag(propertyDecl.getVarFlags(), 4096 /* Constant */)) {
            declFlags |= 524288 /* Constant */;
        }

        var span = TypeScript.TextSpan.fromBounds(propertyDecl.minChar, propertyDecl.limChar);

        var decl = new TypeScript.PullDecl(propertyDecl.id.text, propertyDecl.id.actualText, declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(propertyDecl, decl);
        context.semanticInfo.setASTForDecl(decl, propertyDecl);

        parent.addChildDecl(decl);
        decl.setParentDecl(parent);

        if (propertyDecl.typeExpr && ((propertyDecl.typeExpr).term.nodeType === 14 /* InterfaceDeclaration */ || (propertyDecl.typeExpr).term.nodeType === 12 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            if (parent) {
                declCollectionContext.pushParent(parent);
            }

            declCollectionContext.scriptName = context.scriptName;

            TypeScript.getAstWalkerFactory().walk((propertyDecl.typeExpr).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return false;
    }
    TypeScript.createPropertySignature = createPropertySignature;

    function createMemberVariableDeclaration(memberDecl, context) {
        var declFlags = 0 /* None */;
        var declType = 4096 /* Property */;

        if (TypeScript.hasFlag(memberDecl.getVarFlags(), 2 /* Private */)) {
            declFlags |= 2 /* Private */;
        } else {
            declFlags |= 4 /* Public */;
        }

        if (TypeScript.hasFlag(memberDecl.getVarFlags(), 16 /* Static */)) {
            declFlags |= 16 /* Static */;
        }

        var span = TypeScript.TextSpan.fromBounds(memberDecl.minChar, memberDecl.limChar);

        var decl = new TypeScript.PullDecl(memberDecl.id.text, memberDecl.id.actualText, declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(memberDecl, decl);
        context.semanticInfo.setASTForDecl(decl, memberDecl);

        var parent = context.getParent();
        parent.addChildDecl(decl);
        decl.setParentDecl(parent);

        if (memberDecl.typeExpr && ((memberDecl.typeExpr).term.nodeType === 14 /* InterfaceDeclaration */ || (memberDecl.typeExpr).term.nodeType === 12 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            if (parent) {
                declCollectionContext.pushParent(parent);
            }

            declCollectionContext.scriptName = context.scriptName;

            TypeScript.getAstWalkerFactory().walk((memberDecl.typeExpr).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return false;
    }
    TypeScript.createMemberVariableDeclaration = createMemberVariableDeclaration;

    function createVariableDeclaration(varDecl, context) {
        var declFlags = 0 /* None */;
        var declType = 1024 /* Variable */;

        if (TypeScript.hasFlag(varDecl.getVarFlags(), 8 /* Ambient */)) {
            declFlags |= 8 /* Ambient */;
        }

        if (TypeScript.hasFlag(varDecl.getVarFlags(), 1 /* Exported */)) {
            declFlags |= 1 /* Exported */;
        }

        var span = TypeScript.TextSpan.fromBounds(varDecl.minChar, varDecl.limChar);

        var parent = context.getParent();

        if (parent && (parent.getKind() === 536870912 /* WithBlock */ || (parent.getFlags() & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.PullDecl(varDecl.id.text, varDecl.id.actualText, declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(varDecl, decl);
        context.semanticInfo.setASTForDecl(decl, varDecl);

        parent.addChildDecl(decl);
        decl.setParentDecl(parent);

        if (varDecl.typeExpr && ((varDecl.typeExpr).term.nodeType === 14 /* InterfaceDeclaration */ || (varDecl.typeExpr).term.nodeType === 12 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            if (parent) {
                declCollectionContext.pushParent(parent);
            }

            declCollectionContext.scriptName = context.scriptName;

            TypeScript.getAstWalkerFactory().walk((varDecl.typeExpr).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return false;
    }
    TypeScript.createVariableDeclaration = createVariableDeclaration;

    function preCollectVarDecls(ast, parentAST, context) {
        var varDecl = ast;
        var declFlags = 0 /* None */;
        var declType = 1024 /* Variable */;
        var isProperty = false;
        var isStatic = false;

        if (TypeScript.hasFlag(varDecl.getVarFlags(), 2048 /* ClassProperty */)) {
            return createMemberVariableDeclaration(varDecl, context);
        } else if (TypeScript.hasFlag(varDecl.getVarFlags(), 256 /* Property */)) {
            return createPropertySignature(varDecl, context);
        }

        return createVariableDeclaration(varDecl, context);
    }
    TypeScript.preCollectVarDecls = preCollectVarDecls;

    function createFunctionTypeDeclaration(functionTypeDeclAST, context) {
        var declFlags = 2048 /* Signature */;
        var declType = 16777216 /* FunctionType */;

        var span = TypeScript.TextSpan.fromBounds(functionTypeDeclAST.minChar, functionTypeDeclAST.limChar);

        var parent = context.getParent();

        if (parent && (parent.getKind() === 536870912 /* WithBlock */ || (parent.getFlags() & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.PullDecl("", "", declType, declFlags, span, context.semanticInfo.getPath());
        context.semanticInfo.setDeclForAST(functionTypeDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, functionTypeDeclAST);

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        if (functionTypeDeclAST.returnTypeAnnotation && ((functionTypeDeclAST.returnTypeAnnotation).term.nodeType === 14 /* InterfaceDeclaration */ || (functionTypeDeclAST.returnTypeAnnotation).term.nodeType === 12 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            if (parent) {
                declCollectionContext.pushParent(parent);
            }

            declCollectionContext.scriptName = context.scriptName;

            TypeScript.getAstWalkerFactory().walk((functionTypeDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }
    TypeScript.createFunctionTypeDeclaration = createFunctionTypeDeclaration;

    function createConstructorTypeDeclaration(constructorTypeDeclAST, context) {
        var declFlags = 0 /* None */;
        var declType = 33554432 /* ConstructorType */;

        var span = TypeScript.TextSpan.fromBounds(constructorTypeDeclAST.minChar, constructorTypeDeclAST.limChar);

        var parent = context.getParent();

        if (parent && (parent.getKind() === 536870912 /* WithBlock */ || (parent.getFlags() & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.PullDecl("{new}", "{new}", declType, declFlags, span, context.semanticInfo.getPath());
        context.semanticInfo.setDeclForAST(constructorTypeDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, constructorTypeDeclAST);

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        if (constructorTypeDeclAST.returnTypeAnnotation && ((constructorTypeDeclAST.returnTypeAnnotation).term.nodeType === 14 /* InterfaceDeclaration */ || (constructorTypeDeclAST.returnTypeAnnotation).term.nodeType === 12 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            if (parent) {
                declCollectionContext.pushParent(parent);
            }

            declCollectionContext.scriptName = context.scriptName;

            TypeScript.getAstWalkerFactory().walk((constructorTypeDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }
    TypeScript.createConstructorTypeDeclaration = createConstructorTypeDeclaration;

    function createFunctionDeclaration(funcDeclAST, context) {
        var declFlags = 0 /* None */;
        var declType = 16384 /* Function */;

        if (TypeScript.hasFlag(funcDeclAST.getFunctionFlags(), 8 /* Ambient */)) {
            declFlags |= 8 /* Ambient */;
        }

        if (TypeScript.hasFlag(funcDeclAST.getFunctionFlags(), 1 /* Exported */)) {
            declFlags |= 1 /* Exported */;
        }

        if (!funcDeclAST.block) {
            declFlags |= 2048 /* Signature */;
        }

        var span = TypeScript.TextSpan.fromBounds(funcDeclAST.minChar, funcDeclAST.limChar);

        var parent = context.getParent();

        if (parent && (parent.getKind() === 536870912 /* WithBlock */ || (parent.getFlags() & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.PullDecl(funcDeclAST.name.text, funcDeclAST.name.actualText, declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(funcDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, funcDeclAST);

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        if (funcDeclAST.returnTypeAnnotation && ((funcDeclAST.returnTypeAnnotation).term.nodeType === 14 /* InterfaceDeclaration */ || (funcDeclAST.returnTypeAnnotation).term.nodeType === 12 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            if (parent) {
                declCollectionContext.pushParent(parent);
            }

            declCollectionContext.scriptName = context.scriptName;

            TypeScript.getAstWalkerFactory().walk((funcDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }
    TypeScript.createFunctionDeclaration = createFunctionDeclaration;

    function createFunctionExpressionDeclaration(functionExpressionDeclAST, context) {
        var declFlags = 0 /* None */;

        if (TypeScript.hasFlag(functionExpressionDeclAST.getFunctionFlags(), 2048 /* IsFatArrowFunction */)) {
            declFlags |= 8192 /* FatArrow */;
        }

        var span = TypeScript.TextSpan.fromBounds(functionExpressionDeclAST.minChar, functionExpressionDeclAST.limChar);

        var parent = context.getParent();

        if (parent && (parent.getKind() === 536870912 /* WithBlock */ || (parent.getFlags() & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var name = functionExpressionDeclAST.name ? functionExpressionDeclAST.name.actualText : "";
        var decl = new TypeScript.PullFunctionExpressionDecl(name, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(functionExpressionDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, functionExpressionDeclAST);

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        if (functionExpressionDeclAST.returnTypeAnnotation && ((functionExpressionDeclAST.returnTypeAnnotation).term.nodeType === 14 /* InterfaceDeclaration */ || (functionExpressionDeclAST.returnTypeAnnotation).term.nodeType === 12 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            declCollectionContext.scriptName = context.scriptName;

            if (parent) {
                declCollectionContext.pushParent(parent);
            }

            TypeScript.getAstWalkerFactory().walk((functionExpressionDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }
    TypeScript.createFunctionExpressionDeclaration = createFunctionExpressionDeclaration;

    function createMemberFunctionDeclaration(memberFunctionDeclAST, context) {
        var declFlags = 0 /* None */;
        var declType = 65536 /* Method */;

        if (TypeScript.hasFlag(memberFunctionDeclAST.getFunctionFlags(), 16 /* Static */)) {
            declFlags |= 16 /* Static */;
        }

        if (TypeScript.hasFlag(memberFunctionDeclAST.getFunctionFlags(), 2 /* Private */)) {
            declFlags |= 2 /* Private */;
        } else {
            declFlags |= 4 /* Public */;
        }

        if (!memberFunctionDeclAST.block) {
            declFlags |= 2048 /* Signature */;
        }

        if (TypeScript.hasFlag(memberFunctionDeclAST.name.getFlags(), 4 /* OptionalName */)) {
            declFlags |= 128 /* Optional */;
        }

        var span = TypeScript.TextSpan.fromBounds(memberFunctionDeclAST.minChar, memberFunctionDeclAST.limChar);

        var decl = new TypeScript.PullDecl(memberFunctionDeclAST.name.text, memberFunctionDeclAST.name.actualText, declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(memberFunctionDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, memberFunctionDeclAST);

        var parent = context.getParent();

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        if (memberFunctionDeclAST.returnTypeAnnotation && ((memberFunctionDeclAST.returnTypeAnnotation).term.nodeType === 14 /* InterfaceDeclaration */ || (memberFunctionDeclAST.returnTypeAnnotation).term.nodeType === 12 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            declCollectionContext.scriptName = context.scriptName;

            if (parent) {
                declCollectionContext.pushParent(parent);
            }

            TypeScript.getAstWalkerFactory().walk((memberFunctionDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }
    TypeScript.createMemberFunctionDeclaration = createMemberFunctionDeclaration;

    function createIndexSignatureDeclaration(indexSignatureDeclAST, context) {
        var declFlags = 2048 /* Signature */ | 1024 /* Index */;
        var declType = 4194304 /* IndexSignature */;

        var span = TypeScript.TextSpan.fromBounds(indexSignatureDeclAST.minChar, indexSignatureDeclAST.limChar);

        var parent = context.getParent();

        if (parent && (parent.getKind() === 536870912 /* WithBlock */ || (parent.getFlags() & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.PullDecl("[]", "[]", declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(indexSignatureDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, indexSignatureDeclAST);

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        if (indexSignatureDeclAST.returnTypeAnnotation && ((indexSignatureDeclAST.returnTypeAnnotation).term.nodeType === 14 /* InterfaceDeclaration */ || (indexSignatureDeclAST.returnTypeAnnotation).term.nodeType === 12 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            if (parent) {
                declCollectionContext.pushParent(parent);
            }

            declCollectionContext.scriptName = context.scriptName;

            TypeScript.getAstWalkerFactory().walk((indexSignatureDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }
    TypeScript.createIndexSignatureDeclaration = createIndexSignatureDeclaration;

    function createCallSignatureDeclaration(callSignatureDeclAST, context) {
        var declFlags = 2048 /* Signature */ | 256 /* Call */;
        var declType = 1048576 /* CallSignature */;

        var span = TypeScript.TextSpan.fromBounds(callSignatureDeclAST.minChar, callSignatureDeclAST.limChar);

        var parent = context.getParent();

        if (parent && (parent.getKind() === 536870912 /* WithBlock */ || (parent.getFlags() & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.PullDecl("()", "()", declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(callSignatureDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, callSignatureDeclAST);

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        if (callSignatureDeclAST.returnTypeAnnotation && ((callSignatureDeclAST.returnTypeAnnotation).term.nodeType === 14 /* InterfaceDeclaration */ || (callSignatureDeclAST.returnTypeAnnotation).term.nodeType === 12 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            declCollectionContext.scriptName = context.scriptName;

            if (parent) {
                declCollectionContext.pushParent(parent);
            }

            TypeScript.getAstWalkerFactory().walk((callSignatureDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }
    TypeScript.createCallSignatureDeclaration = createCallSignatureDeclaration;

    function createConstructSignatureDeclaration(constructSignatureDeclAST, context) {
        var declFlags = 2048 /* Signature */ | 256 /* Call */;
        var declType = 2097152 /* ConstructSignature */;

        var span = TypeScript.TextSpan.fromBounds(constructSignatureDeclAST.minChar, constructSignatureDeclAST.limChar);

        var parent = context.getParent();

        if (parent && (parent.getKind() === 536870912 /* WithBlock */ || (parent.getFlags() & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.PullDecl("new", "new", declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(constructSignatureDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, constructSignatureDeclAST);

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        if (constructSignatureDeclAST.returnTypeAnnotation && ((constructSignatureDeclAST.returnTypeAnnotation).term.nodeType === 14 /* InterfaceDeclaration */ || (constructSignatureDeclAST.returnTypeAnnotation).term.nodeType === 12 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            declCollectionContext.scriptName = context.scriptName;

            if (parent) {
                declCollectionContext.pushParent(parent);
            }

            TypeScript.getAstWalkerFactory().walk((constructSignatureDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }
    TypeScript.createConstructSignatureDeclaration = createConstructSignatureDeclaration;

    function createClassConstructorDeclaration(constructorDeclAST, context) {
        var declFlags = 512 /* Constructor */;
        var declType = 32768 /* ConstructorMethod */;

        if (!constructorDeclAST.block) {
            declFlags |= 2048 /* Signature */;
        }

        var span = TypeScript.TextSpan.fromBounds(constructorDeclAST.minChar, constructorDeclAST.limChar);

        var parent = context.getParent();

        if (parent) {
            var parentFlags = parent.getFlags();

            if (parentFlags & 1 /* Exported */) {
                declFlags |= 1 /* Exported */;
            }
        }

        var decl = new TypeScript.PullDecl(parent.getName(), parent.getDisplayName(), declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(constructorDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, constructorDeclAST);

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        if (constructorDeclAST.returnTypeAnnotation && ((constructorDeclAST.returnTypeAnnotation).term.nodeType === 14 /* InterfaceDeclaration */ || (constructorDeclAST.returnTypeAnnotation).term.nodeType === 12 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            declCollectionContext.scriptName = context.scriptName;

            if (parent) {
                declCollectionContext.pushParent(parent);
            }

            TypeScript.getAstWalkerFactory().walk((constructorDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }
    TypeScript.createClassConstructorDeclaration = createClassConstructorDeclaration;

    function createGetAccessorDeclaration(getAccessorDeclAST, context) {
        var declFlags = 4 /* Public */;
        var declType = 262144 /* GetAccessor */;

        if (TypeScript.hasFlag(getAccessorDeclAST.getFunctionFlags(), 16 /* Static */)) {
            declFlags |= 16 /* Static */;
        }

        if (TypeScript.hasFlag(getAccessorDeclAST.name.getFlags(), 4 /* OptionalName */)) {
            declFlags |= 128 /* Optional */;
        }

        if (TypeScript.hasFlag(getAccessorDeclAST.getFunctionFlags(), 2 /* Private */)) {
            declFlags |= 2 /* Private */;
        } else {
            declFlags |= 4 /* Public */;
        }

        var span = TypeScript.TextSpan.fromBounds(getAccessorDeclAST.minChar, getAccessorDeclAST.limChar);

        var parent = context.getParent();

        if (parent && (parent.getKind() === 536870912 /* WithBlock */ || (parent.getFlags() & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.PullDecl(getAccessorDeclAST.name.text, getAccessorDeclAST.name.actualText, declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(getAccessorDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, getAccessorDeclAST);

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        if (getAccessorDeclAST.returnTypeAnnotation && ((getAccessorDeclAST.returnTypeAnnotation).term.nodeType === 14 /* InterfaceDeclaration */ || (getAccessorDeclAST.returnTypeAnnotation).term.nodeType === 12 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo);

            declCollectionContext.scriptName = context.scriptName;

            if (parent) {
                declCollectionContext.pushParent(parent);
            }

            TypeScript.getAstWalkerFactory().walk((getAccessorDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }
    TypeScript.createGetAccessorDeclaration = createGetAccessorDeclaration;

    function createSetAccessorDeclaration(setAccessorDeclAST, context) {
        var declFlags = 4 /* Public */;
        var declType = 524288 /* SetAccessor */;

        if (TypeScript.hasFlag(setAccessorDeclAST.getFunctionFlags(), 16 /* Static */)) {
            declFlags |= 16 /* Static */;
        }

        if (TypeScript.hasFlag(setAccessorDeclAST.name.getFlags(), 4 /* OptionalName */)) {
            declFlags |= 128 /* Optional */;
        }

        if (TypeScript.hasFlag(setAccessorDeclAST.getFunctionFlags(), 2 /* Private */)) {
            declFlags |= 2 /* Private */;
        } else {
            declFlags |= 4 /* Public */;
        }

        var span = TypeScript.TextSpan.fromBounds(setAccessorDeclAST.minChar, setAccessorDeclAST.limChar);

        var parent = context.getParent();

        if (parent && (parent.getKind() === 536870912 /* WithBlock */ || (parent.getFlags() & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.PullDecl(setAccessorDeclAST.name.actualText, setAccessorDeclAST.name.actualText, declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(setAccessorDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, setAccessorDeclAST);

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        return true;
    }
    TypeScript.createSetAccessorDeclaration = createSetAccessorDeclaration;

    function preCollectCatchDecls(ast, parentAST, context) {
        var declFlags = 0 /* None */;
        var declType = 1073741824 /* CatchBlock */;

        var span = TypeScript.TextSpan.fromBounds(ast.minChar, ast.limChar);

        var parent = context.getParent();

        if (parent && (parent.getKind() === 536870912 /* WithBlock */ || (parent.getFlags() & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.PullDecl("", "", declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(ast, decl);
        context.semanticInfo.setASTForDecl(decl, ast);

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        return true;
    }
    TypeScript.preCollectCatchDecls = preCollectCatchDecls;

    function preCollectWithDecls(ast, parentAST, context) {
        var declFlags = 0 /* None */;
        var declType = 536870912 /* WithBlock */;

        var span = TypeScript.TextSpan.fromBounds(ast.minChar, ast.limChar);

        var parent = context.getParent();

        var decl = new TypeScript.PullDecl("", "", declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(ast, decl);
        context.semanticInfo.setASTForDecl(decl, ast);

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        return true;
    }
    TypeScript.preCollectWithDecls = preCollectWithDecls;

    function preCollectFuncDecls(ast, parentAST, context) {
        var funcDecl = ast;

        if (funcDecl.isConstructor) {
            return createClassConstructorDeclaration(funcDecl, context);
        } else if (funcDecl.isGetAccessor()) {
            return createGetAccessorDeclaration(funcDecl, context);
        } else if (funcDecl.isSetAccessor()) {
            return createSetAccessorDeclaration(funcDecl, context);
        } else if (TypeScript.hasFlag(funcDecl.getFunctionFlags(), 1024 /* ConstructMember */)) {
            return TypeScript.hasFlag(funcDecl.getFlags(), 8 /* TypeReference */) ? createConstructorTypeDeclaration(funcDecl, context) : createConstructSignatureDeclaration(funcDecl, context);
        } else if (TypeScript.hasFlag(funcDecl.getFunctionFlags(), 512 /* CallMember */)) {
            return createCallSignatureDeclaration(funcDecl, context);
        } else if (TypeScript.hasFlag(funcDecl.getFunctionFlags(), 4096 /* IndexerMember */)) {
            return createIndexSignatureDeclaration(funcDecl, context);
        } else if (TypeScript.hasFlag(funcDecl.getFlags(), 8 /* TypeReference */)) {
            return createFunctionTypeDeclaration(funcDecl, context);
        } else if (TypeScript.hasFlag(funcDecl.getFunctionFlags(), 256 /* Method */)) {
            return createMemberFunctionDeclaration(funcDecl, context);
        } else if (TypeScript.hasFlag(funcDecl.getFunctionFlags(), (8192 /* IsFunctionExpression */ | 2048 /* IsFatArrowFunction */ | 16384 /* IsFunctionProperty */))) {
            return createFunctionExpressionDeclaration(funcDecl, context);
        }

        return createFunctionDeclaration(funcDecl, context);
    }
    TypeScript.preCollectFuncDecls = preCollectFuncDecls;

    function preCollectDecls(ast, parentAST, walker) {
        var context = walker.state;
        var go = false;

        if (ast.nodeType === 2 /* Script */) {
            var script = ast;
            var span = TypeScript.TextSpan.fromBounds(script.minChar, script.limChar);

            var decl = new TypeScript.PullDecl(context.scriptName, context.scriptName, 1 /* Script */, 0 /* None */, span, context.scriptName);
            context.semanticInfo.setDeclForAST(ast, decl);
            context.semanticInfo.setASTForDecl(decl, ast);

            context.pushParent(decl);

            go = true;
        } else if (ast.nodeType === 1 /* List */) {
            go = true;
        } else if (ast.nodeType === 81 /* Block */) {
            go = true;
        } else if (ast.nodeType === 18 /* VariableDeclaration */) {
            go = true;
        } else if (ast.nodeType === 97 /* VariableStatement */) {
            go = true;
        } else if (ast.nodeType === 15 /* ModuleDeclaration */) {
            go = preCollectModuleDecls(ast, parentAST, context);
        } else if (ast.nodeType === 13 /* ClassDeclaration */) {
            go = preCollectClassDecls(ast, parentAST, context);
        } else if (ast.nodeType === 14 /* InterfaceDeclaration */) {
            go = preCollectInterfaceDecls(ast, parentAST, context);
        } else if (ast.nodeType === 19 /* Parameter */) {
            go = preCollectParameterDecl(ast, parentAST, context);
        } else if (ast.nodeType === 17 /* VariableDeclarator */) {
            go = preCollectVarDecls(ast, parentAST, context);
        } else if (ast.nodeType === 12 /* FunctionDeclaration */) {
            go = preCollectFuncDecls(ast, parentAST, context);
        } else if (ast.nodeType === 16 /* ImportDeclaration */) {
            go = preCollectImportDecls(ast, parentAST, context);
        } else if (ast.nodeType === 9 /* TypeParameter */) {
            go = preCollectTypeParameterDecl(ast, parentAST, context);
        } else if (ast.nodeType === 91 /* IfStatement */) {
            go = true;
        } else if (ast.nodeType === 90 /* ForStatement */) {
            go = true;
        } else if (ast.nodeType === 89 /* ForInStatement */) {
            go = true;
        } else if (ast.nodeType === 98 /* WhileStatement */) {
            go = true;
        } else if (ast.nodeType === 85 /* DoStatement */) {
            go = true;
        } else if (ast.nodeType === 25 /* CommaExpression */) {
            go = true;
        } else if (ast.nodeType === 93 /* ReturnStatement */) {
            go = true;
        } else if (ast.nodeType === 94 /* SwitchStatement */ || ast.nodeType === 100 /* CaseClause */) {
            go = true;
        } else if (ast.nodeType === 36 /* InvocationExpression */) {
            go = true;
        } else if (ast.nodeType === 37 /* ObjectCreationExpression */) {
            go = true;
        } else if (ast.nodeType === 96 /* TryStatement */) {
            go = true;
        } else if (ast.nodeType === 92 /* LabeledStatement */) {
            go = true;
        } else if (ast.nodeType === 101 /* CatchClause */) {
            go = preCollectCatchDecls(ast, parentAST, context);
        } else if (ast.nodeType === 99 /* WithStatement */) {
            go = preCollectWithDecls(ast, parentAST, context);
        }

        walker.options.goChildren = go;

        return ast;
    }
    TypeScript.preCollectDecls = preCollectDecls;

    function isContainer(decl) {
        return decl.getKind() === 4 /* Container */ || decl.getKind() === 32 /* DynamicModule */ || decl.getKind() === 64 /* Enum */;
    }

    function getInitializationFlag(decl) {
        if (decl.getKind() & 4 /* Container */) {
            return 32768 /* InitializedModule */;
        } else if (decl.getKind() & 64 /* Enum */) {
            return 131072 /* InitializedEnum */;
        } else if (decl.getKind() & 32 /* DynamicModule */) {
            return 65536 /* InitializedDynamicModule */;
        }

        return 0 /* None */;
    }

    function hasInitializationFlag(decl) {
        var kind = decl.getKind();

        if (kind & 4 /* Container */) {
            return (decl.getFlags() & 32768 /* InitializedModule */) !== 0;
        } else if (kind & 64 /* Enum */) {
            return (decl.getFlags() & 131072 /* InitializedEnum */) != 0;
        } else if (kind & 32 /* DynamicModule */) {
            return (decl.getFlags() & 65536 /* InitializedDynamicModule */) !== 0;
        }

        return false;
    }

    function postCollectDecls(ast, parentAST, walker) {
        var context = walker.state;
        var parentDecl;
        var initFlag = 0 /* None */;

        if (ast.nodeType === 15 /* ModuleDeclaration */) {
            var thisModule = context.getParent();
            context.popParent();
            parentDecl = context.getParent();

            if (hasInitializationFlag(thisModule)) {
                if (parentDecl && isContainer(parentDecl)) {
                    initFlag = getInitializationFlag(parentDecl);
                    parentDecl.setFlags(parentDecl.getFlags() | initFlag);
                }

                var valueDecl = new TypeScript.PullDecl(thisModule.getName(), thisModule.getDisplayName(), 1024 /* Variable */, thisModule.getFlags(), thisModule.getSpan(), context.scriptName);

                thisModule.setValueDecl(valueDecl);

                context.semanticInfo.setASTForDecl(valueDecl, ast);

                if (parentDecl) {
                    parentDecl.addChildDecl(valueDecl);
                    valueDecl.setParentDecl(parentDecl);
                }
            }
        } else if (ast.nodeType === 13 /* ClassDeclaration */) {
            context.popParent();

            parentDecl = context.getParent();

            if (parentDecl && isContainer(parentDecl)) {
                initFlag = getInitializationFlag(parentDecl);
                parentDecl.setFlags(parentDecl.getFlags() | initFlag);
            }
        } else if (ast.nodeType === 14 /* InterfaceDeclaration */) {
            context.popParent();
        } else if (ast.nodeType === 12 /* FunctionDeclaration */) {
            context.popParent();

            parentDecl = context.getParent();

            if (parentDecl && isContainer(parentDecl)) {
                initFlag = getInitializationFlag(parentDecl);
                parentDecl.setFlags(parentDecl.getFlags() | initFlag);
            }
        } else if (ast.nodeType === 17 /* VariableDeclarator */) {
            parentDecl = context.getParent();

            if (parentDecl && isContainer(parentDecl)) {
                initFlag = getInitializationFlag(parentDecl);
                parentDecl.setFlags(parentDecl.getFlags() | initFlag);
            }
        } else if (ast.nodeType === 101 /* CatchClause */) {
            parentDecl = context.getParent();

            if (parentDecl && isContainer(parentDecl)) {
                initFlag = getInitializationFlag(parentDecl);
                parentDecl.setFlags(parentDecl.getFlags() | initFlag);
            }

            context.popParent();
        } else if (ast.nodeType === 99 /* WithStatement */) {
            parentDecl = context.getParent();

            if (parentDecl && isContainer(parentDecl)) {
                initFlag = getInitializationFlag(parentDecl);
                parentDecl.setFlags(parentDecl.getFlags() | initFlag);
            }

            context.popParent();
        }

        return ast;
    }
    TypeScript.postCollectDecls = postCollectDecls;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.globalBindingPhase = 0;

    function getPathToDecl(decl) {
        if (!decl) {
            return [];
        }

        var decls = decl.getParentPath();

        if (decls) {
            return decls;
        } else {
            decls = [decl];
        }

        var parentDecl = decl.getParentDecl();

        while (parentDecl) {
            if (parentDecl && decls[decls.length - 1] != parentDecl && !(parentDecl.getKind() & 512 /* ObjectLiteral */)) {
                decls[decls.length] = parentDecl;
            }
            parentDecl = parentDecl.getParentDecl();
        }

        decls = decls.reverse();

        decl.setParentPath(decls);

        return decls;
    }
    TypeScript.getPathToDecl = getPathToDecl;

    function findSymbolInContext(name, declKind, startingDecl) {
        var startTime = new Date().getTime();
        var contextSymbolPath = getPathToDecl(startingDecl);
        var copyOfContextSymbolPath = [];
        var symbol = null;

        var endTime = 0;

        if (contextSymbolPath.length) {
            for (var i = 0; i < contextSymbolPath.length; i++) {
                copyOfContextSymbolPath[copyOfContextSymbolPath.length] = contextSymbolPath[i].getName();
            }

            copyOfContextSymbolPath[copyOfContextSymbolPath.length] = name;

            while (copyOfContextSymbolPath.length >= 2) {
                symbol = TypeScript.globalSemanticInfoChain.findSymbol(copyOfContextSymbolPath, declKind);

                if (symbol) {
                    endTime = new Date().getTime();
                    TypeScript.time_in_findSymbol += endTime - startTime;

                    return symbol;
                }
                copyOfContextSymbolPath.length -= 2;
                copyOfContextSymbolPath[copyOfContextSymbolPath.length] = name;
            }
        }

        symbol = TypeScript.globalSemanticInfoChain.findSymbol([name], declKind);

        endTime = new Date().getTime();
        TypeScript.time_in_findSymbol += endTime - startTime;

        return symbol;
    }
    TypeScript.findSymbolInContext = findSymbolInContext;

    var PullSymbolBinder = (function () {
        function PullSymbolBinder(semanticInfoChain) {
            this.semanticInfoChain = semanticInfoChain;
            this.bindingPhase = TypeScript.globalBindingPhase++;
            this.functionTypeParameterCache = new TypeScript.BlockIntrinsics();
            this.reBindingAfterChange = false;
            this.startingDeclForRebind = TypeScript.pullDeclID;
            this.startingSymbolForRebind = TypeScript.pullSymbolID;
        }
        PullSymbolBinder.prototype.findTypeParameterInCache = function (name) {
            return this.functionTypeParameterCache[name];
        };

        PullSymbolBinder.prototype.addTypeParameterToCache = function (typeParameter) {
            this.functionTypeParameterCache[typeParameter.getName()] = typeParameter;
        };

        PullSymbolBinder.prototype.resetTypeParameterCache = function () {
            this.functionTypeParameterCache = new TypeScript.BlockIntrinsics();
        };

        PullSymbolBinder.prototype.setUnit = function (fileName) {
            this.semanticInfo = this.semanticInfoChain.getUnit(fileName);
        };

        PullSymbolBinder.prototype.getParent = function (decl, returnInstanceType) {
            if (typeof returnInstanceType === "undefined") { returnInstanceType = false; }
            var parentDecl = decl.getParentDecl();

            if (parentDecl.getKind() == 1 /* Script */) {
                return null;
            }

            var parent = parentDecl.getSymbol();

            if (!parent && parentDecl && !parentDecl.isBound()) {
                this.bindDeclToPullSymbol(parentDecl);
            }

            parent = parentDecl.getSymbol();

            if (parent) {
                if (returnInstanceType && parent.isType() && parent.isContainer()) {
                    var instanceSymbol = (parent).getInstanceSymbol();

                    if (instanceSymbol) {
                        return instanceSymbol.getType();
                    }
                }

                return parent.getType();
            }

            return null;
        };

        PullSymbolBinder.prototype.findDeclsInContext = function (startingDecl, declKind, searchGlobally) {
            if (!searchGlobally) {
                var parentDecl = startingDecl.getParentDecl();
                return parentDecl.searchChildDecls(startingDecl.getName(), declKind);
            }

            var contextSymbolPath = getPathToDecl(startingDecl);

            if (contextSymbolPath.length) {
                var copyOfContextSymbolPath = [];

                for (var i = 0; i < contextSymbolPath.length; i++) {
                    if (contextSymbolPath[i].getKind() & 1 /* Script */) {
                        continue;
                    }
                    copyOfContextSymbolPath[copyOfContextSymbolPath.length] = contextSymbolPath[i].getName();
                }

                return this.semanticInfoChain.findDecls(copyOfContextSymbolPath, declKind);
            }

            return this.semanticInfoChain.findDecls([name], declKind);
        };

        PullSymbolBinder.prototype.symbolIsRedeclaration = function (sym) {
            var symID = sym.getSymbolID();
            return (symID >= this.startingSymbolForRebind) || ((sym.getRebindingID() === this.bindingPhase) && (symID !== this.startingSymbolForRebind));
        };

        PullSymbolBinder.prototype.bindModuleDeclarationToPullSymbol = function (moduleContainerDecl) {
            var modName = moduleContainerDecl.getName();

            var moduleContainerTypeSymbol = null;
            var moduleInstanceSymbol = null;
            var moduleInstanceTypeSymbol = null;

            var moduleInstanceDecl = moduleContainerDecl.getValueDecl();

            var moduleKind = moduleContainerDecl.getKind();

            var parent = this.getParent(moduleContainerDecl);
            var parentInstanceSymbol = this.getParent(moduleContainerDecl, true);
            var parentDecl = moduleContainerDecl.getParentDecl();
            var moduleAST = this.semanticInfo.getASTForDecl(moduleContainerDecl);

            var isExported = moduleContainerDecl.getFlags() & 1 /* Exported */;
            var isEnum = (moduleKind & 64 /* Enum */) != 0;
            var searchKind = isEnum ? 64 /* Enum */ : TypeScript.PullElementKind.SomeContainer;
            var isInitializedModule = (moduleContainerDecl.getFlags() & TypeScript.PullElementFlags.SomeInitializedModule) != 0;

            var createdNewSymbol = false;

            if (parent) {
                if (isExported) {
                    moduleContainerTypeSymbol = parent.findNestedType(modName, searchKind);
                } else {
                    moduleContainerTypeSymbol = parent.findContainedMember(modName);

                    if (moduleContainerTypeSymbol && !(moduleContainerTypeSymbol.getKind() & searchKind)) {
                        moduleContainerTypeSymbol = null;
                    }
                }
            } else if (!isExported || moduleContainerDecl.getKind() === 32 /* DynamicModule */) {
                moduleContainerTypeSymbol = findSymbolInContext(modName, searchKind, moduleContainerDecl);
            }

            if (moduleContainerTypeSymbol && moduleContainerTypeSymbol.getKind() !== moduleKind) {
                if (isInitializedModule) {
                    moduleContainerDecl.addDiagnostic(new TypeScript.SemanticDiagnostic(this.semanticInfo.getPath(), moduleAST.minChar, moduleAST.getLength(), 69 /* Duplicate_identifier__0_ */, [moduleContainerDecl.getDisplayName()]));
                }

                moduleContainerTypeSymbol = null;
            }

            if (moduleContainerTypeSymbol) {
                moduleInstanceSymbol = moduleContainerTypeSymbol.getInstanceSymbol();
            } else {
                moduleContainerTypeSymbol = new TypeScript.PullContainerTypeSymbol(modName, moduleKind);
                createdNewSymbol = true;

                if (!parent) {
                    this.semanticInfoChain.cacheGlobalSymbol(moduleContainerTypeSymbol, searchKind);
                }
            }

            if (!moduleInstanceSymbol && isInitializedModule) {
                var variableSymbol = null;
                if (!isEnum) {
                    if (parentInstanceSymbol) {
                        if (isExported) {
                            variableSymbol = parentInstanceSymbol.findMember(modName, false);

                            if (!variableSymbol) {
                                variableSymbol = parentInstanceSymbol.findContainedMember(modName);
                            }
                        } else {
                            variableSymbol = parentInstanceSymbol.findContainedMember(modName);

                            if (!variableSymbol) {
                                variableSymbol = parentInstanceSymbol.findMember(modName, false);
                            }
                        }

                        if (variableSymbol) {
                            var declarations = variableSymbol.getDeclarations();

                            if (declarations.length) {
                                var variableSymbolParent = declarations[0].getParentDecl();

                                if ((parentDecl !== variableSymbolParent) && (!this.reBindingAfterChange || (variableSymbolParent.getDeclID() >= this.startingDeclForRebind))) {
                                    variableSymbol = null;
                                }
                            }
                        }
                    } else if (!(moduleContainerDecl.getFlags() & 1 /* Exported */)) {
                        var siblingDecls = parentDecl.getChildDecls();
                        var augmentedDecl = null;

                        for (var i = 0; i < siblingDecls.length; i++) {
                            if (siblingDecls[i] == moduleContainerDecl) {
                                break;
                            }

                            if ((siblingDecls[i].getName() == modName) && (siblingDecls[i].getKind() & (8 /* Class */ | TypeScript.PullElementKind.SomeFunction))) {
                                augmentedDecl = siblingDecls[i];
                                break;
                            }
                        }

                        if (augmentedDecl) {
                            variableSymbol = augmentedDecl.getSymbol();

                            if (variableSymbol && variableSymbol.isType()) {
                                variableSymbol = (variableSymbol).getConstructorMethod();
                            }
                        }
                    }
                }

                if (variableSymbol) {
                    var prevKind = variableSymbol.getKind();
                    var acceptableRedeclaration = (prevKind == 16384 /* Function */) || (prevKind == 32768 /* ConstructorMethod */) || variableSymbol.hasFlag(TypeScript.PullElementFlags.ImplicitVariable);

                    if (acceptableRedeclaration) {
                        moduleInstanceTypeSymbol = variableSymbol.getType();
                    } else {
                        variableSymbol = null;
                    }
                }

                if (!moduleInstanceTypeSymbol) {
                    moduleInstanceTypeSymbol = new TypeScript.PullTypeSymbol(modName, 8388608 /* ObjectType */);
                }

                moduleInstanceTypeSymbol.addDeclaration(moduleContainerDecl);

                moduleInstanceTypeSymbol.setAssociatedContainerType(moduleContainerTypeSymbol);

                if (variableSymbol) {
                    moduleInstanceSymbol = variableSymbol;
                } else {
                    moduleInstanceSymbol = new TypeScript.PullSymbol(modName, 1024 /* Variable */);
                    moduleInstanceSymbol.setType(moduleInstanceTypeSymbol);
                }

                moduleContainerTypeSymbol.setInstanceSymbol(moduleInstanceSymbol);
            }

            moduleContainerTypeSymbol.addDeclaration(moduleContainerDecl);
            moduleContainerDecl.setSymbol(moduleContainerTypeSymbol);

            this.semanticInfo.setSymbolAndDiagnosticsForAST(moduleAST.name, TypeScript.SymbolAndDiagnostics.fromSymbol(moduleContainerTypeSymbol));
            this.semanticInfo.setSymbolAndDiagnosticsForAST(moduleAST, TypeScript.SymbolAndDiagnostics.fromSymbol(moduleContainerTypeSymbol));

            var moduleDeclarations = moduleContainerTypeSymbol.getDeclarations();
            if (isEnum && moduleDeclarations.length > 1 && moduleAST.members.members.length > 0) {
                var multipleEnums = TypeScript.ArrayUtilities.where(moduleDeclarations, function (d) {
                    return d.getKind() === 64 /* Enum */;
                }).length > 1;
                if (multipleEnums) {
                    var firstVariable = moduleAST.members.members[0];
                    var firstVariableDeclarator = firstVariable.declaration.declarators.members[0];
                    if (firstVariableDeclarator.isImplicitlyInitialized) {
                        moduleContainerDecl.addDiagnostic(new TypeScript.SemanticDiagnostic(this.semanticInfo.getPath(), firstVariableDeclarator.minChar, firstVariableDeclarator.getLength(), 264 /* Enums_with_multiple_declarations_must_provide_an_initializer_for_the_first_enum_element */, null));
                    }
                }
            }

            if (createdNewSymbol) {
                if (parent) {
                    var linkKind = moduleContainerDecl.getFlags() & 1 /* Exported */ ? 5 /* PublicMember */ : 6 /* PrivateMember */;

                    if (linkKind === 5 /* PublicMember */) {
                        parent.addMember(moduleContainerTypeSymbol, linkKind);
                    } else {
                        moduleContainerTypeSymbol.setContainer(parent);
                    }
                }
            } else if (this.reBindingAfterChange) {
                var decls = moduleContainerTypeSymbol.getDeclarations();
                var scriptName = moduleContainerDecl.getScriptName();

                for (var i = 0; i < decls.length; i++) {
                    if (decls[i].getScriptName() === scriptName && decls[i].getDeclID() < this.startingDeclForRebind) {
                        moduleContainerTypeSymbol.removeDeclaration(decls[i]);
                    }
                }

                moduleContainerTypeSymbol.invalidate();

                moduleInstanceSymbol = moduleContainerTypeSymbol.getInstanceSymbol();

                if (moduleInstanceSymbol) {
                    var moduleInstanceTypeSymbol = moduleInstanceSymbol.getType();
                    decls = moduleInstanceTypeSymbol.getDeclarations();

                    for (var i = 0; i < decls.length; i++) {
                        if (decls[i].getScriptName() === scriptName && decls[i].getDeclID() < this.startingDeclForRebind) {
                            moduleInstanceTypeSymbol.removeDeclaration(decls[i]);
                        }
                    }

                    moduleInstanceTypeSymbol.addDeclaration(moduleContainerDecl);
                    moduleInstanceTypeSymbol.invalidate();
                }
            }

            if (isEnum) {
                moduleInstanceTypeSymbol = moduleContainerTypeSymbol.getInstanceSymbol().getType();

                if (this.reBindingAfterChange) {
                    var existingIndexSigs = moduleInstanceTypeSymbol.getIndexSignatures();

                    for (var i = 0; i < existingIndexSigs.length; i++) {
                        moduleInstanceTypeSymbol.removeIndexSignature(existingIndexSigs[i]);
                    }
                }

                var enumIndexSignature = new TypeScript.PullSignatureSymbol(4194304 /* IndexSignature */);
                var enumIndexParameterSymbol = new TypeScript.PullSymbol("x", 2048 /* Parameter */);
                enumIndexParameterSymbol.setType(this.semanticInfoChain.numberTypeSymbol);
                enumIndexSignature.addParameter(enumIndexParameterSymbol);
                enumIndexSignature.setReturnType(this.semanticInfoChain.stringTypeSymbol);

                moduleInstanceTypeSymbol.addIndexSignature(enumIndexSignature);

                moduleInstanceTypeSymbol.recomputeIndexSignatures();
            }

            var valueDecl = moduleContainerDecl.getValueDecl();

            if (valueDecl) {
                valueDecl.ensureSymbolIsBound();
            }

            var otherDecls = this.findDeclsInContext(moduleContainerDecl, moduleContainerDecl.getKind(), true);

            if (otherDecls && otherDecls.length) {
                for (var i = 0; i < otherDecls.length; i++) {
                    otherDecls[i].ensureSymbolIsBound();
                }
            }
        };

        PullSymbolBinder.prototype.bindImportDeclaration = function (importDeclaration) {
            var declFlags = importDeclaration.getFlags();
            var declKind = importDeclaration.getKind();
            var importDeclAST = this.semanticInfo.getASTForDecl(importDeclaration);

            var isExported = false;
            var linkKind = 6 /* PrivateMember */;
            var importSymbol = null;
            var declName = importDeclaration.getName();
            var parentHadSymbol = false;
            var parent = this.getParent(importDeclaration);

            if (parent) {
                importSymbol = parent.findMember(declName, false);

                if (!importSymbol) {
                    importSymbol = parent.findContainedMember(declName);

                    if (importSymbol) {
                        var declarations = importSymbol.getDeclarations();

                        if (declarations.length) {
                            var importSymbolParent = declarations[0].getParentDecl();

                            if ((importSymbolParent !== importDeclaration.getParentDecl()) && (!this.reBindingAfterChange || (importSymbolParent.getDeclID() >= this.startingDeclForRebind))) {
                                importSymbol = null;
                            }
                        }
                    }
                }
            } else if (!(importDeclaration.getFlags() & 1 /* Exported */)) {
                importSymbol = findSymbolInContext(declName, TypeScript.PullElementKind.SomeContainer, importDeclaration);
            }

            if (importSymbol) {
                parentHadSymbol = true;
            }

            if (importSymbol && this.symbolIsRedeclaration(importSymbol)) {
                importDeclaration.addDiagnostic(new TypeScript.SemanticDiagnostic(this.semanticInfo.getPath(), importDeclAST.minChar, importDeclAST.getLength(), 69 /* Duplicate_identifier__0_ */, [importDeclaration.getDisplayName()]));
                importSymbol = null;
            }

            if (this.reBindingAfterChange && importSymbol) {
                var decls = importSymbol.getDeclarations();
                var scriptName = importDeclaration.getScriptName();

                for (var j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() === scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        importSymbol.removeDeclaration(decls[j]);
                    }
                }

                importSymbol.setUnresolved();
            }

            if (!importSymbol) {
                importSymbol = new TypeScript.PullTypeAliasSymbol(declName);

                if (!parent) {
                    this.semanticInfoChain.cacheGlobalSymbol(importSymbol, TypeScript.PullElementKind.SomeContainer);
                }
            }

            importSymbol.addDeclaration(importDeclaration);
            importDeclaration.setSymbol(importSymbol);

            this.semanticInfo.setSymbolAndDiagnosticsForAST(importDeclAST, TypeScript.SymbolAndDiagnostics.fromSymbol(importSymbol));

            if (parent && !parentHadSymbol) {
                if (declFlags & 1 /* Exported */) {
                    parent.addMember(importSymbol, 5 /* PublicMember */);
                } else {
                    importSymbol.setContainer(parent);
                }
            }

            importSymbol.setIsBound(this.bindingPhase);
        };

        PullSymbolBinder.prototype.cleanInterfaceSignatures = function (interfaceSymbol) {
            var callSigs = interfaceSymbol.getCallSignatures();
            var constructSigs = interfaceSymbol.getConstructSignatures();
            var indexSigs = interfaceSymbol.getIndexSignatures();

            for (var i = 0; i < callSigs.length; i++) {
                if (callSigs[i].getSymbolID() < this.startingSymbolForRebind) {
                    interfaceSymbol.removeCallSignature(callSigs[i], false);
                }
            }
            for (var i = 0; i < constructSigs.length; i++) {
                if (constructSigs[i].getSymbolID() < this.startingSymbolForRebind) {
                    interfaceSymbol.removeConstructSignature(constructSigs[i], false);
                }
            }
            for (var i = 0; i < indexSigs.length; i++) {
                if (indexSigs[i].getSymbolID() < this.startingSymbolForRebind) {
                    interfaceSymbol.removeIndexSignature(indexSigs[i], false);
                }
            }

            interfaceSymbol.recomputeCallSignatures();
            interfaceSymbol.recomputeConstructSignatures();
            interfaceSymbol.recomputeIndexSignatures();
        };

        PullSymbolBinder.prototype.cleanClassSignatures = function (classSymbol) {
            var callSigs = classSymbol.getCallSignatures();
            var constructSigs = classSymbol.getConstructSignatures();
            var indexSigs = classSymbol.getIndexSignatures();

            for (var i = 0; i < callSigs.length; i++) {
                classSymbol.removeCallSignature(callSigs[i], false);
            }
            for (var i = 0; i < constructSigs.length; i++) {
                classSymbol.removeConstructSignature(constructSigs[i], false);
            }
            for (var i = 0; i < indexSigs.length; i++) {
                classSymbol.removeIndexSignature(indexSigs[i], false);
            }

            classSymbol.recomputeCallSignatures();
            classSymbol.recomputeConstructSignatures();
            classSymbol.recomputeIndexSignatures();

            var constructorSymbol = classSymbol.getConstructorMethod();
            var constructorTypeSymbol = (constructorSymbol ? constructorSymbol.getType() : null);

            if (constructorTypeSymbol) {
                constructSigs = constructorTypeSymbol.getConstructSignatures();

                for (var i = 0; i < constructSigs.length; i++) {
                    constructorTypeSymbol.removeConstructSignature(constructSigs[i], false);
                }

                constructorTypeSymbol.recomputeConstructSignatures();
                constructorTypeSymbol.invalidate();
                constructorSymbol.invalidate();
            }

            classSymbol.invalidate();
        };

        PullSymbolBinder.prototype.bindClassDeclarationToPullSymbol = function (classDecl) {
            var className = classDecl.getName();
            var classSymbol = null;

            var constructorSymbol = null;
            var constructorTypeSymbol = null;

            var classAST = this.semanticInfo.getASTForDecl(classDecl);
            var parentHadSymbol = false;

            var parent = this.getParent(classDecl);
            var parentDecl = classDecl.getParentDecl();
            var cleanedPreviousDecls = false;
            var isExported = classDecl.getFlags() & 1 /* Exported */;
            var isGeneric = false;

            var acceptableSharedKind = 8 /* Class */;

            if (parent) {
                if (isExported) {
                    classSymbol = parent.findNestedType(className);

                    if (!classSymbol) {
                        classSymbol = parent.findMember(className, false);
                    }
                } else {
                    classSymbol = parent.findContainedMember(className);

                    if (classSymbol && (classSymbol.getKind() & acceptableSharedKind)) {
                        var declarations = classSymbol.getDeclarations();

                        if (declarations.length) {
                            var classSymbolParent = declarations[0].getParentDecl();

                            if ((classSymbolParent !== parentDecl) && (!this.reBindingAfterChange || (classSymbolParent.getDeclID() >= this.startingDeclForRebind))) {
                                classSymbol = null;
                            }
                        }
                    } else {
                        classSymbol = null;
                    }
                }
            } else {
                classSymbol = findSymbolInContext(className, acceptableSharedKind, classDecl);
            }

            if (classSymbol && (!(classSymbol.getKind() & acceptableSharedKind) || !this.reBindingAfterChange || this.symbolIsRedeclaration(classSymbol))) {
                classDecl.addDiagnostic(new TypeScript.SemanticDiagnostic(this.semanticInfo.getPath(), classAST.minChar, classAST.getLength(), 69 /* Duplicate_identifier__0_ */, [classDecl.getDisplayName()]));
                classSymbol = null;
            } else if (classSymbol) {
                parentHadSymbol = true;
            }

            var decls;

            if (this.reBindingAfterChange && classSymbol) {
                decls = classSymbol.getDeclarations();
                var scriptName = classDecl.getScriptName();

                for (var j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() === scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        classSymbol.removeDeclaration(decls[j]);

                        cleanedPreviousDecls = true;
                    }
                }

                constructorSymbol = classSymbol.getConstructorMethod();
                constructorTypeSymbol = constructorSymbol.getType();

                decls = constructorSymbol.getDeclarations();

                for (var j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() === scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        constructorSymbol.removeDeclaration(decls[j]);

                        cleanedPreviousDecls = true;
                    }
                }

                if (constructorSymbol.getIsSynthesized()) {
                    classSymbol.setConstructorMethod(null);
                }

                if (classSymbol.isGeneric()) {
                    isGeneric = true;

                    var specializations = classSymbol.getKnownSpecializations();
                    var specialization = null;

                    for (var i = 0; i < specializations.length; i++) {
                        specializations[i].setUnresolved();
                        specializations[i].invalidate();
                    }

                    classSymbol.cleanTypeParameters();
                    constructorTypeSymbol.cleanTypeParameters();
                }

                classSymbol.setUnresolved();
                constructorSymbol.setUnresolved();
                constructorTypeSymbol.setUnresolved();
            }

            if (!parentHadSymbol) {
                classSymbol = new TypeScript.PullClassTypeSymbol(className);

                if (!parent) {
                    this.semanticInfoChain.cacheGlobalSymbol(classSymbol, acceptableSharedKind);
                }
            }

            classSymbol.addDeclaration(classDecl);

            classDecl.setSymbol(classSymbol);

            this.semanticInfo.setSymbolAndDiagnosticsForAST(classAST.name, TypeScript.SymbolAndDiagnostics.fromSymbol(classSymbol));
            this.semanticInfo.setSymbolAndDiagnosticsForAST(classAST, TypeScript.SymbolAndDiagnostics.fromSymbol(classSymbol));

            if (parent && !parentHadSymbol) {
                var linkKind = classDecl.getFlags() & 1 /* Exported */ ? 5 /* PublicMember */ : 6 /* PrivateMember */;

                if (linkKind === 5 /* PublicMember */) {
                    parent.addMember(classSymbol, linkKind);
                } else {
                    classSymbol.setContainer(parent);
                }
            }

            if (parentHadSymbol && cleanedPreviousDecls) {
                this.cleanClassSignatures(classSymbol);

                if (isGeneric) {
                    specializations = classSymbol.getKnownSpecializations();

                    for (var i = 0; i < specializations.length; i++) {
                        this.cleanClassSignatures(specializations[i]);
                    }
                }
            }

            this.resetTypeParameterCache();

            this.resetTypeParameterCache();

            constructorSymbol = classSymbol.getConstructorMethod();
            constructorTypeSymbol = (constructorSymbol ? constructorSymbol.getType() : null);

            if (!constructorSymbol) {
                constructorSymbol = new TypeScript.PullSymbol(className, 32768 /* ConstructorMethod */);
                constructorTypeSymbol = new TypeScript.PullConstructorTypeSymbol();

                constructorSymbol.setIsSynthesized();

                constructorSymbol.setType(constructorTypeSymbol);
                constructorSymbol.addDeclaration(classDecl.getValueDecl());
                classSymbol.setConstructorMethod(constructorSymbol);

                constructorTypeSymbol.addDeclaration(classDecl);

                classSymbol.setHasDefaultConstructor();
            }

            constructorTypeSymbol.setAssociatedContainerType(classSymbol);

            var typeParameters = classDecl.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = classSymbol.findTypeParameter(typeParameters[i].getName());

                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].getName(), false);

                    classSymbol.addMember(typeParameter, 18 /* TypeParameter */);
                    constructorTypeSymbol.addTypeParameter(typeParameter, true);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();

                    if (this.symbolIsRedeclaration(typeParameter)) {
                        var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameterDecls[0]);
                        classDecl.addDiagnostic(new TypeScript.SemanticDiagnostic(this.semanticInfo.getPath(), typeParameterAST.minChar, typeParameterAST.getLength(), 69 /* Duplicate_identifier__0_ */, [typeParameter.getName()]));
                    }

                    for (var j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }

            var valueDecl = classDecl.getValueDecl();

            if (valueDecl) {
                valueDecl.ensureSymbolIsBound();
            }

            classSymbol.setIsBound(this.bindingPhase);
        };

        PullSymbolBinder.prototype.bindInterfaceDeclarationToPullSymbol = function (interfaceDecl) {
            var interfaceName = interfaceDecl.getName();
            var interfaceSymbol = findSymbolInContext(interfaceName, TypeScript.PullElementKind.SomeType, interfaceDecl);

            var interfaceAST = this.semanticInfo.getASTForDecl(interfaceDecl);
            var createdNewSymbol = false;
            var parent = this.getParent(interfaceDecl);

            var acceptableSharedKind = 16 /* Interface */;

            if (parent) {
                interfaceSymbol = parent.findNestedType(interfaceName);
            } else if (!(interfaceDecl.getFlags() & 1 /* Exported */)) {
                interfaceSymbol = findSymbolInContext(interfaceName, acceptableSharedKind, interfaceDecl);
            }

            if (interfaceSymbol && !(interfaceSymbol.getKind() & acceptableSharedKind)) {
                interfaceDecl.addDiagnostic(new TypeScript.SemanticDiagnostic(this.semanticInfo.getPath(), interfaceAST.minChar, interfaceAST.getLength(), 69 /* Duplicate_identifier__0_ */, [interfaceDecl.getDisplayName()]));
                interfaceSymbol = null;
            }

            if (!interfaceSymbol) {
                interfaceSymbol = new TypeScript.PullTypeSymbol(interfaceName, 16 /* Interface */);
                createdNewSymbol = true;

                if (!parent) {
                    this.semanticInfoChain.cacheGlobalSymbol(interfaceSymbol, acceptableSharedKind);
                }
            }

            interfaceSymbol.addDeclaration(interfaceDecl);
            interfaceDecl.setSymbol(interfaceSymbol);

            if (createdNewSymbol) {
                if (parent) {
                    var linkKind = interfaceDecl.getFlags() & 1 /* Exported */ ? 5 /* PublicMember */ : 6 /* PrivateMember */;

                    if (linkKind === 5 /* PublicMember */) {
                        parent.addMember(interfaceSymbol, linkKind);
                    } else {
                        interfaceSymbol.setContainer(parent);
                    }
                }
            } else if (this.reBindingAfterChange) {
                var decls = interfaceSymbol.getDeclarations();
                var scriptName = interfaceDecl.getScriptName();

                for (var i = 0; i < decls.length; i++) {
                    if (decls[i].getScriptName() === scriptName && decls[i].getDeclID() < this.startingDeclForRebind) {
                        interfaceSymbol.removeDeclaration(decls[i]);
                    }
                }

                if (interfaceSymbol.isGeneric()) {
                    var specializations = interfaceSymbol.getKnownSpecializations();
                    var specialization = null;

                    for (var i = 0; i < specializations.length; i++) {
                        specialization = specializations[i];

                        this.cleanInterfaceSignatures(specialization);
                        specialization.invalidate();
                    }

                    interfaceSymbol.cleanTypeParameters();
                }

                this.cleanInterfaceSignatures(interfaceSymbol);
                interfaceSymbol.invalidate();
            }

            this.resetTypeParameterCache();

            this.resetTypeParameterCache();

            var typeParameters = interfaceDecl.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = interfaceSymbol.findTypeParameter(typeParameters[i].getName());

                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].getName(), false);

                    interfaceSymbol.addMember(typeParameter, 18 /* TypeParameter */);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();

                    if (this.symbolIsRedeclaration(typeParameter)) {
                        for (var j = 0; j < typeParameterDecls.length; j++) {
                            var typeParameterDeclParent = typeParameterDecls[j].getParentDecl();

                            if (typeParameterDeclParent && typeParameterDeclParent === interfaceDecl) {
                                var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameterDecls[0]);
                                interfaceDecl.addDiagnostic(new TypeScript.SemanticDiagnostic(this.semanticInfo.getPath(), typeParameterAST.minChar, typeParameterAST.getLength(), 69 /* Duplicate_identifier__0_ */, [typeParameter.getName()]));

                                break;
                            }
                        }
                    }

                    for (var j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }

            var otherDecls = this.findDeclsInContext(interfaceDecl, interfaceDecl.getKind(), true);

            if (otherDecls && otherDecls.length) {
                for (var i = 0; i < otherDecls.length; i++) {
                    otherDecls[i].ensureSymbolIsBound();
                }
            }
        };

        PullSymbolBinder.prototype.bindObjectTypeDeclarationToPullSymbol = function (objectDecl) {
            var objectSymbolAST = this.semanticInfo.getASTForDecl(objectDecl);

            var objectSymbol = new TypeScript.PullTypeSymbol("", 8388608 /* ObjectType */);

            objectSymbol.addDeclaration(objectDecl);
            objectDecl.setSymbol(objectSymbol);

            this.semanticInfo.setSymbolAndDiagnosticsForAST(objectSymbolAST, TypeScript.SymbolAndDiagnostics.fromSymbol(objectSymbol));

            var childDecls = objectDecl.getChildDecls();

            for (var i = 0; i < childDecls.length; i++) {
                this.bindDeclToPullSymbol(childDecls[i]);
            }

            var typeParameters = objectDecl.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = objectSymbol.findTypeParameter(typeParameters[i].getName());

                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].getName(), false);

                    objectSymbol.addMember(typeParameter, 18 /* TypeParameter */);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();

                    if (this.symbolIsRedeclaration(typeParameter)) {
                        var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameterDecls[0]);
                        objectDecl.addDiagnostic(new TypeScript.SemanticDiagnostic(this.semanticInfo.getPath(), typeParameterAST.minChar, typeParameterAST.getLength(), 69 /* Duplicate_identifier__0_ */, [typeParameter.getName()]));
                    }

                    for (var j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }
        };

        PullSymbolBinder.prototype.bindConstructorTypeDeclarationToPullSymbol = function (constructorTypeDeclaration) {
            var declKind = constructorTypeDeclaration.getKind();
            var declFlags = constructorTypeDeclaration.getFlags();
            var constructorTypeAST = this.semanticInfo.getASTForDecl(constructorTypeDeclaration);

            var constructorTypeSymbol = new TypeScript.PullConstructorTypeSymbol();

            constructorTypeDeclaration.setSymbol(constructorTypeSymbol);
            constructorTypeSymbol.addDeclaration(constructorTypeDeclaration);
            this.semanticInfo.setSymbolAndDiagnosticsForAST(constructorTypeAST, TypeScript.SymbolAndDiagnostics.fromSymbol(constructorTypeSymbol));

            var signature = new TypeScript.PullDefinitionSignatureSymbol(2097152 /* ConstructSignature */);

            if ((constructorTypeAST).variableArgList) {
                signature.setHasVariableParamList();
            }

            signature.addDeclaration(constructorTypeDeclaration);
            constructorTypeDeclaration.setSignatureSymbol(signature);

            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(constructorTypeDeclaration), constructorTypeSymbol, signature);

            constructorTypeSymbol.addSignature(signature);

            var typeParameters = constructorTypeDeclaration.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = constructorTypeSymbol.findTypeParameter(typeParameters[i].getName());

                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].getName(), false);

                    constructorTypeSymbol.addTypeParameter(typeParameter);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();

                    if (this.symbolIsRedeclaration(typeParameter)) {
                        var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameterDecls[0]);
                        constructorTypeDeclaration.addDiagnostic(new TypeScript.SemanticDiagnostic(this.semanticInfo.getPath(), typeParameterAST.minChar, typeParameterAST.getLength(), 69 /* Duplicate_identifier__0_ */, [typeParameter.getName()]));
                    }

                    for (var j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }
        };

        PullSymbolBinder.prototype.bindVariableDeclarationToPullSymbol = function (variableDeclaration) {
            var declFlags = variableDeclaration.getFlags();
            var declKind = variableDeclaration.getKind();
            var varDeclAST = this.semanticInfo.getASTForDecl(variableDeclaration);

            var isExported = (declFlags & 1 /* Exported */) !== 0;

            var linkKind = 6 /* PrivateMember */;

            var variableSymbol = null;

            var declName = variableDeclaration.getName();

            var parentHadSymbol = false;

            var parent = this.getParent(variableDeclaration, true);

            var parentDecl = variableDeclaration.getParentDecl();

            var isImplicit = (declFlags & TypeScript.PullElementFlags.ImplicitVariable) !== 0;
            var isModuleValue = (declFlags & (32768 /* InitializedModule */ | 65536 /* InitializedDynamicModule */ | 131072 /* InitializedEnum */)) != 0;
            var isEnumValue = (declFlags & 131072 /* InitializedEnum */) != 0;
            var isClassConstructorVariable = (declFlags & 16384 /* ClassConstructorVariable */) != 0;

            if (parentDecl && !isImplicit) {
                parentDecl.addVariableDeclToGroup(variableDeclaration);
            }

            if (parent) {
                if (isExported) {
                    variableSymbol = parent.findMember(declName, false);
                } else {
                    variableSymbol = parent.findContainedMember(declName);
                }

                if (variableSymbol) {
                    var declarations = variableSymbol.getDeclarations();

                    if (declarations.length) {
                        var variableSymbolParent = declarations[0].getParentDecl();

                        if ((parentDecl !== variableSymbolParent) && (!this.reBindingAfterChange || (variableSymbolParent.getDeclID() >= this.startingDeclForRebind))) {
                            variableSymbol = null;
                        }
                    }
                }
            } else if (!(variableDeclaration.getFlags() & 1 /* Exported */)) {
                variableSymbol = findSymbolInContext(declName, TypeScript.PullElementKind.SomeValue, variableDeclaration);
            }

            if (variableSymbol && !variableSymbol.isType()) {
                parentHadSymbol = true;
            }

            var span;
            var decl;
            var decls;
            var ast;
            var members;

            if (variableSymbol && this.symbolIsRedeclaration(variableSymbol)) {
                var prevKind = variableSymbol.getKind();
                var prevIsAmbient = variableSymbol.hasFlag(8 /* Ambient */);
                var prevIsEnum = variableSymbol.hasFlag(131072 /* InitializedEnum */);
                var prevIsClass = prevKind == 32768 /* ConstructorMethod */;
                var prevIsContainer = variableSymbol.hasFlag(32768 /* InitializedModule */ | 65536 /* InitializedDynamicModule */);
                var onlyOneIsEnum = (isEnumValue || prevIsEnum) && !(isEnumValue && prevIsEnum);
                var isAmbient = (variableDeclaration.getFlags() & 8 /* Ambient */) != 0;
                var isClass = variableDeclaration.getKind() == 32768 /* ConstructorMethod */;

                var acceptableRedeclaration = isImplicit && ((!isEnumValue && !isClassConstructorVariable && prevKind == 16384 /* Function */) || (!isModuleValue && prevIsContainer && isAmbient) || (!isModuleValue && prevIsClass) || variableSymbol.hasFlag(TypeScript.PullElementFlags.ImplicitVariable));

                if (acceptableRedeclaration && prevIsClass && !prevIsAmbient) {
                    if (variableSymbol.getDeclarations()[0].getScriptName() != variableDeclaration.getScriptName()) {
                        acceptableRedeclaration = false;
                    }
                }

                if ((!isModuleValue && !isClass && !isAmbient) || !acceptableRedeclaration || onlyOneIsEnum) {
                    span = variableDeclaration.getSpan();
                    if (!parent || variableSymbol.getIsSynthesized()) {
                        var errorDecl = isImplicit ? variableSymbol.getDeclarations()[0] : variableDeclaration;
                        errorDecl.addDiagnostic(new TypeScript.SemanticDiagnostic(this.semanticInfo.getPath(), span.start(), span.length(), 69 /* Duplicate_identifier__0_ */, [variableDeclaration.getDisplayName()]));
                    }

                    variableSymbol = null;
                    parentHadSymbol = false;
                }
            } else if (variableSymbol && (variableSymbol.getKind() !== 1024 /* Variable */) && !isImplicit) {
                span = variableDeclaration.getSpan();

                variableDeclaration.addDiagnostic(new TypeScript.SemanticDiagnostic(this.semanticInfo.getPath(), span.start(), span.length(), 69 /* Duplicate_identifier__0_ */, [variableDeclaration.getDisplayName()]));
                variableSymbol = null;
                parentHadSymbol = false;
            }

            if (this.reBindingAfterChange && variableSymbol && !variableSymbol.isType()) {
                decls = variableSymbol.getDeclarations();
                var scriptName = variableDeclaration.getScriptName();

                for (var j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() === scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        variableSymbol.removeDeclaration(decls[j]);
                    }
                }

                variableSymbol.invalidate();
            }

            var replaceProperty = false;
            var previousProperty = null;

            if ((declFlags & TypeScript.PullElementFlags.ImplicitVariable) === 0) {
                if (!variableSymbol) {
                    variableSymbol = new TypeScript.PullSymbol(declName, declKind);
                }

                variableSymbol.addDeclaration(variableDeclaration);
                variableDeclaration.setSymbol(variableSymbol);

                this.semanticInfo.setSymbolAndDiagnosticsForAST(varDeclAST.id, TypeScript.SymbolAndDiagnostics.fromSymbol(variableSymbol));
                this.semanticInfo.setSymbolAndDiagnosticsForAST(varDeclAST, TypeScript.SymbolAndDiagnostics.fromSymbol(variableSymbol));
            } else if (!parentHadSymbol) {
                if (isClassConstructorVariable) {
                    var classTypeSymbol = variableSymbol;

                    if (parent) {
                        members = parent.getMembers();

                        for (var i = 0; i < members.length; i++) {
                            if ((members[i].getName() === declName) && (members[i].getKind() === 8 /* Class */)) {
                                classTypeSymbol = members[i];
                                break;
                            }
                        }
                    }

                    if (!classTypeSymbol) {
                        var parentDecl = variableDeclaration.getParentDecl();

                        if (parentDecl) {
                            var childDecls = parentDecl.searchChildDecls(declName, TypeScript.PullElementKind.SomeType);

                            if (childDecls.length) {
                                for (var i = 0; i < childDecls.length; i++) {
                                    if (childDecls[i].getValueDecl() === variableDeclaration) {
                                        classTypeSymbol = childDecls[i].getSymbol();
                                    }
                                }
                            }
                        }

                        if (!classTypeSymbol) {
                            classTypeSymbol = findSymbolInContext(declName, TypeScript.PullElementKind.SomeType, variableDeclaration);
                        }
                    }

                    if (classTypeSymbol && (classTypeSymbol.getKind() !== 8 /* Class */)) {
                        classTypeSymbol = null;
                    }

                    if (classTypeSymbol && classTypeSymbol.isClass()) {
                        replaceProperty = variableSymbol && variableSymbol.getIsSynthesized();

                        if (replaceProperty) {
                            previousProperty = variableSymbol;
                        }

                        variableSymbol = classTypeSymbol.getConstructorMethod();
                        variableDeclaration.setSymbol(variableSymbol);

                        decls = classTypeSymbol.getDeclarations();

                        if (decls.length) {
                            decl = decls[decls.length - 1];
                            ast = this.semanticInfo.getASTForDecl(decl);

                            if (ast) {
                                this.semanticInfo.setASTForDecl(variableDeclaration, ast);
                            }
                        }
                    } else {
                        if (!variableSymbol) {
                            variableSymbol = new TypeScript.PullSymbol(declName, declKind);
                        }

                        variableSymbol.addDeclaration(variableDeclaration);
                        variableDeclaration.setSymbol(variableSymbol);

                        variableSymbol.setType(this.semanticInfoChain.anyTypeSymbol);
                    }
                } else if (declFlags & TypeScript.PullElementFlags.SomeInitializedModule) {
                    var moduleContainerTypeSymbol = null;
                    var moduleParent = this.getParent(variableDeclaration);

                    if (moduleParent) {
                        members = moduleParent.getMembers();

                        for (var i = 0; i < members.length; i++) {
                            if ((members[i].getName() === declName) && (members[i].isContainer())) {
                                moduleContainerTypeSymbol = members[i];
                                break;
                            }
                        }
                    }

                    if (!moduleContainerTypeSymbol) {
                        var parentDecl = variableDeclaration.getParentDecl();

                        if (parentDecl) {
                            var searchKind = (declFlags & (32768 /* InitializedModule */ | 65536 /* InitializedDynamicModule */)) ? TypeScript.PullElementKind.SomeContainer : 64 /* Enum */;
                            var childDecls = parentDecl.searchChildDecls(declName, searchKind);

                            if (childDecls.length) {
                                for (var i = 0; i < childDecls.length; i++) {
                                    if (childDecls[i].getValueDecl() === variableDeclaration) {
                                        moduleContainerTypeSymbol = childDecls[i].getSymbol();
                                    }
                                }
                            }
                        }
                        if (!moduleContainerTypeSymbol) {
                            moduleContainerTypeSymbol = findSymbolInContext(declName, TypeScript.PullElementKind.SomeContainer, variableDeclaration);

                            if (!moduleContainerTypeSymbol) {
                                moduleContainerTypeSymbol = findSymbolInContext(declName, 64 /* Enum */, variableDeclaration);
                            }
                        }
                    }

                    if (moduleContainerTypeSymbol && (!moduleContainerTypeSymbol.isContainer())) {
                        moduleContainerTypeSymbol = null;
                    }

                    if (moduleContainerTypeSymbol) {
                        variableSymbol = moduleContainerTypeSymbol.getInstanceSymbol();

                        variableSymbol.addDeclaration(variableDeclaration);
                        variableDeclaration.setSymbol(variableSymbol);

                        decls = moduleContainerTypeSymbol.getDeclarations();

                        if (decls.length) {
                            decl = decls[decls.length - 1];
                            ast = this.semanticInfo.getASTForDecl(decl);

                            if (ast) {
                                this.semanticInfo.setASTForDecl(variableDeclaration, ast);
                            }
                        }
                    } else {
                        TypeScript.Debug.assert(false, "Attempted to bind invalid implicit variable symbol");
                    }
                }
            } else {
                variableSymbol.addDeclaration(variableDeclaration);
                variableDeclaration.setSymbol(variableSymbol);
            }

            if (parent && !parentHadSymbol) {
                if (declFlags & 1 /* Exported */) {
                    parent.addMember(variableSymbol, 5 /* PublicMember */);
                } else {
                    variableSymbol.setContainer(parent);
                }
            } else if (replaceProperty) {
                parent.removeMember(previousProperty);
                parent.addMember(variableSymbol, linkKind);
            }

            variableSymbol.setIsBound(this.bindingPhase);
        };

        PullSymbolBinder.prototype.bindPropertyDeclarationToPullSymbol = function (propertyDeclaration) {
            var declFlags = propertyDeclaration.getFlags();
            var declKind = propertyDeclaration.getKind();
            var propDeclAST = this.semanticInfo.getASTForDecl(propertyDeclaration);

            var isStatic = false;
            var isOptional = false;

            var linkKind = 5 /* PublicMember */;

            var propertySymbol = null;

            if (TypeScript.hasFlag(declFlags, 16 /* Static */)) {
                isStatic = true;
            }

            if (TypeScript.hasFlag(declFlags, 2 /* Private */)) {
                linkKind = 6 /* PrivateMember */;
            }

            if (TypeScript.hasFlag(declFlags, 128 /* Optional */)) {
                isOptional = true;
            }

            var declName = propertyDeclaration.getName();

            var parentHadSymbol = false;

            var parent = this.getParent(propertyDeclaration, true);

            if (parent.isClass() && isStatic) {
                parent = (parent).getConstructorMethod().getType();
            }

            propertySymbol = parent.findMember(declName, false);

            if (propertySymbol && (!this.reBindingAfterChange || this.symbolIsRedeclaration(propertySymbol))) {
                var span = propertyDeclaration.getSpan();

                propertyDeclaration.addDiagnostic(new TypeScript.SemanticDiagnostic(this.semanticInfo.getPath(), span.start(), span.length(), 69 /* Duplicate_identifier__0_ */, [propertyDeclaration.getDisplayName()]));

                propertySymbol = null;
            }

            if (propertySymbol) {
                parentHadSymbol = true;
            }

            if (this.reBindingAfterChange && propertySymbol) {
                var decls = propertySymbol.getDeclarations();
                var scriptName = propertyDeclaration.getScriptName();

                for (var j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() === scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        propertySymbol.removeDeclaration(decls[j]);
                    }
                }

                propertySymbol.setUnresolved();
            }

            var classTypeSymbol;

            if (!parentHadSymbol) {
                propertySymbol = new TypeScript.PullSymbol(declName, declKind);
            }

            propertySymbol.addDeclaration(propertyDeclaration);
            propertyDeclaration.setSymbol(propertySymbol);

            this.semanticInfo.setSymbolAndDiagnosticsForAST(propDeclAST.id, TypeScript.SymbolAndDiagnostics.fromSymbol(propertySymbol));
            this.semanticInfo.setSymbolAndDiagnosticsForAST(propDeclAST, TypeScript.SymbolAndDiagnostics.fromSymbol(propertySymbol));

            if (isOptional) {
                propertySymbol.setIsOptional();
            }

            if (parent && !parentHadSymbol) {
                if (parent.isClass()) {
                    classTypeSymbol = parent;

                    classTypeSymbol.addMember(propertySymbol, linkKind);
                } else {
                    parent.addMember(propertySymbol, linkKind);
                }
            }

            propertySymbol.setIsBound(this.bindingPhase);
        };

        PullSymbolBinder.prototype.bindParameterSymbols = function (funcDecl, funcType, signatureSymbol) {
            var parameters = [];
            var decl = null;
            var argDecl = null;
            var parameterSymbol = null;
            var isProperty = false;
            var params = new TypeScript.BlockIntrinsics();

            if (funcDecl.arguments) {
                for (var i = 0; i < funcDecl.arguments.members.length; i++) {
                    argDecl = funcDecl.arguments.members[i];
                    decl = this.semanticInfo.getDeclForAST(argDecl);
                    isProperty = TypeScript.hasFlag(argDecl.getVarFlags(), 256 /* Property */);
                    parameterSymbol = new TypeScript.PullSymbol(argDecl.id.text, 2048 /* Parameter */);

                    if (funcDecl.variableArgList && i === funcDecl.arguments.members.length - 1) {
                        parameterSymbol.setIsVarArg();
                    }

                    if (decl.getFlags() & 128 /* Optional */) {
                        parameterSymbol.setIsOptional();
                    }

                    if (params[argDecl.id.text]) {
                        decl.addDiagnostic(new TypeScript.SemanticDiagnostic(this.semanticInfo.getPath(), argDecl.minChar, argDecl.getLength(), 69 /* Duplicate_identifier__0_ */, [argDecl.id.actualText]));
                    } else {
                        params[argDecl.id.text] = true;
                    }
                    if (decl) {
                        if (isProperty) {
                            decl.ensureSymbolIsBound();
                            var valDecl = decl.getValueDecl();

                            if (valDecl) {
                                valDecl.setSymbol(parameterSymbol);
                                parameterSymbol.addDeclaration(valDecl);
                            }
                        } else {
                            parameterSymbol.addDeclaration(decl);
                            decl.setSymbol(parameterSymbol);
                        }
                    }

                    signatureSymbol.addParameter(parameterSymbol, parameterSymbol.getIsOptional());

                    if (signatureSymbol.isDefinition()) {
                        parameterSymbol.setContainer(funcType);
                    }
                }
            }
        };

        PullSymbolBinder.prototype.bindFunctionDeclarationToPullSymbol = function (functionDeclaration) {
            var declKind = functionDeclaration.getKind();
            var declFlags = functionDeclaration.getFlags();
            var funcDeclAST = this.semanticInfo.getASTForDecl(functionDeclaration);

            var isExported = (declFlags & 1 /* Exported */) !== 0;

            var funcName = functionDeclaration.getName();

            var isSignature = (declFlags & 2048 /* Signature */) !== 0;

            var parent = this.getParent(functionDeclaration, true);
            var parentDecl = functionDeclaration.getParentDecl();
            var parentHadSymbol = false;
            var cleanedPreviousDecls = false;

            var functionSymbol = null;
            var functionTypeSymbol = null;

            if (parent) {
                functionSymbol = parent.findMember(funcName, false);

                if (!functionSymbol) {
                    functionSymbol = parent.findContainedMember(funcName);

                    if (functionSymbol) {
                        var declarations = functionSymbol.getDeclarations();

                        if (declarations.length) {
                            var funcSymbolParent = declarations[0].getParentDecl();

                            if ((parentDecl !== funcSymbolParent) && (!this.reBindingAfterChange || (funcSymbolParent.getDeclID() >= this.startingDeclForRebind))) {
                                functionSymbol = null;
                            }
                        }
                    }
                }
            } else if (!(functionDeclaration.getFlags() & 1 /* Exported */)) {
                functionSymbol = findSymbolInContext(funcName, TypeScript.PullElementKind.SomeValue, functionDeclaration);
            }

            if (functionSymbol && (functionSymbol.getKind() !== 16384 /* Function */ || (this.symbolIsRedeclaration(functionSymbol) && !isSignature && !functionSymbol.allDeclsHaveFlag(2048 /* Signature */)))) {
                functionDeclaration.addDiagnostic(new TypeScript.SemanticDiagnostic(this.semanticInfo.getPath(), funcDeclAST.minChar, funcDeclAST.getLength(), 69 /* Duplicate_identifier__0_ */, [functionDeclaration.getDisplayName()]));
                functionSymbol = null;
            }

            if (functionSymbol) {
                functionTypeSymbol = functionSymbol.getType();
                parentHadSymbol = true;
            }

            if (this.reBindingAfterChange && functionSymbol) {
                var decls = functionSymbol.getDeclarations();
                var scriptName = functionDeclaration.getScriptName();
                var isGeneric = functionTypeSymbol.isGeneric();

                for (var j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() === scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        functionSymbol.removeDeclaration(decls[j]);

                        cleanedPreviousDecls = true;
                    }
                }

                decls = functionTypeSymbol.getDeclarations();

                for (var j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() === scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        functionTypeSymbol.removeDeclaration(decls[j]);

                        cleanedPreviousDecls = true;
                    }
                }

                if (isGeneric) {
                    var specializations = functionTypeSymbol.getKnownSpecializations();

                    for (var i = 0; i < specializations.length; i++) {
                        specializations[i].invalidate();
                    }
                }

                functionSymbol.invalidate();
                functionTypeSymbol.invalidate();
            }

            if (!functionSymbol) {
                functionSymbol = new TypeScript.PullSymbol(funcName, 16384 /* Function */);
            }

            if (!functionTypeSymbol) {
                functionTypeSymbol = new TypeScript.PullFunctionTypeSymbol();
                functionSymbol.setType(functionTypeSymbol);
            }

            functionDeclaration.setSymbol(functionSymbol);
            functionSymbol.addDeclaration(functionDeclaration);
            functionTypeSymbol.addDeclaration(functionDeclaration);

            this.semanticInfo.setSymbolAndDiagnosticsForAST(funcDeclAST.name, TypeScript.SymbolAndDiagnostics.fromSymbol(functionSymbol));
            this.semanticInfo.setSymbolAndDiagnosticsForAST(funcDeclAST, TypeScript.SymbolAndDiagnostics.fromSymbol(functionSymbol));

            if (parent && !parentHadSymbol) {
                if (isExported) {
                    parent.addMember(functionSymbol, 5 /* PublicMember */);
                } else {
                    functionSymbol.setContainer(parent);
                }
            }

            if (parentHadSymbol && cleanedPreviousDecls) {
                var callSigs = functionTypeSymbol.getCallSignatures();

                for (var i = 0; i < callSigs.length; i++) {
                    functionTypeSymbol.removeCallSignature(callSigs[i], false);
                }

                functionSymbol.invalidate();
                functionTypeSymbol.invalidate();
                functionTypeSymbol.recomputeCallSignatures();

                if (isGeneric) {
                    var specializations = functionTypeSymbol.getKnownSpecializations();

                    for (var j = 0; j < specializations.length; j++) {
                        callSigs = specializations[j].getCallSignatures();

                        for (var i = 0; i < callSigs.length; i++) {
                            callSigs[i].invalidate();
                        }
                    }
                }
            }

            var signature = isSignature ? new TypeScript.PullSignatureSymbol(1048576 /* CallSignature */) : new TypeScript.PullDefinitionSignatureSymbol(1048576 /* CallSignature */);

            signature.addDeclaration(functionDeclaration);
            functionDeclaration.setSignatureSymbol(signature);

            if (funcDeclAST.variableArgList) {
                signature.setHasVariableParamList();
            }

            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(functionDeclaration), functionTypeSymbol, signature);

            var typeParameters = functionDeclaration.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = signature.findTypeParameter(typeParameters[i].getName());

                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].getName(), true);

                    signature.addTypeParameter(typeParameter);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();

                    if (this.symbolIsRedeclaration(typeParameter)) {
                        var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameterDecls[0]);
                        functionDeclaration.addDiagnostic(new TypeScript.SemanticDiagnostic(this.semanticInfo.getPath(), typeParameterAST.minChar, typeParameterAST.getLength(), 69 /* Duplicate_identifier__0_ */, [typeParameter.getName()]));
                    }

                    for (var j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }

            functionTypeSymbol.addCallSignature(signature);

            if (!isSignature) {
            }

            functionSymbol.setIsBound(this.bindingPhase);

            var otherDecls = this.findDeclsInContext(functionDeclaration, functionDeclaration.getKind(), false);

            if (otherDecls && otherDecls.length) {
                for (var i = 0; i < otherDecls.length; i++) {
                    otherDecls[i].ensureSymbolIsBound();
                }
            }
        };

        PullSymbolBinder.prototype.bindFunctionExpressionToPullSymbol = function (functionExpressionDeclaration) {
            var declKind = functionExpressionDeclaration.getKind();
            var declFlags = functionExpressionDeclaration.getFlags();
            var funcExpAST = this.semanticInfo.getASTForDecl(functionExpressionDeclaration);

            var functionName = declKind == 131072 /* FunctionExpression */ ? (functionExpressionDeclaration).getFunctionExpressionName() : functionExpressionDeclaration.getName();
            var functionSymbol = new TypeScript.PullSymbol(functionName, 16384 /* Function */);
            var functionTypeSymbol = new TypeScript.PullFunctionTypeSymbol();

            functionSymbol.setType(functionTypeSymbol);

            functionExpressionDeclaration.setSymbol(functionSymbol);
            functionSymbol.addDeclaration(functionExpressionDeclaration);
            functionTypeSymbol.addDeclaration(functionExpressionDeclaration);

            if (funcExpAST.name) {
                this.semanticInfo.setSymbolAndDiagnosticsForAST(funcExpAST.name, TypeScript.SymbolAndDiagnostics.fromSymbol(functionSymbol));
            }
            this.semanticInfo.setSymbolAndDiagnosticsForAST(funcExpAST, TypeScript.SymbolAndDiagnostics.fromSymbol(functionSymbol));

            var signature = new TypeScript.PullDefinitionSignatureSymbol(1048576 /* CallSignature */);

            if (funcExpAST.variableArgList) {
                signature.setHasVariableParamList();
            }

            var typeParameters = functionExpressionDeclaration.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = signature.findTypeParameter(typeParameters[i].getName());

                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].getName(), true);

                    signature.addTypeParameter(typeParameter);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();

                    if (this.symbolIsRedeclaration(typeParameter)) {
                        var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameterDecls[0]);
                        functionExpressionDeclaration.addDiagnostic(new TypeScript.SemanticDiagnostic(this.semanticInfo.getPath(), typeParameterAST.minChar, typeParameterAST.getLength(), 69 /* Duplicate_identifier__0_ */, [typeParameter.getName()]));
                    }

                    typeParameterDecls = typeParameter.getDeclarations();

                    for (var j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }

            signature.addDeclaration(functionExpressionDeclaration);
            functionExpressionDeclaration.setSignatureSymbol(signature);

            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(functionExpressionDeclaration), functionTypeSymbol, signature);

            functionTypeSymbol.addSignature(signature);
        };

        PullSymbolBinder.prototype.bindFunctionTypeDeclarationToPullSymbol = function (functionTypeDeclaration) {
            var declKind = functionTypeDeclaration.getKind();
            var declFlags = functionTypeDeclaration.getFlags();
            var funcTypeAST = this.semanticInfo.getASTForDecl(functionTypeDeclaration);

            var functionTypeSymbol = new TypeScript.PullFunctionTypeSymbol();

            functionTypeDeclaration.setSymbol(functionTypeSymbol);
            functionTypeSymbol.addDeclaration(functionTypeDeclaration);
            this.semanticInfo.setSymbolAndDiagnosticsForAST(funcTypeAST, TypeScript.SymbolAndDiagnostics.fromSymbol(functionTypeSymbol));

            var isSignature = (declFlags & 2048 /* Signature */) !== 0;
            var signature = isSignature ? new TypeScript.PullSignatureSymbol(1048576 /* CallSignature */) : new TypeScript.PullDefinitionSignatureSymbol(1048576 /* CallSignature */);

            if (funcTypeAST.variableArgList) {
                signature.setHasVariableParamList();
            }

            var typeParameters = functionTypeDeclaration.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = signature.findTypeParameter(typeParameters[i].getName());

                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].getName(), true);

                    signature.addTypeParameter(typeParameter);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();

                    if (this.symbolIsRedeclaration(typeParameter)) {
                        var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameterDecls[0]);
                        functionTypeDeclaration.addDiagnostic(new TypeScript.SemanticDiagnostic(this.semanticInfo.getPath(), typeParameterAST.minChar, typeParameterAST.getLength(), 69 /* Duplicate_identifier__0_ */, [typeParameter.getName()]));
                    }

                    typeParameterDecls = typeParameter.getDeclarations();

                    for (var j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }

            signature.addDeclaration(functionTypeDeclaration);
            functionTypeDeclaration.setSignatureSymbol(signature);

            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(functionTypeDeclaration), functionTypeSymbol, signature);

            functionTypeSymbol.addSignature(signature);
        };

        PullSymbolBinder.prototype.bindMethodDeclarationToPullSymbol = function (methodDeclaration) {
            var declKind = methodDeclaration.getKind();
            var declFlags = methodDeclaration.getFlags();
            var methodAST = this.semanticInfo.getASTForDecl(methodDeclaration);

            var isPrivate = (declFlags & 2 /* Private */) !== 0;
            var isStatic = (declFlags & 16 /* Static */) !== 0;
            var isOptional = (declFlags & 128 /* Optional */) !== 0;

            var methodName = methodDeclaration.getName();

            var isSignature = (declFlags & 2048 /* Signature */) !== 0;

            var parent = this.getParent(methodDeclaration, true);
            var parentHadSymbol = false;

            var cleanedPreviousDecls = false;

            var methodSymbol = null;
            var methodTypeSymbol = null;

            var linkKind = isPrivate ? 6 /* PrivateMember */ : 5 /* PublicMember */;

            if (parent.isClass() && isStatic) {
                parent = (parent).getConstructorMethod().getType();
            }

            methodSymbol = parent.findMember(methodName, false);

            if (methodSymbol && (methodSymbol.getKind() !== 65536 /* Method */ || (this.symbolIsRedeclaration(methodSymbol) && !isSignature && !methodSymbol.allDeclsHaveFlag(2048 /* Signature */)))) {
                methodDeclaration.addDiagnostic(new TypeScript.SemanticDiagnostic(this.semanticInfo.getPath(), methodAST.minChar, methodAST.getLength(), 69 /* Duplicate_identifier__0_ */, [methodDeclaration.getDisplayName()]));
                methodSymbol = null;
            }

            if (methodSymbol) {
                methodTypeSymbol = methodSymbol.getType();
                parentHadSymbol = true;
            }

            if (this.reBindingAfterChange && methodSymbol) {
                var decls = methodSymbol.getDeclarations();
                var scriptName = methodDeclaration.getScriptName();
                var isGeneric = methodTypeSymbol.isGeneric();

                for (var j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() === scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        methodSymbol.removeDeclaration(decls[j]);

                        cleanedPreviousDecls = true;
                    }
                }

                decls = methodTypeSymbol.getDeclarations();
                for (var j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() === scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        methodTypeSymbol.removeDeclaration(decls[j]);

                        cleanedPreviousDecls = true;
                    }
                }

                if (isGeneric) {
                    var specializations = methodTypeSymbol.getKnownSpecializations();

                    for (var i = 0; i < specializations.length; i++) {
                        specializations[i].invalidate();
                    }
                }

                methodSymbol.invalidate();
                methodTypeSymbol.invalidate();
            }

            if (!methodSymbol) {
                methodSymbol = new TypeScript.PullSymbol(methodName, 65536 /* Method */);
            }

            if (!methodTypeSymbol) {
                methodTypeSymbol = new TypeScript.PullFunctionTypeSymbol();
                methodSymbol.setType(methodTypeSymbol);
            }

            methodDeclaration.setSymbol(methodSymbol);
            methodSymbol.addDeclaration(methodDeclaration);
            methodTypeSymbol.addDeclaration(methodDeclaration);
            this.semanticInfo.setSymbolAndDiagnosticsForAST(methodAST.name, TypeScript.SymbolAndDiagnostics.fromSymbol(methodSymbol));
            this.semanticInfo.setSymbolAndDiagnosticsForAST(methodAST, TypeScript.SymbolAndDiagnostics.fromSymbol(methodSymbol));

            if (isOptional) {
                methodSymbol.setIsOptional();
            }

            if (!parentHadSymbol) {
                parent.addMember(methodSymbol, linkKind);
            }

            if (parentHadSymbol && cleanedPreviousDecls) {
                var callSigs = methodTypeSymbol.getCallSignatures();
                var constructSigs = methodTypeSymbol.getConstructSignatures();
                var indexSigs = methodTypeSymbol.getIndexSignatures();

                for (var i = 0; i < callSigs.length; i++) {
                    methodTypeSymbol.removeCallSignature(callSigs[i], false);
                }
                for (var i = 0; i < constructSigs.length; i++) {
                    methodTypeSymbol.removeConstructSignature(constructSigs[i], false);
                }
                for (var i = 0; i < indexSigs.length; i++) {
                    methodTypeSymbol.removeIndexSignature(indexSigs[i], false);
                }

                methodSymbol.invalidate();
                methodTypeSymbol.invalidate();
                methodTypeSymbol.recomputeCallSignatures();
                methodTypeSymbol.recomputeConstructSignatures();
                methodTypeSymbol.recomputeIndexSignatures();

                if (isGeneric) {
                    var specializations = methodTypeSymbol.getKnownSpecializations();

                    for (var j = 0; j < specializations.length; j++) {
                        callSigs = specializations[j].getCallSignatures();

                        for (var i = 0; i < callSigs.length; i++) {
                            callSigs[i].invalidate();
                        }
                    }
                }
            }

            var sigKind = 1048576 /* CallSignature */;

            var signature = isSignature ? new TypeScript.PullSignatureSymbol(sigKind) : new TypeScript.PullDefinitionSignatureSymbol(sigKind);

            if (methodAST.variableArgList) {
                signature.setHasVariableParamList();
            }

            var typeParameters = methodDeclaration.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;
            var typeParameterName;
            var typeParameterAST;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameterName = typeParameters[i].getName();
                typeParameterAST = this.semanticInfo.getASTForDecl(typeParameters[i]);

                typeParameter = signature.findTypeParameter(typeParameterName);

                if (!typeParameter) {
                    if (!typeParameterAST.constraint) {
                        typeParameter = this.findTypeParameterInCache(typeParameterName);
                    }

                    if (!typeParameter) {
                        typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameterName, true);

                        if (!typeParameterAST.constraint) {
                            this.addTypeParameterToCache(typeParameter);
                        }
                    }

                    signature.addTypeParameter(typeParameter);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();

                    if (this.symbolIsRedeclaration(typeParameter)) {
                        typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameterDecls[0]);
                        methodDeclaration.addDiagnostic(new TypeScript.SemanticDiagnostic(this.semanticInfo.getPath(), typeParameterAST.minChar, typeParameterAST.getLength(), 69 /* Duplicate_identifier__0_ */, [typeParameter.getName()]));
                    }

                    typeParameterDecls = typeParameter.getDeclarations();

                    for (var j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }

            signature.addDeclaration(methodDeclaration);
            methodDeclaration.setSignatureSymbol(signature);

            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(methodDeclaration), methodTypeSymbol, signature);

            methodTypeSymbol.addSignature(signature);

            if (!isSignature) {
            }

            var otherDecls = this.findDeclsInContext(methodDeclaration, methodDeclaration.getKind(), false);

            if (otherDecls && otherDecls.length) {
                for (var i = 0; i < otherDecls.length; i++) {
                    otherDecls[i].ensureSymbolIsBound();
                }
            }
        };

        PullSymbolBinder.prototype.bindConstructorDeclarationToPullSymbol = function (constructorDeclaration) {
            var declKind = constructorDeclaration.getKind();
            var declFlags = constructorDeclaration.getFlags();
            var constructorAST = this.semanticInfo.getASTForDecl(constructorDeclaration);

            var constructorName = constructorDeclaration.getName();

            var isSignature = (declFlags & 2048 /* Signature */) !== 0;

            var parent = this.getParent(constructorDeclaration, true);

            var parentHadSymbol = false;
            var cleanedPreviousDecls = false;

            var constructorSymbol = parent.getConstructorMethod();
            var constructorTypeSymbol = null;

            var linkKind = 7 /* ConstructorMethod */;

            if (constructorSymbol && (constructorSymbol.getKind() !== 32768 /* ConstructorMethod */ || (!isSignature && constructorSymbol.getType() && constructorSymbol.getType().hasOwnConstructSignatures() && (constructorSymbol.getType()).getDefinitionSignature() && !constructorSymbol.allDeclsHaveFlag(2048 /* Signature */)))) {
                constructorDeclaration.addDiagnostic(new TypeScript.SemanticDiagnostic(this.semanticInfo.getPath(), constructorAST.minChar, constructorAST.getLength(), 139 /* Multiple_constructor_implementations_are_not_allowed */, null));

                constructorSymbol = null;
            }

            if (constructorSymbol) {
                constructorTypeSymbol = constructorSymbol.getType();

                if (this.reBindingAfterChange) {
                    var decls = constructorSymbol.getDeclarations();
                    var scriptName = constructorDeclaration.getScriptName();
                    var isGeneric = constructorTypeSymbol.isGeneric();

                    for (var j = 0; j < decls.length; j++) {
                        if (decls[j].getScriptName() === scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                            constructorSymbol.removeDeclaration(decls[j]);

                            cleanedPreviousDecls = true;
                        }
                    }

                    decls = constructorTypeSymbol.getDeclarations();

                    for (var j = 0; j < decls.length; j++) {
                        if (decls[j].getScriptName() === scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                            constructorTypeSymbol.removeDeclaration(decls[j]);

                            cleanedPreviousDecls = true;
                        }
                    }

                    if (isGeneric) {
                        var specializations = constructorTypeSymbol.getKnownSpecializations();

                        for (var i = 0; i < specializations.length; i++) {
                            specializations[i].invalidate();
                        }
                    }

                    constructorSymbol.invalidate();
                    constructorTypeSymbol.invalidate();
                }
            }

            if (!constructorSymbol) {
                constructorSymbol = new TypeScript.PullSymbol(constructorName, 32768 /* ConstructorMethod */);
                constructorTypeSymbol = new TypeScript.PullConstructorTypeSymbol();
            }

            parent.setConstructorMethod(constructorSymbol);
            constructorSymbol.setType(constructorTypeSymbol);

            constructorDeclaration.setSymbol(constructorSymbol);
            constructorSymbol.addDeclaration(constructorDeclaration);
            constructorTypeSymbol.addDeclaration(constructorDeclaration);
            this.semanticInfo.setSymbolAndDiagnosticsForAST(constructorAST, TypeScript.SymbolAndDiagnostics.fromSymbol(constructorSymbol));

            if (parentHadSymbol && cleanedPreviousDecls) {
                var constructSigs = constructorTypeSymbol.getConstructSignatures();

                for (var i = 0; i < constructSigs.length; i++) {
                    constructorTypeSymbol.removeConstructSignature(constructSigs[i]);
                }

                constructorSymbol.invalidate();
                constructorTypeSymbol.invalidate();
                constructorTypeSymbol.recomputeConstructSignatures();

                if (isGeneric) {
                    var specializations = constructorTypeSymbol.getKnownSpecializations();

                    for (var j = 0; j < specializations.length; j++) {
                        constructSigs = specializations[j].getConstructSignatures();

                        for (var i = 0; i < constructSigs.length; i++) {
                            constructSigs[i].invalidate();
                        }
                    }
                }
            }

            var constructSignature = isSignature ? new TypeScript.PullSignatureSymbol(2097152 /* ConstructSignature */) : new TypeScript.PullDefinitionSignatureSymbol(2097152 /* ConstructSignature */);

            constructSignature.setReturnType(parent);

            constructSignature.addDeclaration(constructorDeclaration);
            constructorDeclaration.setSignatureSymbol(constructSignature);

            this.bindParameterSymbols(constructorAST, constructorTypeSymbol, constructSignature);

            var typeParameters = constructorTypeSymbol.getTypeParameters();

            for (var i = 0; i < typeParameters.length; i++) {
                constructSignature.addTypeParameter(typeParameters[i]);
            }

            if (constructorAST.variableArgList) {
                constructSignature.setHasVariableParamList();
            }

            constructorTypeSymbol.addSignature(constructSignature);

            if (!isSignature) {
            }

            var otherDecls = this.findDeclsInContext(constructorDeclaration, constructorDeclaration.getKind(), false);

            if (otherDecls && otherDecls.length) {
                for (var i = 0; i < otherDecls.length; i++) {
                    otherDecls[i].ensureSymbolIsBound();
                }
            }
        };

        PullSymbolBinder.prototype.bindConstructSignatureDeclarationToPullSymbol = function (constructSignatureDeclaration) {
            var parent = this.getParent(constructSignatureDeclaration, true);
            var constructorAST = this.semanticInfo.getASTForDecl(constructSignatureDeclaration);

            var constructSigs = parent.getConstructSignatures();

            for (var i = 0; i < constructSigs.length; i++) {
                if (constructSigs[i].getSymbolID() < this.startingSymbolForRebind) {
                    parent.removeConstructSignature(constructSigs[i], false);
                }
            }

            parent.recomputeConstructSignatures();
            var constructSignature = new TypeScript.PullSignatureSymbol(2097152 /* ConstructSignature */);

            if (constructorAST.variableArgList) {
                constructSignature.setHasVariableParamList();
            }

            var typeParameters = constructSignatureDeclaration.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = constructSignature.findTypeParameter(typeParameters[i].getName());

                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].getName(), true);

                    constructSignature.addTypeParameter(typeParameter);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();

                    if (this.symbolIsRedeclaration(typeParameter)) {
                        var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameterDecls[0]);
                        constructSignatureDeclaration.addDiagnostic(new TypeScript.SemanticDiagnostic(this.semanticInfo.getPath(), typeParameterAST.minChar, typeParameterAST.getLength(), 69 /* Duplicate_identifier__0_ */, [typeParameter.getName()]));
                    }

                    for (var j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }

            constructSignature.addDeclaration(constructSignatureDeclaration);
            constructSignatureDeclaration.setSignatureSymbol(constructSignature);

            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(constructSignatureDeclaration), null, constructSignature);

            this.semanticInfo.setSymbolAndDiagnosticsForAST(this.semanticInfo.getASTForDecl(constructSignatureDeclaration), TypeScript.SymbolAndDiagnostics.fromSymbol(constructSignature));

            parent.addConstructSignature(constructSignature);
        };

        PullSymbolBinder.prototype.bindCallSignatureDeclarationToPullSymbol = function (callSignatureDeclaration) {
            var parent = this.getParent(callSignatureDeclaration, true);
            var callSignatureAST = this.semanticInfo.getASTForDecl(callSignatureDeclaration);

            var callSigs = parent.getCallSignatures();

            for (var i = 0; i < callSigs.length; i++) {
                if (callSigs[i].getSymbolID() < this.startingSymbolForRebind) {
                    parent.removeCallSignature(callSigs[i], false);
                }
            }

            parent.recomputeCallSignatures();

            var callSignature = new TypeScript.PullSignatureSymbol(1048576 /* CallSignature */);

            if (callSignatureAST.variableArgList) {
                callSignature.setHasVariableParamList();
            }

            var typeParameters = callSignatureDeclaration.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = callSignature.findTypeParameter(typeParameters[i].getName());

                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].getName(), true);

                    callSignature.addTypeParameter(typeParameter);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();

                    if (this.symbolIsRedeclaration(typeParameter)) {
                        var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameterDecls[0]);
                        callSignatureDeclaration.addDiagnostic(new TypeScript.SemanticDiagnostic(this.semanticInfo.getPath(), typeParameterAST.minChar, typeParameterAST.getLength(), 69 /* Duplicate_identifier__0_ */, [typeParameter.getName()]));
                    }

                    for (var j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }

            callSignature.addDeclaration(callSignatureDeclaration);
            callSignatureDeclaration.setSignatureSymbol(callSignature);

            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(callSignatureDeclaration), null, callSignature);

            this.semanticInfo.setSymbolAndDiagnosticsForAST(this.semanticInfo.getASTForDecl(callSignatureDeclaration), TypeScript.SymbolAndDiagnostics.fromSymbol(callSignature));

            parent.addCallSignature(callSignature);
        };

        PullSymbolBinder.prototype.bindIndexSignatureDeclarationToPullSymbol = function (indexSignatureDeclaration) {
            var parent = this.getParent(indexSignatureDeclaration, true);

            var indexSigs = parent.getIndexSignatures();

            for (var i = 0; i < indexSigs.length; i++) {
                if (indexSigs[i].getSymbolID() < this.startingSymbolForRebind) {
                    parent.removeIndexSignature(indexSigs[i], false);
                }
            }

            parent.recomputeIndexSignatures();

            var indexSignature = new TypeScript.PullSignatureSymbol(4194304 /* IndexSignature */);

            var typeParameters = indexSignatureDeclaration.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = indexSignature.findTypeParameter(typeParameters[i].getName());

                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].getName(), true);

                    indexSignature.addTypeParameter(typeParameter);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();

                    if (this.symbolIsRedeclaration(typeParameter)) {
                        var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameterDecls[0]);
                        indexSignatureDeclaration.addDiagnostic(new TypeScript.SemanticDiagnostic(this.semanticInfo.getPath(), typeParameterAST.minChar, typeParameterAST.getLength(), 69 /* Duplicate_identifier__0_ */, [typeParameter.getName()]));
                    }

                    typeParameterDecls = typeParameter.getDeclarations();

                    for (var j = 0; j < typeParameterDecls.length; j++) {
                        if (typeParameterDecls[j].getDeclID() < this.startingDeclForRebind) {
                            typeParameter.removeDeclaration(typeParameterDecls[j]);
                        }
                    }
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }

            indexSignature.addDeclaration(indexSignatureDeclaration);
            indexSignatureDeclaration.setSignatureSymbol(indexSignature);

            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(indexSignatureDeclaration), null, indexSignature);

            this.semanticInfo.setSymbolAndDiagnosticsForAST(this.semanticInfo.getASTForDecl(indexSignatureDeclaration), TypeScript.SymbolAndDiagnostics.fromSymbol(indexSignature));

            parent.addIndexSignature(indexSignature);
        };

        PullSymbolBinder.prototype.bindGetAccessorDeclarationToPullSymbol = function (getAccessorDeclaration) {
            var declKind = getAccessorDeclaration.getKind();
            var declFlags = getAccessorDeclaration.getFlags();
            var funcDeclAST = this.semanticInfo.getASTForDecl(getAccessorDeclaration);

            var isExported = (declFlags & 1 /* Exported */) !== 0;

            var funcName = getAccessorDeclaration.getName();

            var isSignature = (declFlags & 2048 /* Signature */) !== 0;
            var isStatic = false;
            var linkKind = 5 /* PublicMember */;

            if (TypeScript.hasFlag(declFlags, 16 /* Static */)) {
                isStatic = true;
            }

            if (TypeScript.hasFlag(declFlags, 2 /* Private */)) {
                linkKind = 6 /* PrivateMember */;
            }

            var parent = this.getParent(getAccessorDeclaration, true);
            var parentHadSymbol = false;
            var cleanedPreviousDecls = false;

            var accessorSymbol = null;
            var getterSymbol = null;
            var getterTypeSymbol = null;

            if (isStatic) {
                parent = (parent).getConstructorMethod().getType();
            }

            accessorSymbol = parent.findMember(funcName, false);

            if (accessorSymbol) {
                if (!accessorSymbol.isAccessor()) {
                    getAccessorDeclaration.addDiagnostic(new TypeScript.SemanticDiagnostic(this.semanticInfo.getPath(), funcDeclAST.minChar, funcDeclAST.getLength(), 69 /* Duplicate_identifier__0_ */, [getAccessorDeclaration.getDisplayName()]));
                    accessorSymbol = null;
                } else {
                    getterSymbol = accessorSymbol.getGetter();

                    if (getterSymbol && (!this.reBindingAfterChange || this.symbolIsRedeclaration(getterSymbol))) {
                        getAccessorDeclaration.addDiagnostic(new TypeScript.SemanticDiagnostic(this.semanticInfo.getPath(), funcDeclAST.minChar, funcDeclAST.getLength(), 84 /* Getter__0__already_declared */, [getAccessorDeclaration.getDisplayName()]));
                        accessorSymbol = null;
                        getterSymbol = null;
                    }
                }
            }

            if (accessorSymbol) {
                parentHadSymbol = true;
            }

            if (accessorSymbol && getterSymbol) {
                getterTypeSymbol = getterSymbol.getType();
            }

            if (this.reBindingAfterChange && accessorSymbol) {
                var decls = accessorSymbol.getDeclarations();
                var scriptName = getAccessorDeclaration.getScriptName();

                for (var j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() === scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        accessorSymbol.removeDeclaration(decls[j]);

                        cleanedPreviousDecls = true;
                    }
                }

                if (getterSymbol) {
                    decls = getterSymbol.getDeclarations();

                    for (var j = 0; j < decls.length; j++) {
                        if (decls[j].getScriptName() === scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                            getterSymbol.removeDeclaration(decls[j]);

                            cleanedPreviousDecls = true;
                        }
                    }
                }

                accessorSymbol.invalidate();
            }

            if (!accessorSymbol) {
                accessorSymbol = new TypeScript.PullAccessorSymbol(funcName);
            }

            if (!getterSymbol) {
                getterSymbol = new TypeScript.PullSymbol(funcName, 16384 /* Function */);
                getterTypeSymbol = new TypeScript.PullFunctionTypeSymbol();

                getterSymbol.setType(getterTypeSymbol);

                accessorSymbol.setGetter(getterSymbol);
            }

            getAccessorDeclaration.setSymbol(accessorSymbol);
            accessorSymbol.addDeclaration(getAccessorDeclaration);
            getterSymbol.addDeclaration(getAccessorDeclaration);

            this.semanticInfo.setSymbolAndDiagnosticsForAST(funcDeclAST.name, TypeScript.SymbolAndDiagnostics.fromSymbol(getterSymbol));
            this.semanticInfo.setSymbolAndDiagnosticsForAST(funcDeclAST, TypeScript.SymbolAndDiagnostics.fromSymbol(getterSymbol));

            if (!parentHadSymbol) {
                parent.addMember(accessorSymbol, linkKind);
            }

            if (parentHadSymbol && cleanedPreviousDecls) {
                var callSigs = getterTypeSymbol.getCallSignatures();

                for (var i = 0; i < callSigs.length; i++) {
                    getterTypeSymbol.removeCallSignature(callSigs[i], false);
                }

                getterSymbol.invalidate();
                getterTypeSymbol.invalidate();
                getterTypeSymbol.recomputeCallSignatures();
            }

            var signature = isSignature ? new TypeScript.PullSignatureSymbol(1048576 /* CallSignature */) : new TypeScript.PullDefinitionSignatureSymbol(1048576 /* CallSignature */);

            signature.addDeclaration(getAccessorDeclaration);
            getAccessorDeclaration.setSignatureSymbol(signature);

            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(getAccessorDeclaration), getterTypeSymbol, signature);

            var typeParameters = getAccessorDeclaration.getTypeParameters();

            if (typeParameters.length) {
                getAccessorDeclaration.addDiagnostic(new TypeScript.SemanticDiagnostic(this.semanticInfo.getPath(), funcDeclAST.minChar, funcDeclAST.getLength(), 86 /* Accessor_cannot_have_type_parameters */, null));
            }

            getterTypeSymbol.addSignature(signature);

            if (!isSignature) {
            }

            getterSymbol.setIsBound(this.bindingPhase);
        };

        PullSymbolBinder.prototype.bindSetAccessorDeclarationToPullSymbol = function (setAccessorDeclaration) {
            var declKind = setAccessorDeclaration.getKind();
            var declFlags = setAccessorDeclaration.getFlags();
            var funcDeclAST = this.semanticInfo.getASTForDecl(setAccessorDeclaration);

            var isExported = (declFlags & 1 /* Exported */) !== 0;

            var funcName = setAccessorDeclaration.getName();

            var isSignature = (declFlags & 2048 /* Signature */) !== 0;
            var isStatic = false;
            var linkKind = 5 /* PublicMember */;

            if (TypeScript.hasFlag(declFlags, 16 /* Static */)) {
                isStatic = true;
            }

            if (TypeScript.hasFlag(declFlags, 2 /* Private */)) {
                linkKind = 6 /* PrivateMember */;
            }

            var parent = this.getParent(setAccessorDeclaration, true);
            var parentHadSymbol = false;
            var cleanedPreviousDecls = false;

            var accessorSymbol = null;
            var setterSymbol = null;
            var setterTypeSymbol = null;

            if (isStatic) {
                parent = (parent).getConstructorMethod().getType();
            }

            accessorSymbol = parent.findMember(funcName, false);

            if (accessorSymbol) {
                if (!accessorSymbol.isAccessor()) {
                    setAccessorDeclaration.addDiagnostic(new TypeScript.SemanticDiagnostic(this.semanticInfo.getPath(), funcDeclAST.minChar, funcDeclAST.getLength(), 69 /* Duplicate_identifier__0_ */, [setAccessorDeclaration.getDisplayName()]));
                    accessorSymbol = null;
                } else {
                    setterSymbol = accessorSymbol.getSetter();

                    if (setterSymbol && (!this.reBindingAfterChange || this.symbolIsRedeclaration(setterSymbol))) {
                        setAccessorDeclaration.addDiagnostic(new TypeScript.SemanticDiagnostic(this.semanticInfo.getPath(), funcDeclAST.minChar, funcDeclAST.getLength(), 85 /* Setter__0__already_declared */, [setAccessorDeclaration.getDisplayName()]));
                        accessorSymbol = null;
                        setterSymbol = null;
                    }
                }
            }

            if (accessorSymbol) {
                parentHadSymbol = true;
            }

            if (accessorSymbol && setterSymbol) {
                setterTypeSymbol = setterSymbol.getType();
            }

            if (this.reBindingAfterChange && accessorSymbol) {
                var decls = accessorSymbol.getDeclarations();
                var scriptName = setAccessorDeclaration.getScriptName();

                for (var j = 0; j < decls.length; j++) {
                    if (decls[j].getScriptName() === scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                        accessorSymbol.removeDeclaration(decls[j]);

                        cleanedPreviousDecls = true;
                    }
                }

                if (setterSymbol) {
                    decls = setterSymbol.getDeclarations();

                    for (var j = 0; j < decls.length; j++) {
                        if (decls[j].getScriptName() === scriptName && decls[j].getDeclID() < this.startingDeclForRebind) {
                            setterSymbol.removeDeclaration(decls[j]);

                            cleanedPreviousDecls = true;
                        }
                    }
                }

                accessorSymbol.invalidate();
            }

            if (!accessorSymbol) {
                accessorSymbol = new TypeScript.PullAccessorSymbol(funcName);
            }

            if (!setterSymbol) {
                setterSymbol = new TypeScript.PullSymbol(funcName, 16384 /* Function */);
                setterTypeSymbol = new TypeScript.PullFunctionTypeSymbol();

                setterSymbol.setType(setterTypeSymbol);

                accessorSymbol.setSetter(setterSymbol);
            }

            setAccessorDeclaration.setSymbol(accessorSymbol);
            accessorSymbol.addDeclaration(setAccessorDeclaration);
            setterSymbol.addDeclaration(setAccessorDeclaration);

            this.semanticInfo.setSymbolAndDiagnosticsForAST(funcDeclAST.name, TypeScript.SymbolAndDiagnostics.fromSymbol(setterSymbol));
            this.semanticInfo.setSymbolAndDiagnosticsForAST(funcDeclAST, TypeScript.SymbolAndDiagnostics.fromSymbol(setterSymbol));

            if (!parentHadSymbol) {
                parent.addMember(accessorSymbol, linkKind);
            }

            if (parentHadSymbol && cleanedPreviousDecls) {
                var callSigs = setterTypeSymbol.getCallSignatures();

                for (var i = 0; i < callSigs.length; i++) {
                    setterTypeSymbol.removeCallSignature(callSigs[i], false);
                }

                setterSymbol.invalidate();
                setterTypeSymbol.invalidate();
                setterTypeSymbol.recomputeCallSignatures();
            }

            var signature = isSignature ? new TypeScript.PullSignatureSymbol(1048576 /* CallSignature */) : new TypeScript.PullDefinitionSignatureSymbol(1048576 /* CallSignature */);

            signature.addDeclaration(setAccessorDeclaration);
            setAccessorDeclaration.setSignatureSymbol(signature);

            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(setAccessorDeclaration), setterTypeSymbol, signature);

            var typeParameters = setAccessorDeclaration.getTypeParameters();

            if (typeParameters.length) {
                setAccessorDeclaration.addDiagnostic(new TypeScript.SemanticDiagnostic(this.semanticInfo.getPath(), funcDeclAST.minChar, funcDeclAST.getLength(), 86 /* Accessor_cannot_have_type_parameters */, null));
            }

            setterTypeSymbol.addSignature(signature);

            if (!isSignature) {
            }

            setterSymbol.setIsBound(this.bindingPhase);
        };

        PullSymbolBinder.prototype.bindCatchBlockPullSymbols = function (catchBlockDecl) {
        };

        PullSymbolBinder.prototype.bindWithBlockPullSymbols = function (withBlockDecl) {
        };

        PullSymbolBinder.prototype.bindDeclToPullSymbol = function (decl, rebind) {
            if (typeof rebind === "undefined") { rebind = false; }
            if (rebind) {
                this.startingDeclForRebind = TypeScript.lastBoundPullDeclId;
                this.startingSymbolForRebind = TypeScript.lastBoundPullSymbolID;
                this.reBindingAfterChange = true;
            }

            if (decl.isBound()) {
                return;
            }

            decl.setIsBound(true);

            switch (decl.getKind()) {
                case 1 /* Script */:
                    var childDecls = decl.getChildDecls();
                    for (var i = 0; i < childDecls.length; i++) {
                        this.bindDeclToPullSymbol(childDecls[i]);
                    }
                    break;

                case 64 /* Enum */:
                case 32 /* DynamicModule */:
                case 4 /* Container */:
                    this.bindModuleDeclarationToPullSymbol(decl);
                    break;

                case 16 /* Interface */:
                    this.bindInterfaceDeclarationToPullSymbol(decl);
                    break;

                case 8 /* Class */:
                    this.bindClassDeclarationToPullSymbol(decl);
                    break;

                case 16384 /* Function */:
                    this.bindFunctionDeclarationToPullSymbol(decl);
                    break;

                case 1024 /* Variable */:
                    this.bindVariableDeclarationToPullSymbol(decl);
                    break;

                case 67108864 /* EnumMember */:
                case 4096 /* Property */:
                    this.bindPropertyDeclarationToPullSymbol(decl);
                    break;

                case 65536 /* Method */:
                    this.bindMethodDeclarationToPullSymbol(decl);
                    break;

                case 32768 /* ConstructorMethod */:
                    this.bindConstructorDeclarationToPullSymbol(decl);
                    break;

                case 1048576 /* CallSignature */:
                    this.bindCallSignatureDeclarationToPullSymbol(decl);
                    break;

                case 2097152 /* ConstructSignature */:
                    this.bindConstructSignatureDeclarationToPullSymbol(decl);
                    break;

                case 4194304 /* IndexSignature */:
                    this.bindIndexSignatureDeclarationToPullSymbol(decl);
                    break;

                case 262144 /* GetAccessor */:
                    this.bindGetAccessorDeclarationToPullSymbol(decl);
                    break;

                case 524288 /* SetAccessor */:
                    this.bindSetAccessorDeclarationToPullSymbol(decl);
                    break;

                case 8388608 /* ObjectType */:
                    this.bindObjectTypeDeclarationToPullSymbol(decl);
                    break;

                case 16777216 /* FunctionType */:
                    this.bindFunctionTypeDeclarationToPullSymbol(decl);
                    break;

                case 33554432 /* ConstructorType */:
                    this.bindConstructorTypeDeclarationToPullSymbol(decl);
                    break;

                case 131072 /* FunctionExpression */:
                    this.bindFunctionExpressionToPullSymbol(decl);
                    break;

                case 256 /* TypeAlias */:
                    this.bindImportDeclaration(decl);
                    break;

                case 2048 /* Parameter */:
                case 8192 /* TypeParameter */:
                    break;

                case 1073741824 /* CatchBlock */:
                    this.bindCatchBlockPullSymbols(decl);

                case 536870912 /* WithBlock */:
                    this.bindWithBlockPullSymbols(decl);
                    break;

                default:
                    throw new Error("Unrecognized type declaration");
            }
        };

        PullSymbolBinder.prototype.bindDeclsForUnit = function (filePath, rebind) {
            if (typeof rebind === "undefined") { rebind = false; }
            this.setUnit(filePath);

            var topLevelDecls = this.semanticInfo.getTopLevelDecls();

            for (var i = 0; i < topLevelDecls.length; i++) {
                this.bindDeclToPullSymbol(topLevelDecls[i], rebind);
            }
        };
        return PullSymbolBinder;
    })();
    TypeScript.PullSymbolBinder = PullSymbolBinder;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.linkID = 0;

    var IListItem = (function () {
        function IListItem(value) {
            this.value = value;
            this.next = null;
            this.prev = null;
        }
        return IListItem;
    })();
    TypeScript.IListItem = IListItem;

    var LinkList = (function () {
        function LinkList() {
            this.head = null;
            this.last = null;
            this.length = 0;
        }
        LinkList.prototype.addItem = function (item) {
            if (!this.head) {
                this.head = new IListItem(item);
                this.last = this.head;
            } else {
                this.last.next = new IListItem(item);
                this.last.next.prev = this.last;
                this.last = this.last.next;
            }

            this.length++;
        };

        LinkList.prototype.find = function (p) {
            var node = this.head;
            var vals = [];

            while (node) {
                if (p(node.value)) {
                    vals[vals.length] = node.value;
                }
                node = node.next;
            }

            return vals;
        };

        LinkList.prototype.remove = function (p) {
            var node = this.head;
            var prev = null;
            var next = null;

            while (node) {
                if (p(node.value)) {
                    if (node === this.head) {
                        if (this.last === this.head) {
                            this.last = null;
                        }

                        this.head = this.head.next;

                        if (this.head) {
                            this.head.prev = null;
                        }
                    } else {
                        prev = node.prev;
                        next = node.next;

                        if (prev) {
                            prev.next = next;
                        }
                        if (next) {
                            next.prev = prev;
                        }

                        if (node === this.last) {
                            this.last = prev;
                        }
                    }

                    this.length--;
                }
                node = node.next;
            }
        };

        LinkList.prototype.update = function (map, context) {
            var node = this.head;

            while (node) {
                map(node.value, context);

                node = node.next;
            }
        };
        return LinkList;
    })();
    TypeScript.LinkList = LinkList;

    var PullSymbolLink = (function () {
        function PullSymbolLink(start, end, kind) {
            this.start = start;
            this.end = end;
            this.kind = kind;
            this.id = TypeScript.linkID++;
        }
        return PullSymbolLink;
    })();
    TypeScript.PullSymbolLink = PullSymbolLink;

    (function (GraphUpdateKind) {
        GraphUpdateKind[GraphUpdateKind["NoUpdate"] = 0] = "NoUpdate";

        GraphUpdateKind[GraphUpdateKind["SymbolRemoved"] = 1] = "SymbolRemoved";
        GraphUpdateKind[GraphUpdateKind["SymbolAdded"] = 2] = "SymbolAdded";

        GraphUpdateKind[GraphUpdateKind["TypeChanged"] = 3] = "TypeChanged";
    })(TypeScript.GraphUpdateKind || (TypeScript.GraphUpdateKind = {}));
    var GraphUpdateKind = TypeScript.GraphUpdateKind;

    var PullSymbolUpdate = (function () {
        function PullSymbolUpdate(updateKind, symbolToUpdate, updater) {
            this.updateKind = updateKind;
            this.symbolToUpdate = symbolToUpdate;
            this.updater = updater;
        }
        return PullSymbolUpdate;
    })();
    TypeScript.PullSymbolUpdate = PullSymbolUpdate;

    TypeScript.updateVersion = 0;

    var PullSymbolGraphUpdater = (function () {
        function PullSymbolGraphUpdater(semanticInfoChain) {
            this.semanticInfoChain = semanticInfoChain;
        }
        PullSymbolGraphUpdater.prototype.removeDecl = function (declToRemove) {
            var declSymbol = declToRemove.getSymbol();

            if (declSymbol) {
                declSymbol.removeDeclaration(declToRemove);

                var childDecls = declToRemove.getChildDecls();

                for (var i = 0; i < childDecls.length; i++) {
                    this.removeDecl(childDecls[i]);
                }

                var remainingDecls = declSymbol.getDeclarations();

                if (!remainingDecls.length) {
                    this.removeSymbol(declSymbol);

                    this.semanticInfoChain.removeSymbolFromCache(declSymbol);
                } else {
                    declSymbol.invalidate();
                }
            }

            var valDecl = declToRemove.getValueDecl();

            if (valDecl) {
                this.removeDecl(valDecl);
            }

            TypeScript.updateVersion++;
        };

        PullSymbolGraphUpdater.prototype.addDecl = function (declToAdd) {
            var symbolToAdd = declToAdd.getSymbol();

            if (symbolToAdd) {
                this.addSymbol(symbolToAdd);
            }

            TypeScript.updateVersion++;
        };

        PullSymbolGraphUpdater.prototype.removeSymbol = function (symbolToRemove) {
            if (symbolToRemove.removeUpdateVersion === TypeScript.updateVersion) {
                return;
            }

            symbolToRemove.removeUpdateVersion = TypeScript.updateVersion;

            symbolToRemove.updateOutgoingLinks(propagateRemovalToOutgoingLinks, new PullSymbolUpdate(1 /* SymbolRemoved */, symbolToRemove, this));

            symbolToRemove.updateIncomingLinks(propagateRemovalToIncomingLinks, new PullSymbolUpdate(1 /* SymbolRemoved */, symbolToRemove, this));

            symbolToRemove.unsetContainer();

            this.semanticInfoChain.removeSymbolFromCache(symbolToRemove);

            var container = symbolToRemove.getContainer();

            if (container) {
                container.removeMember(symbolToRemove);
                this.semanticInfoChain.removeSymbolFromCache(symbolToRemove);
            }

            if (symbolToRemove.isAccessor()) {
                var getterSymbol = (symbolToRemove).getGetter();
                var setterSymbol = (symbolToRemove).getSetter();

                if (getterSymbol) {
                    this.removeSymbol(getterSymbol);
                }

                if (setterSymbol) {
                    this.removeSymbol(setterSymbol);
                }
            }

            symbolToRemove.removeAllLinks();
        };

        PullSymbolGraphUpdater.prototype.addSymbol = function (symbolToAdd) {
            if (symbolToAdd.addUpdateVersion === TypeScript.updateVersion) {
                return;
            }

            symbolToAdd.addUpdateVersion = TypeScript.updateVersion;

            symbolToAdd.updateOutgoingLinks(propagateAdditionToOutgoingLinks, new PullSymbolUpdate(2 /* SymbolAdded */, symbolToAdd, this));

            symbolToAdd.updateIncomingLinks(propagateAdditionToIncomingLinks, new PullSymbolUpdate(2 /* SymbolAdded */, symbolToAdd, this));
        };

        PullSymbolGraphUpdater.prototype.invalidateType = function (symbolWhoseTypeChanged) {
            if (!symbolWhoseTypeChanged) {
                return;
            }

            if (symbolWhoseTypeChanged.isPrimitive()) {
                return;
            }

            if (symbolWhoseTypeChanged.typeChangeUpdateVersion === TypeScript.updateVersion) {
                return;
            }

            symbolWhoseTypeChanged.typeChangeUpdateVersion = TypeScript.updateVersion;

            symbolWhoseTypeChanged.updateOutgoingLinks(propagateChangedTypeToOutgoingLinks, new PullSymbolUpdate(3 /* TypeChanged */, symbolWhoseTypeChanged, this));

            symbolWhoseTypeChanged.updateIncomingLinks(propagateChangedTypeToIncomingLinks, new PullSymbolUpdate(3 /* TypeChanged */, symbolWhoseTypeChanged, this));

            if (symbolWhoseTypeChanged.getKind() === 4 /* Container */) {
                var instanceSymbol = (symbolWhoseTypeChanged).getInstanceSymbol();

                this.invalidateType(instanceSymbol);
            }

            if (symbolWhoseTypeChanged.isResolved()) {
                symbolWhoseTypeChanged.invalidate();
            }

            this.invalidateUnitsForSymbol(symbolWhoseTypeChanged);
        };

        PullSymbolGraphUpdater.prototype.invalidateUnitsForSymbol = function (symbol) {
            var declarations = symbol.getDeclarations();

            for (var i = 0; i < declarations.length; i++) {
                this.semanticInfoChain.invalidateUnit(declarations[i].getScriptName());
            }
        };
        return PullSymbolGraphUpdater;
    })();
    TypeScript.PullSymbolGraphUpdater = PullSymbolGraphUpdater;

    function propagateRemovalToOutgoingLinks(link, update) {
        var symbolToRemove = update.symbolToUpdate;
        var affectedSymbol = link.end;

        if (affectedSymbol.removeUpdateVersion === TypeScript.updateVersion || affectedSymbol.isPrimitive()) {
            return;
        }

        if (link.kind === 2 /* ProvidesInferredType */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 21 /* SpecializedTo */) {
            (symbolToRemove).removeSpecialization(affectedSymbol);
            update.updater.removeSymbol(affectedSymbol);
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 5 /* PublicMember */) {
            update.updater.removeSymbol(affectedSymbol);
        } else if (link.kind === 6 /* PrivateMember */) {
            update.updater.removeSymbol(affectedSymbol);
        } else if (link.kind === 7 /* ConstructorMethod */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 10 /* ContainedBy */) {
            (affectedSymbol).removeMember(symbolToRemove);
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 13 /* Parameter */) {
            update.updater.removeSymbol(affectedSymbol);
        } else if (link.kind === 15 /* CallSignature */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 16 /* ConstructSignature */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 17 /* IndexSignature */) {
            update.updater.invalidateType(affectedSymbol);
        }

        symbolToRemove.removeOutgoingLink(link);
    }
    TypeScript.propagateRemovalToOutgoingLinks = propagateRemovalToOutgoingLinks;

    function propagateRemovalToIncomingLinks(link, update) {
        var symbolToRemove = update.symbolToUpdate;
        var affectedSymbol = link.start;

        if (affectedSymbol.removeUpdateVersion === TypeScript.updateVersion || affectedSymbol.isPrimitive()) {
            return;
        }

        if (link.kind === 0 /* TypedAs */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 1 /* ContextuallyTypedAs */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 18 /* TypeParameter */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 19 /* TypeArgument */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 21 /* SpecializedTo */) {
            (affectedSymbol).removeSpecialization(symbolToRemove);
        } else if (link.kind === 22 /* TypeConstraint */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 5 /* PublicMember */) {
            (affectedSymbol).removeMember(symbolToRemove);
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 6 /* PrivateMember */) {
            (affectedSymbol).removeMember(symbolToRemove);
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 7 /* ConstructorMethod */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 10 /* ContainedBy */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 11 /* Extends */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 12 /* Implements */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 13 /* Parameter */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 14 /* ReturnType */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 15 /* CallSignature */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 16 /* ConstructSignature */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 17 /* IndexSignature */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 8 /* Aliases */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 9 /* ExportAliases */) {
            update.updater.invalidateType(affectedSymbol);
        }
    }
    TypeScript.propagateRemovalToIncomingLinks = propagateRemovalToIncomingLinks;

    function propagateAdditionToOutgoingLinks(link, update) {
        var symbolToAdd = update.symbolToUpdate;
        var affectedSymbol = link.end;

        if (affectedSymbol.addUpdateVersion === TypeScript.updateVersion || affectedSymbol.isPrimitive()) {
            return;
        }

        if (link.kind === 10 /* ContainedBy */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 2 /* ProvidesInferredType */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 18 /* TypeParameter */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 19 /* TypeArgument */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 21 /* SpecializedTo */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 22 /* TypeConstraint */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 5 /* PublicMember */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 7 /* ConstructorMethod */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 14 /* ReturnType */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 15 /* CallSignature */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 16 /* ConstructSignature */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 17 /* IndexSignature */) {
            update.updater.invalidateType(affectedSymbol);
        }
    }
    TypeScript.propagateAdditionToOutgoingLinks = propagateAdditionToOutgoingLinks;

    function propagateAdditionToIncomingLinks(link, update) {
        var symbolToAdd = update.symbolToUpdate;
        var affectedSymbol = link.start;

        if (affectedSymbol.addUpdateVersion === TypeScript.updateVersion || affectedSymbol.isPrimitive()) {
            return;
        }

        if (link.kind === 0 /* TypedAs */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 1 /* ContextuallyTypedAs */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 18 /* TypeParameter */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 19 /* TypeArgument */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 22 /* TypeConstraint */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 5 /* PublicMember */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 7 /* ConstructorMethod */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 11 /* Extends */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 12 /* Implements */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 14 /* ReturnType */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 8 /* Aliases */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 9 /* ExportAliases */) {
            update.updater.invalidateType(affectedSymbol);
        }
    }
    TypeScript.propagateAdditionToIncomingLinks = propagateAdditionToIncomingLinks;

    function propagateChangedTypeToOutgoingLinks(link, update) {
        var symbolWhoseTypeChanged = update.symbolToUpdate;
        var affectedSymbol = link.end;

        if (affectedSymbol.typeChangeUpdateVersion === TypeScript.updateVersion || affectedSymbol.isPrimitive()) {
            return;
        }

        if (link.kind === 2 /* ProvidesInferredType */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 10 /* ContainedBy */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 18 /* TypeParameter */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 19 /* TypeArgument */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 21 /* SpecializedTo */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 22 /* TypeConstraint */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 5 /* PublicMember */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 15 /* CallSignature */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 7 /* ConstructorMethod */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 16 /* ConstructSignature */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 17 /* IndexSignature */) {
            update.updater.invalidateType(affectedSymbol);
        }
    }
    TypeScript.propagateChangedTypeToOutgoingLinks = propagateChangedTypeToOutgoingLinks;

    function propagateChangedTypeToIncomingLinks(link, update) {
        var symbolWhoseTypeChanged = update.symbolToUpdate;
        var affectedSymbol = link.start;

        if (affectedSymbol.typeChangeUpdateVersion === TypeScript.updateVersion || affectedSymbol.isPrimitive()) {
            return;
        }

        if (link.kind === 0 /* TypedAs */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 1 /* ContextuallyTypedAs */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 18 /* TypeParameter */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 19 /* TypeArgument */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 22 /* TypeConstraint */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 5 /* PublicMember */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 17 /* IndexSignature */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 11 /* Extends */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 12 /* Implements */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 14 /* ReturnType */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 8 /* Aliases */) {
            update.updater.invalidateType(affectedSymbol);
        } else if (link.kind === 9 /* ExportAliases */) {
            update.updater.invalidateType(affectedSymbol);
        }
    }
    TypeScript.propagateChangedTypeToIncomingLinks = propagateChangedTypeToIncomingLinks;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SemanticDiagnostic = (function (_super) {
        __extends(SemanticDiagnostic, _super);
        function SemanticDiagnostic() {
            _super.apply(this, arguments);
        }
        SemanticDiagnostic.equals = function (diagnostic1, diagnostic2) {
            return TypeScript.Diagnostic.equals(diagnostic1, diagnostic2);
        };
        return SemanticDiagnostic;
    })(TypeScript.Diagnostic);
    TypeScript.SemanticDiagnostic = SemanticDiagnostic;

    function getDiagnosticsFromEnclosingDecl(enclosingDecl, errors) {
        var declErrors = enclosingDecl.getDiagnostics();

        if (declErrors) {
            for (var i = 0; i < declErrors.length; i++) {
                errors[errors.length] = declErrors[i];
            }
        }

        var childDecls = enclosingDecl.getChildDecls();

        for (var i = 0; i < childDecls.length; i++) {
            getDiagnosticsFromEnclosingDecl(childDecls[i], errors);
        }
    }
    TypeScript.getDiagnosticsFromEnclosingDecl = getDiagnosticsFromEnclosingDecl;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (PullHelpers) {
        function getSignatureForFuncDecl(funcDecl, semanticInfo) {
            var functionDecl = semanticInfo.getDeclForAST(funcDecl);
            var funcSymbol = functionDecl.getSymbol();

            if (!funcSymbol) {
                funcSymbol = functionDecl.getSignatureSymbol();
            }

            var functionSignature = null;
            var typeSymbolWithAllSignatures = null;
            if (funcSymbol.isSignature()) {
                functionSignature = funcSymbol;
                var parent = functionDecl.getParentDecl();
                typeSymbolWithAllSignatures = parent.getSymbol().getType();
            } else {
                functionSignature = functionDecl.getSignatureSymbol();
                typeSymbolWithAllSignatures = funcSymbol.getType();
            }
            var signatures;
            if (funcDecl.isConstructor || funcDecl.isConstructMember()) {
                signatures = typeSymbolWithAllSignatures.getConstructSignatures();
            } else if (funcDecl.isIndexerMember()) {
                signatures = typeSymbolWithAllSignatures.getIndexSignatures();
            } else {
                signatures = typeSymbolWithAllSignatures.getCallSignatures();
            }
            return {
                signature: functionSignature,
                allSignatures: signatures
            };
        }
        PullHelpers.getSignatureForFuncDecl = getSignatureForFuncDecl;

        function getAccessorSymbol(getterOrSetter, semanticInfoChain, unitPath) {
            var functionDecl = semanticInfoChain.getDeclForAST(getterOrSetter, unitPath);
            var getterOrSetterSymbol = functionDecl.getSymbol();

            return getterOrSetterSymbol;
        }
        PullHelpers.getAccessorSymbol = getAccessorSymbol;

        function getGetterAndSetterFunction(funcDecl, semanticInfoChain, unitPath) {
            var accessorSymbol = PullHelpers.getAccessorSymbol(funcDecl, semanticInfoChain, unitPath);
            var result = {
                getter: null,
                setter: null
            };
            var getter = accessorSymbol.getGetter();
            if (getter) {
                var getterDecl = getter.getDeclarations()[0];
                result.getter = semanticInfoChain.getASTForDecl(getterDecl);
            }
            var setter = accessorSymbol.getSetter();
            if (setter) {
                var setterDecl = setter.getDeclarations()[0];
                result.setter = semanticInfoChain.getASTForDecl(setterDecl);
            }

            return result;
        }
        PullHelpers.getGetterAndSetterFunction = getGetterAndSetterFunction;

        function symbolIsEnum(source) {
            return source && ((source.getKind() & (64 /* Enum */ | 67108864 /* EnumMember */)) || source.hasFlag(131072 /* InitializedEnum */));
        }
        PullHelpers.symbolIsEnum = symbolIsEnum;
    })(TypeScript.PullHelpers || (TypeScript.PullHelpers = {}));
    var PullHelpers = TypeScript.PullHelpers;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var incrementalAst = true;
    var SyntaxPositionMap = (function () {
        function SyntaxPositionMap(node) {
            this.position = 0;
            this.elementToPosition = TypeScript.Collections.createHashTable(2048, TypeScript.Collections.identityHashCode);
            this.process(node);
        }
        SyntaxPositionMap.prototype.process = function (element) {
            if (element !== null) {
                if (element.isToken()) {
                    this.elementToPosition.add(element, this.position);
                    this.position += element.fullWidth();
                } else {
                    if (element.isNode() || (element.isList() && (element).childCount() > 0) || (element.isSeparatedList() && (element).childCount() > 0)) {
                        this.elementToPosition.add(element, this.position);
                    }

                    for (var i = 0, n = element.childCount(); i < n; i++) {
                        this.process(element.childAt(i));
                    }
                }
            }
        };

        SyntaxPositionMap.create = function (node) {
            var map = new SyntaxPositionMap(node);
            return map;
        };

        SyntaxPositionMap.prototype.fullStart = function (element) {
            return this.elementToPosition.get(element);
        };

        SyntaxPositionMap.prototype.start = function (element) {
            return this.fullStart(element) + element.leadingTriviaWidth();
        };

        SyntaxPositionMap.prototype.end = function (element) {
            return this.start(element) + element.width();
        };

        SyntaxPositionMap.prototype.fullEnd = function (element) {
            return this.fullStart(element) + element.fullWidth();
        };
        return SyntaxPositionMap;
    })();
    TypeScript.SyntaxPositionMap = SyntaxPositionMap;

    var SyntaxTreeToAstVisitor = (function () {
        function SyntaxTreeToAstVisitor(syntaxPositionMap, fileName, lineMap, compilationSettings) {
            this.syntaxPositionMap = syntaxPositionMap;
            this.fileName = fileName;
            this.lineMap = lineMap;
            this.compilationSettings = compilationSettings;
            this.position = 0;
            this.requiresExtendsBlock = false;
            this.previousTokenTrailingComments = null;
            this.isParsingAmbientModule = false;
            this.containingModuleHasExportAssignment = false;
            this.isParsingDeclareFile = TypeScript.isDTSFile(fileName);
        }
        SyntaxTreeToAstVisitor.visit = function (syntaxTree, fileName, compilationSettings) {
            var map = SyntaxTreeToAstVisitor.checkPositions ? SyntaxPositionMap.create(syntaxTree.sourceUnit()) : null;
            var visitor = new SyntaxTreeToAstVisitor(map, fileName, syntaxTree.lineMap(), compilationSettings);
            return syntaxTree.sourceUnit().accept(visitor);
        };

        SyntaxTreeToAstVisitor.prototype.assertElementAtPosition = function (element) {
            if (SyntaxTreeToAstVisitor.checkPositions) {
                TypeScript.Debug.assert(this.position === this.syntaxPositionMap.fullStart(element));
            }
        };

        SyntaxTreeToAstVisitor.prototype.movePast = function (element) {
            if (element !== null) {
                this.assertElementAtPosition(element);
                this.position += element.fullWidth();
            }
        };

        SyntaxTreeToAstVisitor.prototype.moveTo = function (element1, element2) {
            if (element2 !== null) {
                this.position += TypeScript.Syntax.childOffset(element1, element2);
            }
        };

        SyntaxTreeToAstVisitor.prototype.applyDelta = function (ast, delta) {
            var _this = this;
            if (delta === 0) {
                return;
            }

            var applyDelta = function (ast) {
                if (ast.minChar !== -1) {
                    ast.minChar += delta;
                }
                if (ast.limChar !== -1) {
                    ast.limChar += delta;
                }
            };

            var applyDeltaToComments = function (comments) {
                if (comments && comments.length > 0) {
                    for (var i = 0; i < comments.length; i++) {
                        var comment = comments[i];
                        applyDelta(comment);
                        comment.minLine = _this.lineMap.getLineNumberFromPosition(comment.minChar);
                        comment.limLine = _this.lineMap.getLineNumberFromPosition(comment.limChar);
                    }
                }
            };

            var pre = function (cur, parent, walker) {
                applyDelta(cur);
                applyDeltaToComments(cur.preComments);
                applyDeltaToComments(cur.postComments);

                return cur;
            };

            TypeScript.getAstWalkerFactory().walk(ast, pre);
        };

        SyntaxTreeToAstVisitor.prototype.setSpan = function (span, fullStart, element) {
            var desiredMinChar = fullStart + element.leadingTriviaWidth();
            var desiredLimChar = desiredMinChar + element.width();

            this.setSpanExplicit(span, desiredMinChar, desiredLimChar);

            span.trailingTriviaWidth = element.trailingTriviaWidth();
        };

        SyntaxTreeToAstVisitor.prototype.setSpanExplicit = function (span, start, end) {
            if (span.minChar !== -1) {
                TypeScript.Debug.assert(span.limChar !== -1);
                TypeScript.Debug.assert((span).nodeType !== undefined);

                var delta = start - span.minChar;
                this.applyDelta(span, delta);

                span.limChar = end;

                TypeScript.Debug.assert(span.minChar === start);
                TypeScript.Debug.assert(span.limChar === end);
            } else {
                TypeScript.Debug.assert(span.limChar === -1);

                span.minChar = start;
                span.limChar = end;
            }

            TypeScript.Debug.assert(!isNaN(span.minChar));
            TypeScript.Debug.assert(!isNaN(span.limChar));
            TypeScript.Debug.assert(span.minChar !== -1);
            TypeScript.Debug.assert(span.limChar !== -1);
        };

        SyntaxTreeToAstVisitor.prototype.identifierFromToken = function (token, isOptional, useValueText) {
            this.assertElementAtPosition(token);

            var result = null;
            if (token.fullWidth() === 0) {
                result = new TypeScript.MissingIdentifier();
            } else {
                result = new TypeScript.Identifier(token.text());
                result.text = useValueText ? token.valueText() : result.text;
                if (result.text == SyntaxTreeToAstVisitor.protoString) {
                    result.text = SyntaxTreeToAstVisitor.protoSubstitutionString;
                }
            }

            if (isOptional) {
                result.setFlags(result.getFlags() | 4 /* OptionalName */);
            }

            var start = this.position + token.leadingTriviaWidth();
            this.setSpanExplicit(result, start, start + token.width());

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.getAST = function (element) {
            if (this.previousTokenTrailingComments !== null) {
                return null;
            }

            if (incrementalAst) {
                var result = (element)._ast;
                return result ? result : null;
            } else {
                return null;
            }
        };

        SyntaxTreeToAstVisitor.prototype.setAST = function (element, ast) {
            if (incrementalAst) {
                (element)._ast = ast;
            }
        };

        SyntaxTreeToAstVisitor.prototype.visitSyntaxList = function (list) {
            var start = this.position;
            var result = this.getAST(list);
            if (result) {
                this.movePast(list);
            } else {
                result = new TypeScript.ASTList();

                for (var i = 0, n = list.childCount(); i < n; i++) {
                    result.append(list.childAt(i).accept(this));
                }

                if (n > 0) {
                    this.setAST(list, result);
                }
            }

            this.setSpan(result, start, list);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitSeparatedSyntaxList = function (list) {
            var start = this.position;
            var result = this.getAST(list);
            if (result) {
                this.movePast(list);
            } else {
                result = new TypeScript.ASTList();

                for (var i = 0, n = list.childCount(); i < n; i++) {
                    if (i % 2 === 0) {
                        result.append(list.childAt(i).accept(this));
                        this.previousTokenTrailingComments = null;
                    } else {
                        var separatorToken = list.childAt(i);
                        this.previousTokenTrailingComments = this.convertTokenTrailingComments(separatorToken, this.position + separatorToken.leadingTriviaWidth() + separatorToken.width());
                        this.movePast(separatorToken);
                    }
                }

                result.postComments = this.previousTokenTrailingComments;
                this.previousTokenTrailingComments = null;

                if (n > 0) {
                    this.setAST(list, result);
                }
            }

            this.setSpan(result, start, list);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.createRef = function (text, minChar) {
            var id = new TypeScript.Identifier(text);
            id.minChar = minChar;
            return id;
        };

        SyntaxTreeToAstVisitor.prototype.convertComment = function (trivia, commentStartPosition, hasTrailingNewLine) {
            var comment = new TypeScript.Comment(trivia.fullText(), trivia.kind() === 6 /* MultiLineCommentTrivia */, hasTrailingNewLine);

            comment.minChar = commentStartPosition;
            comment.limChar = commentStartPosition + trivia.fullWidth();
            comment.minLine = this.lineMap.getLineNumberFromPosition(comment.minChar);
            comment.limLine = this.lineMap.getLineNumberFromPosition(comment.limChar);

            return comment;
        };

        SyntaxTreeToAstVisitor.prototype.convertComments = function (triviaList, commentStartPosition) {
            var result = [];

            for (var i = 0, n = triviaList.count(); i < n; i++) {
                var trivia = triviaList.syntaxTriviaAt(i);

                if (trivia.isComment()) {
                    var hasTrailingNewLine = ((i + 1) < n) && triviaList.syntaxTriviaAt(i + 1).isNewLine();
                    result.push(this.convertComment(trivia, commentStartPosition, hasTrailingNewLine));
                }

                commentStartPosition += trivia.fullWidth();
            }

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.mergeComments = function (comments1, comments2) {
            if (comments1 === null) {
                return comments2;
            }

            if (comments2 === null) {
                return comments1;
            }

            return comments1.concat(comments2);
        };

        SyntaxTreeToAstVisitor.prototype.convertTokenLeadingComments = function (token, commentStartPosition) {
            if (token === null) {
                return null;
            }

            var preComments = token.hasLeadingComment() ? this.convertComments(token.leadingTrivia(), commentStartPosition) : null;

            var previousTokenTrailingComments = this.previousTokenTrailingComments;
            this.previousTokenTrailingComments = null;

            return this.mergeComments(previousTokenTrailingComments, preComments);
        };

        SyntaxTreeToAstVisitor.prototype.convertTokenTrailingComments = function (token, commentStartPosition) {
            if (token === null || !token.hasTrailingComment() || token.hasTrailingNewLine()) {
                return null;
            }

            return this.convertComments(token.trailingTrivia(), commentStartPosition);
        };

        SyntaxTreeToAstVisitor.prototype.convertNodeLeadingComments = function (node, nodeStart) {
            return this.convertTokenLeadingComments(node.firstToken(), nodeStart);
        };

        SyntaxTreeToAstVisitor.prototype.convertNodeTrailingComments = function (node, nodeStart) {
            return this.convertTokenTrailingComments(node.lastToken(), nodeStart + node.leadingTriviaWidth() + node.width());
        };

        SyntaxTreeToAstVisitor.prototype.visitToken = function (token) {
            this.assertElementAtPosition(token);

            var result = this.getAST(token);
            var fullStart = this.position;

            if (result) {
                this.movePast(token);
            } else {
                if (token.kind() === 35 /* ThisKeyword */) {
                    result = new TypeScript.ThisExpression();
                } else if (token.kind() === 50 /* SuperKeyword */) {
                    result = new TypeScript.SuperExpression();
                } else if (token.kind() === 37 /* TrueKeyword */) {
                    result = new TypeScript.LiteralExpression(3 /* TrueLiteral */);
                } else if (token.kind() === 24 /* FalseKeyword */) {
                    result = new TypeScript.LiteralExpression(4 /* FalseLiteral */);
                } else if (token.kind() === 32 /* NullKeyword */) {
                    result = new TypeScript.LiteralExpression(8 /* NullLiteral */);
                } else if (token.kind() === 14 /* StringLiteral */) {
                    result = new TypeScript.StringLiteral(token.text(), token.valueText());
                } else if (token.kind() === 12 /* RegularExpressionLiteral */) {
                    result = new TypeScript.RegexLiteral(token.text());
                } else if (token.kind() === 13 /* NumericLiteral */) {
                    var preComments = this.convertTokenLeadingComments(token, fullStart);

                    var value = token.text().indexOf(".") > 0 ? parseFloat(token.text()) : parseInt(token.text());
                    result = new TypeScript.NumberLiteral(value, token.text());

                    result.preComments = preComments;
                } else {
                    result = this.identifierFromToken(token, false, true);
                }

                this.movePast(token);
            }

            var start = fullStart + token.leadingTriviaWidth();
            this.setAST(token, result);
            this.setSpanExplicit(result, start, start + token.width());
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.getLeadingComments = function (node) {
            var firstToken = node.firstToken();
            var result = [];

            if (firstToken.hasLeadingComment()) {
                var leadingTrivia = firstToken.leadingTrivia();

                for (var i = 0, n = leadingTrivia.count(); i < n; i++) {
                    var trivia = leadingTrivia.syntaxTriviaAt(i);

                    if (trivia.isComment()) {
                        result.push(trivia);
                    }
                }
            }

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.hasTopLevelImportOrExport = function (node) {
            var firstToken;

            for (var i = 0, n = node.moduleElements.childCount(); i < n; i++) {
                var moduleElement = node.moduleElements.childAt(i);

                firstToken = moduleElement.firstToken();
                if (firstToken !== null && firstToken.kind() === 47 /* ExportKeyword */) {
                    return true;
                }

                if (moduleElement.kind() === 133 /* ImportDeclaration */) {
                    var importDecl = moduleElement;
                    if (importDecl.moduleReference.kind() === 245 /* ExternalModuleReference */) {
                        return true;
                    }
                }
            }

            var leadingComments = this.getLeadingComments(node);
            for (var i = 0, n = leadingComments.length; i < n; i++) {
                var trivia = leadingComments[i];

                if (TypeScript.getImplicitImport(trivia.fullText())) {
                    return true;
                }
            }

            return false;
        };

        SyntaxTreeToAstVisitor.prototype.getAmdDependency = function (comment) {
            var amdDependencyRegEx = /^\/\/\/\s*<amd-dependency\s+path=('|")(.+?)\1/gim;
            var match = amdDependencyRegEx.exec(comment);
            return match ? match[2] : null;
        };

        SyntaxTreeToAstVisitor.prototype.visitSourceUnit = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var members;

            var bod = this.visitSyntaxList(node.moduleElements);

            var topLevelMod = null;
            if (this.hasTopLevelImportOrExport(node)) {
                var correctedFileName = TypeScript.switchToForwardSlashes(this.fileName);
                var id = new TypeScript.Identifier(correctedFileName);
                topLevelMod = new TypeScript.ModuleDeclaration(id, bod, null);
                this.setSpanExplicit(topLevelMod, start, this.position);

                topLevelMod.setModuleFlags(topLevelMod.getModuleFlags() | 512 /* IsDynamic */);
                topLevelMod.setModuleFlags(topLevelMod.getModuleFlags() | 256 /* IsWholeFile */);
                topLevelMod.setModuleFlags(topLevelMod.getModuleFlags() | 1 /* Exported */);

                if (this.isParsingDeclareFile) {
                    topLevelMod.setModuleFlags(topLevelMod.getModuleFlags() | 8 /* Ambient */);
                }

                topLevelMod.prettyName = TypeScript.getPrettyName(correctedFileName);

                var leadingComments = this.getLeadingComments(node);
                for (var i = 0, n = leadingComments.length; i < n; i++) {
                    var trivia = leadingComments[i];
                    var amdDependency = this.getAmdDependency(trivia.fullText());
                    if (amdDependency) {
                        topLevelMod.amdDependencies.push(amdDependency);
                    }
                }

                bod = new TypeScript.ASTList();
                this.setSpanExplicit(bod, start, this.position);
                bod.append(topLevelMod);
            }

            var result = new TypeScript.Script();
            this.setSpanExplicit(result, start, start + node.fullWidth());

            result.moduleElements = bod;
            result.topLevelMod = topLevelMod;
            result.isDeclareFile = this.isParsingDeclareFile;
            result.requiresExtendsBlock = this.requiresExtendsBlock;

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitExternalModuleReference = function (node) {
            this.assertElementAtPosition(node);
            this.moveTo(node, node.stringLiteral);
            var result = this.identifierFromToken(node.stringLiteral, false, false);
            this.movePast(node.stringLiteral);
            this.movePast(node.closeParenToken);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitModuleNameModuleReference = function (node) {
            this.assertElementAtPosition(node);
            return node.moduleName.accept(this);
        };

        SyntaxTreeToAstVisitor.prototype.visitClassDeclaration = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var preComments = this.convertNodeLeadingComments(node, start);
                var postComments = this.convertNodeTrailingComments(node, start);
                this.moveTo(node, node.identifier);
                var name = this.identifierFromToken(node.identifier, false, true);
                this.movePast(node.identifier);

                var typeParameters = node.typeParameterList === null ? null : node.typeParameterList.accept(this);
                var extendsList = new TypeScript.ASTList();
                var implementsList = new TypeScript.ASTList();

                for (var i = 0, n = node.heritageClauses.childCount(); i < n; i++) {
                    var heritageClause = node.heritageClauses.childAt(i);
                    if (heritageClause.extendsOrImplementsKeyword.tokenKind === 48 /* ExtendsKeyword */) {
                        extendsList = heritageClause.accept(this);
                    } else {
                        TypeScript.Debug.assert(heritageClause.extendsOrImplementsKeyword.tokenKind === 51 /* ImplementsKeyword */);
                        implementsList = heritageClause.accept(this);
                    }
                }

                this.movePast(node.openBraceToken);
                var members = this.visitSyntaxList(node.classElements);
                var closeBracePosition = this.position;
                this.movePast(node.closeBraceToken);
                var closeBraceSpan = new TypeScript.ASTSpan();
                this.setSpan(closeBraceSpan, closeBracePosition, node.closeBraceToken);

                result = new TypeScript.ClassDeclaration(name, typeParameters, members, extendsList, implementsList);
                result.endingToken = closeBraceSpan;

                result.preComments = preComments;
                result.postComments = postComments;

                for (var i = 0; i < members.members.length; i++) {
                    var member = members.members[i];
                    if (member.nodeType === 12 /* FunctionDeclaration */) {
                        var funcDecl = member;

                        if (funcDecl.isConstructor) {
                            funcDecl.classDecl = result;

                            result.constructorDecl = funcDecl;
                        }
                    }
                }
            }

            this.requiresExtendsBlock = this.requiresExtendsBlock || result.extendsList.members.length > 0;

            if (!this.containingModuleHasExportAssignment && (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 47 /* ExportKeyword */) || this.isParsingAmbientModule)) {
                result.setVarFlags(result.getVarFlags() | 1 /* Exported */);
            } else {
                result.setVarFlags(result.getVarFlags() & ~1 /* Exported */);
            }

            if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 64 /* DeclareKeyword */) || this.isParsingAmbientModule || this.isParsingDeclareFile) {
                result.setVarFlags(result.getVarFlags() | 8 /* Ambient */);
            } else {
                result.setVarFlags(result.getVarFlags() & ~8 /* Ambient */);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitInterfaceDeclaration = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var preComments = this.convertNodeLeadingComments(node, start);
                var postComments = this.convertNodeTrailingComments(node, start);
                this.moveTo(node, node.identifier);
                var name = this.identifierFromToken(node.identifier, false, true);
                this.movePast(node.identifier);
                var typeParameters = node.typeParameterList === null ? null : node.typeParameterList.accept(this);

                var extendsList = null;

                for (var i = 0, n = node.heritageClauses.childCount(); i < n; i++) {
                    var heritageClause = node.heritageClauses.childAt(i);
                    if (i === 0) {
                        extendsList = heritageClause.accept(this);
                    } else {
                        this.movePast(heritageClause);
                    }
                }

                this.movePast(node.body.openBraceToken);
                var members = this.visitSeparatedSyntaxList(node.body.typeMembers);

                this.movePast(node.body.closeBraceToken);

                result = new TypeScript.InterfaceDeclaration(name, typeParameters, members, extendsList, null);

                result.preComments = preComments;
                result.postComments = postComments;
            }

            if (!this.containingModuleHasExportAssignment && (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 47 /* ExportKeyword */) || this.isParsingAmbientModule)) {
                result.setVarFlags(result.getVarFlags() | 1 /* Exported */);
            } else {
                result.setVarFlags(result.getVarFlags() & ~1 /* Exported */);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitHeritageClause = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                result = new TypeScript.ASTList();

                this.movePast(node.extendsOrImplementsKeyword);
                for (var i = 0, n = node.typeNames.childCount(); i < n; i++) {
                    if (i % 2 === 1) {
                        this.movePast(node.typeNames.childAt(i));
                    } else {
                        var type = this.visitType(node.typeNames.childAt(i)).term;
                        result.append(type);
                    }
                }
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.getModuleNames = function (node) {
            var result = [];

            if (node.stringLiteral !== null) {
                result.push(this.identifierFromToken(node.stringLiteral, false, false));
                this.movePast(node.stringLiteral);
            } else {
                this.getModuleNamesHelper(node.moduleName, result);
            }

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.getModuleNamesHelper = function (name, result) {
            this.assertElementAtPosition(name);

            if (name.kind() === 122 /* QualifiedName */) {
                var qualifiedName = name;
                this.getModuleNamesHelper(qualifiedName.left, result);
                this.movePast(qualifiedName.dotToken);
                result.push(this.identifierFromToken(qualifiedName.right, false, false));
                this.movePast(qualifiedName.right);
            } else {
                result.push(this.identifierFromToken(name, false, false));
                this.movePast(name);
            }
        };

        SyntaxTreeToAstVisitor.prototype.visitModuleDeclaration = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var preComments = this.convertNodeLeadingComments(node, start);
                var postComments = this.convertNodeTrailingComments(node, start);

                this.moveTo(node, node.moduleKeyword);
                this.movePast(node.moduleKeyword);
                var names = this.getModuleNames(node);
                this.movePast(node.openBraceToken);

                var savedIsParsingAmbientModule = this.isParsingAmbientModule;
                if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 64 /* DeclareKeyword */) || this.isParsingDeclareFile) {
                    this.isParsingAmbientModule = true;
                }

                var savedContainingModuleHasExportAssignment = this.containingModuleHasExportAssignment;
                this.containingModuleHasExportAssignment = TypeScript.ArrayUtilities.any(node.moduleElements.toArray(), function (m) {
                    return m.kind() === 134 /* ExportAssignment */;
                });

                var members = this.visitSyntaxList(node.moduleElements);

                this.isParsingAmbientModule = savedIsParsingAmbientModule;
                this.containingModuleHasExportAssignment = savedContainingModuleHasExportAssignment;

                var closeBracePosition = this.position;
                this.movePast(node.closeBraceToken);
                var closeBraceSpan = new TypeScript.ASTSpan();
                this.setSpan(closeBraceSpan, closeBracePosition, node.closeBraceToken);

                for (var i = names.length - 1; i >= 0; i--) {
                    var innerName = names[i];

                    result = new TypeScript.ModuleDeclaration(innerName, members, closeBraceSpan);
                    this.setSpan(result, start, node);

                    result.preComments = preComments;
                    result.postComments = postComments;

                    preComments = null;
                    postComments = null;

                    if (i) {
                        result.setModuleFlags(result.getModuleFlags() | 1 /* Exported */);
                    } else if (!this.containingModuleHasExportAssignment && (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 47 /* ExportKeyword */) || this.isParsingAmbientModule)) {
                        result.setModuleFlags(result.getModuleFlags() | 1 /* Exported */);
                    }

                    members = new TypeScript.ASTList();
                    members.append(result);
                }
            }

            if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 64 /* DeclareKeyword */) || this.isParsingAmbientModule || this.isParsingDeclareFile) {
                result.setModuleFlags(result.getModuleFlags() | 8 /* Ambient */);
            } else {
                result.setModuleFlags(result.getModuleFlags() & ~8 /* Ambient */);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.hasDotDotDotParameter = function (parameters) {
            for (var i = 0, n = parameters.nonSeparatorCount(); i < n; i++) {
                if ((parameters.nonSeparatorAt(i)).dotDotDotToken) {
                    return true;
                }
            }

            return false;
        };

        SyntaxTreeToAstVisitor.prototype.visitFunctionDeclaration = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var preComments = this.convertNodeLeadingComments(node, start);
                var postComments = this.convertNodeTrailingComments(node, start);

                this.moveTo(node, node.identifier);
                var name = this.identifierFromToken(node.identifier, false, true);

                this.movePast(node.identifier);

                var typeParameters = node.callSignature.typeParameterList === null ? null : node.callSignature.typeParameterList.accept(this);
                var parameters = node.callSignature.parameterList.accept(this);

                var returnType = node.callSignature.typeAnnotation ? node.callSignature.typeAnnotation.accept(this) : null;

                var block = node.block ? node.block.accept(this) : null;

                this.movePast(node.semicolonToken);

                result = new TypeScript.FunctionDeclaration(name, block, false, typeParameters, parameters, 12 /* FunctionDeclaration */);

                result.preComments = preComments;
                result.postComments = postComments;
                result.variableArgList = this.hasDotDotDotParameter(node.callSignature.parameterList.parameters);
                result.returnTypeAnnotation = returnType;

                if (node.semicolonToken) {
                    result.setFunctionFlags(result.getFunctionFlags() | 128 /* Signature */);
                }
            }

            if (!this.containingModuleHasExportAssignment && (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 47 /* ExportKeyword */) || this.isParsingAmbientModule)) {
                result.setFunctionFlags(result.getFunctionFlags() | 1 /* Exported */);
            } else {
                result.setFunctionFlags(result.getFunctionFlags() & ~1 /* Exported */);
            }

            if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 64 /* DeclareKeyword */) || this.isParsingAmbientModule || this.isParsingDeclareFile) {
                result.setFunctionFlags(result.getFunctionFlags() | 8 /* Ambient */);
            } else {
                result.setFunctionFlags(result.getFunctionFlags() & ~8 /* Ambient */);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitEnumDeclaration = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;

            var preComments = this.convertNodeLeadingComments(node, start);
            var postComments = this.convertNodeTrailingComments(node, start);

            this.moveTo(node, node.identifier);
            var name = this.identifierFromToken(node.identifier, false, true);
            this.movePast(node.identifier);

            this.movePast(node.openBraceToken);
            var members = new TypeScript.ASTList();

            var lastValue = null;
            var memberNames = [];
            var memberName;

            for (var i = 0, n = node.enumElements.childCount(); i < n; i++) {
                if (i % 2 === 1) {
                    this.movePast(node.enumElements.childAt(i));
                } else {
                    var enumElement = node.enumElements.childAt(i);

                    var memberValue = null;

                    memberName = this.identifierFromToken(enumElement.propertyName, false, true);
                    this.movePast(enumElement.propertyName);

                    if (enumElement.equalsValueClause !== null) {
                        memberValue = enumElement.equalsValueClause.accept(this);
                        lastValue = null;
                    }

                    var memberStart = this.position;

                    if (memberValue === null) {
                        if (lastValue === null) {
                            memberValue = new TypeScript.NumberLiteral(0, "0");
                            lastValue = memberValue;
                        } else {
                            var nextValue = lastValue.value + 1;
                            memberValue = new TypeScript.NumberLiteral(nextValue, nextValue.toString());
                            lastValue = memberValue;
                        }
                    }

                    var declarator = new TypeScript.VariableDeclarator(memberName);
                    declarator.init = memberValue;
                    declarator.isImplicitlyInitialized = enumElement.equalsValueClause === null;

                    declarator.typeExpr = new TypeScript.TypeReference(this.createRef(name.actualText, -1), 0);
                    declarator.setVarFlags(declarator.getVarFlags() | 256 /* Property */);
                    this.setSpanExplicit(declarator, memberStart, this.position);

                    if (memberValue.nodeType === 7 /* NumericLiteral */) {
                        declarator.setVarFlags(declarator.getVarFlags() | 4096 /* Constant */);
                    } else if (memberValue.nodeType === 69 /* LeftShiftExpression */) {
                        var binop = memberValue;
                        if (binop.operand1.nodeType === 7 /* NumericLiteral */ && binop.operand2.nodeType === 7 /* NumericLiteral */) {
                            declarator.setVarFlags(declarator.getVarFlags() | 4096 /* Constant */);
                        }
                    } else if (memberValue.nodeType === 20 /* Name */) {
                        var nameNode = memberValue;
                        for (var j = 0; j < memberNames.length; j++) {
                            memberName = memberNames[j];
                            if (memberName.text === nameNode.text) {
                                declarator.setVarFlags(declarator.getVarFlags() | 4096 /* Constant */);
                                break;
                            }
                        }
                    }

                    var declarators = new TypeScript.ASTList();
                    declarators.append(declarator);
                    var declaration = new TypeScript.VariableDeclaration(declarators);
                    this.setSpanExplicit(declaration, memberStart, this.position);

                    var statement = new TypeScript.VariableStatement(declaration);
                    statement.setFlags(16 /* EnumElement */);
                    this.setSpanExplicit(statement, memberStart, this.position);

                    members.append(statement);
                    memberNames.push(memberName);

                    declarator.setVarFlags(declarator.getVarFlags() | 1 /* Exported */);
                }
            }

            var closeBracePosition = this.position;
            this.movePast(node.closeBraceToken);
            var closeBraceSpan = new TypeScript.ASTSpan();
            this.setSpan(closeBraceSpan, closeBracePosition, node.closeBraceToken);

            var modDecl = new TypeScript.ModuleDeclaration(name, members, closeBraceSpan);
            this.setSpan(modDecl, start, node);

            modDecl.preComments = preComments;
            modDecl.postComments = postComments;
            modDecl.setModuleFlags(modDecl.getModuleFlags() | 128 /* IsEnum */);

            if (!this.containingModuleHasExportAssignment && (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 47 /* ExportKeyword */) || this.isParsingAmbientModule)) {
                modDecl.setModuleFlags(modDecl.getModuleFlags() | 1 /* Exported */);
            }

            return modDecl;
        };

        SyntaxTreeToAstVisitor.prototype.visitEnumElement = function (node) {
            throw TypeScript.Errors.invalidOperation();
        };

        SyntaxTreeToAstVisitor.prototype.visitImportDeclaration = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var preComments = this.convertNodeLeadingComments(node, start);
                var postComments = this.convertNodeTrailingComments(node, start);

                this.moveTo(node, node.identifier);
                var name = this.identifierFromToken(node.identifier, false, true);
                this.movePast(node.identifier);
                this.movePast(node.equalsToken);
                var alias = node.moduleReference.accept(this);
                this.movePast(node.semicolonToken);

                result = new TypeScript.ImportDeclaration(name, alias);

                result.preComments = preComments;
                result.postComments = postComments;
                result.isDynamicImport = node.moduleReference.kind() === 245 /* ExternalModuleReference */;
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitExportAssignment = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.moveTo(node, node.identifier);
                var name = this.identifierFromToken(node.identifier, false, true);
                this.movePast(node.identifier);
                this.movePast(node.semicolonToken);

                result = new TypeScript.ExportAssignment(name);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitVariableStatement = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;

            var preComments = null;
            if (node.modifiers.childCount() > 0) {
                preComments = this.convertTokenLeadingComments(node.modifiers.firstToken(), start);
            }

            this.moveTo(node, node.variableDeclaration);

            var declaration = node.variableDeclaration.accept(this);
            this.movePast(node.semicolonToken);

            for (var i = 0, n = declaration.declarators.members.length; i < n; i++) {
                var varDecl = declaration.declarators.members[i];

                if (i === 0) {
                    varDecl.preComments = this.mergeComments(preComments, varDecl.preComments);
                }

                if (!this.containingModuleHasExportAssignment && (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 47 /* ExportKeyword */) || this.isParsingAmbientModule)) {
                    varDecl.setVarFlags(varDecl.getVarFlags() | 1 /* Exported */);
                } else {
                    varDecl.setVarFlags(varDecl.getVarFlags() & ~1 /* Exported */);
                }

                if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 64 /* DeclareKeyword */) || this.isParsingAmbientModule || this.isParsingDeclareFile) {
                    varDecl.setVarFlags(varDecl.getVarFlags() | 8 /* Ambient */);
                } else {
                    varDecl.setVarFlags(varDecl.getVarFlags() & ~8 /* Ambient */);
                }
            }

            var result = new TypeScript.VariableStatement(declaration);

            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitVariableDeclaration = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;

            var preComments = this.convertNodeLeadingComments(node, start);
            var postComments = this.convertNodeTrailingComments(node, start);

            this.moveTo(node, node.variableDeclarators);
            var variableDecls = this.visitSeparatedSyntaxList(node.variableDeclarators);

            for (var i = 0; i < variableDecls.members.length; i++) {
                if (i === 0) {
                    variableDecls.members[i].preComments = preComments;
                    variableDecls.members[i].postComments = postComments;
                }
            }

            var result = new TypeScript.VariableDeclaration(variableDecls);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitVariableDeclarator = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var name = this.identifierFromToken(node.identifier, false, true);
            this.movePast(node.identifier);
            var typeExpr = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;
            var init = node.equalsValueClause ? node.equalsValueClause.accept(this) : null;

            var result = new TypeScript.VariableDeclarator(name);
            this.setSpan(result, start, node);

            result.typeExpr = typeExpr;
            result.init = init;
            if (init && init.nodeType === 12 /* FunctionDeclaration */) {
                var funcDecl = init;
                funcDecl.hint = name.actualText;
            }

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitEqualsValueClause = function (node) {
            this.assertElementAtPosition(node);

            this.previousTokenTrailingComments = this.convertTokenTrailingComments(node.equalsToken, this.position + node.equalsToken.leadingTriviaWidth() + node.equalsToken.width());

            this.movePast(node.equalsToken);
            var result = node.value.accept(this);

            this.previousTokenTrailingComments = null;
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.getUnaryExpressionNodeType = function (kind) {
            switch (kind) {
                case 163 /* PlusExpression */:
                    return 26 /* PlusExpression */;
                case 164 /* NegateExpression */:
                    return 27 /* NegateExpression */;
                case 165 /* BitwiseNotExpression */:
                    return 72 /* BitwiseNotExpression */;
                case 166 /* LogicalNotExpression */:
                    return 73 /* LogicalNotExpression */;
                case 167 /* PreIncrementExpression */:
                    return 74 /* PreIncrementExpression */;
                case 168 /* PreDecrementExpression */:
                    return 75 /* PreDecrementExpression */;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        SyntaxTreeToAstVisitor.prototype.visitPrefixUnaryExpression = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.operatorToken);
                var operand = node.operand.accept(this);

                result = new TypeScript.UnaryExpression(this.getUnaryExpressionNodeType(node.kind()), operand);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.isOnSingleLine = function (start, end) {
            return this.lineMap.getLineNumberFromPosition(start) === this.lineMap.getLineNumberFromPosition(end);
        };

        SyntaxTreeToAstVisitor.prototype.visitArrayLiteralExpression = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var openStart = this.position + node.openBracketToken.leadingTriviaWidth();
                this.movePast(node.openBracketToken);

                var expressions = this.visitSeparatedSyntaxList(node.expressions);

                var closeStart = this.position + node.closeBracketToken.leadingTriviaWidth();
                this.movePast(node.closeBracketToken);

                TypeScript.Debug.assert(expressions !== null);
                result = new TypeScript.UnaryExpression(21 /* ArrayLiteralExpression */, expressions);

                if (this.isOnSingleLine(openStart, closeStart)) {
                    result.setFlags(result.getFlags() | 2 /* SingleLine */);
                }
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitOmittedExpression = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                result = new TypeScript.OmittedExpression();
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitParenthesizedExpression = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.openParenToken);
                var expr = node.expression.accept(this);
                this.movePast(node.closeParenToken);

                result = new TypeScript.ParenthesizedExpression(expr);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.getArrowFunctionStatements = function (body) {
            if (body.kind() === 145 /* Block */) {
                return body.accept(this);
            } else {
                var statements = new TypeScript.ASTList();
                var expression = body.accept(this);
                var returnStatement = new TypeScript.ReturnStatement(expression);

                returnStatement.preComments = expression.preComments;
                expression.preComments = null;

                statements.append(returnStatement);
                var block = new TypeScript.Block(statements);
                block.closeBraceSpan = statements.members[0];
                return block;
            }
        };

        SyntaxTreeToAstVisitor.prototype.visitSimpleArrowFunctionExpression = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var identifier = this.identifierFromToken(node.identifier, false, true);
                this.movePast(node.identifier);
                this.movePast(node.equalsGreaterThanToken);

                var parameters = new TypeScript.ASTList();

                var parameter = new TypeScript.Parameter(identifier);
                this.setSpanExplicit(parameter, identifier.minChar, identifier.limChar);

                parameters.append(parameter);

                var statements = this.getArrowFunctionStatements(node.body);

                result = new TypeScript.FunctionDeclaration(null, statements, false, null, parameters, 12 /* FunctionDeclaration */);

                result.returnTypeAnnotation = null;
                result.setFunctionFlags(result.getFunctionFlags() | 8192 /* IsFunctionExpression */);
                result.setFunctionFlags(result.getFunctionFlags() | 2048 /* IsFatArrowFunction */);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitParenthesizedArrowFunctionExpression = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var preComments = this.convertNodeLeadingComments(node, start);

                var typeParameters = node.callSignature.typeParameterList === null ? null : node.callSignature.typeParameterList.accept(this);
                var parameters = node.callSignature.parameterList.accept(this);
                var returnType = node.callSignature.typeAnnotation ? node.callSignature.typeAnnotation.accept(this) : null;
                this.movePast(node.equalsGreaterThanToken);

                var block = this.getArrowFunctionStatements(node.body);

                result = new TypeScript.FunctionDeclaration(null, block, false, typeParameters, parameters, 12 /* FunctionDeclaration */);

                result.preComments = preComments;
                result.returnTypeAnnotation = returnType;
                result.setFunctionFlags(result.getFunctionFlags() | 8192 /* IsFunctionExpression */);
                result.setFunctionFlags(result.getFunctionFlags() | 2048 /* IsFatArrowFunction */);
                result.variableArgList = this.hasDotDotDotParameter(node.callSignature.parameterList.parameters);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitType = function (type) {
            this.assertElementAtPosition(type);

            var result;
            if (type.isToken()) {
                var start = this.position;
                result = new TypeScript.TypeReference(type.accept(this), 0);
                this.setSpan(result, start, type);
            } else {
                result = type.accept(this);
            }

            TypeScript.Debug.assert(result.nodeType === 11 /* TypeRef */);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitQualifiedName = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var left = this.visitType(node.left).term;
                this.movePast(node.dotToken);
                var right = this.identifierFromToken(node.right, false, true);
                this.movePast(node.right);

                var term = new TypeScript.BinaryExpression(32 /* MemberAccessExpression */, left, right);
                this.setSpan(term, start, node);

                result = new TypeScript.TypeReference(term, 0);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitTypeArgumentList = function (node) {
            this.assertElementAtPosition(node);

            var result = new TypeScript.ASTList();

            this.movePast(node.lessThanToken);

            var start = this.position;

            for (var i = 0, n = node.typeArguments.childCount(); i < n; i++) {
                if (i % 2 === 1) {
                    this.movePast(node.typeArguments.childAt(i));
                } else {
                    result.append(this.visitType(node.typeArguments.childAt(i)));
                }
            }
            this.movePast(node.greaterThanToken);

            this.setSpan(result, start, node.typeArguments);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitConstructorType = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.newKeyword);
                var typeParameters = node.typeParameterList === null ? null : node.typeParameterList.accept(this);
                var parameters = node.parameterList.accept(this);
                this.movePast(node.equalsGreaterThanToken);
                var returnType = node.type ? this.visitType(node.type) : null;

                var funcDecl = new TypeScript.FunctionDeclaration(null, null, false, typeParameters, parameters, 12 /* FunctionDeclaration */);
                this.setSpan(funcDecl, start, node);

                funcDecl.returnTypeAnnotation = returnType;
                funcDecl.setFunctionFlags(funcDecl.getFunctionFlags() | 128 /* Signature */);
                funcDecl.variableArgList = this.hasDotDotDotParameter(node.parameterList.parameters);

                funcDecl.setFunctionFlags(funcDecl.getFunctionFlags() | 1024 /* ConstructMember */);
                funcDecl.setFlags(funcDecl.getFlags() | 8 /* TypeReference */);
                funcDecl.hint = "_construct";
                funcDecl.classDecl = null;

                result = new TypeScript.TypeReference(funcDecl, 0);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitFunctionType = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var typeParameters = node.typeParameterList === null ? null : node.typeParameterList.accept(this);
                var parameters = node.parameterList.accept(this);
                this.movePast(node.equalsGreaterThanToken);
                var returnType = node.type ? this.visitType(node.type) : null;

                var funcDecl = new TypeScript.FunctionDeclaration(null, null, false, typeParameters, parameters, 12 /* FunctionDeclaration */);
                this.setSpan(funcDecl, start, node);

                funcDecl.returnTypeAnnotation = returnType;

                funcDecl.setFlags(funcDecl.getFunctionFlags() | 128 /* Signature */);
                funcDecl.setFlags(funcDecl.getFlags() | 8 /* TypeReference */);
                funcDecl.variableArgList = this.hasDotDotDotParameter(node.parameterList.parameters);

                result = new TypeScript.TypeReference(funcDecl, 0);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitObjectType = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.openBraceToken);
                var typeMembers = this.visitSeparatedSyntaxList(node.typeMembers);
                this.movePast(node.closeBraceToken);

                var interfaceDecl = new TypeScript.InterfaceDeclaration(new TypeScript.Identifier("__anonymous"), null, typeMembers, null, null);
                this.setSpan(interfaceDecl, start, node);

                interfaceDecl.setFlags(interfaceDecl.getFlags() | 8 /* TypeReference */);

                result = new TypeScript.TypeReference(interfaceDecl, 0);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitArrayType = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var underlying = this.visitType(node.type);
                this.movePast(node.openBracketToken);
                this.movePast(node.closeBracketToken);

                if (underlying.nodeType === 11 /* TypeRef */) {
                    result = underlying;
                    result.arrayCount++;
                } else {
                    result = new TypeScript.TypeReference(underlying, 1);
                }

                result.setFlags(result.getFlags() | 8 /* TypeReference */);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitGenericType = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var underlying = this.visitType(node.name).term;
                var typeArguments = node.typeArgumentList.accept(this);

                var genericType = new TypeScript.GenericType(underlying, typeArguments);
                this.setSpan(genericType, start, node);

                genericType.setFlags(genericType.getFlags() | 8 /* TypeReference */);

                result = new TypeScript.TypeReference(genericType, 0);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitTypeAnnotation = function (node) {
            this.assertElementAtPosition(node);

            this.movePast(node.colonToken);
            return this.visitType(node.type);
        };

        SyntaxTreeToAstVisitor.prototype.visitBlock = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.openBraceToken);
                var statements = this.visitSyntaxList(node.statements);
                var closeBracePosition = this.position;
                this.movePast(node.closeBraceToken);
                var closeBraceSpan = new TypeScript.ASTSpan();
                this.setSpan(closeBraceSpan, closeBracePosition, node.closeBraceToken);

                result = new TypeScript.Block(statements);
                result.closeBraceSpan = closeBraceSpan;
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitParameter = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var preComments = this.convertNodeLeadingComments(node, start);
                var postComments = this.convertNodeTrailingComments(node, start);

                this.moveTo(node, node.identifier);
                var identifier = this.identifierFromToken(node.identifier, !!node.questionToken, true);
                this.movePast(node.identifier);
                this.movePast(node.questionToken);
                var typeExpr = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;
                var init = node.equalsValueClause ? node.equalsValueClause.accept(this) : null;

                result = new TypeScript.Parameter(identifier);

                result.preComments = preComments;
                result.postComments = postComments;
                result.isOptional = !!node.questionToken;
                result.init = init;
                result.typeExpr = typeExpr;

                if (node.publicOrPrivateKeyword) {
                    result.setVarFlags(result.getVarFlags() | 256 /* Property */);

                    if (node.publicOrPrivateKeyword.kind() === 57 /* PublicKeyword */) {
                        result.setVarFlags(result.getVarFlags() | 4 /* Public */);
                    } else {
                        result.setVarFlags(result.getVarFlags() | 2 /* Private */);
                    }
                }

                if (node.equalsValueClause || node.dotDotDotToken) {
                    result.setFlags(result.getFlags() | 4 /* OptionalName */);
                }
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitMemberAccessExpression = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var expression = node.expression.accept(this);
                this.movePast(node.dotToken);
                var name = this.identifierFromToken(node.name, false, true);
                this.movePast(node.name);

                result = new TypeScript.BinaryExpression(32 /* MemberAccessExpression */, expression, name);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitPostfixUnaryExpression = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var operand = node.operand.accept(this);
                this.movePast(node.operatorToken);

                result = new TypeScript.UnaryExpression(node.kind() === 209 /* PostIncrementExpression */ ? 76 /* PostIncrementExpression */ : 77 /* PostDecrementExpression */, operand);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitElementAccessExpression = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var expression = node.expression.accept(this);
                this.movePast(node.openBracketToken);
                var argumentExpression = node.argumentExpression.accept(this);
                this.movePast(node.closeBracketToken);

                result = new TypeScript.BinaryExpression(35 /* ElementAccessExpression */, expression, argumentExpression);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.convertArgumentListArguments = function (node) {
            if (node === null) {
                return null;
            }

            var start = this.position;

            this.movePast(node.openParenToken);

            var result = this.visitSeparatedSyntaxList(node.arguments);

            if (node.arguments.fullWidth() === 0 && node.closeParenToken.fullWidth() === 0) {
                var openParenTokenEnd = start + node.openParenToken.leadingTriviaWidth() + node.openParenToken.width();
                this.setSpanExplicit(result, openParenTokenEnd, openParenTokenEnd + node.openParenToken.trailingTriviaWidth());
            }

            this.movePast(node.closeParenToken);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitInvocationExpression = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var expression = node.expression.accept(this);
                var typeArguments = node.argumentList.typeArgumentList !== null ? node.argumentList.typeArgumentList.accept(this) : null;
                var argumentList = this.convertArgumentListArguments(node.argumentList);

                result = new TypeScript.CallExpression(36 /* InvocationExpression */, expression, typeArguments, argumentList);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitArgumentList = function (node) {
            throw TypeScript.Errors.invalidOperation();
        };

        SyntaxTreeToAstVisitor.prototype.getBinaryExpressionNodeType = function (node) {
            switch (node.kind()) {
                case 172 /* CommaExpression */:
                    return 25 /* CommaExpression */;
                case 173 /* AssignmentExpression */:
                    return 38 /* AssignmentExpression */;
                case 174 /* AddAssignmentExpression */:
                    return 39 /* AddAssignmentExpression */;
                case 175 /* SubtractAssignmentExpression */:
                    return 40 /* SubtractAssignmentExpression */;
                case 176 /* MultiplyAssignmentExpression */:
                    return 42 /* MultiplyAssignmentExpression */;
                case 177 /* DivideAssignmentExpression */:
                    return 41 /* DivideAssignmentExpression */;
                case 178 /* ModuloAssignmentExpression */:
                    return 43 /* ModuloAssignmentExpression */;
                case 179 /* AndAssignmentExpression */:
                    return 44 /* AndAssignmentExpression */;
                case 180 /* ExclusiveOrAssignmentExpression */:
                    return 45 /* ExclusiveOrAssignmentExpression */;
                case 181 /* OrAssignmentExpression */:
                    return 46 /* OrAssignmentExpression */;
                case 182 /* LeftShiftAssignmentExpression */:
                    return 47 /* LeftShiftAssignmentExpression */;
                case 183 /* SignedRightShiftAssignmentExpression */:
                    return 48 /* SignedRightShiftAssignmentExpression */;
                case 184 /* UnsignedRightShiftAssignmentExpression */:
                    return 49 /* UnsignedRightShiftAssignmentExpression */;
                case 186 /* LogicalOrExpression */:
                    return 51 /* LogicalOrExpression */;
                case 187 /* LogicalAndExpression */:
                    return 52 /* LogicalAndExpression */;
                case 188 /* BitwiseOrExpression */:
                    return 53 /* BitwiseOrExpression */;
                case 189 /* BitwiseExclusiveOrExpression */:
                    return 54 /* BitwiseExclusiveOrExpression */;
                case 190 /* BitwiseAndExpression */:
                    return 55 /* BitwiseAndExpression */;
                case 191 /* EqualsWithTypeConversionExpression */:
                    return 56 /* EqualsWithTypeConversionExpression */;
                case 192 /* NotEqualsWithTypeConversionExpression */:
                    return 57 /* NotEqualsWithTypeConversionExpression */;
                case 193 /* EqualsExpression */:
                    return 58 /* EqualsExpression */;
                case 194 /* NotEqualsExpression */:
                    return 59 /* NotEqualsExpression */;
                case 195 /* LessThanExpression */:
                    return 60 /* LessThanExpression */;
                case 196 /* GreaterThanExpression */:
                    return 62 /* GreaterThanExpression */;
                case 197 /* LessThanOrEqualExpression */:
                    return 61 /* LessThanOrEqualExpression */;
                case 198 /* GreaterThanOrEqualExpression */:
                    return 63 /* GreaterThanOrEqualExpression */;
                case 199 /* InstanceOfExpression */:
                    return 33 /* InstanceOfExpression */;
                case 200 /* InExpression */:
                    return 31 /* InExpression */;
                case 201 /* LeftShiftExpression */:
                    return 69 /* LeftShiftExpression */;
                case 202 /* SignedRightShiftExpression */:
                    return 70 /* SignedRightShiftExpression */;
                case 203 /* UnsignedRightShiftExpression */:
                    return 71 /* UnsignedRightShiftExpression */;
                case 204 /* MultiplyExpression */:
                    return 66 /* MultiplyExpression */;
                case 205 /* DivideExpression */:
                    return 67 /* DivideExpression */;
                case 206 /* ModuloExpression */:
                    return 68 /* ModuloExpression */;
                case 207 /* AddExpression */:
                    return 64 /* AddExpression */;
                case 208 /* SubtractExpression */:
                    return 65 /* SubtractExpression */;
            }

            throw TypeScript.Errors.invalidOperation();
        };

        SyntaxTreeToAstVisitor.prototype.visitBinaryExpression = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var nodeType = this.getBinaryExpressionNodeType(node);
                var left = node.left.accept(this);
                this.movePast(node.operatorToken);
                var right = node.right.accept(this);

                result = new TypeScript.BinaryExpression(nodeType, left, right);

                if (right.nodeType === 12 /* FunctionDeclaration */) {
                    var id = left.nodeType === 32 /* MemberAccessExpression */ ? (left).operand2 : left;
                    var idHint = id.nodeType === 20 /* Name */ ? id.actualText : null;

                    var funcDecl = right;
                    funcDecl.hint = idHint;
                }
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitConditionalExpression = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var condition = node.condition.accept(this);
                this.movePast(node.questionToken);
                var whenTrue = node.whenTrue.accept(this);
                this.movePast(node.colonToken);
                var whenFalse = node.whenFalse.accept(this);

                result = new TypeScript.ConditionalExpression(condition, whenTrue, whenFalse);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitConstructSignature = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var preComments = this.convertNodeLeadingComments(node, start);

                this.movePast(node.newKeyword);
                var typeParameters = node.callSignature.typeParameterList === null ? null : node.callSignature.typeParameterList.accept(this);
                var parameters = node.callSignature.parameterList.accept(this);
                var returnType = node.callSignature.typeAnnotation ? node.callSignature.typeAnnotation.accept(this) : null;

                result = new TypeScript.FunctionDeclaration(null, null, false, typeParameters, parameters, 12 /* FunctionDeclaration */);

                result.preComments = preComments;
                result.returnTypeAnnotation = returnType;

                result.hint = "_construct";
                result.setFunctionFlags(result.getFunctionFlags() | 1024 /* ConstructMember */);
                result.setFunctionFlags(result.getFunctionFlags() | 256 /* Method */);
                result.setFunctionFlags(result.getFunctionFlags() | 128 /* Signature */);
                result.variableArgList = this.hasDotDotDotParameter(node.callSignature.parameterList.parameters);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitMethodSignature = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var preComments = this.convertNodeLeadingComments(node, start);

                var name = this.identifierFromToken(node.propertyName, !!node.questionToken, true);
                this.movePast(node.propertyName);
                this.movePast(node.questionToken);

                var typeParameters = node.callSignature.typeParameterList ? node.callSignature.typeParameterList.accept(this) : null;
                var parameters = node.callSignature.parameterList.accept(this);
                var returnType = node.callSignature.typeAnnotation ? node.callSignature.typeAnnotation.accept(this) : null;

                result = new TypeScript.FunctionDeclaration(name, null, false, typeParameters, parameters, 12 /* FunctionDeclaration */);

                result.preComments = preComments;
                result.variableArgList = this.hasDotDotDotParameter(node.callSignature.parameterList.parameters);
                result.returnTypeAnnotation = returnType;
                result.setFunctionFlags(result.getFunctionFlags() | 256 /* Method */);
                result.setFunctionFlags(result.getFunctionFlags() | 128 /* Signature */);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitIndexSignature = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var preComments = this.convertNodeLeadingComments(node, start);

                this.movePast(node.openBracketToken);

                var parameter = node.parameter.accept(this);

                this.movePast(node.closeBracketToken);
                var returnType = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;

                var name = new TypeScript.Identifier("__item");
                this.setSpanExplicit(name, start, start);

                var parameters = new TypeScript.ASTList();
                parameters.append(parameter);

                result = new TypeScript.FunctionDeclaration(name, null, false, null, parameters, 12 /* FunctionDeclaration */);

                result.preComments = preComments;
                result.variableArgList = false;
                result.returnTypeAnnotation = returnType;

                result.setFunctionFlags(result.getFunctionFlags() | 4096 /* IndexerMember */);
                result.setFunctionFlags(result.getFunctionFlags() | 256 /* Method */);
                result.setFunctionFlags(result.getFunctionFlags() | 128 /* Signature */);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitPropertySignature = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var preComments = this.convertNodeLeadingComments(node, start);

                var name = this.identifierFromToken(node.propertyName, !!node.questionToken, true);
                this.movePast(node.propertyName);
                this.movePast(node.questionToken);
                var typeExpr = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;

                result = new TypeScript.VariableDeclarator(name);

                result.preComments = preComments;
                result.typeExpr = typeExpr;
                result.setVarFlags(result.getVarFlags() | 256 /* Property */);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitParameterList = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;

            var openParenToken = node.openParenToken;
            this.previousTokenTrailingComments = this.convertTokenTrailingComments(openParenToken, start + openParenToken.leadingTriviaWidth() + openParenToken.width());

            this.movePast(node.openParenToken);
            var result = this.visitSeparatedSyntaxList(node.parameters);
            this.movePast(node.closeParenToken);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitCallSignature = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var preComments = this.convertNodeLeadingComments(node, start);

                var typeParameters = node.typeParameterList === null ? null : node.typeParameterList.accept(this);
                var parameters = node.parameterList.accept(this);
                var returnType = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;

                result = new TypeScript.FunctionDeclaration(null, null, false, typeParameters, parameters, 12 /* FunctionDeclaration */);

                result.preComments = preComments;
                result.variableArgList = this.hasDotDotDotParameter(node.parameterList.parameters);
                result.returnTypeAnnotation = returnType;

                result.hint = "_call";
                result.setFunctionFlags(result.getFunctionFlags() | 512 /* CallMember */);
                result.setFunctionFlags(result.getFunctionFlags() | 256 /* Method */);
                result.setFunctionFlags(result.getFunctionFlags() | 128 /* Signature */);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitTypeParameterList = function (node) {
            this.assertElementAtPosition(node);

            this.movePast(node.lessThanToken);
            var result = this.visitSeparatedSyntaxList(node.typeParameters);
            this.movePast(node.greaterThanToken);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitTypeParameter = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var identifier = this.identifierFromToken(node.identifier, false, true);
                this.movePast(node.identifier);
                var constraint = node.constraint ? node.constraint.accept(this) : null;

                result = new TypeScript.TypeParameter(identifier, constraint);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitConstraint = function (node) {
            this.assertElementAtPosition(node);

            this.movePast(node.extendsKeyword);
            return this.visitType(node.type);
        };

        SyntaxTreeToAstVisitor.prototype.visitIfStatement = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.moveTo(node, node.condition);
                var condition = node.condition.accept(this);
                this.movePast(node.closeParenToken);
                var thenBod = node.statement.accept(this);
                var elseBod = node.elseClause ? node.elseClause.accept(this) : null;

                result = new TypeScript.IfStatement(condition, thenBod, elseBod);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitElseClause = function (node) {
            this.assertElementAtPosition(node);

            this.movePast(node.elseKeyword);
            return node.statement.accept(this);
        };

        SyntaxTreeToAstVisitor.prototype.visitExpressionStatement = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var preComments = this.convertNodeLeadingComments(node, start);
                var postComments = this.convertNodeTrailingComments(node, start);

                var expression = node.expression.accept(this);
                this.movePast(node.semicolonToken);

                result = new TypeScript.ExpressionStatement(expression);
                result.preComments = preComments;
                result.postComments = postComments;
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitConstructorDeclaration = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var preComments = this.convertNodeLeadingComments(node, start);
                var postComments = this.convertNodeTrailingComments(node, start);

                this.moveTo(node, node.parameterList);
                var parameters = node.parameterList.accept(this);

                var block = node.block ? node.block.accept(this) : null;

                this.movePast(node.semicolonToken);

                result = new TypeScript.FunctionDeclaration(null, block, true, null, parameters, 12 /* FunctionDeclaration */);

                result.preComments = preComments;
                result.postComments = postComments;
                result.variableArgList = this.hasDotDotDotParameter(node.parameterList.parameters);

                if (node.semicolonToken) {
                    result.setFunctionFlags(result.getFunctionFlags() | 128 /* Signature */);
                }
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitMemberFunctionDeclaration = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var preComments = this.convertNodeLeadingComments(node, start);
                var postComments = this.convertNodeTrailingComments(node, start);

                this.moveTo(node, node.propertyName);
                var name = this.identifierFromToken(node.propertyName, false, true);

                this.movePast(node.propertyName);

                var typeParameters = node.callSignature.typeParameterList === null ? null : node.callSignature.typeParameterList.accept(this);
                var parameters = node.callSignature.parameterList.accept(this);
                var returnType = node.callSignature.typeAnnotation ? node.callSignature.typeAnnotation.accept(this) : null;

                var block = node.block ? node.block.accept(this) : null;
                this.movePast(node.semicolonToken);

                result = new TypeScript.FunctionDeclaration(name, block, false, typeParameters, parameters, 12 /* FunctionDeclaration */);

                result.preComments = preComments;
                result.postComments = postComments;
                result.variableArgList = this.hasDotDotDotParameter(node.callSignature.parameterList.parameters);
                result.returnTypeAnnotation = returnType;

                if (node.semicolonToken) {
                    result.setFunctionFlags(result.getFunctionFlags() | 128 /* Signature */);
                }

                if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 55 /* PrivateKeyword */)) {
                    result.setFunctionFlags(result.getFunctionFlags() | 2 /* Private */);
                } else {
                    result.setFunctionFlags(result.getFunctionFlags() | 4 /* Public */);
                }

                if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 58 /* StaticKeyword */)) {
                    result.setFunctionFlags(result.getFunctionFlags() | 16 /* Static */);
                }

                result.setFunctionFlags(result.getFunctionFlags() | 256 /* Method */);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitMemberAccessorDeclaration = function (node, typeAnnotation) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var preComments = this.convertNodeLeadingComments(node, start);
                var postComments = this.convertNodeTrailingComments(node, start);

                this.moveTo(node, node.propertyName);
                var name = this.identifierFromToken(node.propertyName, false, true);
                this.movePast(node.propertyName);
                var parameters = node.parameterList.accept(this);
                var returnType = typeAnnotation ? typeAnnotation.accept(this) : null;

                var block = node.block ? node.block.accept(this) : null;
                result = new TypeScript.FunctionDeclaration(name, block, false, null, parameters, 12 /* FunctionDeclaration */);

                result.preComments = preComments;
                result.postComments = postComments;
                result.variableArgList = this.hasDotDotDotParameter(node.parameterList.parameters);
                result.returnTypeAnnotation = returnType;

                if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 55 /* PrivateKeyword */)) {
                    result.setFunctionFlags(result.getFunctionFlags() | 2 /* Private */);
                } else {
                    result.setFunctionFlags(result.getFunctionFlags() | 4 /* Public */);
                }

                if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 58 /* StaticKeyword */)) {
                    result.setFunctionFlags(result.getFunctionFlags() | 16 /* Static */);
                }

                result.setFunctionFlags(result.getFunctionFlags() | 256 /* Method */);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitGetMemberAccessorDeclaration = function (node) {
            this.assertElementAtPosition(node);

            var result = this.visitMemberAccessorDeclaration(node, node.typeAnnotation);

            result.setFunctionFlags(result.getFunctionFlags() | 32 /* GetAccessor */);
            result.hint = "get" + result.name.actualText;

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitSetMemberAccessorDeclaration = function (node) {
            this.assertElementAtPosition(node);

            var result = this.visitMemberAccessorDeclaration(node, null);

            result.setFunctionFlags(result.getFunctionFlags() | 64 /* SetAccessor */);
            result.hint = "set" + result.name.actualText;

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitMemberVariableDeclaration = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var preComments = this.convertNodeLeadingComments(node, start);
                var postComments = this.convertNodeTrailingComments(node, start);

                this.moveTo(node, node.variableDeclarator);
                this.moveTo(node.variableDeclarator, node.variableDeclarator.identifier);

                var name = this.identifierFromToken(node.variableDeclarator.identifier, false, true);
                this.movePast(node.variableDeclarator.identifier);
                var typeExpr = node.variableDeclarator.typeAnnotation ? node.variableDeclarator.typeAnnotation.accept(this) : null;
                var init = node.variableDeclarator.equalsValueClause ? node.variableDeclarator.equalsValueClause.accept(this) : null;
                this.movePast(node.semicolonToken);

                result = new TypeScript.VariableDeclarator(name);

                result.preComments = preComments;
                result.postComments = postComments;
                result.typeExpr = typeExpr;
                result.init = init;

                if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 58 /* StaticKeyword */)) {
                    result.setVarFlags(result.getVarFlags() | 16 /* Static */);
                }

                if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 55 /* PrivateKeyword */)) {
                    result.setVarFlags(result.getVarFlags() | 2 /* Private */);
                } else {
                    result.setVarFlags(result.getVarFlags() | 4 /* Public */);
                }

                result.setVarFlags(result.getVarFlags() | 2048 /* ClassProperty */);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitThrowStatement = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.throwKeyword);
                var expression = node.expression.accept(this);
                this.movePast(node.semicolonToken);

                result = new TypeScript.ThrowStatement(expression);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitReturnStatement = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;

            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var preComments = this.convertNodeLeadingComments(node, start);
                var postComments = this.convertNodeTrailingComments(node, start);

                this.movePast(node.returnKeyword);
                var expression = node.expression ? node.expression.accept(this) : null;
                this.movePast(node.semicolonToken);

                result = new TypeScript.ReturnStatement(expression);
                result.preComments = preComments;
                result.postComments = postComments;
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitObjectCreationExpression = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.newKeyword);
                var expression = node.expression.accept(this);
                var typeArgumentList = node.argumentList === null || node.argumentList.typeArgumentList === null ? null : node.argumentList.typeArgumentList.accept(this);
                var argumentList = this.convertArgumentListArguments(node.argumentList);

                result = new TypeScript.CallExpression(37 /* ObjectCreationExpression */, expression, typeArgumentList, argumentList);

                if (expression.nodeType === 11 /* TypeRef */) {
                    var typeRef = expression;

                    if (typeRef.arrayCount === 0) {
                        var term = typeRef.term;
                        if (term.nodeType === 32 /* MemberAccessExpression */ || term.nodeType === 20 /* Name */) {
                            expression = term;
                        }
                    }
                }
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitSwitchStatement = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.switchKeyword);
                this.movePast(node.openParenToken);
                var expression = node.expression.accept(this);
                this.movePast(node.closeParenToken);
                var closeParenPosition = this.position;
                this.movePast(node.openBraceToken);

                result = new TypeScript.SwitchStatement(expression);

                result.statement.minChar = start;
                result.statement.limChar = closeParenPosition;

                result.caseList = new TypeScript.ASTList();

                for (var i = 0, n = node.switchClauses.childCount(); i < n; i++) {
                    var switchClause = node.switchClauses.childAt(i);
                    var translated = switchClause.accept(this);

                    if (switchClause.kind() === 232 /* DefaultSwitchClause */) {
                        result.defaultCase = translated;
                    }

                    result.caseList.append(translated);
                }

                this.movePast(node.closeBraceToken);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitCaseSwitchClause = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.caseKeyword);
                var expression = node.expression.accept(this);
                this.movePast(node.colonToken);
                var statements = this.visitSyntaxList(node.statements);

                result = new TypeScript.CaseClause();

                result.expr = expression;
                result.body = statements;
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitDefaultSwitchClause = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.defaultKeyword);
                this.movePast(node.colonToken);
                var statements = this.visitSyntaxList(node.statements);

                result = new TypeScript.CaseClause();
                result.body = statements;
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitBreakStatement = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.breakKeyword);
                this.movePast(node.identifier);
                this.movePast(node.semicolonToken);

                result = new TypeScript.Jump(82 /* BreakStatement */);

                if (node.identifier !== null) {
                    result.target = node.identifier.valueText();
                }
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitContinueStatement = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.continueKeyword);
                this.movePast(node.identifier);
                this.movePast(node.semicolonToken);

                result = new TypeScript.Jump(83 /* ContinueStatement */);

                if (node.identifier !== null) {
                    result.target = node.identifier.valueText();
                }
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitForStatement = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.forKeyword);
                this.movePast(node.openParenToken);
                var init = node.variableDeclaration ? node.variableDeclaration.accept(this) : node.initializer ? node.initializer.accept(this) : null;
                this.movePast(node.firstSemicolonToken);
                var cond = node.condition ? node.condition.accept(this) : null;
                this.movePast(node.secondSemicolonToken);
                var incr = node.incrementor ? node.incrementor.accept(this) : null;
                this.movePast(node.closeParenToken);
                var body = node.statement.accept(this);

                result = new TypeScript.ForStatement(init, cond, incr, body);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitForInStatement = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.forKeyword);
                this.movePast(node.openParenToken);
                var init = node.variableDeclaration ? node.variableDeclaration.accept(this) : node.left.accept(this);
                this.movePast(node.inKeyword);
                var expression = node.expression.accept(this);
                this.movePast(node.closeParenToken);
                var body = node.statement.accept(this);

                result = new TypeScript.ForInStatement(init, expression, body);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitWhileStatement = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.moveTo(node, node.condition);
                var condition = node.condition.accept(this);
                this.movePast(node.closeParenToken);
                var statement = node.statement.accept(this);

                result = new TypeScript.WhileStatement(condition, statement);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitWithStatement = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.moveTo(node, node.condition);
                var condition = node.condition.accept(this);
                this.movePast(node.closeParenToken);
                var statement = node.statement.accept(this);

                result = new TypeScript.WithStatement(condition, statement);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitCastExpression = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.lessThanToken);
                var castTerm = this.visitType(node.type);
                this.movePast(node.greaterThanToken);
                var expression = node.expression.accept(this);

                result = new TypeScript.UnaryExpression(78 /* CastExpression */, expression);
                result.castTerm = castTerm;
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitObjectLiteralExpression = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var preComments = this.convertNodeLeadingComments(node, start);

                var openStart = this.position + node.openBraceToken.leadingTriviaWidth();
                this.movePast(node.openBraceToken);

                var propertyAssignments = this.visitSeparatedSyntaxList(node.propertyAssignments);

                var closeStart = this.position + node.closeBraceToken.leadingTriviaWidth();
                this.movePast(node.closeBraceToken);

                result = new TypeScript.UnaryExpression(22 /* ObjectLiteralExpression */, propertyAssignments);
                result.preComments = preComments;

                if (this.isOnSingleLine(openStart, closeStart)) {
                    result.setFlags(result.getFlags() | 2 /* SingleLine */);
                }
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitSimplePropertyAssignment = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var preComments = this.convertNodeLeadingComments(node, start);

                var left = node.propertyName.accept(this);

                this.previousTokenTrailingComments = this.convertTokenTrailingComments(node.colonToken, this.position + node.colonToken.leadingTriviaWidth() + node.colonToken.width());

                this.movePast(node.colonToken);
                var right = node.expression.accept(this);

                result = new TypeScript.BinaryExpression(80 /* Member */, left, right);
                result.preComments = preComments;

                if (right.nodeType === 12 /* FunctionDeclaration */) {
                    var funcDecl = right;
                    funcDecl.hint = left.text;
                }
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitFunctionPropertyAssignment = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var left = node.propertyName.accept(this);
                var functionDeclaration = node.callSignature.accept(this);
                var block = node.block.accept(this);

                functionDeclaration.hint = left.text;
                functionDeclaration.block = block;
                functionDeclaration.setFunctionFlags(16384 /* IsFunctionProperty */);

                result = new TypeScript.BinaryExpression(80 /* Member */, left, functionDeclaration);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitGetAccessorPropertyAssignment = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.moveTo(node, node.propertyName);
                var name = this.identifierFromToken(node.propertyName, false, true);
                var functionName = this.identifierFromToken(node.propertyName, false, true);
                this.movePast(node.propertyName);
                this.movePast(node.openParenToken);
                this.movePast(node.closeParenToken);
                var returnType = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;

                var block = node.block ? node.block.accept(this) : null;

                var funcDecl = new TypeScript.FunctionDeclaration(functionName, block, false, null, new TypeScript.ASTList(), 12 /* FunctionDeclaration */);
                this.setSpan(funcDecl, start, node);

                funcDecl.setFunctionFlags(funcDecl.getFunctionFlags() | 32 /* GetAccessor */);
                funcDecl.setFunctionFlags(funcDecl.getFunctionFlags() | 8192 /* IsFunctionExpression */);
                funcDecl.hint = "get" + node.propertyName.valueText();
                funcDecl.returnTypeAnnotation = returnType;

                result = new TypeScript.BinaryExpression(80 /* Member */, name, funcDecl);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitSetAccessorPropertyAssignment = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.moveTo(node, node.propertyName);
                var name = this.identifierFromToken(node.propertyName, false, true);
                var functionName = this.identifierFromToken(node.propertyName, false, true);
                this.movePast(node.propertyName);
                this.movePast(node.openParenToken);
                var parameter = node.parameter.accept(this);
                this.movePast(node.closeParenToken);

                var parameters = new TypeScript.ASTList();
                parameters.append(parameter);

                var block = node.block ? node.block.accept(this) : null;

                var funcDecl = new TypeScript.FunctionDeclaration(functionName, block, false, null, parameters, 12 /* FunctionDeclaration */);
                this.setSpan(funcDecl, start, node);

                funcDecl.setFunctionFlags(funcDecl.getFunctionFlags() | 64 /* SetAccessor */);
                funcDecl.setFunctionFlags(funcDecl.getFunctionFlags() | 8192 /* IsFunctionExpression */);
                funcDecl.hint = "set" + node.propertyName.valueText();

                result = new TypeScript.BinaryExpression(80 /* Member */, name, funcDecl);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitFunctionExpression = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var preComments = this.convertNodeLeadingComments(node, start);

                this.movePast(node.functionKeyword);
                var name = node.identifier === null ? null : this.identifierFromToken(node.identifier, false, true);
                this.movePast(node.identifier);
                var typeParameters = node.callSignature.typeParameterList === null ? null : node.callSignature.typeParameterList.accept(this);
                var parameters = node.callSignature.parameterList.accept(this);
                var returnType = node.callSignature.typeAnnotation ? node.callSignature.typeAnnotation.accept(this) : null;

                var block = node.block ? node.block.accept(this) : null;

                result = new TypeScript.FunctionDeclaration(name, block, false, typeParameters, parameters, 12 /* FunctionDeclaration */);

                result.preComments = preComments;
                result.variableArgList = this.hasDotDotDotParameter(node.callSignature.parameterList.parameters);
                result.returnTypeAnnotation = returnType;
                result.setFunctionFlags(result.getFunctionFlags() | 8192 /* IsFunctionExpression */);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitEmptyStatement = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.semicolonToken);

                result = new TypeScript.EmptyStatement();
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitTryStatement = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.tryKeyword);
                var tryBody = node.block.accept(this);

                var catchClause = null;
                if (node.catchClause !== null) {
                    catchClause = node.catchClause.accept(this);
                }

                var finallyBody = null;
                if (node.finallyClause !== null) {
                    finallyBody = node.finallyClause.accept(this);
                }

                result = new TypeScript.TryStatement(tryBody, catchClause, finallyBody);
            }

            TypeScript.Debug.assert(result !== null);
            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitCatchClause = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.catchKeyword);
                this.movePast(node.openParenToken);
                var identifier = this.identifierFromToken(node.identifier, false, true);
                this.movePast(node.identifier);
                var typeExpr = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;
                this.movePast(node.closeParenToken);
                var block = node.block.accept(this);

                var varDecl = new TypeScript.VariableDeclarator(identifier);
                this.setSpanExplicit(varDecl, identifier.minChar, identifier.limChar);

                varDecl.typeExpr = typeExpr;

                result = new TypeScript.CatchClause(varDecl, block);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitFinallyClause = function (node) {
            this.movePast(node.finallyKeyword);
            return node.block.accept(this);
        };

        SyntaxTreeToAstVisitor.prototype.visitLabeledStatement = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                var identifier = this.identifierFromToken(node.identifier, false, true);
                this.movePast(node.identifier);
                this.movePast(node.colonToken);
                var statement = node.statement.accept(this);

                result = new TypeScript.LabeledStatement(identifier, statement);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitDoStatement = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.doKeyword);
                var statement = node.statement.accept(this);
                var whileSpan = new TypeScript.ASTSpan();
                this.setSpan(whileSpan, this.position, node.whileKeyword);

                this.movePast(node.whileKeyword);
                this.movePast(node.openParenToken);
                var condition = node.condition.accept(this);
                this.movePast(node.closeParenToken);
                this.movePast(node.semicolonToken);

                result = new TypeScript.DoStatement(statement, condition);
                result.whileSpan = whileSpan;
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitTypeOfExpression = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.typeOfKeyword);
                var expression = node.expression.accept(this);

                result = new TypeScript.UnaryExpression(34 /* TypeOfExpression */, expression);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitDeleteExpression = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.deleteKeyword);
                var expression = node.expression.accept(this);

                result = new TypeScript.UnaryExpression(28 /* DeleteExpression */, expression);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitVoidExpression = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.voidKeyword);
                var expression = node.expression.accept(this);

                result = new TypeScript.UnaryExpression(24 /* VoidExpression */, expression);
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitDebuggerStatement = function (node) {
            this.assertElementAtPosition(node);

            var start = this.position;
            var result = this.getAST(node);
            if (result) {
                this.movePast(node);
            } else {
                this.movePast(node.debuggerKeyword);
                this.movePast(node.semicolonToken);

                result = new TypeScript.DebuggerStatement();
            }

            this.setAST(node, result);
            this.setSpan(result, start, node);
            return result;
        };
        SyntaxTreeToAstVisitor.checkPositions = false;

        SyntaxTreeToAstVisitor.protoString = "__proto__";
        SyntaxTreeToAstVisitor.protoSubstitutionString = "#__proto__";
        return SyntaxTreeToAstVisitor;
    })();
    TypeScript.SyntaxTreeToAstVisitor = SyntaxTreeToAstVisitor;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Document = (function () {
        function Document(fileName, compilationSettings, scriptSnapshot, byteOrderMark, version, isOpen, syntaxTree) {
            this.fileName = fileName;
            this.compilationSettings = compilationSettings;
            this.scriptSnapshot = scriptSnapshot;
            this.byteOrderMark = byteOrderMark;
            this.version = version;
            this.isOpen = isOpen;
            this._diagnostics = null;
            this._syntaxTree = null;
            this._bloomFilter = null;
            if (isOpen) {
                this._syntaxTree = syntaxTree;
            } else {
                this._diagnostics = syntaxTree.diagnostics();
            }

            var identifiers = new TypeScript.BlockIntrinsics();

            var identifierWalker = new TypeScript.IdentifierWalker(identifiers);
            syntaxTree.sourceUnit().accept(identifierWalker);

            var identifierCount = 0;
            for (var name in identifiers) {
                identifierCount++;
            }
            this._bloomFilter = new TypeScript.BloomFilter(identifierCount);
            this._bloomFilter.addKeys(identifiers);

            this.lineMap = syntaxTree.lineMap();
            this.script = TypeScript.SyntaxTreeToAstVisitor.visit(syntaxTree, fileName, compilationSettings);
        }
        Document.prototype.diagnostics = function () {
            if (this._diagnostics === null) {
                this._diagnostics = this._syntaxTree.diagnostics();
            }

            return this._diagnostics;
        };

        Document.prototype.syntaxTree = function () {
            if (this._syntaxTree) {
                return this._syntaxTree;
            }

            return TypeScript.Parser.parse(this.fileName, TypeScript.SimpleText.fromScriptSnapshot(this.scriptSnapshot), TypeScript.isDTSFile(this.fileName), this.compilationSettings.codeGenTarget, TypeScript.getParseOptions(this.compilationSettings));
        };

        Document.prototype.bloomFilter = function () {
            return this._bloomFilter;
        };

        Document.prototype.update = function (scriptSnapshot, version, isOpen, textChangeRange, settings) {
            var oldScript = this.script;
            var oldSyntaxTree = this._syntaxTree;

            var text = TypeScript.SimpleText.fromScriptSnapshot(scriptSnapshot);

            var newSyntaxTree = textChangeRange === null || oldSyntaxTree === null ? TypeScript.Parser.parse(this.fileName, text, TypeScript.isDTSFile(this.fileName), settings.codeGenTarget, TypeScript.getParseOptions(this.compilationSettings)) : TypeScript.Parser.incrementalParse(oldSyntaxTree, textChangeRange, text);

            return new Document(this.fileName, this.compilationSettings, scriptSnapshot, this.byteOrderMark, version, isOpen, newSyntaxTree);
        };

        Document.create = function (fileName, scriptSnapshot, byteOrderMark, version, isOpen, referencedFiles, compilationSettings) {
            var syntaxTree = TypeScript.Parser.parse(fileName, TypeScript.SimpleText.fromScriptSnapshot(scriptSnapshot), TypeScript.isDTSFile(fileName), compilationSettings.codeGenTarget, TypeScript.getParseOptions(compilationSettings));

            var document = new Document(fileName, compilationSettings, scriptSnapshot, byteOrderMark, version, isOpen, syntaxTree);
            document.script.referencedFiles = referencedFiles;

            return document;
        };
        return Document;
    })();
    TypeScript.Document = Document;

    TypeScript.globalSemanticInfoChain = null;
    TypeScript.globalBinder = null;
    TypeScript.globalLogger = null;
    var TypeScriptCompiler = (function () {
        function TypeScriptCompiler(logger, settings, diagnosticMessages) {
            if (typeof logger === "undefined") { logger = new TypeScript.NullLogger(); }
            if (typeof settings === "undefined") { settings = new TypeScript.CompilationSettings(); }
            if (typeof diagnosticMessages === "undefined") { diagnosticMessages = null; }
            this.logger = logger;
            this.settings = settings;
            this.diagnosticMessages = diagnosticMessages;
            this.pullTypeChecker = null;
            this.semanticInfoChain = null;
            this.fileNameToDocument = new TypeScript.StringHashTable();
            this.emitOptions = new TypeScript.EmitOptions(this.settings);
            TypeScript.globalLogger = logger;
            if (this.diagnosticMessages) {
                TypeScript.diagnosticMessages = this.diagnosticMessages;
            }
        }
        TypeScriptCompiler.prototype.getDocument = function (fileName) {
            return this.fileNameToDocument.lookup(fileName);
        };

        TypeScriptCompiler.prototype.timeFunction = function (funcDescription, func) {
            return TypeScript.timeFunction(this.logger, funcDescription, func);
        };

        TypeScriptCompiler.prototype.addSourceUnit = function (fileName, scriptSnapshot, byteOrderMark, version, isOpen, referencedFiles) {
            if (typeof referencedFiles === "undefined") { referencedFiles = []; }
            var _this = this;
            return this.timeFunction("addSourceUnit(" + fileName + ")", function () {
                var document = Document.create(fileName, scriptSnapshot, byteOrderMark, version, isOpen, referencedFiles, _this.emitOptions.compilationSettings);
                _this.fileNameToDocument.addOrUpdate(fileName, document);

                return document;
            });
        };

        TypeScriptCompiler.prototype.updateSourceUnit = function (fileName, scriptSnapshot, version, isOpen, textChangeRange) {
            var _this = this;
            return this.timeFunction("pullUpdateUnit(" + fileName + ")", function () {
                var document = _this.getDocument(fileName);
                var updatedDocument = document.update(scriptSnapshot, version, isOpen, textChangeRange, _this.settings);

                _this.fileNameToDocument.addOrUpdate(fileName, updatedDocument);

                _this.pullUpdateScript(document, updatedDocument);

                return updatedDocument;
            });
        };

        TypeScriptCompiler.prototype.isDynamicModuleCompilation = function () {
            var fileNames = this.fileNameToDocument.getAllKeys();
            for (var i = 0, n = fileNames.length; i < n; i++) {
                var document = this.getDocument(fileNames[i]);
                var script = document.script;
                if (!script.isDeclareFile && script.topLevelMod !== null) {
                    return true;
                }
            }
            return false;
        };

        TypeScriptCompiler.prototype.updateCommonDirectoryPath = function () {
            var commonComponents = [];
            var commonComponentsLength = -1;

            var fileNames = this.fileNameToDocument.getAllKeys();
            for (var i = 0, len = fileNames.length; i < len; i++) {
                var fileName = fileNames[i];
                var document = this.getDocument(fileNames[i]);
                var script = document.script;

                if (!script.isDeclareFile) {
                    var fileComponents = TypeScript.filePathComponents(fileName);
                    if (commonComponentsLength === -1) {
                        commonComponents = fileComponents;
                        commonComponentsLength = commonComponents.length;
                    } else {
                        var updatedPath = false;
                        for (var j = 0; j < commonComponentsLength && j < fileComponents.length; j++) {
                            if (commonComponents[j] !== fileComponents[j]) {
                                commonComponentsLength = j;
                                updatedPath = true;

                                if (j === 0) {
                                    return new TypeScript.Diagnostic(null, 0, 0, 273 /* Cannot_find_the_common_subdirectory_path_for_the_input_files */, null);
                                }

                                break;
                            }
                        }

                        if (!updatedPath && fileComponents.length < commonComponentsLength) {
                            commonComponentsLength = fileComponents.length;
                        }
                    }
                }
            }

            this.emitOptions.commonDirectoryPath = commonComponents.slice(0, commonComponentsLength).join("/") + "/";
            if (this.emitOptions.compilationSettings.outputOption.charAt(this.emitOptions.compilationSettings.outputOption.length - 1) !== "/") {
                this.emitOptions.compilationSettings.outputOption += "/";
            }

            return null;
        };

        TypeScriptCompiler.prototype.parseEmitOption = function (ioHost) {
            this.emitOptions.ioHost = ioHost;
            if (this.emitOptions.compilationSettings.outputOption === "") {
                this.emitOptions.outputMany = true;
                this.emitOptions.commonDirectoryPath = "";
                return null;
            }

            this.emitOptions.compilationSettings.outputOption = TypeScript.switchToForwardSlashes(this.emitOptions.ioHost.resolvePath(this.emitOptions.compilationSettings.outputOption));

            if (this.emitOptions.ioHost.directoryExists(this.emitOptions.compilationSettings.outputOption)) {
                this.emitOptions.outputMany = true;
            } else if (this.emitOptions.ioHost.fileExists(this.emitOptions.compilationSettings.outputOption)) {
                this.emitOptions.outputMany = false;
            } else {
                this.emitOptions.outputMany = !TypeScript.isJSFile(this.emitOptions.compilationSettings.outputOption);
            }

            if (this.isDynamicModuleCompilation() && !this.emitOptions.outputMany) {
                return new TypeScript.Diagnostic(null, 0, 0, 274 /* Cannot_compile_dynamic_modules_when_emitting_into_single_file */, null);
            }

            if (this.emitOptions.outputMany) {
                return this.updateCommonDirectoryPath();
            }

            return null;
        };

        TypeScriptCompiler.prototype.getScripts = function () {
            var result = [];
            var fileNames = this.fileNameToDocument.getAllKeys();

            for (var i = 0, n = fileNames.length; i < n; i++) {
                var document = this.getDocument(fileNames[i]);
                result.push(document.script);
            }

            return result;
        };

        TypeScriptCompiler.prototype.writeByteOrderMarkForDocument = function (document) {
            if (this.emitOptions.outputMany) {
                return document.byteOrderMark !== 0 /* None */;
            } else {
                var fileNames = this.fileNameToDocument.getAllKeys();

                for (var i = 0, n = fileNames.length; i < n; i++) {
                    var document = this.getDocument(fileNames[i]);
                    if (document.byteOrderMark !== 0 /* None */) {
                        return true;
                    }
                }

                return false;
            }
        };

        TypeScriptCompiler.mapToDTSFileName = function (fileName, wholeFileNameReplaced) {
            return TypeScript.getDeclareFilePath(fileName);
        };

        TypeScriptCompiler.prototype.canEmitDeclarations = function (script) {
            if (!this.settings.generateDeclarationFiles) {
                return false;
            }

            if (!!script && (script.isDeclareFile || script.moduleElements === null)) {
                return false;
            }

            return true;
        };

        TypeScriptCompiler.prototype.emitDeclarations = function (document, declarationEmitter) {
            var script = document.script;
            if (this.canEmitDeclarations(script)) {
                if (!declarationEmitter) {
                    var declareFileName = this.emitOptions.mapOutputFileName(document.fileName, TypeScriptCompiler.mapToDTSFileName);
                    declarationEmitter = new TypeScript.DeclarationEmitter(declareFileName, this.semanticInfoChain, this.emitOptions, document.byteOrderMark !== 0 /* None */);
                }

                declarationEmitter.fileName = document.fileName;
                declarationEmitter.emitDeclarations(script);
            }

            return declarationEmitter;
        };

        TypeScriptCompiler.prototype.emitAllDeclarations = function () {
            if (this.canEmitDeclarations()) {
                var sharedEmitter = null;
                var fileNames = this.fileNameToDocument.getAllKeys();

                for (var i = 0, n = fileNames.length; i < n; i++) {
                    var fileName = fileNames[i];

                    try  {
                        var document = this.getDocument(fileNames[i]);

                        if (this.emitOptions.outputMany) {
                            var singleEmitter = this.emitDeclarations(document);
                            if (singleEmitter) {
                                singleEmitter.close();
                            }
                        } else {
                            sharedEmitter = this.emitDeclarations(document, sharedEmitter);
                        }
                    } catch (ex1) {
                        return TypeScript.Emitter.handleEmitterError(fileName, ex1);
                    }
                }

                if (sharedEmitter) {
                    try  {
                        sharedEmitter.close();
                    } catch (ex2) {
                        return TypeScript.Emitter.handleEmitterError(sharedEmitter.fileName, ex2);
                    }
                }
            }

            return [];
        };

        TypeScriptCompiler.prototype.emitUnitDeclarations = function (fileName) {
            if (this.canEmitDeclarations()) {
                if (this.emitOptions.outputMany) {
                    try  {
                        var document = this.getDocument(fileName);
                        var emitter = this.emitDeclarations(document);
                        if (emitter) {
                            emitter.close();
                        }
                    } catch (ex1) {
                        return TypeScript.Emitter.handleEmitterError(fileName, ex1);
                    }
                } else {
                    return this.emitAllDeclarations();
                }
            }

            return [];
        };

        TypeScriptCompiler.mapToFileNameExtension = function (extension, fileName, wholeFileNameReplaced) {
            if (wholeFileNameReplaced) {
                return fileName;
            } else {
                var splitFname = fileName.split(".");
                splitFname.pop();
                return splitFname.join(".") + extension;
            }
        };

        TypeScriptCompiler.mapToJSFileName = function (fileName, wholeFileNameReplaced) {
            return TypeScriptCompiler.mapToFileNameExtension(".js", fileName, wholeFileNameReplaced);
        };

        TypeScriptCompiler.prototype.emit = function (document, inputOutputMapper, emitter) {
            var script = document.script;
            if (!script.isDeclareFile) {
                var typeScriptFileName = document.fileName;
                if (!emitter) {
                    var javaScriptFileName = this.emitOptions.mapOutputFileName(typeScriptFileName, TypeScriptCompiler.mapToJSFileName);
                    var outFile = this.createFile(javaScriptFileName, this.writeByteOrderMarkForDocument(document));

                    emitter = new TypeScript.Emitter(javaScriptFileName, outFile, this.emitOptions, this.semanticInfoChain);

                    if (this.settings.mapSourceFiles) {
                        var sourceMapFileName = javaScriptFileName + TypeScript.SourceMapper.MapFileExtension;
                        emitter.setSourceMappings(new TypeScript.SourceMapper(typeScriptFileName, javaScriptFileName, sourceMapFileName, outFile, this.createFile(sourceMapFileName, false), this.settings.emitFullSourceMapPath));
                    }

                    if (inputOutputMapper) {
                        inputOutputMapper(typeScriptFileName, javaScriptFileName);
                    }
                } else if (this.settings.mapSourceFiles) {
                    emitter.setSourceMappings(new TypeScript.SourceMapper(typeScriptFileName, emitter.emittingFileName, emitter.sourceMapper.sourceMapFileName, emitter.outfile, emitter.sourceMapper.sourceMapOut, this.settings.emitFullSourceMapPath));
                }

                emitter.setDocument(document);
                emitter.emitJavascript(script, false);
            }

            return emitter;
        };

        TypeScriptCompiler.prototype.emitAll = function (ioHost, inputOutputMapper) {
            var optionsDiagnostic = this.parseEmitOption(ioHost);
            if (optionsDiagnostic) {
                return [optionsDiagnostic];
            }

            var startEmitTime = (new Date()).getTime();

            var fileNames = this.fileNameToDocument.getAllKeys();
            var sharedEmitter = null;

            for (var i = 0, n = fileNames.length; i < n; i++) {
                var fileName = fileNames[i];

                var document = this.getDocument(fileName);

                try  {
                    if (this.emitOptions.outputMany) {
                        var singleEmitter = this.emit(document, inputOutputMapper);

                        if (singleEmitter) {
                            singleEmitter.emitSourceMapsAndClose();
                        }
                    } else {
                        sharedEmitter = this.emit(document, inputOutputMapper, sharedEmitter);
                    }
                } catch (ex1) {
                    return TypeScript.Emitter.handleEmitterError(fileName, ex1);
                }
            }

            this.logger.log("Emit: " + ((new Date()).getTime() - startEmitTime));

            if (sharedEmitter) {
                try  {
                    sharedEmitter.emitSourceMapsAndClose();
                } catch (ex2) {
                    return TypeScript.Emitter.handleEmitterError(sharedEmitter.document.fileName, ex2);
                }
            }

            return [];
        };

        TypeScriptCompiler.prototype.emitUnit = function (fileName, ioHost, inputOutputMapper) {
            var optionsDiagnostic = this.parseEmitOption(ioHost);
            if (optionsDiagnostic) {
                return [optionsDiagnostic];
            }

            if (this.emitOptions.outputMany) {
                var document = this.getDocument(fileName);
                try  {
                    var emitter = this.emit(document, inputOutputMapper);

                    if (emitter) {
                        emitter.emitSourceMapsAndClose();
                    }
                } catch (ex1) {
                    return TypeScript.Emitter.handleEmitterError(fileName, ex1);
                }

                return [];
            } else {
                return this.emitAll(ioHost, inputOutputMapper);
            }
        };

        TypeScriptCompiler.prototype.createFile = function (fileName, writeByteOrderMark) {
            return new TypeScript.TextWriter(this.emitOptions.ioHost, fileName, writeByteOrderMark);
        };

        TypeScriptCompiler.prototype.getSyntacticDiagnostics = function (fileName) {
            return this.getDocument(fileName).diagnostics();
        };

        TypeScriptCompiler.prototype.getSyntaxTree = function (fileName) {
            return this.getDocument(fileName).syntaxTree();
        };
        TypeScriptCompiler.prototype.getScript = function (fileName) {
            return this.getDocument(fileName).script;
        };

        TypeScriptCompiler.prototype.getSemanticDiagnostics = function (fileName) {
            var errors = [];
            var unit = this.semanticInfoChain.getUnit(fileName);

            TypeScript.globalSemanticInfoChain = this.semanticInfoChain;
            if (TypeScript.globalBinder) {
                TypeScript.globalBinder.semanticInfoChain = this.semanticInfoChain;
            }

            if (unit) {
                var document = this.getDocument(fileName);
                var script = document.script;

                if (script) {
                    this.pullTypeChecker.typeCheckScript(script, fileName, this);

                    unit.getDiagnostics(errors);
                }
            }

            return errors;
        };

        TypeScriptCompiler.prototype.pullTypeCheck = function () {
            var _this = this;
            return this.timeFunction("pullTypeCheck()", function () {
                _this.semanticInfoChain = new TypeScript.SemanticInfoChain();
                TypeScript.globalSemanticInfoChain = _this.semanticInfoChain;
                _this.pullTypeChecker = new TypeScript.PullTypeChecker(_this.settings, _this.semanticInfoChain);

                var declCollectionContext = null;
                var i, n;

                var createDeclsStartTime = new Date().getTime();

                var fileNames = _this.fileNameToDocument.getAllKeys();
                for (var i = 0, n = fileNames.length; i < n; i++) {
                    var fileName = fileNames[i];
                    var document = _this.getDocument(fileName);
                    var semanticInfo = new TypeScript.SemanticInfo(fileName);

                    declCollectionContext = new TypeScript.DeclCollectionContext(semanticInfo);
                    declCollectionContext.scriptName = fileName;

                    TypeScript.getAstWalkerFactory().walk(document.script, TypeScript.preCollectDecls, TypeScript.postCollectDecls, null, declCollectionContext);

                    semanticInfo.addTopLevelDecl(declCollectionContext.getParent());

                    _this.semanticInfoChain.addUnit(semanticInfo);
                }

                var createDeclsEndTime = new Date().getTime();

                var bindStartTime = new Date().getTime();

                var binder = new TypeScript.PullSymbolBinder(_this.semanticInfoChain);
                TypeScript.globalBinder = binder;

                var bindEndTime = new Date().getTime();

                _this.logger.log("Decl creation: " + (createDeclsEndTime - createDeclsStartTime));
                _this.logger.log("Binding: " + (bindEndTime - bindStartTime));
                _this.logger.log("    Time in findSymbol: " + TypeScript.time_in_findSymbol);
                _this.logger.log("Number of symbols created: " + TypeScript.pullSymbolID);
                _this.logger.log("Number of specialized types created: " + TypeScript.nSpecializationsCreated);
                _this.logger.log("Number of specialized signatures created: " + TypeScript.nSpecializedSignaturesCreated);
            });
        };

        TypeScriptCompiler.prototype.pullUpdateScript = function (oldDocument, newDocument) {
            var _this = this;
            this.timeFunction("pullUpdateScript: ", function () {
                var oldScript = oldDocument.script;
                var newScript = newDocument.script;

                var newScriptSemanticInfo = new TypeScript.SemanticInfo(oldDocument.fileName);
                var oldScriptSemanticInfo = _this.semanticInfoChain.getUnit(oldDocument.fileName);

                TypeScript.lastBoundPullDeclId = TypeScript.pullDeclID;
                TypeScript.lastBoundPullSymbolID = TypeScript.pullSymbolID;

                var declCollectionContext = new TypeScript.DeclCollectionContext(newScriptSemanticInfo);

                declCollectionContext.scriptName = oldDocument.fileName;

                TypeScript.getAstWalkerFactory().walk(newScript, TypeScript.preCollectDecls, TypeScript.postCollectDecls, null, declCollectionContext);

                var oldTopLevelDecl = oldScriptSemanticInfo.getTopLevelDecls()[0];
                var newTopLevelDecl = declCollectionContext.getParent();

                newScriptSemanticInfo.addTopLevelDecl(newTopLevelDecl);

                if (_this.pullTypeChecker && _this.pullTypeChecker.resolver) {
                    _this.pullTypeChecker.resolver.cleanCachedGlobals();
                }

                _this.semanticInfoChain.updateUnit(oldScriptSemanticInfo, newScriptSemanticInfo);

                _this.logger.log("Cleaning symbols...");
                var cleanStart = new Date().getTime();
                _this.semanticInfoChain.update();
                var cleanEnd = new Date().getTime();
                _this.logger.log("   time to clean: " + (cleanEnd - cleanStart));

                if (_this.pullTypeChecker && _this.pullTypeChecker.resolver) {
                    _this.pullTypeChecker.resolver.setUnitPath(oldDocument.fileName);
                }
            });
        };

        TypeScriptCompiler.prototype.getSymbolOfDeclaration = function (decl) {
            if (!decl) {
                return null;
            }
            var ast = this.pullTypeChecker.resolver.getASTForDecl(decl);
            if (!ast) {
                return null;
            }
            var enlosingDecl = this.pullTypeChecker.resolver.getEnclosingDecl(decl);
            if (ast.nodeType === 80 /* Member */) {
                return this.getSymbolOfDeclaration(enlosingDecl);
            }
            var resolutionContext = new TypeScript.PullTypeResolutionContext();
            return this.pullTypeChecker.resolver.resolveAST(ast, false, enlosingDecl, resolutionContext).symbol;
        };

        TypeScriptCompiler.prototype.resolvePosition = function (pos, document) {
            var declStack = [];
            var resultASTs = [];
            var script = document.script;
            var scriptName = document.fileName;

            var semanticInfo = this.semanticInfoChain.getUnit(scriptName);
            var lastDeclAST = null;
            var foundAST = null;
            var symbol = null;
            var candidateSignature = null;
            var callSignatures = null;

            var lambdaAST = null;
            var declarationInitASTs = [];
            var objectLitAST = null;
            var asgAST = null;
            var typeAssertionASTs = [];
            var resolutionContext = new TypeScript.PullTypeResolutionContext();
            var inTypeReference = false;
            var enclosingDecl = null;
            var isConstructorCall = false;

            TypeScript.globalSemanticInfoChain = this.semanticInfoChain;
            if (TypeScript.globalBinder) {
                TypeScript.globalBinder.semanticInfoChain = this.semanticInfoChain;
            }

            var pre = function (cur, parent) {
                if (TypeScript.isValidAstNode(cur)) {
                    if (pos >= cur.minChar && pos <= cur.limChar) {
                        var previous = resultASTs[resultASTs.length - 1];

                        if (previous === undefined || (cur.minChar >= previous.minChar && cur.limChar <= previous.limChar)) {
                            var decl = semanticInfo.getDeclForAST(cur);

                            if (decl) {
                                declStack[declStack.length] = decl;
                                lastDeclAST = cur;
                            }

                            if (cur.nodeType === 12 /* FunctionDeclaration */ && TypeScript.hasFlag((cur).getFunctionFlags(), 8192 /* IsFunctionExpression */)) {
                                lambdaAST = cur;
                            } else if (cur.nodeType === 17 /* VariableDeclarator */) {
                                declarationInitASTs[declarationInitASTs.length] = cur;
                            } else if (cur.nodeType === 22 /* ObjectLiteralExpression */) {
                                objectLitAST = cur;
                            } else if (cur.nodeType === 78 /* CastExpression */) {
                                typeAssertionASTs[typeAssertionASTs.length] = cur;
                            } else if (cur.nodeType === 38 /* AssignmentExpression */) {
                                asgAST = cur;
                            } else if (cur.nodeType === 11 /* TypeRef */) {
                                inTypeReference = true;
                            }

                            resultASTs[resultASTs.length] = cur;
                        }
                    }
                }
                return cur;
            };

            TypeScript.getAstWalkerFactory().walk(script, pre);

            if (resultASTs.length) {
                this.pullTypeChecker.setUnit(scriptName);

                foundAST = resultASTs[resultASTs.length - 1];

                if (foundAST.nodeType === 20 /* Name */ && resultASTs.length > 1) {
                    var previousAST = resultASTs[resultASTs.length - 2];
                    switch (previousAST.nodeType) {
                        case 14 /* InterfaceDeclaration */:
                        case 13 /* ClassDeclaration */:
                        case 15 /* ModuleDeclaration */:
                            if (foundAST === (previousAST).name) {
                                foundAST = previousAST;
                            }
                            break;

                        case 17 /* VariableDeclarator */:
                            if (foundAST === (previousAST).id) {
                                foundAST = previousAST;
                            }
                            break;

                        case 12 /* FunctionDeclaration */:
                            if (foundAST === (previousAST).name) {
                                foundAST = previousAST;
                            }
                            break;
                    }
                }

                var funcDecl = null;
                if (lastDeclAST === foundAST) {
                    symbol = declStack[declStack.length - 1].getSymbol();
                    this.pullTypeChecker.resolver.resolveDeclaredSymbol(symbol, null, resolutionContext);
                    symbol.setUnresolved();
                    enclosingDecl = declStack[declStack.length - 1].getParentDecl();
                    if (foundAST.nodeType === 12 /* FunctionDeclaration */) {
                        funcDecl = foundAST;
                    }
                } else {
                    for (var i = declStack.length - 1; i >= 0; i--) {
                        if (!(declStack[i].getKind() & (1024 /* Variable */ | 2048 /* Parameter */))) {
                            enclosingDecl = declStack[i];
                            break;
                        }
                    }

                    var callExpression = null;
                    if ((foundAST.nodeType === 30 /* SuperExpression */ || foundAST.nodeType === 29 /* ThisExpression */ || foundAST.nodeType === 20 /* Name */) && resultASTs.length > 1) {
                        for (var i = resultASTs.length - 2; i >= 0; i--) {
                            if (resultASTs[i].nodeType === 32 /* MemberAccessExpression */ && (resultASTs[i]).operand2 === resultASTs[i + 1]) {
                                foundAST = resultASTs[i];
                            } else if ((resultASTs[i].nodeType === 36 /* InvocationExpression */ || resultASTs[i].nodeType === 37 /* ObjectCreationExpression */) && (resultASTs[i]).target === resultASTs[i + 1]) {
                                callExpression = resultASTs[i];
                                break;
                            } else if (resultASTs[i].nodeType === 12 /* FunctionDeclaration */ && (resultASTs[i]).name === resultASTs[i + 1]) {
                                funcDecl = resultASTs[i];
                                break;
                            } else {
                                break;
                            }
                        }
                    }

                    if (foundAST.nodeType === 1 /* List */) {
                        for (var i = 0; i < (foundAST).members.length; i++) {
                            if ((foundAST).members[i].minChar > pos) {
                                foundAST = (foundAST).members[i];
                                break;
                            }
                        }
                    }

                    resolutionContext.resolvingTypeReference = inTypeReference;

                    var inContextuallyTypedAssignment = false;

                    if (declarationInitASTs.length) {
                        var assigningAST;

                        for (var i = 0; i < declarationInitASTs.length; i++) {
                            assigningAST = declarationInitASTs[i];
                            inContextuallyTypedAssignment = (assigningAST !== null) && (assigningAST.typeExpr !== null);

                            this.pullTypeChecker.resolver.resolveAST(assigningAST, false, null, resolutionContext);
                            var varSymbolAndDiagnostics = this.semanticInfoChain.getSymbolAndDiagnosticsForAST(assigningAST, scriptName);
                            var varSymbol = varSymbolAndDiagnostics && varSymbolAndDiagnostics.symbol;

                            if (varSymbol && inContextuallyTypedAssignment) {
                                var contextualType = varSymbol.getType();
                                resolutionContext.pushContextualType(contextualType, false, null);
                            }

                            if (assigningAST.init) {
                                this.pullTypeChecker.resolver.resolveAST(assigningAST.init, inContextuallyTypedAssignment, enclosingDecl, resolutionContext);
                            }
                        }
                    }

                    if (typeAssertionASTs.length) {
                        for (var i = 0; i < typeAssertionASTs.length; i++) {
                            this.pullTypeChecker.resolver.resolveAST(typeAssertionASTs[i], inContextuallyTypedAssignment, enclosingDecl, resolutionContext);
                        }
                    }

                    if (asgAST) {
                        this.pullTypeChecker.resolver.resolveAST(asgAST, inContextuallyTypedAssignment, enclosingDecl, resolutionContext);
                    }

                    if (objectLitAST) {
                        this.pullTypeChecker.resolver.resolveAST(objectLitAST, inContextuallyTypedAssignment, enclosingDecl, resolutionContext);
                    }

                    if (lambdaAST) {
                        this.pullTypeChecker.resolver.resolveAST(lambdaAST, true, enclosingDecl, resolutionContext);
                        enclosingDecl = semanticInfo.getDeclForAST(lambdaAST);
                    }

                    symbol = this.pullTypeChecker.resolver.resolveAST(foundAST, inContextuallyTypedAssignment, enclosingDecl, resolutionContext).symbol;
                    if (callExpression) {
                        var isPropertyOrVar = symbol.getKind() === 4096 /* Property */ || symbol.getKind() === 1024 /* Variable */;
                        var typeSymbol = symbol.getType();
                        if (isPropertyOrVar) {
                            isPropertyOrVar = (typeSymbol.getKind() !== 16 /* Interface */ && typeSymbol.getKind() !== 8388608 /* ObjectType */) || typeSymbol.getName() === "";
                        }

                        if (!isPropertyOrVar) {
                            isConstructorCall = foundAST.nodeType === 30 /* SuperExpression */ || callExpression.nodeType === 37 /* ObjectCreationExpression */;

                            if (foundAST.nodeType === 30 /* SuperExpression */) {
                                if (symbol.getKind() === 8 /* Class */) {
                                    callSignatures = (symbol).getConstructorMethod().getType().getConstructSignatures();
                                }
                            } else {
                                callSignatures = callExpression.nodeType === 36 /* InvocationExpression */ ? typeSymbol.getCallSignatures() : typeSymbol.getConstructSignatures();
                            }

                            var callResolutionResults = new TypeScript.PullAdditionalCallResolutionData();
                            if (callExpression.nodeType === 36 /* InvocationExpression */) {
                                this.pullTypeChecker.resolver.resolveCallExpression(callExpression, inContextuallyTypedAssignment, enclosingDecl, resolutionContext, callResolutionResults);
                            } else {
                                this.pullTypeChecker.resolver.resolveNewExpression(callExpression, inContextuallyTypedAssignment, enclosingDecl, resolutionContext, callResolutionResults);
                            }

                            if (callResolutionResults.candidateSignature) {
                                candidateSignature = callResolutionResults.candidateSignature;
                            }
                            if (callResolutionResults.targetSymbol && callResolutionResults.targetSymbol.getName() !== "") {
                                symbol = callResolutionResults.targetSymbol;
                            }
                            foundAST = callExpression;
                        }
                    }
                }

                if (funcDecl) {
                    if (symbol && symbol.getKind() !== 4096 /* Property */) {
                        var signatureInfo = TypeScript.PullHelpers.getSignatureForFuncDecl(funcDecl, this.semanticInfoChain.getUnit(scriptName));
                        candidateSignature = signatureInfo.signature;
                        callSignatures = signatureInfo.allSignatures;
                    }
                } else if (!callSignatures && symbol && (symbol.getKind() === 65536 /* Method */ || symbol.getKind() === 16384 /* Function */)) {
                    var typeSym = symbol.getType();
                    if (typeSym) {
                        callSignatures = typeSym.getCallSignatures();
                    }
                }
            }

            var enclosingScopeSymbol = this.getSymbolOfDeclaration(enclosingDecl);

            return {
                symbol: symbol,
                ast: foundAST,
                enclosingScopeSymbol: enclosingScopeSymbol,
                candidateSignature: candidateSignature,
                callSignatures: callSignatures,
                isConstructorCall: isConstructorCall
            };
        };

        TypeScriptCompiler.prototype.extractResolutionContextFromPath = function (path, document) {
            var script = document.script;
            var scriptName = document.fileName;

            var semanticInfo = this.semanticInfoChain.getUnit(scriptName);
            var enclosingDecl = null;
            var enclosingDeclAST = null;
            var inContextuallyTypedAssignment = false;

            TypeScript.globalSemanticInfoChain = this.semanticInfoChain;
            if (TypeScript.globalBinder) {
                TypeScript.globalBinder.semanticInfoChain = this.semanticInfoChain;
            }

            var resolutionContext = new TypeScript.PullTypeResolutionContext();
            resolutionContext.resolveAggressively = true;

            if (path.count() === 0) {
                return null;
            }

            this.pullTypeChecker.setUnit(semanticInfo.getPath());

            for (var i = 0, n = path.count(); i < n; i++) {
                var current = path.asts[i];

                switch (current.nodeType) {
                    case 12 /* FunctionDeclaration */:
                        if (TypeScript.hasFlag((current).getFunctionFlags(), 8192 /* IsFunctionExpression */)) {
                            this.pullTypeChecker.resolver.resolveAST((current), true, enclosingDecl, resolutionContext);
                        }

                        break;

                    case 17 /* VariableDeclarator */:
                        var assigningAST = current;
                        inContextuallyTypedAssignment = (assigningAST.typeExpr !== null);

                        this.pullTypeChecker.resolver.resolveAST(assigningAST, false, null, resolutionContext);
                        var varSymbolAndDiagnostics = this.semanticInfoChain.getSymbolAndDiagnosticsForAST(assigningAST, scriptName);
                        var varSymbol = varSymbolAndDiagnostics && varSymbolAndDiagnostics.symbol;

                        var contextualType = null;
                        if (varSymbol && inContextuallyTypedAssignment) {
                            contextualType = varSymbol.getType();
                        }

                        resolutionContext.pushContextualType(contextualType, false, null);

                        if (assigningAST.init) {
                            this.pullTypeChecker.resolver.resolveAST(assigningAST.init, inContextuallyTypedAssignment, enclosingDecl, resolutionContext);
                        }

                        break;

                    case 36 /* InvocationExpression */:
                    case 37 /* ObjectCreationExpression */:
                        var isNew = current.nodeType === 37 /* ObjectCreationExpression */;
                        var callExpression = current;
                        var contextualType = null;

                        if ((i + 1 < n) && callExpression.arguments === path.asts[i + 1]) {
                            var callResolutionResults = new TypeScript.PullAdditionalCallResolutionData();
                            if (isNew) {
                                this.pullTypeChecker.resolver.resolveNewExpression(callExpression, inContextuallyTypedAssignment, enclosingDecl, resolutionContext, callResolutionResults);
                            } else {
                                this.pullTypeChecker.resolver.resolveCallExpression(callExpression, inContextuallyTypedAssignment, enclosingDecl, resolutionContext, callResolutionResults);
                            }

                            if (callResolutionResults.actualParametersContextTypeSymbols) {
                                var argExpression = (path.asts[i + 1] && path.asts[i + 1].nodeType === 1 /* List */) ? path.asts[i + 2] : path.asts[i + 1];
                                if (argExpression) {
                                    for (var j = 0, m = callExpression.arguments.members.length; j < m; j++) {
                                        if (callExpression.arguments.members[j] === argExpression) {
                                            var callContextualType = callResolutionResults.actualParametersContextTypeSymbols[j];
                                            if (callContextualType) {
                                                contextualType = callContextualType;
                                                break;
                                            }
                                        }
                                    }
                                }
                            }
                        } else {
                            if (isNew) {
                                this.pullTypeChecker.resolver.resolveNewExpression(callExpression, inContextuallyTypedAssignment, enclosingDecl, resolutionContext);
                            } else {
                                this.pullTypeChecker.resolver.resolveCallExpression(callExpression, inContextuallyTypedAssignment, enclosingDecl, resolutionContext);
                            }
                        }

                        resolutionContext.pushContextualType(contextualType, false, null);

                        break;

                    case 21 /* ArrayLiteralExpression */:
                        this.pullTypeChecker.resolver.resolveAST(current, inContextuallyTypedAssignment, enclosingDecl, resolutionContext);

                        var contextualType = null;
                        var currentContextualType = resolutionContext.getContextualType();
                        if (currentContextualType && currentContextualType.isArray()) {
                            contextualType = currentContextualType.getElementType();
                        }

                        resolutionContext.pushContextualType(contextualType, false, null);

                        break;

                    case 22 /* ObjectLiteralExpression */:
                        var objectLiteralExpression = current;
                        var objectLiteralResolutionContext = new TypeScript.PullAdditionalObjectLiteralResolutionData();
                        this.pullTypeChecker.resolver.resolveObjectLiteralExpression(objectLiteralExpression, inContextuallyTypedAssignment, enclosingDecl, resolutionContext, objectLiteralResolutionContext);

                        var memeberAST = (path.asts[i + 1] && path.asts[i + 1].nodeType === 1 /* List */) ? path.asts[i + 2] : path.asts[i + 1];
                        if (memeberAST) {
                            var contextualType = null;
                            var memberDecls = objectLiteralExpression.operand;
                            if (memberDecls && objectLiteralResolutionContext.membersContextTypeSymbols) {
                                for (var j = 0, m = memberDecls.members.length; j < m; j++) {
                                    if (memberDecls.members[j] === memeberAST) {
                                        var memberContextualType = objectLiteralResolutionContext.membersContextTypeSymbols[j];
                                        if (memberContextualType) {
                                            contextualType = memberContextualType;
                                            break;
                                        }
                                    }
                                }
                            }

                            resolutionContext.pushContextualType(contextualType, false, null);
                        }

                        break;

                    case 38 /* AssignmentExpression */:
                        var assignmentExpression = current;
                        var contextualType = null;

                        if (path.asts[i + 1] && path.asts[i + 1] === assignmentExpression.operand2) {
                            var leftType = this.pullTypeChecker.resolver.resolveAST(assignmentExpression.operand1, inContextuallyTypedAssignment, enclosingDecl, resolutionContext).symbol.getType();
                            if (leftType) {
                                inContextuallyTypedAssignment = true;
                                contextualType = leftType;
                            }
                        }

                        resolutionContext.pushContextualType(contextualType, false, null);

                        break;

                    case 78 /* CastExpression */:
                        var castExpression = current;
                        var contextualType = null;

                        if (i + 1 < n && path.asts[i + 1] === castExpression.castTerm) {
                            resolutionContext.resolvingTypeReference = true;
                        }

                        var typeSymbol = this.pullTypeChecker.resolver.resolveTypeAssertionExpression(castExpression, inContextuallyTypedAssignment, enclosingDecl, resolutionContext).symbol;

                        if (typeSymbol) {
                            inContextuallyTypedAssignment = true;
                            contextualType = typeSymbol;
                        }

                        resolutionContext.pushContextualType(contextualType, false, null);

                        break;

                    case 93 /* ReturnStatement */:
                        var returnStatement = current;
                        var contextualType = null;

                        if (enclosingDecl && (enclosingDecl.getKind() & TypeScript.PullElementKind.SomeFunction)) {
                            var functionDeclaration = enclosingDeclAST;
                            if (functionDeclaration.returnTypeAnnotation) {
                                var currentResolvingTypeReference = resolutionContext.resolvingTypeReference;
                                resolutionContext.resolvingTypeReference = true;
                                var returnTypeSymbol = this.pullTypeChecker.resolver.resolveTypeReference(functionDeclaration.returnTypeAnnotation, enclosingDecl, resolutionContext).symbol;
                                resolutionContext.resolvingTypeReference = currentResolvingTypeReference;
                                if (returnTypeSymbol) {
                                    inContextuallyTypedAssignment = true;
                                    contextualType = returnTypeSymbol;
                                }
                            } else {
                                var currentContextualType = resolutionContext.getContextualType();
                                if (currentContextualType && currentContextualType.isFunction()) {
                                    var currentContextualTypeSignatureSymbol = currentContextualType.getDeclarations()[0].getSignatureSymbol();
                                    var currentContextualTypeReturnTypeSymbol = currentContextualTypeSignatureSymbol.getReturnType();
                                    if (currentContextualTypeReturnTypeSymbol) {
                                        inContextuallyTypedAssignment = true;
                                        contextualType = currentContextualTypeReturnTypeSymbol;
                                    }
                                }
                            }
                        }

                        resolutionContext.pushContextualType(contextualType, false, null);

                        break;

                    case 11 /* TypeRef */:
                    case 9 /* TypeParameter */:
                        resolutionContext.resolvingTypeReference = true;
                        break;
                }

                var decl = semanticInfo.getDeclForAST(current);
                if (decl && !(decl.getKind() & (1024 /* Variable */ | 2048 /* Parameter */ | 8192 /* TypeParameter */))) {
                    enclosingDecl = decl;
                    enclosingDeclAST = current;
                }
            }

            if (path.isNameOfInterface() || path.isInClassImplementsList() || path.isInInterfaceExtendsList()) {
                resolutionContext.resolvingTypeReference = true;
            }

            if (path.ast().nodeType === 20 /* Name */ && path.count() > 1) {
                for (var i = path.count() - 1; i >= 0; i--) {
                    if (path.asts[path.top - 1].nodeType === 32 /* MemberAccessExpression */ && (path.asts[path.top - 1]).operand2 === path.asts[path.top]) {
                        path.pop();
                    } else {
                        break;
                    }
                }
            }

            return {
                ast: path.ast(),
                enclosingDecl: enclosingDecl,
                resolutionContext: resolutionContext,
                inContextuallyTypedAssignment: inContextuallyTypedAssignment
            };
        };

        TypeScriptCompiler.prototype.pullGetSymbolInformationFromPath = function (path, document) {
            var context = this.extractResolutionContextFromPath(path, document);
            if (!context) {
                return null;
            }

            TypeScript.globalSemanticInfoChain = this.semanticInfoChain;
            if (TypeScript.globalBinder) {
                TypeScript.globalBinder.semanticInfoChain = this.semanticInfoChain;
            }

            var symbolAndDiagnostics = this.pullTypeChecker.resolver.resolveAST(path.ast(), context.inContextuallyTypedAssignment, context.enclosingDecl, context.resolutionContext);
            var symbol = symbolAndDiagnostics && symbolAndDiagnostics.symbol;

            return {
                symbol: symbol,
                ast: path.ast(),
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl)
            };
        };

        TypeScriptCompiler.prototype.pullGetDeclarationSymbolInformation = function (path, document) {
            var script = document.script;
            var scriptName = document.fileName;

            var ast = path.ast();

            if (ast.nodeType !== 13 /* ClassDeclaration */ && ast.nodeType !== 14 /* InterfaceDeclaration */ && ast.nodeType !== 15 /* ModuleDeclaration */ && ast.nodeType !== 12 /* FunctionDeclaration */ && ast.nodeType !== 17 /* VariableDeclarator */) {
                return null;
            }

            var context = this.extractResolutionContextFromPath(path, document);
            if (!context) {
                return null;
            }

            TypeScript.globalSemanticInfoChain = this.semanticInfoChain;
            if (TypeScript.globalBinder) {
                TypeScript.globalBinder.semanticInfoChain = this.semanticInfoChain;
            }

            var semanticInfo = this.semanticInfoChain.getUnit(scriptName);
            var decl = semanticInfo.getDeclForAST(ast);
            var symbol = (decl.getKind() & TypeScript.PullElementKind.SomeSignature) ? decl.getSignatureSymbol() : decl.getSymbol();
            this.pullTypeChecker.resolver.resolveDeclaredSymbol(symbol, null, context.resolutionContext);

            symbol.setUnresolved();

            return {
                symbol: symbol,
                ast: path.ast(),
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl)
            };
        };

        TypeScriptCompiler.prototype.pullGetCallInformationFromPath = function (path, document) {
            if (path.ast().nodeType !== 36 /* InvocationExpression */ && path.ast().nodeType !== 37 /* ObjectCreationExpression */) {
                return null;
            }

            var isNew = (path.ast().nodeType === 37 /* ObjectCreationExpression */);

            var context = this.extractResolutionContextFromPath(path, document);
            if (!context) {
                return null;
            }

            TypeScript.globalSemanticInfoChain = this.semanticInfoChain;
            if (TypeScript.globalBinder) {
                TypeScript.globalBinder.semanticInfoChain = this.semanticInfoChain;
            }

            var callResolutionResults = new TypeScript.PullAdditionalCallResolutionData();

            if (isNew) {
                this.pullTypeChecker.resolver.resolveNewExpression(path.ast(), context.inContextuallyTypedAssignment, context.enclosingDecl, context.resolutionContext, callResolutionResults);
            } else {
                this.pullTypeChecker.resolver.resolveCallExpression(path.ast(), context.inContextuallyTypedAssignment, context.enclosingDecl, context.resolutionContext, callResolutionResults);
            }

            return {
                targetSymbol: callResolutionResults.targetSymbol,
                resolvedSignatures: callResolutionResults.resolvedSignatures,
                candidateSignature: callResolutionResults.candidateSignature,
                ast: path.ast(),
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl),
                isConstructorCall: isNew
            };
        };

        TypeScriptCompiler.prototype.pullGetVisibleMemberSymbolsFromPath = function (path, document) {
            TypeScript.globalSemanticInfoChain = this.semanticInfoChain;
            if (TypeScript.globalBinder) {
                TypeScript.globalBinder.semanticInfoChain = this.semanticInfoChain;
            }

            var context = this.extractResolutionContextFromPath(path, document);
            if (!context) {
                return null;
            }

            var symbols = this.pullTypeChecker.resolver.getVisibleMembersFromExpression(path.ast(), context.enclosingDecl, context.resolutionContext);
            if (!symbols) {
                return null;
            }

            return {
                symbols: symbols,
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl)
            };
        };

        TypeScriptCompiler.prototype.pullGetVisibleDeclsFromPath = function (path, document) {
            TypeScript.globalSemanticInfoChain = this.semanticInfoChain;
            if (TypeScript.globalBinder) {
                TypeScript.globalBinder.semanticInfoChain = this.semanticInfoChain;
            }

            var context = this.extractResolutionContextFromPath(path, document);
            if (!context) {
                return null;
            }

            var symbols = null;

            return this.pullTypeChecker.resolver.getVisibleDecls(context.enclosingDecl, context.resolutionContext);
        };

        TypeScriptCompiler.prototype.pullGetContextualMembersFromPath = function (path, document) {
            TypeScript.globalSemanticInfoChain = this.semanticInfoChain;
            if (TypeScript.globalBinder) {
                TypeScript.globalBinder.semanticInfoChain = this.semanticInfoChain;
            }

            if (path.ast().nodeType !== 22 /* ObjectLiteralExpression */) {
                return null;
            }

            var context = this.extractResolutionContextFromPath(path, document);
            if (!context) {
                return null;
            }

            var members = this.pullTypeChecker.resolver.getVisibleContextSymbols(context.enclosingDecl, context.resolutionContext);

            return {
                symbols: members,
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl)
            };
        };

        TypeScriptCompiler.prototype.pullGetDeclInformation = function (decl, path, document) {
            var context = this.extractResolutionContextFromPath(path, document);
            if (!context) {
                return null;
            }

            TypeScript.globalSemanticInfoChain = this.semanticInfoChain;
            if (TypeScript.globalBinder) {
                TypeScript.globalBinder.semanticInfoChain = this.semanticInfoChain;
            }

            var symbol = decl.getSymbol();
            this.pullTypeChecker.resolver.resolveDeclaredSymbol(symbol, context.enclosingDecl, context.resolutionContext);
            symbol.setUnresolved();

            return {
                symbol: symbol,
                ast: path.ast(),
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl)
            };
        };

        TypeScriptCompiler.prototype.pullGetTypeInfoAtPosition = function (pos, document) {
            var _this = this;
            return this.timeFunction("pullGetTypeInfoAtPosition for pos " + pos + ":", function () {
                return _this.resolvePosition(pos, document);
            });
        };

        TypeScriptCompiler.prototype.getTopLevelDeclarations = function (scriptName) {
            var unit = this.semanticInfoChain.getUnit(scriptName);

            if (!unit) {
                return null;
            }

            return unit.getTopLevelDecls();
        };

        TypeScriptCompiler.prototype.reportDiagnostics = function (errors, errorReporter) {
            for (var i = 0; i < errors.length; i++) {
                errorReporter.addDiagnostic(errors[i]);
            }
        };
        return TypeScriptCompiler;
    })();
    TypeScript.TypeScriptCompiler = TypeScriptCompiler;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (CompilerDiagnostics) {
        CompilerDiagnostics.debug = false;

        CompilerDiagnostics.diagnosticWriter = null;

        CompilerDiagnostics.analysisPass = 0;

        function Alert(output) {
            if (CompilerDiagnostics.diagnosticWriter) {
                CompilerDiagnostics.diagnosticWriter.Alert(output);
            }
        }
        CompilerDiagnostics.Alert = Alert;

        function debugPrint(s) {
            if (CompilerDiagnostics.debug) {
                Alert(s);
            }
        }
        CompilerDiagnostics.debugPrint = debugPrint;

        function assert(condition, s) {
            if (CompilerDiagnostics.debug) {
                if (!condition) {
                    Alert(s);
                }
            }
        }
        CompilerDiagnostics.assert = assert;
    })(TypeScript.CompilerDiagnostics || (TypeScript.CompilerDiagnostics = {}));
    var CompilerDiagnostics = TypeScript.CompilerDiagnostics;

    var NullLogger = (function () {
        function NullLogger() {
        }
        NullLogger.prototype.information = function () {
            return false;
        };
        NullLogger.prototype.debug = function () {
            return false;
        };
        NullLogger.prototype.warning = function () {
            return false;
        };
        NullLogger.prototype.error = function () {
            return false;
        };
        NullLogger.prototype.fatal = function () {
            return false;
        };
        NullLogger.prototype.log = function (s) {
        };
        return NullLogger;
    })();
    TypeScript.NullLogger = NullLogger;

    function timeFunction(logger, funcDescription, func) {
        var start = (new Date()).getTime();
        var result = func();
        var end = (new Date()).getTime();
        logger.log(funcDescription + " completed in " + (end - start) + " msec");
        return result;
    }
    TypeScript.timeFunction = timeFunction;
})(TypeScript || (TypeScript = {}));
var IOUtils;
(function (IOUtils) {
    function createDirectoryStructure(ioHost, dirName) {
        if (ioHost.directoryExists(dirName)) {
            return;
        }

        var parentDirectory = ioHost.dirName(dirName);
        if (parentDirectory != "") {
            createDirectoryStructure(ioHost, parentDirectory);
        }
        ioHost.createDirectory(dirName);
    }

    function writeFileAndFolderStructure(ioHost, fileName, contents, writeByteOrderMark) {
        var path = ioHost.resolvePath(fileName);
        var dirName = ioHost.dirName(path);
        createDirectoryStructure(ioHost, dirName);
        return ioHost.writeFile(path, contents, writeByteOrderMark);
    }
    IOUtils.writeFileAndFolderStructure = writeFileAndFolderStructure;

    function throwIOError(message, error) {
        var errorMessage = message;
        if (error && error.message) {
            errorMessage += (" " + error.message);
        }
        throw new Error(errorMessage);
    }
    IOUtils.throwIOError = throwIOError;

    var BufferedTextWriter = (function () {
        function BufferedTextWriter(writer, capacity) {
            if (typeof capacity === "undefined") { capacity = 1024; }
            this.writer = writer;
            this.capacity = capacity;
            this.buffer = "";
        }
        BufferedTextWriter.prototype.Write = function (str) {
            this.buffer += str;
            if (this.buffer.length >= this.capacity) {
                this.writer.Write(this.buffer);
                this.buffer = "";
            }
        };
        BufferedTextWriter.prototype.WriteLine = function (str) {
            this.Write(str + '\r\n');
        };
        BufferedTextWriter.prototype.Close = function () {
            this.writer.Write(this.buffer);
            this.writer.Close();
            this.buffer = null;
        };
        return BufferedTextWriter;
    })();
    IOUtils.BufferedTextWriter = BufferedTextWriter;
})(IOUtils || (IOUtils = {}));

var IO = (function () {
    function getWindowsScriptHostIO() {
        var fso = new ActiveXObject("Scripting.FileSystemObject");
        var streamObjectPool = [];

        function getStreamObject() {
            if (streamObjectPool.length > 0) {
                return streamObjectPool.pop();
            } else {
                return new ActiveXObject("ADODB.Stream");
            }
        }

        function releaseStreamObject(obj) {
            streamObjectPool.push(obj);
        }

        var args = [];
        for (var i = 0; i < WScript.Arguments.length; i++) {
            args[i] = WScript.Arguments.Item(i);
        }

        return {
            readFile: function (path) {
                return Environment.readFile(path);
            },
            writeFile: function (path, contents, writeByteOrderMark) {
                Environment.writeFile(path, contents, writeByteOrderMark);
            },
            fileExists: function (path) {
                return fso.FileExists(path);
            },
            resolvePath: function (path) {
                return fso.GetAbsolutePathName(path);
            },
            dirName: function (path) {
                return fso.GetParentFolderName(path);
            },
            findFile: function (rootPath, partialFilePath) {
                var path = fso.GetAbsolutePathName(rootPath) + "/" + partialFilePath;

                while (true) {
                    if (fso.FileExists(path)) {
                        return { fileInformation: this.readFile(path), path: path };
                    } else {
                        rootPath = fso.GetParentFolderName(fso.GetAbsolutePathName(rootPath));

                        if (rootPath == "") {
                            return null;
                        } else {
                            path = fso.BuildPath(rootPath, partialFilePath);
                        }
                    }
                }
            },
            deleteFile: function (path) {
                try  {
                    if (fso.FileExists(path)) {
                        fso.DeleteFile(path, true);
                    }
                } catch (e) {
                    IOUtils.throwIOError("Couldn't delete file '" + path + "'.", e);
                }
            },
            directoryExists: function (path) {
                return fso.FolderExists(path);
            },
            createDirectory: function (path) {
                try  {
                    if (!this.directoryExists(path)) {
                        fso.CreateFolder(path);
                    }
                } catch (e) {
                    IOUtils.throwIOError("Couldn't create directory '" + path + "'.", e);
                }
            },
            dir: function (path, spec, options) {
                options = options || {};
                function filesInFolder(folder, root) {
                    var paths = [];
                    var fc;

                    if (options.recursive) {
                        fc = new Enumerator(folder.subfolders);

                        for (; !fc.atEnd(); fc.moveNext()) {
                            paths = paths.concat(filesInFolder(fc.item(), root + "/" + fc.item().Name));
                        }
                    }

                    fc = new Enumerator(folder.files);

                    for (; !fc.atEnd(); fc.moveNext()) {
                        if (!spec || fc.item().Name.match(spec)) {
                            paths.push(root + "/" + fc.item().Name);
                        }
                    }

                    return paths;
                }

                var folder = fso.GetFolder(path);
                var paths = [];

                return filesInFolder(folder, path);
            },
            print: function (str) {
                WScript.StdOut.Write(str);
            },
            printLine: function (str) {
                WScript.Echo(str);
            },
            arguments: args,
            stderr: WScript.StdErr,
            stdout: WScript.StdOut,
            watchFile: null,
            run: function (source, fileName) {
                try  {
                    eval(source);
                } catch (e) {
                    IOUtils.throwIOError("Error while executing file '" + fileName + "'.", e);
                }
            },
            getExecutingFilePath: function () {
                return WScript.ScriptFullName;
            },
            quit: function (exitCode) {
                if (typeof exitCode === "undefined") { exitCode = 0; }
                try  {
                    WScript.Quit(exitCode);
                } catch (e) {
                }
            }
        };
    }
    ;

    function getNodeIO() {
        var _fs = require('fs');
        var _path = require('path');
        var _module = require('module');

        return {
            readFile: function (file) {
                return Environment.readFile(file);
            },
            writeFile: function (path, contents, writeByteOrderMark) {
                Environment.writeFile(path, contents, writeByteOrderMark);
            },
            deleteFile: function (path) {
                try  {
                    _fs.unlinkSync(path);
                } catch (e) {
                    IOUtils.throwIOError("Couldn't delete file '" + path + "'.", e);
                }
            },
            fileExists: function (path) {
                return _fs.existsSync(path);
            },
            dir: function dir(path, spec, options) {
                options = options || {};

                function filesInFolder(folder) {
                    var paths = [];

                    try  {
                        var files = _fs.readdirSync(folder);
                        for (var i = 0; i < files.length; i++) {
                            var stat = _fs.statSync(folder + "/" + files[i]);
                            if (options.recursive && stat.isDirectory()) {
                                paths = paths.concat(filesInFolder(folder + "/" + files[i]));
                            } else if (stat.isFile() && (!spec || files[i].match(spec))) {
                                paths.push(folder + "/" + files[i]);
                            }
                        }
                    } catch (err) {
                    }

                    return paths;
                }

                return filesInFolder(path);
            },
            createDirectory: function (path) {
                try  {
                    if (!this.directoryExists(path)) {
                        _fs.mkdirSync(path);
                    }
                } catch (e) {
                    IOUtils.throwIOError("Couldn't create directory '" + path + "'.", e);
                }
            },
            directoryExists: function (path) {
                return _fs.existsSync(path) && _fs.statSync(path).isDirectory();
            },
            resolvePath: function (path) {
                return _path.resolve(path);
            },
            dirName: function (path) {
                return _path.dirname(path);
            },
            findFile: function (rootPath, partialFilePath) {
                var path = rootPath + "/" + partialFilePath;

                while (true) {
                    if (_fs.existsSync(path)) {
                        return { fileInformation: this.readFile(path), path: path };
                    } else {
                        var parentPath = _path.resolve(rootPath, "..");

                        if (rootPath === parentPath) {
                            return null;
                        } else {
                            rootPath = parentPath;
                            path = _path.resolve(rootPath, partialFilePath);
                        }
                    }
                }
            },
            print: function (str) {
                process.stdout.write(str);
            },
            printLine: function (str) {
                process.stdout.write(str + '\n');
            },
            arguments: process.argv.slice(2),
            stderr: {
                Write: function (str) {
                    process.stderr.write(str);
                },
                WriteLine: function (str) {
                    process.stderr.write(str + '\n');
                },
                Close: function () {
                }
            },
            stdout: {
                Write: function (str) {
                    process.stdout.write(str);
                },
                WriteLine: function (str) {
                    process.stdout.write(str + '\n');
                },
                Close: function () {
                }
            },
            watchFile: function (fileName, callback) {
                var firstRun = true;
                var processingChange = false;

                var fileChanged = function (curr, prev) {
                    if (!firstRun) {
                        if (curr.mtime < prev.mtime) {
                            return;
                        }

                        _fs.unwatchFile(fileName, fileChanged);
                        if (!processingChange) {
                            processingChange = true;
                            callback(fileName);
                            setTimeout(function () {
                                processingChange = false;
                            }, 100);
                        }
                    }
                    firstRun = false;
                    _fs.watchFile(fileName, { persistent: true, interval: 500 }, fileChanged);
                };

                fileChanged();
                return {
                    fileName: fileName,
                    close: function () {
                        _fs.unwatchFile(fileName, fileChanged);
                    }
                };
            },
            run: function (source, fileName) {
                require.main.fileName = fileName;
                require.main.paths = _module._nodeModulePaths(_path.dirname(_fs.realpathSync(fileName)));
                require.main._compile(source, fileName);
            },
            getExecutingFilePath: function () {
                return process.mainModule.filename;
            },
            quit: process.exit
        };
    }
    ;

    if (typeof ActiveXObject === "function")
        return getWindowsScriptHostIO(); else if (typeof module !== 'undefined' && module.exports)
        return getNodeIO(); else
        return null;
})();
var OptionsParser = (function () {
    function OptionsParser(host) {
        this.host = host;
        this.DEFAULT_SHORT_FLAG = "-";
        this.DEFAULT_LONG_FLAG = "--";
        this.unnamed = [];
        this.options = [];
    }
    OptionsParser.prototype.findOption = function (arg) {
        for (var i = 0; i < this.options.length; i++) {
            if (arg === this.options[i].short || arg === this.options[i].name) {
                return this.options[i];
            }
        }

        return null;
    };

    OptionsParser.prototype.printUsage = function () {
        this.host.printLine("Syntax:   tsc [options] [file ..]");
        this.host.printLine("");
        this.host.printLine("Examples: tsc hello.ts");
        this.host.printLine("          tsc --out foo.js foo.ts");
        this.host.printLine("          tsc @args.txt");
        this.host.printLine("");
        this.host.printLine("Options:");

        var output = [];
        var maxLength = 0;
        var i = 0;

        this.options = this.options.sort(function (a, b) {
            var aName = a.name.toLowerCase();
            var bName = b.name.toLowerCase();

            if (aName > bName) {
                return 1;
            } else if (aName < bName) {
                return -1;
            } else {
                return 0;
            }
        });

        for (i = 0; i < this.options.length; i++) {
            var option = this.options[i];

            if (option.experimental) {
                continue;
            }

            if (!option.usage) {
                break;
            }

            var usageString = "  ";
            var type = option.type ? " " + option.type.toUpperCase() : "";

            if (option.short) {
                usageString += this.DEFAULT_SHORT_FLAG + option.short + type + ", ";
            }

            usageString += this.DEFAULT_LONG_FLAG + option.name + type;

            output.push([usageString, option.usage]);

            if (usageString.length > maxLength) {
                maxLength = usageString.length;
            }
        }

        output.push(["  @<file>", "Insert command line options and files from a file."]);

        for (i = 0; i < output.length; i++) {
            this.host.printLine(output[i][0] + (new Array(maxLength - output[i][0].length + 3)).join(" ") + output[i][1]);
        }
    };

    OptionsParser.prototype.option = function (name, config, short) {
        if (!config) {
            config = short;
            short = null;
        }

        config.name = name;
        config.short = short;
        config.flag = false;

        this.options.push(config);
    };

    OptionsParser.prototype.flag = function (name, config, short) {
        if (!config) {
            config = short;
            short = null;
        }

        config.name = name;
        config.short = short;
        config.flag = true;

        this.options.push(config);
    };

    OptionsParser.prototype.parseString = function (argString) {
        var position = 0;
        var tokens = argString.match(/\s+|"|[^\s"]+/g);

        function peek() {
            return tokens[position];
        }

        function consume() {
            return tokens[position++];
        }

        function consumeQuotedString() {
            var value = '';
            consume();

            var token = peek();

            while (token && token !== '"') {
                consume();

                value += token;

                token = peek();
            }

            consume();

            return value;
        }

        var args = [];
        var currentArg = '';

        while (position < tokens.length) {
            var token = peek();

            if (token === '"') {
                currentArg += consumeQuotedString();
            } else if (token.match(/\s/)) {
                if (currentArg.length > 0) {
                    args.push(currentArg);
                    currentArg = '';
                }

                consume();
            } else {
                consume();
                currentArg += token;
            }
        }

        if (currentArg.length > 0) {
            args.push(currentArg);
        }

        this.parse(args);
    };

    OptionsParser.prototype.parse = function (args) {
        var position = 0;

        function consume() {
            return args[position++];
        }

        while (position < args.length) {
            var current = consume();
            var match = current.match(/^(--?|@)(.*)/);
            var value = null;

            if (match) {
                if (match[1] === '@') {
                    this.parseString(this.host.readFile(match[2]).contents());
                } else {
                    var arg = match[2];
                    var option = this.findOption(arg);

                    if (option === null) {
                        this.host.printLine("Unknown option '" + arg + "'");
                        this.host.printLine("Use the '--help' flag to see options");
                    } else {
                        if (!option.flag)
                            value = consume();

                        option.set(value);
                    }
                }
            } else {
                this.unnamed.push(current);
            }
        }
    };
    return OptionsParser;
})();
var DiagnosticsLogger = (function () {
    function DiagnosticsLogger(ioHost) {
        this.ioHost = ioHost;
    }
    DiagnosticsLogger.prototype.information = function () {
        return false;
    };
    DiagnosticsLogger.prototype.debug = function () {
        return false;
    };
    DiagnosticsLogger.prototype.warning = function () {
        return false;
    };
    DiagnosticsLogger.prototype.error = function () {
        return false;
    };
    DiagnosticsLogger.prototype.fatal = function () {
        return false;
    };
    DiagnosticsLogger.prototype.log = function (s) {
        this.ioHost.stdout.WriteLine(s);
    };
    return DiagnosticsLogger;
})();

var ErrorReporter = (function () {
    function ErrorReporter(ioHost, compilationEnvironment) {
        this.ioHost = ioHost;
        this.hasErrors = false;
        this.setCompilationEnvironment(compilationEnvironment);
    }
    ErrorReporter.prototype.addDiagnostic = function (diagnostic) {
        this.hasErrors = true;

        if (diagnostic.fileName()) {
            var soruceUnit = this.compilationEnvironment.getSourceUnit(diagnostic.fileName());
            if (!soruceUnit) {
                soruceUnit = new TypeScript.SourceUnit(diagnostic.fileName(), this.ioHost.readFile(diagnostic.fileName()));
            }
            var lineMap = new TypeScript.LineMap(soruceUnit.getLineStartPositions(), soruceUnit.getLength());
            var lineCol = { line: -1, character: -1 };
            lineMap.fillLineAndCharacterFromPosition(diagnostic.start(), lineCol);

            this.ioHost.stderr.Write(diagnostic.fileName() + "(" + (lineCol.line + 1) + "," + (lineCol.character + 1) + "): ");
        }

        this.ioHost.stderr.WriteLine(diagnostic.message());
    };

    ErrorReporter.prototype.setCompilationEnvironment = function (compilationEnvironment) {
        this.compilationEnvironment = compilationEnvironment;
    };

    ErrorReporter.prototype.reset = function () {
        this.hasErrors = false;
    };
    return ErrorReporter;
})();

var CommandLineHost = (function () {
    function CommandLineHost(compilationSettings, errorReporter) {
        this.compilationSettings = compilationSettings;
        this.errorReporter = errorReporter;
        this.pathMap = {};
        this.resolvedPaths = {};
    }
    CommandLineHost.prototype.getPathIdentifier = function (path) {
        return this.compilationSettings.useCaseSensitiveFileResolution ? path : path.toLocaleUpperCase();
    };

    CommandLineHost.prototype.isResolved = function (path) {
        return this.resolvedPaths[this.getPathIdentifier(this.pathMap[path])] != undefined;
    };

    CommandLineHost.prototype.resolveCompilationEnvironment = function (preEnv, resolver, traceDependencies) {
        var _this = this;
        var resolvedEnv = new TypeScript.CompilationEnvironment(preEnv.compilationSettings, preEnv.ioHost);

        var nCode = preEnv.code.length;
        var path = "";

        this.errorReporter.setCompilationEnvironment(resolvedEnv);

        var resolutionDispatcher = {
            errorReporter: this.errorReporter,
            postResolution: function (path, code) {
                var pathId = _this.getPathIdentifier(path);
                if (!_this.resolvedPaths[pathId]) {
                    resolvedEnv.code.push(code);
                    _this.resolvedPaths[pathId] = true;
                }
            }
        };

        for (var i = 0; i < nCode; i++) {
            path = TypeScript.switchToForwardSlashes(preEnv.ioHost.resolvePath(preEnv.code[i].path));
            this.pathMap[preEnv.code[i].path] = path;
            resolver.resolveCode(path, "", false, resolutionDispatcher);
        }

        return resolvedEnv;
    };
    return CommandLineHost;
})();

var BatchCompiler = (function () {
    function BatchCompiler(ioHost) {
        this.ioHost = ioHost;
        this.resolvedEnvironment = null;
        this.hasResolveErrors = false;
        this.compilerVersion = "0.9.0.0";
        this.printedVersion = false;
        this.errorReporter = null;
        this.compilationSettings = new TypeScript.CompilationSettings();
        this.compilationEnvironment = new TypeScript.CompilationEnvironment(this.compilationSettings, this.ioHost);
        this.errorReporter = new ErrorReporter(this.ioHost, this.compilationEnvironment);
    }
    BatchCompiler.prototype.resolve = function () {
        var resolver = new TypeScript.CodeResolver(this.compilationEnvironment);
        var commandLineHost = new CommandLineHost(this.compilationSettings, this.errorReporter);
        var ret = commandLineHost.resolveCompilationEnvironment(this.compilationEnvironment, resolver, true);

        for (var i = 0; i < this.compilationEnvironment.code.length; i++) {
            if (!commandLineHost.isResolved(this.compilationEnvironment.code[i].path)) {
                var path = this.compilationEnvironment.code[i].path;
                if (!TypeScript.isTSFile(path) && !TypeScript.isDTSFile(path)) {
                    this.errorReporter.addDiagnostic(new TypeScript.Diagnostic(null, 0, 0, 269 /* Unknown_extension_for_file___0__Only__ts_and_d_ts_extensions_are_allowed */, [path]));
                } else {
                    this.errorReporter.addDiagnostic(new TypeScript.Diagnostic(null, 0, 0, 268 /* Could_not_find_file___0_ */, [path]));
                }
            }
        }

        return ret;
    };

    BatchCompiler.prototype.compile = function () {
        var _this = this;
        if (typeof localizedDiagnosticMessages === "undefined") {
            localizedDiagnosticMessages = null;
        }

        var logger = this.compilationSettings.gatherDiagnostics ? new DiagnosticsLogger(this.ioHost) : new TypeScript.NullLogger();
        var compiler = new TypeScript.TypeScriptCompiler(logger, this.compilationSettings, localizedDiagnosticMessages);

        var anySyntacticErrors = false;
        var anySemanticErrors = false;

        for (var iCode = 0; iCode < this.resolvedEnvironment.code.length; iCode++) {
            var code = this.resolvedEnvironment.code[iCode];

            if (!this.compilationSettings.resolve) {
                code.fileInformation = this.ioHost.readFile(code.path);

                if (this.compilationSettings.generateDeclarationFiles) {
                    TypeScript.CompilerDiagnostics.assert(code.referencedFiles === null, "With no resolve option, referenced files need to null");
                    code.referencedFiles = TypeScript.getReferencedFiles(code.path, code);
                }
            }

            if (code.fileInformation != null) {
                compiler.addSourceUnit(code.path, TypeScript.ScriptSnapshot.fromString(code.fileInformation.contents()), code.fileInformation.byteOrderMark(), 0, false, code.referencedFiles);

                var syntacticDiagnostics = compiler.getSyntacticDiagnostics(code.path);
                compiler.reportDiagnostics(syntacticDiagnostics, this.errorReporter);

                if (syntacticDiagnostics.length > 0) {
                    anySyntacticErrors = true;
                }
            }
        }

        if (anySyntacticErrors) {
            return true;
        }

        compiler.pullTypeCheck();
        var fileNames = compiler.fileNameToDocument.getAllKeys();

        for (var i = 0, n = fileNames.length; i < n; i++) {
            var fileName = fileNames[i];
            var semanticDiagnostics = compiler.getSemanticDiagnostics(fileName);
            if (semanticDiagnostics.length > 0) {
                anySemanticErrors = true;
                compiler.reportDiagnostics(semanticDiagnostics, this.errorReporter);
            }
        }

        var emitterIOHost = {
            writeFile: function (fileName, contents, writeByteOrderMark) {
                return IOUtils.writeFileAndFolderStructure(_this.ioHost, fileName, contents, writeByteOrderMark);
            },
            directoryExists: this.ioHost.directoryExists,
            fileExists: this.ioHost.fileExists,
            resolvePath: this.ioHost.resolvePath
        };

        var mapInputToOutput = function (inputFile, outputFile) {
            _this.resolvedEnvironment.inputFileNameToOutputFileName.addOrUpdate(inputFile, outputFile);
        };

        var emitDiagnostics = compiler.emitAll(emitterIOHost, mapInputToOutput);
        compiler.reportDiagnostics(emitDiagnostics, this.errorReporter);
        if (emitDiagnostics.length > 0) {
            return true;
        }

        if (anySemanticErrors) {
            return true;
        }

        var emitDeclarationsDiagnostics = compiler.emitAllDeclarations();
        compiler.reportDiagnostics(emitDeclarationsDiagnostics, this.errorReporter);
        if (emitDeclarationsDiagnostics.length > 0) {
            return true;
        }

        return false;
    };

    BatchCompiler.prototype.updateCompile = function () {
        if (typeof localizedDiagnosticMessages === "undefined") {
            localizedDiagnosticMessages = null;
        }

        var logger = this.compilationSettings.gatherDiagnostics ? new DiagnosticsLogger(this.ioHost) : new TypeScript.NullLogger();
        var compiler = new TypeScript.TypeScriptCompiler(logger, this.compilationSettings, localizedDiagnosticMessages);

        var anySyntacticErrors = false;
        var foundLib = false;

        for (var iCode = 0; iCode <= this.resolvedEnvironment.code.length; iCode++) {
            var code = this.resolvedEnvironment.code[iCode];

            if (code.path.indexOf("lib.d.ts") != -1) {
                foundLib = true;
            } else if ((foundLib && iCode > 1) || (!foundLib && iCode > 0)) {
                break;
            }

            this.ioHost.stdout.WriteLine("Consuming " + this.resolvedEnvironment.code[iCode].path + "...");

            if (!this.compilationSettings.resolve) {
                code.fileInformation = this.ioHost.readFile(code.path);

                if (this.compilationSettings.generateDeclarationFiles) {
                    TypeScript.CompilerDiagnostics.assert(code.referencedFiles === null, "With no resolve option, referenced files need to null");
                    code.referencedFiles = TypeScript.getReferencedFiles(code.path, code);
                }
            }

            if (code.fileInformation != null) {
                compiler.addSourceUnit(code.path, TypeScript.ScriptSnapshot.fromString(code.fileInformation.contents()), code.fileInformation.byteOrderMark(), 0, true, code.referencedFiles);

                var syntacticDiagnostics = compiler.getSyntacticDiagnostics(code.path);
                compiler.reportDiagnostics(syntacticDiagnostics, this.errorReporter);

                if (syntacticDiagnostics.length > 0) {
                    anySyntacticErrors = true;
                }
            }
        }

        this.ioHost.stdout.WriteLine("**** Initial type check errors:");
        compiler.pullTypeCheck();

        var semanticDiagnostics;

        for (var i = 0; i < iCode; i++) {
            semanticDiagnostics = compiler.getSemanticDiagnostics(this.resolvedEnvironment.code[i].path);
            compiler.reportDiagnostics(semanticDiagnostics, this.errorReporter);
        }

        if (iCode && iCode <= this.resolvedEnvironment.code.length - 1) {
            var lastTypecheckedFileName = this.resolvedEnvironment.code[iCode - 1].path;
            var snapshot;

            for (; iCode < this.resolvedEnvironment.code.length; iCode++) {
                this.ioHost.stdout.WriteLine("**** Update type check and errors for " + this.resolvedEnvironment.code[iCode].path + ":");
                var text = this.resolvedEnvironment.code[iCode].getText(0, this.resolvedEnvironment.code[iCode].getLength());
                snapshot = TypeScript.ScriptSnapshot.fromString(text);
                compiler.updateSourceUnit(lastTypecheckedFileName, snapshot, 0, true, null);

                semanticDiagnostics = compiler.getSemanticDiagnostics(lastTypecheckedFileName);
                compiler.reportDiagnostics(semanticDiagnostics, this.errorReporter);
            }
        }

        return false;
    };

    BatchCompiler.prototype.run = function () {
        for (var i in this.resolvedEnvironment.code) {
            var outputFileName = this.resolvedEnvironment.inputFileNameToOutputFileName.lookup(this.resolvedEnvironment.code[i].path) || undefined;
            if (this.ioHost.fileExists(outputFileName)) {
                var unitRes = this.ioHost.readFile(outputFileName);
                this.ioHost.run(unitRes.contents(), outputFileName);
            }
        }
    };

    BatchCompiler.prototype.batchCompile = function () {
        var _this = this;
        TypeScript.CompilerDiagnostics.diagnosticWriter = { Alert: function (s) {
                _this.ioHost.printLine(s);
            } };

        var code;

        var opts = new OptionsParser(this.ioHost);

        opts.option('out', {
            usage: 'Concatenate and emit output to single file | Redirect output structure to the directory',
            type: 'file|directory',
            set: function (str) {
                _this.compilationSettings.outputOption = str;
            }
        });

        opts.flag('sourcemap', {
            usage: 'Generates corresponding .map file',
            set: function () {
                _this.compilationSettings.mapSourceFiles = true;
            }
        });

        opts.flag('fullSourceMapPath', {
            usage: 'Writes the full path of map file in the generated js file',
            experimental: true,
            set: function () {
                _this.compilationSettings.emitFullSourceMapPath = true;
            }
        });

        opts.flag('declaration', {
            usage: 'Generates corresponding .d.ts file',
            set: function () {
                _this.compilationSettings.generateDeclarationFiles = true;
            }
        }, 'd');

        if (this.ioHost.watchFile) {
            opts.flag('watch', {
                usage: 'Watch input files',
                set: function () {
                    _this.compilationSettings.watch = true;
                }
            }, 'w');
        }

        opts.flag('exec', {
            usage: 'Execute the script after compilation',
            set: function () {
                _this.compilationSettings.exec = true;
            }
        }, 'e');

        opts.flag('minw', {
            usage: 'Minimize whitespace',
            experimental: true,
            set: function () {
                _this.compilationSettings.minWhitespace = true;
            }
        }, 'mw');

        opts.flag('const', {
            usage: 'Propagate constants to emitted code',
            experimental: true,
            set: function () {
                _this.compilationSettings.propagateConstants = true;
            }
        });

        opts.flag('comments', {
            usage: 'Emit comments to output',
            set: function () {
                _this.compilationSettings.emitComments = true;
            }
        }, 'c');

        opts.flag('noresolve', {
            usage: 'Skip resolution and preprocessing',
            experimental: true,
            set: function () {
                _this.compilationSettings.resolve = false;
            }
        });

        opts.flag('debug', {
            usage: 'Print debug output',
            experimental: true,
            set: function () {
                TypeScript.CompilerDiagnostics.debug = true;
            }
        });

        opts.flag('nolib', {
            usage: 'Do not include a default lib.d.ts with global declarations',
            set: function () {
                _this.compilationSettings.useDefaultLib = false;
            }
        });

        opts.flag('diagnostics', {
            usage: 'gather diagnostic info about the compilation process',
            experimental: true,
            set: function () {
                _this.compilationSettings.gatherDiagnostics = true;
            }
        });

        opts.flag('update', {
            usage: 'Typecheck each file as an update on the first',
            experimental: true,
            set: function () {
                _this.compilationSettings.updateTC = true;
            }
        });

        opts.option('target', {
            usage: 'Specify ECMAScript target version: "ES3" (default), or "ES5"',
            type: 'VER',
            set: function (type) {
                type = type.toLowerCase();

                if (type === 'es3') {
                    _this.compilationSettings.codeGenTarget = 0 /* EcmaScript3 */;
                } else if (type === 'es5') {
                    _this.compilationSettings.codeGenTarget = 1 /* EcmaScript5 */;
                } else {
                    _this.errorReporter.addDiagnostic(new TypeScript.Diagnostic(null, 0, 0, 266 /* ECMAScript_target_version__0__not_supported___Using_default__1__code_generation */, [type, "ES3"]));
                }
            }
        });

        opts.option('module', {
            usage: 'Specify module code generation: "commonjs" (default) or "amd"',
            type: 'kind',
            set: function (type) {
                type = type.toLowerCase();

                if (type === 'commonjs' || type === 'node') {
                    _this.compilationSettings.moduleGenTarget = 0 /* Synchronous */;
                } else if (type === 'amd') {
                    _this.compilationSettings.moduleGenTarget = 1 /* Asynchronous */;
                } else {
                    _this.errorReporter.addDiagnostic(new TypeScript.Diagnostic(null, 0, 0, 267 /* Module_code_generation__0__not_supported___Using_default__1__code_generation */, [type, "commonjs"]));
                }
            }
        });

        var printedUsage = false;

        opts.flag('help', {
            usage: 'Print this message',
            set: function () {
                _this.printVersion();
                opts.printUsage();
                printedUsage = true;
            }
        }, 'h');

        opts.flag('useCaseSensitiveFileResolution', {
            usage: 'Force file resolution to be case sensitive',
            experimental: true,
            set: function () {
                _this.compilationSettings.useCaseSensitiveFileResolution = true;
            }
        });

        opts.flag('version', {
            usage: 'Print the compiler\'s version: ' + this.compilerVersion,
            set: function () {
                _this.printVersion();
            }
        }, 'v');

        opts.flag('disallowbool', {
            usage: 'Throw error for use of deprecated "bool" type',
            set: function () {
                _this.compilationSettings.disallowBool = true;
            }
        }, 'b');

        opts.flag('disallowimportmodule', {
            usage: 'Throw error for use of deprecated "module" keyword when referencing an external module. Only allow "require" keyword.',
            set: function () {
                _this.compilationSettings.allowModuleKeywordInExternalModuleReference = false;
            }
        }, 'm');

        opts.parse(this.ioHost.arguments);

        if (this.compilationSettings.useDefaultLib) {
            var compilerFilePath = this.ioHost.getExecutingFilePath();
            var binDirPath = this.ioHost.dirName(compilerFilePath);
            var libStrPath = this.ioHost.resolvePath(binDirPath + "/lib.d.ts");
            code = new TypeScript.SourceUnit(libStrPath, null);
            this.compilationEnvironment.code.push(code);
        }

        for (var i = 0; i < opts.unnamed.length; i++) {
            code = new TypeScript.SourceUnit(opts.unnamed[i], null);
            this.compilationEnvironment.code.push(code);
        }

        if (this.compilationEnvironment.code.length === (this.compilationSettings.useDefaultLib ? 1 : 0)) {
            if (!printedUsage && !this.printedVersion) {
                this.printVersion();
                opts.printUsage();
                this.ioHost.quit(1);
            }
            return;
        }

        if (this.compilationSettings.watch) {
            this.watchFiles(this.compilationEnvironment.code.slice(0));
        } else {
            this.resolvedEnvironment = this.compilationSettings.resolve ? this.resolve() : this.compilationEnvironment;

            if (!this.compilationSettings.updateTC) {
                this.compile();
            } else {
                this.updateCompile();
            }

            if (!this.errorReporter.hasErrors) {
                if (this.compilationSettings.exec) {
                    this.run();
                }
            }

            this.ioHost.quit(this.errorReporter.hasErrors ? 1 : 0);
        }
    };

    BatchCompiler.prototype.printVersion = function () {
        if (!this.printedVersion) {
            this.ioHost.printLine("Version " + this.compilerVersion);
            this.printedVersion = true;
        }
    };

    BatchCompiler.prototype.watchFiles = function (sourceFiles) {
        var _this = this;
        if (!this.ioHost.watchFile) {
            this.errorReporter.addDiagnostic(new TypeScript.SemanticDiagnostic(null, 0, 0, 265 /* Current_host_does_not_support__w_atch_option */, null));
            return;
        }

        var resolvedFiles = [];
        var watchers = {};
        var firstTime = true;

        var addWatcher = function (fileName) {
            if (!watchers[fileName]) {
                var watcher = _this.ioHost.watchFile(fileName, onWatchedFileChange);
                watchers[fileName] = watcher;
            } else {
                TypeScript.CompilerDiagnostics.debugPrint("Cannot watch file, it is already watched.");
            }
        };

        var removeWatcher = function (fileName) {
            if (watchers[fileName]) {
                watchers[fileName].close();
                delete watchers[fileName];
            } else {
                TypeScript.CompilerDiagnostics.debugPrint("Cannot stop watching file, it is not being watched.");
            }
        };

        var onWatchedFileChange = function () {
            _this.compilationEnvironment.code = sourceFiles;

            _this.errorReporter.reset();

            _this.resolvedEnvironment = _this.compilationSettings.resolve ? _this.resolve() : _this.compilationEnvironment;

            var oldFiles = resolvedFiles;
            var newFiles = [];
            _this.resolvedEnvironment.code.forEach(function (sf) {
                return newFiles.push(sf.path);
            });
            newFiles = newFiles.sort();

            var i = 0, j = 0;
            while (i < oldFiles.length && j < newFiles.length) {
                var compareResult = oldFiles[i].localeCompare(newFiles[j]);
                if (compareResult === 0) {
                    i++;
                    j++;
                } else if (compareResult < 0) {
                    removeWatcher(oldFiles[i]);
                    i++;
                } else {
                    addWatcher(newFiles[j]);
                    j++;
                }
            }

            for (var k = i; k < oldFiles.length; k++) {
                removeWatcher(oldFiles[k]);
            }

            for (k = j; k < newFiles.length; k++) {
                addWatcher(newFiles[k]);
            }

            resolvedFiles = newFiles;

            if (!firstTime) {
                _this.ioHost.printLine("");
                _this.ioHost.printLine("Recompiling (" + new Date() + "): ");
                resolvedFiles.forEach(function (f) {
                    return _this.ioHost.printLine("    " + f);
                });
            }

            _this.compile();

            if (!_this.errorReporter.hasErrors && _this.compilationSettings.exec) {
                try  {
                    _this.run();
                } catch (e) {
                    if (e.stack) {
                        _this.ioHost.stderr.WriteLine('\n' + e.stack);
                    }
                }
            }

            firstTime = false;
        };

        this.ioHost.stderr = this.ioHost.stdout;
        onWatchedFileChange();
    };
    return BatchCompiler;
})();

var batch = new BatchCompiler(IO);
batch.batchCompile();
