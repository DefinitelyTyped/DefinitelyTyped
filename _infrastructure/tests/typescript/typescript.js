/*! *****************************************************************************
Copyright (c) Microsoft Corporation. All rights reserved. 
Licensed under the Apache License, Version 2.0 (the "License"); you may not use
this file except in compliance with the License. You may obtain a copy of the
License at http://www.apache.org/licenses/LICENSE-2.0  
 
THIS CODE IS PROVIDED ON AN *AS IS* BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
KIND, EITHER EXPRESS OR IMPLIED, INCLUDING WITHOUT LIMITATION ANY IMPLIED
WARRANTIES OR CONDITIONS OF TITLE, FITNESS FOR A PARTICULAR PURPOSE, 
MERCHANTABLITY OR NON-INFRINGEMENT. 
 
See the Apache Version 2.0 License for specific language governing permissions
and limitations under the License.
***************************************************************************** */

var TypeScript;
(function (TypeScript) {
    TypeScript.DiagnosticCode = {
        error_TS_0_1: "error TS{0}: {1}",
        warning_TS_0_1: "warning TS{0}: {1}",
        Unrecognized_escape_sequence: "Unrecognized escape sequence.",
        Unexpected_character_0: "Unexpected character {0}.",
        Missing_close_quote_character: "Missing close quote character.",
        Identifier_expected: "Identifier expected.",
        _0_keyword_expected: "'{0}' keyword expected.",
        _0_expected: "'{0}' expected.",
        Identifier_expected_0_is_a_keyword: "Identifier expected; '{0}' is a keyword.",
        Automatic_semicolon_insertion_not_allowed: "Automatic semicolon insertion not allowed.",
        Unexpected_token_0_expected: "Unexpected token; '{0}' expected.",
        Trailing_separator_not_allowed: "Trailing separator not allowed.",
        AsteriskSlash_expected: "'*/' expected.",
        public_or_private_modifier_must_precede_static: "'public' or 'private' modifier must precede 'static'.",
        Unexpected_token: "Unexpected token.",
        Catch_clause_parameter_cannot_have_a_type_annotation: "Catch clause parameter cannot have a type annotation.",
        Rest_parameter_must_be_last_in_list: "Rest parameter must be last in list.",
        Parameter_cannot_have_question_mark_and_initializer: "Parameter cannot have question mark and initializer.",
        Required_parameter_cannot_follow_optional_parameter: "Required parameter cannot follow optional parameter.",
        Index_signatures_cannot_have_rest_parameters: "Index signatures cannot have rest parameters.",
        Index_signature_parameter_cannot_have_accessibility_modifiers: "Index signature parameter cannot have accessibility modifiers.",
        Index_signature_parameter_cannot_have_a_question_mark: "Index signature parameter cannot have a question mark.",
        Index_signature_parameter_cannot_have_an_initializer: "Index signature parameter cannot have an initializer.",
        Index_signature_must_have_a_type_annotation: "Index signature must have a type annotation.",
        Index_signature_parameter_must_have_a_type_annotation: "Index signature parameter must have a type annotation.",
        Index_signature_parameter_type_must_be_string_or_number: "Index signature parameter type must be 'string' or 'number'.",
        extends_clause_already_seen: "'extends' clause already seen.",
        extends_clause_must_precede_implements_clause: "'extends' clause must precede 'implements' clause.",
        Classes_can_only_extend_a_single_class: "Classes can only extend a single class.",
        implements_clause_already_seen: "'implements' clause already seen.",
        Accessibility_modifier_already_seen: "Accessibility modifier already seen.",
        _0_modifier_must_precede_1_modifier: "'{0}' modifier must precede '{1}' modifier.",
        _0_modifier_already_seen: "'{0}' modifier already seen.",
        _0_modifier_cannot_appear_on_a_class_element: "'{0}' modifier cannot appear on a class element.",
        Interface_declaration_cannot_have_implements_clause: "Interface declaration cannot have 'implements' clause.",
        super_invocation_cannot_have_type_arguments: "'super' invocation cannot have type arguments.",
        Only_ambient_modules_can_use_quoted_names: "Only ambient modules can use quoted names.",
        Statements_are_not_allowed_in_ambient_contexts: "Statements are not allowed in ambient contexts.",
        Implementations_are_not_allowed_in_ambient_contexts: "Implementations are not allowed in ambient contexts.",
        declare_modifier_not_allowed_for_code_already_in_an_ambient_context: "'declare' modifier not allowed for code already in an ambient context.",
        Initializers_are_not_allowed_in_ambient_contexts: "Initializers are not allowed in ambient contexts.",
        Parameter_property_declarations_can_only_be_used_in_constructors: "Parameter property declarations can only be used in constructors.",
        Function_implementation_expected: "Function implementation expected.",
        Constructor_implementation_expected: "Constructor implementation expected.",
        Function_overload_name_must_be_0: "Function overload name must be '{0}'.",
        _0_modifier_cannot_appear_on_a_module_element: "'{0}' modifier cannot appear on a module element.",
        declare_modifier_cannot_appear_on_an_interface_declaration: "'declare' modifier cannot appear on an interface declaration.",
        declare_modifier_required_for_top_level_element: "'declare' modifier required for top level element.",
        Rest_parameter_cannot_be_optional: "Rest parameter cannot be optional.",
        Rest_parameter_cannot_have_an_initializer: "Rest parameter cannot have an initializer.",
        set_accessor_must_have_one_and_only_one_parameter: "'set' accessor must have one and only one parameter.",
        set_accessor_parameter_cannot_have_accessibility_modifier: "'set' accessor parameter cannot have accessibility modifier.",
        set_accessor_parameter_cannot_be_optional: "'set' accessor parameter cannot be optional.",
        set_accessor_parameter_cannot_have_an_initializer: "'set' accessor parameter cannot have an initializer.",
        set_accessor_cannot_have_rest_parameter: "'set' accessor cannot have rest parameter.",
        get_accessor_cannot_have_parameters: "'get' accessor cannot have parameters.",
        Modifiers_cannot_appear_here: "Modifiers cannot appear here.",
        Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher: "Accessors are only available when targeting ECMAScript 5 and higher.",
        Class_name_cannot_be_0: "Class name cannot be '{0}'.",
        Interface_name_cannot_be_0: "Interface name cannot be '{0}'.",
        Enum_name_cannot_be_0: "Enum name cannot be '{0}'.",
        Module_name_cannot_be_0: "Module name cannot be '{0}'.",
        Enum_member_must_have_initializer: "Enum member must have initializer.",
        Export_assignment_cannot_be_used_in_internal_modules: "Export assignment cannot be used in internal modules.",
        Export_assignment_not_allowed_in_module_with_exported_element: "Export assignment not allowed in module with exported element.",
        Module_cannot_have_multiple_export_assignments: "Module cannot have multiple export assignments.",
        Ambient_enum_elements_can_only_have_integer_literal_initializers: "Ambient enum elements can only have integer literal initializers.",
        module_class_interface_enum_import_or_statement: "module, class, interface, enum, import or statement",
        constructor_function_accessor_or_variable: "constructor, function, accessor or variable",
        statement: "statement",
        case_or_default_clause: "case or default clause",
        identifier: "identifier",
        call_construct_index_property_or_function_signature: "call, construct, index, property or function signature",
        expression: "expression",
        type_name: "type name",
        property_or_accessor: "property or accessor",
        parameter: "parameter",
        type: "type",
        type_parameter: "type parameter",
        declare_modifier_not_allowed_on_import_declaration: "'declare' modifier not allowed on import declaration.",
        Function_overload_must_be_static: "Function overload must be static",
        Function_overload_must_not_be_static: "Function overload must not be static",
        Parameter_property_declarations_cannot_be_used_in_an_ambient_context: "Parameter property declarations cannot be used in an ambient context.",
        Parameter_property_declarations_cannot_be_used_in_a_constructor_overload: "Parameter property declarations cannot be used in a constructor overload.",
        Duplicate_identifier_0: "Duplicate identifier '{0}'.",
        The_name_0_does_not_exist_in_the_current_scope: "The name '{0}' does not exist in the current scope.",
        The_name_0_does_not_refer_to_a_value: "The name '{0}' does not refer to a value.",
        super_can_only_be_used_inside_a_class_instance_method: "'super' can only be used inside a class instance method.",
        The_left_hand_side_of_an_assignment_expression_must_be_a_variable_property_or_indexer: "The left-hand side of an assignment expression must be a variable, property or indexer.",
        Value_of_type_0_is_not_callable_Did_you_mean_to_include_new: "Value of type '{0}' is not callable. Did you mean to include 'new'?",
        Value_of_type_0_is_not_callable: "Value of type '{0}' is not callable.",
        Value_of_type_0_is_not_newable: "Value of type '{0}' is not newable.",
        Value_of_type_0_is_not_indexable_by_type_1: "Value of type '{0}' is not indexable by type '{1}'.",
        Operator_0_cannot_be_applied_to_types_1_and_2: "Operator '{0}' cannot be applied to types '{1}' and '{2}'.",
        Operator_0_cannot_be_applied_to_types_1_and_2_3: "Operator '{0}' cannot be applied to types '{1}' and '{2}': {3}",
        Cannot_convert_0_to_1: "Cannot convert '{0}' to '{1}'.",
        Cannot_convert_0_to_1_NL_2: "Cannot convert '{0}' to '{1}':{NL}{2}",
        Expected_var_class_interface_or_module: "Expected var, class, interface, or module.",
        Operator_0_cannot_be_applied_to_type_1: "Operator '{0}' cannot be applied to type '{1}'.",
        Getter_0_already_declared: "Getter '{0}' already declared.",
        Setter_0_already_declared: "Setter '{0}' already declared.",
        Accessors_cannot_have_type_parameters: "Accessors cannot have type parameters.",
        Exported_class_0_extends_private_class_1: "Exported class '{0}' extends private class '{1}'.",
        Exported_class_0_implements_private_interface_1: "Exported class '{0}' implements private interface '{1}'.",
        Exported_interface_0_extends_private_interface_1: "Exported interface '{0}' extends private interface '{1}'.",
        Exported_class_0_extends_class_from_inaccessible_module_1: "Exported class '{0}' extends class from inaccessible module {1}.",
        Exported_class_0_implements_interface_from_inaccessible_module_1: "Exported class '{0}' implements interface from inaccessible module {1}.",
        Exported_interface_0_extends_interface_from_inaccessible_module_1: "Exported interface '{0}' extends interface from inaccessible module {1}.",
        Public_static_property_0_of_exported_class_has_or_is_using_private_type_1: "Public static property '{0}' of exported class has or is using private type '{1}'.",
        Public_property_0_of_exported_class_has_or_is_using_private_type_1: "Public property '{0}' of exported class has or is using private type '{1}'.",
        Property_0_of_exported_interface_has_or_is_using_private_type_1: "Property '{0}' of exported interface has or is using private type '{1}'.",
        Exported_variable_0_has_or_is_using_private_type_1: "Exported variable '{0}' has or is using private type '{1}'.",
        Public_static_property_0_of_exported_class_is_using_inaccessible_module_1: "Public static property '{0}' of exported class is using inaccessible module {1}.",
        Public_property_0_of_exported_class_is_using_inaccessible_module_1: "Public property '{0}' of exported class is using inaccessible module {1}.",
        Property_0_of_exported_interface_is_using_inaccessible_module_1: "Property '{0}' of exported interface is using inaccessible module {1}.",
        Exported_variable_0_is_using_inaccessible_module_1: "Exported variable '{0}' is using inaccessible module {1}.",
        Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_type_1: "Parameter '{0}' of constructor from exported class has or is using private type '{1}'.",
        Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_private_type_1: "Parameter '{0}' of public static property setter from exported class has or is using private type '{1}'.",
        Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_private_type_1: "Parameter '{0}' of public property setter from exported class has or is using private type '{1}'.",
        Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_type_1: "Parameter '{0}' of constructor signature from exported interface has or is using private type '{1}'.",
        Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_type_1: "Parameter '{0}' of call signature from exported interface has or is using private type '{1}'.",
        Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_type_1: "Parameter '{0}' of public static method from exported class has or is using private type '{1}'.",
        Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_type_1: "Parameter '{0}' of public method from exported class has or is using private type '{1}'.",
        Parameter_0_of_method_from_exported_interface_has_or_is_using_private_type_1: "Parameter '{0}' of method from exported interface has or is using private type '{1}'.",
        Parameter_0_of_exported_function_has_or_is_using_private_type_1: "Parameter '{0}' of exported function has or is using private type '{1}'.",
        Parameter_0_of_constructor_from_exported_class_is_using_inaccessible_module_1: "Parameter '{0}' of constructor from exported class is using inaccessible module {1}.",
        Parameter_0_of_public_static_property_setter_from_exported_class_is_using_inaccessible_module_1: "Parameter '{0}' of public static property setter from exported class is using inaccessible module {1}.",
        Parameter_0_of_public_property_setter_from_exported_class_is_using_inaccessible_module_1: "Parameter '{0}' of public property setter from exported class is using inaccessible module {1}.",
        Parameter_0_of_constructor_signature_from_exported_interface_is_using_inaccessible_module_1: "Parameter '{0}' of constructor signature from exported interface is using inaccessible module {1}.",
        Parameter_0_of_call_signature_from_exported_interface_is_using_inaccessible_module_1: "Parameter '{0}' of call signature from exported interface is using inaccessible module {1}",
        Parameter_0_of_public_static_method_from_exported_class_is_using_inaccessible_module_1: "Parameter '{0}' of public static method from exported class is using inaccessible module {1}.",
        Parameter_0_of_public_method_from_exported_class_is_using_inaccessible_module_1: "Parameter '{0}' of public method from exported class is using inaccessible module {1}.",
        Parameter_0_of_method_from_exported_interface_is_using_inaccessible_module_1: "Parameter '{0}' of method from exported interface is using inaccessible module {1}.",
        Parameter_0_of_exported_function_is_using_inaccessible_module_1: "Parameter '{0}' of exported function is using inaccessible module {1}.",
        Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_private_type_0: "Return type of public static property getter from exported class has or is using private type '{0}'.",
        Return_type_of_public_property_getter_from_exported_class_has_or_is_using_private_type_0: "Return type of public property getter from exported class has or is using private type '{0}'.",
        Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_type_0: "Return type of constructor signature from exported interface has or is using private type '{0}'.",
        Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_type_0: "Return type of call signature from exported interface has or is using private type '{0}'.",
        Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_type_0: "Return type of index signature from exported interface has or is using private type '{0}'.",
        Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_type_0: "Return type of public static method from exported class has or is using private type '{0}'.",
        Return_type_of_public_method_from_exported_class_has_or_is_using_private_type_0: "Return type of public method from exported class has or is using private type '{0}'.",
        Return_type_of_method_from_exported_interface_has_or_is_using_private_type_0: "Return type of method from exported interface has or is using private type '{0}'.",
        Return_type_of_exported_function_has_or_is_using_private_type_0: "Return type of exported function has or is using private type '{0}'.",
        Return_type_of_public_static_property_getter_from_exported_class_is_using_inaccessible_module_0: "Return type of public static property getter from exported class is using inaccessible module {0}.",
        Return_type_of_public_property_getter_from_exported_class_is_using_inaccessible_module_0: "Return type of public property getter from exported class is using inaccessible module {0}.",
        Return_type_of_constructor_signature_from_exported_interface_is_using_inaccessible_module_0: "Return type of constructor signature from exported interface is using inaccessible module {0}.",
        Return_type_of_call_signature_from_exported_interface_is_using_inaccessible_module_0: "Return type of call signature from exported interface is using inaccessible module {0}.",
        Return_type_of_index_signature_from_exported_interface_is_using_inaccessible_module_0: "Return type of index signature from exported interface is using inaccessible module {0}.",
        Return_type_of_public_static_method_from_exported_class_is_using_inaccessible_module_0: "Return type of public static method from exported class is using inaccessible module {0}.",
        Return_type_of_public_method_from_exported_class_is_using_inaccessible_module_0: "Return type of public method from exported class is using inaccessible module {0}.",
        Return_type_of_method_from_exported_interface_is_using_inaccessible_module_0: "Return type of method from exported interface is using inaccessible module {0}.",
        Return_type_of_exported_function_is_using_inaccessible_module_0: "Return type of exported function is using inaccessible module {0}.",
        new_T_cannot_be_used_to_create_an_array_Use_new_Array_T_instead: "'new T[]' cannot be used to create an array. Use 'new Array<T>()' instead.",
        A_parameter_list_must_follow_a_generic_type_argument_list_expected: "A parameter list must follow a generic type argument list. '(' expected.",
        Multiple_constructor_implementations_are_not_allowed: "Multiple constructor implementations are not allowed.",
        Unable_to_resolve_external_module_0: "Unable to resolve external module '{0}'.",
        Module_cannot_be_aliased_to_a_non_module_type: "Module cannot be aliased to a non-module type.",
        A_class_may_only_extend_another_class: "A class may only extend another class.",
        A_class_may_only_implement_another_class_or_interface: "A class may only implement another class or interface.",
        An_interface_may_only_extend_another_class_or_interface: "An interface may only extend another class or interface.",
        An_interface_cannot_implement_another_type: "An interface cannot implement another type.",
        Unable_to_resolve_type: "Unable to resolve type.",
        Unable_to_resolve_type_of_0: "Unable to resolve type of '{0}'.",
        Unable_to_resolve_type_parameter_constraint: "Unable to resolve type parameter constraint.",
        Type_parameter_constraint_cannot_be_a_primitive_type: "Type parameter constraint cannot be a primitive type.",
        Supplied_parameters_do_not_match_any_signature_of_call_target: "Supplied parameters do not match any signature of call target.",
        Supplied_parameters_do_not_match_any_signature_of_call_target_NL_0: "Supplied parameters do not match any signature of call target:{NL}{0}",
        Invalid_new_expression: "Invalid 'new' expression.",
        Call_signatures_used_in_a_new_expression_must_have_a_void_return_type: "Call signatures used in a 'new' expression must have a 'void' return type.",
        Could_not_select_overload_for_new_expression: "Could not select overload for 'new' expression.",
        Type_0_does_not_satisfy_the_constraint_1_for_type_parameter_2: "Type '{0}' does not satisfy the constraint '{1}' for type parameter '{2}'.",
        Could_not_select_overload_for_call_expression: "Could not select overload for 'call' expression.",
        Cannot_invoke_an_expression_whose_type_lacks_a_call_signature: "Cannot invoke an expression whose type lacks a call signature.",
        Calls_to_super_are_only_valid_inside_a_class: "Calls to 'super' are only valid inside a class.",
        Generic_type_0_requires_1_type_argument_s: "Generic type '{0}' requires {1} type argument(s).",
        Type_of_conditional_expression_cannot_be_determined_Best_common_type_could_not_be_found_between_0_and_1: "Type of conditional expression cannot be determined. Best common type could not be found between '{0}' and '{1}'.",
        Type_of_array_literal_cannot_be_determined_Best_common_type_could_not_be_found_for_array_elements: "Type of array literal cannot be determined. Best common type could not be found for array elements.",
        Could_not_find_enclosing_symbol_for_dotted_name_0: "Could not find enclosing symbol for dotted name '{0}'.",
        The_property_0_does_not_exist_on_value_of_type_1: "The property '{0}' does not exist on value of type '{1}'.",
        Could_not_find_symbol_0: "Could not find symbol '{0}'.",
        get_and_set_accessor_must_have_the_same_type: "'get' and 'set' accessor must have the same type.",
        this_cannot_be_referenced_in_current_location: "'this' cannot be referenced in current location.",
        Static_methods_cannot_reference_class_type_parameters: "Static methods cannot reference class type parameters.",
        Class_0_is_recursively_referenced_as_a_base_type_of_itself: "Class '{0}' is recursively referenced as a base type of itself.",
        Interface_0_is_recursively_referenced_as_a_base_type_of_itself: "Interface '{0}' is recursively referenced as a base type of itself.",
        super_property_access_is_permitted_only_in_a_constructor_instance_member_function_or_instance_member_accessor_of_a_derived_class: "'super' property access is permitted only in a constructor, instance member function, or instance member accessor of a derived class.",
        super_cannot_be_referenced_in_non_derived_classes: "'super' cannot be referenced in non-derived classes.",
        A_super_call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_initialized_properties_or_has_parameter_properties: "A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.",
        Constructors_for_derived_classes_must_contain_a_super_call: "Constructors for derived classes must contain a 'super' call.",
        Super_calls_are_not_permitted_outside_constructors_or_in_local_functions_inside_constructors: "Super calls are not permitted outside constructors or in local functions inside constructors.",
        _0_1_is_inaccessible: "'{0}.{1}' is inaccessible.",
        this_cannot_be_referenced_within_module_bodies: "'this' cannot be referenced within module bodies.",
        Invalid_expression_types_not_known_to_support_the_addition_operator: "Invalid '+' expression - types not known to support the addition operator.",
        The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type: "The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.",
        The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type: "The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.",
        The_type_of_a_unary_arithmetic_operation_operand_must_be_of_type_any_number_or_an_enum_type: "The type of a unary arithmetic operation operand must be of type 'any', 'number' or an enum type.",
        Variable_declarations_of_a_for_statement_cannot_use_a_type_annotation: "Variable declarations of a 'for' statement cannot use a type annotation.",
        Variable_declarations_of_a_for_statement_must_be_of_types_string_or_any: "Variable declarations of a 'for' statement must be of types 'string' or 'any'.",
        The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter: "The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter.",
        The_left_hand_side_of_an_in_expression_must_be_of_types_string_or_any: "The left-hand side of an 'in' expression must be of types 'string' or 'any'.",
        The_right_hand_side_of_an_in_expression_must_be_of_type_any_an_object_type_or_a_type_parameter: "The right-hand side of an 'in' expression must be of type 'any', an object type or a type parameter.",
        The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter: "The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter.",
        The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_a_subtype_of_the_Function_interface_type: "The right-hand side of an 'instanceof' expression must be of type 'any' or a subtype of the 'Function' interface type.",
        Setters_cannot_return_a_value: "Setters cannot return a value.",
        Tried_to_query_type_of_uninitialized_module_0: "Tried to query type of uninitialized module '{0}'.",
        Tried_to_set_variable_type_to_uninitialized_module_type_0: "Tried to set variable type to uninitialized module type '{0}'.",
        Function_0_declared_a_non_void_return_type_but_has_no_return_expression: "Function '{0}' declared a non-void return type, but has no return expression.",
        Getters_must_return_a_value: "Getters must return a value.",
        Getter_and_setter_accessors_do_not_agree_in_visibility: "Getter and setter accessors do not agree in visibility.",
        Invalid_left_hand_side_of_assignment_expression: "Invalid left-hand side of assignment expression.",
        Function_declared_a_non_void_return_type_but_has_no_return_expression: "Function declared a non-void return type, but has no return expression.",
        Cannot_resolve_return_type_reference: "Cannot resolve return type reference.",
        Constructors_cannot_have_a_return_type_of_void: "Constructors cannot have a return type of 'void'.",
        Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2: "Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'.",
        All_symbols_within_a_with_block_will_be_resolved_to_any: "All symbols within a with block will be resolved to 'any'.",
        Import_declarations_in_an_internal_module_cannot_reference_an_external_module: "Import declarations in an internal module cannot reference an external module.",
        Class_0_declares_interface_1_but_does_not_implement_it_NL_2: "Class {0} declares interface {1} but does not implement it:{NL}{2}",
        Class_0_declares_class_1_as_an_interface_but_does_not_implement_it_NL_2: "Class {0} declares class {1} as an interface but does not implement it:{NL}{2}",
        The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_property_or_indexer: "The operand of an increment or decrement operator must be a variable, property or indexer.",
        this_cannot_be_referenced_in_static_initializers_in_a_class_body: "'this' cannot be referenced in static initializers in a class body.",
        Class_0_cannot_extend_class_1_NL_2: "Class '{0}' cannot extend class '{1}':{NL}{2}",
        Interface_0_cannot_extend_class_1_NL_2: "Interface '{0}' cannot extend class '{1}':{NL}{2}",
        Interface_0_cannot_extend_interface_1_NL_2: "Interface '{0}' cannot extend interface '{1}':{NL}{2}",
        Duplicate_overload_signature_for_0: "Duplicate overload signature for '{0}'.",
        Duplicate_constructor_overload_signature: "Duplicate constructor overload signature.",
        Duplicate_overload_call_signature: "Duplicate overload call signature.",
        Duplicate_overload_construct_signature: "Duplicate overload construct signature.",
        Overload_signature_is_not_compatible_with_function_definition: "Overload signature is not compatible with function definition.",
        Overload_signature_is_not_compatible_with_function_definition_NL_0: "Overload signature is not compatible with function definition:{NL}{0}",
        Overload_signatures_must_all_be_public_or_private: "Overload signatures must all be public or private.",
        Overload_signatures_must_all_be_exported_or_local: "Overload signatures must all be exported or local.",
        Overload_signatures_must_all_be_ambient_or_non_ambient: "Overload signatures must all be ambient or non-ambient.",
        Overload_signatures_must_all_be_optional_or_required: "Overload signatures must all be optional or required.",
        Specialized_overload_signature_is_not_subtype_of_any_non_specialized_signature: "Specialized overload signature is not subtype of any non-specialized signature.",
        this_cannot_be_referenced_in_constructor_arguments: "'this' cannot be referenced in constructor arguments.",
        Static_member_cannot_be_accessed_off_an_instance_variable: "Static member cannot be accessed off an instance variable.",
        Instance_member_cannot_be_accessed_off_a_class: "Instance member cannot be accessed off a class.",
        Untyped_function_calls_may_not_accept_type_arguments: "Untyped function calls may not accept type arguments.",
        Non_generic_functions_may_not_accept_type_arguments: "Non-generic functions may not accept type arguments.",
        A_generic_type_may_not_reference_itself_with_a_wrapped_form_of_its_own_type_parameters: "A generic type may not reference itself with a wrapped form of its own type parameters.",
        Rest_parameters_must_be_array_types: "Rest parameters must be array types.",
        Overload_signature_implementation_cannot_use_specialized_type: "Overload signature implementation cannot use specialized type.",
        Export_assignments_may_only_be_used_at_the_top_level_of_external_modules: "Export assignments may only be used at the top-level of external modules.",
        Export_assignments_may_only_be_made_with_variables_functions_classes_interfaces_enums_and_internal_modules: "Export assignments may only be made with variables, functions, classes, interfaces, enums and internal modules",
        Only_public_instance_methods_of_the_base_class_are_accessible_via_the_super_keyword: "Only public instance methods of the base class are accessible via the 'super' keyword.",
        Numeric_indexer_type_0_must_be_a_subtype_of_string_indexer_type_1: "Numeric indexer type '{0}' must be a subtype of string indexer type '{1}'.",
        Numeric_indexer_type_0_must_be_a_subtype_of_string_indexer_type_1_NL_2: "Numeric indexer type '{0}' must be a subtype of string indexer type '{1}':{NL}{2}",
        All_numerically_named_properties_must_be_subtypes_of_numeric_indexer_type_0: "All numerically named properties must be subtypes of numeric indexer type '{0}'.",
        All_numerically_named_properties_must_be_subtypes_of_numeric_indexer_type_0_NL_1: "All numerically named properties must be subtypes of numeric indexer type '{0}':{NL}{1}",
        All_named_properties_must_be_subtypes_of_string_indexer_type_0: "All named properties must be subtypes of string indexer type '{0}'.",
        All_named_properties_must_be_subtypes_of_string_indexer_type_0_NL_1: "All named properties must be subtypes of string indexer type '{0}':{NL}{1}",
        Generic_type_references_must_include_all_type_arguments: "Generic type references must include all type arguments.",
        Default_arguments_are_not_allowed_in_an_overload_parameter: "Default arguments are not allowed in an overload parameter.",
        Overloads_cannot_differ_only_by_return_type: "Overloads cannot differ only by return type.",
        Function_expression_declared_a_non_void_return_type_but_has_no_return_expression: "Function expression declared a non-void return type, but has no return expression.",
        Import_declaration_referencing_identifier_from_internal_module_can_only_be_made_with_variables_functions_classes_interfaces_enums_and_internal_modules: "Import declaration referencing identifier from internal module can only be made with variables, functions, classes, interfaces, enums and internal modules.",
        Could_not_find_symbol_0_in_module_1: "Could not find symbol '{0}' in module '{1}'.",
        Unable_to_resolve_module_reference_0: "Unable to resolve module reference '{0}'.",
        Could_not_find_module_0_in_module_1: "Could not find module '{0}' in module '{1}'.",
        Exported_import_declaration_0_is_assigned_value_with_type_that_has_or_is_using_private_type_1: "Exported import declaration '{0}' is assigned value with type that has or is using private type '{1}'.",
        Exported_import_declaration_0_is_assigned_value_with_type_that_is_using_inaccessible_module_1: "Exported import declaration '{0}' is assigned value with type that is using inaccessible module '{1}'.",
        Exported_import_declaration_0_is_assigned_type_that_has_or_is_using_private_type_1: "Exported import declaration '{0}' is assigned type that has or is using private type '{1}'.",
        Exported_import_declaration_0_is_assigned_type_that_is_using_inaccessible_module_1: "Exported import declaration '{0}' is assigned type that is using inaccessible module '{1}'.",
        Exported_import_declaration_0_is_assigned_container_that_is_or_is_using_inaccessible_module_1: "Exported import declaration '{0}' is assigned container that is or is using inaccessible module '{1}'.",
        Type_reference_0_in_extends_clause_doesn_t_reference_constructor_function_for_1: "Type reference '{0}' in extends clause doesn't reference constructor function for '{1}'.",
        Internal_module_reference_0_in_import_declaration_doesn_t_reference_module_instance_for_1: "Internal module reference '{0}' in import declaration doesn't reference module instance for '{1}'.",
        Type_0_is_missing_property_1_from_type_2: "Type '{0}' is missing property '{1}' from type '{2}'.",
        Types_of_property_0_of_types_1_and_2_are_incompatible: "Types of property '{0}' of types '{1}' and '{2}' are incompatible.",
        Types_of_property_0_of_types_1_and_2_are_incompatible_NL_3: "Types of property '{0}' of types '{1}' and '{2}' are incompatible:{NL}{3}",
        Property_0_defined_as_private_in_type_1_is_defined_as_public_in_type_2: "Property '{0}' defined as private in type '{1}' is defined as public in type '{2}'.",
        Property_0_defined_as_public_in_type_1_is_defined_as_private_in_type_2: "Property '{0}' defined as public in type '{1}' is defined as private in type '{2}'.",
        Types_0_and_1_define_property_2_as_private: "Types '{0}' and '{1}' define property '{2}' as private.",
        Call_signatures_of_types_0_and_1_are_incompatible: "Call signatures of types '{0}' and '{1}' are incompatible.",
        Call_signatures_of_types_0_and_1_are_incompatible_NL_2: "Call signatures of types '{0}' and '{1}' are incompatible:{NL}{2}",
        Type_0_requires_a_call_signature_but_type_1_lacks_one: "Type '{0}' requires a call signature, but type '{1}' lacks one.",
        Construct_signatures_of_types_0_and_1_are_incompatible: "Construct signatures of types '{0}' and '{1}' are incompatible.",
        Construct_signatures_of_types_0_and_1_are_incompatible_NL_2: "Construct signatures of types '{0}' and '{1}' are incompatible:{NL}{2}",
        Type_0_requires_a_construct_signature_but_type_1_lacks_one: "Type '{0}' requires a construct signature, but type '{1}' lacks one.",
        Index_signatures_of_types_0_and_1_are_incompatible: "Index signatures of types '{0}' and '{1}' are incompatible.",
        Index_signatures_of_types_0_and_1_are_incompatible_NL_2: "Index signatures of types '{0}' and '{1}' are incompatible:{NL}{2}",
        Call_signature_expects_0_or_fewer_parameters: "Call signature expects {0} or fewer parameters.",
        Could_not_apply_type_0_to_argument_1_which_is_of_type_2: "Could not apply type '{0}' to argument {1} which is of type '{2}'.",
        Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function: "Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function.",
        Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function: "Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function.",
        Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor: "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor.",
        Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_property: "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member property.",
        Types_of_static_property_0_of_class_1_and_class_2_are_incompatible: "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible.",
        Types_of_static_property_0_of_class_1_and_class_2_are_incompatible_NL_3: "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible:{NL}{3}",
        Type_reference_cannot_refer_to_container_0: "Type reference cannot refer to container '{0}'.",
        Type_reference_must_refer_to_type: "Type reference must refer to type.",
        Enums_with_multiple_declarations_must_provide_an_initializer_for_the_first_enum_element: "Enums with multiple declarations must provide an initializer for the first enum element.",
        _0_overload_s: " (+ {0} overload(s))",
        Current_host_does_not_support_0_option: "Current host does not support '{0}' option.",
        ECMAScript_target_version_0_not_supported_Using_default_1_code_generation: "ECMAScript target version '{0}' not supported.  Using default '{1}' code generation.",
        Module_code_generation_0_not_supported: "Module code generation '{0}' not supported.",
        Could_not_find_file_0: "Could not find file: '{0}'.",
        A_file_cannot_have_a_reference_to_itself: "A file cannot have a reference to itself.",
        Cannot_resolve_referenced_file_0: "Cannot resolve referenced file: '{0}'.",
        Cannot_find_the_common_subdirectory_path_for_the_input_files: "Cannot find the common subdirectory path for the input files.",
        Emit_Error_0: "Emit Error: {0}.",
        Cannot_read_file_0_1: "Cannot read file '{0}': {1}",
        Unsupported_file_encoding: "Unsupported file encoding.",
        Locale_must_be_of_the_form_language_or_language_territory_For_example_0_or_1: "Locale must be of the form <language> or <language>-<territory>. For example '{0}' or '{1}'.",
        Unsupported_locale_0: "Unsupported locale: '{0}'.",
        Execution_Failed_NL: "Execution Failed.{NL}",
        Should_not_emit_a_type_query: "Should not emit a type query",
        Should_not_emit_a_type_reference: "Should not emit a type reference",
        Invalid_call_to_up: "Invalid call to 'up'",
        Invalid_call_to_down: "Invalid call to 'down'",
        Base64_value_0_finished_with_a_continuation_bit: "Base64 value '{0}' finished with a continuation bit",
        Key_was_already_in_table: "Key was already in table",
        Unknown_option_0: "Unknown option '{0}'",
        Expected_0_arguments_to_message_got_1_instead: "Expected {0} arguments to message, got {1} instead",
        Expected_the_message_0_to_have_1_arguments_but_it_had_2: "Expected the message '{0}' to have {1} arguments, but it had {2}",
        Invalid_argument_0_1: "Invalid argument: {0}. {1}",
        Invalid_argument_0: "Invalid argument: {0}.",
        Argument_out_of_range_0: "Argument out of range: {0}.",
        Argument_null_0: "Argument null: {0}.",
        Operation_not_implemented_properly_by_subclass: "Operation not implemented properly by subclass.",
        Not_yet_implemented: "Not yet implemented.",
        Invalid_operation_0: "Invalid operation: {0}",
        Invalid_operation: "Invalid operation.",
        Could_not_delete_file_0: "Could not delete file '{0}'",
        Could_not_create_directory_0: "Could not create directory '{0}'",
        Error_while_executing_file_0: "Error while executing file '{0}': ",
        Cannot_compile_external_modules_unless_the_module_flag_is_provided: "Cannot compile external modules unless the '--module' flag is provided.",
        Option_mapRoot_cannot_be_specified_without_specifying_sourcemap_option: "Option mapRoot cannot be specified without specifying sourcemap option.",
        Option_sourceRoot_cannot_be_specified_without_specifying_sourcemap_option: "Option sourceRoot cannot be specified without specifying sourcemap option.",
        Options_mapRoot_and_sourceRoot_cannot_be_specified_without_specifying_sourcemap_option: "Options mapRoot and sourceRoot cannot be specified without specifying sourcemap option.",
        Concatenate_and_emit_output_to_single_file: "Concatenate and emit output to single file",
        Generates_corresponding_0_file: "Generates corresponding {0} file",
        Specifies_the_location_where_debugger_should_locate_map_files_instead_of_generated_locations: "Specifies the location where debugger should locate map files instead of generated locations.",
        Specifies_the_location_where_debugger_should_locate_TypeScript_files_instead_of_source_locations: "Specifies the location where debugger should locate TypeScript files instead of source locations.",
        Watch_input_files: "Watch input files",
        Redirect_output_structure_to_the_directory: "Redirect output structure to the directory",
        Do_not_emit_comments_to_output: "Do not emit comments to output",
        Skip_resolution_and_preprocessing: "Skip resolution and preprocessing",
        Specify_ECMAScript_target_version_0_default_or_1: "Specify ECMAScript target version: \"{0}\" (default), or \"{1}\"",
        Specify_module_code_generation_0_or_1: "Specify module code generation: \"{0}\" or \"{1}\"",
        Print_this_message: "Print this message",
        Print_the_compiler_s_version_0: "Print the compiler's version: {0}",
        Allow_use_of_deprecated_0_keyword_when_referencing_an_external_module: "Allow use of deprecated \"{0}\" keyword when referencing an external module",
        Specify_locale_for_errors_and_messages_For_example_0_or_1: "Specify locale for errors and messages. For example '{0}' or '{1}'",
        Syntax_0: "Syntax:   {0}",
        options: "options",
        file: "file",
        Examples: "Examples:",
        Options: "Options:",
        Insert_command_line_options_and_files_from_a_file: "Insert command line options and files from a file.",
        Version_0: "Version {0}",
        Use_the_0_flag_to_see_options: "Use the '{0}' flag to see options",
        NL_Recompiling_0: "{NL}Recompiling ({0}):",
        STRING: "STRING",
        KIND: "KIND",
        FILE: "FILE",
        VERSION: "VERSION",
        LOCATION: "LOCATION",
        DIRECTORY: "DIRECTORY",
        This_version_of_the_Javascript_runtime_does_not_support_the_0_function: "This version of the Javascript runtime does not support the '{0}' function.",
        Looking_up_path_for_identifier_token_did_not_result_in_an_identifer: "Looking up path for identifier token did not result in an identifer.",
        Unknown_rule: "Unknown rule",
        Invalid_line_number_0: "Invalid line number ({0})",
        Warn_on_expressions_and_declarations_with_an_implied_any_type: "Warn on expressions and declarations with an implied 'any' type.",
        Variable_0_implicitly_has_an_any_type: "Variable '{0}' implicitly has an 'any' type.",
        Parameter_0_of_1_implicitly_has_an_any_type: "Parameter '{0}' of '{1}' implicitly has an 'any' type.",
        Parameter_0_of_function_type_implicitly_has_an_any_type: "Parameter '{0}' of function type implicitly has an 'any' type.",
        Member_0_of_object_type_implicitly_has_an_any_type: "Member '{0}' of object type implicitly has an 'any' type.",
        New_expression_which_lacks_a_constructor_signature_implicitly_has_an_any_type: "\"New\" expression, which lacks a constructor signature, implicitly has an 'any' type.",
        _0_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: "'{0}', which lacks return-type annotation, implicitly has an 'any' return type.",
        Function_expression_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: "Function expression, which lacks return-type annotation, implicitly has an 'any' return type.",
        Parameter_0_of_lambda_function_implicitly_has_an_any_type: "Parameter '{0}' of lambda function implicitly has an 'any' type.",
        Constructor_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: "Constructor signature, which lacks return-type annotation, implicitly has an 'any' return type.",
        Lambda_Function_which_lacks_return_type_annotation_implicitly_has_an_any_return_type: "Lambda Function, which lacks return-type annotation, implicitly has an 'any' return type.",
        Array_Literal_implicitly_has_an_any_type_from_widening: "Array Literal implicitly has an 'any' type from widening."
    };
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var ArrayUtilities = (function () {
        function ArrayUtilities() {
        }
        ArrayUtilities.isArray = function (value) {
            return Object.prototype.toString.apply(value, []) === '[object Array]';
        };

        ArrayUtilities.sequenceEquals = function (array1, array2, equals) {
            if (array1 === array2) {
                return true;
            }

            if (array1 === null || array2 === null) {
                return false;
            }

            if (array1.length !== array2.length) {
                return false;
            }

            for (var i = 0, n = array1.length; i < n; i++) {
                if (!equals(array1[i], array2[i])) {
                    return false;
                }
            }

            return true;
        };

        ArrayUtilities.contains = function (array, value) {
            for (var i = 0; i < array.length; i++) {
                if (array[i] === value) {
                    return true;
                }
            }

            return false;
        };

        ArrayUtilities.groupBy = function (array, func) {
            var result = {};

            for (var i = 0, n = array.length; i < n; i++) {
                var v = array[i];
                var k = func(v);

                var list = result[k] || [];
                list.push(v);
                result[k] = list;
            }

            return result;
        };

        ArrayUtilities.min = function (array, func) {
            var min = func(array[0]);

            for (var i = 1; i < array.length; i++) {
                var next = func(array[i]);
                if (next < min) {
                    min = next;
                }
            }

            return min;
        };

        ArrayUtilities.max = function (array, func) {
            var max = func(array[0]);

            for (var i = 1; i < array.length; i++) {
                var next = func(array[i]);
                if (next > max) {
                    max = next;
                }
            }

            return max;
        };

        ArrayUtilities.last = function (array) {
            if (array.length === 0) {
                throw TypeScript.Errors.argumentOutOfRange('array');
            }

            return array[array.length - 1];
        };

        ArrayUtilities.firstOrDefault = function (array, func) {
            for (var i = 0, n = array.length; i < n; i++) {
                var value = array[i];
                if (func(value)) {
                    return value;
                }
            }

            return null;
        };

        ArrayUtilities.sum = function (array, func) {
            var result = 0;

            for (var i = 0, n = array.length; i < n; i++) {
                result += func(array[i]);
            }

            return result;
        };

        ArrayUtilities.whereNotNull = function (array) {
            var result = [];
            for (var i = 0; i < array.length; i++) {
                var value = array[i];
                if (value !== null) {
                    result.push(value);
                }
            }

            return result;
        };

        ArrayUtilities.select = function (values, func) {
            var result = new Array(values.length);

            for (var i = 0; i < values.length; i++) {
                result[i] = func(values[i]);
            }

            return result;
        };

        ArrayUtilities.where = function (values, func) {
            var result = new Array();

            for (var i = 0; i < values.length; i++) {
                if (func(values[i])) {
                    result.push(values[i]);
                }
            }

            return result;
        };

        ArrayUtilities.any = function (array, func) {
            for (var i = 0, n = array.length; i < n; i++) {
                if (func(array[i])) {
                    return true;
                }
            }

            return false;
        };

        ArrayUtilities.all = function (array, func) {
            for (var i = 0, n = array.length; i < n; i++) {
                if (!func(array[i])) {
                    return false;
                }
            }

            return true;
        };

        ArrayUtilities.binarySearch = function (array, value) {
            var low = 0;
            var high = array.length - 1;

            while (low <= high) {
                var middle = low + ((high - low) >> 1);
                var midValue = array[middle];

                if (midValue === value) {
                    return middle;
                } else if (midValue > value) {
                    high = middle - 1;
                } else {
                    low = middle + 1;
                }
            }

            return ~low;
        };

        ArrayUtilities.createArray = function (length, defaultValue) {
            var result = new Array(length);
            for (var i = 0; i < length; i++) {
                result[i] = defaultValue;
            }

            return result;
        };

        ArrayUtilities.grow = function (array, length, defaultValue) {
            var count = length - array.length;
            for (var i = 0; i < count; i++) {
                array.push(defaultValue);
            }
        };

        ArrayUtilities.copy = function (sourceArray, sourceIndex, destinationArray, destinationIndex, length) {
            for (var i = 0; i < length; i++) {
                destinationArray[destinationIndex + i] = sourceArray[sourceIndex + i];
            }
        };
        return ArrayUtilities;
    })();
    TypeScript.ArrayUtilities = ArrayUtilities;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Constants) {
        Constants[Constants["Max31BitInteger"] = 1073741823] = "Max31BitInteger";
        Constants[Constants["Min31BitInteger"] = -1073741824] = "Min31BitInteger";
    })(TypeScript.Constants || (TypeScript.Constants = {}));
    var Constants = TypeScript.Constants;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Debug = (function () {
        function Debug() {
        }
        Debug.assert = function (expression, message) {
            if (!expression) {
                throw new Error("Debug Failure. False expression: " + (message ? message : ""));
            }
        };
        return Debug;
    })();
    TypeScript.Debug = Debug;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Errors = (function () {
        function Errors() {
        }
        Errors.argument = function (argument, message) {
            return new Error(message ? TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Invalid_argument_0_1, [argument, message]) : TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Invalid_argument_0, [argument]));
        };

        Errors.argumentOutOfRange = function (argument) {
            return new Error(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Argument_out_of_range_0, [argument]));
        };

        Errors.argumentNull = function (argument) {
            return new Error(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Argument_null_0, [argument]));
        };

        Errors.abstract = function () {
            return new Error(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Operation_not_implemented_properly_by_subclass, null));
        };

        Errors.notYetImplemented = function () {
            return new Error(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Not_yet_implemented, null));
        };

        Errors.invalidOperation = function (message) {
            return new Error(message ? TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Invalid_operation_0, [message]) : TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Invalid_operation, null));
        };
        return Errors;
    })();
    TypeScript.Errors = Errors;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Hash = (function () {
        function Hash() {
        }
        Hash.computeFnv1aCharArrayHashCode = function (text, start, len) {
            var hashCode = Hash.FNV_BASE;
            var end = start + len;

            for (var i = start; i < end; i++) {
                hashCode = TypeScript.IntegerUtilities.integerMultiplyLow32Bits(hashCode ^ text[i], Hash.FNV_PRIME);
            }

            return hashCode;
        };

        Hash.computeSimple31BitCharArrayHashCode = function (key, start, len) {
            var hash = 0;

            for (var i = 0; i < len; i++) {
                var ch = key[start + i];

                hash = ((((hash << 5) - hash) | 0) + ch) | 0;
            }

            return hash & 0x7FFFFFFF;
        };

        Hash.computeSimple31BitStringHashCode = function (key) {
            var hash = 0;

            var start = 0;
            var len = key.length;

            for (var i = 0; i < len; i++) {
                var ch = key.charCodeAt(start + i);

                hash = ((((hash << 5) - hash) | 0) + ch) | 0;
            }

            return hash & 0x7FFFFFFF;
        };

        Hash.computeMurmur2StringHashCode = function (key, seed) {
            var m = 0x5bd1e995;
            var r = 24;

            var numberOfCharsLeft = key.length;
            var h = Math.abs(seed ^ numberOfCharsLeft);

            var index = 0;
            while (numberOfCharsLeft >= 2) {
                var c1 = key.charCodeAt(index);
                var c2 = key.charCodeAt(index + 1);

                var k = Math.abs(c1 | (c2 << 16));

                k = TypeScript.IntegerUtilities.integerMultiplyLow32Bits(k, m);
                k ^= k >> r;
                k = TypeScript.IntegerUtilities.integerMultiplyLow32Bits(k, m);

                h = TypeScript.IntegerUtilities.integerMultiplyLow32Bits(h, m);
                h ^= k;

                index += 2;
                numberOfCharsLeft -= 2;
            }

            if (numberOfCharsLeft == 1) {
                h ^= key.charCodeAt(index);
                h = TypeScript.IntegerUtilities.integerMultiplyLow32Bits(h, m);
            }

            h ^= h >> 13;
            h = TypeScript.IntegerUtilities.integerMultiplyLow32Bits(h, m);
            h ^= h >> 15;

            return h;
        };

        Hash.getPrime = function (min) {
            for (var i = 0; i < Hash.primes.length; i++) {
                var num = Hash.primes[i];
                if (num >= min) {
                    return num;
                }
            }

            throw TypeScript.Errors.notYetImplemented();
        };

        Hash.expandPrime = function (oldSize) {
            var num = oldSize << 1;
            if (num > 2146435069 && 2146435069 > oldSize) {
                return 2146435069;
            }
            return Hash.getPrime(num);
        };

        Hash.combine = function (value, currentHash) {
            return (((currentHash << 5) + currentHash) + value) & 0x7FFFFFFF;
        };
        Hash.FNV_BASE = 2166136261;
        Hash.FNV_PRIME = 16777619;

        Hash.primes = [
            3,
            7,
            11,
            17,
            23,
            29,
            37,
            47,
            59,
            71,
            89,
            107,
            131,
            163,
            197,
            239,
            293,
            353,
            431,
            521,
            631,
            761,
            919,
            1103,
            1327,
            1597,
            1931,
            2333,
            2801,
            3371,
            4049,
            4861,
            5839,
            7013,
            8419,
            10103,
            12143,
            14591,
            17519,
            21023,
            25229,
            30293,
            36353,
            43627,
            52361,
            62851,
            75431,
            90523,
            108631,
            130363,
            156437,
            187751,
            225307,
            270371,
            324449,
            389357,
            467237,
            560689,
            672827,
            807403,
            968897,
            1162687,
            1395263,
            1674319,
            2009191,
            2411033,
            2893249,
            3471899,
            4166287,
            4999559,
            5999471,
            7199369
        ];
        return Hash;
    })();
    TypeScript.Hash = Hash;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Collections) {
        Collections.DefaultHashTableCapacity = 1024;

        var HashTableEntry = (function () {
            function HashTableEntry(Key, Value, HashCode, Next) {
                this.Key = Key;
                this.Value = Value;
                this.HashCode = HashCode;
                this.Next = Next;
            }
            return HashTableEntry;
        })();

        var HashTable = (function () {
            function HashTable(capacity, hash) {
                this.hash = hash;
                this.count = 0;
                var size = TypeScript.Hash.getPrime(capacity);
                this.entries = TypeScript.ArrayUtilities.createArray(size, null);
            }
            HashTable.prototype.set = function (key, value) {
                this.addOrSet(key, value, false);
            };

            HashTable.prototype.add = function (key, value) {
                this.addOrSet(key, value, true);
            };

            HashTable.prototype.containsKey = function (key) {
                var hashCode = this.computeHashCode(key);
                var entry = this.findEntry(key, hashCode);
                return entry !== null;
            };

            HashTable.prototype.get = function (key) {
                var hashCode = this.computeHashCode(key);
                var entry = this.findEntry(key, hashCode);

                return entry === null ? null : entry.Value;
            };

            HashTable.prototype.computeHashCode = function (key) {
                var hashCode = this.hash === null ? (key).hashCode : this.hash(key);

                hashCode = hashCode & 0x7FFFFFFF;
                TypeScript.Debug.assert(hashCode >= 0);

                return hashCode;
            };

            HashTable.prototype.addOrSet = function (key, value, throwOnExistingEntry) {
                var hashCode = this.computeHashCode(key);

                var entry = this.findEntry(key, hashCode);
                if (entry !== null) {
                    if (throwOnExistingEntry) {
                        throw TypeScript.Errors.argument('key', TypeScript.getLocalizedText(TypeScript.DiagnosticCode.Key_was_already_in_table, null));
                    }

                    entry.Key = key;
                    entry.Value = value;
                    return;
                }

                return this.addEntry(key, value, hashCode);
            };

            HashTable.prototype.findEntry = function (key, hashCode) {
                for (var e = this.entries[hashCode % this.entries.length]; e !== null; e = e.Next) {
                    if (e.HashCode === hashCode && key === e.Key) {
                        return e;
                    }
                }

                return null;
            };

            HashTable.prototype.addEntry = function (key, value, hashCode) {
                var index = hashCode % this.entries.length;

                var e = new HashTableEntry(key, value, hashCode, this.entries[index]);

                this.entries[index] = e;

                if (this.count >= (this.entries.length / 2)) {
                    this.grow();
                }

                this.count++;
                return e.Key;
            };

            HashTable.prototype.grow = function () {
                var newSize = TypeScript.Hash.expandPrime(this.entries.length);

                var oldEntries = this.entries;
                var newEntries = TypeScript.ArrayUtilities.createArray(newSize, null);

                this.entries = newEntries;

                for (var i = 0; i < oldEntries.length; i++) {
                    var e = oldEntries[i];

                    while (e !== null) {
                        var newIndex = e.HashCode % newSize;
                        var tmp = e.Next;
                        e.Next = newEntries[newIndex];
                        newEntries[newIndex] = e;
                        e = tmp;
                    }
                }
            };
            return HashTable;
        })();
        Collections.HashTable = HashTable;

        function createHashTable(capacity, hash) {
            if (typeof capacity === "undefined") { capacity = Collections.DefaultHashTableCapacity; }
            if (typeof hash === "undefined") { hash = null; }
            return new HashTable(capacity, hash);
        }
        Collections.createHashTable = createHashTable;

        var currentHashCode = 1;
        function identityHashCode(value) {
            if (value.__hash === undefined) {
                value.__hash = currentHashCode;
                currentHashCode++;
            }

            return value.__hash;
        }
        Collections.identityHashCode = identityHashCode;
    })(TypeScript.Collections || (TypeScript.Collections = {}));
    var Collections = TypeScript.Collections;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.LocalizedDiagnosticMessages = null;

    function newLine() {
        return Environment ? Environment.newLine : "\r\n";
    }
    TypeScript.newLine = newLine;

    var Diagnostic = (function () {
        function Diagnostic(fileName, start, length, diagnosticKey, arguments) {
            if (typeof arguments === "undefined") { arguments = null; }
            this._diagnosticKey = diagnosticKey;
            this._arguments = (arguments && arguments.length > 0) ? arguments : null;
            this._fileName = fileName;
            this._start = start;
            this._length = length;
        }
        Diagnostic.prototype.toJSON = function (key) {
            var result = {};
            result.start = this.start();
            result.length = this.length();

            result.diagnosticCode = this._diagnosticKey;

            var arguments = (this).arguments();
            if (arguments && arguments.length > 0) {
                result.arguments = arguments;
            }

            return result;
        };

        Diagnostic.prototype.fileName = function () {
            return this._fileName;
        };

        Diagnostic.prototype.start = function () {
            return this._start;
        };

        Diagnostic.prototype.length = function () {
            return this._length;
        };

        Diagnostic.prototype.diagnosticKey = function () {
            return this._diagnosticKey;
        };

        Diagnostic.prototype.arguments = function () {
            return this._arguments;
        };

        Diagnostic.prototype.text = function () {
            return TypeScript.getLocalizedText(this._diagnosticKey, this._arguments);
        };

        Diagnostic.prototype.message = function () {
            return TypeScript.getDiagnosticMessage(this._diagnosticKey, this._arguments);
        };

        Diagnostic.prototype.additionalLocations = function () {
            return [];
        };

        Diagnostic.equals = function (diagnostic1, diagnostic2) {
            return diagnostic1._fileName === diagnostic2._fileName && diagnostic1._start === diagnostic2._start && diagnostic1._length === diagnostic2._length && diagnostic1._diagnosticKey === diagnostic2._diagnosticKey && TypeScript.ArrayUtilities.sequenceEquals(diagnostic1._arguments, diagnostic2._arguments, function (v1, v2) {
                return v1 === v2;
            });
        };
        return Diagnostic;
    })();
    TypeScript.Diagnostic = Diagnostic;

    function getLargestIndex(diagnostic) {
        var largest = -1;
        var regex = /\{(\d+)\}/g;

        var match;
        while ((match = regex.exec(diagnostic)) != null) {
            var val = parseInt(match[1]);
            if (!isNaN(val) && val > largest) {
                largest = val;
            }
        }

        return largest;
    }

    function getDiagnosticInfoFromKey(diagnosticKey) {
        var result = TypeScript.diagnosticInformationMap[diagnosticKey];
        TypeScript.Debug.assert(result !== undefined && result !== null);
        return result;
    }
    TypeScript.getDiagnosticInfoFromKey = getDiagnosticInfoFromKey;

    function getLocalizedText(diagnosticKey, args) {
        if (TypeScript.LocalizedDiagnosticMessages) {
            TypeScript.Debug.assert(TypeScript.LocalizedDiagnosticMessages.hasOwnProperty(diagnosticKey));
        }

        var diagnosticMessageText = TypeScript.LocalizedDiagnosticMessages ? TypeScript.LocalizedDiagnosticMessages[diagnosticKey] : diagnosticKey;
        TypeScript.Debug.assert(diagnosticMessageText !== undefined && diagnosticMessageText !== null);

        var actualCount = args ? args.length : 0;

        var expectedCount = 1 + getLargestIndex(diagnosticKey);

        if (expectedCount !== actualCount) {
            throw new Error(getLocalizedText(TypeScript.DiagnosticCode.Expected_0_arguments_to_message_got_1_instead, [expectedCount, actualCount]));
        }

        var valueCount = 1 + getLargestIndex(diagnosticMessageText);
        if (valueCount !== expectedCount) {
            throw new Error(getLocalizedText(TypeScript.DiagnosticCode.Expected_the_message_0_to_have_1_arguments_but_it_had_2, [diagnosticMessageText, expectedCount, valueCount]));
        }

        diagnosticMessageText = diagnosticMessageText.replace(/{(\d+)}/g, function (match, num) {
            return typeof args[num] !== 'undefined' ? args[num] : match;
        });

        diagnosticMessageText = diagnosticMessageText.replace(/{(NL)}/g, function (match) {
            return TypeScript.newLine();
        });

        return diagnosticMessageText;
    }
    TypeScript.getLocalizedText = getLocalizedText;

    function getDiagnosticMessage(diagnosticKey, args) {
        var diagnostic = getDiagnosticInfoFromKey(diagnosticKey);
        var diagnosticMessageText = getLocalizedText(diagnosticKey, args);

        var message;
        if (diagnostic.category === 1 /* Error */) {
            message = getLocalizedText(TypeScript.DiagnosticCode.error_TS_0_1, [diagnostic.code, diagnosticMessageText]);
        } else if (diagnostic.category === 0 /* Warning */) {
            message = getLocalizedText(TypeScript.DiagnosticCode.warning_TS_0_1, [diagnostic.code, diagnosticMessageText]);
        } else {
            message = diagnosticMessageText;
        }

        return message;
    }
    TypeScript.getDiagnosticMessage = getDiagnosticMessage;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.nodeMakeDirectoryTime = 0;
    TypeScript.nodeCreateBufferTime = 0;
    TypeScript.nodeWriteFileSyncTime = 0;
})(TypeScript || (TypeScript = {}));

var ByteOrderMark;
(function (ByteOrderMark) {
    ByteOrderMark[ByteOrderMark["None"] = 0] = "None";
    ByteOrderMark[ByteOrderMark["Utf8"] = 1] = "Utf8";
    ByteOrderMark[ByteOrderMark["Utf16BigEndian"] = 2] = "Utf16BigEndian";
    ByteOrderMark[ByteOrderMark["Utf16LittleEndian"] = 3] = "Utf16LittleEndian";
})(ByteOrderMark || (ByteOrderMark = {}));

var FileInformation = (function () {
    function FileInformation(contents, byteOrderMark) {
        this.contents = contents;
        this.byteOrderMark = byteOrderMark;
    }
    return FileInformation;
})();

var Environment = (function () {
    function getWindowsScriptHostEnvironment() {
        try  {
            var fso = new ActiveXObject("Scripting.FileSystemObject");
        } catch (e) {
            return null;
        }

        var streamObjectPool = [];

        function getStreamObject() {
            if (streamObjectPool.length > 0) {
                return streamObjectPool.pop();
            } else {
                return new ActiveXObject("ADODB.Stream");
            }
        }

        function releaseStreamObject(obj) {
            streamObjectPool.push(obj);
        }

        var args = [];
        for (var i = 0; i < WScript.Arguments.length; i++) {
            args[i] = WScript.Arguments.Item(i);
        }

        return {
            newLine: "\r\n",
            currentDirectory: function () {
                return (WScript).CreateObject("WScript.Shell").CurrentDirectory;
            },
            readFile: function (path) {
                try  {
                    var streamObj = getStreamObject();
                    streamObj.Open();
                    streamObj.Type = 2;

                    streamObj.Charset = 'x-ansi';

                    streamObj.LoadFromFile(path);
                    var bomChar = streamObj.ReadText(2);

                    streamObj.Position = 0;

                    var byteOrderMark = 0 /* None */;

                    if (bomChar.charCodeAt(0) === 0xFE && bomChar.charCodeAt(1) === 0xFF) {
                        streamObj.Charset = 'unicode';
                        byteOrderMark = 2 /* Utf16BigEndian */;
                    } else if (bomChar.charCodeAt(0) === 0xFF && bomChar.charCodeAt(1) === 0xFE) {
                        streamObj.Charset = 'unicode';
                        byteOrderMark = 3 /* Utf16LittleEndian */;
                    } else if (bomChar.charCodeAt(0) === 0xEF && bomChar.charCodeAt(1) === 0xBB) {
                        streamObj.Charset = 'utf-8';
                        byteOrderMark = 1 /* Utf8 */;
                    } else {
                        streamObj.Charset = 'utf-8';
                    }

                    var contents = streamObj.ReadText(-1);
                    streamObj.Close();
                    releaseStreamObject(streamObj);
                    return new FileInformation(contents, byteOrderMark);
                } catch (err) {
                    var message;
                    if (err.number === -2147024809) {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Unsupported_file_encoding, null);
                    } else {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Cannot_read_file_0_1, [path, err.message]);
                    }

                    throw new Error(message);
                }
            },
            writeFile: function (path, contents, writeByteOrderMark) {
                var textStream = getStreamObject();
                textStream.Charset = 'utf-8';
                textStream.Open();
                textStream.WriteText(contents, 0);

                if (!writeByteOrderMark) {
                    textStream.Position = 3;
                } else {
                    textStream.Position = 0;
                }

                var fileStream = getStreamObject();
                fileStream.Type = 1;
                fileStream.Open();

                textStream.CopyTo(fileStream);

                fileStream.Flush();
                fileStream.SaveToFile(path, 2);
                fileStream.Close();

                textStream.Flush();
                textStream.Close();
            },
            fileExists: function (path) {
                return fso.FileExists(path);
            },
            deleteFile: function (path) {
                if (fso.FileExists(path)) {
                    fso.DeleteFile(path, true);
                }
            },
            directoryExists: function (path) {
                return fso.FolderExists(path);
            },
            listFiles: function (path, spec, options) {
                options = options || {};
                function filesInFolder(folder, root) {
                    var paths = [];
                    var fc;

                    if (options.recursive) {
                        fc = new Enumerator(folder.subfolders);

                        for (; !fc.atEnd(); fc.moveNext()) {
                            paths = paths.concat(filesInFolder(fc.item(), root + "\\" + fc.item().Name));
                        }
                    }

                    fc = new Enumerator(folder.files);

                    for (; !fc.atEnd(); fc.moveNext()) {
                        if (!spec || fc.item().Name.match(spec)) {
                            paths.push(root + "\\" + fc.item().Name);
                        }
                    }

                    return paths;
                }

                var folder = fso.GetFolder(path);
                var paths = [];

                return filesInFolder(folder, path);
            },
            arguments: args,
            standardOut: WScript.StdOut
        };
    }
    ;

    function getNodeEnvironment() {
        var _fs = require('fs');
        var _path = require('path');
        var _module = require('module');
        var _os = require('os');

        return {
            newLine: _os.EOL,
            currentDirectory: function () {
                return (process).cwd();
            },
            readFile: function (file) {
                var buffer = _fs.readFileSync(file);
                switch (buffer[0]) {
                    case 0xFE:
                        if (buffer[1] === 0xFF) {
                            var i = 0;
                            while ((i + 1) < buffer.length) {
                                var temp = buffer[i];
                                buffer[i] = buffer[i + 1];
                                buffer[i + 1] = temp;
                                i += 2;
                            }
                            return new FileInformation(buffer.toString("ucs2", 2), 2 /* Utf16BigEndian */);
                        }
                        break;
                    case 0xFF:
                        if (buffer[1] === 0xFE) {
                            return new FileInformation(buffer.toString("ucs2", 2), 3 /* Utf16LittleEndian */);
                        }
                        break;
                    case 0xEF:
                        if (buffer[1] === 0xBB) {
                            return new FileInformation(buffer.toString("utf8", 3), 1 /* Utf8 */);
                        }
                }

                return new FileInformation(buffer.toString("utf8", 0), 0 /* None */);
            },
            writeFile: function (path, contents, writeByteOrderMark) {
                function mkdirRecursiveSync(path) {
                    var stats = _fs.statSync(path);
                    if (stats.isFile()) {
                        throw "\"" + path + "\" exists but isn't a directory.";
                    } else if (stats.isDirectory()) {
                        return;
                    } else {
                        mkdirRecursiveSync(_path.dirname(path));
                        _fs.mkdirSync(path, 0775);
                    }
                }
                var start = new Date().getTime();
                mkdirRecursiveSync(_path.dirname(path));
                TypeScript.nodeMakeDirectoryTime += new Date().getTime() - start;

                if (writeByteOrderMark) {
                    contents = '\uFEFF' + contents;
                }

                var start = new Date().getTime();

                var chunkLength = 4 * 1024;
                var fileDescriptor = _fs.openSync(path, "w");
                try  {
                    for (var index = 0; index < contents.length; index += chunkLength) {
                        var bufferStart = new Date().getTime();
                        var buffer = new Buffer(contents.substr(index, chunkLength), "utf8");
                        TypeScript.nodeCreateBufferTime += new Date().getTime() - bufferStart;

                        _fs.writeSync(fileDescriptor, buffer, 0, buffer.length, null);
                    }
                } finally {
                    _fs.closeSync(fileDescriptor);
                }

                TypeScript.nodeWriteFileSyncTime += new Date().getTime() - start;
            },
            fileExists: function (path) {
                return _fs.existsSync(path);
            },
            deleteFile: function (path) {
                try  {
                    _fs.unlinkSync(path);
                } catch (e) {
                }
            },
            directoryExists: function (path) {
                return _fs.existsSync(path) && _fs.statSync(path).isDirectory();
            },
            listFiles: function dir(path, spec, options) {
                options = options || {};

                function filesInFolder(folder) {
                    var paths = [];

                    var files = _fs.readdirSync(folder);
                    for (var i = 0; i < files.length; i++) {
                        var stat = _fs.statSync(folder + "\\" + files[i]);
                        if (options.recursive && stat.isDirectory()) {
                            paths = paths.concat(filesInFolder(folder + "\\" + files[i]));
                        } else if (stat.isFile() && (!spec || files[i].match(spec))) {
                            paths.push(folder + "\\" + files[i]);
                        }
                    }

                    return paths;
                }

                return filesInFolder(path);
            },
            arguments: process.argv.slice(2),
            standardOut: {
                Write: function (str) {
                    process.stdout.write(str);
                },
                WriteLine: function (str) {
                    process.stdout.write(str + '\n');
                },
                Close: function () {
                }
            }
        };
    }
    ;

    if (typeof WScript !== "undefined" && typeof ActiveXObject === "function") {
        return getWindowsScriptHostEnvironment();
    } else if (typeof module !== 'undefined' && module.exports) {
        return getNodeEnvironment();
    } else {
        return null;
    }
})();
var TypeScript;
(function (TypeScript) {
    var IntegerUtilities = (function () {
        function IntegerUtilities() {
        }
        IntegerUtilities.integerDivide = function (numerator, denominator) {
            return (numerator / denominator) >> 0;
        };

        IntegerUtilities.integerMultiplyLow32Bits = function (n1, n2) {
            var n1Low16 = n1 & 0x0000ffff;
            var n1High16 = n1 >>> 16;

            var n2Low16 = n2 & 0x0000ffff;
            var n2High16 = n2 >>> 16;

            var resultLow32 = (((n1 & 0xffff0000) * n2) >>> 0) + (((n1 & 0x0000ffff) * n2) >>> 0) >>> 0;
            return resultLow32;
        };

        IntegerUtilities.integerMultiplyHigh32Bits = function (n1, n2) {
            var n1Low16 = n1 & 0x0000ffff;
            var n1High16 = n1 >>> 16;

            var n2Low16 = n2 & 0x0000ffff;
            var n2High16 = n2 >>> 16;

            var resultHigh32 = n1High16 * n2High16 + ((((n1Low16 * n2Low16) >>> 17) + n1Low16 * n2High16) >>> 15);
            return resultHigh32;
        };
        return IntegerUtilities;
    })();
    TypeScript.IntegerUtilities = IntegerUtilities;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var MathPrototype = (function () {
        function MathPrototype() {
        }
        MathPrototype.max = function (a, b) {
            return a >= b ? a : b;
        };

        MathPrototype.min = function (a, b) {
            return a <= b ? a : b;
        };
        return MathPrototype;
    })();
    TypeScript.MathPrototype = MathPrototype;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Collections) {
        Collections.DefaultStringTableCapacity = 256;

        var StringTableEntry = (function () {
            function StringTableEntry(Text, HashCode, Next) {
                this.Text = Text;
                this.HashCode = HashCode;
                this.Next = Next;
            }
            return StringTableEntry;
        })();

        var StringTable = (function () {
            function StringTable(capacity) {
                this.count = 0;
                var size = TypeScript.Hash.getPrime(capacity);
                this.entries = TypeScript.ArrayUtilities.createArray(size, null);
            }
            StringTable.prototype.addCharArray = function (key, start, len) {
                var hashCode = TypeScript.Hash.computeSimple31BitCharArrayHashCode(key, start, len) & 0x7FFFFFFF;

                var entry = this.findCharArrayEntry(key, start, len, hashCode);
                if (entry !== null) {
                    return entry.Text;
                }

                var slice = key.slice(start, start + len);
                return this.addEntry(TypeScript.StringUtilities.fromCharCodeArray(slice), hashCode);
            };

            StringTable.prototype.findCharArrayEntry = function (key, start, len, hashCode) {
                for (var e = this.entries[hashCode % this.entries.length]; e !== null; e = e.Next) {
                    if (e.HashCode === hashCode && StringTable.textCharArrayEquals(e.Text, key, start, len)) {
                        return e;
                    }
                }

                return null;
            };

            StringTable.prototype.addEntry = function (text, hashCode) {
                var index = hashCode % this.entries.length;

                var e = new StringTableEntry(text, hashCode, this.entries[index]);

                this.entries[index] = e;

                if (this.count === this.entries.length) {
                    this.grow();
                }

                this.count++;
                return e.Text;
            };

            StringTable.prototype.grow = function () {
                var newSize = TypeScript.Hash.expandPrime(this.entries.length);

                var oldEntries = this.entries;
                var newEntries = TypeScript.ArrayUtilities.createArray(newSize, null);

                this.entries = newEntries;

                for (var i = 0; i < oldEntries.length; i++) {
                    var e = oldEntries[i];
                    while (e !== null) {
                        var newIndex = e.HashCode % newSize;
                        var tmp = e.Next;
                        e.Next = newEntries[newIndex];
                        newEntries[newIndex] = e;
                        e = tmp;
                    }
                }
            };

            StringTable.textCharArrayEquals = function (text, array, start, length) {
                if (text.length !== length) {
                    return false;
                }

                var s = start;
                for (var i = 0; i < length; i++) {
                    if (text.charCodeAt(i) !== array[s]) {
                        return false;
                    }

                    s++;
                }

                return true;
            };
            return StringTable;
        })();
        Collections.StringTable = StringTable;

        Collections.DefaultStringTable = new StringTable(Collections.DefaultStringTableCapacity);
    })(TypeScript.Collections || (TypeScript.Collections = {}));
    var Collections = TypeScript.Collections;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var StringUtilities = (function () {
        function StringUtilities() {
        }
        StringUtilities.isString = function (value) {
            return Object.prototype.toString.apply(value, []) === '[object String]';
        };

        StringUtilities.fromCharCodeArray = function (array) {
            return String.fromCharCode.apply(null, array);
        };

        StringUtilities.endsWith = function (string, value) {
            return string.substring(string.length - value.length, string.length) === value;
        };

        StringUtilities.startsWith = function (string, value) {
            return string.substr(0, value.length) === value;
        };

        StringUtilities.copyTo = function (source, sourceIndex, destination, destinationIndex, count) {
            for (var i = 0; i < count; i++) {
                destination[destinationIndex + i] = source.charCodeAt(sourceIndex + i);
            }
        };

        StringUtilities.repeat = function (value, count) {
            return Array(count + 1).join(value);
        };

        StringUtilities.stringEquals = function (val1, val2) {
            return val1 === val2;
        };
        return StringUtilities;
    })();
    TypeScript.StringUtilities = StringUtilities;
})(TypeScript || (TypeScript = {}));
var global = Function("return this").call(null);

var TypeScript;
(function (TypeScript) {
    var Clock;
    (function (Clock) {
        Clock.now;
        Clock.resolution;

        if (typeof WScript !== "undefined" && typeof global['WScript'].InitializeProjection !== "undefined") {
            global['WScript'].InitializeProjection();

            Clock.now = function () {
                return TestUtilities.QueryPerformanceCounter();
            };

            Clock.resolution = TestUtilities.QueryPerformanceFrequency();
        } else {
            Clock.now = function () {
                return Date.now();
            };

            Clock.resolution = 1000;
        }
    })(Clock || (Clock = {}));

    var Timer = (function () {
        function Timer() {
            this.time = 0;
        }
        Timer.prototype.start = function () {
            this.time = 0;
            this.startTime = Clock.now();
        };

        Timer.prototype.end = function () {
            this.time = (Clock.now() - this.startTime);
        };
        return Timer;
    })();
    TypeScript.Timer = Timer;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (DiagnosticCategory) {
        DiagnosticCategory[DiagnosticCategory["Warning"] = 0] = "Warning";
        DiagnosticCategory[DiagnosticCategory["Error"] = 1] = "Error";
        DiagnosticCategory[DiagnosticCategory["Message"] = 2] = "Message";
        DiagnosticCategory[DiagnosticCategory["NoPrefix"] = 3] = "NoPrefix";
    })(TypeScript.DiagnosticCategory || (TypeScript.DiagnosticCategory = {}));
    var DiagnosticCategory = TypeScript.DiagnosticCategory;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.diagnosticInformationMap = {
        "error TS{0}: {1}": {
            "code": 0,
            "category": 3 /* NoPrefix */
        },
        "warning TS{0}: {1}": {
            "code": 1,
            "category": 3 /* NoPrefix */
        },
        "Unrecognized escape sequence.": {
            "code": 1000,
            "category": 1 /* Error */
        },
        "Unexpected character {0}.": {
            "code": 1001,
            "category": 1 /* Error */
        },
        "Missing close quote character.": {
            "code": 1002,
            "category": 1 /* Error */
        },
        "Identifier expected.": {
            "code": 1003,
            "category": 1 /* Error */
        },
        "'{0}' keyword expected.": {
            "code": 1004,
            "category": 1 /* Error */
        },
        "'{0}' expected.": {
            "code": 1005,
            "category": 1 /* Error */
        },
        "Identifier expected; '{0}' is a keyword.": {
            "code": 1006,
            "category": 1 /* Error */
        },
        "Automatic semicolon insertion not allowed.": {
            "code": 1007,
            "category": 1 /* Error */
        },
        "Unexpected token; '{0}' expected.": {
            "code": 1008,
            "category": 1 /* Error */
        },
        "Trailing separator not allowed.": {
            "code": 1009,
            "category": 1 /* Error */
        },
        "'*/' expected.": {
            "code": 1010,
            "category": 1 /* Error */
        },
        "'public' or 'private' modifier must precede 'static'.": {
            "code": 1011,
            "category": 1 /* Error */
        },
        "Unexpected token.": {
            "code": 1012,
            "category": 1 /* Error */
        },
        "Catch clause parameter cannot have a type annotation.": {
            "code": 1013,
            "category": 1 /* Error */
        },
        "Rest parameter must be last in list.": {
            "code": 1014,
            "category": 1 /* Error */
        },
        "Parameter cannot have question mark and initializer.": {
            "code": 1015,
            "category": 1 /* Error */
        },
        "Required parameter cannot follow optional parameter.": {
            "code": 1016,
            "category": 1 /* Error */
        },
        "Index signatures cannot have rest parameters.": {
            "code": 1017,
            "category": 1 /* Error */
        },
        "Index signature parameter cannot have accessibility modifiers.": {
            "code": 1018,
            "category": 1 /* Error */
        },
        "Index signature parameter cannot have a question mark.": {
            "code": 1019,
            "category": 1 /* Error */
        },
        "Index signature parameter cannot have an initializer.": {
            "code": 1020,
            "category": 1 /* Error */
        },
        "Index signature must have a type annotation.": {
            "code": 1021,
            "category": 1 /* Error */
        },
        "Index signature parameter must have a type annotation.": {
            "code": 1022,
            "category": 1 /* Error */
        },
        "Index signature parameter type must be 'string' or 'number'.": {
            "code": 1023,
            "category": 1 /* Error */
        },
        "'extends' clause already seen.": {
            "code": 1024,
            "category": 1 /* Error */
        },
        "'extends' clause must precede 'implements' clause.": {
            "code": 1025,
            "category": 1 /* Error */
        },
        "Classes can only extend a single class.": {
            "code": 1026,
            "category": 1 /* Error */
        },
        "'implements' clause already seen.": {
            "code": 1027,
            "category": 1 /* Error */
        },
        "Accessibility modifier already seen.": {
            "code": 1028,
            "category": 1 /* Error */
        },
        "'{0}' modifier must precede '{1}' modifier.": {
            "code": 1029,
            "category": 1 /* Error */
        },
        "'{0}' modifier already seen.": {
            "code": 1030,
            "category": 1 /* Error */
        },
        "'{0}' modifier cannot appear on a class element.": {
            "code": 1031,
            "category": 1 /* Error */
        },
        "Interface declaration cannot have 'implements' clause.": {
            "code": 1032,
            "category": 1 /* Error */
        },
        "'super' invocation cannot have type arguments.": {
            "code": 1034,
            "category": 1 /* Error */
        },
        "Only ambient modules can use quoted names.": {
            "code": 1035,
            "category": 1 /* Error */
        },
        "Statements are not allowed in ambient contexts.": {
            "code": 1036,
            "category": 1 /* Error */
        },
        "Implementations are not allowed in ambient contexts.": {
            "code": 1037,
            "category": 1 /* Error */
        },
        "'declare' modifier not allowed for code already in an ambient context.": {
            "code": 1038,
            "category": 1 /* Error */
        },
        "Initializers are not allowed in ambient contexts.": {
            "code": 1039,
            "category": 1 /* Error */
        },
        "Parameter property declarations can only be used in constructors.": {
            "code": 1040,
            "category": 1 /* Error */
        },
        "Function implementation expected.": {
            "code": 1041,
            "category": 1 /* Error */
        },
        "Constructor implementation expected.": {
            "code": 1042,
            "category": 1 /* Error */
        },
        "Function overload name must be '{0}'.": {
            "code": 1043,
            "category": 1 /* Error */
        },
        "'{0}' modifier cannot appear on a module element.": {
            "code": 1044,
            "category": 1 /* Error */
        },
        "'declare' modifier cannot appear on an interface declaration.": {
            "code": 1045,
            "category": 1 /* Error */
        },
        "'declare' modifier required for top level element.": {
            "code": 1046,
            "category": 1 /* Error */
        },
        "Rest parameter cannot be optional.": {
            "code": 1047,
            "category": 1 /* Error */
        },
        "Rest parameter cannot have an initializer.": {
            "code": 1048,
            "category": 1 /* Error */
        },
        "'set' accessor must have one and only one parameter.": {
            "code": 1049,
            "category": 1 /* Error */
        },
        "'set' accessor parameter cannot have accessibility modifier.": {
            "code": 1050,
            "category": 1 /* Error */
        },
        "'set' accessor parameter cannot be optional.": {
            "code": 1051,
            "category": 1 /* Error */
        },
        "'set' accessor parameter cannot have an initializer.": {
            "code": 1052,
            "category": 1 /* Error */
        },
        "'set' accessor cannot have rest parameter.": {
            "code": 1053,
            "category": 1 /* Error */
        },
        "'get' accessor cannot have parameters.": {
            "code": 1054,
            "category": 1 /* Error */
        },
        "Modifiers cannot appear here.": {
            "code": 1055,
            "category": 1 /* Error */
        },
        "Accessors are only available when targeting ECMAScript 5 and higher.": {
            "code": 1056,
            "category": 1 /* Error */
        },
        "Class name cannot be '{0}'.": {
            "code": 1057,
            "category": 1 /* Error */
        },
        "Interface name cannot be '{0}'.": {
            "code": 1058,
            "category": 1 /* Error */
        },
        "Enum name cannot be '{0}'.": {
            "code": 1059,
            "category": 1 /* Error */
        },
        "Module name cannot be '{0}'.": {
            "code": 1060,
            "category": 1 /* Error */
        },
        "Enum member must have initializer.": {
            "code": 1061,
            "category": 1 /* Error */
        },
        "Export assignment cannot be used in internal modules.": {
            "code": 1063,
            "category": 1 /* Error */
        },
        "Export assignment not allowed in module with exported element.": {
            "code": 1064,
            "category": 1 /* Error */
        },
        "Module cannot have multiple export assignments.": {
            "code": 1065,
            "category": 1 /* Error */
        },
        "Ambient enum elements can only have integer literal initializers.": {
            "code": 1066,
            "category": 1 /* Error */
        },
        "module, class, interface, enum, import or statement": {
            "code": 1067,
            "category": 3 /* NoPrefix */
        },
        "constructor, function, accessor or variable": {
            "code": 1068,
            "category": 3 /* NoPrefix */
        },
        "statement": {
            "code": 1069,
            "category": 3 /* NoPrefix */
        },
        "case or default clause": {
            "code": 1070,
            "category": 3 /* NoPrefix */
        },
        "identifier": {
            "code": 1071,
            "category": 3 /* NoPrefix */
        },
        "call, construct, index, property or function signature": {
            "code": 1072,
            "category": 3 /* NoPrefix */
        },
        "expression": {
            "code": 1073,
            "category": 3 /* NoPrefix */
        },
        "type name": {
            "code": 1074,
            "category": 3 /* NoPrefix */
        },
        "property or accessor": {
            "code": 1075,
            "category": 3 /* NoPrefix */
        },
        "parameter": {
            "code": 1076,
            "category": 3 /* NoPrefix */
        },
        "type": {
            "code": 1077,
            "category": 3 /* NoPrefix */
        },
        "type parameter": {
            "code": 1078,
            "category": 3 /* NoPrefix */
        },
        "'declare' modifier not allowed on import declaration.": {
            "code": 1079,
            "category": 1 /* Error */
        },
        "Function overload must be static": {
            "code": 1080,
            "category": 1 /* Error */
        },
        "Function overload must not be static": {
            "code": 1081,
            "category": 1 /* Error */
        },
        "Parameter property declarations cannot be used in an ambient context.": {
            "code": 1082,
            "category": 1 /* Error */
        },
        "Parameter property declarations cannot be used in a constructor overload.": {
            "code": 1083,
            "category": 1 /* Error */
        },
        "Duplicate identifier '{0}'.": {
            "code": 2000,
            "category": 1 /* Error */
        },
        "The name '{0}' does not exist in the current scope.": {
            "code": 2001,
            "category": 1 /* Error */
        },
        "The name '{0}' does not refer to a value.": {
            "code": 2002,
            "category": 1 /* Error */
        },
        "'super' can only be used inside a class instance method.": {
            "code": 2003,
            "category": 1 /* Error */
        },
        "The left-hand side of an assignment expression must be a variable, property or indexer.": {
            "code": 2004,
            "category": 1 /* Error */
        },
        "Value of type '{0}' is not callable. Did you mean to include 'new'?": {
            "code": 2161,
            "category": 1 /* Error */
        },
        "Value of type '{0}' is not callable.": {
            "code": 2006,
            "category": 1 /* Error */
        },
        "Value of type '{0}' is not newable.": {
            "code": 2007,
            "category": 1 /* Error */
        },
        "Value of type '{0}' is not indexable by type '{1}'.": {
            "code": 2008,
            "category": 1 /* Error */
        },
        "Operator '{0}' cannot be applied to types '{1}' and '{2}'.": {
            "code": 2009,
            "category": 1 /* Error */
        },
        "Operator '{0}' cannot be applied to types '{1}' and '{2}': {3}": {
            "code": 2010,
            "category": 1 /* Error */
        },
        "Cannot convert '{0}' to '{1}'.": {
            "code": 2011,
            "category": 1 /* Error */
        },
        "Cannot convert '{0}' to '{1}':{NL}{2}": {
            "code": 2012,
            "category": 1 /* Error */
        },
        "Expected var, class, interface, or module.": {
            "code": 2013,
            "category": 1 /* Error */
        },
        "Operator '{0}' cannot be applied to type '{1}'.": {
            "code": 2014,
            "category": 1 /* Error */
        },
        "Getter '{0}' already declared.": {
            "code": 2015,
            "category": 1 /* Error */
        },
        "Setter '{0}' already declared.": {
            "code": 2016,
            "category": 1 /* Error */
        },
        "Accessors cannot have type parameters.": {
            "code": 2017,
            "category": 1 /* Error */
        },
        "Exported class '{0}' extends private class '{1}'.": {
            "code": 2018,
            "category": 1 /* Error */
        },
        "Exported class '{0}' implements private interface '{1}'.": {
            "code": 2019,
            "category": 1 /* Error */
        },
        "Exported interface '{0}' extends private interface '{1}'.": {
            "code": 2020,
            "category": 1 /* Error */
        },
        "Exported class '{0}' extends class from inaccessible module {1}.": {
            "code": 2021,
            "category": 1 /* Error */
        },
        "Exported class '{0}' implements interface from inaccessible module {1}.": {
            "code": 2022,
            "category": 1 /* Error */
        },
        "Exported interface '{0}' extends interface from inaccessible module {1}.": {
            "code": 2023,
            "category": 1 /* Error */
        },
        "Public static property '{0}' of exported class has or is using private type '{1}'.": {
            "code": 2024,
            "category": 1 /* Error */
        },
        "Public property '{0}' of exported class has or is using private type '{1}'.": {
            "code": 2025,
            "category": 1 /* Error */
        },
        "Property '{0}' of exported interface has or is using private type '{1}'.": {
            "code": 2026,
            "category": 1 /* Error */
        },
        "Exported variable '{0}' has or is using private type '{1}'.": {
            "code": 2027,
            "category": 1 /* Error */
        },
        "Public static property '{0}' of exported class is using inaccessible module {1}.": {
            "code": 2028,
            "category": 1 /* Error */
        },
        "Public property '{0}' of exported class is using inaccessible module {1}.": {
            "code": 2029,
            "category": 1 /* Error */
        },
        "Property '{0}' of exported interface is using inaccessible module {1}.": {
            "code": 2030,
            "category": 1 /* Error */
        },
        "Exported variable '{0}' is using inaccessible module {1}.": {
            "code": 2031,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of constructor from exported class has or is using private type '{1}'.": {
            "code": 2032,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of public static property setter from exported class has or is using private type '{1}'.": {
            "code": 2033,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of public property setter from exported class has or is using private type '{1}'.": {
            "code": 2034,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of constructor signature from exported interface has or is using private type '{1}'.": {
            "code": 2035,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of call signature from exported interface has or is using private type '{1}'.": {
            "code": 2036,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of public static method from exported class has or is using private type '{1}'.": {
            "code": 2037,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of public method from exported class has or is using private type '{1}'.": {
            "code": 2038,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of method from exported interface has or is using private type '{1}'.": {
            "code": 2039,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of exported function has or is using private type '{1}'.": {
            "code": 2040,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of constructor from exported class is using inaccessible module {1}.": {
            "code": 2041,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of public static property setter from exported class is using inaccessible module {1}.": {
            "code": 2042,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of public property setter from exported class is using inaccessible module {1}.": {
            "code": 2043,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of constructor signature from exported interface is using inaccessible module {1}.": {
            "code": 2044,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of call signature from exported interface is using inaccessible module {1}": {
            "code": 2045,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of public static method from exported class is using inaccessible module {1}.": {
            "code": 2046,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of public method from exported class is using inaccessible module {1}.": {
            "code": 2047,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of method from exported interface is using inaccessible module {1}.": {
            "code": 2048,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of exported function is using inaccessible module {1}.": {
            "code": 2049,
            "category": 1 /* Error */
        },
        "Return type of public static property getter from exported class has or is using private type '{0}'.": {
            "code": 2050,
            "category": 1 /* Error */
        },
        "Return type of public property getter from exported class has or is using private type '{0}'.": {
            "code": 2051,
            "category": 1 /* Error */
        },
        "Return type of constructor signature from exported interface has or is using private type '{0}'.": {
            "code": 2052,
            "category": 1 /* Error */
        },
        "Return type of call signature from exported interface has or is using private type '{0}'.": {
            "code": 2053,
            "category": 1 /* Error */
        },
        "Return type of index signature from exported interface has or is using private type '{0}'.": {
            "code": 2054,
            "category": 1 /* Error */
        },
        "Return type of public static method from exported class has or is using private type '{0}'.": {
            "code": 2055,
            "category": 1 /* Error */
        },
        "Return type of public method from exported class has or is using private type '{0}'.": {
            "code": 2056,
            "category": 1 /* Error */
        },
        "Return type of method from exported interface has or is using private type '{0}'.": {
            "code": 2057,
            "category": 1 /* Error */
        },
        "Return type of exported function has or is using private type '{0}'.": {
            "code": 2058,
            "category": 1 /* Error */
        },
        "Return type of public static property getter from exported class is using inaccessible module {0}.": {
            "code": 2059,
            "category": 1 /* Error */
        },
        "Return type of public property getter from exported class is using inaccessible module {0}.": {
            "code": 2060,
            "category": 1 /* Error */
        },
        "Return type of constructor signature from exported interface is using inaccessible module {0}.": {
            "code": 2061,
            "category": 1 /* Error */
        },
        "Return type of call signature from exported interface is using inaccessible module {0}.": {
            "code": 2062,
            "category": 1 /* Error */
        },
        "Return type of index signature from exported interface is using inaccessible module {0}.": {
            "code": 2063,
            "category": 1 /* Error */
        },
        "Return type of public static method from exported class is using inaccessible module {0}.": {
            "code": 2064,
            "category": 1 /* Error */
        },
        "Return type of public method from exported class is using inaccessible module {0}.": {
            "code": 2065,
            "category": 1 /* Error */
        },
        "Return type of method from exported interface is using inaccessible module {0}.": {
            "code": 2066,
            "category": 1 /* Error */
        },
        "Return type of exported function is using inaccessible module {0}.": {
            "code": 2067,
            "category": 1 /* Error */
        },
        "'new T[]' cannot be used to create an array. Use 'new Array<T>()' instead.": {
            "code": 2068,
            "category": 1 /* Error */
        },
        "A parameter list must follow a generic type argument list. '(' expected.": {
            "code": 2069,
            "category": 1 /* Error */
        },
        "Multiple constructor implementations are not allowed.": {
            "code": 2070,
            "category": 1 /* Error */
        },
        "Unable to resolve external module '{0}'.": {
            "code": 2071,
            "category": 1 /* Error */
        },
        "Module cannot be aliased to a non-module type.": {
            "code": 2072,
            "category": 1 /* Error */
        },
        "A class may only extend another class.": {
            "code": 2073,
            "category": 1 /* Error */
        },
        "A class may only implement another class or interface.": {
            "code": 2074,
            "category": 1 /* Error */
        },
        "An interface may only extend another class or interface.": {
            "code": 2075,
            "category": 1 /* Error */
        },
        "An interface cannot implement another type.": {
            "code": 2076,
            "category": 1 /* Error */
        },
        "Unable to resolve type.": {
            "code": 2077,
            "category": 1 /* Error */
        },
        "Unable to resolve type of '{0}'.": {
            "code": 2078,
            "category": 1 /* Error */
        },
        "Unable to resolve type parameter constraint.": {
            "code": 2079,
            "category": 1 /* Error */
        },
        "Type parameter constraint cannot be a primitive type.": {
            "code": 2080,
            "category": 1 /* Error */
        },
        "Supplied parameters do not match any signature of call target.": {
            "code": 2081,
            "category": 1 /* Error */
        },
        "Supplied parameters do not match any signature of call target:{NL}{0}": {
            "code": 2082,
            "category": 1 /* Error */
        },
        "Invalid 'new' expression.": {
            "code": 2083,
            "category": 1 /* Error */
        },
        "Call signatures used in a 'new' expression must have a 'void' return type.": {
            "code": 2084,
            "category": 1 /* Error */
        },
        "Could not select overload for 'new' expression.": {
            "code": 2085,
            "category": 1 /* Error */
        },
        "Type '{0}' does not satisfy the constraint '{1}' for type parameter '{2}'.": {
            "code": 2086,
            "category": 1 /* Error */
        },
        "Could not select overload for 'call' expression.": {
            "code": 2087,
            "category": 1 /* Error */
        },
        "Cannot invoke an expression whose type lacks a call signature.": {
            "code": 2088,
            "category": 1 /* Error */
        },
        "Calls to 'super' are only valid inside a class.": {
            "code": 2089,
            "category": 1 /* Error */
        },
        "Generic type '{0}' requires {1} type argument(s).": {
            "code": 2090,
            "category": 1 /* Error */
        },
        "Type of conditional expression cannot be determined. Best common type could not be found between '{0}' and '{1}'.": {
            "code": 2091,
            "category": 1 /* Error */
        },
        "Type of array literal cannot be determined. Best common type could not be found for array elements.": {
            "code": 2092,
            "category": 1 /* Error */
        },
        "Could not find enclosing symbol for dotted name '{0}'.": {
            "code": 2093,
            "category": 1 /* Error */
        },
        "The property '{0}' does not exist on value of type '{1}'.": {
            "code": 2094,
            "category": 1 /* Error */
        },
        "Could not find symbol '{0}'.": {
            "code": 2095,
            "category": 1 /* Error */
        },
        "'get' and 'set' accessor must have the same type.": {
            "code": 2096,
            "category": 1 /* Error */
        },
        "'this' cannot be referenced in current location.": {
            "code": 2097,
            "category": 1 /* Error */
        },
        "Static methods cannot reference class type parameters.": {
            "code": 2099,
            "category": 1 /* Error */
        },
        "Class '{0}' is recursively referenced as a base type of itself.": {
            "code": 2100,
            "category": 1 /* Error */
        },
        "Interface '{0}' is recursively referenced as a base type of itself.": {
            "code": 2101,
            "category": 1 /* Error */
        },
        "'super' property access is permitted only in a constructor, instance member function, or instance member accessor of a derived class.": {
            "code": 2102,
            "category": 1 /* Error */
        },
        "'super' cannot be referenced in non-derived classes.": {
            "code": 2103,
            "category": 1 /* Error */
        },
        "A 'super' call must be the first statement in the constructor when a class contains initialized properties or has parameter properties.": {
            "code": 2104,
            "category": 1 /* Error */
        },
        "Constructors for derived classes must contain a 'super' call.": {
            "code": 2105,
            "category": 1 /* Error */
        },
        "Super calls are not permitted outside constructors or in local functions inside constructors.": {
            "code": 2106,
            "category": 1 /* Error */
        },
        "'{0}.{1}' is inaccessible.": {
            "code": 2107,
            "category": 1 /* Error */
        },
        "'this' cannot be referenced within module bodies.": {
            "code": 2108,
            "category": 1 /* Error */
        },
        "Invalid '+' expression - types not known to support the addition operator.": {
            "code": 2111,
            "category": 1 /* Error */
        },
        "The right-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.": {
            "code": 2112,
            "category": 1 /* Error */
        },
        "The left-hand side of an arithmetic operation must be of type 'any', 'number' or an enum type.": {
            "code": 2113,
            "category": 1 /* Error */
        },
        "The type of a unary arithmetic operation operand must be of type 'any', 'number' or an enum type.": {
            "code": 2114,
            "category": 1 /* Error */
        },
        "Variable declarations of a 'for' statement cannot use a type annotation.": {
            "code": 2115,
            "category": 1 /* Error */
        },
        "Variable declarations of a 'for' statement must be of types 'string' or 'any'.": {
            "code": 2116,
            "category": 1 /* Error */
        },
        "The right-hand side of a 'for...in' statement must be of type 'any', an object type or a type parameter.": {
            "code": 2117,
            "category": 1 /* Error */
        },
        "The left-hand side of an 'in' expression must be of types 'string' or 'any'.": {
            "code": 2118,
            "category": 1 /* Error */
        },
        "The right-hand side of an 'in' expression must be of type 'any', an object type or a type parameter.": {
            "code": 2119,
            "category": 1 /* Error */
        },
        "The left-hand side of an 'instanceof' expression must be of type 'any', an object type or a type parameter.": {
            "code": 2120,
            "category": 1 /* Error */
        },
        "The right-hand side of an 'instanceof' expression must be of type 'any' or a subtype of the 'Function' interface type.": {
            "code": 2121,
            "category": 1 /* Error */
        },
        "Setters cannot return a value.": {
            "code": 2122,
            "category": 1 /* Error */
        },
        "Tried to query type of uninitialized module '{0}'.": {
            "code": 2123,
            "category": 1 /* Error */
        },
        "Tried to set variable type to uninitialized module type '{0}'.": {
            "code": 2124,
            "category": 1 /* Error */
        },
        "Function '{0}' declared a non-void return type, but has no return expression.": {
            "code": 2125,
            "category": 1 /* Error */
        },
        "Getters must return a value.": {
            "code": 2126,
            "category": 1 /* Error */
        },
        "Getter and setter accessors do not agree in visibility.": {
            "code": 2127,
            "category": 1 /* Error */
        },
        "Invalid left-hand side of assignment expression.": {
            "code": 2130,
            "category": 1 /* Error */
        },
        "Function declared a non-void return type, but has no return expression.": {
            "code": 2131,
            "category": 1 /* Error */
        },
        "Cannot resolve return type reference.": {
            "code": 2132,
            "category": 1 /* Error */
        },
        "Constructors cannot have a return type of 'void'.": {
            "code": 2133,
            "category": 1 /* Error */
        },
        "Subsequent variable declarations must have the same type.  Variable '{0}' must be of type '{1}', but here has type '{2}'.": {
            "code": 2134,
            "category": 1 /* Error */
        },
        "All symbols within a with block will be resolved to 'any'.": {
            "code": 2135,
            "category": 1 /* Error */
        },
        "Import declarations in an internal module cannot reference an external module.": {
            "code": 2136,
            "category": 1 /* Error */
        },
        "Class {0} declares interface {1} but does not implement it:{NL}{2}": {
            "code": 2137,
            "category": 1 /* Error */
        },
        "Class {0} declares class {1} as an interface but does not implement it:{NL}{2}": {
            "code": 2138,
            "category": 1 /* Error */
        },
        "The operand of an increment or decrement operator must be a variable, property or indexer.": {
            "code": 2139,
            "category": 1 /* Error */
        },
        "'this' cannot be referenced in static initializers in a class body.": {
            "code": 2140,
            "category": 1 /* Error */
        },
        "Class '{0}' cannot extend class '{1}':{NL}{2}": {
            "code": 2141,
            "category": 1 /* Error */
        },
        "Interface '{0}' cannot extend class '{1}':{NL}{2}": {
            "code": 2142,
            "category": 1 /* Error */
        },
        "Interface '{0}' cannot extend interface '{1}':{NL}{2}": {
            "code": 2143,
            "category": 1 /* Error */
        },
        "Duplicate overload signature for '{0}'.": {
            "code": 2144,
            "category": 1 /* Error */
        },
        "Duplicate constructor overload signature.": {
            "code": 2145,
            "category": 1 /* Error */
        },
        "Duplicate overload call signature.": {
            "code": 2146,
            "category": 1 /* Error */
        },
        "Duplicate overload construct signature.": {
            "code": 2147,
            "category": 1 /* Error */
        },
        "Overload signature is not compatible with function definition.": {
            "code": 2148,
            "category": 1 /* Error */
        },
        "Overload signature is not compatible with function definition:{NL}{0}": {
            "code": 2149,
            "category": 1 /* Error */
        },
        "Overload signatures must all be public or private.": {
            "code": 2150,
            "category": 1 /* Error */
        },
        "Overload signatures must all be exported or local.": {
            "code": 2151,
            "category": 1 /* Error */
        },
        "Overload signatures must all be ambient or non-ambient.": {
            "code": 2152,
            "category": 1 /* Error */
        },
        "Overload signatures must all be optional or required.": {
            "code": 2153,
            "category": 1 /* Error */
        },
        "Specialized overload signature is not subtype of any non-specialized signature.": {
            "code": 2154,
            "category": 1 /* Error */
        },
        "'this' cannot be referenced in constructor arguments.": {
            "code": 2155,
            "category": 1 /* Error */
        },
        "Static member cannot be accessed off an instance variable.": {
            "code": 2156,
            "category": 1 /* Error */
        },
        "Instance member cannot be accessed off a class.": {
            "code": 2157,
            "category": 1 /* Error */
        },
        "Untyped function calls may not accept type arguments.": {
            "code": 2158,
            "category": 1 /* Error */
        },
        "Non-generic functions may not accept type arguments.": {
            "code": 2159,
            "category": 1 /* Error */
        },
        "A generic type may not reference itself with a wrapped form of its own type parameters.": {
            "code": 2160,
            "category": 1 /* Error */
        },
        "Rest parameters must be array types.": {
            "code": 2162,
            "category": 1 /* Error */
        },
        "Overload signature implementation cannot use specialized type.": {
            "code": 2163,
            "category": 1 /* Error */
        },
        "Export assignments may only be used at the top-level of external modules.": {
            "code": 2164,
            "category": 1 /* Error */
        },
        "Export assignments may only be made with variables, functions, classes, interfaces, enums and internal modules": {
            "code": 2165,
            "category": 1 /* Error */
        },
        "Only public instance methods of the base class are accessible via the 'super' keyword.": {
            "code": 2166,
            "category": 1 /* Error */
        },
        "Numeric indexer type '{0}' must be a subtype of string indexer type '{1}'.": {
            "code": 2167,
            "category": 1 /* Error */
        },
        "Numeric indexer type '{0}' must be a subtype of string indexer type '{1}':{NL}{2}": {
            "code": 2168,
            "category": 1 /* Error */
        },
        "All numerically named properties must be subtypes of numeric indexer type '{0}'.": {
            "code": 2169,
            "category": 1 /* Error */
        },
        "All numerically named properties must be subtypes of numeric indexer type '{0}':{NL}{1}": {
            "code": 2170,
            "category": 1 /* Error */
        },
        "All named properties must be subtypes of string indexer type '{0}'.": {
            "code": 2171,
            "category": 1 /* Error */
        },
        "All named properties must be subtypes of string indexer type '{0}':{NL}{1}": {
            "code": 2172,
            "category": 1 /* Error */
        },
        "Generic type references must include all type arguments.": {
            "code": 2173,
            "category": 1 /* Error */
        },
        "Default arguments are not allowed in an overload parameter.": {
            "code": 2174,
            "category": 1 /* Error */
        },
        "Overloads cannot differ only by return type.": {
            "code": 2175,
            "category": 1 /* Error */
        },
        "Function expression declared a non-void return type, but has no return expression.": {
            "code": 2176,
            "category": 1 /* Error */
        },
        "Import declaration referencing identifier from internal module can only be made with variables, functions, classes, interfaces, enums and internal modules.": {
            "code": 2177,
            "category": 1 /* Error */
        },
        "Could not find symbol '{0}' in module '{1}'.": {
            "code": 2178,
            "category": 1 /* Error */
        },
        "Unable to resolve module reference '{0}'.": {
            "code": 2179,
            "category": 1 /* Error */
        },
        "Could not find module '{0}' in module '{1}'.": {
            "code": 2180,
            "category": 1 /* Error */
        },
        "Exported import declaration '{0}' is assigned value with type that has or is using private type '{1}'.": {
            "code": 2181,
            "category": 1 /* Error */
        },
        "Exported import declaration '{0}' is assigned value with type that is using inaccessible module '{1}'.": {
            "code": 2182,
            "category": 1 /* Error */
        },
        "Exported import declaration '{0}' is assigned type that has or is using private type '{1}'.": {
            "code": 2183,
            "category": 1 /* Error */
        },
        "Exported import declaration '{0}' is assigned type that is using inaccessible module '{1}'.": {
            "code": 2184,
            "category": 1 /* Error */
        },
        "Exported import declaration '{0}' is assigned container that is or is using inaccessible module '{1}'.": {
            "code": 2185,
            "category": 1 /* Error */
        },
        "Type reference '{0}' in extends clause doesn't reference constructor function for '{1}'.": {
            "code": 2186,
            "category": 1 /* Error */
        },
        "Internal module reference '{0}' in import declaration doesn't reference module instance for '{1}'.": {
            "code": 2187,
            "category": 1 /* Error */
        },
        "Type '{0}' is missing property '{1}' from type '{2}'.": {
            "code": 4000,
            "category": 3 /* NoPrefix */
        },
        "Types of property '{0}' of types '{1}' and '{2}' are incompatible.": {
            "code": 4001,
            "category": 3 /* NoPrefix */
        },
        "Types of property '{0}' of types '{1}' and '{2}' are incompatible:{NL}{3}": {
            "code": 4002,
            "category": 3 /* NoPrefix */
        },
        "Property '{0}' defined as private in type '{1}' is defined as public in type '{2}'.": {
            "code": 4003,
            "category": 3 /* NoPrefix */
        },
        "Property '{0}' defined as public in type '{1}' is defined as private in type '{2}'.": {
            "code": 4004,
            "category": 3 /* NoPrefix */
        },
        "Types '{0}' and '{1}' define property '{2}' as private.": {
            "code": 4005,
            "category": 3 /* NoPrefix */
        },
        "Call signatures of types '{0}' and '{1}' are incompatible.": {
            "code": 4006,
            "category": 3 /* NoPrefix */
        },
        "Call signatures of types '{0}' and '{1}' are incompatible:{NL}{2}": {
            "code": 4007,
            "category": 3 /* NoPrefix */
        },
        "Type '{0}' requires a call signature, but type '{1}' lacks one.": {
            "code": 4008,
            "category": 3 /* NoPrefix */
        },
        "Construct signatures of types '{0}' and '{1}' are incompatible.": {
            "code": 4009,
            "category": 3 /* NoPrefix */
        },
        "Construct signatures of types '{0}' and '{1}' are incompatible:{NL}{2}": {
            "code": 40010,
            "category": 3 /* NoPrefix */
        },
        "Type '{0}' requires a construct signature, but type '{1}' lacks one.": {
            "code": 4011,
            "category": 3 /* NoPrefix */
        },
        "Index signatures of types '{0}' and '{1}' are incompatible.": {
            "code": 4012,
            "category": 3 /* NoPrefix */
        },
        "Index signatures of types '{0}' and '{1}' are incompatible:{NL}{2}": {
            "code": 4013,
            "category": 3 /* NoPrefix */
        },
        "Call signature expects {0} or fewer parameters.": {
            "code": 4014,
            "category": 3 /* NoPrefix */
        },
        "Could not apply type '{0}' to argument {1} which is of type '{2}'.": {
            "code": 4015,
            "category": 3 /* NoPrefix */
        },
        "Class '{0}' defines instance member accessor '{1}', but extended class '{2}' defines it as instance member function.": {
            "code": 4016,
            "category": 3 /* NoPrefix */
        },
        "Class '{0}' defines instance member property '{1}', but extended class '{2}' defines it as instance member function.": {
            "code": 4017,
            "category": 3 /* NoPrefix */
        },
        "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member accessor.": {
            "code": 4018,
            "category": 3 /* NoPrefix */
        },
        "Class '{0}' defines instance member function '{1}', but extended class '{2}' defines it as instance member property.": {
            "code": 4019,
            "category": 3 /* NoPrefix */
        },
        "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible.": {
            "code": 4020,
            "category": 3 /* NoPrefix */
        },
        "Types of static property '{0}' of class '{1}' and class '{2}' are incompatible:{NL}{3}": {
            "code": 4021,
            "category": 3 /* NoPrefix */
        },
        "Type reference cannot refer to container '{0}'.": {
            "code": 4022,
            "category": 1 /* Error */
        },
        "Type reference must refer to type.": {
            "code": 4023,
            "category": 1 /* Error */
        },
        "Enums with multiple declarations must provide an initializer for the first enum element.": {
            "code": 4024,
            "category": 1 /* Error */
        },
        " (+ {0} overload(s))": {
            "code": 4025,
            "category": 2 /* Message */
        },
        "Current host does not support '{0}' option.": {
            "code": 5001,
            "category": 1 /* Error */
        },
        "ECMAScript target version '{0}' not supported.  Using default '{1}' code generation.": {
            "code": 5002,
            "category": 0 /* Warning */
        },
        "Module code generation '{0}' not supported.": {
            "code": 5003,
            "category": 0 /* Warning */
        },
        "Could not find file: '{0}'.": {
            "code": 5004,
            "category": 1 /* Error */
        },
        "A file cannot have a reference to itself.": {
            "code": 5006,
            "category": 1 /* Error */
        },
        "Cannot resolve referenced file: '{0}'.": {
            "code": 5007,
            "category": 1 /* Error */
        },
        "Cannot find the common subdirectory path for the input files.": {
            "code": 5009,
            "category": 1 /* Error */
        },
        "Emit Error: {0}.": {
            "code": 5011,
            "category": 1 /* Error */
        },
        "Cannot read file '{0}': {1}": {
            "code": 5012,
            "category": 1 /* Error */
        },
        "Unsupported file encoding.": {
            "code": 5013,
            "category": 3 /* NoPrefix */
        },
        "Locale must be of the form <language> or <language>-<territory>. For example '{0}' or '{1}'.": {
            "code": 5014,
            "category": 1 /* Error */
        },
        "Unsupported locale: '{0}'.": {
            "code": 5015,
            "category": 1 /* Error */
        },
        "Execution Failed.{NL}": {
            "code": 5016,
            "category": 1 /* Error */
        },
        "Should not emit a type query": {
            "code": 5017,
            "category": 1 /* Error */
        },
        "Should not emit a type reference": {
            "code": 5018,
            "category": 1 /* Error */
        },
        "Invalid call to 'up'": {
            "code": 5019,
            "category": 1 /* Error */
        },
        "Invalid call to 'down'": {
            "code": 5020,
            "category": 1 /* Error */
        },
        "Base64 value '{0}' finished with a continuation bit": {
            "code": 5021,
            "category": 1 /* Error */
        },
        "Key was already in table": {
            "code": 5022,
            "category": 1 /* Error */
        },
        "Unknown option '{0}'": {
            "code": 5023,
            "category": 1 /* Error */
        },
        "Expected {0} arguments to message, got {1} instead": {
            "code": 5024,
            "category": 1 /* Error */
        },
        "Expected the message '{0}' to have {1} arguments, but it had {2}": {
            "code": 5025,
            "category": 1 /* Error */
        },
        "Invalid argument: {0}. {1}": {
            "code": 5026,
            "category": 1 /* Error */
        },
        "Invalid argument: {0}.": {
            "code": 5027,
            "category": 1 /* Error */
        },
        "Argument out of range: {0}.": {
            "code": 5028,
            "category": 1 /* Error */
        },
        "Argument null: {0}.": {
            "code": 5029,
            "category": 1 /* Error */
        },
        "Operation not implemented properly by subclass.": {
            "code": 5030,
            "category": 1 /* Error */
        },
        "Not yet implemented.": {
            "code": 5031,
            "category": 1 /* Error */
        },
        "Invalid operation: {0}": {
            "code": 5032,
            "category": 1 /* Error */
        },
        "Invalid operation.": {
            "code": 5033,
            "category": 1 /* Error */
        },
        "Could not delete file '{0}'": {
            "code": 5034,
            "category": 1 /* Error */
        },
        "Could not create directory '{0}'": {
            "code": 5035,
            "category": 1 /* Error */
        },
        "Error while executing file '{0}': ": {
            "code": 5036,
            "category": 1 /* Error */
        },
        "Cannot compile external modules unless the '--module' flag is provided.": {
            "code": 5037,
            "category": 1 /* Error */
        },
        "Option mapRoot cannot be specified without specifying sourcemap option.": {
            "code": 5038,
            "category": 1 /* Error */
        },
        "Option sourceRoot cannot be specified without specifying sourcemap option.": {
            "code": 5039,
            "category": 1 /* Error */
        },
        "Options mapRoot and sourceRoot cannot be specified without specifying sourcemap option.": {
            "code": 5040,
            "category": 1 /* Error */
        },
        "Concatenate and emit output to single file": {
            "code": 6001,
            "category": 2 /* Message */
        },
        "Generates corresponding {0} file": {
            "code": 6002,
            "category": 2 /* Message */
        },
        "Specifies the location where debugger should locate map files instead of generated locations.": {
            "code": 6003,
            "category": 2 /* Message */
        },
        "Specifies the location where debugger should locate TypeScript files instead of source locations.": {
            "code": 6004,
            "category": 2 /* Message */
        },
        "Watch input files": {
            "code": 6005,
            "category": 2 /* Message */
        },
        "Redirect output structure to the directory": {
            "code": 6006,
            "category": 2 /* Message */
        },
        "Do not emit comments to output": {
            "code": 6009,
            "category": 2 /* Message */
        },
        "Skip resolution and preprocessing": {
            "code": 6010,
            "category": 2 /* Message */
        },
        "Specify ECMAScript target version: \"{0}\" (default), or \"{1}\"": {
            "code": 6015,
            "category": 2 /* Message */
        },
        "Specify module code generation: \"{0}\" or \"{1}\"": {
            "code": 6016,
            "category": 2 /* Message */
        },
        "Print this message": {
            "code": 6017,
            "category": 2 /* Message */
        },
        "Print the compiler's version: {0}": {
            "code": 6019,
            "category": 2 /* Message */
        },
        "Allow use of deprecated \"{0}\" keyword when referencing an external module": {
            "code": 6021,
            "category": 2 /* Message */
        },
        "Specify locale for errors and messages. For example '{0}' or '{1}'": {
            "code": 6022,
            "category": 2 /* Message */
        },
        "Syntax:   {0}": {
            "code": 6023,
            "category": 2 /* Message */
        },
        "options": {
            "code": 6024,
            "category": 2 /* Message */
        },
        "file": {
            "code": 6025,
            "category": 2 /* Message */
        },
        "Examples:": {
            "code": 6026,
            "category": 2 /* Message */
        },
        "Options:": {
            "code": 6027,
            "category": 2 /* Message */
        },
        "Insert command line options and files from a file.": {
            "code": 6030,
            "category": 2 /* Message */
        },
        "Version {0}": {
            "code": 6029,
            "category": 2 /* Message */
        },
        "Use the '{0}' flag to see options": {
            "code": 6031,
            "category": 2 /* Message */
        },
        "{NL}Recompiling ({0}):": {
            "code": 6032,
            "category": 2 /* Message */
        },
        "STRING": {
            "code": 6033,
            "category": 2 /* Message */
        },
        "KIND": {
            "code": 6034,
            "category": 2 /* Message */
        },
        "FILE": {
            "code": 6035,
            "category": 2 /* Message */
        },
        "VERSION": {
            "code": 6036,
            "category": 2 /* Message */
        },
        "LOCATION": {
            "code": 6037,
            "category": 2 /* Message */
        },
        "DIRECTORY": {
            "code": 6038,
            "category": 2 /* Message */
        },
        "This version of the Javascript runtime does not support the '{0}' function.": {
            "code": 7000,
            "category": 1 /* Error */
        },
        "Looking up path for identifier token did not result in an identifer.": {
            "code": 7001,
            "category": 1 /* Error */
        },
        "Unknown rule": {
            "code": 7002,
            "category": 1 /* Error */
        },
        "Invalid line number ({0})": {
            "code": 7003,
            "category": 1 /* Error */
        },
        "Warn on expressions and declarations with an implied 'any' type.": {
            "code": 7004,
            "category": 2 /* Message */
        },
        "Variable '{0}' implicitly has an 'any' type.": {
            "code": 7005,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of '{1}' implicitly has an 'any' type.": {
            "code": 7006,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of function type implicitly has an 'any' type.": {
            "code": 7007,
            "category": 1 /* Error */
        },
        "Member '{0}' of object type implicitly has an 'any' type.": {
            "code": 7008,
            "category": 1 /* Error */
        },
        "\"New\" expression, which lacks a constructor signature, implicitly has an 'any' type.": {
            "code": 7009,
            "category": 1 /* Error */
        },
        "'{0}', which lacks return-type annotation, implicitly has an 'any' return type.": {
            "code": 7010,
            "category": 1 /* Error */
        },
        "Function expression, which lacks return-type annotation, implicitly has an 'any' return type.": {
            "code": 7011,
            "category": 1 /* Error */
        },
        "Parameter '{0}' of lambda function implicitly has an 'any' type.": {
            "code": 7012,
            "category": 1 /* Error */
        },
        "Constructor signature, which lacks return-type annotation, implicitly has an 'any' return type.": {
            "code": 7013,
            "category": 1 /* Error */
        },
        "Lambda Function, which lacks return-type annotation, implicitly has an 'any' return type.": {
            "code": 7014,
            "category": 1 /* Error */
        },
        "Array Literal implicitly has an 'any' type from widening.": {
            "code": 7014,
            "category": 1 /* Error */
        }
    };
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (CharacterCodes) {
        CharacterCodes[CharacterCodes["nullCharacter"] = 0] = "nullCharacter";
        CharacterCodes[CharacterCodes["maxAsciiCharacter"] = 127] = "maxAsciiCharacter";

        CharacterCodes[CharacterCodes["lineFeed"] = 10] = "lineFeed";
        CharacterCodes[CharacterCodes["carriageReturn"] = 13] = "carriageReturn";
        CharacterCodes[CharacterCodes["lineSeparator"] = 0x2028] = "lineSeparator";
        CharacterCodes[CharacterCodes["paragraphSeparator"] = 0x2029] = "paragraphSeparator";

        CharacterCodes[CharacterCodes["nextLine"] = 0x0085] = "nextLine";

        CharacterCodes[CharacterCodes["space"] = 0x0020] = "space";
        CharacterCodes[CharacterCodes["nonBreakingSpace"] = 0x00A0] = "nonBreakingSpace";
        CharacterCodes[CharacterCodes["enQuad"] = 0x2000] = "enQuad";
        CharacterCodes[CharacterCodes["emQuad"] = 0x2001] = "emQuad";
        CharacterCodes[CharacterCodes["enSpace"] = 0x2002] = "enSpace";
        CharacterCodes[CharacterCodes["emSpace"] = 0x2003] = "emSpace";
        CharacterCodes[CharacterCodes["threePerEmSpace"] = 0x2004] = "threePerEmSpace";
        CharacterCodes[CharacterCodes["fourPerEmSpace"] = 0x2005] = "fourPerEmSpace";
        CharacterCodes[CharacterCodes["sixPerEmSpace"] = 0x2006] = "sixPerEmSpace";
        CharacterCodes[CharacterCodes["figureSpace"] = 0x2007] = "figureSpace";
        CharacterCodes[CharacterCodes["punctuationSpace"] = 0x2008] = "punctuationSpace";
        CharacterCodes[CharacterCodes["thinSpace"] = 0x2009] = "thinSpace";
        CharacterCodes[CharacterCodes["hairSpace"] = 0x200A] = "hairSpace";
        CharacterCodes[CharacterCodes["zeroWidthSpace"] = 0x200B] = "zeroWidthSpace";
        CharacterCodes[CharacterCodes["narrowNoBreakSpace"] = 0x202F] = "narrowNoBreakSpace";
        CharacterCodes[CharacterCodes["ideographicSpace"] = 0x3000] = "ideographicSpace";

        CharacterCodes[CharacterCodes["_"] = 95] = "_";
        CharacterCodes[CharacterCodes["$"] = 36] = "$";

        CharacterCodes[CharacterCodes["_0"] = 48] = "_0";
        CharacterCodes[CharacterCodes["_9"] = 57] = "_9";

        CharacterCodes[CharacterCodes["a"] = 97] = "a";
        CharacterCodes[CharacterCodes["b"] = 98] = "b";
        CharacterCodes[CharacterCodes["c"] = 99] = "c";
        CharacterCodes[CharacterCodes["d"] = 100] = "d";
        CharacterCodes[CharacterCodes["e"] = 101] = "e";
        CharacterCodes[CharacterCodes["f"] = 102] = "f";
        CharacterCodes[CharacterCodes["g"] = 103] = "g";
        CharacterCodes[CharacterCodes["h"] = 104] = "h";
        CharacterCodes[CharacterCodes["i"] = 105] = "i";
        CharacterCodes[CharacterCodes["k"] = 107] = "k";
        CharacterCodes[CharacterCodes["l"] = 108] = "l";
        CharacterCodes[CharacterCodes["m"] = 109] = "m";
        CharacterCodes[CharacterCodes["n"] = 110] = "n";
        CharacterCodes[CharacterCodes["o"] = 111] = "o";
        CharacterCodes[CharacterCodes["p"] = 112] = "p";
        CharacterCodes[CharacterCodes["q"] = 113] = "q";
        CharacterCodes[CharacterCodes["r"] = 114] = "r";
        CharacterCodes[CharacterCodes["s"] = 115] = "s";
        CharacterCodes[CharacterCodes["t"] = 116] = "t";
        CharacterCodes[CharacterCodes["u"] = 117] = "u";
        CharacterCodes[CharacterCodes["v"] = 118] = "v";
        CharacterCodes[CharacterCodes["w"] = 119] = "w";
        CharacterCodes[CharacterCodes["x"] = 120] = "x";
        CharacterCodes[CharacterCodes["y"] = 121] = "y";
        CharacterCodes[CharacterCodes["z"] = 122] = "z";

        CharacterCodes[CharacterCodes["A"] = 65] = "A";
        CharacterCodes[CharacterCodes["E"] = 69] = "E";
        CharacterCodes[CharacterCodes["F"] = 70] = "F";
        CharacterCodes[CharacterCodes["X"] = 88] = "X";
        CharacterCodes[CharacterCodes["Z"] = 90] = "Z";

        CharacterCodes[CharacterCodes["ampersand"] = 38] = "ampersand";
        CharacterCodes[CharacterCodes["asterisk"] = 42] = "asterisk";
        CharacterCodes[CharacterCodes["at"] = 64] = "at";
        CharacterCodes[CharacterCodes["backslash"] = 92] = "backslash";
        CharacterCodes[CharacterCodes["bar"] = 124] = "bar";
        CharacterCodes[CharacterCodes["caret"] = 94] = "caret";
        CharacterCodes[CharacterCodes["closeBrace"] = 125] = "closeBrace";
        CharacterCodes[CharacterCodes["closeBracket"] = 93] = "closeBracket";
        CharacterCodes[CharacterCodes["closeParen"] = 41] = "closeParen";
        CharacterCodes[CharacterCodes["colon"] = 58] = "colon";
        CharacterCodes[CharacterCodes["comma"] = 44] = "comma";
        CharacterCodes[CharacterCodes["dot"] = 46] = "dot";
        CharacterCodes[CharacterCodes["doubleQuote"] = 34] = "doubleQuote";
        CharacterCodes[CharacterCodes["equals"] = 61] = "equals";
        CharacterCodes[CharacterCodes["exclamation"] = 33] = "exclamation";
        CharacterCodes[CharacterCodes["greaterThan"] = 62] = "greaterThan";
        CharacterCodes[CharacterCodes["lessThan"] = 60] = "lessThan";
        CharacterCodes[CharacterCodes["minus"] = 45] = "minus";
        CharacterCodes[CharacterCodes["openBrace"] = 123] = "openBrace";
        CharacterCodes[CharacterCodes["openBracket"] = 91] = "openBracket";
        CharacterCodes[CharacterCodes["openParen"] = 40] = "openParen";
        CharacterCodes[CharacterCodes["percent"] = 37] = "percent";
        CharacterCodes[CharacterCodes["plus"] = 43] = "plus";
        CharacterCodes[CharacterCodes["question"] = 63] = "question";
        CharacterCodes[CharacterCodes["semicolon"] = 59] = "semicolon";
        CharacterCodes[CharacterCodes["singleQuote"] = 39] = "singleQuote";
        CharacterCodes[CharacterCodes["slash"] = 47] = "slash";
        CharacterCodes[CharacterCodes["tilde"] = 126] = "tilde";

        CharacterCodes[CharacterCodes["backspace"] = 8] = "backspace";
        CharacterCodes[CharacterCodes["formFeed"] = 12] = "formFeed";
        CharacterCodes[CharacterCodes["byteOrderMark"] = 0xFEFF] = "byteOrderMark";
        CharacterCodes[CharacterCodes["tab"] = 9] = "tab";
        CharacterCodes[CharacterCodes["verticalTab"] = 11] = "verticalTab";
    })(TypeScript.CharacterCodes || (TypeScript.CharacterCodes = {}));
    var CharacterCodes = TypeScript.CharacterCodes;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (ScriptSnapshot) {
        var StringScriptSnapshot = (function () {
            function StringScriptSnapshot(text) {
                this.text = text;
            }
            StringScriptSnapshot.prototype.getText = function (start, end) {
                return this.text.substring(start, end);
            };

            StringScriptSnapshot.prototype.getLength = function () {
                return this.text.length;
            };

            StringScriptSnapshot.prototype.getLineStartPositions = function () {
                return TypeScript.TextUtilities.parseLineStarts(TypeScript.SimpleText.fromString(this.text));
            };

            StringScriptSnapshot.prototype.getTextChangeRangeSinceVersion = function (scriptVersion) {
                throw TypeScript.Errors.notYetImplemented();
            };
            return StringScriptSnapshot;
        })();

        function fromString(text) {
            return new StringScriptSnapshot(text);
        }
        ScriptSnapshot.fromString = fromString;
    })(TypeScript.ScriptSnapshot || (TypeScript.ScriptSnapshot = {}));
    var ScriptSnapshot = TypeScript.ScriptSnapshot;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var LineMap = (function () {
        function LineMap(_lineStarts, length) {
            this._lineStarts = _lineStarts;
            this.length = length;
        }
        LineMap.prototype.toJSON = function (key) {
            return { lineStarts: this._lineStarts, length: this.length };
        };

        LineMap.prototype.equals = function (other) {
            return this.length === other.length && TypeScript.ArrayUtilities.sequenceEquals(this.lineStarts(), other.lineStarts(), function (v1, v2) {
                return v1 === v2;
            });
        };

        LineMap.prototype.lineStarts = function () {
            return this._lineStarts;
        };

        LineMap.prototype.lineCount = function () {
            return this.lineStarts().length;
        };

        LineMap.prototype.getPosition = function (line, character) {
            return this.lineStarts()[line] + character;
        };

        LineMap.prototype.getLineNumberFromPosition = function (position) {
            if (position < 0 || position > this.length) {
                throw TypeScript.Errors.argumentOutOfRange("position");
            }

            if (position === this.length) {
                return this.lineCount() - 1;
            }

            var lineNumber = TypeScript.ArrayUtilities.binarySearch(this.lineStarts(), position);
            if (lineNumber < 0) {
                lineNumber = (~lineNumber) - 1;
            }

            return lineNumber;
        };

        LineMap.prototype.getLineStartPosition = function (lineNumber) {
            return this.lineStarts()[lineNumber];
        };

        LineMap.prototype.fillLineAndCharacterFromPosition = function (position, lineAndCharacter) {
            if (position < 0 || position > this.length) {
                throw TypeScript.Errors.argumentOutOfRange("position");
            }

            var lineNumber = this.getLineNumberFromPosition(position);
            lineAndCharacter.line = lineNumber;
            lineAndCharacter.character = position - this.lineStarts()[lineNumber];
        };

        LineMap.prototype.getLineAndCharacterFromPosition = function (position) {
            if (position < 0 || position > this.length) {
                throw TypeScript.Errors.argumentOutOfRange("position");
            }

            var lineNumber = this.getLineNumberFromPosition(position);

            return new TypeScript.LineAndCharacter(lineNumber, position - this.lineStarts()[lineNumber]);
        };

        LineMap.fromSimpleText = function (text) {
            var lineStarts = TypeScript.TextUtilities.parseLineStarts(text);

            return new LineMap(lineStarts, text.length());
        };

        LineMap.fromScriptSnapshot = function (scriptSnapshot) {
            return new LineMap(scriptSnapshot.getLineStartPositions(), scriptSnapshot.getLength());
        };

        LineMap.fromString = function (text) {
            return LineMap.fromSimpleText(TypeScript.SimpleText.fromString(text));
        };
        LineMap.empty = new LineMap([0], 0);
        return LineMap;
    })();
    TypeScript.LineMap = LineMap;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var LineAndCharacter = (function () {
        function LineAndCharacter(line, character) {
            this._line = 0;
            this._character = 0;
            if (line < 0) {
                throw TypeScript.Errors.argumentOutOfRange("line");
            }

            if (character < 0) {
                throw TypeScript.Errors.argumentOutOfRange("character");
            }

            this._line = line;
            this._character = character;
        }
        LineAndCharacter.prototype.line = function () {
            return this._line;
        };

        LineAndCharacter.prototype.character = function () {
            return this._character;
        };
        return LineAndCharacter;
    })();
    TypeScript.LineAndCharacter = LineAndCharacter;
})(TypeScript || (TypeScript = {}));
var __extends = this.__extends || function (d, b) {
    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];
    function __() { this.constructor = d; }
    __.prototype = b.prototype;
    d.prototype = new __();
};
var TypeScript;
(function (TypeScript) {
    (function (TextFactory) {
        function getStartAndLengthOfLineBreakEndingAt(text, index, info) {
            var c = text.charCodeAt(index);
            if (c === 10 /* lineFeed */) {
                if (index > 0 && text.charCodeAt(index - 1) === 13 /* carriageReturn */) {
                    info.startPosition = index - 1;
                    info.length = 2;
                } else {
                    info.startPosition = index;
                    info.length = 1;
                }
            } else if (TypeScript.TextUtilities.isAnyLineBreakCharacter(c)) {
                info.startPosition = index;
                info.length = 1;
            } else {
                info.startPosition = index + 1;
                info.length = 0;
            }
        }

        var LinebreakInfo = (function () {
            function LinebreakInfo(startPosition, length) {
                this.startPosition = startPosition;
                this.length = length;
            }
            return LinebreakInfo;
        })();

        var TextLine = (function () {
            function TextLine(text, body, lineBreakLength, lineNumber) {
                this._text = null;
                this._textSpan = null;
                if (text === null) {
                    throw TypeScript.Errors.argumentNull('text');
                }
                TypeScript.Debug.assert(lineBreakLength >= 0);
                TypeScript.Debug.assert(lineNumber >= 0);
                this._text = text;
                this._textSpan = body;
                this._lineBreakLength = lineBreakLength;
                this._lineNumber = lineNumber;
            }
            TextLine.prototype.start = function () {
                return this._textSpan.start();
            };

            TextLine.prototype.end = function () {
                return this._textSpan.end();
            };

            TextLine.prototype.endIncludingLineBreak = function () {
                return this.end() + this._lineBreakLength;
            };

            TextLine.prototype.extent = function () {
                return this._textSpan;
            };

            TextLine.prototype.extentIncludingLineBreak = function () {
                return TypeScript.TextSpan.fromBounds(this.start(), this.endIncludingLineBreak());
            };

            TextLine.prototype.toString = function () {
                return this._text.toString(this._textSpan);
            };

            TextLine.prototype.lineNumber = function () {
                return this._lineNumber;
            };
            return TextLine;
        })();

        var TextBase = (function () {
            function TextBase() {
                this.lazyLineStarts = null;
                this.linebreakInfo = new LinebreakInfo(0, 0);
                this.lastLineFoundForPosition = null;
            }
            TextBase.prototype.length = function () {
                throw TypeScript.Errors.abstract();
            };

            TextBase.prototype.charCodeAt = function (position) {
                throw TypeScript.Errors.abstract();
            };

            TextBase.prototype.checkSubSpan = function (span) {
                if (span.start() < 0 || span.start() > this.length() || span.end() > this.length()) {
                    throw TypeScript.Errors.argumentOutOfRange("span");
                }
            };

            TextBase.prototype.toString = function (span) {
                if (typeof span === "undefined") { span = null; }
                throw TypeScript.Errors.abstract();
            };

            TextBase.prototype.subText = function (span) {
                this.checkSubSpan(span);

                return new SubText(this, span);
            };

            TextBase.prototype.substr = function (start, length, intern) {
                throw TypeScript.Errors.abstract();
            };

            TextBase.prototype.copyTo = function (sourceIndex, destination, destinationIndex, count) {
                throw TypeScript.Errors.abstract();
            };

            TextBase.prototype.lineCount = function () {
                return this.lineStarts().length;
            };

            TextBase.prototype.lines = function () {
                var lines = [];

                var length = this.lineCount();
                for (var i = 0; i < length; ++i) {
                    lines[i] = this.getLineFromLineNumber(i);
                }

                return lines;
            };

            TextBase.prototype.lineMap = function () {
                return new TypeScript.LineMap(this.lineStarts(), this.length());
            };

            TextBase.prototype.lineStarts = function () {
                if (this.lazyLineStarts === null) {
                    this.lazyLineStarts = TypeScript.TextUtilities.parseLineStarts(this);
                }

                return this.lazyLineStarts;
            };

            TextBase.prototype.getLineFromLineNumber = function (lineNumber) {
                var lineStarts = this.lineStarts();

                if (lineNumber < 0 || lineNumber >= lineStarts.length) {
                    throw TypeScript.Errors.argumentOutOfRange("lineNumber");
                }

                var first = lineStarts[lineNumber];
                if (lineNumber === lineStarts.length - 1) {
                    return new TextLine(this, new TypeScript.TextSpan(first, this.length() - first), 0, lineNumber);
                } else {
                    getStartAndLengthOfLineBreakEndingAt(this, lineStarts[lineNumber + 1] - 1, this.linebreakInfo);
                    return new TextLine(this, new TypeScript.TextSpan(first, this.linebreakInfo.startPosition - first), this.linebreakInfo.length, lineNumber);
                }
            };

            TextBase.prototype.getLineFromPosition = function (position) {
                var lastFound = this.lastLineFoundForPosition;
                if (lastFound !== null && lastFound.start() <= position && lastFound.endIncludingLineBreak() > position) {
                    return lastFound;
                }

                var lineNumber = this.getLineNumberFromPosition(position);

                var result = this.getLineFromLineNumber(lineNumber);
                this.lastLineFoundForPosition = result;
                return result;
            };

            TextBase.prototype.getLineNumberFromPosition = function (position) {
                if (position < 0 || position > this.length()) {
                    throw TypeScript.Errors.argumentOutOfRange("position");
                }

                if (position === this.length()) {
                    return this.lineCount() - 1;
                }

                var lineNumber = TypeScript.ArrayUtilities.binarySearch(this.lineStarts(), position);
                if (lineNumber < 0) {
                    lineNumber = (~lineNumber) - 1;
                }

                return lineNumber;
            };

            TextBase.prototype.getLinePosition = function (position) {
                if (position < 0 || position > this.length()) {
                    throw TypeScript.Errors.argumentOutOfRange("position");
                }

                var lineNumber = this.getLineNumberFromPosition(position);

                return new TypeScript.LineAndCharacter(lineNumber, position - this.lineStarts()[lineNumber]);
            };
            return TextBase;
        })();

        var SubText = (function (_super) {
            __extends(SubText, _super);
            function SubText(text, span) {
                _super.call(this);

                if (text === null) {
                    throw TypeScript.Errors.argumentNull("text");
                }

                if (span.start() < 0 || span.start() >= text.length() || span.end() < 0 || span.end() > text.length()) {
                    throw TypeScript.Errors.argument("span");
                }

                this.text = text;
                this.span = span;
            }
            SubText.prototype.length = function () {
                return this.span.length();
            };

            SubText.prototype.charCodeAt = function (position) {
                if (position < 0 || position > this.length()) {
                    throw TypeScript.Errors.argumentOutOfRange("position");
                }

                return this.text.charCodeAt(this.span.start() + position);
            };

            SubText.prototype.subText = function (span) {
                this.checkSubSpan(span);

                return new SubText(this.text, this.getCompositeSpan(span.start(), span.length()));
            };

            SubText.prototype.copyTo = function (sourceIndex, destination, destinationIndex, count) {
                var span = this.getCompositeSpan(sourceIndex, count);
                this.text.copyTo(span.start(), destination, destinationIndex, span.length());
            };

            SubText.prototype.getCompositeSpan = function (start, length) {
                var compositeStart = TypeScript.MathPrototype.min(this.text.length(), this.span.start() + start);
                var compositeEnd = TypeScript.MathPrototype.min(this.text.length(), compositeStart + length);
                return new TypeScript.TextSpan(compositeStart, compositeEnd - compositeStart);
            };
            return SubText;
        })(TextBase);

        var StringText = (function (_super) {
            __extends(StringText, _super);
            function StringText(data) {
                _super.call(this);
                this.source = null;

                if (data === null) {
                    throw TypeScript.Errors.argumentNull("data");
                }

                this.source = data;
            }
            StringText.prototype.length = function () {
                return this.source.length;
            };

            StringText.prototype.charCodeAt = function (position) {
                if (position < 0 || position >= this.source.length) {
                    throw TypeScript.Errors.argumentOutOfRange("position");
                }

                return this.source.charCodeAt(position);
            };

            StringText.prototype.substr = function (start, length, intern) {
                return this.source.substr(start, length);
            };

            StringText.prototype.toString = function (span) {
                if (typeof span === "undefined") { span = null; }
                if (span === null) {
                    span = new TypeScript.TextSpan(0, this.length());
                }

                this.checkSubSpan(span);

                if (span.start() === 0 && span.length() === this.length()) {
                    return this.source;
                }

                return this.source.substr(span.start(), span.length());
            };

            StringText.prototype.copyTo = function (sourceIndex, destination, destinationIndex, count) {
                TypeScript.StringUtilities.copyTo(this.source, sourceIndex, destination, destinationIndex, count);
            };
            return StringText;
        })(TextBase);

        function createText(value) {
            return new StringText(value);
        }
        TextFactory.createText = createText;
    })(TypeScript.TextFactory || (TypeScript.TextFactory = {}));
    var TextFactory = TypeScript.TextFactory;
})(TypeScript || (TypeScript = {}));

var TypeScript;
(function (TypeScript) {
    (function (SimpleText) {
        var SimpleSubText = (function () {
            function SimpleSubText(text, span) {
                this.text = null;
                this.span = null;
                if (text === null) {
                    throw TypeScript.Errors.argumentNull("text");
                }

                if (span.start() < 0 || span.start() >= text.length() || span.end() < 0 || span.end() > text.length()) {
                    throw TypeScript.Errors.argument("span");
                }

                this.text = text;
                this.span = span;
            }
            SimpleSubText.prototype.checkSubSpan = function (span) {
                if (span.start() < 0 || span.start() > this.length() || span.end() > this.length()) {
                    throw TypeScript.Errors.argumentOutOfRange("span");
                }
            };

            SimpleSubText.prototype.checkSubPosition = function (position) {
                if (position < 0 || position >= this.length()) {
                    throw TypeScript.Errors.argumentOutOfRange("position");
                }
            };

            SimpleSubText.prototype.length = function () {
                return this.span.length();
            };

            SimpleSubText.prototype.subText = function (span) {
                this.checkSubSpan(span);

                return new SimpleSubText(this.text, this.getCompositeSpan(span.start(), span.length()));
            };

            SimpleSubText.prototype.copyTo = function (sourceIndex, destination, destinationIndex, count) {
                var span = this.getCompositeSpan(sourceIndex, count);
                this.text.copyTo(span.start(), destination, destinationIndex, span.length());
            };

            SimpleSubText.prototype.substr = function (start, length, intern) {
                var span = this.getCompositeSpan(start, length);
                return this.text.substr(span.start(), span.length(), intern);
            };

            SimpleSubText.prototype.getCompositeSpan = function (start, length) {
                var compositeStart = TypeScript.MathPrototype.min(this.text.length(), this.span.start() + start);
                var compositeEnd = TypeScript.MathPrototype.min(this.text.length(), compositeStart + length);
                return new TypeScript.TextSpan(compositeStart, compositeEnd - compositeStart);
            };

            SimpleSubText.prototype.charCodeAt = function (index) {
                this.checkSubPosition(index);
                return this.text.charCodeAt(this.span.start() + index);
            };

            SimpleSubText.prototype.lineMap = function () {
                return TypeScript.LineMap.fromSimpleText(this);
            };
            return SimpleSubText;
        })();

        var SimpleStringText = (function () {
            function SimpleStringText(value) {
                this.value = value;
            }
            SimpleStringText.prototype.length = function () {
                return this.value.length;
            };

            SimpleStringText.prototype.copyTo = function (sourceIndex, destination, destinationIndex, count) {
                TypeScript.StringUtilities.copyTo(this.value, sourceIndex, destination, destinationIndex, count);
            };

            SimpleStringText.prototype.substr = function (start, length, intern) {
                if (intern) {
                    var array = length <= SimpleStringText.charArray.length ? SimpleStringText.charArray : TypeScript.ArrayUtilities.createArray(length, 0);
                    this.copyTo(start, array, 0, length);
                    return TypeScript.Collections.DefaultStringTable.addCharArray(array, 0, length);
                }

                return this.value.substr(start, length);
            };

            SimpleStringText.prototype.subText = function (span) {
                return new SimpleSubText(this, span);
            };

            SimpleStringText.prototype.charCodeAt = function (index) {
                return this.value.charCodeAt(index);
            };

            SimpleStringText.prototype.lineMap = function () {
                return TypeScript.LineMap.fromSimpleText(this);
            };
            SimpleStringText.charArray = TypeScript.ArrayUtilities.createArray(1024, 0);
            return SimpleStringText;
        })();

        var SimpleScriptSnapshotText = (function () {
            function SimpleScriptSnapshotText(scriptSnapshot) {
                this.scriptSnapshot = scriptSnapshot;
            }
            SimpleScriptSnapshotText.prototype.charCodeAt = function (index) {
                return this.scriptSnapshot.getText(index, index + 1).charCodeAt(0);
            };

            SimpleScriptSnapshotText.prototype.length = function () {
                return this.scriptSnapshot.getLength();
            };

            SimpleScriptSnapshotText.prototype.copyTo = function (sourceIndex, destination, destinationIndex, count) {
                var text = this.scriptSnapshot.getText(sourceIndex, sourceIndex + count);
                TypeScript.StringUtilities.copyTo(text, 0, destination, destinationIndex, count);
            };

            SimpleScriptSnapshotText.prototype.substr = function (start, length, intern) {
                return this.scriptSnapshot.getText(start, start + length);
            };

            SimpleScriptSnapshotText.prototype.subText = function (span) {
                return new SimpleSubText(this, span);
            };

            SimpleScriptSnapshotText.prototype.lineMap = function () {
                var lineStartPositions = this.scriptSnapshot.getLineStartPositions();
                return new TypeScript.LineMap(lineStartPositions, this.length());
            };
            return SimpleScriptSnapshotText;
        })();

        function fromString(value) {
            return new SimpleStringText(value);
        }
        SimpleText.fromString = fromString;

        function fromScriptSnapshot(scriptSnapshot) {
            return new SimpleScriptSnapshotText(scriptSnapshot);
        }
        SimpleText.fromScriptSnapshot = fromScriptSnapshot;
    })(TypeScript.SimpleText || (TypeScript.SimpleText = {}));
    var SimpleText = TypeScript.SimpleText;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (TextUtilities) {
        function parseLineStarts(text) {
            var length = text.length();

            if (0 === length) {
                var result = new Array();
                result.push(0);
                return result;
            }

            var position = 0;
            var index = 0;
            var arrayBuilder = new Array();
            var lineNumber = 0;

            while (index < length) {
                var c = text.charCodeAt(index);
                var lineBreakLength;

                if (c > 13 /* carriageReturn */ && c <= 127) {
                    index++;
                    continue;
                } else if (c === 13 /* carriageReturn */ && index + 1 < length && text.charCodeAt(index + 1) === 10 /* lineFeed */) {
                    lineBreakLength = 2;
                } else if (c === 10 /* lineFeed */) {
                    lineBreakLength = 1;
                } else {
                    lineBreakLength = TextUtilities.getLengthOfLineBreak(text, index);
                }

                if (0 === lineBreakLength) {
                    index++;
                } else {
                    arrayBuilder.push(position);
                    index += lineBreakLength;
                    position = index;
                    lineNumber++;
                }
            }

            arrayBuilder.push(position);

            return arrayBuilder;
        }
        TextUtilities.parseLineStarts = parseLineStarts;

        function getLengthOfLineBreakSlow(text, index, c) {
            if (c === 13 /* carriageReturn */) {
                var next = index + 1;
                return (next < text.length()) && 10 /* lineFeed */ === text.charCodeAt(next) ? 2 : 1;
            } else if (isAnyLineBreakCharacter(c)) {
                return 1;
            } else {
                return 0;
            }
        }
        TextUtilities.getLengthOfLineBreakSlow = getLengthOfLineBreakSlow;

        function getLengthOfLineBreak(text, index) {
            var c = text.charCodeAt(index);

            if (c > 13 /* carriageReturn */ && c <= 127) {
                return 0;
            }

            return getLengthOfLineBreakSlow(text, index, c);
        }
        TextUtilities.getLengthOfLineBreak = getLengthOfLineBreak;

        function isAnyLineBreakCharacter(c) {
            return c === 10 /* lineFeed */ || c === 13 /* carriageReturn */ || c === 133 /* nextLine */ || c === 8232 /* lineSeparator */ || c === 8233 /* paragraphSeparator */;
        }
        TextUtilities.isAnyLineBreakCharacter = isAnyLineBreakCharacter;
    })(TypeScript.TextUtilities || (TypeScript.TextUtilities = {}));
    var TextUtilities = TypeScript.TextUtilities;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var TextSpan = (function () {
        function TextSpan(start, length) {
            if (start < 0) {
                TypeScript.Errors.argument("start");
            }

            if (length < 0) {
                TypeScript.Errors.argument("length");
            }

            this._start = start;
            this._length = length;
        }
        TextSpan.prototype.start = function () {
            return this._start;
        };

        TextSpan.prototype.length = function () {
            return this._length;
        };

        TextSpan.prototype.end = function () {
            return this._start + this._length;
        };

        TextSpan.prototype.isEmpty = function () {
            return this._length === 0;
        };

        TextSpan.prototype.containsPosition = function (position) {
            return position >= this._start && position < this.end();
        };

        TextSpan.prototype.containsTextSpan = function (span) {
            return span._start >= this._start && span.end() <= this.end();
        };

        TextSpan.prototype.overlapsWith = function (span) {
            var overlapStart = TypeScript.MathPrototype.max(this._start, span._start);
            var overlapEnd = TypeScript.MathPrototype.min(this.end(), span.end());

            return overlapStart < overlapEnd;
        };

        TextSpan.prototype.overlap = function (span) {
            var overlapStart = TypeScript.MathPrototype.max(this._start, span._start);
            var overlapEnd = TypeScript.MathPrototype.min(this.end(), span.end());

            if (overlapStart < overlapEnd) {
                return TextSpan.fromBounds(overlapStart, overlapEnd);
            }

            return null;
        };

        TextSpan.prototype.intersectsWithTextSpan = function (span) {
            return span._start <= this.end() && span.end() >= this._start;
        };

        TextSpan.prototype.intersectsWith = function (start, length) {
            var end = start + length;
            return start <= this.end() && end >= this._start;
        };

        TextSpan.prototype.intersectsWithPosition = function (position) {
            return position <= this.end() && position >= this._start;
        };

        TextSpan.prototype.intersection = function (span) {
            var intersectStart = TypeScript.MathPrototype.max(this._start, span._start);
            var intersectEnd = TypeScript.MathPrototype.min(this.end(), span.end());

            if (intersectStart <= intersectEnd) {
                return TextSpan.fromBounds(intersectStart, intersectEnd);
            }

            return null;
        };

        TextSpan.fromBounds = function (start, end) {
            TypeScript.Debug.assert(start >= 0);
            TypeScript.Debug.assert(end - start >= 0);
            return new TextSpan(start, end - start);
        };
        return TextSpan;
    })();
    TypeScript.TextSpan = TextSpan;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var TextChangeRange = (function () {
        function TextChangeRange(span, newLength) {
            if (newLength < 0) {
                throw TypeScript.Errors.argumentOutOfRange("newLength");
            }

            this._span = span;
            this._newLength = newLength;
        }
        TextChangeRange.prototype.span = function () {
            return this._span;
        };

        TextChangeRange.prototype.newLength = function () {
            return this._newLength;
        };

        TextChangeRange.prototype.newSpan = function () {
            return new TypeScript.TextSpan(this.span().start(), this.newLength());
        };

        TextChangeRange.prototype.isUnchanged = function () {
            return this.span().isEmpty() && this.newLength() === 0;
        };

        TextChangeRange.collapseChangesFromSingleVersion = function (changes) {
            var diff = 0;
            var start = 1073741823 /* Max31BitInteger */;
            var end = 0;

            for (var i = 0; i < changes.length; i++) {
                var change = changes[i];
                diff += change.newLength() - change.span().length();

                if (change.span().start() < start) {
                    start = change.span().start();
                }

                if (change.span().end() > end) {
                    end = change.span().end();
                }
            }

            if (start > end) {
                return null;
            }

            var combined = TypeScript.TextSpan.fromBounds(start, end);
            var newLen = combined.length() + diff;

            return new TextChangeRange(combined, newLen);
        };

        TextChangeRange.collapseChangesAcrossMultipleVersions = function (changes) {
            if (changes.length === 0) {
                return TextChangeRange.unchanged;
            }

            if (changes.length === 1) {
                return changes[0];
            }

            var change0 = changes[0];

            var oldStartN = change0.span().start();
            var oldEndN = change0.span().end();
            var newEndN = oldStartN + change0.newLength();

            for (var i = 1; i < changes.length; i++) {
                var nextChange = changes[i];

                var oldStart1 = oldStartN;
                var oldEnd1 = oldEndN;
                var newEnd1 = newEndN;

                var oldStart2 = nextChange.span().start();
                var oldEnd2 = nextChange.span().end();
                var newEnd2 = oldStart2 + nextChange.newLength();

                oldStartN = TypeScript.MathPrototype.min(oldStart1, oldStart2);
                oldEndN = TypeScript.MathPrototype.max(oldEnd1, oldEnd1 + (oldEnd2 - newEnd1));
                newEndN = TypeScript.MathPrototype.max(newEnd2, newEnd2 + (newEnd1 - oldEnd2));
            }

            return new TextChangeRange(TypeScript.TextSpan.fromBounds(oldStartN, oldEndN), newEndN - oldStartN);
        };
        TextChangeRange.unchanged = new TextChangeRange(new TypeScript.TextSpan(0, 0), 0);
        return TextChangeRange;
    })();
    TypeScript.TextChangeRange = TextChangeRange;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var CharacterInfo = (function () {
        function CharacterInfo() {
        }
        CharacterInfo.isDecimalDigit = function (c) {
            return c >= 48 /* _0 */ && c <= 57 /* _9 */;
        };

        CharacterInfo.isHexDigit = function (c) {
            return CharacterInfo.isDecimalDigit(c) || (c >= 65 /* A */ && c <= 70 /* F */) || (c >= 97 /* a */ && c <= 102 /* f */);
        };

        CharacterInfo.hexValue = function (c) {
            return CharacterInfo.isDecimalDigit(c) ? (c - 48 /* _0 */) : (c >= 65 /* A */ && c <= 70 /* F */) ? c - 65 /* A */ + 10 : c - 97 /* a */ + 10;
        };

        CharacterInfo.isWhitespace = function (ch) {
            switch (ch) {
                case 32 /* space */:
                case 160 /* nonBreakingSpace */:
                case 8192 /* enQuad */:
                case 8193 /* emQuad */:
                case 8194 /* enSpace */:
                case 8195 /* emSpace */:
                case 8196 /* threePerEmSpace */:
                case 8197 /* fourPerEmSpace */:
                case 8198 /* sixPerEmSpace */:
                case 8199 /* figureSpace */:
                case 8200 /* punctuationSpace */:
                case 8201 /* thinSpace */:
                case 8202 /* hairSpace */:
                case 8203 /* zeroWidthSpace */:
                case 8239 /* narrowNoBreakSpace */:
                case 12288 /* ideographicSpace */:

                case 9 /* tab */:
                case 11 /* verticalTab */:
                case 12 /* formFeed */:
                case 65279 /* byteOrderMark */:
                    return true;
            }

            return false;
        };

        CharacterInfo.isLineTerminator = function (ch) {
            switch (ch) {
                case 13 /* carriageReturn */:
                case 10 /* lineFeed */:
                case 8233 /* paragraphSeparator */:
                case 8232 /* lineSeparator */:
                    return true;
            }

            return false;
        };
        return CharacterInfo;
    })();
    TypeScript.CharacterInfo = CharacterInfo;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (SyntaxConstants) {
        SyntaxConstants[SyntaxConstants["TriviaNewLineMask"] = 0x00000001] = "TriviaNewLineMask";
        SyntaxConstants[SyntaxConstants["TriviaCommentMask"] = 0x00000002] = "TriviaCommentMask";
        SyntaxConstants[SyntaxConstants["TriviaFullWidthShift"] = 2] = "TriviaFullWidthShift";

        SyntaxConstants[SyntaxConstants["NodeDataComputed"] = 0x00000001] = "NodeDataComputed";
        SyntaxConstants[SyntaxConstants["NodeIncrementallyUnusableMask"] = 0x00000002] = "NodeIncrementallyUnusableMask";
        SyntaxConstants[SyntaxConstants["NodeParsedInStrictModeMask"] = 0x00000004] = "NodeParsedInStrictModeMask";
        SyntaxConstants[SyntaxConstants["NodeFullWidthShift"] = 3] = "NodeFullWidthShift";
    })(TypeScript.SyntaxConstants || (TypeScript.SyntaxConstants = {}));
    var SyntaxConstants = TypeScript.SyntaxConstants;
})(TypeScript || (TypeScript = {}));
var FormattingOptions = (function () {
    function FormattingOptions(useTabs, spacesPerTab, indentSpaces, newLineCharacter) {
        this.useTabs = useTabs;
        this.spacesPerTab = spacesPerTab;
        this.indentSpaces = indentSpaces;
        this.newLineCharacter = newLineCharacter;
    }
    FormattingOptions.defaultOptions = new FormattingOptions(false, 4, 4, "\r\n");
    return FormattingOptions;
})();
var TypeScript;
(function (TypeScript) {
    (function (Indentation) {
        function columnForEndOfToken(token, syntaxInformationMap, options) {
            return columnForStartOfToken(token, syntaxInformationMap, options) + token.width();
        }
        Indentation.columnForEndOfToken = columnForEndOfToken;

        function columnForStartOfToken(token, syntaxInformationMap, options) {
            var firstTokenInLine = syntaxInformationMap.firstTokenInLineContainingToken(token);
            var leadingTextInReverse = [];

            var current = token;
            while (current !== firstTokenInLine) {
                current = syntaxInformationMap.previousToken(current);

                if (current === firstTokenInLine) {
                    leadingTextInReverse.push(current.trailingTrivia().fullText());
                    leadingTextInReverse.push(current.text());
                } else {
                    leadingTextInReverse.push(current.fullText());
                }
            }

            collectLeadingTriviaTextToStartOfLine(firstTokenInLine, leadingTextInReverse);

            return columnForLeadingTextInReverse(leadingTextInReverse, options);
        }
        Indentation.columnForStartOfToken = columnForStartOfToken;

        function columnForStartOfFirstTokenInLineContainingToken(token, syntaxInformationMap, options) {
            var firstTokenInLine = syntaxInformationMap.firstTokenInLineContainingToken(token);
            var leadingTextInReverse = [];

            collectLeadingTriviaTextToStartOfLine(firstTokenInLine, leadingTextInReverse);

            return columnForLeadingTextInReverse(leadingTextInReverse, options);
        }
        Indentation.columnForStartOfFirstTokenInLineContainingToken = columnForStartOfFirstTokenInLineContainingToken;

        function collectLeadingTriviaTextToStartOfLine(firstTokenInLine, leadingTextInReverse) {
            var leadingTrivia = firstTokenInLine.leadingTrivia();

            for (var i = leadingTrivia.count() - 1; i >= 0; i--) {
                var trivia = leadingTrivia.syntaxTriviaAt(i);
                if (trivia.kind() === 5 /* NewLineTrivia */) {
                    break;
                }

                if (trivia.kind() === 6 /* MultiLineCommentTrivia */) {
                    var lineSegments = TypeScript.Syntax.splitMultiLineCommentTriviaIntoMultipleLines(trivia);
                    leadingTextInReverse.push(TypeScript.ArrayUtilities.last(lineSegments));

                    if (lineSegments.length > 0) {
                        break;
                    }
                }

                leadingTextInReverse.push(trivia.fullText());
            }
        }

        function columnForLeadingTextInReverse(leadingTextInReverse, options) {
            var column = 0;

            for (var i = leadingTextInReverse.length - 1; i >= 0; i--) {
                var text = leadingTextInReverse[i];
                column = columnForPositionInStringWorker(text, text.length, column, options);
            }

            return column;
        }

        function columnForPositionInString(input, position, options) {
            return columnForPositionInStringWorker(input, position, 0, options);
        }
        Indentation.columnForPositionInString = columnForPositionInString;

        function columnForPositionInStringWorker(input, position, startColumn, options) {
            var column = startColumn;
            var spacesPerTab = options.spacesPerTab;

            for (var j = 0; j < position; j++) {
                var ch = input.charCodeAt(j);

                if (ch === 9 /* tab */) {
                    column += spacesPerTab - column % spacesPerTab;
                } else {
                    column++;
                }
            }

            return column;
        }

        function indentationString(column, options) {
            var numberOfTabs = 0;
            var numberOfSpaces = TypeScript.MathPrototype.max(0, column);

            if (options.useTabs) {
                numberOfTabs = Math.floor(column / options.spacesPerTab);
                numberOfSpaces -= numberOfTabs * options.spacesPerTab;
            }

            return TypeScript.StringUtilities.repeat('\t', numberOfTabs) + TypeScript.StringUtilities.repeat(' ', numberOfSpaces);
        }
        Indentation.indentationString = indentationString;

        function indentationTrivia(column, options) {
            return TypeScript.Syntax.whitespace(this.indentationString(column, options));
        }
        Indentation.indentationTrivia = indentationTrivia;

        function firstNonWhitespacePosition(value) {
            for (var i = 0; i < value.length; i++) {
                var ch = value.charCodeAt(i);
                if (!TypeScript.CharacterInfo.isWhitespace(ch)) {
                    return i;
                }
            }

            return value.length;
        }
        Indentation.firstNonWhitespacePosition = firstNonWhitespacePosition;
    })(TypeScript.Indentation || (TypeScript.Indentation = {}));
    var Indentation = TypeScript.Indentation;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (LanguageVersion) {
        LanguageVersion[LanguageVersion["EcmaScript3"] = 0] = "EcmaScript3";
        LanguageVersion[LanguageVersion["EcmaScript5"] = 1] = "EcmaScript5";
    })(TypeScript.LanguageVersion || (TypeScript.LanguageVersion = {}));
    var LanguageVersion = TypeScript.LanguageVersion;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var ParseOptions = (function () {
        function ParseOptions(languageVersion, allowAutomaticSemicolonInsertion) {
            this._languageVersion = languageVersion;
            this._allowAutomaticSemicolonInsertion = allowAutomaticSemicolonInsertion;
        }
        ParseOptions.prototype.toJSON = function (key) {
            return { allowAutomaticSemicolonInsertion: this._allowAutomaticSemicolonInsertion };
        };

        ParseOptions.prototype.languageVersion = function () {
            return this._languageVersion;
        };

        ParseOptions.prototype.allowAutomaticSemicolonInsertion = function () {
            return this._allowAutomaticSemicolonInsertion;
        };
        return ParseOptions;
    })();
    TypeScript.ParseOptions = ParseOptions;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var PositionedElement = (function () {
        function PositionedElement(parent, element, fullStart) {
            this._parent = parent;
            this._element = element;
            this._fullStart = fullStart;
        }
        PositionedElement.create = function (parent, element, fullStart) {
            if (element === null) {
                return null;
            }

            if (element.isNode()) {
                return new PositionedNode(parent, element, fullStart);
            } else if (element.isToken()) {
                return new PositionedToken(parent, element, fullStart);
            } else if (element.isList()) {
                return new PositionedList(parent, element, fullStart);
            } else if (element.isSeparatedList()) {
                return new PositionedSeparatedList(parent, element, fullStart);
            } else {
                throw TypeScript.Errors.invalidOperation();
            }
        };

        PositionedElement.prototype.parent = function () {
            return this._parent;
        };

        PositionedElement.prototype.parentElement = function () {
            return this._parent && this._parent._element;
        };

        PositionedElement.prototype.element = function () {
            return this._element;
        };

        PositionedElement.prototype.kind = function () {
            return this.element().kind();
        };

        PositionedElement.prototype.childIndex = function (child) {
            return TypeScript.Syntax.childIndex(this.element(), child);
        };

        PositionedElement.prototype.childCount = function () {
            return this.element().childCount();
        };

        PositionedElement.prototype.childAt = function (index) {
            var offset = TypeScript.Syntax.childOffsetAt(this.element(), index);
            return PositionedElement.create(this, this.element().childAt(index), this.fullStart() + offset);
        };

        PositionedElement.prototype.childStart = function (child) {
            var offset = TypeScript.Syntax.childOffset(this.element(), child);
            return this.fullStart() + offset + child.leadingTriviaWidth();
        };

        PositionedElement.prototype.childEnd = function (child) {
            var offset = TypeScript.Syntax.childOffset(this.element(), child);
            return this.fullStart() + offset + child.leadingTriviaWidth() + child.width();
        };

        PositionedElement.prototype.childStartAt = function (index) {
            var offset = TypeScript.Syntax.childOffsetAt(this.element(), index);
            var child = this.element().childAt(index);
            return this.fullStart() + offset + child.leadingTriviaWidth();
        };

        PositionedElement.prototype.childEndAt = function (index) {
            var offset = TypeScript.Syntax.childOffsetAt(this.element(), index);
            var child = this.element().childAt(index);
            return this.fullStart() + offset + child.leadingTriviaWidth() + child.width();
        };

        PositionedElement.prototype.getPositionedChild = function (child) {
            var offset = TypeScript.Syntax.childOffset(this.element(), child);
            return PositionedElement.create(this, child, this.fullStart() + offset);
        };

        PositionedElement.prototype.fullStart = function () {
            return this._fullStart;
        };

        PositionedElement.prototype.fullEnd = function () {
            return this.fullStart() + this.element().fullWidth();
        };

        PositionedElement.prototype.fullWidth = function () {
            return this.element().fullWidth();
        };

        PositionedElement.prototype.start = function () {
            return this.fullStart() + this.element().leadingTriviaWidth();
        };

        PositionedElement.prototype.end = function () {
            return this.fullStart() + this.element().leadingTriviaWidth() + this.element().width();
        };

        PositionedElement.prototype.root = function () {
            var current = this;
            while (current.parent() !== null) {
                current = current.parent();
            }

            return current;
        };

        PositionedElement.prototype.containingNode = function () {
            var current = this.parent();

            while (current !== null && !current.element().isNode()) {
                current = current.parent();
            }

            return current;
        };
        return PositionedElement;
    })();
    TypeScript.PositionedElement = PositionedElement;

    var PositionedNodeOrToken = (function (_super) {
        __extends(PositionedNodeOrToken, _super);
        function PositionedNodeOrToken(parent, nodeOrToken, fullStart) {
            _super.call(this, parent, nodeOrToken, fullStart);
        }
        PositionedNodeOrToken.prototype.nodeOrToken = function () {
            return this.element();
        };
        return PositionedNodeOrToken;
    })(PositionedElement);
    TypeScript.PositionedNodeOrToken = PositionedNodeOrToken;

    var PositionedNode = (function (_super) {
        __extends(PositionedNode, _super);
        function PositionedNode(parent, node, fullStart) {
            _super.call(this, parent, node, fullStart);
        }
        PositionedNode.prototype.node = function () {
            return this.element();
        };
        return PositionedNode;
    })(PositionedNodeOrToken);
    TypeScript.PositionedNode = PositionedNode;

    var PositionedToken = (function (_super) {
        __extends(PositionedToken, _super);
        function PositionedToken(parent, token, fullStart) {
            _super.call(this, parent, token, fullStart);
        }
        PositionedToken.prototype.token = function () {
            return this.element();
        };

        PositionedToken.prototype.previousToken = function (includeSkippedTokens) {
            if (typeof includeSkippedTokens === "undefined") { includeSkippedTokens = false; }
            var triviaList = this.token().leadingTrivia();
            if (includeSkippedTokens && triviaList && triviaList.hasSkippedToken()) {
                var currentTriviaEndPosition = this.start();
                for (var i = triviaList.count() - 1; i >= 0; i--) {
                    var trivia = triviaList.syntaxTriviaAt(i);
                    if (trivia.isSkippedToken()) {
                        return new PositionedSkippedToken(this, trivia.skippedToken(), currentTriviaEndPosition - trivia.fullWidth());
                    }

                    currentTriviaEndPosition -= trivia.fullWidth();
                }
            }

            var start = this.fullStart();
            if (start === 0) {
                return null;
            }

            return this.root().node().findToken(start - 1, includeSkippedTokens);
        };

        PositionedToken.prototype.nextToken = function (includeSkippedTokens) {
            if (typeof includeSkippedTokens === "undefined") { includeSkippedTokens = false; }
            if (this.token().tokenKind === 10 /* EndOfFileToken */) {
                return null;
            }

            var triviaList = this.token().trailingTrivia();
            if (includeSkippedTokens && triviaList && triviaList.hasSkippedToken()) {
                var fullStart = this.end();
                for (var i = 0, n = triviaList.count(); i < n; i++) {
                    var trivia = triviaList.syntaxTriviaAt(i);
                    if (trivia.isSkippedToken()) {
                        return new PositionedSkippedToken(this, trivia.skippedToken(), fullStart);
                    }

                    fullStart += trivia.fullWidth();
                }
            }

            return this.root().node().findToken(this.fullEnd(), includeSkippedTokens);
        };
        return PositionedToken;
    })(PositionedNodeOrToken);
    TypeScript.PositionedToken = PositionedToken;

    var PositionedList = (function (_super) {
        __extends(PositionedList, _super);
        function PositionedList(parent, list, fullStart) {
            _super.call(this, parent, list, fullStart);
        }
        PositionedList.prototype.list = function () {
            return this.element();
        };
        return PositionedList;
    })(PositionedElement);
    TypeScript.PositionedList = PositionedList;

    var PositionedSeparatedList = (function (_super) {
        __extends(PositionedSeparatedList, _super);
        function PositionedSeparatedList(parent, list, fullStart) {
            _super.call(this, parent, list, fullStart);
        }
        PositionedSeparatedList.prototype.list = function () {
            return this.element();
        };
        return PositionedSeparatedList;
    })(PositionedElement);
    TypeScript.PositionedSeparatedList = PositionedSeparatedList;

    var PositionedSkippedToken = (function (_super) {
        __extends(PositionedSkippedToken, _super);
        function PositionedSkippedToken(parentToken, token, fullStart) {
            _super.call(this, parentToken.parent(), token, fullStart);
            this._parentToken = parentToken;
        }
        PositionedSkippedToken.prototype.parentToken = function () {
            return this._parentToken;
        };

        PositionedSkippedToken.prototype.previousToken = function (includeSkippedTokens) {
            if (typeof includeSkippedTokens === "undefined") { includeSkippedTokens = false; }
            var start = this.fullStart();

            if (includeSkippedTokens) {
                var previousToken;

                if (start >= this.parentToken().end()) {
                    previousToken = TypeScript.Syntax.findSkippedTokenInTrailingTriviaList(this.parentToken(), start - 1);

                    if (previousToken) {
                        return previousToken;
                    }

                    return this.parentToken();
                } else {
                    previousToken = TypeScript.Syntax.findSkippedTokenInLeadingTriviaList(this.parentToken(), start - 1);

                    if (previousToken) {
                        return previousToken;
                    }
                }
            }

            var start = this.parentToken().fullStart();
            if (start === 0) {
                return null;
            }

            return this.root().node().findToken(start - 1, includeSkippedTokens);
        };

        PositionedSkippedToken.prototype.nextToken = function (includeSkippedTokens) {
            if (typeof includeSkippedTokens === "undefined") { includeSkippedTokens = false; }
            if (this.token().tokenKind === 10 /* EndOfFileToken */) {
                return null;
            }

            if (includeSkippedTokens) {
                var end = this.end();
                var nextToken;

                if (end <= this.parentToken().start()) {
                    nextToken = TypeScript.Syntax.findSkippedTokenInLeadingTriviaList(this.parentToken(), end);

                    if (nextToken) {
                        return nextToken;
                    }

                    return this.parentToken();
                } else {
                    nextToken = TypeScript.Syntax.findSkippedTokenInTrailingTriviaList(this.parentToken(), end);

                    if (nextToken) {
                        return nextToken;
                    }
                }
            }

            return this.root().node().findToken(this.parentToken().fullEnd(), includeSkippedTokens);
        };
        return PositionedSkippedToken;
    })(PositionedToken);
    TypeScript.PositionedSkippedToken = PositionedSkippedToken;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (SyntaxKind) {
        SyntaxKind[SyntaxKind["None"] = 0] = "None";
        SyntaxKind[SyntaxKind["List"] = 1] = "List";
        SyntaxKind[SyntaxKind["SeparatedList"] = 2] = "SeparatedList";
        SyntaxKind[SyntaxKind["TriviaList"] = 3] = "TriviaList";

        SyntaxKind[SyntaxKind["WhitespaceTrivia"] = 4] = "WhitespaceTrivia";
        SyntaxKind[SyntaxKind["NewLineTrivia"] = 5] = "NewLineTrivia";
        SyntaxKind[SyntaxKind["MultiLineCommentTrivia"] = 6] = "MultiLineCommentTrivia";
        SyntaxKind[SyntaxKind["SingleLineCommentTrivia"] = 7] = "SingleLineCommentTrivia";
        SyntaxKind[SyntaxKind["SkippedTokenTrivia"] = 8] = "SkippedTokenTrivia";

        SyntaxKind[SyntaxKind["ErrorToken"] = 9] = "ErrorToken";
        SyntaxKind[SyntaxKind["EndOfFileToken"] = 10] = "EndOfFileToken";

        SyntaxKind[SyntaxKind["IdentifierName"] = 11] = "IdentifierName";

        SyntaxKind[SyntaxKind["RegularExpressionLiteral"] = 12] = "RegularExpressionLiteral";
        SyntaxKind[SyntaxKind["NumericLiteral"] = 13] = "NumericLiteral";
        SyntaxKind[SyntaxKind["StringLiteral"] = 14] = "StringLiteral";

        SyntaxKind[SyntaxKind["BreakKeyword"] = 15] = "BreakKeyword";
        SyntaxKind[SyntaxKind["CaseKeyword"] = 16] = "CaseKeyword";
        SyntaxKind[SyntaxKind["CatchKeyword"] = 17] = "CatchKeyword";
        SyntaxKind[SyntaxKind["ContinueKeyword"] = 18] = "ContinueKeyword";
        SyntaxKind[SyntaxKind["DebuggerKeyword"] = 19] = "DebuggerKeyword";
        SyntaxKind[SyntaxKind["DefaultKeyword"] = 20] = "DefaultKeyword";
        SyntaxKind[SyntaxKind["DeleteKeyword"] = 21] = "DeleteKeyword";
        SyntaxKind[SyntaxKind["DoKeyword"] = 22] = "DoKeyword";
        SyntaxKind[SyntaxKind["ElseKeyword"] = 23] = "ElseKeyword";
        SyntaxKind[SyntaxKind["FalseKeyword"] = 24] = "FalseKeyword";
        SyntaxKind[SyntaxKind["FinallyKeyword"] = 25] = "FinallyKeyword";
        SyntaxKind[SyntaxKind["ForKeyword"] = 26] = "ForKeyword";
        SyntaxKind[SyntaxKind["FunctionKeyword"] = 27] = "FunctionKeyword";
        SyntaxKind[SyntaxKind["IfKeyword"] = 28] = "IfKeyword";
        SyntaxKind[SyntaxKind["InKeyword"] = 29] = "InKeyword";
        SyntaxKind[SyntaxKind["InstanceOfKeyword"] = 30] = "InstanceOfKeyword";
        SyntaxKind[SyntaxKind["NewKeyword"] = 31] = "NewKeyword";
        SyntaxKind[SyntaxKind["NullKeyword"] = 32] = "NullKeyword";
        SyntaxKind[SyntaxKind["ReturnKeyword"] = 33] = "ReturnKeyword";
        SyntaxKind[SyntaxKind["SwitchKeyword"] = 34] = "SwitchKeyword";
        SyntaxKind[SyntaxKind["ThisKeyword"] = 35] = "ThisKeyword";
        SyntaxKind[SyntaxKind["ThrowKeyword"] = 36] = "ThrowKeyword";
        SyntaxKind[SyntaxKind["TrueKeyword"] = 37] = "TrueKeyword";
        SyntaxKind[SyntaxKind["TryKeyword"] = 38] = "TryKeyword";
        SyntaxKind[SyntaxKind["TypeOfKeyword"] = 39] = "TypeOfKeyword";
        SyntaxKind[SyntaxKind["VarKeyword"] = 40] = "VarKeyword";
        SyntaxKind[SyntaxKind["VoidKeyword"] = 41] = "VoidKeyword";
        SyntaxKind[SyntaxKind["WhileKeyword"] = 42] = "WhileKeyword";
        SyntaxKind[SyntaxKind["WithKeyword"] = 43] = "WithKeyword";

        SyntaxKind[SyntaxKind["ClassKeyword"] = 44] = "ClassKeyword";
        SyntaxKind[SyntaxKind["ConstKeyword"] = 45] = "ConstKeyword";
        SyntaxKind[SyntaxKind["EnumKeyword"] = 46] = "EnumKeyword";
        SyntaxKind[SyntaxKind["ExportKeyword"] = 47] = "ExportKeyword";
        SyntaxKind[SyntaxKind["ExtendsKeyword"] = 48] = "ExtendsKeyword";
        SyntaxKind[SyntaxKind["ImportKeyword"] = 49] = "ImportKeyword";
        SyntaxKind[SyntaxKind["SuperKeyword"] = 50] = "SuperKeyword";

        SyntaxKind[SyntaxKind["ImplementsKeyword"] = 51] = "ImplementsKeyword";
        SyntaxKind[SyntaxKind["InterfaceKeyword"] = 52] = "InterfaceKeyword";
        SyntaxKind[SyntaxKind["LetKeyword"] = 53] = "LetKeyword";
        SyntaxKind[SyntaxKind["PackageKeyword"] = 54] = "PackageKeyword";
        SyntaxKind[SyntaxKind["PrivateKeyword"] = 55] = "PrivateKeyword";
        SyntaxKind[SyntaxKind["ProtectedKeyword"] = 56] = "ProtectedKeyword";
        SyntaxKind[SyntaxKind["PublicKeyword"] = 57] = "PublicKeyword";
        SyntaxKind[SyntaxKind["StaticKeyword"] = 58] = "StaticKeyword";
        SyntaxKind[SyntaxKind["YieldKeyword"] = 59] = "YieldKeyword";

        SyntaxKind[SyntaxKind["AnyKeyword"] = 60] = "AnyKeyword";
        SyntaxKind[SyntaxKind["BooleanKeyword"] = 61] = "BooleanKeyword";
        SyntaxKind[SyntaxKind["ConstructorKeyword"] = 62] = "ConstructorKeyword";
        SyntaxKind[SyntaxKind["DeclareKeyword"] = 63] = "DeclareKeyword";
        SyntaxKind[SyntaxKind["GetKeyword"] = 64] = "GetKeyword";
        SyntaxKind[SyntaxKind["ModuleKeyword"] = 65] = "ModuleKeyword";
        SyntaxKind[SyntaxKind["RequireKeyword"] = 66] = "RequireKeyword";
        SyntaxKind[SyntaxKind["NumberKeyword"] = 67] = "NumberKeyword";
        SyntaxKind[SyntaxKind["SetKeyword"] = 68] = "SetKeyword";
        SyntaxKind[SyntaxKind["StringKeyword"] = 69] = "StringKeyword";

        SyntaxKind[SyntaxKind["OpenBraceToken"] = 70] = "OpenBraceToken";
        SyntaxKind[SyntaxKind["CloseBraceToken"] = 71] = "CloseBraceToken";
        SyntaxKind[SyntaxKind["OpenParenToken"] = 72] = "OpenParenToken";
        SyntaxKind[SyntaxKind["CloseParenToken"] = 73] = "CloseParenToken";
        SyntaxKind[SyntaxKind["OpenBracketToken"] = 74] = "OpenBracketToken";
        SyntaxKind[SyntaxKind["CloseBracketToken"] = 75] = "CloseBracketToken";
        SyntaxKind[SyntaxKind["DotToken"] = 76] = "DotToken";
        SyntaxKind[SyntaxKind["DotDotDotToken"] = 77] = "DotDotDotToken";
        SyntaxKind[SyntaxKind["SemicolonToken"] = 78] = "SemicolonToken";
        SyntaxKind[SyntaxKind["CommaToken"] = 79] = "CommaToken";
        SyntaxKind[SyntaxKind["LessThanToken"] = 80] = "LessThanToken";
        SyntaxKind[SyntaxKind["GreaterThanToken"] = 81] = "GreaterThanToken";
        SyntaxKind[SyntaxKind["LessThanEqualsToken"] = 82] = "LessThanEqualsToken";
        SyntaxKind[SyntaxKind["GreaterThanEqualsToken"] = 83] = "GreaterThanEqualsToken";
        SyntaxKind[SyntaxKind["EqualsEqualsToken"] = 84] = "EqualsEqualsToken";
        SyntaxKind[SyntaxKind["EqualsGreaterThanToken"] = 85] = "EqualsGreaterThanToken";
        SyntaxKind[SyntaxKind["ExclamationEqualsToken"] = 86] = "ExclamationEqualsToken";
        SyntaxKind[SyntaxKind["EqualsEqualsEqualsToken"] = 87] = "EqualsEqualsEqualsToken";
        SyntaxKind[SyntaxKind["ExclamationEqualsEqualsToken"] = 88] = "ExclamationEqualsEqualsToken";
        SyntaxKind[SyntaxKind["PlusToken"] = 89] = "PlusToken";
        SyntaxKind[SyntaxKind["MinusToken"] = 90] = "MinusToken";
        SyntaxKind[SyntaxKind["AsteriskToken"] = 91] = "AsteriskToken";
        SyntaxKind[SyntaxKind["PercentToken"] = 92] = "PercentToken";
        SyntaxKind[SyntaxKind["PlusPlusToken"] = 93] = "PlusPlusToken";
        SyntaxKind[SyntaxKind["MinusMinusToken"] = 94] = "MinusMinusToken";
        SyntaxKind[SyntaxKind["LessThanLessThanToken"] = 95] = "LessThanLessThanToken";
        SyntaxKind[SyntaxKind["GreaterThanGreaterThanToken"] = 96] = "GreaterThanGreaterThanToken";
        SyntaxKind[SyntaxKind["GreaterThanGreaterThanGreaterThanToken"] = 97] = "GreaterThanGreaterThanGreaterThanToken";
        SyntaxKind[SyntaxKind["AmpersandToken"] = 98] = "AmpersandToken";
        SyntaxKind[SyntaxKind["BarToken"] = 99] = "BarToken";
        SyntaxKind[SyntaxKind["CaretToken"] = 100] = "CaretToken";
        SyntaxKind[SyntaxKind["ExclamationToken"] = 101] = "ExclamationToken";
        SyntaxKind[SyntaxKind["TildeToken"] = 102] = "TildeToken";
        SyntaxKind[SyntaxKind["AmpersandAmpersandToken"] = 103] = "AmpersandAmpersandToken";
        SyntaxKind[SyntaxKind["BarBarToken"] = 104] = "BarBarToken";
        SyntaxKind[SyntaxKind["QuestionToken"] = 105] = "QuestionToken";
        SyntaxKind[SyntaxKind["ColonToken"] = 106] = "ColonToken";
        SyntaxKind[SyntaxKind["EqualsToken"] = 107] = "EqualsToken";
        SyntaxKind[SyntaxKind["PlusEqualsToken"] = 108] = "PlusEqualsToken";
        SyntaxKind[SyntaxKind["MinusEqualsToken"] = 109] = "MinusEqualsToken";
        SyntaxKind[SyntaxKind["AsteriskEqualsToken"] = 110] = "AsteriskEqualsToken";
        SyntaxKind[SyntaxKind["PercentEqualsToken"] = 111] = "PercentEqualsToken";
        SyntaxKind[SyntaxKind["LessThanLessThanEqualsToken"] = 112] = "LessThanLessThanEqualsToken";
        SyntaxKind[SyntaxKind["GreaterThanGreaterThanEqualsToken"] = 113] = "GreaterThanGreaterThanEqualsToken";
        SyntaxKind[SyntaxKind["GreaterThanGreaterThanGreaterThanEqualsToken"] = 114] = "GreaterThanGreaterThanGreaterThanEqualsToken";
        SyntaxKind[SyntaxKind["AmpersandEqualsToken"] = 115] = "AmpersandEqualsToken";
        SyntaxKind[SyntaxKind["BarEqualsToken"] = 116] = "BarEqualsToken";
        SyntaxKind[SyntaxKind["CaretEqualsToken"] = 117] = "CaretEqualsToken";
        SyntaxKind[SyntaxKind["SlashToken"] = 118] = "SlashToken";
        SyntaxKind[SyntaxKind["SlashEqualsToken"] = 119] = "SlashEqualsToken";

        SyntaxKind[SyntaxKind["SourceUnit"] = 120] = "SourceUnit";

        SyntaxKind[SyntaxKind["QualifiedName"] = 121] = "QualifiedName";

        SyntaxKind[SyntaxKind["ObjectType"] = 122] = "ObjectType";
        SyntaxKind[SyntaxKind["FunctionType"] = 123] = "FunctionType";
        SyntaxKind[SyntaxKind["ArrayType"] = 124] = "ArrayType";
        SyntaxKind[SyntaxKind["ConstructorType"] = 125] = "ConstructorType";
        SyntaxKind[SyntaxKind["GenericType"] = 126] = "GenericType";
        SyntaxKind[SyntaxKind["TypeQuery"] = 127] = "TypeQuery";

        SyntaxKind[SyntaxKind["InterfaceDeclaration"] = 128] = "InterfaceDeclaration";
        SyntaxKind[SyntaxKind["FunctionDeclaration"] = 129] = "FunctionDeclaration";
        SyntaxKind[SyntaxKind["ModuleDeclaration"] = 130] = "ModuleDeclaration";
        SyntaxKind[SyntaxKind["ClassDeclaration"] = 131] = "ClassDeclaration";
        SyntaxKind[SyntaxKind["EnumDeclaration"] = 132] = "EnumDeclaration";
        SyntaxKind[SyntaxKind["ImportDeclaration"] = 133] = "ImportDeclaration";
        SyntaxKind[SyntaxKind["ExportAssignment"] = 134] = "ExportAssignment";

        SyntaxKind[SyntaxKind["MemberFunctionDeclaration"] = 135] = "MemberFunctionDeclaration";
        SyntaxKind[SyntaxKind["MemberVariableDeclaration"] = 136] = "MemberVariableDeclaration";
        SyntaxKind[SyntaxKind["ConstructorDeclaration"] = 137] = "ConstructorDeclaration";
        SyntaxKind[SyntaxKind["GetMemberAccessorDeclaration"] = 138] = "GetMemberAccessorDeclaration";
        SyntaxKind[SyntaxKind["SetMemberAccessorDeclaration"] = 139] = "SetMemberAccessorDeclaration";

        SyntaxKind[SyntaxKind["PropertySignature"] = 140] = "PropertySignature";
        SyntaxKind[SyntaxKind["CallSignature"] = 141] = "CallSignature";
        SyntaxKind[SyntaxKind["ConstructSignature"] = 142] = "ConstructSignature";
        SyntaxKind[SyntaxKind["IndexSignature"] = 143] = "IndexSignature";
        SyntaxKind[SyntaxKind["MethodSignature"] = 144] = "MethodSignature";

        SyntaxKind[SyntaxKind["Block"] = 145] = "Block";
        SyntaxKind[SyntaxKind["IfStatement"] = 146] = "IfStatement";
        SyntaxKind[SyntaxKind["VariableStatement"] = 147] = "VariableStatement";
        SyntaxKind[SyntaxKind["ExpressionStatement"] = 148] = "ExpressionStatement";
        SyntaxKind[SyntaxKind["ReturnStatement"] = 149] = "ReturnStatement";
        SyntaxKind[SyntaxKind["SwitchStatement"] = 150] = "SwitchStatement";
        SyntaxKind[SyntaxKind["BreakStatement"] = 151] = "BreakStatement";
        SyntaxKind[SyntaxKind["ContinueStatement"] = 152] = "ContinueStatement";
        SyntaxKind[SyntaxKind["ForStatement"] = 153] = "ForStatement";
        SyntaxKind[SyntaxKind["ForInStatement"] = 154] = "ForInStatement";
        SyntaxKind[SyntaxKind["EmptyStatement"] = 155] = "EmptyStatement";
        SyntaxKind[SyntaxKind["ThrowStatement"] = 156] = "ThrowStatement";
        SyntaxKind[SyntaxKind["WhileStatement"] = 157] = "WhileStatement";
        SyntaxKind[SyntaxKind["TryStatement"] = 158] = "TryStatement";
        SyntaxKind[SyntaxKind["LabeledStatement"] = 159] = "LabeledStatement";
        SyntaxKind[SyntaxKind["DoStatement"] = 160] = "DoStatement";
        SyntaxKind[SyntaxKind["DebuggerStatement"] = 161] = "DebuggerStatement";
        SyntaxKind[SyntaxKind["WithStatement"] = 162] = "WithStatement";

        SyntaxKind[SyntaxKind["PlusExpression"] = 163] = "PlusExpression";
        SyntaxKind[SyntaxKind["NegateExpression"] = 164] = "NegateExpression";
        SyntaxKind[SyntaxKind["BitwiseNotExpression"] = 165] = "BitwiseNotExpression";
        SyntaxKind[SyntaxKind["LogicalNotExpression"] = 166] = "LogicalNotExpression";
        SyntaxKind[SyntaxKind["PreIncrementExpression"] = 167] = "PreIncrementExpression";
        SyntaxKind[SyntaxKind["PreDecrementExpression"] = 168] = "PreDecrementExpression";
        SyntaxKind[SyntaxKind["DeleteExpression"] = 169] = "DeleteExpression";
        SyntaxKind[SyntaxKind["TypeOfExpression"] = 170] = "TypeOfExpression";
        SyntaxKind[SyntaxKind["VoidExpression"] = 171] = "VoidExpression";
        SyntaxKind[SyntaxKind["CommaExpression"] = 172] = "CommaExpression";
        SyntaxKind[SyntaxKind["AssignmentExpression"] = 173] = "AssignmentExpression";
        SyntaxKind[SyntaxKind["AddAssignmentExpression"] = 174] = "AddAssignmentExpression";
        SyntaxKind[SyntaxKind["SubtractAssignmentExpression"] = 175] = "SubtractAssignmentExpression";
        SyntaxKind[SyntaxKind["MultiplyAssignmentExpression"] = 176] = "MultiplyAssignmentExpression";
        SyntaxKind[SyntaxKind["DivideAssignmentExpression"] = 177] = "DivideAssignmentExpression";
        SyntaxKind[SyntaxKind["ModuloAssignmentExpression"] = 178] = "ModuloAssignmentExpression";
        SyntaxKind[SyntaxKind["AndAssignmentExpression"] = 179] = "AndAssignmentExpression";
        SyntaxKind[SyntaxKind["ExclusiveOrAssignmentExpression"] = 180] = "ExclusiveOrAssignmentExpression";
        SyntaxKind[SyntaxKind["OrAssignmentExpression"] = 181] = "OrAssignmentExpression";
        SyntaxKind[SyntaxKind["LeftShiftAssignmentExpression"] = 182] = "LeftShiftAssignmentExpression";
        SyntaxKind[SyntaxKind["SignedRightShiftAssignmentExpression"] = 183] = "SignedRightShiftAssignmentExpression";
        SyntaxKind[SyntaxKind["UnsignedRightShiftAssignmentExpression"] = 184] = "UnsignedRightShiftAssignmentExpression";
        SyntaxKind[SyntaxKind["ConditionalExpression"] = 185] = "ConditionalExpression";
        SyntaxKind[SyntaxKind["LogicalOrExpression"] = 186] = "LogicalOrExpression";
        SyntaxKind[SyntaxKind["LogicalAndExpression"] = 187] = "LogicalAndExpression";
        SyntaxKind[SyntaxKind["BitwiseOrExpression"] = 188] = "BitwiseOrExpression";
        SyntaxKind[SyntaxKind["BitwiseExclusiveOrExpression"] = 189] = "BitwiseExclusiveOrExpression";
        SyntaxKind[SyntaxKind["BitwiseAndExpression"] = 190] = "BitwiseAndExpression";
        SyntaxKind[SyntaxKind["EqualsWithTypeConversionExpression"] = 191] = "EqualsWithTypeConversionExpression";
        SyntaxKind[SyntaxKind["NotEqualsWithTypeConversionExpression"] = 192] = "NotEqualsWithTypeConversionExpression";
        SyntaxKind[SyntaxKind["EqualsExpression"] = 193] = "EqualsExpression";
        SyntaxKind[SyntaxKind["NotEqualsExpression"] = 194] = "NotEqualsExpression";
        SyntaxKind[SyntaxKind["LessThanExpression"] = 195] = "LessThanExpression";
        SyntaxKind[SyntaxKind["GreaterThanExpression"] = 196] = "GreaterThanExpression";
        SyntaxKind[SyntaxKind["LessThanOrEqualExpression"] = 197] = "LessThanOrEqualExpression";
        SyntaxKind[SyntaxKind["GreaterThanOrEqualExpression"] = 198] = "GreaterThanOrEqualExpression";
        SyntaxKind[SyntaxKind["InstanceOfExpression"] = 199] = "InstanceOfExpression";
        SyntaxKind[SyntaxKind["InExpression"] = 200] = "InExpression";
        SyntaxKind[SyntaxKind["LeftShiftExpression"] = 201] = "LeftShiftExpression";
        SyntaxKind[SyntaxKind["SignedRightShiftExpression"] = 202] = "SignedRightShiftExpression";
        SyntaxKind[SyntaxKind["UnsignedRightShiftExpression"] = 203] = "UnsignedRightShiftExpression";
        SyntaxKind[SyntaxKind["MultiplyExpression"] = 204] = "MultiplyExpression";
        SyntaxKind[SyntaxKind["DivideExpression"] = 205] = "DivideExpression";
        SyntaxKind[SyntaxKind["ModuloExpression"] = 206] = "ModuloExpression";
        SyntaxKind[SyntaxKind["AddExpression"] = 207] = "AddExpression";
        SyntaxKind[SyntaxKind["SubtractExpression"] = 208] = "SubtractExpression";
        SyntaxKind[SyntaxKind["PostIncrementExpression"] = 209] = "PostIncrementExpression";
        SyntaxKind[SyntaxKind["PostDecrementExpression"] = 210] = "PostDecrementExpression";
        SyntaxKind[SyntaxKind["MemberAccessExpression"] = 211] = "MemberAccessExpression";
        SyntaxKind[SyntaxKind["InvocationExpression"] = 212] = "InvocationExpression";
        SyntaxKind[SyntaxKind["ArrayLiteralExpression"] = 213] = "ArrayLiteralExpression";
        SyntaxKind[SyntaxKind["ObjectLiteralExpression"] = 214] = "ObjectLiteralExpression";
        SyntaxKind[SyntaxKind["ObjectCreationExpression"] = 215] = "ObjectCreationExpression";
        SyntaxKind[SyntaxKind["ParenthesizedExpression"] = 216] = "ParenthesizedExpression";
        SyntaxKind[SyntaxKind["ParenthesizedArrowFunctionExpression"] = 217] = "ParenthesizedArrowFunctionExpression";
        SyntaxKind[SyntaxKind["SimpleArrowFunctionExpression"] = 218] = "SimpleArrowFunctionExpression";
        SyntaxKind[SyntaxKind["CastExpression"] = 219] = "CastExpression";
        SyntaxKind[SyntaxKind["ElementAccessExpression"] = 220] = "ElementAccessExpression";
        SyntaxKind[SyntaxKind["FunctionExpression"] = 221] = "FunctionExpression";
        SyntaxKind[SyntaxKind["OmittedExpression"] = 222] = "OmittedExpression";

        SyntaxKind[SyntaxKind["VariableDeclaration"] = 223] = "VariableDeclaration";
        SyntaxKind[SyntaxKind["VariableDeclarator"] = 224] = "VariableDeclarator";

        SyntaxKind[SyntaxKind["ArgumentList"] = 225] = "ArgumentList";
        SyntaxKind[SyntaxKind["ParameterList"] = 226] = "ParameterList";
        SyntaxKind[SyntaxKind["TypeArgumentList"] = 227] = "TypeArgumentList";
        SyntaxKind[SyntaxKind["TypeParameterList"] = 228] = "TypeParameterList";

        SyntaxKind[SyntaxKind["HeritageClause"] = 229] = "HeritageClause";
        SyntaxKind[SyntaxKind["EqualsValueClause"] = 230] = "EqualsValueClause";
        SyntaxKind[SyntaxKind["CaseSwitchClause"] = 231] = "CaseSwitchClause";
        SyntaxKind[SyntaxKind["DefaultSwitchClause"] = 232] = "DefaultSwitchClause";
        SyntaxKind[SyntaxKind["ElseClause"] = 233] = "ElseClause";
        SyntaxKind[SyntaxKind["CatchClause"] = 234] = "CatchClause";
        SyntaxKind[SyntaxKind["FinallyClause"] = 235] = "FinallyClause";

        SyntaxKind[SyntaxKind["TypeParameter"] = 236] = "TypeParameter";
        SyntaxKind[SyntaxKind["Constraint"] = 237] = "Constraint";

        SyntaxKind[SyntaxKind["SimplePropertyAssignment"] = 238] = "SimplePropertyAssignment";
        SyntaxKind[SyntaxKind["GetAccessorPropertyAssignment"] = 239] = "GetAccessorPropertyAssignment";
        SyntaxKind[SyntaxKind["SetAccessorPropertyAssignment"] = 240] = "SetAccessorPropertyAssignment";
        SyntaxKind[SyntaxKind["FunctionPropertyAssignment"] = 241] = "FunctionPropertyAssignment";

        SyntaxKind[SyntaxKind["Parameter"] = 242] = "Parameter";
        SyntaxKind[SyntaxKind["EnumElement"] = 243] = "EnumElement";
        SyntaxKind[SyntaxKind["TypeAnnotation"] = 244] = "TypeAnnotation";
        SyntaxKind[SyntaxKind["ExternalModuleReference"] = 245] = "ExternalModuleReference";
        SyntaxKind[SyntaxKind["ModuleNameModuleReference"] = 246] = "ModuleNameModuleReference";

        SyntaxKind[SyntaxKind["FirstStandardKeyword"] = SyntaxKind.BreakKeyword] = "FirstStandardKeyword";
        SyntaxKind[SyntaxKind["LastStandardKeyword"] = SyntaxKind.WithKeyword] = "LastStandardKeyword";

        SyntaxKind[SyntaxKind["FirstFutureReservedKeyword"] = SyntaxKind.ClassKeyword] = "FirstFutureReservedKeyword";
        SyntaxKind[SyntaxKind["LastFutureReservedKeyword"] = SyntaxKind.SuperKeyword] = "LastFutureReservedKeyword";

        SyntaxKind[SyntaxKind["FirstFutureReservedStrictKeyword"] = SyntaxKind.ImplementsKeyword] = "FirstFutureReservedStrictKeyword";
        SyntaxKind[SyntaxKind["LastFutureReservedStrictKeyword"] = SyntaxKind.YieldKeyword] = "LastFutureReservedStrictKeyword";

        SyntaxKind[SyntaxKind["FirstTypeScriptKeyword"] = SyntaxKind.AnyKeyword] = "FirstTypeScriptKeyword";
        SyntaxKind[SyntaxKind["LastTypeScriptKeyword"] = SyntaxKind.StringKeyword] = "LastTypeScriptKeyword";

        SyntaxKind[SyntaxKind["FirstKeyword"] = SyntaxKind.FirstStandardKeyword] = "FirstKeyword";
        SyntaxKind[SyntaxKind["LastKeyword"] = SyntaxKind.LastTypeScriptKeyword] = "LastKeyword";

        SyntaxKind[SyntaxKind["FirstToken"] = SyntaxKind.ErrorToken] = "FirstToken";
        SyntaxKind[SyntaxKind["LastToken"] = SyntaxKind.SlashEqualsToken] = "LastToken";

        SyntaxKind[SyntaxKind["FirstPunctuation"] = SyntaxKind.OpenBraceToken] = "FirstPunctuation";
        SyntaxKind[SyntaxKind["LastPunctuation"] = SyntaxKind.SlashEqualsToken] = "LastPunctuation";

        SyntaxKind[SyntaxKind["FirstFixedWidth"] = SyntaxKind.FirstKeyword] = "FirstFixedWidth";
        SyntaxKind[SyntaxKind["LastFixedWidth"] = SyntaxKind.LastPunctuation] = "LastFixedWidth";
    })(TypeScript.SyntaxKind || (TypeScript.SyntaxKind = {}));
    var SyntaxKind = TypeScript.SyntaxKind;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (SyntaxFacts) {
        var textToKeywordKind = {
            "any": 60 /* AnyKeyword */,
            "boolean": 61 /* BooleanKeyword */,
            "break": 15 /* BreakKeyword */,
            "case": 16 /* CaseKeyword */,
            "catch": 17 /* CatchKeyword */,
            "class": 44 /* ClassKeyword */,
            "continue": 18 /* ContinueKeyword */,
            "const": 45 /* ConstKeyword */,
            "constructor": 62 /* ConstructorKeyword */,
            "debugger": 19 /* DebuggerKeyword */,
            "declare": 63 /* DeclareKeyword */,
            "default": 20 /* DefaultKeyword */,
            "delete": 21 /* DeleteKeyword */,
            "do": 22 /* DoKeyword */,
            "else": 23 /* ElseKeyword */,
            "enum": 46 /* EnumKeyword */,
            "export": 47 /* ExportKeyword */,
            "extends": 48 /* ExtendsKeyword */,
            "false": 24 /* FalseKeyword */,
            "finally": 25 /* FinallyKeyword */,
            "for": 26 /* ForKeyword */,
            "function": 27 /* FunctionKeyword */,
            "get": 64 /* GetKeyword */,
            "if": 28 /* IfKeyword */,
            "implements": 51 /* ImplementsKeyword */,
            "import": 49 /* ImportKeyword */,
            "in": 29 /* InKeyword */,
            "instanceof": 30 /* InstanceOfKeyword */,
            "interface": 52 /* InterfaceKeyword */,
            "let": 53 /* LetKeyword */,
            "module": 65 /* ModuleKeyword */,
            "new": 31 /* NewKeyword */,
            "null": 32 /* NullKeyword */,
            "number": 67 /* NumberKeyword */,
            "package": 54 /* PackageKeyword */,
            "private": 55 /* PrivateKeyword */,
            "protected": 56 /* ProtectedKeyword */,
            "public": 57 /* PublicKeyword */,
            "require": 66 /* RequireKeyword */,
            "return": 33 /* ReturnKeyword */,
            "set": 68 /* SetKeyword */,
            "static": 58 /* StaticKeyword */,
            "string": 69 /* StringKeyword */,
            "super": 50 /* SuperKeyword */,
            "switch": 34 /* SwitchKeyword */,
            "this": 35 /* ThisKeyword */,
            "throw": 36 /* ThrowKeyword */,
            "true": 37 /* TrueKeyword */,
            "try": 38 /* TryKeyword */,
            "typeof": 39 /* TypeOfKeyword */,
            "var": 40 /* VarKeyword */,
            "void": 41 /* VoidKeyword */,
            "while": 42 /* WhileKeyword */,
            "with": 43 /* WithKeyword */,
            "yield": 59 /* YieldKeyword */,
            "{": 70 /* OpenBraceToken */,
            "}": 71 /* CloseBraceToken */,
            "(": 72 /* OpenParenToken */,
            ")": 73 /* CloseParenToken */,
            "[": 74 /* OpenBracketToken */,
            "]": 75 /* CloseBracketToken */,
            ".": 76 /* DotToken */,
            "...": 77 /* DotDotDotToken */,
            ";": 78 /* SemicolonToken */,
            ",": 79 /* CommaToken */,
            "<": 80 /* LessThanToken */,
            ">": 81 /* GreaterThanToken */,
            "<=": 82 /* LessThanEqualsToken */,
            ">=": 83 /* GreaterThanEqualsToken */,
            "==": 84 /* EqualsEqualsToken */,
            "=>": 85 /* EqualsGreaterThanToken */,
            "!=": 86 /* ExclamationEqualsToken */,
            "===": 87 /* EqualsEqualsEqualsToken */,
            "!==": 88 /* ExclamationEqualsEqualsToken */,
            "+": 89 /* PlusToken */,
            "-": 90 /* MinusToken */,
            "*": 91 /* AsteriskToken */,
            "%": 92 /* PercentToken */,
            "++": 93 /* PlusPlusToken */,
            "--": 94 /* MinusMinusToken */,
            "<<": 95 /* LessThanLessThanToken */,
            ">>": 96 /* GreaterThanGreaterThanToken */,
            ">>>": 97 /* GreaterThanGreaterThanGreaterThanToken */,
            "&": 98 /* AmpersandToken */,
            "|": 99 /* BarToken */,
            "^": 100 /* CaretToken */,
            "!": 101 /* ExclamationToken */,
            "~": 102 /* TildeToken */,
            "&&": 103 /* AmpersandAmpersandToken */,
            "||": 104 /* BarBarToken */,
            "?": 105 /* QuestionToken */,
            ":": 106 /* ColonToken */,
            "=": 107 /* EqualsToken */,
            "+=": 108 /* PlusEqualsToken */,
            "-=": 109 /* MinusEqualsToken */,
            "*=": 110 /* AsteriskEqualsToken */,
            "%=": 111 /* PercentEqualsToken */,
            "<<=": 112 /* LessThanLessThanEqualsToken */,
            ">>=": 113 /* GreaterThanGreaterThanEqualsToken */,
            ">>>=": 114 /* GreaterThanGreaterThanGreaterThanEqualsToken */,
            "&=": 115 /* AmpersandEqualsToken */,
            "|=": 116 /* BarEqualsToken */,
            "^=": 117 /* CaretEqualsToken */,
            "/": 118 /* SlashToken */,
            "/=": 119 /* SlashEqualsToken */
        };

        var kindToText = new Array();

        for (var name in textToKeywordKind) {
            if (textToKeywordKind.hasOwnProperty(name)) {
                kindToText[textToKeywordKind[name]] = name;
            }
        }

        kindToText[62 /* ConstructorKeyword */] = "constructor";

        function getTokenKind(text) {
            if (textToKeywordKind.hasOwnProperty(text)) {
                return textToKeywordKind[text];
            }

            return 0 /* None */;
        }
        SyntaxFacts.getTokenKind = getTokenKind;

        function getText(kind) {
            var result = kindToText[kind];
            return result !== undefined ? result : null;
        }
        SyntaxFacts.getText = getText;

        function isTokenKind(kind) {
            return kind >= 9 /* FirstToken */ && kind <= 119 /* LastToken */;
        }
        SyntaxFacts.isTokenKind = isTokenKind;

        function isAnyKeyword(kind) {
            return kind >= 15 /* FirstKeyword */ && kind <= 69 /* LastKeyword */;
        }
        SyntaxFacts.isAnyKeyword = isAnyKeyword;

        function isStandardKeyword(kind) {
            return kind >= 15 /* FirstStandardKeyword */ && kind <= 43 /* LastStandardKeyword */;
        }
        SyntaxFacts.isStandardKeyword = isStandardKeyword;

        function isFutureReservedKeyword(kind) {
            return kind >= 44 /* FirstFutureReservedKeyword */ && kind <= 50 /* LastFutureReservedKeyword */;
        }
        SyntaxFacts.isFutureReservedKeyword = isFutureReservedKeyword;

        function isFutureReservedStrictKeyword(kind) {
            return kind >= 51 /* FirstFutureReservedStrictKeyword */ && kind <= 59 /* LastFutureReservedStrictKeyword */;
        }
        SyntaxFacts.isFutureReservedStrictKeyword = isFutureReservedStrictKeyword;

        function isAnyPunctuation(kind) {
            return kind >= 70 /* FirstPunctuation */ && kind <= 119 /* LastPunctuation */;
        }
        SyntaxFacts.isAnyPunctuation = isAnyPunctuation;

        function isPrefixUnaryExpressionOperatorToken(tokenKind) {
            return getPrefixUnaryExpressionFromOperatorToken(tokenKind) !== 0 /* None */;
        }
        SyntaxFacts.isPrefixUnaryExpressionOperatorToken = isPrefixUnaryExpressionOperatorToken;

        function isBinaryExpressionOperatorToken(tokenKind) {
            return getBinaryExpressionFromOperatorToken(tokenKind) !== 0 /* None */;
        }
        SyntaxFacts.isBinaryExpressionOperatorToken = isBinaryExpressionOperatorToken;

        function getPrefixUnaryExpressionFromOperatorToken(tokenKind) {
            switch (tokenKind) {
                case 89 /* PlusToken */:
                    return 163 /* PlusExpression */;
                case 90 /* MinusToken */:
                    return 164 /* NegateExpression */;
                case 102 /* TildeToken */:
                    return 165 /* BitwiseNotExpression */;
                case 101 /* ExclamationToken */:
                    return 166 /* LogicalNotExpression */;
                case 93 /* PlusPlusToken */:
                    return 167 /* PreIncrementExpression */;
                case 94 /* MinusMinusToken */:
                    return 168 /* PreDecrementExpression */;

                default:
                    return 0 /* None */;
            }
        }
        SyntaxFacts.getPrefixUnaryExpressionFromOperatorToken = getPrefixUnaryExpressionFromOperatorToken;

        function getPostfixUnaryExpressionFromOperatorToken(tokenKind) {
            switch (tokenKind) {
                case 93 /* PlusPlusToken */:
                    return 209 /* PostIncrementExpression */;
                case 94 /* MinusMinusToken */:
                    return 210 /* PostDecrementExpression */;
                default:
                    return 0 /* None */;
            }
        }
        SyntaxFacts.getPostfixUnaryExpressionFromOperatorToken = getPostfixUnaryExpressionFromOperatorToken;

        function getBinaryExpressionFromOperatorToken(tokenKind) {
            switch (tokenKind) {
                case 91 /* AsteriskToken */:
                    return 204 /* MultiplyExpression */;

                case 118 /* SlashToken */:
                    return 205 /* DivideExpression */;

                case 92 /* PercentToken */:
                    return 206 /* ModuloExpression */;

                case 89 /* PlusToken */:
                    return 207 /* AddExpression */;

                case 90 /* MinusToken */:
                    return 208 /* SubtractExpression */;

                case 95 /* LessThanLessThanToken */:
                    return 201 /* LeftShiftExpression */;

                case 96 /* GreaterThanGreaterThanToken */:
                    return 202 /* SignedRightShiftExpression */;

                case 97 /* GreaterThanGreaterThanGreaterThanToken */:
                    return 203 /* UnsignedRightShiftExpression */;

                case 80 /* LessThanToken */:
                    return 195 /* LessThanExpression */;

                case 81 /* GreaterThanToken */:
                    return 196 /* GreaterThanExpression */;

                case 82 /* LessThanEqualsToken */:
                    return 197 /* LessThanOrEqualExpression */;

                case 83 /* GreaterThanEqualsToken */:
                    return 198 /* GreaterThanOrEqualExpression */;

                case 30 /* InstanceOfKeyword */:
                    return 199 /* InstanceOfExpression */;

                case 29 /* InKeyword */:
                    return 200 /* InExpression */;

                case 84 /* EqualsEqualsToken */:
                    return 191 /* EqualsWithTypeConversionExpression */;

                case 86 /* ExclamationEqualsToken */:
                    return 192 /* NotEqualsWithTypeConversionExpression */;

                case 87 /* EqualsEqualsEqualsToken */:
                    return 193 /* EqualsExpression */;

                case 88 /* ExclamationEqualsEqualsToken */:
                    return 194 /* NotEqualsExpression */;

                case 98 /* AmpersandToken */:
                    return 190 /* BitwiseAndExpression */;

                case 100 /* CaretToken */:
                    return 189 /* BitwiseExclusiveOrExpression */;

                case 99 /* BarToken */:
                    return 188 /* BitwiseOrExpression */;

                case 103 /* AmpersandAmpersandToken */:
                    return 187 /* LogicalAndExpression */;

                case 104 /* BarBarToken */:
                    return 186 /* LogicalOrExpression */;

                case 116 /* BarEqualsToken */:
                    return 181 /* OrAssignmentExpression */;

                case 115 /* AmpersandEqualsToken */:
                    return 179 /* AndAssignmentExpression */;

                case 117 /* CaretEqualsToken */:
                    return 180 /* ExclusiveOrAssignmentExpression */;

                case 112 /* LessThanLessThanEqualsToken */:
                    return 182 /* LeftShiftAssignmentExpression */;

                case 113 /* GreaterThanGreaterThanEqualsToken */:
                    return 183 /* SignedRightShiftAssignmentExpression */;

                case 114 /* GreaterThanGreaterThanGreaterThanEqualsToken */:
                    return 184 /* UnsignedRightShiftAssignmentExpression */;

                case 108 /* PlusEqualsToken */:
                    return 174 /* AddAssignmentExpression */;

                case 109 /* MinusEqualsToken */:
                    return 175 /* SubtractAssignmentExpression */;

                case 110 /* AsteriskEqualsToken */:
                    return 176 /* MultiplyAssignmentExpression */;

                case 119 /* SlashEqualsToken */:
                    return 177 /* DivideAssignmentExpression */;

                case 111 /* PercentEqualsToken */:
                    return 178 /* ModuloAssignmentExpression */;

                case 107 /* EqualsToken */:
                    return 173 /* AssignmentExpression */;

                case 79 /* CommaToken */:
                    return 172 /* CommaExpression */;

                default:
                    return 0 /* None */;
            }
        }
        SyntaxFacts.getBinaryExpressionFromOperatorToken = getBinaryExpressionFromOperatorToken;

        function isAnyDivideToken(kind) {
            switch (kind) {
                case 118 /* SlashToken */:
                case 119 /* SlashEqualsToken */:
                    return true;
                default:
                    return false;
            }
        }
        SyntaxFacts.isAnyDivideToken = isAnyDivideToken;

        function isAnyDivideOrRegularExpressionToken(kind) {
            switch (kind) {
                case 118 /* SlashToken */:
                case 119 /* SlashEqualsToken */:
                case 12 /* RegularExpressionLiteral */:
                    return true;
                default:
                    return false;
            }
        }
        SyntaxFacts.isAnyDivideOrRegularExpressionToken = isAnyDivideOrRegularExpressionToken;

        function isParserGenerated(kind) {
            switch (kind) {
                case 96 /* GreaterThanGreaterThanToken */:
                case 97 /* GreaterThanGreaterThanGreaterThanToken */:
                case 83 /* GreaterThanEqualsToken */:
                case 113 /* GreaterThanGreaterThanEqualsToken */:
                case 114 /* GreaterThanGreaterThanGreaterThanEqualsToken */:
                    return true;
                default:
                    return false;
            }
        }
        SyntaxFacts.isParserGenerated = isParserGenerated;

        function isAnyBinaryExpression(kind) {
            switch (kind) {
                case 172 /* CommaExpression */:
                case 173 /* AssignmentExpression */:
                case 174 /* AddAssignmentExpression */:
                case 175 /* SubtractAssignmentExpression */:
                case 176 /* MultiplyAssignmentExpression */:
                case 177 /* DivideAssignmentExpression */:
                case 178 /* ModuloAssignmentExpression */:
                case 179 /* AndAssignmentExpression */:
                case 180 /* ExclusiveOrAssignmentExpression */:
                case 181 /* OrAssignmentExpression */:
                case 182 /* LeftShiftAssignmentExpression */:
                case 183 /* SignedRightShiftAssignmentExpression */:
                case 184 /* UnsignedRightShiftAssignmentExpression */:
                case 186 /* LogicalOrExpression */:
                case 187 /* LogicalAndExpression */:
                case 188 /* BitwiseOrExpression */:
                case 189 /* BitwiseExclusiveOrExpression */:
                case 190 /* BitwiseAndExpression */:
                case 191 /* EqualsWithTypeConversionExpression */:
                case 192 /* NotEqualsWithTypeConversionExpression */:
                case 193 /* EqualsExpression */:
                case 194 /* NotEqualsExpression */:
                case 195 /* LessThanExpression */:
                case 196 /* GreaterThanExpression */:
                case 197 /* LessThanOrEqualExpression */:
                case 198 /* GreaterThanOrEqualExpression */:
                case 199 /* InstanceOfExpression */:
                case 200 /* InExpression */:
                case 201 /* LeftShiftExpression */:
                case 202 /* SignedRightShiftExpression */:
                case 203 /* UnsignedRightShiftExpression */:
                case 204 /* MultiplyExpression */:
                case 205 /* DivideExpression */:
                case 206 /* ModuloExpression */:
                case 207 /* AddExpression */:
                case 208 /* SubtractExpression */:
                    return true;
            }

            return false;
        }
        SyntaxFacts.isAnyBinaryExpression = isAnyBinaryExpression;
    })(TypeScript.SyntaxFacts || (TypeScript.SyntaxFacts = {}));
    var SyntaxFacts = TypeScript.SyntaxFacts;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var isKeywordStartCharacter = TypeScript.ArrayUtilities.createArray(127 /* maxAsciiCharacter */, false);
    var isIdentifierStartCharacter = TypeScript.ArrayUtilities.createArray(127 /* maxAsciiCharacter */, false);
    var isIdentifierPartCharacter = TypeScript.ArrayUtilities.createArray(127 /* maxAsciiCharacter */, false);
    var isNumericLiteralStart = TypeScript.ArrayUtilities.createArray(127 /* maxAsciiCharacter */, false);

    for (var character = 0; character < 127 /* maxAsciiCharacter */; character++) {
        if (character >= 97 /* a */ && character <= 122 /* z */) {
            isIdentifierStartCharacter[character] = true;
            isIdentifierPartCharacter[character] = true;
        } else if ((character >= 65 /* A */ && character <= 90 /* Z */) || character === 95 /* _ */ || character === 36 /* $ */) {
            isIdentifierStartCharacter[character] = true;
            isIdentifierPartCharacter[character] = true;
        } else if (character >= 48 /* _0 */ && character <= 57 /* _9 */) {
            isIdentifierPartCharacter[character] = true;
            isNumericLiteralStart[character] = true;
        }
    }

    isNumericLiteralStart[46 /* dot */] = true;

    for (var keywordKind = 15 /* FirstKeyword */; keywordKind <= 69 /* LastKeyword */; keywordKind++) {
        var keyword = TypeScript.SyntaxFacts.getText(keywordKind);
        isKeywordStartCharacter[keyword.charCodeAt(0)] = true;
    }

    var Scanner = (function () {
        function Scanner(fileName, text, languageVersion, window) {
            if (typeof window === "undefined") { window = TypeScript.ArrayUtilities.createArray(2048, 0); }
            this.slidingWindow = new TypeScript.SlidingWindow(this, window, 0, text.length());
            this.fileName = fileName;
            this.text = text;
            this._languageVersion = languageVersion;
        }
        Scanner.prototype.languageVersion = function () {
            return this._languageVersion;
        };

        Scanner.prototype.fetchMoreItems = function (argument, sourceIndex, window, destinationIndex, spaceAvailable) {
            var charactersRemaining = this.text.length() - sourceIndex;
            var amountToRead = TypeScript.MathPrototype.min(charactersRemaining, spaceAvailable);
            this.text.copyTo(sourceIndex, window, destinationIndex, amountToRead);
            return amountToRead;
        };

        Scanner.prototype.currentCharCode = function () {
            return this.slidingWindow.currentItem(null);
        };

        Scanner.prototype.absoluteIndex = function () {
            return this.slidingWindow.absoluteIndex();
        };

        Scanner.prototype.setAbsoluteIndex = function (index) {
            this.slidingWindow.setAbsoluteIndex(index);
        };

        Scanner.prototype.scan = function (diagnostics, allowRegularExpression) {
            var diagnosticsLength = diagnostics.length;
            var fullStart = this.slidingWindow.absoluteIndex();
            var leadingTriviaInfo = this.scanTriviaInfo(diagnostics, false);

            var start = this.slidingWindow.absoluteIndex();
            var kind = this.scanSyntaxToken(diagnostics, allowRegularExpression);
            var end = this.slidingWindow.absoluteIndex();

            var trailingTriviaInfo = this.scanTriviaInfo(diagnostics, true);

            var token = this.createToken(fullStart, leadingTriviaInfo, start, kind, end, trailingTriviaInfo);

            return diagnosticsLength !== diagnostics.length ? TypeScript.Syntax.realizeToken(token) : token;
        };

        Scanner.prototype.createToken = function (fullStart, leadingTriviaInfo, start, kind, end, trailingTriviaInfo) {
            if (kind >= 15 /* FirstFixedWidth */) {
                if (leadingTriviaInfo === 0) {
                    if (trailingTriviaInfo === 0) {
                        return new TypeScript.Syntax.FixedWidthTokenWithNoTrivia(kind);
                    } else {
                        return new TypeScript.Syntax.FixedWidthTokenWithTrailingTrivia(this.text, fullStart, kind, trailingTriviaInfo);
                    }
                } else if (trailingTriviaInfo === 0) {
                    return new TypeScript.Syntax.FixedWidthTokenWithLeadingTrivia(this.text, fullStart, kind, leadingTriviaInfo);
                } else {
                    return new TypeScript.Syntax.FixedWidthTokenWithLeadingAndTrailingTrivia(this.text, fullStart, kind, leadingTriviaInfo, trailingTriviaInfo);
                }
            } else {
                var width = end - start;
                if (leadingTriviaInfo === 0) {
                    if (trailingTriviaInfo === 0) {
                        return new TypeScript.Syntax.VariableWidthTokenWithNoTrivia(this.text, fullStart, kind, width);
                    } else {
                        return new TypeScript.Syntax.VariableWidthTokenWithTrailingTrivia(this.text, fullStart, kind, width, trailingTriviaInfo);
                    }
                } else if (trailingTriviaInfo === 0) {
                    return new TypeScript.Syntax.VariableWidthTokenWithLeadingTrivia(this.text, fullStart, kind, leadingTriviaInfo, width);
                } else {
                    return new TypeScript.Syntax.VariableWidthTokenWithLeadingAndTrailingTrivia(this.text, fullStart, kind, leadingTriviaInfo, width, trailingTriviaInfo);
                }
            }
        };

        Scanner.scanTrivia = function (text, start, length, isTrailing) {
            var scanner = new Scanner(null, text.subText(new TypeScript.TextSpan(start, length)), 1 /* EcmaScript5 */, Scanner.triviaWindow);
            return scanner.scanTrivia(isTrailing);
        };

        Scanner.prototype.scanTrivia = function (isTrailing) {
            var trivia = new Array();

            while (true) {
                if (!this.slidingWindow.isAtEndOfSource()) {
                    var ch = this.currentCharCode();

                    switch (ch) {
                        case 32 /* space */:
                        case 160 /* nonBreakingSpace */:
                        case 8192 /* enQuad */:
                        case 8193 /* emQuad */:
                        case 8194 /* enSpace */:
                        case 8195 /* emSpace */:
                        case 8196 /* threePerEmSpace */:
                        case 8197 /* fourPerEmSpace */:
                        case 8198 /* sixPerEmSpace */:
                        case 8199 /* figureSpace */:
                        case 8200 /* punctuationSpace */:
                        case 8201 /* thinSpace */:
                        case 8202 /* hairSpace */:
                        case 8203 /* zeroWidthSpace */:
                        case 8239 /* narrowNoBreakSpace */:
                        case 12288 /* ideographicSpace */:

                        case 9 /* tab */:
                        case 11 /* verticalTab */:
                        case 12 /* formFeed */:
                        case 65279 /* byteOrderMark */:
                            trivia.push(this.scanWhitespaceTrivia());
                            continue;

                        case 47 /* slash */:
                            var ch2 = this.slidingWindow.peekItemN(1);
                            if (ch2 === 47 /* slash */) {
                                trivia.push(this.scanSingleLineCommentTrivia());
                                continue;
                            }

                            if (ch2 === 42 /* asterisk */) {
                                trivia.push(this.scanMultiLineCommentTrivia());
                                continue;
                            }

                            throw TypeScript.Errors.invalidOperation();

                        case 13 /* carriageReturn */:
                        case 10 /* lineFeed */:
                        case 8233 /* paragraphSeparator */:
                        case 8232 /* lineSeparator */:
                            trivia.push(this.scanLineTerminatorSequenceTrivia(ch));

                            if (!isTrailing) {
                                continue;
                            }

                            break;

                        default:
                            throw TypeScript.Errors.invalidOperation();
                    }
                }

                return TypeScript.Syntax.triviaList(trivia);
            }
        };

        Scanner.prototype.scanTriviaInfo = function (diagnostics, isTrailing) {
            var width = 0;
            var hasCommentOrNewLine = 0;

            while (true) {
                var ch = this.currentCharCode();

                switch (ch) {
                    case 32 /* space */:
                    case 160 /* nonBreakingSpace */:
                    case 8192 /* enQuad */:
                    case 8193 /* emQuad */:
                    case 8194 /* enSpace */:
                    case 8195 /* emSpace */:
                    case 8196 /* threePerEmSpace */:
                    case 8197 /* fourPerEmSpace */:
                    case 8198 /* sixPerEmSpace */:
                    case 8199 /* figureSpace */:
                    case 8200 /* punctuationSpace */:
                    case 8201 /* thinSpace */:
                    case 8202 /* hairSpace */:
                    case 8203 /* zeroWidthSpace */:
                    case 8239 /* narrowNoBreakSpace */:
                    case 12288 /* ideographicSpace */:

                    case 9 /* tab */:
                    case 11 /* verticalTab */:
                    case 12 /* formFeed */:
                    case 65279 /* byteOrderMark */:
                        this.slidingWindow.moveToNextItem();
                        width++;
                        continue;

                    case 47 /* slash */:
                        var ch2 = this.slidingWindow.peekItemN(1);
                        if (ch2 === 47 /* slash */) {
                            hasCommentOrNewLine |= 2 /* TriviaCommentMask */;
                            width += this.scanSingleLineCommentTriviaLength();
                            continue;
                        }

                        if (ch2 === 42 /* asterisk */) {
                            hasCommentOrNewLine |= 2 /* TriviaCommentMask */;
                            width += this.scanMultiLineCommentTriviaLength(diagnostics);
                            continue;
                        }

                        break;

                    case 13 /* carriageReturn */:
                    case 10 /* lineFeed */:
                    case 8233 /* paragraphSeparator */:
                    case 8232 /* lineSeparator */:
                        hasCommentOrNewLine |= 1 /* TriviaNewLineMask */;
                        width += this.scanLineTerminatorSequenceLength(ch);

                        if (!isTrailing) {
                            continue;
                        }

                        break;
                }

                return (width << 2 /* TriviaFullWidthShift */) | hasCommentOrNewLine;
            }
        };

        Scanner.prototype.isNewLineCharacter = function (ch) {
            switch (ch) {
                case 13 /* carriageReturn */:
                case 10 /* lineFeed */:
                case 8233 /* paragraphSeparator */:
                case 8232 /* lineSeparator */:
                    return true;
                default:
                    return false;
            }
        };

        Scanner.prototype.scanWhitespaceTrivia = function () {
            var absoluteStartIndex = this.slidingWindow.getAndPinAbsoluteIndex();

            var width = 0;
            while (true) {
                var ch = this.currentCharCode();

                switch (ch) {
                    case 32 /* space */:
                    case 160 /* nonBreakingSpace */:
                    case 8192 /* enQuad */:
                    case 8193 /* emQuad */:
                    case 8194 /* enSpace */:
                    case 8195 /* emSpace */:
                    case 8196 /* threePerEmSpace */:
                    case 8197 /* fourPerEmSpace */:
                    case 8198 /* sixPerEmSpace */:
                    case 8199 /* figureSpace */:
                    case 8200 /* punctuationSpace */:
                    case 8201 /* thinSpace */:
                    case 8202 /* hairSpace */:
                    case 8203 /* zeroWidthSpace */:
                    case 8239 /* narrowNoBreakSpace */:
                    case 12288 /* ideographicSpace */:

                    case 9 /* tab */:
                    case 11 /* verticalTab */:
                    case 12 /* formFeed */:
                    case 65279 /* byteOrderMark */:
                        this.slidingWindow.moveToNextItem();
                        width++;
                        continue;
                }

                break;
            }

            var text = this.substring(absoluteStartIndex, absoluteStartIndex + width, false);
            this.slidingWindow.releaseAndUnpinAbsoluteIndex(absoluteStartIndex);

            return TypeScript.Syntax.whitespace(text);
        };

        Scanner.prototype.scanSingleLineCommentTrivia = function () {
            var absoluteStartIndex = this.slidingWindow.getAndPinAbsoluteIndex();
            var width = this.scanSingleLineCommentTriviaLength();

            var text = this.substring(absoluteStartIndex, absoluteStartIndex + width, false);
            this.slidingWindow.releaseAndUnpinAbsoluteIndex(absoluteStartIndex);

            return TypeScript.Syntax.singleLineComment(text);
        };

        Scanner.prototype.scanSingleLineCommentTriviaLength = function () {
            this.slidingWindow.moveToNextItem();
            this.slidingWindow.moveToNextItem();

            var width = 2;
            while (true) {
                if (this.slidingWindow.isAtEndOfSource() || this.isNewLineCharacter(this.currentCharCode())) {
                    return width;
                }

                this.slidingWindow.moveToNextItem();
                width++;
            }
        };

        Scanner.prototype.scanMultiLineCommentTrivia = function () {
            var absoluteStartIndex = this.slidingWindow.getAndPinAbsoluteIndex();
            var width = this.scanMultiLineCommentTriviaLength(null);

            var text = this.substring(absoluteStartIndex, absoluteStartIndex + width, false);
            this.slidingWindow.releaseAndUnpinAbsoluteIndex(absoluteStartIndex);

            return TypeScript.Syntax.multiLineComment(text);
        };

        Scanner.prototype.scanMultiLineCommentTriviaLength = function (diagnostics) {
            this.slidingWindow.moveToNextItem();
            this.slidingWindow.moveToNextItem();

            var width = 2;
            while (true) {
                if (this.slidingWindow.isAtEndOfSource()) {
                    if (diagnostics !== null) {
                        diagnostics.push(new TypeScript.Diagnostic(this.fileName, this.slidingWindow.absoluteIndex(), 0, TypeScript.DiagnosticCode.AsteriskSlash_expected, null));
                    }

                    return width;
                }

                var ch = this.currentCharCode();
                if (ch === 42 /* asterisk */ && this.slidingWindow.peekItemN(1) === 47 /* slash */) {
                    this.slidingWindow.moveToNextItem();
                    this.slidingWindow.moveToNextItem();
                    width += 2;
                    return width;
                }

                this.slidingWindow.moveToNextItem();
                width++;
            }
        };

        Scanner.prototype.scanLineTerminatorSequenceTrivia = function (ch) {
            var absoluteStartIndex = this.slidingWindow.getAndPinAbsoluteIndex();
            var width = this.scanLineTerminatorSequenceLength(ch);

            var text = this.substring(absoluteStartIndex, absoluteStartIndex + width, false);
            this.slidingWindow.releaseAndUnpinAbsoluteIndex(absoluteStartIndex);

            return TypeScript.Syntax.trivia(5 /* NewLineTrivia */, text);
        };

        Scanner.prototype.scanLineTerminatorSequenceLength = function (ch) {
            this.slidingWindow.moveToNextItem();

            if (ch === 13 /* carriageReturn */ && this.currentCharCode() === 10 /* lineFeed */) {
                this.slidingWindow.moveToNextItem();
                return 2;
            } else {
                return 1;
            }
        };

        Scanner.prototype.scanSyntaxToken = function (diagnostics, allowRegularExpression) {
            if (this.slidingWindow.isAtEndOfSource()) {
                return 10 /* EndOfFileToken */;
            }

            var character = this.currentCharCode();

            switch (character) {
                case 34 /* doubleQuote */:
                case 39 /* singleQuote */:
                    return this.scanStringLiteral(diagnostics);

                case 47 /* slash */:
                    return this.scanSlashToken(allowRegularExpression);

                case 46 /* dot */:
                    return this.scanDotToken();

                case 45 /* minus */:
                    return this.scanMinusToken();

                case 33 /* exclamation */:
                    return this.scanExclamationToken();

                case 61 /* equals */:
                    return this.scanEqualsToken();

                case 124 /* bar */:
                    return this.scanBarToken();

                case 42 /* asterisk */:
                    return this.scanAsteriskToken();

                case 43 /* plus */:
                    return this.scanPlusToken();

                case 37 /* percent */:
                    return this.scanPercentToken();

                case 38 /* ampersand */:
                    return this.scanAmpersandToken();

                case 94 /* caret */:
                    return this.scanCaretToken();

                case 60 /* lessThan */:
                    return this.scanLessThanToken();

                case 62 /* greaterThan */:
                    return this.advanceAndSetTokenKind(81 /* GreaterThanToken */);

                case 44 /* comma */:
                    return this.advanceAndSetTokenKind(79 /* CommaToken */);

                case 58 /* colon */:
                    return this.advanceAndSetTokenKind(106 /* ColonToken */);

                case 59 /* semicolon */:
                    return this.advanceAndSetTokenKind(78 /* SemicolonToken */);

                case 126 /* tilde */:
                    return this.advanceAndSetTokenKind(102 /* TildeToken */);

                case 40 /* openParen */:
                    return this.advanceAndSetTokenKind(72 /* OpenParenToken */);

                case 41 /* closeParen */:
                    return this.advanceAndSetTokenKind(73 /* CloseParenToken */);

                case 123 /* openBrace */:
                    return this.advanceAndSetTokenKind(70 /* OpenBraceToken */);

                case 125 /* closeBrace */:
                    return this.advanceAndSetTokenKind(71 /* CloseBraceToken */);

                case 91 /* openBracket */:
                    return this.advanceAndSetTokenKind(74 /* OpenBracketToken */);

                case 93 /* closeBracket */:
                    return this.advanceAndSetTokenKind(75 /* CloseBracketToken */);

                case 63 /* question */:
                    return this.advanceAndSetTokenKind(105 /* QuestionToken */);
            }

            if (isNumericLiteralStart[character]) {
                return this.scanNumericLiteral();
            }

            if (isIdentifierStartCharacter[character]) {
                var result = this.tryFastScanIdentifierOrKeyword(character);
                if (result !== 0 /* None */) {
                    return result;
                }
            }

            if (this.isIdentifierStart(this.peekCharOrUnicodeEscape())) {
                return this.slowScanIdentifier(diagnostics);
            }

            return this.scanDefaultCharacter(character, diagnostics);
        };

        Scanner.prototype.isIdentifierStart = function (interpretedChar) {
            if (isIdentifierStartCharacter[interpretedChar]) {
                return true;
            }

            return interpretedChar > 127 /* maxAsciiCharacter */ && TypeScript.Unicode.isIdentifierStart(interpretedChar, this._languageVersion);
        };

        Scanner.prototype.isIdentifierPart = function (interpretedChar) {
            if (isIdentifierPartCharacter[interpretedChar]) {
                return true;
            }

            return interpretedChar > 127 /* maxAsciiCharacter */ && TypeScript.Unicode.isIdentifierPart(interpretedChar, this._languageVersion);
        };

        Scanner.prototype.tryFastScanIdentifierOrKeyword = function (firstCharacter) {
            var startIndex = this.slidingWindow.getAndPinAbsoluteIndex();

            while (true) {
                var character = this.currentCharCode();
                if (isIdentifierPartCharacter[character]) {
                    this.slidingWindow.moveToNextItem();
                } else if (character === 92 /* backslash */ || character > 127 /* maxAsciiCharacter */) {
                    this.slidingWindow.rewindToPinnedIndex(startIndex);
                    this.slidingWindow.releaseAndUnpinAbsoluteIndex(startIndex);
                    return 0 /* None */;
                } else {
                    var endIndex = this.slidingWindow.absoluteIndex();

                    var kind;
                    if (isKeywordStartCharacter[firstCharacter]) {
                        var offset = startIndex - this.slidingWindow.windowAbsoluteStartIndex;
                        kind = TypeScript.ScannerUtilities.identifierKind(this.slidingWindow.window, offset, endIndex - startIndex);
                    } else {
                        kind = 11 /* IdentifierName */;
                    }

                    this.slidingWindow.releaseAndUnpinAbsoluteIndex(startIndex);
                    return kind;
                }
            }
        };

        Scanner.prototype.slowScanIdentifier = function (diagnostics) {
            var startIndex = this.slidingWindow.absoluteIndex();

            do {
                this.scanCharOrUnicodeEscape(diagnostics);
            } while(this.isIdentifierPart(this.peekCharOrUnicodeEscape()));

            return 11 /* IdentifierName */;
        };

        Scanner.prototype.scanNumericLiteral = function () {
            if (this.isHexNumericLiteral()) {
                return this.scanHexNumericLiteral();
            } else {
                return this.scanDecimalNumericLiteral();
            }
        };

        Scanner.prototype.scanDecimalNumericLiteral = function () {
            while (TypeScript.CharacterInfo.isDecimalDigit(this.currentCharCode())) {
                this.slidingWindow.moveToNextItem();
            }

            if (this.currentCharCode() === 46 /* dot */) {
                this.slidingWindow.moveToNextItem();
            }

            while (TypeScript.CharacterInfo.isDecimalDigit(this.currentCharCode())) {
                this.slidingWindow.moveToNextItem();
            }

            var ch = this.currentCharCode();
            if (ch === 101 /* e */ || ch === 69 /* E */) {
                this.slidingWindow.moveToNextItem();

                ch = this.currentCharCode();
                if (ch === 45 /* minus */ || ch === 43 /* plus */) {
                    if (TypeScript.CharacterInfo.isDecimalDigit(this.slidingWindow.peekItemN(1))) {
                        this.slidingWindow.moveToNextItem();
                    }
                }
            }

            while (TypeScript.CharacterInfo.isDecimalDigit(this.currentCharCode())) {
                this.slidingWindow.moveToNextItem();
            }

            return 13 /* NumericLiteral */;
        };

        Scanner.prototype.scanHexNumericLiteral = function () {
            this.slidingWindow.moveToNextItem();
            this.slidingWindow.moveToNextItem();

            while (TypeScript.CharacterInfo.isHexDigit(this.currentCharCode())) {
                this.slidingWindow.moveToNextItem();
            }

            return 13 /* NumericLiteral */;
        };

        Scanner.prototype.isHexNumericLiteral = function () {
            if (this.currentCharCode() === 48 /* _0 */) {
                var ch = this.slidingWindow.peekItemN(1);

                if (ch === 120 /* x */ || ch === 88 /* X */) {
                    ch = this.slidingWindow.peekItemN(2);

                    return TypeScript.CharacterInfo.isHexDigit(ch);
                }
            }

            return false;
        };

        Scanner.prototype.advanceAndSetTokenKind = function (kind) {
            this.slidingWindow.moveToNextItem();
            return kind;
        };

        Scanner.prototype.scanLessThanToken = function () {
            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === 61 /* equals */) {
                this.slidingWindow.moveToNextItem();
                return 82 /* LessThanEqualsToken */;
            } else if (this.currentCharCode() === 60 /* lessThan */) {
                this.slidingWindow.moveToNextItem();
                if (this.currentCharCode() === 61 /* equals */) {
                    this.slidingWindow.moveToNextItem();
                    return 112 /* LessThanLessThanEqualsToken */;
                } else {
                    return 95 /* LessThanLessThanToken */;
                }
            } else {
                return 80 /* LessThanToken */;
            }
        };

        Scanner.prototype.scanBarToken = function () {
            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === 61 /* equals */) {
                this.slidingWindow.moveToNextItem();
                return 116 /* BarEqualsToken */;
            } else if (this.currentCharCode() === 124 /* bar */) {
                this.slidingWindow.moveToNextItem();
                return 104 /* BarBarToken */;
            } else {
                return 99 /* BarToken */;
            }
        };

        Scanner.prototype.scanCaretToken = function () {
            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === 61 /* equals */) {
                this.slidingWindow.moveToNextItem();
                return 117 /* CaretEqualsToken */;
            } else {
                return 100 /* CaretToken */;
            }
        };

        Scanner.prototype.scanAmpersandToken = function () {
            this.slidingWindow.moveToNextItem();
            var character = this.currentCharCode();
            if (character === 61 /* equals */) {
                this.slidingWindow.moveToNextItem();
                return 115 /* AmpersandEqualsToken */;
            } else if (this.currentCharCode() === 38 /* ampersand */) {
                this.slidingWindow.moveToNextItem();
                return 103 /* AmpersandAmpersandToken */;
            } else {
                return 98 /* AmpersandToken */;
            }
        };

        Scanner.prototype.scanPercentToken = function () {
            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === 61 /* equals */) {
                this.slidingWindow.moveToNextItem();
                return 111 /* PercentEqualsToken */;
            } else {
                return 92 /* PercentToken */;
            }
        };

        Scanner.prototype.scanMinusToken = function () {
            this.slidingWindow.moveToNextItem();
            var character = this.currentCharCode();

            if (character === 61 /* equals */) {
                this.slidingWindow.moveToNextItem();
                return 109 /* MinusEqualsToken */;
            } else if (character === 45 /* minus */) {
                this.slidingWindow.moveToNextItem();
                return 94 /* MinusMinusToken */;
            } else {
                return 90 /* MinusToken */;
            }
        };

        Scanner.prototype.scanPlusToken = function () {
            this.slidingWindow.moveToNextItem();
            var character = this.currentCharCode();
            if (character === 61 /* equals */) {
                this.slidingWindow.moveToNextItem();
                return 108 /* PlusEqualsToken */;
            } else if (character === 43 /* plus */) {
                this.slidingWindow.moveToNextItem();
                return 93 /* PlusPlusToken */;
            } else {
                return 89 /* PlusToken */;
            }
        };

        Scanner.prototype.scanAsteriskToken = function () {
            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === 61 /* equals */) {
                this.slidingWindow.moveToNextItem();
                return 110 /* AsteriskEqualsToken */;
            } else {
                return 91 /* AsteriskToken */;
            }
        };

        Scanner.prototype.scanEqualsToken = function () {
            this.slidingWindow.moveToNextItem();
            var character = this.currentCharCode();
            if (character === 61 /* equals */) {
                this.slidingWindow.moveToNextItem();

                if (this.currentCharCode() === 61 /* equals */) {
                    this.slidingWindow.moveToNextItem();

                    return 87 /* EqualsEqualsEqualsToken */;
                } else {
                    return 84 /* EqualsEqualsToken */;
                }
            } else if (character === 62 /* greaterThan */) {
                this.slidingWindow.moveToNextItem();
                return 85 /* EqualsGreaterThanToken */;
            } else {
                return 107 /* EqualsToken */;
            }
        };

        Scanner.prototype.isDotPrefixedNumericLiteral = function () {
            if (this.currentCharCode() === 46 /* dot */) {
                var ch = this.slidingWindow.peekItemN(1);
                return TypeScript.CharacterInfo.isDecimalDigit(ch);
            }

            return false;
        };

        Scanner.prototype.scanDotToken = function () {
            if (this.isDotPrefixedNumericLiteral()) {
                return this.scanNumericLiteral();
            }

            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === 46 /* dot */ && this.slidingWindow.peekItemN(1) === 46 /* dot */) {
                this.slidingWindow.moveToNextItem();
                this.slidingWindow.moveToNextItem();
                return 77 /* DotDotDotToken */;
            } else {
                return 76 /* DotToken */;
            }
        };

        Scanner.prototype.scanSlashToken = function (allowRegularExpression) {
            if (allowRegularExpression) {
                var result = this.tryScanRegularExpressionToken();
                if (result !== 0 /* None */) {
                    return result;
                }
            }

            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === 61 /* equals */) {
                this.slidingWindow.moveToNextItem();
                return 119 /* SlashEqualsToken */;
            } else {
                return 118 /* SlashToken */;
            }
        };

        Scanner.prototype.tryScanRegularExpressionToken = function () {
            var startIndex = this.slidingWindow.getAndPinAbsoluteIndex();
            try  {
                this.slidingWindow.moveToNextItem();

                var inEscape = false;
                var inCharacterClass = false;
                while (true) {
                    var ch = this.currentCharCode();
                    if (this.isNewLineCharacter(ch) || this.slidingWindow.isAtEndOfSource()) {
                        this.slidingWindow.rewindToPinnedIndex(startIndex);
                        return 0 /* None */;
                    }

                    this.slidingWindow.moveToNextItem();
                    if (inEscape) {
                        inEscape = false;
                        continue;
                    }

                    switch (ch) {
                        case 92 /* backslash */:
                            inEscape = true;
                            continue;

                        case 91 /* openBracket */:
                            inCharacterClass = true;
                            continue;

                        case 93 /* closeBracket */:
                            inCharacterClass = false;
                            continue;

                        case 47 /* slash */:
                            if (inCharacterClass) {
                                continue;
                            }

                            break;

                        default:
                            continue;
                    }

                    break;
                }

                while (isIdentifierPartCharacter[this.currentCharCode()]) {
                    this.slidingWindow.moveToNextItem();
                }

                return 12 /* RegularExpressionLiteral */;
            } finally {
                this.slidingWindow.releaseAndUnpinAbsoluteIndex(startIndex);
            }
        };

        Scanner.prototype.scanExclamationToken = function () {
            this.slidingWindow.moveToNextItem();
            if (this.currentCharCode() === 61 /* equals */) {
                this.slidingWindow.moveToNextItem();

                if (this.currentCharCode() === 61 /* equals */) {
                    this.slidingWindow.moveToNextItem();

                    return 88 /* ExclamationEqualsEqualsToken */;
                } else {
                    return 86 /* ExclamationEqualsToken */;
                }
            } else {
                return 101 /* ExclamationToken */;
            }
        };

        Scanner.prototype.scanDefaultCharacter = function (character, diagnostics) {
            var position = this.slidingWindow.absoluteIndex();
            this.slidingWindow.moveToNextItem();

            var text = String.fromCharCode(character);
            var messageText = this.getErrorMessageText(text);
            diagnostics.push(new TypeScript.Diagnostic(this.fileName, position, 1, TypeScript.DiagnosticCode.Unexpected_character_0, [messageText]));

            return 9 /* ErrorToken */;
        };

        Scanner.prototype.getErrorMessageText = function (text) {
            if (text === "\\") {
                return '"\\"';
            }

            return JSON.stringify(text);
        };

        Scanner.prototype.skipEscapeSequence = function (diagnostics) {
            var rewindPoint = this.slidingWindow.getAndPinAbsoluteIndex();
            try  {
                this.slidingWindow.moveToNextItem();

                var ch = this.currentCharCode();
                this.slidingWindow.moveToNextItem();
                switch (ch) {
                    case 120 /* x */:
                    case 117 /* u */:
                        this.slidingWindow.rewindToPinnedIndex(rewindPoint);
                        var value = this.scanUnicodeOrHexEscape(diagnostics);
                        return;

                    case 13 /* carriageReturn */:
                        if (this.currentCharCode() === 10 /* lineFeed */) {
                            this.slidingWindow.moveToNextItem();
                        }
                        return;

                    default:
                        return;
                }
            } finally {
                this.slidingWindow.releaseAndUnpinAbsoluteIndex(rewindPoint);
            }
        };

        Scanner.prototype.scanStringLiteral = function (diagnostics) {
            var quoteCharacter = this.currentCharCode();

            this.slidingWindow.moveToNextItem();

            while (true) {
                var ch = this.currentCharCode();
                if (ch === 92 /* backslash */) {
                    this.skipEscapeSequence(diagnostics);
                } else if (ch === quoteCharacter) {
                    this.slidingWindow.moveToNextItem();
                    break;
                } else if (this.isNewLineCharacter(ch) || this.slidingWindow.isAtEndOfSource()) {
                    diagnostics.push(new TypeScript.Diagnostic(this.fileName, this.slidingWindow.absoluteIndex(), 1, TypeScript.DiagnosticCode.Missing_close_quote_character, null));
                    break;
                } else {
                    this.slidingWindow.moveToNextItem();
                }
            }

            return 14 /* StringLiteral */;
        };

        Scanner.prototype.isUnicodeOrHexEscape = function (character) {
            return this.isUnicodeEscape(character) || this.isHexEscape(character);
        };

        Scanner.prototype.isUnicodeEscape = function (character) {
            if (character === 92 /* backslash */) {
                var ch2 = this.slidingWindow.peekItemN(1);
                if (ch2 === 117 /* u */) {
                    return true;
                }
            }

            return false;
        };

        Scanner.prototype.isHexEscape = function (character) {
            if (character === 92 /* backslash */) {
                var ch2 = this.slidingWindow.peekItemN(1);
                if (ch2 === 120 /* x */) {
                    return true;
                }
            }

            return false;
        };

        Scanner.prototype.peekCharOrUnicodeOrHexEscape = function () {
            var character = this.currentCharCode();
            if (this.isUnicodeOrHexEscape(character)) {
                return this.peekUnicodeOrHexEscape();
            } else {
                return character;
            }
        };

        Scanner.prototype.peekCharOrUnicodeEscape = function () {
            var character = this.currentCharCode();
            if (this.isUnicodeEscape(character)) {
                return this.peekUnicodeOrHexEscape();
            } else {
                return character;
            }
        };

        Scanner.prototype.peekUnicodeOrHexEscape = function () {
            var startIndex = this.slidingWindow.getAndPinAbsoluteIndex();

            var ch = this.scanUnicodeOrHexEscape(null);

            this.slidingWindow.rewindToPinnedIndex(startIndex);
            this.slidingWindow.releaseAndUnpinAbsoluteIndex(startIndex);

            return ch;
        };

        Scanner.prototype.scanCharOrUnicodeEscape = function (errors) {
            var ch = this.currentCharCode();
            if (ch === 92 /* backslash */) {
                var ch2 = this.slidingWindow.peekItemN(1);
                if (ch2 === 117 /* u */) {
                    return this.scanUnicodeOrHexEscape(errors);
                }
            }

            this.slidingWindow.moveToNextItem();
            return ch;
        };

        Scanner.prototype.scanCharOrUnicodeOrHexEscape = function (errors) {
            var ch = this.currentCharCode();
            if (ch === 92 /* backslash */) {
                var ch2 = this.slidingWindow.peekItemN(1);
                if (ch2 === 117 /* u */ || ch2 === 120 /* x */) {
                    return this.scanUnicodeOrHexEscape(errors);
                }
            }

            this.slidingWindow.moveToNextItem();
            return ch;
        };

        Scanner.prototype.scanUnicodeOrHexEscape = function (errors) {
            var start = this.slidingWindow.absoluteIndex();
            var character = this.currentCharCode();

            this.slidingWindow.moveToNextItem();

            character = this.currentCharCode();

            var intChar = 0;
            this.slidingWindow.moveToNextItem();

            var count = character === 117 /* u */ ? 4 : 2;

            for (var i = 0; i < count; i++) {
                var ch2 = this.currentCharCode();
                if (!TypeScript.CharacterInfo.isHexDigit(ch2)) {
                    if (errors !== null) {
                        var end = this.slidingWindow.absoluteIndex();
                        var info = this.createIllegalEscapeDiagnostic(start, end);
                        errors.push(info);
                    }

                    break;
                }

                intChar = (intChar << 4) + TypeScript.CharacterInfo.hexValue(ch2);
                this.slidingWindow.moveToNextItem();
            }

            return intChar;
        };

        Scanner.prototype.substring = function (start, end, intern) {
            var length = end - start;
            var offset = start - this.slidingWindow.windowAbsoluteStartIndex;

            if (intern) {
                return TypeScript.Collections.DefaultStringTable.addCharArray(this.slidingWindow.window, offset, length);
            } else {
                return TypeScript.StringUtilities.fromCharCodeArray(this.slidingWindow.window.slice(offset, offset + length));
            }
        };

        Scanner.prototype.createIllegalEscapeDiagnostic = function (start, end) {
            return new TypeScript.Diagnostic(this.fileName, start, end - start, TypeScript.DiagnosticCode.Unrecognized_escape_sequence, null);
        };

        Scanner.isValidIdentifier = function (text, languageVersion) {
            var scanner = new Scanner(null, text, TypeScript.LanguageVersion, Scanner.triviaWindow);
            var errors = new Array();
            var token = scanner.scan(errors, false);

            return errors.length === 0 && TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(token) && token.width() === text.length();
        };
        Scanner.triviaWindow = TypeScript.ArrayUtilities.createArray(2048, 0);
        return Scanner;
    })();
    TypeScript.Scanner = Scanner;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var ScannerUtilities = (function () {
        function ScannerUtilities() {
        }
        ScannerUtilities.identifierKind = function (array, startIndex, length) {
            switch (length) {
                case 2:
                    switch (array[startIndex]) {
                        case 100 /* d */:
                            return (array[startIndex + 1] === 111 /* o */) ? 22 /* DoKeyword */ : 11 /* IdentifierName */;
                        case 105 /* i */:
                            switch (array[startIndex + 1]) {
                                case 102 /* f */:
                                    return 28 /* IfKeyword */;
                                case 110 /* n */:
                                    return 29 /* InKeyword */;
                                default:
                                    return 11 /* IdentifierName */;
                            }

                        default:
                            return 11 /* IdentifierName */;
                    }

                case 3:
                    switch (array[startIndex]) {
                        case 102 /* f */:
                            return (array[startIndex + 1] === 111 /* o */ && array[startIndex + 2] === 114 /* r */) ? 26 /* ForKeyword */ : 11 /* IdentifierName */;
                        case 110 /* n */:
                            return (array[startIndex + 1] === 101 /* e */ && array[startIndex + 2] === 119 /* w */) ? 31 /* NewKeyword */ : 11 /* IdentifierName */;
                        case 116 /* t */:
                            return (array[startIndex + 1] === 114 /* r */ && array[startIndex + 2] === 121 /* y */) ? 38 /* TryKeyword */ : 11 /* IdentifierName */;
                        case 118 /* v */:
                            return (array[startIndex + 1] === 97 /* a */ && array[startIndex + 2] === 114 /* r */) ? 40 /* VarKeyword */ : 11 /* IdentifierName */;
                        case 108 /* l */:
                            return (array[startIndex + 1] === 101 /* e */ && array[startIndex + 2] === 116 /* t */) ? 53 /* LetKeyword */ : 11 /* IdentifierName */;
                        case 97 /* a */:
                            return (array[startIndex + 1] === 110 /* n */ && array[startIndex + 2] === 121 /* y */) ? 60 /* AnyKeyword */ : 11 /* IdentifierName */;
                        case 103 /* g */:
                            return (array[startIndex + 1] === 101 /* e */ && array[startIndex + 2] === 116 /* t */) ? 64 /* GetKeyword */ : 11 /* IdentifierName */;
                        case 115 /* s */:
                            return (array[startIndex + 1] === 101 /* e */ && array[startIndex + 2] === 116 /* t */) ? 68 /* SetKeyword */ : 11 /* IdentifierName */;
                        default:
                            return 11 /* IdentifierName */;
                    }

                case 4:
                    switch (array[startIndex]) {
                        case 99 /* c */:
                            return (array[startIndex + 1] === 97 /* a */ && array[startIndex + 2] === 115 /* s */ && array[startIndex + 3] === 101 /* e */) ? 16 /* CaseKeyword */ : 11 /* IdentifierName */;
                        case 101 /* e */:
                            switch (array[startIndex + 1]) {
                                case 108 /* l */:
                                    return (array[startIndex + 2] === 115 /* s */ && array[startIndex + 3] === 101 /* e */) ? 23 /* ElseKeyword */ : 11 /* IdentifierName */;
                                case 110 /* n */:
                                    return (array[startIndex + 2] === 117 /* u */ && array[startIndex + 3] === 109 /* m */) ? 46 /* EnumKeyword */ : 11 /* IdentifierName */;
                                default:
                                    return 11 /* IdentifierName */;
                            }

                        case 110 /* n */:
                            return (array[startIndex + 1] === 117 /* u */ && array[startIndex + 2] === 108 /* l */ && array[startIndex + 3] === 108 /* l */) ? 32 /* NullKeyword */ : 11 /* IdentifierName */;
                        case 116 /* t */:
                            switch (array[startIndex + 1]) {
                                case 104 /* h */:
                                    return (array[startIndex + 2] === 105 /* i */ && array[startIndex + 3] === 115 /* s */) ? 35 /* ThisKeyword */ : 11 /* IdentifierName */;
                                case 114 /* r */:
                                    return (array[startIndex + 2] === 117 /* u */ && array[startIndex + 3] === 101 /* e */) ? 37 /* TrueKeyword */ : 11 /* IdentifierName */;
                                default:
                                    return 11 /* IdentifierName */;
                            }

                        case 118 /* v */:
                            return (array[startIndex + 1] === 111 /* o */ && array[startIndex + 2] === 105 /* i */ && array[startIndex + 3] === 100 /* d */) ? 41 /* VoidKeyword */ : 11 /* IdentifierName */;
                        case 119 /* w */:
                            return (array[startIndex + 1] === 105 /* i */ && array[startIndex + 2] === 116 /* t */ && array[startIndex + 3] === 104 /* h */) ? 43 /* WithKeyword */ : 11 /* IdentifierName */;
                        default:
                            return 11 /* IdentifierName */;
                    }

                case 5:
                    switch (array[startIndex]) {
                        case 98 /* b */:
                            return (array[startIndex + 1] === 114 /* r */ && array[startIndex + 2] === 101 /* e */ && array[startIndex + 3] === 97 /* a */ && array[startIndex + 4] === 107 /* k */) ? 15 /* BreakKeyword */ : 11 /* IdentifierName */;
                        case 99 /* c */:
                            switch (array[startIndex + 1]) {
                                case 97 /* a */:
                                    return (array[startIndex + 2] === 116 /* t */ && array[startIndex + 3] === 99 /* c */ && array[startIndex + 4] === 104 /* h */) ? 17 /* CatchKeyword */ : 11 /* IdentifierName */;
                                case 108 /* l */:
                                    return (array[startIndex + 2] === 97 /* a */ && array[startIndex + 3] === 115 /* s */ && array[startIndex + 4] === 115 /* s */) ? 44 /* ClassKeyword */ : 11 /* IdentifierName */;
                                case 111 /* o */:
                                    return (array[startIndex + 2] === 110 /* n */ && array[startIndex + 3] === 115 /* s */ && array[startIndex + 4] === 116 /* t */) ? 45 /* ConstKeyword */ : 11 /* IdentifierName */;
                                default:
                                    return 11 /* IdentifierName */;
                            }

                        case 102 /* f */:
                            return (array[startIndex + 1] === 97 /* a */ && array[startIndex + 2] === 108 /* l */ && array[startIndex + 3] === 115 /* s */ && array[startIndex + 4] === 101 /* e */) ? 24 /* FalseKeyword */ : 11 /* IdentifierName */;
                        case 116 /* t */:
                            return (array[startIndex + 1] === 104 /* h */ && array[startIndex + 2] === 114 /* r */ && array[startIndex + 3] === 111 /* o */ && array[startIndex + 4] === 119 /* w */) ? 36 /* ThrowKeyword */ : 11 /* IdentifierName */;
                        case 119 /* w */:
                            return (array[startIndex + 1] === 104 /* h */ && array[startIndex + 2] === 105 /* i */ && array[startIndex + 3] === 108 /* l */ && array[startIndex + 4] === 101 /* e */) ? 42 /* WhileKeyword */ : 11 /* IdentifierName */;
                        case 115 /* s */:
                            return (array[startIndex + 1] === 117 /* u */ && array[startIndex + 2] === 112 /* p */ && array[startIndex + 3] === 101 /* e */ && array[startIndex + 4] === 114 /* r */) ? 50 /* SuperKeyword */ : 11 /* IdentifierName */;
                        case 121 /* y */:
                            return (array[startIndex + 1] === 105 /* i */ && array[startIndex + 2] === 101 /* e */ && array[startIndex + 3] === 108 /* l */ && array[startIndex + 4] === 100 /* d */) ? 59 /* YieldKeyword */ : 11 /* IdentifierName */;
                        default:
                            return 11 /* IdentifierName */;
                    }

                case 6:
                    switch (array[startIndex]) {
                        case 100 /* d */:
                            return (array[startIndex + 1] === 101 /* e */ && array[startIndex + 2] === 108 /* l */ && array[startIndex + 3] === 101 /* e */ && array[startIndex + 4] === 116 /* t */ && array[startIndex + 5] === 101 /* e */) ? 21 /* DeleteKeyword */ : 11 /* IdentifierName */;
                        case 114 /* r */:
                            return (array[startIndex + 1] === 101 /* e */ && array[startIndex + 2] === 116 /* t */ && array[startIndex + 3] === 117 /* u */ && array[startIndex + 4] === 114 /* r */ && array[startIndex + 5] === 110 /* n */) ? 33 /* ReturnKeyword */ : 11 /* IdentifierName */;
                        case 115 /* s */:
                            switch (array[startIndex + 1]) {
                                case 119 /* w */:
                                    return (array[startIndex + 2] === 105 /* i */ && array[startIndex + 3] === 116 /* t */ && array[startIndex + 4] === 99 /* c */ && array[startIndex + 5] === 104 /* h */) ? 34 /* SwitchKeyword */ : 11 /* IdentifierName */;
                                case 116 /* t */:
                                    switch (array[startIndex + 2]) {
                                        case 97 /* a */:
                                            return (array[startIndex + 3] === 116 /* t */ && array[startIndex + 4] === 105 /* i */ && array[startIndex + 5] === 99 /* c */) ? 58 /* StaticKeyword */ : 11 /* IdentifierName */;
                                        case 114 /* r */:
                                            return (array[startIndex + 3] === 105 /* i */ && array[startIndex + 4] === 110 /* n */ && array[startIndex + 5] === 103 /* g */) ? 69 /* StringKeyword */ : 11 /* IdentifierName */;
                                        default:
                                            return 11 /* IdentifierName */;
                                    }

                                default:
                                    return 11 /* IdentifierName */;
                            }

                        case 116 /* t */:
                            return (array[startIndex + 1] === 121 /* y */ && array[startIndex + 2] === 112 /* p */ && array[startIndex + 3] === 101 /* e */ && array[startIndex + 4] === 111 /* o */ && array[startIndex + 5] === 102 /* f */) ? 39 /* TypeOfKeyword */ : 11 /* IdentifierName */;
                        case 101 /* e */:
                            return (array[startIndex + 1] === 120 /* x */ && array[startIndex + 2] === 112 /* p */ && array[startIndex + 3] === 111 /* o */ && array[startIndex + 4] === 114 /* r */ && array[startIndex + 5] === 116 /* t */) ? 47 /* ExportKeyword */ : 11 /* IdentifierName */;
                        case 105 /* i */:
                            return (array[startIndex + 1] === 109 /* m */ && array[startIndex + 2] === 112 /* p */ && array[startIndex + 3] === 111 /* o */ && array[startIndex + 4] === 114 /* r */ && array[startIndex + 5] === 116 /* t */) ? 49 /* ImportKeyword */ : 11 /* IdentifierName */;
                        case 112 /* p */:
                            return (array[startIndex + 1] === 117 /* u */ && array[startIndex + 2] === 98 /* b */ && array[startIndex + 3] === 108 /* l */ && array[startIndex + 4] === 105 /* i */ && array[startIndex + 5] === 99 /* c */) ? 57 /* PublicKeyword */ : 11 /* IdentifierName */;
                        case 109 /* m */:
                            return (array[startIndex + 1] === 111 /* o */ && array[startIndex + 2] === 100 /* d */ && array[startIndex + 3] === 117 /* u */ && array[startIndex + 4] === 108 /* l */ && array[startIndex + 5] === 101 /* e */) ? 65 /* ModuleKeyword */ : 11 /* IdentifierName */;
                        case 110 /* n */:
                            return (array[startIndex + 1] === 117 /* u */ && array[startIndex + 2] === 109 /* m */ && array[startIndex + 3] === 98 /* b */ && array[startIndex + 4] === 101 /* e */ && array[startIndex + 5] === 114 /* r */) ? 67 /* NumberKeyword */ : 11 /* IdentifierName */;
                        default:
                            return 11 /* IdentifierName */;
                    }

                case 7:
                    switch (array[startIndex]) {
                        case 100 /* d */:
                            switch (array[startIndex + 1]) {
                                case 101 /* e */:
                                    switch (array[startIndex + 2]) {
                                        case 102 /* f */:
                                            return (array[startIndex + 3] === 97 /* a */ && array[startIndex + 4] === 117 /* u */ && array[startIndex + 5] === 108 /* l */ && array[startIndex + 6] === 116 /* t */) ? 20 /* DefaultKeyword */ : 11 /* IdentifierName */;
                                        case 99 /* c */:
                                            return (array[startIndex + 3] === 108 /* l */ && array[startIndex + 4] === 97 /* a */ && array[startIndex + 5] === 114 /* r */ && array[startIndex + 6] === 101 /* e */) ? 63 /* DeclareKeyword */ : 11 /* IdentifierName */;
                                        default:
                                            return 11 /* IdentifierName */;
                                    }

                                default:
                                    return 11 /* IdentifierName */;
                            }

                        case 102 /* f */:
                            return (array[startIndex + 1] === 105 /* i */ && array[startIndex + 2] === 110 /* n */ && array[startIndex + 3] === 97 /* a */ && array[startIndex + 4] === 108 /* l */ && array[startIndex + 5] === 108 /* l */ && array[startIndex + 6] === 121 /* y */) ? 25 /* FinallyKeyword */ : 11 /* IdentifierName */;
                        case 101 /* e */:
                            return (array[startIndex + 1] === 120 /* x */ && array[startIndex + 2] === 116 /* t */ && array[startIndex + 3] === 101 /* e */ && array[startIndex + 4] === 110 /* n */ && array[startIndex + 5] === 100 /* d */ && array[startIndex + 6] === 115 /* s */) ? 48 /* ExtendsKeyword */ : 11 /* IdentifierName */;
                        case 112 /* p */:
                            switch (array[startIndex + 1]) {
                                case 97 /* a */:
                                    return (array[startIndex + 2] === 99 /* c */ && array[startIndex + 3] === 107 /* k */ && array[startIndex + 4] === 97 /* a */ && array[startIndex + 5] === 103 /* g */ && array[startIndex + 6] === 101 /* e */) ? 54 /* PackageKeyword */ : 11 /* IdentifierName */;
                                case 114 /* r */:
                                    return (array[startIndex + 2] === 105 /* i */ && array[startIndex + 3] === 118 /* v */ && array[startIndex + 4] === 97 /* a */ && array[startIndex + 5] === 116 /* t */ && array[startIndex + 6] === 101 /* e */) ? 55 /* PrivateKeyword */ : 11 /* IdentifierName */;
                                default:
                                    return 11 /* IdentifierName */;
                            }

                        case 98 /* b */:
                            return (array[startIndex + 1] === 111 /* o */ && array[startIndex + 2] === 111 /* o */ && array[startIndex + 3] === 108 /* l */ && array[startIndex + 4] === 101 /* e */ && array[startIndex + 5] === 97 /* a */ && array[startIndex + 6] === 110 /* n */) ? 61 /* BooleanKeyword */ : 11 /* IdentifierName */;
                        case 114 /* r */:
                            return (array[startIndex + 1] === 101 /* e */ && array[startIndex + 2] === 113 /* q */ && array[startIndex + 3] === 117 /* u */ && array[startIndex + 4] === 105 /* i */ && array[startIndex + 5] === 114 /* r */ && array[startIndex + 6] === 101 /* e */) ? 66 /* RequireKeyword */ : 11 /* IdentifierName */;
                        default:
                            return 11 /* IdentifierName */;
                    }

                case 8:
                    switch (array[startIndex]) {
                        case 99 /* c */:
                            return (array[startIndex + 1] === 111 /* o */ && array[startIndex + 2] === 110 /* n */ && array[startIndex + 3] === 116 /* t */ && array[startIndex + 4] === 105 /* i */ && array[startIndex + 5] === 110 /* n */ && array[startIndex + 6] === 117 /* u */ && array[startIndex + 7] === 101 /* e */) ? 18 /* ContinueKeyword */ : 11 /* IdentifierName */;
                        case 100 /* d */:
                            return (array[startIndex + 1] === 101 /* e */ && array[startIndex + 2] === 98 /* b */ && array[startIndex + 3] === 117 /* u */ && array[startIndex + 4] === 103 /* g */ && array[startIndex + 5] === 103 /* g */ && array[startIndex + 6] === 101 /* e */ && array[startIndex + 7] === 114 /* r */) ? 19 /* DebuggerKeyword */ : 11 /* IdentifierName */;
                        case 102 /* f */:
                            return (array[startIndex + 1] === 117 /* u */ && array[startIndex + 2] === 110 /* n */ && array[startIndex + 3] === 99 /* c */ && array[startIndex + 4] === 116 /* t */ && array[startIndex + 5] === 105 /* i */ && array[startIndex + 6] === 111 /* o */ && array[startIndex + 7] === 110 /* n */) ? 27 /* FunctionKeyword */ : 11 /* IdentifierName */;
                        default:
                            return 11 /* IdentifierName */;
                    }

                case 9:
                    switch (array[startIndex]) {
                        case 105 /* i */:
                            return (array[startIndex + 1] === 110 /* n */ && array[startIndex + 2] === 116 /* t */ && array[startIndex + 3] === 101 /* e */ && array[startIndex + 4] === 114 /* r */ && array[startIndex + 5] === 102 /* f */ && array[startIndex + 6] === 97 /* a */ && array[startIndex + 7] === 99 /* c */ && array[startIndex + 8] === 101 /* e */) ? 52 /* InterfaceKeyword */ : 11 /* IdentifierName */;
                        case 112 /* p */:
                            return (array[startIndex + 1] === 114 /* r */ && array[startIndex + 2] === 111 /* o */ && array[startIndex + 3] === 116 /* t */ && array[startIndex + 4] === 101 /* e */ && array[startIndex + 5] === 99 /* c */ && array[startIndex + 6] === 116 /* t */ && array[startIndex + 7] === 101 /* e */ && array[startIndex + 8] === 100 /* d */) ? 56 /* ProtectedKeyword */ : 11 /* IdentifierName */;
                        default:
                            return 11 /* IdentifierName */;
                    }

                case 10:
                    switch (array[startIndex]) {
                        case 105 /* i */:
                            switch (array[startIndex + 1]) {
                                case 110 /* n */:
                                    return (array[startIndex + 2] === 115 /* s */ && array[startIndex + 3] === 116 /* t */ && array[startIndex + 4] === 97 /* a */ && array[startIndex + 5] === 110 /* n */ && array[startIndex + 6] === 99 /* c */ && array[startIndex + 7] === 101 /* e */ && array[startIndex + 8] === 111 /* o */ && array[startIndex + 9] === 102 /* f */) ? 30 /* InstanceOfKeyword */ : 11 /* IdentifierName */;
                                case 109 /* m */:
                                    return (array[startIndex + 2] === 112 /* p */ && array[startIndex + 3] === 108 /* l */ && array[startIndex + 4] === 101 /* e */ && array[startIndex + 5] === 109 /* m */ && array[startIndex + 6] === 101 /* e */ && array[startIndex + 7] === 110 /* n */ && array[startIndex + 8] === 116 /* t */ && array[startIndex + 9] === 115 /* s */) ? 51 /* ImplementsKeyword */ : 11 /* IdentifierName */;
                                default:
                                    return 11 /* IdentifierName */;
                            }

                        default:
                            return 11 /* IdentifierName */;
                    }

                case 11:
                    return (array[startIndex] === 99 /* c */ && array[startIndex + 1] === 111 /* o */ && array[startIndex + 2] === 110 /* n */ && array[startIndex + 3] === 115 /* s */ && array[startIndex + 4] === 116 /* t */ && array[startIndex + 5] === 114 /* r */ && array[startIndex + 6] === 117 /* u */ && array[startIndex + 7] === 99 /* c */ && array[startIndex + 8] === 116 /* t */ && array[startIndex + 9] === 111 /* o */ && array[startIndex + 10] === 114 /* r */) ? 62 /* ConstructorKeyword */ : 11 /* IdentifierName */;
                default:
                    return 11 /* IdentifierName */;
            }
        };
        return ScannerUtilities;
    })();
    TypeScript.ScannerUtilities = ScannerUtilities;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Syntax) {
        var EmptySeparatedSyntaxList = (function () {
            function EmptySeparatedSyntaxList() {
            }
            EmptySeparatedSyntaxList.prototype.kind = function () {
                return 2 /* SeparatedList */;
            };

            EmptySeparatedSyntaxList.prototype.isNode = function () {
                return false;
            };

            EmptySeparatedSyntaxList.prototype.isToken = function () {
                return false;
            };

            EmptySeparatedSyntaxList.prototype.isList = function () {
                return false;
            };

            EmptySeparatedSyntaxList.prototype.isSeparatedList = function () {
                return true;
            };

            EmptySeparatedSyntaxList.prototype.toJSON = function (key) {
                return [];
            };

            EmptySeparatedSyntaxList.prototype.childCount = function () {
                return 0;
            };

            EmptySeparatedSyntaxList.prototype.nonSeparatorCount = function () {
                return 0;
            };

            EmptySeparatedSyntaxList.prototype.separatorCount = function () {
                return 0;
            };

            EmptySeparatedSyntaxList.prototype.toArray = function () {
                return [];
            };

            EmptySeparatedSyntaxList.prototype.toNonSeparatorArray = function () {
                return [];
            };

            EmptySeparatedSyntaxList.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            };

            EmptySeparatedSyntaxList.prototype.nonSeparatorAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            };

            EmptySeparatedSyntaxList.prototype.separatorAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            };

            EmptySeparatedSyntaxList.prototype.collectTextElements = function (elements) {
            };

            EmptySeparatedSyntaxList.prototype.firstToken = function () {
                return null;
            };

            EmptySeparatedSyntaxList.prototype.lastToken = function () {
                return null;
            };

            EmptySeparatedSyntaxList.prototype.fullWidth = function () {
                return 0;
            };

            EmptySeparatedSyntaxList.prototype.fullText = function () {
                return "";
            };

            EmptySeparatedSyntaxList.prototype.width = function () {
                return 0;
            };

            EmptySeparatedSyntaxList.prototype.isTypeScriptSpecific = function () {
                return false;
            };

            EmptySeparatedSyntaxList.prototype.isIncrementallyUnusable = function () {
                return false;
            };

            EmptySeparatedSyntaxList.prototype.findTokenInternal = function (parent, position, fullStart) {
                throw TypeScript.Errors.invalidOperation();
            };

            EmptySeparatedSyntaxList.prototype.insertChildrenInto = function (array, index) {
            };

            EmptySeparatedSyntaxList.prototype.leadingTrivia = function () {
                return Syntax.emptyTriviaList;
            };

            EmptySeparatedSyntaxList.prototype.trailingTrivia = function () {
                return Syntax.emptyTriviaList;
            };

            EmptySeparatedSyntaxList.prototype.leadingTriviaWidth = function () {
                return 0;
            };

            EmptySeparatedSyntaxList.prototype.trailingTriviaWidth = function () {
                return 0;
            };
            return EmptySeparatedSyntaxList;
        })();

        Syntax.emptySeparatedList = new EmptySeparatedSyntaxList();

        var SingletonSeparatedSyntaxList = (function () {
            function SingletonSeparatedSyntaxList(item) {
                this.item = item;
            }
            SingletonSeparatedSyntaxList.prototype.toJSON = function (key) {
                return [this.item];
            };

            SingletonSeparatedSyntaxList.prototype.kind = function () {
                return 2 /* SeparatedList */;
            };

            SingletonSeparatedSyntaxList.prototype.isNode = function () {
                return false;
            };
            SingletonSeparatedSyntaxList.prototype.isToken = function () {
                return false;
            };
            SingletonSeparatedSyntaxList.prototype.isList = function () {
                return false;
            };
            SingletonSeparatedSyntaxList.prototype.isSeparatedList = function () {
                return true;
            };

            SingletonSeparatedSyntaxList.prototype.childCount = function () {
                return 1;
            };
            SingletonSeparatedSyntaxList.prototype.nonSeparatorCount = function () {
                return 1;
            };
            SingletonSeparatedSyntaxList.prototype.separatorCount = function () {
                return 0;
            };

            SingletonSeparatedSyntaxList.prototype.toArray = function () {
                return [this.item];
            };
            SingletonSeparatedSyntaxList.prototype.toNonSeparatorArray = function () {
                return [this.item];
            };

            SingletonSeparatedSyntaxList.prototype.childAt = function (index) {
                if (index !== 0) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }

                return this.item;
            };

            SingletonSeparatedSyntaxList.prototype.nonSeparatorAt = function (index) {
                if (index !== 0) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }

                return this.item;
            };

            SingletonSeparatedSyntaxList.prototype.separatorAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            };

            SingletonSeparatedSyntaxList.prototype.collectTextElements = function (elements) {
                this.item.collectTextElements(elements);
            };

            SingletonSeparatedSyntaxList.prototype.firstToken = function () {
                return this.item.firstToken();
            };

            SingletonSeparatedSyntaxList.prototype.lastToken = function () {
                return this.item.lastToken();
            };

            SingletonSeparatedSyntaxList.prototype.fullWidth = function () {
                return this.item.fullWidth();
            };

            SingletonSeparatedSyntaxList.prototype.width = function () {
                return this.item.width();
            };

            SingletonSeparatedSyntaxList.prototype.fullText = function () {
                return this.item.fullText();
            };

            SingletonSeparatedSyntaxList.prototype.leadingTrivia = function () {
                return this.item.leadingTrivia();
            };

            SingletonSeparatedSyntaxList.prototype.trailingTrivia = function () {
                return this.item.trailingTrivia();
            };

            SingletonSeparatedSyntaxList.prototype.leadingTriviaWidth = function () {
                return this.item.leadingTriviaWidth();
            };

            SingletonSeparatedSyntaxList.prototype.trailingTriviaWidth = function () {
                return this.item.trailingTriviaWidth();
            };

            SingletonSeparatedSyntaxList.prototype.isTypeScriptSpecific = function () {
                return this.item.isTypeScriptSpecific();
            };

            SingletonSeparatedSyntaxList.prototype.isIncrementallyUnusable = function () {
                return this.item.isIncrementallyUnusable();
            };

            SingletonSeparatedSyntaxList.prototype.findTokenInternal = function (parent, position, fullStart) {
                return (this.item).findTokenInternal(new TypeScript.PositionedSeparatedList(parent, this, fullStart), position, fullStart);
            };

            SingletonSeparatedSyntaxList.prototype.insertChildrenInto = function (array, index) {
                array.splice(index, 0, this.item);
            };
            return SingletonSeparatedSyntaxList;
        })();

        var NormalSeparatedSyntaxList = (function () {
            function NormalSeparatedSyntaxList(elements) {
                this._data = 0;
                this.elements = elements;
            }
            NormalSeparatedSyntaxList.prototype.kind = function () {
                return 2 /* SeparatedList */;
            };

            NormalSeparatedSyntaxList.prototype.isToken = function () {
                return false;
            };
            NormalSeparatedSyntaxList.prototype.isNode = function () {
                return false;
            };
            NormalSeparatedSyntaxList.prototype.isList = function () {
                return false;
            };
            NormalSeparatedSyntaxList.prototype.isSeparatedList = function () {
                return true;
            };
            NormalSeparatedSyntaxList.prototype.toJSON = function (key) {
                return this.elements;
            };

            NormalSeparatedSyntaxList.prototype.childCount = function () {
                return this.elements.length;
            };
            NormalSeparatedSyntaxList.prototype.nonSeparatorCount = function () {
                return TypeScript.IntegerUtilities.integerDivide(this.elements.length + 1, 2);
            };
            NormalSeparatedSyntaxList.prototype.separatorCount = function () {
                return TypeScript.IntegerUtilities.integerDivide(this.elements.length, 2);
            };

            NormalSeparatedSyntaxList.prototype.toArray = function () {
                return this.elements.slice(0);
            };

            NormalSeparatedSyntaxList.prototype.toNonSeparatorArray = function () {
                var result = [];
                for (var i = 0, n = this.nonSeparatorCount(); i < n; i++) {
                    result.push(this.nonSeparatorAt(i));
                }

                return result;
            };

            NormalSeparatedSyntaxList.prototype.childAt = function (index) {
                if (index < 0 || index >= this.elements.length) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }

                return this.elements[index];
            };

            NormalSeparatedSyntaxList.prototype.nonSeparatorAt = function (index) {
                var value = index * 2;
                if (value < 0 || value >= this.elements.length) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }

                return this.elements[value];
            };

            NormalSeparatedSyntaxList.prototype.separatorAt = function (index) {
                var value = index * 2 + 1;
                if (value < 0 || value >= this.elements.length) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }

                return this.elements[value];
            };

            NormalSeparatedSyntaxList.prototype.firstToken = function () {
                var token;
                for (var i = 0, n = this.elements.length; i < n; i++) {
                    if (i % 2 === 0) {
                        var nodeOrToken = this.elements[i];
                        token = nodeOrToken.firstToken();
                        if (token !== null) {
                            return token;
                        }
                    } else {
                        token = this.elements[i];
                        if (token.width() > 0) {
                            return token;
                        }
                    }
                }

                return null;
            };

            NormalSeparatedSyntaxList.prototype.lastToken = function () {
                var token;
                for (var i = this.elements.length - 1; i >= 0; i--) {
                    if (i % 2 === 0) {
                        var nodeOrToken = this.elements[i];
                        token = nodeOrToken.lastToken();
                        if (token !== null) {
                            return token;
                        }
                    } else {
                        token = this.elements[i];
                        if (token.width() > 0) {
                            return token;
                        }
                    }
                }

                return null;
            };

            NormalSeparatedSyntaxList.prototype.fullText = function () {
                var elements = [];
                this.collectTextElements(elements);
                return elements.join("");
            };

            NormalSeparatedSyntaxList.prototype.isTypeScriptSpecific = function () {
                for (var i = 0, n = this.nonSeparatorCount(); i < n; i++) {
                    if (this.nonSeparatorAt(i).isTypeScriptSpecific()) {
                        return true;
                    }
                }

                return false;
            };

            NormalSeparatedSyntaxList.prototype.isIncrementallyUnusable = function () {
                return (this.data() & 2 /* NodeIncrementallyUnusableMask */) !== 0;
            };

            NormalSeparatedSyntaxList.prototype.fullWidth = function () {
                return this.data() >>> 3 /* NodeFullWidthShift */;
            };

            NormalSeparatedSyntaxList.prototype.width = function () {
                var fullWidth = this.fullWidth();
                return fullWidth - this.leadingTriviaWidth() - this.trailingTriviaWidth();
            };

            NormalSeparatedSyntaxList.prototype.leadingTrivia = function () {
                return this.firstToken().leadingTrivia();
            };

            NormalSeparatedSyntaxList.prototype.trailingTrivia = function () {
                return this.lastToken().trailingTrivia();
            };

            NormalSeparatedSyntaxList.prototype.leadingTriviaWidth = function () {
                return this.firstToken().leadingTriviaWidth();
            };

            NormalSeparatedSyntaxList.prototype.trailingTriviaWidth = function () {
                return this.lastToken().trailingTriviaWidth();
            };

            NormalSeparatedSyntaxList.prototype.computeData = function () {
                var fullWidth = 0;
                var isIncrementallyUnusable = false;

                for (var i = 0, n = this.elements.length; i < n; i++) {
                    var element = this.elements[i];

                    var childWidth = element.fullWidth();
                    fullWidth += childWidth;

                    isIncrementallyUnusable = isIncrementallyUnusable || element.isIncrementallyUnusable();
                }

                return (fullWidth << 3 /* NodeFullWidthShift */) | (isIncrementallyUnusable ? 2 /* NodeIncrementallyUnusableMask */ : 0) | 1 /* NodeDataComputed */;
            };

            NormalSeparatedSyntaxList.prototype.data = function () {
                if ((this._data & 1 /* NodeDataComputed */) === 0) {
                    this._data = this.computeData();
                }

                return this._data;
            };

            NormalSeparatedSyntaxList.prototype.findTokenInternal = function (parent, position, fullStart) {
                parent = new TypeScript.PositionedSeparatedList(parent, this, fullStart);
                for (var i = 0, n = this.elements.length; i < n; i++) {
                    var element = this.elements[i];

                    var childWidth = element.fullWidth();
                    if (position < childWidth) {
                        return (element).findTokenInternal(parent, position, fullStart);
                    }

                    position -= childWidth;
                    fullStart += childWidth;
                }

                throw TypeScript.Errors.invalidOperation();
            };

            NormalSeparatedSyntaxList.prototype.collectTextElements = function (elements) {
                for (var i = 0, n = this.elements.length; i < n; i++) {
                    var element = this.elements[i];
                    element.collectTextElements(elements);
                }
            };

            NormalSeparatedSyntaxList.prototype.insertChildrenInto = function (array, index) {
                if (index === 0) {
                    array.unshift.apply(array, this.elements);
                } else {
                    array.splice.apply(array, [index, 0].concat(this.elements));
                }
            };
            return NormalSeparatedSyntaxList;
        })();

        function separatedList(nodes) {
            return separatedListAndValidate(nodes, false);
        }
        Syntax.separatedList = separatedList;

        function separatedListAndValidate(nodes, validate) {
            if (nodes === undefined || nodes === null || nodes.length === 0) {
                return Syntax.emptySeparatedList;
            }

            if (validate) {
                for (var i = 0; i < nodes.length; i++) {
                    var item = nodes[i];

                    if (i % 2 === 1) {
                    }
                }
            }

            if (nodes.length === 1) {
                return new SingletonSeparatedSyntaxList(nodes[0]);
            }

            return new NormalSeparatedSyntaxList(nodes);
        }
    })(TypeScript.Syntax || (TypeScript.Syntax = {}));
    var Syntax = TypeScript.Syntax;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SlidingWindow = (function () {
        function SlidingWindow(source, window, defaultValue, sourceLength) {
            if (typeof sourceLength === "undefined") { sourceLength = -1; }
            this.source = source;
            this.window = window;
            this.defaultValue = defaultValue;
            this.sourceLength = sourceLength;
            this.windowCount = 0;
            this.windowAbsoluteStartIndex = 0;
            this.currentRelativeItemIndex = 0;
            this._pinCount = 0;
            this.firstPinnedAbsoluteIndex = -1;
        }
        SlidingWindow.prototype.windowAbsoluteEndIndex = function () {
            return this.windowAbsoluteStartIndex + this.windowCount;
        };

        SlidingWindow.prototype.addMoreItemsToWindow = function (argument) {
            if (this.sourceLength >= 0 && this.absoluteIndex() >= this.sourceLength) {
                return false;
            }

            if (this.windowCount >= this.window.length) {
                this.tryShiftOrGrowWindow();
            }

            var spaceAvailable = this.window.length - this.windowCount;
            var amountFetched = this.source.fetchMoreItems(argument, this.windowAbsoluteEndIndex(), this.window, this.windowCount, spaceAvailable);

            this.windowCount += amountFetched;
            return amountFetched > 0;
        };

        SlidingWindow.prototype.tryShiftOrGrowWindow = function () {
            var currentIndexIsPastWindowHalfwayPoint = this.currentRelativeItemIndex > (this.window.length >>> 1);

            var isAllowedToShift = this.firstPinnedAbsoluteIndex === -1 || this.firstPinnedAbsoluteIndex > this.windowAbsoluteStartIndex;

            if (currentIndexIsPastWindowHalfwayPoint && isAllowedToShift) {
                var shiftStartIndex = this.firstPinnedAbsoluteIndex === -1 ? this.currentRelativeItemIndex : this.firstPinnedAbsoluteIndex - this.windowAbsoluteStartIndex;

                var shiftCount = this.windowCount - shiftStartIndex;

                if (shiftCount > 0) {
                    TypeScript.ArrayUtilities.copy(this.window, shiftStartIndex, this.window, 0, shiftCount);
                }

                this.windowAbsoluteStartIndex += shiftStartIndex;

                this.windowCount -= shiftStartIndex;

                this.currentRelativeItemIndex -= shiftStartIndex;
            } else {
                TypeScript.ArrayUtilities.grow(this.window, this.window.length * 2, this.defaultValue);
            }
        };

        SlidingWindow.prototype.absoluteIndex = function () {
            return this.windowAbsoluteStartIndex + this.currentRelativeItemIndex;
        };

        SlidingWindow.prototype.isAtEndOfSource = function () {
            return this.absoluteIndex() >= this.sourceLength;
        };

        SlidingWindow.prototype.getAndPinAbsoluteIndex = function () {
            var absoluteIndex = this.absoluteIndex();
            var pinCount = this._pinCount++;
            if (pinCount === 0) {
                this.firstPinnedAbsoluteIndex = absoluteIndex;
            }

            return absoluteIndex;
        };

        SlidingWindow.prototype.releaseAndUnpinAbsoluteIndex = function (absoluteIndex) {
            this._pinCount--;
            if (this._pinCount === 0) {
                this.firstPinnedAbsoluteIndex = -1;
            }
        };

        SlidingWindow.prototype.rewindToPinnedIndex = function (absoluteIndex) {
            var relativeIndex = absoluteIndex - this.windowAbsoluteStartIndex;

            this.currentRelativeItemIndex = relativeIndex;
        };

        SlidingWindow.prototype.currentItem = function (argument) {
            if (this.currentRelativeItemIndex >= this.windowCount) {
                if (!this.addMoreItemsToWindow(argument)) {
                    return this.defaultValue;
                }
            }

            return this.window[this.currentRelativeItemIndex];
        };

        SlidingWindow.prototype.peekItemN = function (n) {
            while (this.currentRelativeItemIndex + n >= this.windowCount) {
                if (!this.addMoreItemsToWindow(null)) {
                    return this.defaultValue;
                }
            }

            return this.window[this.currentRelativeItemIndex + n];
        };

        SlidingWindow.prototype.moveToNextItem = function () {
            this.currentRelativeItemIndex++;
        };

        SlidingWindow.prototype.disgardAllItemsFromCurrentIndexOnwards = function () {
            this.windowCount = this.currentRelativeItemIndex;
        };

        SlidingWindow.prototype.setAbsoluteIndex = function (absoluteIndex) {
            if (this.absoluteIndex() === absoluteIndex) {
                return;
            }

            if (this._pinCount > 0) {
            }

            if (absoluteIndex >= this.windowAbsoluteStartIndex && absoluteIndex < this.windowAbsoluteEndIndex()) {
                this.currentRelativeItemIndex = (absoluteIndex - this.windowAbsoluteStartIndex);
            } else {
                this.windowAbsoluteStartIndex = absoluteIndex;

                this.windowCount = 0;

                this.currentRelativeItemIndex = 0;
            }
        };

        SlidingWindow.prototype.pinCount = function () {
            return this._pinCount;
        };
        return SlidingWindow;
    })();
    TypeScript.SlidingWindow = SlidingWindow;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Syntax) {
        function emptySourceUnit() {
            return TypeScript.Syntax.normalModeFactory.sourceUnit(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(10 /* EndOfFileToken */, { text: "" }));
        }
        Syntax.emptySourceUnit = emptySourceUnit;

        function getStandaloneExpression(positionedToken) {
            var token = positionedToken.token();
            if (positionedToken !== null && positionedToken.kind() === 11 /* IdentifierName */) {
                var parentPositionedNode = positionedToken.containingNode();
                var parentNode = parentPositionedNode.node();

                if (parentNode.kind() === 121 /* QualifiedName */ && (parentNode).right === token) {
                    return parentPositionedNode;
                } else if (parentNode.kind() === 211 /* MemberAccessExpression */ && (parentNode).name === token) {
                    return parentPositionedNode;
                }
            }

            return positionedToken;
        }
        Syntax.getStandaloneExpression = getStandaloneExpression;

        function isInModuleOrTypeContext(positionedToken) {
            if (positionedToken !== null) {
                var positionedNodeOrToken = TypeScript.Syntax.getStandaloneExpression(positionedToken);
                var parent = positionedNodeOrToken.containingNode();

                if (parent !== null) {
                    switch (parent.kind()) {
                        case 246 /* ModuleNameModuleReference */:
                            return true;
                        case 121 /* QualifiedName */:
                            return true;
                        default:
                            return isInTypeOnlyContext(positionedToken);
                    }
                }
            }

            return false;
        }
        Syntax.isInModuleOrTypeContext = isInModuleOrTypeContext;

        function isInTypeOnlyContext(positionedToken) {
            var positionedNodeOrToken = TypeScript.Syntax.getStandaloneExpression(positionedToken);
            var positionedParent = positionedNodeOrToken.containingNode();

            var parent = positionedParent.node();
            var nodeOrToken = positionedNodeOrToken.nodeOrToken();

            if (parent !== null) {
                switch (parent.kind()) {
                    case 124 /* ArrayType */:
                        return (parent).type === nodeOrToken;
                    case 219 /* CastExpression */:
                        return (parent).type === nodeOrToken;
                    case 244 /* TypeAnnotation */:
                    case 229 /* HeritageClause */:
                    case 227 /* TypeArgumentList */:
                        return true;
                }
            }

            return false;
        }
        Syntax.isInTypeOnlyContext = isInTypeOnlyContext;

        function childOffset(parent, child) {
            var offset = 0;
            for (var i = 0, n = parent.childCount(); i < n; i++) {
                var current = parent.childAt(i);
                if (current === child) {
                    return offset;
                }

                if (current !== null) {
                    offset += current.fullWidth();
                }
            }

            throw TypeScript.Errors.invalidOperation();
        }
        Syntax.childOffset = childOffset;

        function childOffsetAt(parent, index) {
            var offset = 0;
            for (var i = 0; i < index; i++) {
                var current = parent.childAt(i);
                if (current !== null) {
                    offset += current.fullWidth();
                }
            }

            return offset;
        }
        Syntax.childOffsetAt = childOffsetAt;

        function childIndex(parent, child) {
            for (var i = 0, n = parent.childCount(); i < n; i++) {
                var current = parent.childAt(i);
                if (current === child) {
                    return i;
                }
            }

            throw TypeScript.Errors.invalidOperation();
        }
        Syntax.childIndex = childIndex;

        function nodeStructuralEquals(node1, node2) {
            if (node1 === null) {
                return node2 === null;
            }

            return node1.structuralEquals(node2);
        }
        Syntax.nodeStructuralEquals = nodeStructuralEquals;

        function nodeOrTokenStructuralEquals(node1, node2) {
            if (node1 === node2) {
                return true;
            }

            if (node1 === null || node2 === null) {
                return false;
            }

            if (node1.isToken()) {
                return node2.isToken() ? tokenStructuralEquals(node1, node2) : false;
            }

            return node2.isNode() ? nodeStructuralEquals(node1, node2) : false;
        }
        Syntax.nodeOrTokenStructuralEquals = nodeOrTokenStructuralEquals;

        function tokenStructuralEquals(token1, token2) {
            if (token1 === token2) {
                return true;
            }

            if (token1 === null || token2 === null) {
                return false;
            }

            return token1.kind() === token2.kind() && token1.width() === token2.width() && token1.fullWidth() === token2.fullWidth() && token1.text() === token2.text() && TypeScript.Syntax.triviaListStructuralEquals(token1.leadingTrivia(), token2.leadingTrivia()) && TypeScript.Syntax.triviaListStructuralEquals(token1.trailingTrivia(), token2.trailingTrivia());
        }
        Syntax.tokenStructuralEquals = tokenStructuralEquals;

        function triviaListStructuralEquals(triviaList1, triviaList2) {
            if (triviaList1.count() !== triviaList2.count()) {
                return false;
            }

            for (var i = 0, n = triviaList1.count(); i < n; i++) {
                if (!TypeScript.Syntax.triviaStructuralEquals(triviaList1.syntaxTriviaAt(i), triviaList2.syntaxTriviaAt(i))) {
                    return false;
                }
            }

            return true;
        }
        Syntax.triviaListStructuralEquals = triviaListStructuralEquals;

        function triviaStructuralEquals(trivia1, trivia2) {
            return trivia1.kind() === trivia2.kind() && trivia1.fullWidth() === trivia2.fullWidth() && trivia1.fullText() === trivia2.fullText();
        }
        Syntax.triviaStructuralEquals = triviaStructuralEquals;

        function listStructuralEquals(list1, list2) {
            if (list1.childCount() !== list2.childCount()) {
                return false;
            }

            for (var i = 0, n = list1.childCount(); i < n; i++) {
                var child1 = list1.childAt(i);
                var child2 = list2.childAt(i);

                if (!TypeScript.Syntax.nodeOrTokenStructuralEquals(child1, child2)) {
                    return false;
                }
            }

            return true;
        }
        Syntax.listStructuralEquals = listStructuralEquals;

        function separatedListStructuralEquals(list1, list2) {
            if (list1.childCount() !== list2.childCount()) {
                return false;
            }

            for (var i = 0, n = list1.childCount(); i < n; i++) {
                var element1 = list1.childAt(i);
                var element2 = list2.childAt(i);
                if (!TypeScript.Syntax.nodeOrTokenStructuralEquals(element1, element2)) {
                    return false;
                }
            }

            return true;
        }
        Syntax.separatedListStructuralEquals = separatedListStructuralEquals;

        function elementStructuralEquals(element1, element2) {
            if (element1 === element2) {
                return true;
            }

            if (element1 === null || element2 === null) {
                return false;
            }

            if (element2.kind() !== element2.kind()) {
                return false;
            }

            if (element1.isToken()) {
                return tokenStructuralEquals(element1, element2);
            } else if (element1.isNode()) {
                return nodeStructuralEquals(element1, element2);
            } else if (element1.isList()) {
                return listStructuralEquals(element1, element2);
            } else if (element1.isSeparatedList()) {
                return separatedListStructuralEquals(element1, element2);
            }

            throw TypeScript.Errors.invalidOperation();
        }
        Syntax.elementStructuralEquals = elementStructuralEquals;

        function identifierName(text, info) {
            if (typeof info === "undefined") { info = null; }
            return Syntax.identifier(text);
        }
        Syntax.identifierName = identifierName;

        function trueExpression() {
            return TypeScript.Syntax.token(37 /* TrueKeyword */);
        }
        Syntax.trueExpression = trueExpression;

        function falseExpression() {
            return TypeScript.Syntax.token(24 /* FalseKeyword */);
        }
        Syntax.falseExpression = falseExpression;

        function numericLiteralExpression(text) {
            return TypeScript.Syntax.token(13 /* NumericLiteral */, { text: text });
        }
        Syntax.numericLiteralExpression = numericLiteralExpression;

        function stringLiteralExpression(text) {
            return TypeScript.Syntax.token(14 /* StringLiteral */, { text: text });
        }
        Syntax.stringLiteralExpression = stringLiteralExpression;

        function isSuperInvocationExpression(node) {
            return node.kind() === 212 /* InvocationExpression */ && (node).expression.kind() === 50 /* SuperKeyword */;
        }
        Syntax.isSuperInvocationExpression = isSuperInvocationExpression;

        function isSuperInvocationExpressionStatement(node) {
            return node.kind() === 148 /* ExpressionStatement */ && isSuperInvocationExpression((node).expression);
        }
        Syntax.isSuperInvocationExpressionStatement = isSuperInvocationExpressionStatement;

        function isSuperMemberAccessExpression(node) {
            return node.kind() === 211 /* MemberAccessExpression */ && (node).expression.kind() === 50 /* SuperKeyword */;
        }
        Syntax.isSuperMemberAccessExpression = isSuperMemberAccessExpression;

        function isSuperMemberAccessInvocationExpression(node) {
            return node.kind() === 212 /* InvocationExpression */ && isSuperMemberAccessExpression((node).expression);
        }
        Syntax.isSuperMemberAccessInvocationExpression = isSuperMemberAccessInvocationExpression;

        function assignmentExpression(left, token, right) {
            return TypeScript.Syntax.normalModeFactory.binaryExpression(173 /* AssignmentExpression */, left, token, right);
        }
        Syntax.assignmentExpression = assignmentExpression;

        function nodeHasSkippedOrMissingTokens(node) {
            for (var i = 0; i < node.childCount(); i++) {
                var child = node.childAt(i);
                if (child !== null && child.isToken()) {
                    var token = child;

                    if (token.hasSkippedToken() || (token.width() === 0 && token.kind() !== 10 /* EndOfFileToken */)) {
                        return true;
                    }
                }
            }
            return false;
        }
        Syntax.nodeHasSkippedOrMissingTokens = nodeHasSkippedOrMissingTokens;

        function isUnterminatedStringLiteral(token) {
            if (token && token.kind() === 14 /* StringLiteral */) {
                var text = token.text();
                return text.length < 2 || text.charCodeAt(text.length - 1) !== text.charCodeAt(0);
            }

            return false;
        }
        Syntax.isUnterminatedStringLiteral = isUnterminatedStringLiteral;

        function isUnterminatedMultilineCommentTrivia(trivia) {
            if (trivia && trivia.kind() === 6 /* MultiLineCommentTrivia */) {
                var text = trivia.fullText();
                return text.length < 4 || text.substring(text.length - 2) !== "*/";
            }
            return false;
        }
        Syntax.isUnterminatedMultilineCommentTrivia = isUnterminatedMultilineCommentTrivia;

        function isEntirelyInsideCommentTrivia(trivia, fullStart, position) {
            if (trivia && trivia.isComment() && position > fullStart) {
                var end = fullStart + trivia.fullWidth();
                if (position < end) {
                    return true;
                } else if (position === end) {
                    return trivia.kind() === 7 /* SingleLineCommentTrivia */ || isUnterminatedMultilineCommentTrivia(trivia);
                }
            }

            return false;
        }
        Syntax.isEntirelyInsideCommentTrivia = isEntirelyInsideCommentTrivia;

        function isEntirelyInsideComment(sourceUnit, position) {
            var positionedToken = sourceUnit.findToken(position);
            var fullStart = positionedToken.fullStart();
            var triviaList = null;
            var lastTriviaBeforeToken = null;

            if (positionedToken.kind() === 10 /* EndOfFileToken */) {
                if (positionedToken.token().hasLeadingTrivia()) {
                    triviaList = positionedToken.token().leadingTrivia();
                } else {
                    positionedToken = positionedToken.previousToken();
                    if (positionedToken) {
                        if (positionedToken && positionedToken.token().hasTrailingTrivia()) {
                            triviaList = positionedToken.token().trailingTrivia();
                            fullStart = positionedToken.end();
                        }
                    }
                }
            } else {
                if (position <= (fullStart + positionedToken.token().leadingTriviaWidth())) {
                    triviaList = positionedToken.token().leadingTrivia();
                } else if (position >= (fullStart + positionedToken.token().width())) {
                    triviaList = positionedToken.token().trailingTrivia();
                    fullStart = positionedToken.end();
                }
            }

            if (triviaList) {
                for (var i = 0, n = triviaList.count(); i < n; i++) {
                    var trivia = triviaList.syntaxTriviaAt(i);
                    if (position <= fullStart) {
                        break;
                    } else if (position <= fullStart + trivia.fullWidth() && trivia.isComment()) {
                        lastTriviaBeforeToken = trivia;
                        break;
                    }

                    fullStart += trivia.fullWidth();
                }
            }

            return lastTriviaBeforeToken && isEntirelyInsideCommentTrivia(lastTriviaBeforeToken, fullStart, position);
        }
        Syntax.isEntirelyInsideComment = isEntirelyInsideComment;

        function isEntirelyInStringOrRegularExpressionLiteral(sourceUnit, position) {
            var positionedToken = sourceUnit.findToken(position);

            if (positionedToken) {
                if (positionedToken.kind() === 10 /* EndOfFileToken */) {
                    positionedToken = positionedToken.previousToken();
                    return positionedToken && positionedToken.token().trailingTriviaWidth() === 0 && isUnterminatedStringLiteral(positionedToken.token());
                } else if (position > positionedToken.start()) {
                    return (position < positionedToken.end() && (positionedToken.kind() === 14 /* StringLiteral */ || positionedToken.kind() === 12 /* RegularExpressionLiteral */)) || (position <= positionedToken.end() && isUnterminatedStringLiteral(positionedToken.token()));
                }
            }

            return false;
        }
        Syntax.isEntirelyInStringOrRegularExpressionLiteral = isEntirelyInStringOrRegularExpressionLiteral;

        function findSkippedTokenInTriviaList(positionedToken, position, lookInLeadingTriviaList) {
            var triviaList = null;
            var fullStart;

            if (lookInLeadingTriviaList) {
                triviaList = positionedToken.token().leadingTrivia();
                fullStart = positionedToken.fullStart();
            } else {
                triviaList = positionedToken.token().trailingTrivia();
                fullStart = positionedToken.end();
            }

            if (triviaList && triviaList.hasSkippedToken()) {
                for (var i = 0, n = triviaList.count(); i < n; i++) {
                    var trivia = triviaList.syntaxTriviaAt(i);
                    var triviaWidth = trivia.fullWidth();

                    if (trivia.isSkippedToken() && position >= fullStart && position <= fullStart + triviaWidth) {
                        return new TypeScript.PositionedSkippedToken(positionedToken, trivia.skippedToken(), fullStart);
                    }

                    fullStart += triviaWidth;
                }
            }

            return null;
        }

        function findSkippedTokenOnLeftInTriviaList(positionedToken, position, lookInLeadingTriviaList) {
            var triviaList = null;
            var fullEnd;

            if (lookInLeadingTriviaList) {
                triviaList = positionedToken.token().leadingTrivia();
                fullEnd = positionedToken.fullStart() + triviaList.fullWidth();
            } else {
                triviaList = positionedToken.token().trailingTrivia();
                fullEnd = positionedToken.fullEnd();
            }

            if (triviaList && triviaList.hasSkippedToken()) {
                for (var i = triviaList.count() - 1; i >= 0; i--) {
                    var trivia = triviaList.syntaxTriviaAt(i);
                    var triviaWidth = trivia.fullWidth();

                    if (trivia.isSkippedToken() && position >= fullEnd) {
                        return new TypeScript.PositionedSkippedToken(positionedToken, trivia.skippedToken(), fullEnd - triviaWidth);
                    }

                    fullEnd -= triviaWidth;
                }
            }

            return null;
        }

        function findSkippedTokenInLeadingTriviaList(positionedToken, position) {
            return findSkippedTokenInTriviaList(positionedToken, position, true);
        }
        Syntax.findSkippedTokenInLeadingTriviaList = findSkippedTokenInLeadingTriviaList;

        function findSkippedTokenInTrailingTriviaList(positionedToken, position) {
            return findSkippedTokenInTriviaList(positionedToken, position, false);
        }
        Syntax.findSkippedTokenInTrailingTriviaList = findSkippedTokenInTrailingTriviaList;

        function findSkippedTokenInPositionedToken(positionedToken, position) {
            var positionInLeadingTriviaList = (position < positionedToken.start());
            return findSkippedTokenInTriviaList(positionedToken, position, positionInLeadingTriviaList);
        }
        Syntax.findSkippedTokenInPositionedToken = findSkippedTokenInPositionedToken;

        function findSkippedTokenOnLeft(positionedToken, position) {
            var positionInLeadingTriviaList = (position < positionedToken.start());
            return findSkippedTokenOnLeftInTriviaList(positionedToken, position, positionInLeadingTriviaList);
        }
        Syntax.findSkippedTokenOnLeft = findSkippedTokenOnLeft;

        function getAncestorOfKind(positionedToken, kind) {
            while (positionedToken && positionedToken.parent()) {
                if (positionedToken.parent().kind() === kind) {
                    return positionedToken.parent();
                }

                positionedToken = positionedToken.parent();
            }

            return null;
        }
        Syntax.getAncestorOfKind = getAncestorOfKind;

        function hasAncestorOfKind(positionedToken, kind) {
            return TypeScript.Syntax.getAncestorOfKind(positionedToken, kind) !== null;
        }
        Syntax.hasAncestorOfKind = hasAncestorOfKind;

        function isIntegerLiteral(expression) {
            if (expression) {
                switch (expression.kind()) {
                    case 163 /* PlusExpression */:
                    case 164 /* NegateExpression */:
                        expression = (expression).operand;
                        return isInteger((expression).text());

                    case 13 /* NumericLiteral */:
                        var text = (expression).text();
                        return isInteger(text) || isHexInteger(text);
                }
            }

            return false;
        }
        Syntax.isIntegerLiteral = isIntegerLiteral;

        function isInteger(text) {
            return /^[0-9]+$/.test(text);
        }

        function isHexInteger(text) {
            return /^0(x|X)[0-9a-fA-F]+$/.test(text);
        }
        Syntax.isHexInteger = isHexInteger;
    })(TypeScript.Syntax || (TypeScript.Syntax = {}));
    var Syntax = TypeScript.Syntax;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Syntax) {
        var NormalModeFactory = (function () {
            function NormalModeFactory() {
            }
            NormalModeFactory.prototype.sourceUnit = function (moduleElements, endOfFileToken) {
                return new TypeScript.SourceUnitSyntax(moduleElements, endOfFileToken, false);
            };
            NormalModeFactory.prototype.externalModuleReference = function (requireKeyword, openParenToken, stringLiteral, closeParenToken) {
                return new TypeScript.ExternalModuleReferenceSyntax(requireKeyword, openParenToken, stringLiteral, closeParenToken, false);
            };
            NormalModeFactory.prototype.moduleNameModuleReference = function (moduleName) {
                return new TypeScript.ModuleNameModuleReferenceSyntax(moduleName, false);
            };
            NormalModeFactory.prototype.importDeclaration = function (modifiers, importKeyword, identifier, equalsToken, moduleReference, semicolonToken) {
                return new TypeScript.ImportDeclarationSyntax(modifiers, importKeyword, identifier, equalsToken, moduleReference, semicolonToken, false);
            };
            NormalModeFactory.prototype.exportAssignment = function (exportKeyword, equalsToken, identifier, semicolonToken) {
                return new TypeScript.ExportAssignmentSyntax(exportKeyword, equalsToken, identifier, semicolonToken, false);
            };
            NormalModeFactory.prototype.classDeclaration = function (modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken) {
                return new TypeScript.ClassDeclarationSyntax(modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken, false);
            };
            NormalModeFactory.prototype.interfaceDeclaration = function (modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, body) {
                return new TypeScript.InterfaceDeclarationSyntax(modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, body, false);
            };
            NormalModeFactory.prototype.heritageClause = function (extendsOrImplementsKeyword, typeNames) {
                return new TypeScript.HeritageClauseSyntax(extendsOrImplementsKeyword, typeNames, false);
            };
            NormalModeFactory.prototype.moduleDeclaration = function (modifiers, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken) {
                return new TypeScript.ModuleDeclarationSyntax(modifiers, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken, false);
            };
            NormalModeFactory.prototype.functionDeclaration = function (modifiers, functionKeyword, identifier, callSignature, block, semicolonToken) {
                return new TypeScript.FunctionDeclarationSyntax(modifiers, functionKeyword, identifier, callSignature, block, semicolonToken, false);
            };
            NormalModeFactory.prototype.variableStatement = function (modifiers, variableDeclaration, semicolonToken) {
                return new TypeScript.VariableStatementSyntax(modifiers, variableDeclaration, semicolonToken, false);
            };
            NormalModeFactory.prototype.variableDeclaration = function (varKeyword, variableDeclarators) {
                return new TypeScript.VariableDeclarationSyntax(varKeyword, variableDeclarators, false);
            };
            NormalModeFactory.prototype.variableDeclarator = function (identifier, typeAnnotation, equalsValueClause) {
                return new TypeScript.VariableDeclaratorSyntax(identifier, typeAnnotation, equalsValueClause, false);
            };
            NormalModeFactory.prototype.equalsValueClause = function (equalsToken, value) {
                return new TypeScript.EqualsValueClauseSyntax(equalsToken, value, false);
            };
            NormalModeFactory.prototype.prefixUnaryExpression = function (kind, operatorToken, operand) {
                return new TypeScript.PrefixUnaryExpressionSyntax(kind, operatorToken, operand, false);
            };
            NormalModeFactory.prototype.arrayLiteralExpression = function (openBracketToken, expressions, closeBracketToken) {
                return new TypeScript.ArrayLiteralExpressionSyntax(openBracketToken, expressions, closeBracketToken, false);
            };
            NormalModeFactory.prototype.omittedExpression = function () {
                return new TypeScript.OmittedExpressionSyntax(false);
            };
            NormalModeFactory.prototype.parenthesizedExpression = function (openParenToken, expression, closeParenToken) {
                return new TypeScript.ParenthesizedExpressionSyntax(openParenToken, expression, closeParenToken, false);
            };
            NormalModeFactory.prototype.simpleArrowFunctionExpression = function (identifier, equalsGreaterThanToken, body) {
                return new TypeScript.SimpleArrowFunctionExpressionSyntax(identifier, equalsGreaterThanToken, body, false);
            };
            NormalModeFactory.prototype.parenthesizedArrowFunctionExpression = function (callSignature, equalsGreaterThanToken, body) {
                return new TypeScript.ParenthesizedArrowFunctionExpressionSyntax(callSignature, equalsGreaterThanToken, body, false);
            };
            NormalModeFactory.prototype.qualifiedName = function (left, dotToken, right) {
                return new TypeScript.QualifiedNameSyntax(left, dotToken, right, false);
            };
            NormalModeFactory.prototype.typeArgumentList = function (lessThanToken, typeArguments, greaterThanToken) {
                return new TypeScript.TypeArgumentListSyntax(lessThanToken, typeArguments, greaterThanToken, false);
            };
            NormalModeFactory.prototype.constructorType = function (newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type) {
                return new TypeScript.ConstructorTypeSyntax(newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type, false);
            };
            NormalModeFactory.prototype.functionType = function (typeParameterList, parameterList, equalsGreaterThanToken, type) {
                return new TypeScript.FunctionTypeSyntax(typeParameterList, parameterList, equalsGreaterThanToken, type, false);
            };
            NormalModeFactory.prototype.objectType = function (openBraceToken, typeMembers, closeBraceToken) {
                return new TypeScript.ObjectTypeSyntax(openBraceToken, typeMembers, closeBraceToken, false);
            };
            NormalModeFactory.prototype.arrayType = function (type, openBracketToken, closeBracketToken) {
                return new TypeScript.ArrayTypeSyntax(type, openBracketToken, closeBracketToken, false);
            };
            NormalModeFactory.prototype.genericType = function (name, typeArgumentList) {
                return new TypeScript.GenericTypeSyntax(name, typeArgumentList, false);
            };
            NormalModeFactory.prototype.typeQuery = function (typeOfKeyword, name) {
                return new TypeScript.TypeQuerySyntax(typeOfKeyword, name, false);
            };
            NormalModeFactory.prototype.typeAnnotation = function (colonToken, type) {
                return new TypeScript.TypeAnnotationSyntax(colonToken, type, false);
            };
            NormalModeFactory.prototype.block = function (openBraceToken, statements, closeBraceToken) {
                return new TypeScript.BlockSyntax(openBraceToken, statements, closeBraceToken, false);
            };
            NormalModeFactory.prototype.parameter = function (dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause) {
                return new TypeScript.ParameterSyntax(dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause, false);
            };
            NormalModeFactory.prototype.memberAccessExpression = function (expression, dotToken, name) {
                return new TypeScript.MemberAccessExpressionSyntax(expression, dotToken, name, false);
            };
            NormalModeFactory.prototype.postfixUnaryExpression = function (kind, operand, operatorToken) {
                return new TypeScript.PostfixUnaryExpressionSyntax(kind, operand, operatorToken, false);
            };
            NormalModeFactory.prototype.elementAccessExpression = function (expression, openBracketToken, argumentExpression, closeBracketToken) {
                return new TypeScript.ElementAccessExpressionSyntax(expression, openBracketToken, argumentExpression, closeBracketToken, false);
            };
            NormalModeFactory.prototype.invocationExpression = function (expression, argumentList) {
                return new TypeScript.InvocationExpressionSyntax(expression, argumentList, false);
            };
            NormalModeFactory.prototype.argumentList = function (typeArgumentList, openParenToken, _arguments, closeParenToken) {
                return new TypeScript.ArgumentListSyntax(typeArgumentList, openParenToken, _arguments, closeParenToken, false);
            };
            NormalModeFactory.prototype.binaryExpression = function (kind, left, operatorToken, right) {
                return new TypeScript.BinaryExpressionSyntax(kind, left, operatorToken, right, false);
            };
            NormalModeFactory.prototype.conditionalExpression = function (condition, questionToken, whenTrue, colonToken, whenFalse) {
                return new TypeScript.ConditionalExpressionSyntax(condition, questionToken, whenTrue, colonToken, whenFalse, false);
            };
            NormalModeFactory.prototype.constructSignature = function (newKeyword, callSignature) {
                return new TypeScript.ConstructSignatureSyntax(newKeyword, callSignature, false);
            };
            NormalModeFactory.prototype.methodSignature = function (propertyName, questionToken, callSignature) {
                return new TypeScript.MethodSignatureSyntax(propertyName, questionToken, callSignature, false);
            };
            NormalModeFactory.prototype.indexSignature = function (openBracketToken, parameter, closeBracketToken, typeAnnotation) {
                return new TypeScript.IndexSignatureSyntax(openBracketToken, parameter, closeBracketToken, typeAnnotation, false);
            };
            NormalModeFactory.prototype.propertySignature = function (propertyName, questionToken, typeAnnotation) {
                return new TypeScript.PropertySignatureSyntax(propertyName, questionToken, typeAnnotation, false);
            };
            NormalModeFactory.prototype.callSignature = function (typeParameterList, parameterList, typeAnnotation) {
                return new TypeScript.CallSignatureSyntax(typeParameterList, parameterList, typeAnnotation, false);
            };
            NormalModeFactory.prototype.parameterList = function (openParenToken, parameters, closeParenToken) {
                return new TypeScript.ParameterListSyntax(openParenToken, parameters, closeParenToken, false);
            };
            NormalModeFactory.prototype.typeParameterList = function (lessThanToken, typeParameters, greaterThanToken) {
                return new TypeScript.TypeParameterListSyntax(lessThanToken, typeParameters, greaterThanToken, false);
            };
            NormalModeFactory.prototype.typeParameter = function (identifier, constraint) {
                return new TypeScript.TypeParameterSyntax(identifier, constraint, false);
            };
            NormalModeFactory.prototype.constraint = function (extendsKeyword, type) {
                return new TypeScript.ConstraintSyntax(extendsKeyword, type, false);
            };
            NormalModeFactory.prototype.elseClause = function (elseKeyword, statement) {
                return new TypeScript.ElseClauseSyntax(elseKeyword, statement, false);
            };
            NormalModeFactory.prototype.ifStatement = function (ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause) {
                return new TypeScript.IfStatementSyntax(ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause, false);
            };
            NormalModeFactory.prototype.expressionStatement = function (expression, semicolonToken) {
                return new TypeScript.ExpressionStatementSyntax(expression, semicolonToken, false);
            };
            NormalModeFactory.prototype.constructorDeclaration = function (constructorKeyword, parameterList, block, semicolonToken) {
                return new TypeScript.ConstructorDeclarationSyntax(constructorKeyword, parameterList, block, semicolonToken, false);
            };
            NormalModeFactory.prototype.memberFunctionDeclaration = function (modifiers, propertyName, callSignature, block, semicolonToken) {
                return new TypeScript.MemberFunctionDeclarationSyntax(modifiers, propertyName, callSignature, block, semicolonToken, false);
            };
            NormalModeFactory.prototype.getMemberAccessorDeclaration = function (modifiers, getKeyword, propertyName, parameterList, typeAnnotation, block) {
                return new TypeScript.GetMemberAccessorDeclarationSyntax(modifiers, getKeyword, propertyName, parameterList, typeAnnotation, block, false);
            };
            NormalModeFactory.prototype.setMemberAccessorDeclaration = function (modifiers, setKeyword, propertyName, parameterList, block) {
                return new TypeScript.SetMemberAccessorDeclarationSyntax(modifiers, setKeyword, propertyName, parameterList, block, false);
            };
            NormalModeFactory.prototype.memberVariableDeclaration = function (modifiers, variableDeclarator, semicolonToken) {
                return new TypeScript.MemberVariableDeclarationSyntax(modifiers, variableDeclarator, semicolonToken, false);
            };
            NormalModeFactory.prototype.throwStatement = function (throwKeyword, expression, semicolonToken) {
                return new TypeScript.ThrowStatementSyntax(throwKeyword, expression, semicolonToken, false);
            };
            NormalModeFactory.prototype.returnStatement = function (returnKeyword, expression, semicolonToken) {
                return new TypeScript.ReturnStatementSyntax(returnKeyword, expression, semicolonToken, false);
            };
            NormalModeFactory.prototype.objectCreationExpression = function (newKeyword, expression, argumentList) {
                return new TypeScript.ObjectCreationExpressionSyntax(newKeyword, expression, argumentList, false);
            };
            NormalModeFactory.prototype.switchStatement = function (switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken) {
                return new TypeScript.SwitchStatementSyntax(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken, false);
            };
            NormalModeFactory.prototype.caseSwitchClause = function (caseKeyword, expression, colonToken, statements) {
                return new TypeScript.CaseSwitchClauseSyntax(caseKeyword, expression, colonToken, statements, false);
            };
            NormalModeFactory.prototype.defaultSwitchClause = function (defaultKeyword, colonToken, statements) {
                return new TypeScript.DefaultSwitchClauseSyntax(defaultKeyword, colonToken, statements, false);
            };
            NormalModeFactory.prototype.breakStatement = function (breakKeyword, identifier, semicolonToken) {
                return new TypeScript.BreakStatementSyntax(breakKeyword, identifier, semicolonToken, false);
            };
            NormalModeFactory.prototype.continueStatement = function (continueKeyword, identifier, semicolonToken) {
                return new TypeScript.ContinueStatementSyntax(continueKeyword, identifier, semicolonToken, false);
            };
            NormalModeFactory.prototype.forStatement = function (forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement) {
                return new TypeScript.ForStatementSyntax(forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement, false);
            };
            NormalModeFactory.prototype.forInStatement = function (forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement) {
                return new TypeScript.ForInStatementSyntax(forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement, false);
            };
            NormalModeFactory.prototype.whileStatement = function (whileKeyword, openParenToken, condition, closeParenToken, statement) {
                return new TypeScript.WhileStatementSyntax(whileKeyword, openParenToken, condition, closeParenToken, statement, false);
            };
            NormalModeFactory.prototype.withStatement = function (withKeyword, openParenToken, condition, closeParenToken, statement) {
                return new TypeScript.WithStatementSyntax(withKeyword, openParenToken, condition, closeParenToken, statement, false);
            };
            NormalModeFactory.prototype.enumDeclaration = function (modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken) {
                return new TypeScript.EnumDeclarationSyntax(modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken, false);
            };
            NormalModeFactory.prototype.enumElement = function (propertyName, equalsValueClause) {
                return new TypeScript.EnumElementSyntax(propertyName, equalsValueClause, false);
            };
            NormalModeFactory.prototype.castExpression = function (lessThanToken, type, greaterThanToken, expression) {
                return new TypeScript.CastExpressionSyntax(lessThanToken, type, greaterThanToken, expression, false);
            };
            NormalModeFactory.prototype.objectLiteralExpression = function (openBraceToken, propertyAssignments, closeBraceToken) {
                return new TypeScript.ObjectLiteralExpressionSyntax(openBraceToken, propertyAssignments, closeBraceToken, false);
            };
            NormalModeFactory.prototype.simplePropertyAssignment = function (propertyName, colonToken, expression) {
                return new TypeScript.SimplePropertyAssignmentSyntax(propertyName, colonToken, expression, false);
            };
            NormalModeFactory.prototype.functionPropertyAssignment = function (propertyName, callSignature, block) {
                return new TypeScript.FunctionPropertyAssignmentSyntax(propertyName, callSignature, block, false);
            };
            NormalModeFactory.prototype.getAccessorPropertyAssignment = function (getKeyword, propertyName, openParenToken, closeParenToken, typeAnnotation, block) {
                return new TypeScript.GetAccessorPropertyAssignmentSyntax(getKeyword, propertyName, openParenToken, closeParenToken, typeAnnotation, block, false);
            };
            NormalModeFactory.prototype.setAccessorPropertyAssignment = function (setKeyword, propertyName, openParenToken, parameter, closeParenToken, block) {
                return new TypeScript.SetAccessorPropertyAssignmentSyntax(setKeyword, propertyName, openParenToken, parameter, closeParenToken, block, false);
            };
            NormalModeFactory.prototype.functionExpression = function (functionKeyword, identifier, callSignature, block) {
                return new TypeScript.FunctionExpressionSyntax(functionKeyword, identifier, callSignature, block, false);
            };
            NormalModeFactory.prototype.emptyStatement = function (semicolonToken) {
                return new TypeScript.EmptyStatementSyntax(semicolonToken, false);
            };
            NormalModeFactory.prototype.tryStatement = function (tryKeyword, block, catchClause, finallyClause) {
                return new TypeScript.TryStatementSyntax(tryKeyword, block, catchClause, finallyClause, false);
            };
            NormalModeFactory.prototype.catchClause = function (catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block) {
                return new TypeScript.CatchClauseSyntax(catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block, false);
            };
            NormalModeFactory.prototype.finallyClause = function (finallyKeyword, block) {
                return new TypeScript.FinallyClauseSyntax(finallyKeyword, block, false);
            };
            NormalModeFactory.prototype.labeledStatement = function (identifier, colonToken, statement) {
                return new TypeScript.LabeledStatementSyntax(identifier, colonToken, statement, false);
            };
            NormalModeFactory.prototype.doStatement = function (doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken) {
                return new TypeScript.DoStatementSyntax(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken, false);
            };
            NormalModeFactory.prototype.typeOfExpression = function (typeOfKeyword, expression) {
                return new TypeScript.TypeOfExpressionSyntax(typeOfKeyword, expression, false);
            };
            NormalModeFactory.prototype.deleteExpression = function (deleteKeyword, expression) {
                return new TypeScript.DeleteExpressionSyntax(deleteKeyword, expression, false);
            };
            NormalModeFactory.prototype.voidExpression = function (voidKeyword, expression) {
                return new TypeScript.VoidExpressionSyntax(voidKeyword, expression, false);
            };
            NormalModeFactory.prototype.debuggerStatement = function (debuggerKeyword, semicolonToken) {
                return new TypeScript.DebuggerStatementSyntax(debuggerKeyword, semicolonToken, false);
            };
            return NormalModeFactory;
        })();
        Syntax.NormalModeFactory = NormalModeFactory;

        var StrictModeFactory = (function () {
            function StrictModeFactory() {
            }
            StrictModeFactory.prototype.sourceUnit = function (moduleElements, endOfFileToken) {
                return new TypeScript.SourceUnitSyntax(moduleElements, endOfFileToken, true);
            };
            StrictModeFactory.prototype.externalModuleReference = function (requireKeyword, openParenToken, stringLiteral, closeParenToken) {
                return new TypeScript.ExternalModuleReferenceSyntax(requireKeyword, openParenToken, stringLiteral, closeParenToken, true);
            };
            StrictModeFactory.prototype.moduleNameModuleReference = function (moduleName) {
                return new TypeScript.ModuleNameModuleReferenceSyntax(moduleName, true);
            };
            StrictModeFactory.prototype.importDeclaration = function (modifiers, importKeyword, identifier, equalsToken, moduleReference, semicolonToken) {
                return new TypeScript.ImportDeclarationSyntax(modifiers, importKeyword, identifier, equalsToken, moduleReference, semicolonToken, true);
            };
            StrictModeFactory.prototype.exportAssignment = function (exportKeyword, equalsToken, identifier, semicolonToken) {
                return new TypeScript.ExportAssignmentSyntax(exportKeyword, equalsToken, identifier, semicolonToken, true);
            };
            StrictModeFactory.prototype.classDeclaration = function (modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken) {
                return new TypeScript.ClassDeclarationSyntax(modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken, true);
            };
            StrictModeFactory.prototype.interfaceDeclaration = function (modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, body) {
                return new TypeScript.InterfaceDeclarationSyntax(modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, body, true);
            };
            StrictModeFactory.prototype.heritageClause = function (extendsOrImplementsKeyword, typeNames) {
                return new TypeScript.HeritageClauseSyntax(extendsOrImplementsKeyword, typeNames, true);
            };
            StrictModeFactory.prototype.moduleDeclaration = function (modifiers, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken) {
                return new TypeScript.ModuleDeclarationSyntax(modifiers, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken, true);
            };
            StrictModeFactory.prototype.functionDeclaration = function (modifiers, functionKeyword, identifier, callSignature, block, semicolonToken) {
                return new TypeScript.FunctionDeclarationSyntax(modifiers, functionKeyword, identifier, callSignature, block, semicolonToken, true);
            };
            StrictModeFactory.prototype.variableStatement = function (modifiers, variableDeclaration, semicolonToken) {
                return new TypeScript.VariableStatementSyntax(modifiers, variableDeclaration, semicolonToken, true);
            };
            StrictModeFactory.prototype.variableDeclaration = function (varKeyword, variableDeclarators) {
                return new TypeScript.VariableDeclarationSyntax(varKeyword, variableDeclarators, true);
            };
            StrictModeFactory.prototype.variableDeclarator = function (identifier, typeAnnotation, equalsValueClause) {
                return new TypeScript.VariableDeclaratorSyntax(identifier, typeAnnotation, equalsValueClause, true);
            };
            StrictModeFactory.prototype.equalsValueClause = function (equalsToken, value) {
                return new TypeScript.EqualsValueClauseSyntax(equalsToken, value, true);
            };
            StrictModeFactory.prototype.prefixUnaryExpression = function (kind, operatorToken, operand) {
                return new TypeScript.PrefixUnaryExpressionSyntax(kind, operatorToken, operand, true);
            };
            StrictModeFactory.prototype.arrayLiteralExpression = function (openBracketToken, expressions, closeBracketToken) {
                return new TypeScript.ArrayLiteralExpressionSyntax(openBracketToken, expressions, closeBracketToken, true);
            };
            StrictModeFactory.prototype.omittedExpression = function () {
                return new TypeScript.OmittedExpressionSyntax(true);
            };
            StrictModeFactory.prototype.parenthesizedExpression = function (openParenToken, expression, closeParenToken) {
                return new TypeScript.ParenthesizedExpressionSyntax(openParenToken, expression, closeParenToken, true);
            };
            StrictModeFactory.prototype.simpleArrowFunctionExpression = function (identifier, equalsGreaterThanToken, body) {
                return new TypeScript.SimpleArrowFunctionExpressionSyntax(identifier, equalsGreaterThanToken, body, true);
            };
            StrictModeFactory.prototype.parenthesizedArrowFunctionExpression = function (callSignature, equalsGreaterThanToken, body) {
                return new TypeScript.ParenthesizedArrowFunctionExpressionSyntax(callSignature, equalsGreaterThanToken, body, true);
            };
            StrictModeFactory.prototype.qualifiedName = function (left, dotToken, right) {
                return new TypeScript.QualifiedNameSyntax(left, dotToken, right, true);
            };
            StrictModeFactory.prototype.typeArgumentList = function (lessThanToken, typeArguments, greaterThanToken) {
                return new TypeScript.TypeArgumentListSyntax(lessThanToken, typeArguments, greaterThanToken, true);
            };
            StrictModeFactory.prototype.constructorType = function (newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type) {
                return new TypeScript.ConstructorTypeSyntax(newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type, true);
            };
            StrictModeFactory.prototype.functionType = function (typeParameterList, parameterList, equalsGreaterThanToken, type) {
                return new TypeScript.FunctionTypeSyntax(typeParameterList, parameterList, equalsGreaterThanToken, type, true);
            };
            StrictModeFactory.prototype.objectType = function (openBraceToken, typeMembers, closeBraceToken) {
                return new TypeScript.ObjectTypeSyntax(openBraceToken, typeMembers, closeBraceToken, true);
            };
            StrictModeFactory.prototype.arrayType = function (type, openBracketToken, closeBracketToken) {
                return new TypeScript.ArrayTypeSyntax(type, openBracketToken, closeBracketToken, true);
            };
            StrictModeFactory.prototype.genericType = function (name, typeArgumentList) {
                return new TypeScript.GenericTypeSyntax(name, typeArgumentList, true);
            };
            StrictModeFactory.prototype.typeQuery = function (typeOfKeyword, name) {
                return new TypeScript.TypeQuerySyntax(typeOfKeyword, name, true);
            };
            StrictModeFactory.prototype.typeAnnotation = function (colonToken, type) {
                return new TypeScript.TypeAnnotationSyntax(colonToken, type, true);
            };
            StrictModeFactory.prototype.block = function (openBraceToken, statements, closeBraceToken) {
                return new TypeScript.BlockSyntax(openBraceToken, statements, closeBraceToken, true);
            };
            StrictModeFactory.prototype.parameter = function (dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause) {
                return new TypeScript.ParameterSyntax(dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause, true);
            };
            StrictModeFactory.prototype.memberAccessExpression = function (expression, dotToken, name) {
                return new TypeScript.MemberAccessExpressionSyntax(expression, dotToken, name, true);
            };
            StrictModeFactory.prototype.postfixUnaryExpression = function (kind, operand, operatorToken) {
                return new TypeScript.PostfixUnaryExpressionSyntax(kind, operand, operatorToken, true);
            };
            StrictModeFactory.prototype.elementAccessExpression = function (expression, openBracketToken, argumentExpression, closeBracketToken) {
                return new TypeScript.ElementAccessExpressionSyntax(expression, openBracketToken, argumentExpression, closeBracketToken, true);
            };
            StrictModeFactory.prototype.invocationExpression = function (expression, argumentList) {
                return new TypeScript.InvocationExpressionSyntax(expression, argumentList, true);
            };
            StrictModeFactory.prototype.argumentList = function (typeArgumentList, openParenToken, _arguments, closeParenToken) {
                return new TypeScript.ArgumentListSyntax(typeArgumentList, openParenToken, _arguments, closeParenToken, true);
            };
            StrictModeFactory.prototype.binaryExpression = function (kind, left, operatorToken, right) {
                return new TypeScript.BinaryExpressionSyntax(kind, left, operatorToken, right, true);
            };
            StrictModeFactory.prototype.conditionalExpression = function (condition, questionToken, whenTrue, colonToken, whenFalse) {
                return new TypeScript.ConditionalExpressionSyntax(condition, questionToken, whenTrue, colonToken, whenFalse, true);
            };
            StrictModeFactory.prototype.constructSignature = function (newKeyword, callSignature) {
                return new TypeScript.ConstructSignatureSyntax(newKeyword, callSignature, true);
            };
            StrictModeFactory.prototype.methodSignature = function (propertyName, questionToken, callSignature) {
                return new TypeScript.MethodSignatureSyntax(propertyName, questionToken, callSignature, true);
            };
            StrictModeFactory.prototype.indexSignature = function (openBracketToken, parameter, closeBracketToken, typeAnnotation) {
                return new TypeScript.IndexSignatureSyntax(openBracketToken, parameter, closeBracketToken, typeAnnotation, true);
            };
            StrictModeFactory.prototype.propertySignature = function (propertyName, questionToken, typeAnnotation) {
                return new TypeScript.PropertySignatureSyntax(propertyName, questionToken, typeAnnotation, true);
            };
            StrictModeFactory.prototype.callSignature = function (typeParameterList, parameterList, typeAnnotation) {
                return new TypeScript.CallSignatureSyntax(typeParameterList, parameterList, typeAnnotation, true);
            };
            StrictModeFactory.prototype.parameterList = function (openParenToken, parameters, closeParenToken) {
                return new TypeScript.ParameterListSyntax(openParenToken, parameters, closeParenToken, true);
            };
            StrictModeFactory.prototype.typeParameterList = function (lessThanToken, typeParameters, greaterThanToken) {
                return new TypeScript.TypeParameterListSyntax(lessThanToken, typeParameters, greaterThanToken, true);
            };
            StrictModeFactory.prototype.typeParameter = function (identifier, constraint) {
                return new TypeScript.TypeParameterSyntax(identifier, constraint, true);
            };
            StrictModeFactory.prototype.constraint = function (extendsKeyword, type) {
                return new TypeScript.ConstraintSyntax(extendsKeyword, type, true);
            };
            StrictModeFactory.prototype.elseClause = function (elseKeyword, statement) {
                return new TypeScript.ElseClauseSyntax(elseKeyword, statement, true);
            };
            StrictModeFactory.prototype.ifStatement = function (ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause) {
                return new TypeScript.IfStatementSyntax(ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause, true);
            };
            StrictModeFactory.prototype.expressionStatement = function (expression, semicolonToken) {
                return new TypeScript.ExpressionStatementSyntax(expression, semicolonToken, true);
            };
            StrictModeFactory.prototype.constructorDeclaration = function (constructorKeyword, parameterList, block, semicolonToken) {
                return new TypeScript.ConstructorDeclarationSyntax(constructorKeyword, parameterList, block, semicolonToken, true);
            };
            StrictModeFactory.prototype.memberFunctionDeclaration = function (modifiers, propertyName, callSignature, block, semicolonToken) {
                return new TypeScript.MemberFunctionDeclarationSyntax(modifiers, propertyName, callSignature, block, semicolonToken, true);
            };
            StrictModeFactory.prototype.getMemberAccessorDeclaration = function (modifiers, getKeyword, propertyName, parameterList, typeAnnotation, block) {
                return new TypeScript.GetMemberAccessorDeclarationSyntax(modifiers, getKeyword, propertyName, parameterList, typeAnnotation, block, true);
            };
            StrictModeFactory.prototype.setMemberAccessorDeclaration = function (modifiers, setKeyword, propertyName, parameterList, block) {
                return new TypeScript.SetMemberAccessorDeclarationSyntax(modifiers, setKeyword, propertyName, parameterList, block, true);
            };
            StrictModeFactory.prototype.memberVariableDeclaration = function (modifiers, variableDeclarator, semicolonToken) {
                return new TypeScript.MemberVariableDeclarationSyntax(modifiers, variableDeclarator, semicolonToken, true);
            };
            StrictModeFactory.prototype.throwStatement = function (throwKeyword, expression, semicolonToken) {
                return new TypeScript.ThrowStatementSyntax(throwKeyword, expression, semicolonToken, true);
            };
            StrictModeFactory.prototype.returnStatement = function (returnKeyword, expression, semicolonToken) {
                return new TypeScript.ReturnStatementSyntax(returnKeyword, expression, semicolonToken, true);
            };
            StrictModeFactory.prototype.objectCreationExpression = function (newKeyword, expression, argumentList) {
                return new TypeScript.ObjectCreationExpressionSyntax(newKeyword, expression, argumentList, true);
            };
            StrictModeFactory.prototype.switchStatement = function (switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken) {
                return new TypeScript.SwitchStatementSyntax(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken, true);
            };
            StrictModeFactory.prototype.caseSwitchClause = function (caseKeyword, expression, colonToken, statements) {
                return new TypeScript.CaseSwitchClauseSyntax(caseKeyword, expression, colonToken, statements, true);
            };
            StrictModeFactory.prototype.defaultSwitchClause = function (defaultKeyword, colonToken, statements) {
                return new TypeScript.DefaultSwitchClauseSyntax(defaultKeyword, colonToken, statements, true);
            };
            StrictModeFactory.prototype.breakStatement = function (breakKeyword, identifier, semicolonToken) {
                return new TypeScript.BreakStatementSyntax(breakKeyword, identifier, semicolonToken, true);
            };
            StrictModeFactory.prototype.continueStatement = function (continueKeyword, identifier, semicolonToken) {
                return new TypeScript.ContinueStatementSyntax(continueKeyword, identifier, semicolonToken, true);
            };
            StrictModeFactory.prototype.forStatement = function (forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement) {
                return new TypeScript.ForStatementSyntax(forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement, true);
            };
            StrictModeFactory.prototype.forInStatement = function (forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement) {
                return new TypeScript.ForInStatementSyntax(forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement, true);
            };
            StrictModeFactory.prototype.whileStatement = function (whileKeyword, openParenToken, condition, closeParenToken, statement) {
                return new TypeScript.WhileStatementSyntax(whileKeyword, openParenToken, condition, closeParenToken, statement, true);
            };
            StrictModeFactory.prototype.withStatement = function (withKeyword, openParenToken, condition, closeParenToken, statement) {
                return new TypeScript.WithStatementSyntax(withKeyword, openParenToken, condition, closeParenToken, statement, true);
            };
            StrictModeFactory.prototype.enumDeclaration = function (modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken) {
                return new TypeScript.EnumDeclarationSyntax(modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken, true);
            };
            StrictModeFactory.prototype.enumElement = function (propertyName, equalsValueClause) {
                return new TypeScript.EnumElementSyntax(propertyName, equalsValueClause, true);
            };
            StrictModeFactory.prototype.castExpression = function (lessThanToken, type, greaterThanToken, expression) {
                return new TypeScript.CastExpressionSyntax(lessThanToken, type, greaterThanToken, expression, true);
            };
            StrictModeFactory.prototype.objectLiteralExpression = function (openBraceToken, propertyAssignments, closeBraceToken) {
                return new TypeScript.ObjectLiteralExpressionSyntax(openBraceToken, propertyAssignments, closeBraceToken, true);
            };
            StrictModeFactory.prototype.simplePropertyAssignment = function (propertyName, colonToken, expression) {
                return new TypeScript.SimplePropertyAssignmentSyntax(propertyName, colonToken, expression, true);
            };
            StrictModeFactory.prototype.functionPropertyAssignment = function (propertyName, callSignature, block) {
                return new TypeScript.FunctionPropertyAssignmentSyntax(propertyName, callSignature, block, true);
            };
            StrictModeFactory.prototype.getAccessorPropertyAssignment = function (getKeyword, propertyName, openParenToken, closeParenToken, typeAnnotation, block) {
                return new TypeScript.GetAccessorPropertyAssignmentSyntax(getKeyword, propertyName, openParenToken, closeParenToken, typeAnnotation, block, true);
            };
            StrictModeFactory.prototype.setAccessorPropertyAssignment = function (setKeyword, propertyName, openParenToken, parameter, closeParenToken, block) {
                return new TypeScript.SetAccessorPropertyAssignmentSyntax(setKeyword, propertyName, openParenToken, parameter, closeParenToken, block, true);
            };
            StrictModeFactory.prototype.functionExpression = function (functionKeyword, identifier, callSignature, block) {
                return new TypeScript.FunctionExpressionSyntax(functionKeyword, identifier, callSignature, block, true);
            };
            StrictModeFactory.prototype.emptyStatement = function (semicolonToken) {
                return new TypeScript.EmptyStatementSyntax(semicolonToken, true);
            };
            StrictModeFactory.prototype.tryStatement = function (tryKeyword, block, catchClause, finallyClause) {
                return new TypeScript.TryStatementSyntax(tryKeyword, block, catchClause, finallyClause, true);
            };
            StrictModeFactory.prototype.catchClause = function (catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block) {
                return new TypeScript.CatchClauseSyntax(catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block, true);
            };
            StrictModeFactory.prototype.finallyClause = function (finallyKeyword, block) {
                return new TypeScript.FinallyClauseSyntax(finallyKeyword, block, true);
            };
            StrictModeFactory.prototype.labeledStatement = function (identifier, colonToken, statement) {
                return new TypeScript.LabeledStatementSyntax(identifier, colonToken, statement, true);
            };
            StrictModeFactory.prototype.doStatement = function (doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken) {
                return new TypeScript.DoStatementSyntax(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken, true);
            };
            StrictModeFactory.prototype.typeOfExpression = function (typeOfKeyword, expression) {
                return new TypeScript.TypeOfExpressionSyntax(typeOfKeyword, expression, true);
            };
            StrictModeFactory.prototype.deleteExpression = function (deleteKeyword, expression) {
                return new TypeScript.DeleteExpressionSyntax(deleteKeyword, expression, true);
            };
            StrictModeFactory.prototype.voidExpression = function (voidKeyword, expression) {
                return new TypeScript.VoidExpressionSyntax(voidKeyword, expression, true);
            };
            StrictModeFactory.prototype.debuggerStatement = function (debuggerKeyword, semicolonToken) {
                return new TypeScript.DebuggerStatementSyntax(debuggerKeyword, semicolonToken, true);
            };
            return StrictModeFactory;
        })();
        Syntax.StrictModeFactory = StrictModeFactory;

        Syntax.normalModeFactory = new NormalModeFactory();
        Syntax.strictModeFactory = new StrictModeFactory();
    })(TypeScript.Syntax || (TypeScript.Syntax = {}));
    var Syntax = TypeScript.Syntax;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (SyntaxFacts) {
        function isDirectivePrologueElement(node) {
            if (node.kind() === 148 /* ExpressionStatement */) {
                var expressionStatement = node;
                var expression = expressionStatement.expression;

                if (expression.kind() === 14 /* StringLiteral */) {
                    return true;
                }
            }

            return false;
        }
        SyntaxFacts.isDirectivePrologueElement = isDirectivePrologueElement;

        function isUseStrictDirective(node) {
            var expressionStatement = node;
            var stringLiteral = expressionStatement.expression;

            var text = stringLiteral.text();
            return text === '"use strict"' || text === "'use strict'";
        }
        SyntaxFacts.isUseStrictDirective = isUseStrictDirective;

        function isIdentifierNameOrAnyKeyword(token) {
            var tokenKind = token.tokenKind;
            return tokenKind === 11 /* IdentifierName */ || TypeScript.SyntaxFacts.isAnyKeyword(tokenKind);
        }
        SyntaxFacts.isIdentifierNameOrAnyKeyword = isIdentifierNameOrAnyKeyword;
    })(TypeScript.SyntaxFacts || (TypeScript.SyntaxFacts = {}));
    var SyntaxFacts = TypeScript.SyntaxFacts;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Syntax) {
        var EmptySyntaxList = (function () {
            function EmptySyntaxList() {
            }
            EmptySyntaxList.prototype.kind = function () {
                return 1 /* List */;
            };

            EmptySyntaxList.prototype.isNode = function () {
                return false;
            };
            EmptySyntaxList.prototype.isToken = function () {
                return false;
            };
            EmptySyntaxList.prototype.isList = function () {
                return true;
            };
            EmptySyntaxList.prototype.isSeparatedList = function () {
                return false;
            };

            EmptySyntaxList.prototype.toJSON = function (key) {
                return [];
            };

            EmptySyntaxList.prototype.childCount = function () {
                return 0;
            };

            EmptySyntaxList.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            };

            EmptySyntaxList.prototype.toArray = function () {
                return [];
            };

            EmptySyntaxList.prototype.collectTextElements = function (elements) {
            };

            EmptySyntaxList.prototype.firstToken = function () {
                return null;
            };

            EmptySyntaxList.prototype.lastToken = function () {
                return null;
            };

            EmptySyntaxList.prototype.fullWidth = function () {
                return 0;
            };

            EmptySyntaxList.prototype.width = function () {
                return 0;
            };

            EmptySyntaxList.prototype.leadingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };

            EmptySyntaxList.prototype.trailingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };

            EmptySyntaxList.prototype.leadingTriviaWidth = function () {
                return 0;
            };

            EmptySyntaxList.prototype.trailingTriviaWidth = function () {
                return 0;
            };

            EmptySyntaxList.prototype.fullText = function () {
                return "";
            };

            EmptySyntaxList.prototype.isTypeScriptSpecific = function () {
                return false;
            };

            EmptySyntaxList.prototype.isIncrementallyUnusable = function () {
                return false;
            };

            EmptySyntaxList.prototype.findTokenInternal = function (parent, position, fullStart) {
                throw TypeScript.Errors.invalidOperation();
            };

            EmptySyntaxList.prototype.insertChildrenInto = function (array, index) {
            };
            return EmptySyntaxList;
        })();
        Syntax.EmptySyntaxList = EmptySyntaxList;

        Syntax.emptyList = new EmptySyntaxList();

        var SingletonSyntaxList = (function () {
            function SingletonSyntaxList(item) {
                this.item = item;
            }
            SingletonSyntaxList.prototype.kind = function () {
                return 1 /* List */;
            };

            SingletonSyntaxList.prototype.isToken = function () {
                return false;
            };
            SingletonSyntaxList.prototype.isNode = function () {
                return false;
            };
            SingletonSyntaxList.prototype.isList = function () {
                return true;
            };
            SingletonSyntaxList.prototype.isSeparatedList = function () {
                return false;
            };

            SingletonSyntaxList.prototype.toJSON = function (key) {
                return [this.item];
            };

            SingletonSyntaxList.prototype.childCount = function () {
                return 1;
            };

            SingletonSyntaxList.prototype.childAt = function (index) {
                if (index !== 0) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }

                return this.item;
            };

            SingletonSyntaxList.prototype.toArray = function () {
                return [this.item];
            };

            SingletonSyntaxList.prototype.collectTextElements = function (elements) {
                this.item.collectTextElements(elements);
            };

            SingletonSyntaxList.prototype.firstToken = function () {
                return this.item.firstToken();
            };

            SingletonSyntaxList.prototype.lastToken = function () {
                return this.item.lastToken();
            };

            SingletonSyntaxList.prototype.fullWidth = function () {
                return this.item.fullWidth();
            };

            SingletonSyntaxList.prototype.width = function () {
                return this.item.width();
            };

            SingletonSyntaxList.prototype.leadingTrivia = function () {
                return this.item.leadingTrivia();
            };

            SingletonSyntaxList.prototype.trailingTrivia = function () {
                return this.item.trailingTrivia();
            };

            SingletonSyntaxList.prototype.leadingTriviaWidth = function () {
                return this.item.leadingTriviaWidth();
            };

            SingletonSyntaxList.prototype.trailingTriviaWidth = function () {
                return this.item.trailingTriviaWidth();
            };

            SingletonSyntaxList.prototype.fullText = function () {
                return this.item.fullText();
            };

            SingletonSyntaxList.prototype.isTypeScriptSpecific = function () {
                return this.item.isTypeScriptSpecific();
            };

            SingletonSyntaxList.prototype.isIncrementallyUnusable = function () {
                return this.item.isIncrementallyUnusable();
            };

            SingletonSyntaxList.prototype.findTokenInternal = function (parent, position, fullStart) {
                return (this.item).findTokenInternal(new TypeScript.PositionedList(parent, this, fullStart), position, fullStart);
            };

            SingletonSyntaxList.prototype.insertChildrenInto = function (array, index) {
                array.splice(index, 0, this.item);
            };
            return SingletonSyntaxList;
        })();

        var NormalSyntaxList = (function () {
            function NormalSyntaxList(nodeOrTokens) {
                this._data = 0;
                this.nodeOrTokens = nodeOrTokens;
            }
            NormalSyntaxList.prototype.kind = function () {
                return 1 /* List */;
            };

            NormalSyntaxList.prototype.isNode = function () {
                return false;
            };
            NormalSyntaxList.prototype.isToken = function () {
                return false;
            };
            NormalSyntaxList.prototype.isList = function () {
                return true;
            };
            NormalSyntaxList.prototype.isSeparatedList = function () {
                return false;
            };

            NormalSyntaxList.prototype.toJSON = function (key) {
                return this.nodeOrTokens;
            };

            NormalSyntaxList.prototype.childCount = function () {
                return this.nodeOrTokens.length;
            };

            NormalSyntaxList.prototype.childAt = function (index) {
                if (index < 0 || index >= this.nodeOrTokens.length) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }

                return this.nodeOrTokens[index];
            };

            NormalSyntaxList.prototype.toArray = function () {
                return this.nodeOrTokens.slice(0);
            };

            NormalSyntaxList.prototype.collectTextElements = function (elements) {
                for (var i = 0, n = this.nodeOrTokens.length; i < n; i++) {
                    var element = this.nodeOrTokens[i];
                    element.collectTextElements(elements);
                }
            };

            NormalSyntaxList.prototype.firstToken = function () {
                for (var i = 0, n = this.nodeOrTokens.length; i < n; i++) {
                    var token = this.nodeOrTokens[i].firstToken();
                    if (token !== null) {
                        return token;
                    }
                }

                return null;
            };

            NormalSyntaxList.prototype.lastToken = function () {
                for (var i = this.nodeOrTokens.length - 1; i >= 0; i--) {
                    var token = this.nodeOrTokens[i].lastToken();
                    if (token !== null) {
                        return token;
                    }
                }

                return null;
            };

            NormalSyntaxList.prototype.fullText = function () {
                var elements = new Array();
                this.collectTextElements(elements);
                return elements.join("");
            };

            NormalSyntaxList.prototype.isTypeScriptSpecific = function () {
                for (var i = 0, n = this.nodeOrTokens.length; i < n; i++) {
                    if (this.nodeOrTokens[i].isTypeScriptSpecific()) {
                        return true;
                    }
                }

                return false;
            };

            NormalSyntaxList.prototype.isIncrementallyUnusable = function () {
                return (this.data() & 2 /* NodeIncrementallyUnusableMask */) !== 0;
            };

            NormalSyntaxList.prototype.fullWidth = function () {
                return this.data() >>> 3 /* NodeFullWidthShift */;
            };

            NormalSyntaxList.prototype.width = function () {
                var fullWidth = this.fullWidth();
                return fullWidth - this.leadingTriviaWidth() - this.trailingTriviaWidth();
            };

            NormalSyntaxList.prototype.leadingTrivia = function () {
                return this.firstToken().leadingTrivia();
            };

            NormalSyntaxList.prototype.trailingTrivia = function () {
                return this.lastToken().trailingTrivia();
            };

            NormalSyntaxList.prototype.leadingTriviaWidth = function () {
                return this.firstToken().leadingTriviaWidth();
            };

            NormalSyntaxList.prototype.trailingTriviaWidth = function () {
                return this.lastToken().trailingTriviaWidth();
            };

            NormalSyntaxList.prototype.computeData = function () {
                var fullWidth = 0;
                var isIncrementallyUnusable = false;

                for (var i = 0, n = this.nodeOrTokens.length; i < n; i++) {
                    var node = this.nodeOrTokens[i];
                    fullWidth += node.fullWidth();
                    isIncrementallyUnusable = isIncrementallyUnusable || node.isIncrementallyUnusable();
                }

                return (fullWidth << 3 /* NodeFullWidthShift */) | (isIncrementallyUnusable ? 2 /* NodeIncrementallyUnusableMask */ : 0) | 1 /* NodeDataComputed */;
            };

            NormalSyntaxList.prototype.data = function () {
                if ((this._data & 1 /* NodeDataComputed */) === 0) {
                    this._data = this.computeData();
                }

                return this._data;
            };

            NormalSyntaxList.prototype.findTokenInternal = function (parent, position, fullStart) {
                parent = new TypeScript.PositionedList(parent, this, fullStart);
                for (var i = 0, n = this.nodeOrTokens.length; i < n; i++) {
                    var nodeOrToken = this.nodeOrTokens[i];

                    var childWidth = nodeOrToken.fullWidth();
                    if (position < childWidth) {
                        return (nodeOrToken).findTokenInternal(parent, position, fullStart);
                    }

                    position -= childWidth;
                    fullStart += childWidth;
                }

                throw TypeScript.Errors.invalidOperation();
            };

            NormalSyntaxList.prototype.insertChildrenInto = function (array, index) {
                if (index === 0) {
                    array.unshift.apply(array, this.nodeOrTokens);
                } else {
                    array.splice.apply(array, [index, 0].concat(this.nodeOrTokens));
                }
            };
            return NormalSyntaxList;
        })();

        function list(nodes) {
            if (nodes === undefined || nodes === null || nodes.length === 0) {
                return Syntax.emptyList;
            }

            if (nodes.length === 1) {
                var item = nodes[0];
                return new SingletonSyntaxList(item);
            }

            return new NormalSyntaxList(nodes);
        }
        Syntax.list = list;
    })(TypeScript.Syntax || (TypeScript.Syntax = {}));
    var Syntax = TypeScript.Syntax;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxNode = (function () {
        function SyntaxNode(parsedInStrictMode) {
            this._data = parsedInStrictMode ? 4 /* NodeParsedInStrictModeMask */ : 0;
        }
        SyntaxNode.prototype.isNode = function () {
            return true;
        };
        SyntaxNode.prototype.isToken = function () {
            return false;
        };
        SyntaxNode.prototype.isList = function () {
            return false;
        };
        SyntaxNode.prototype.isSeparatedList = function () {
            return false;
        };

        SyntaxNode.prototype.kind = function () {
            throw TypeScript.Errors.abstract();
        };

        SyntaxNode.prototype.childCount = function () {
            throw TypeScript.Errors.abstract();
        };

        SyntaxNode.prototype.childAt = function (slot) {
            throw TypeScript.Errors.abstract();
        };

        SyntaxNode.prototype.firstToken = function () {
            for (var i = 0, n = this.childCount(); i < n; i++) {
                var element = this.childAt(i);

                if (element !== null) {
                    if (element.fullWidth() > 0 || element.kind() === 10 /* EndOfFileToken */) {
                        return element.firstToken();
                    }
                }
            }

            return null;
        };

        SyntaxNode.prototype.lastToken = function () {
            for (var i = this.childCount() - 1; i >= 0; i--) {
                var element = this.childAt(i);

                if (element !== null) {
                    if (element.fullWidth() > 0 || element.kind() === 10 /* EndOfFileToken */) {
                        return element.lastToken();
                    }
                }
            }

            return null;
        };

        SyntaxNode.prototype.insertChildrenInto = function (array, index) {
            for (var i = this.childCount() - 1; i >= 0; i--) {
                var element = this.childAt(i);

                if (element !== null) {
                    if (element.isNode() || element.isToken()) {
                        array.splice(index, 0, element);
                    } else if (element.isList()) {
                        (element).insertChildrenInto(array, index);
                    } else if (element.isSeparatedList()) {
                        (element).insertChildrenInto(array, index);
                    } else {
                        throw TypeScript.Errors.invalidOperation();
                    }
                }
            }
        };

        SyntaxNode.prototype.leadingTrivia = function () {
            return this.firstToken().leadingTrivia();
        };

        SyntaxNode.prototype.trailingTrivia = function () {
            return this.lastToken().trailingTrivia();
        };

        SyntaxNode.prototype.toJSON = function (key) {
            var result = {
                kind: TypeScript.SyntaxKind[this.kind()],
                fullWidth: this.fullWidth()
            };

            if (this.isIncrementallyUnusable()) {
                result.isIncrementallyUnusable = true;
            }

            if (this.parsedInStrictMode()) {
                result.parsedInStrictMode = true;
            }

            for (var i = 0, n = this.childCount(); i < n; i++) {
                var value = this.childAt(i);

                if (value) {
                    for (var name in this) {
                        if (value === this[name]) {
                            result[name] = value;
                            break;
                        }
                    }
                }
            }

            return result;
        };

        SyntaxNode.prototype.accept = function (visitor) {
            throw TypeScript.Errors.abstract();
        };

        SyntaxNode.prototype.fullText = function () {
            var elements = [];
            this.collectTextElements(elements);
            return elements.join("");
        };

        SyntaxNode.prototype.collectTextElements = function (elements) {
            for (var i = 0, n = this.childCount(); i < n; i++) {
                var element = this.childAt(i);

                if (element !== null) {
                    element.collectTextElements(elements);
                }
            }
        };

        SyntaxNode.prototype.replaceToken = function (token1, token2) {
            if (token1 === token2) {
                return this;
            }

            return this.accept(new TypeScript.SyntaxTokenReplacer(token1, token2));
        };

        SyntaxNode.prototype.withLeadingTrivia = function (trivia) {
            return this.replaceToken(this.firstToken(), this.firstToken().withLeadingTrivia(trivia));
        };

        SyntaxNode.prototype.withTrailingTrivia = function (trivia) {
            return this.replaceToken(this.lastToken(), this.lastToken().withTrailingTrivia(trivia));
        };

        SyntaxNode.prototype.hasLeadingTrivia = function () {
            return this.lastToken().hasLeadingTrivia();
        };

        SyntaxNode.prototype.hasTrailingTrivia = function () {
            return this.lastToken().hasTrailingTrivia();
        };

        SyntaxNode.prototype.isTypeScriptSpecific = function () {
            return false;
        };

        SyntaxNode.prototype.isIncrementallyUnusable = function () {
            return (this.data() & 2 /* NodeIncrementallyUnusableMask */) !== 0;
        };

        SyntaxNode.prototype.parsedInStrictMode = function () {
            return (this.data() & 4 /* NodeParsedInStrictModeMask */) !== 0;
        };

        SyntaxNode.prototype.fullWidth = function () {
            return this.data() >>> 3 /* NodeFullWidthShift */;
        };

        SyntaxNode.prototype.computeData = function () {
            var slotCount = this.childCount();

            var fullWidth = 0;
            var childWidth = 0;

            var isIncrementallyUnusable = ((this._data & 2 /* NodeIncrementallyUnusableMask */) !== 0) || slotCount === 0;

            for (var i = 0, n = slotCount; i < n; i++) {
                var element = this.childAt(i);

                if (element !== null) {
                    childWidth = element.fullWidth();
                    fullWidth += childWidth;

                    if (!isIncrementallyUnusable) {
                        isIncrementallyUnusable = element.isIncrementallyUnusable();
                    }
                }
            }

            return (fullWidth << 3 /* NodeFullWidthShift */) | (isIncrementallyUnusable ? 2 /* NodeIncrementallyUnusableMask */ : 0) | 1 /* NodeDataComputed */;
        };

        SyntaxNode.prototype.data = function () {
            if ((this._data & 1 /* NodeDataComputed */) === 0) {
                this._data |= this.computeData();
            }

            return this._data;
        };

        SyntaxNode.prototype.findToken = function (position, includeSkippedTokens) {
            if (typeof includeSkippedTokens === "undefined") { includeSkippedTokens = false; }
            var endOfFileToken = this.tryGetEndOfFileAt(position);
            if (endOfFileToken !== null) {
                return endOfFileToken;
            }

            if (position < 0 || position >= this.fullWidth()) {
                throw TypeScript.Errors.argumentOutOfRange("position");
            }

            var positionedToken = this.findTokenInternal(null, position, 0);

            if (includeSkippedTokens) {
                return TypeScript.Syntax.findSkippedTokenInPositionedToken(positionedToken, position) || positionedToken;
            }

            return positionedToken;
        };

        SyntaxNode.prototype.tryGetEndOfFileAt = function (position) {
            if (this.kind() === 120 /* SourceUnit */ && position === this.fullWidth()) {
                var sourceUnit = this;
                return new TypeScript.PositionedToken(new TypeScript.PositionedNode(null, sourceUnit, 0), sourceUnit.endOfFileToken, sourceUnit.moduleElements.fullWidth());
            }

            return null;
        };

        SyntaxNode.prototype.findTokenInternal = function (parent, position, fullStart) {
            parent = new TypeScript.PositionedNode(parent, this, fullStart);
            for (var i = 0, n = this.childCount(); i < n; i++) {
                var element = this.childAt(i);

                if (element !== null) {
                    var childWidth = element.fullWidth();

                    if (position < childWidth) {
                        return (element).findTokenInternal(parent, position, fullStart);
                    }

                    position -= childWidth;
                    fullStart += childWidth;
                }
            }

            throw TypeScript.Errors.invalidOperation();
        };

        SyntaxNode.prototype.findTokenOnLeft = function (position, includeSkippedTokens) {
            if (typeof includeSkippedTokens === "undefined") { includeSkippedTokens = false; }
            var positionedToken = this.findToken(position, false);
            var start = positionedToken.start();

            if (includeSkippedTokens) {
                positionedToken = TypeScript.Syntax.findSkippedTokenOnLeft(positionedToken, position) || positionedToken;
            }

            if (position > start) {
                return positionedToken;
            }

            if (positionedToken.fullStart() === 0) {
                return null;
            }

            return positionedToken.previousToken(includeSkippedTokens);
        };

        SyntaxNode.prototype.findCompleteTokenOnLeft = function (position, includeSkippedTokens) {
            if (typeof includeSkippedTokens === "undefined") { includeSkippedTokens = false; }
            var positionedToken = this.findToken(position, false);

            if (includeSkippedTokens) {
                positionedToken = TypeScript.Syntax.findSkippedTokenOnLeft(positionedToken, position) || positionedToken;
            }

            if (positionedToken.token().width() > 0 && position >= positionedToken.end()) {
                return positionedToken;
            }

            return positionedToken.previousToken(includeSkippedTokens);
        };

        SyntaxNode.prototype.isModuleElement = function () {
            return false;
        };

        SyntaxNode.prototype.isClassElement = function () {
            return false;
        };

        SyntaxNode.prototype.isTypeMember = function () {
            return false;
        };

        SyntaxNode.prototype.isStatement = function () {
            return false;
        };

        SyntaxNode.prototype.isSwitchClause = function () {
            return false;
        };

        SyntaxNode.prototype.structuralEquals = function (node) {
            if (this === node) {
                return true;
            }
            if (node === null) {
                return false;
            }
            if (this.kind() !== node.kind()) {
                return false;
            }

            for (var i = 0, n = this.childCount(); i < n; i++) {
                var element1 = this.childAt(i);
                var element2 = node.childAt(i);

                if (!TypeScript.Syntax.elementStructuralEquals(element1, element2)) {
                    return false;
                }
            }

            return true;
        };

        SyntaxNode.prototype.width = function () {
            return this.fullWidth() - this.leadingTriviaWidth() - this.trailingTriviaWidth();
        };

        SyntaxNode.prototype.leadingTriviaWidth = function () {
            var firstToken = this.firstToken();
            return firstToken === null ? 0 : firstToken.leadingTriviaWidth();
        };

        SyntaxNode.prototype.trailingTriviaWidth = function () {
            var lastToken = this.lastToken();
            return lastToken === null ? 0 : lastToken.trailingTriviaWidth();
        };
        return SyntaxNode;
    })();
    TypeScript.SyntaxNode = SyntaxNode;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SourceUnitSyntax = (function (_super) {
        __extends(SourceUnitSyntax, _super);
        function SourceUnitSyntax(moduleElements, endOfFileToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.moduleElements = moduleElements;
            this.endOfFileToken = endOfFileToken;
        }
        SourceUnitSyntax.prototype.accept = function (visitor) {
            return visitor.visitSourceUnit(this);
        };

        SourceUnitSyntax.prototype.kind = function () {
            return 120 /* SourceUnit */;
        };

        SourceUnitSyntax.prototype.childCount = function () {
            return 2;
        };

        SourceUnitSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.moduleElements;
                case 1:
                    return this.endOfFileToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        SourceUnitSyntax.prototype.update = function (moduleElements, endOfFileToken) {
            if (this.moduleElements === moduleElements && this.endOfFileToken === endOfFileToken) {
                return this;
            }

            return new SourceUnitSyntax(moduleElements, endOfFileToken, this.parsedInStrictMode());
        };

        SourceUnitSyntax.create = function (endOfFileToken) {
            return new SourceUnitSyntax(TypeScript.Syntax.emptyList, endOfFileToken, false);
        };

        SourceUnitSyntax.create1 = function (endOfFileToken) {
            return new SourceUnitSyntax(TypeScript.Syntax.emptyList, endOfFileToken, false);
        };

        SourceUnitSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        SourceUnitSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        SourceUnitSyntax.prototype.withModuleElements = function (moduleElements) {
            return this.update(moduleElements, this.endOfFileToken);
        };

        SourceUnitSyntax.prototype.withModuleElement = function (moduleElement) {
            return this.withModuleElements(TypeScript.Syntax.list([moduleElement]));
        };

        SourceUnitSyntax.prototype.withEndOfFileToken = function (endOfFileToken) {
            return this.update(this.moduleElements, endOfFileToken);
        };

        SourceUnitSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.moduleElements.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return SourceUnitSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.SourceUnitSyntax = SourceUnitSyntax;

    var ModuleReferenceSyntax = (function (_super) {
        __extends(ModuleReferenceSyntax, _super);
        function ModuleReferenceSyntax(parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
        }
        ModuleReferenceSyntax.prototype.isModuleReference = function () {
            return true;
        };

        ModuleReferenceSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ModuleReferenceSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ModuleReferenceSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ModuleReferenceSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ModuleReferenceSyntax = ModuleReferenceSyntax;

    var ExternalModuleReferenceSyntax = (function (_super) {
        __extends(ExternalModuleReferenceSyntax, _super);
        function ExternalModuleReferenceSyntax(requireKeyword, openParenToken, stringLiteral, closeParenToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.requireKeyword = requireKeyword;
            this.openParenToken = openParenToken;
            this.stringLiteral = stringLiteral;
            this.closeParenToken = closeParenToken;
        }
        ExternalModuleReferenceSyntax.prototype.accept = function (visitor) {
            return visitor.visitExternalModuleReference(this);
        };

        ExternalModuleReferenceSyntax.prototype.kind = function () {
            return 245 /* ExternalModuleReference */;
        };

        ExternalModuleReferenceSyntax.prototype.childCount = function () {
            return 4;
        };

        ExternalModuleReferenceSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.requireKeyword;
                case 1:
                    return this.openParenToken;
                case 2:
                    return this.stringLiteral;
                case 3:
                    return this.closeParenToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ExternalModuleReferenceSyntax.prototype.update = function (requireKeyword, openParenToken, stringLiteral, closeParenToken) {
            if (this.requireKeyword === requireKeyword && this.openParenToken === openParenToken && this.stringLiteral === stringLiteral && this.closeParenToken === closeParenToken) {
                return this;
            }

            return new ExternalModuleReferenceSyntax(requireKeyword, openParenToken, stringLiteral, closeParenToken, this.parsedInStrictMode());
        };

        ExternalModuleReferenceSyntax.create1 = function (stringLiteral) {
            return new ExternalModuleReferenceSyntax(TypeScript.Syntax.token(66 /* RequireKeyword */), TypeScript.Syntax.token(72 /* OpenParenToken */), stringLiteral, TypeScript.Syntax.token(73 /* CloseParenToken */), false);
        };

        ExternalModuleReferenceSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ExternalModuleReferenceSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ExternalModuleReferenceSyntax.prototype.withRequireKeyword = function (requireKeyword) {
            return this.update(requireKeyword, this.openParenToken, this.stringLiteral, this.closeParenToken);
        };

        ExternalModuleReferenceSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.requireKeyword, openParenToken, this.stringLiteral, this.closeParenToken);
        };

        ExternalModuleReferenceSyntax.prototype.withStringLiteral = function (stringLiteral) {
            return this.update(this.requireKeyword, this.openParenToken, stringLiteral, this.closeParenToken);
        };

        ExternalModuleReferenceSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.requireKeyword, this.openParenToken, this.stringLiteral, closeParenToken);
        };

        ExternalModuleReferenceSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ExternalModuleReferenceSyntax;
    })(ModuleReferenceSyntax);
    TypeScript.ExternalModuleReferenceSyntax = ExternalModuleReferenceSyntax;

    var ModuleNameModuleReferenceSyntax = (function (_super) {
        __extends(ModuleNameModuleReferenceSyntax, _super);
        function ModuleNameModuleReferenceSyntax(moduleName, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.moduleName = moduleName;
        }
        ModuleNameModuleReferenceSyntax.prototype.accept = function (visitor) {
            return visitor.visitModuleNameModuleReference(this);
        };

        ModuleNameModuleReferenceSyntax.prototype.kind = function () {
            return 246 /* ModuleNameModuleReference */;
        };

        ModuleNameModuleReferenceSyntax.prototype.childCount = function () {
            return 1;
        };

        ModuleNameModuleReferenceSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.moduleName;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ModuleNameModuleReferenceSyntax.prototype.update = function (moduleName) {
            if (this.moduleName === moduleName) {
                return this;
            }

            return new ModuleNameModuleReferenceSyntax(moduleName, this.parsedInStrictMode());
        };

        ModuleNameModuleReferenceSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ModuleNameModuleReferenceSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ModuleNameModuleReferenceSyntax.prototype.withModuleName = function (moduleName) {
            return this.update(moduleName);
        };

        ModuleNameModuleReferenceSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ModuleNameModuleReferenceSyntax;
    })(ModuleReferenceSyntax);
    TypeScript.ModuleNameModuleReferenceSyntax = ModuleNameModuleReferenceSyntax;

    var ImportDeclarationSyntax = (function (_super) {
        __extends(ImportDeclarationSyntax, _super);
        function ImportDeclarationSyntax(modifiers, importKeyword, identifier, equalsToken, moduleReference, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.modifiers = modifiers;
            this.importKeyword = importKeyword;
            this.identifier = identifier;
            this.equalsToken = equalsToken;
            this.moduleReference = moduleReference;
            this.semicolonToken = semicolonToken;
        }
        ImportDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitImportDeclaration(this);
        };

        ImportDeclarationSyntax.prototype.kind = function () {
            return 133 /* ImportDeclaration */;
        };

        ImportDeclarationSyntax.prototype.childCount = function () {
            return 6;
        };

        ImportDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.importKeyword;
                case 2:
                    return this.identifier;
                case 3:
                    return this.equalsToken;
                case 4:
                    return this.moduleReference;
                case 5:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ImportDeclarationSyntax.prototype.isModuleElement = function () {
            return true;
        };

        ImportDeclarationSyntax.prototype.update = function (modifiers, importKeyword, identifier, equalsToken, moduleReference, semicolonToken) {
            if (this.modifiers === modifiers && this.importKeyword === importKeyword && this.identifier === identifier && this.equalsToken === equalsToken && this.moduleReference === moduleReference && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new ImportDeclarationSyntax(modifiers, importKeyword, identifier, equalsToken, moduleReference, semicolonToken, this.parsedInStrictMode());
        };

        ImportDeclarationSyntax.create = function (importKeyword, identifier, equalsToken, moduleReference, semicolonToken) {
            return new ImportDeclarationSyntax(TypeScript.Syntax.emptyList, importKeyword, identifier, equalsToken, moduleReference, semicolonToken, false);
        };

        ImportDeclarationSyntax.create1 = function (identifier, moduleReference) {
            return new ImportDeclarationSyntax(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(49 /* ImportKeyword */), identifier, TypeScript.Syntax.token(107 /* EqualsToken */), moduleReference, TypeScript.Syntax.token(78 /* SemicolonToken */), false);
        };

        ImportDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ImportDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ImportDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.importKeyword, this.identifier, this.equalsToken, this.moduleReference, this.semicolonToken);
        };

        ImportDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };

        ImportDeclarationSyntax.prototype.withImportKeyword = function (importKeyword) {
            return this.update(this.modifiers, importKeyword, this.identifier, this.equalsToken, this.moduleReference, this.semicolonToken);
        };

        ImportDeclarationSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.modifiers, this.importKeyword, identifier, this.equalsToken, this.moduleReference, this.semicolonToken);
        };

        ImportDeclarationSyntax.prototype.withEqualsToken = function (equalsToken) {
            return this.update(this.modifiers, this.importKeyword, this.identifier, equalsToken, this.moduleReference, this.semicolonToken);
        };

        ImportDeclarationSyntax.prototype.withModuleReference = function (moduleReference) {
            return this.update(this.modifiers, this.importKeyword, this.identifier, this.equalsToken, moduleReference, this.semicolonToken);
        };

        ImportDeclarationSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.modifiers, this.importKeyword, this.identifier, this.equalsToken, this.moduleReference, semicolonToken);
        };

        ImportDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ImportDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ImportDeclarationSyntax = ImportDeclarationSyntax;

    var ExportAssignmentSyntax = (function (_super) {
        __extends(ExportAssignmentSyntax, _super);
        function ExportAssignmentSyntax(exportKeyword, equalsToken, identifier, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.exportKeyword = exportKeyword;
            this.equalsToken = equalsToken;
            this.identifier = identifier;
            this.semicolonToken = semicolonToken;
        }
        ExportAssignmentSyntax.prototype.accept = function (visitor) {
            return visitor.visitExportAssignment(this);
        };

        ExportAssignmentSyntax.prototype.kind = function () {
            return 134 /* ExportAssignment */;
        };

        ExportAssignmentSyntax.prototype.childCount = function () {
            return 4;
        };

        ExportAssignmentSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.exportKeyword;
                case 1:
                    return this.equalsToken;
                case 2:
                    return this.identifier;
                case 3:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ExportAssignmentSyntax.prototype.isModuleElement = function () {
            return true;
        };

        ExportAssignmentSyntax.prototype.update = function (exportKeyword, equalsToken, identifier, semicolonToken) {
            if (this.exportKeyword === exportKeyword && this.equalsToken === equalsToken && this.identifier === identifier && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new ExportAssignmentSyntax(exportKeyword, equalsToken, identifier, semicolonToken, this.parsedInStrictMode());
        };

        ExportAssignmentSyntax.create1 = function (identifier) {
            return new ExportAssignmentSyntax(TypeScript.Syntax.token(47 /* ExportKeyword */), TypeScript.Syntax.token(107 /* EqualsToken */), identifier, TypeScript.Syntax.token(78 /* SemicolonToken */), false);
        };

        ExportAssignmentSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ExportAssignmentSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ExportAssignmentSyntax.prototype.withExportKeyword = function (exportKeyword) {
            return this.update(exportKeyword, this.equalsToken, this.identifier, this.semicolonToken);
        };

        ExportAssignmentSyntax.prototype.withEqualsToken = function (equalsToken) {
            return this.update(this.exportKeyword, equalsToken, this.identifier, this.semicolonToken);
        };

        ExportAssignmentSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.exportKeyword, this.equalsToken, identifier, this.semicolonToken);
        };

        ExportAssignmentSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.exportKeyword, this.equalsToken, this.identifier, semicolonToken);
        };

        ExportAssignmentSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ExportAssignmentSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ExportAssignmentSyntax = ExportAssignmentSyntax;

    var ClassDeclarationSyntax = (function (_super) {
        __extends(ClassDeclarationSyntax, _super);
        function ClassDeclarationSyntax(modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.modifiers = modifiers;
            this.classKeyword = classKeyword;
            this.identifier = identifier;
            this.typeParameterList = typeParameterList;
            this.heritageClauses = heritageClauses;
            this.openBraceToken = openBraceToken;
            this.classElements = classElements;
            this.closeBraceToken = closeBraceToken;
        }
        ClassDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitClassDeclaration(this);
        };

        ClassDeclarationSyntax.prototype.kind = function () {
            return 131 /* ClassDeclaration */;
        };

        ClassDeclarationSyntax.prototype.childCount = function () {
            return 8;
        };

        ClassDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.classKeyword;
                case 2:
                    return this.identifier;
                case 3:
                    return this.typeParameterList;
                case 4:
                    return this.heritageClauses;
                case 5:
                    return this.openBraceToken;
                case 6:
                    return this.classElements;
                case 7:
                    return this.closeBraceToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ClassDeclarationSyntax.prototype.isModuleElement = function () {
            return true;
        };

        ClassDeclarationSyntax.prototype.update = function (modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken) {
            if (this.modifiers === modifiers && this.classKeyword === classKeyword && this.identifier === identifier && this.typeParameterList === typeParameterList && this.heritageClauses === heritageClauses && this.openBraceToken === openBraceToken && this.classElements === classElements && this.closeBraceToken === closeBraceToken) {
                return this;
            }

            return new ClassDeclarationSyntax(modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken, this.parsedInStrictMode());
        };

        ClassDeclarationSyntax.create = function (classKeyword, identifier, openBraceToken, closeBraceToken) {
            return new ClassDeclarationSyntax(TypeScript.Syntax.emptyList, classKeyword, identifier, null, TypeScript.Syntax.emptyList, openBraceToken, TypeScript.Syntax.emptyList, closeBraceToken, false);
        };

        ClassDeclarationSyntax.create1 = function (identifier) {
            return new ClassDeclarationSyntax(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(44 /* ClassKeyword */), identifier, null, TypeScript.Syntax.emptyList, TypeScript.Syntax.token(70 /* OpenBraceToken */), TypeScript.Syntax.emptyList, TypeScript.Syntax.token(71 /* CloseBraceToken */), false);
        };

        ClassDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ClassDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ClassDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.classKeyword, this.identifier, this.typeParameterList, this.heritageClauses, this.openBraceToken, this.classElements, this.closeBraceToken);
        };

        ClassDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };

        ClassDeclarationSyntax.prototype.withClassKeyword = function (classKeyword) {
            return this.update(this.modifiers, classKeyword, this.identifier, this.typeParameterList, this.heritageClauses, this.openBraceToken, this.classElements, this.closeBraceToken);
        };

        ClassDeclarationSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.modifiers, this.classKeyword, identifier, this.typeParameterList, this.heritageClauses, this.openBraceToken, this.classElements, this.closeBraceToken);
        };

        ClassDeclarationSyntax.prototype.withTypeParameterList = function (typeParameterList) {
            return this.update(this.modifiers, this.classKeyword, this.identifier, typeParameterList, this.heritageClauses, this.openBraceToken, this.classElements, this.closeBraceToken);
        };

        ClassDeclarationSyntax.prototype.withHeritageClauses = function (heritageClauses) {
            return this.update(this.modifiers, this.classKeyword, this.identifier, this.typeParameterList, heritageClauses, this.openBraceToken, this.classElements, this.closeBraceToken);
        };

        ClassDeclarationSyntax.prototype.withHeritageClause = function (heritageClause) {
            return this.withHeritageClauses(TypeScript.Syntax.list([heritageClause]));
        };

        ClassDeclarationSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
            return this.update(this.modifiers, this.classKeyword, this.identifier, this.typeParameterList, this.heritageClauses, openBraceToken, this.classElements, this.closeBraceToken);
        };

        ClassDeclarationSyntax.prototype.withClassElements = function (classElements) {
            return this.update(this.modifiers, this.classKeyword, this.identifier, this.typeParameterList, this.heritageClauses, this.openBraceToken, classElements, this.closeBraceToken);
        };

        ClassDeclarationSyntax.prototype.withClassElement = function (classElement) {
            return this.withClassElements(TypeScript.Syntax.list([classElement]));
        };

        ClassDeclarationSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
            return this.update(this.modifiers, this.classKeyword, this.identifier, this.typeParameterList, this.heritageClauses, this.openBraceToken, this.classElements, closeBraceToken);
        };

        ClassDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ClassDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ClassDeclarationSyntax = ClassDeclarationSyntax;

    var InterfaceDeclarationSyntax = (function (_super) {
        __extends(InterfaceDeclarationSyntax, _super);
        function InterfaceDeclarationSyntax(modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, body, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.modifiers = modifiers;
            this.interfaceKeyword = interfaceKeyword;
            this.identifier = identifier;
            this.typeParameterList = typeParameterList;
            this.heritageClauses = heritageClauses;
            this.body = body;
        }
        InterfaceDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitInterfaceDeclaration(this);
        };

        InterfaceDeclarationSyntax.prototype.kind = function () {
            return 128 /* InterfaceDeclaration */;
        };

        InterfaceDeclarationSyntax.prototype.childCount = function () {
            return 6;
        };

        InterfaceDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.interfaceKeyword;
                case 2:
                    return this.identifier;
                case 3:
                    return this.typeParameterList;
                case 4:
                    return this.heritageClauses;
                case 5:
                    return this.body;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        InterfaceDeclarationSyntax.prototype.isModuleElement = function () {
            return true;
        };

        InterfaceDeclarationSyntax.prototype.update = function (modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, body) {
            if (this.modifiers === modifiers && this.interfaceKeyword === interfaceKeyword && this.identifier === identifier && this.typeParameterList === typeParameterList && this.heritageClauses === heritageClauses && this.body === body) {
                return this;
            }

            return new InterfaceDeclarationSyntax(modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, body, this.parsedInStrictMode());
        };

        InterfaceDeclarationSyntax.create = function (interfaceKeyword, identifier, body) {
            return new InterfaceDeclarationSyntax(TypeScript.Syntax.emptyList, interfaceKeyword, identifier, null, TypeScript.Syntax.emptyList, body, false);
        };

        InterfaceDeclarationSyntax.create1 = function (identifier) {
            return new InterfaceDeclarationSyntax(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(52 /* InterfaceKeyword */), identifier, null, TypeScript.Syntax.emptyList, ObjectTypeSyntax.create1(), false);
        };

        InterfaceDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        InterfaceDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        InterfaceDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.interfaceKeyword, this.identifier, this.typeParameterList, this.heritageClauses, this.body);
        };

        InterfaceDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };

        InterfaceDeclarationSyntax.prototype.withInterfaceKeyword = function (interfaceKeyword) {
            return this.update(this.modifiers, interfaceKeyword, this.identifier, this.typeParameterList, this.heritageClauses, this.body);
        };

        InterfaceDeclarationSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.modifiers, this.interfaceKeyword, identifier, this.typeParameterList, this.heritageClauses, this.body);
        };

        InterfaceDeclarationSyntax.prototype.withTypeParameterList = function (typeParameterList) {
            return this.update(this.modifiers, this.interfaceKeyword, this.identifier, typeParameterList, this.heritageClauses, this.body);
        };

        InterfaceDeclarationSyntax.prototype.withHeritageClauses = function (heritageClauses) {
            return this.update(this.modifiers, this.interfaceKeyword, this.identifier, this.typeParameterList, heritageClauses, this.body);
        };

        InterfaceDeclarationSyntax.prototype.withHeritageClause = function (heritageClause) {
            return this.withHeritageClauses(TypeScript.Syntax.list([heritageClause]));
        };

        InterfaceDeclarationSyntax.prototype.withBody = function (body) {
            return this.update(this.modifiers, this.interfaceKeyword, this.identifier, this.typeParameterList, this.heritageClauses, body);
        };

        InterfaceDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return InterfaceDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.InterfaceDeclarationSyntax = InterfaceDeclarationSyntax;

    var HeritageClauseSyntax = (function (_super) {
        __extends(HeritageClauseSyntax, _super);
        function HeritageClauseSyntax(extendsOrImplementsKeyword, typeNames, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.extendsOrImplementsKeyword = extendsOrImplementsKeyword;
            this.typeNames = typeNames;
        }
        HeritageClauseSyntax.prototype.accept = function (visitor) {
            return visitor.visitHeritageClause(this);
        };

        HeritageClauseSyntax.prototype.kind = function () {
            return 229 /* HeritageClause */;
        };

        HeritageClauseSyntax.prototype.childCount = function () {
            return 2;
        };

        HeritageClauseSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.extendsOrImplementsKeyword;
                case 1:
                    return this.typeNames;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        HeritageClauseSyntax.prototype.update = function (extendsOrImplementsKeyword, typeNames) {
            if (this.extendsOrImplementsKeyword === extendsOrImplementsKeyword && this.typeNames === typeNames) {
                return this;
            }

            return new HeritageClauseSyntax(extendsOrImplementsKeyword, typeNames, this.parsedInStrictMode());
        };

        HeritageClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        HeritageClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        HeritageClauseSyntax.prototype.withExtendsOrImplementsKeyword = function (extendsOrImplementsKeyword) {
            return this.update(extendsOrImplementsKeyword, this.typeNames);
        };

        HeritageClauseSyntax.prototype.withTypeNames = function (typeNames) {
            return this.update(this.extendsOrImplementsKeyword, typeNames);
        };

        HeritageClauseSyntax.prototype.withTypeName = function (typeName) {
            return this.withTypeNames(TypeScript.Syntax.separatedList([typeName]));
        };

        HeritageClauseSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return HeritageClauseSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.HeritageClauseSyntax = HeritageClauseSyntax;

    var ModuleDeclarationSyntax = (function (_super) {
        __extends(ModuleDeclarationSyntax, _super);
        function ModuleDeclarationSyntax(modifiers, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.modifiers = modifiers;
            this.moduleKeyword = moduleKeyword;
            this.moduleName = moduleName;
            this.stringLiteral = stringLiteral;
            this.openBraceToken = openBraceToken;
            this.moduleElements = moduleElements;
            this.closeBraceToken = closeBraceToken;
        }
        ModuleDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitModuleDeclaration(this);
        };

        ModuleDeclarationSyntax.prototype.kind = function () {
            return 130 /* ModuleDeclaration */;
        };

        ModuleDeclarationSyntax.prototype.childCount = function () {
            return 7;
        };

        ModuleDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.moduleKeyword;
                case 2:
                    return this.moduleName;
                case 3:
                    return this.stringLiteral;
                case 4:
                    return this.openBraceToken;
                case 5:
                    return this.moduleElements;
                case 6:
                    return this.closeBraceToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ModuleDeclarationSyntax.prototype.isModuleElement = function () {
            return true;
        };

        ModuleDeclarationSyntax.prototype.update = function (modifiers, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken) {
            if (this.modifiers === modifiers && this.moduleKeyword === moduleKeyword && this.moduleName === moduleName && this.stringLiteral === stringLiteral && this.openBraceToken === openBraceToken && this.moduleElements === moduleElements && this.closeBraceToken === closeBraceToken) {
                return this;
            }

            return new ModuleDeclarationSyntax(modifiers, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken, this.parsedInStrictMode());
        };

        ModuleDeclarationSyntax.create = function (moduleKeyword, openBraceToken, closeBraceToken) {
            return new ModuleDeclarationSyntax(TypeScript.Syntax.emptyList, moduleKeyword, null, null, openBraceToken, TypeScript.Syntax.emptyList, closeBraceToken, false);
        };

        ModuleDeclarationSyntax.create1 = function () {
            return new ModuleDeclarationSyntax(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(65 /* ModuleKeyword */), null, null, TypeScript.Syntax.token(70 /* OpenBraceToken */), TypeScript.Syntax.emptyList, TypeScript.Syntax.token(71 /* CloseBraceToken */), false);
        };

        ModuleDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ModuleDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ModuleDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.moduleKeyword, this.moduleName, this.stringLiteral, this.openBraceToken, this.moduleElements, this.closeBraceToken);
        };

        ModuleDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };

        ModuleDeclarationSyntax.prototype.withModuleKeyword = function (moduleKeyword) {
            return this.update(this.modifiers, moduleKeyword, this.moduleName, this.stringLiteral, this.openBraceToken, this.moduleElements, this.closeBraceToken);
        };

        ModuleDeclarationSyntax.prototype.withModuleName = function (moduleName) {
            return this.update(this.modifiers, this.moduleKeyword, moduleName, this.stringLiteral, this.openBraceToken, this.moduleElements, this.closeBraceToken);
        };

        ModuleDeclarationSyntax.prototype.withStringLiteral = function (stringLiteral) {
            return this.update(this.modifiers, this.moduleKeyword, this.moduleName, stringLiteral, this.openBraceToken, this.moduleElements, this.closeBraceToken);
        };

        ModuleDeclarationSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
            return this.update(this.modifiers, this.moduleKeyword, this.moduleName, this.stringLiteral, openBraceToken, this.moduleElements, this.closeBraceToken);
        };

        ModuleDeclarationSyntax.prototype.withModuleElements = function (moduleElements) {
            return this.update(this.modifiers, this.moduleKeyword, this.moduleName, this.stringLiteral, this.openBraceToken, moduleElements, this.closeBraceToken);
        };

        ModuleDeclarationSyntax.prototype.withModuleElement = function (moduleElement) {
            return this.withModuleElements(TypeScript.Syntax.list([moduleElement]));
        };

        ModuleDeclarationSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
            return this.update(this.modifiers, this.moduleKeyword, this.moduleName, this.stringLiteral, this.openBraceToken, this.moduleElements, closeBraceToken);
        };

        ModuleDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ModuleDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ModuleDeclarationSyntax = ModuleDeclarationSyntax;

    var FunctionDeclarationSyntax = (function (_super) {
        __extends(FunctionDeclarationSyntax, _super);
        function FunctionDeclarationSyntax(modifiers, functionKeyword, identifier, callSignature, block, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.modifiers = modifiers;
            this.functionKeyword = functionKeyword;
            this.identifier = identifier;
            this.callSignature = callSignature;
            this.block = block;
            this.semicolonToken = semicolonToken;
        }
        FunctionDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitFunctionDeclaration(this);
        };

        FunctionDeclarationSyntax.prototype.kind = function () {
            return 129 /* FunctionDeclaration */;
        };

        FunctionDeclarationSyntax.prototype.childCount = function () {
            return 6;
        };

        FunctionDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.functionKeyword;
                case 2:
                    return this.identifier;
                case 3:
                    return this.callSignature;
                case 4:
                    return this.block;
                case 5:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        FunctionDeclarationSyntax.prototype.isStatement = function () {
            return true;
        };

        FunctionDeclarationSyntax.prototype.isModuleElement = function () {
            return true;
        };

        FunctionDeclarationSyntax.prototype.update = function (modifiers, functionKeyword, identifier, callSignature, block, semicolonToken) {
            if (this.modifiers === modifiers && this.functionKeyword === functionKeyword && this.identifier === identifier && this.callSignature === callSignature && this.block === block && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new FunctionDeclarationSyntax(modifiers, functionKeyword, identifier, callSignature, block, semicolonToken, this.parsedInStrictMode());
        };

        FunctionDeclarationSyntax.create = function (functionKeyword, identifier, callSignature) {
            return new FunctionDeclarationSyntax(TypeScript.Syntax.emptyList, functionKeyword, identifier, callSignature, null, null, false);
        };

        FunctionDeclarationSyntax.create1 = function (identifier) {
            return new FunctionDeclarationSyntax(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(27 /* FunctionKeyword */), identifier, CallSignatureSyntax.create1(), null, null, false);
        };

        FunctionDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        FunctionDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        FunctionDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.functionKeyword, this.identifier, this.callSignature, this.block, this.semicolonToken);
        };

        FunctionDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };

        FunctionDeclarationSyntax.prototype.withFunctionKeyword = function (functionKeyword) {
            return this.update(this.modifiers, functionKeyword, this.identifier, this.callSignature, this.block, this.semicolonToken);
        };

        FunctionDeclarationSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.modifiers, this.functionKeyword, identifier, this.callSignature, this.block, this.semicolonToken);
        };

        FunctionDeclarationSyntax.prototype.withCallSignature = function (callSignature) {
            return this.update(this.modifiers, this.functionKeyword, this.identifier, callSignature, this.block, this.semicolonToken);
        };

        FunctionDeclarationSyntax.prototype.withBlock = function (block) {
            return this.update(this.modifiers, this.functionKeyword, this.identifier, this.callSignature, block, this.semicolonToken);
        };

        FunctionDeclarationSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.modifiers, this.functionKeyword, this.identifier, this.callSignature, this.block, semicolonToken);
        };

        FunctionDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.modifiers.isTypeScriptSpecific()) {
                return true;
            }
            if (this.callSignature.isTypeScriptSpecific()) {
                return true;
            }
            if (this.block !== null && this.block.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return FunctionDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.FunctionDeclarationSyntax = FunctionDeclarationSyntax;

    var VariableStatementSyntax = (function (_super) {
        __extends(VariableStatementSyntax, _super);
        function VariableStatementSyntax(modifiers, variableDeclaration, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.modifiers = modifiers;
            this.variableDeclaration = variableDeclaration;
            this.semicolonToken = semicolonToken;
        }
        VariableStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitVariableStatement(this);
        };

        VariableStatementSyntax.prototype.kind = function () {
            return 147 /* VariableStatement */;
        };

        VariableStatementSyntax.prototype.childCount = function () {
            return 3;
        };

        VariableStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.variableDeclaration;
                case 2:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        VariableStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        VariableStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        VariableStatementSyntax.prototype.update = function (modifiers, variableDeclaration, semicolonToken) {
            if (this.modifiers === modifiers && this.variableDeclaration === variableDeclaration && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new VariableStatementSyntax(modifiers, variableDeclaration, semicolonToken, this.parsedInStrictMode());
        };

        VariableStatementSyntax.create = function (variableDeclaration, semicolonToken) {
            return new VariableStatementSyntax(TypeScript.Syntax.emptyList, variableDeclaration, semicolonToken, false);
        };

        VariableStatementSyntax.create1 = function (variableDeclaration) {
            return new VariableStatementSyntax(TypeScript.Syntax.emptyList, variableDeclaration, TypeScript.Syntax.token(78 /* SemicolonToken */), false);
        };

        VariableStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        VariableStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        VariableStatementSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.variableDeclaration, this.semicolonToken);
        };

        VariableStatementSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };

        VariableStatementSyntax.prototype.withVariableDeclaration = function (variableDeclaration) {
            return this.update(this.modifiers, variableDeclaration, this.semicolonToken);
        };

        VariableStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.modifiers, this.variableDeclaration, semicolonToken);
        };

        VariableStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.modifiers.isTypeScriptSpecific()) {
                return true;
            }
            if (this.variableDeclaration.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return VariableStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.VariableStatementSyntax = VariableStatementSyntax;

    var VariableDeclarationSyntax = (function (_super) {
        __extends(VariableDeclarationSyntax, _super);
        function VariableDeclarationSyntax(varKeyword, variableDeclarators, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.varKeyword = varKeyword;
            this.variableDeclarators = variableDeclarators;
        }
        VariableDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitVariableDeclaration(this);
        };

        VariableDeclarationSyntax.prototype.kind = function () {
            return 223 /* VariableDeclaration */;
        };

        VariableDeclarationSyntax.prototype.childCount = function () {
            return 2;
        };

        VariableDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.varKeyword;
                case 1:
                    return this.variableDeclarators;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        VariableDeclarationSyntax.prototype.update = function (varKeyword, variableDeclarators) {
            if (this.varKeyword === varKeyword && this.variableDeclarators === variableDeclarators) {
                return this;
            }

            return new VariableDeclarationSyntax(varKeyword, variableDeclarators, this.parsedInStrictMode());
        };

        VariableDeclarationSyntax.create1 = function (variableDeclarators) {
            return new VariableDeclarationSyntax(TypeScript.Syntax.token(40 /* VarKeyword */), variableDeclarators, false);
        };

        VariableDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        VariableDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        VariableDeclarationSyntax.prototype.withVarKeyword = function (varKeyword) {
            return this.update(varKeyword, this.variableDeclarators);
        };

        VariableDeclarationSyntax.prototype.withVariableDeclarators = function (variableDeclarators) {
            return this.update(this.varKeyword, variableDeclarators);
        };

        VariableDeclarationSyntax.prototype.withVariableDeclarator = function (variableDeclarator) {
            return this.withVariableDeclarators(TypeScript.Syntax.separatedList([variableDeclarator]));
        };

        VariableDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.variableDeclarators.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return VariableDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.VariableDeclarationSyntax = VariableDeclarationSyntax;

    var VariableDeclaratorSyntax = (function (_super) {
        __extends(VariableDeclaratorSyntax, _super);
        function VariableDeclaratorSyntax(identifier, typeAnnotation, equalsValueClause, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.identifier = identifier;
            this.typeAnnotation = typeAnnotation;
            this.equalsValueClause = equalsValueClause;
        }
        VariableDeclaratorSyntax.prototype.accept = function (visitor) {
            return visitor.visitVariableDeclarator(this);
        };

        VariableDeclaratorSyntax.prototype.kind = function () {
            return 224 /* VariableDeclarator */;
        };

        VariableDeclaratorSyntax.prototype.childCount = function () {
            return 3;
        };

        VariableDeclaratorSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.identifier;
                case 1:
                    return this.typeAnnotation;
                case 2:
                    return this.equalsValueClause;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        VariableDeclaratorSyntax.prototype.update = function (identifier, typeAnnotation, equalsValueClause) {
            if (this.identifier === identifier && this.typeAnnotation === typeAnnotation && this.equalsValueClause === equalsValueClause) {
                return this;
            }

            return new VariableDeclaratorSyntax(identifier, typeAnnotation, equalsValueClause, this.parsedInStrictMode());
        };

        VariableDeclaratorSyntax.create = function (identifier) {
            return new VariableDeclaratorSyntax(identifier, null, null, false);
        };

        VariableDeclaratorSyntax.create1 = function (identifier) {
            return new VariableDeclaratorSyntax(identifier, null, null, false);
        };

        VariableDeclaratorSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        VariableDeclaratorSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        VariableDeclaratorSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(identifier, this.typeAnnotation, this.equalsValueClause);
        };

        VariableDeclaratorSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
            return this.update(this.identifier, typeAnnotation, this.equalsValueClause);
        };

        VariableDeclaratorSyntax.prototype.withEqualsValueClause = function (equalsValueClause) {
            return this.update(this.identifier, this.typeAnnotation, equalsValueClause);
        };

        VariableDeclaratorSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.typeAnnotation !== null) {
                return true;
            }
            if (this.equalsValueClause !== null && this.equalsValueClause.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return VariableDeclaratorSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.VariableDeclaratorSyntax = VariableDeclaratorSyntax;

    var EqualsValueClauseSyntax = (function (_super) {
        __extends(EqualsValueClauseSyntax, _super);
        function EqualsValueClauseSyntax(equalsToken, value, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.equalsToken = equalsToken;
            this.value = value;
        }
        EqualsValueClauseSyntax.prototype.accept = function (visitor) {
            return visitor.visitEqualsValueClause(this);
        };

        EqualsValueClauseSyntax.prototype.kind = function () {
            return 230 /* EqualsValueClause */;
        };

        EqualsValueClauseSyntax.prototype.childCount = function () {
            return 2;
        };

        EqualsValueClauseSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.equalsToken;
                case 1:
                    return this.value;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        EqualsValueClauseSyntax.prototype.update = function (equalsToken, value) {
            if (this.equalsToken === equalsToken && this.value === value) {
                return this;
            }

            return new EqualsValueClauseSyntax(equalsToken, value, this.parsedInStrictMode());
        };

        EqualsValueClauseSyntax.create1 = function (value) {
            return new EqualsValueClauseSyntax(TypeScript.Syntax.token(107 /* EqualsToken */), value, false);
        };

        EqualsValueClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        EqualsValueClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        EqualsValueClauseSyntax.prototype.withEqualsToken = function (equalsToken) {
            return this.update(equalsToken, this.value);
        };

        EqualsValueClauseSyntax.prototype.withValue = function (value) {
            return this.update(this.equalsToken, value);
        };

        EqualsValueClauseSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.value.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return EqualsValueClauseSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.EqualsValueClauseSyntax = EqualsValueClauseSyntax;

    var PrefixUnaryExpressionSyntax = (function (_super) {
        __extends(PrefixUnaryExpressionSyntax, _super);
        function PrefixUnaryExpressionSyntax(kind, operatorToken, operand, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.operatorToken = operatorToken;
            this.operand = operand;

            this._kind = kind;
        }
        PrefixUnaryExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitPrefixUnaryExpression(this);
        };

        PrefixUnaryExpressionSyntax.prototype.childCount = function () {
            return 2;
        };

        PrefixUnaryExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.operatorToken;
                case 1:
                    return this.operand;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        PrefixUnaryExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        PrefixUnaryExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        PrefixUnaryExpressionSyntax.prototype.kind = function () {
            return this._kind;
        };

        PrefixUnaryExpressionSyntax.prototype.update = function (kind, operatorToken, operand) {
            if (this._kind === kind && this.operatorToken === operatorToken && this.operand === operand) {
                return this;
            }

            return new PrefixUnaryExpressionSyntax(kind, operatorToken, operand, this.parsedInStrictMode());
        };

        PrefixUnaryExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        PrefixUnaryExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        PrefixUnaryExpressionSyntax.prototype.withKind = function (kind) {
            return this.update(kind, this.operatorToken, this.operand);
        };

        PrefixUnaryExpressionSyntax.prototype.withOperatorToken = function (operatorToken) {
            return this.update(this._kind, operatorToken, this.operand);
        };

        PrefixUnaryExpressionSyntax.prototype.withOperand = function (operand) {
            return this.update(this._kind, this.operatorToken, operand);
        };

        PrefixUnaryExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.operand.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return PrefixUnaryExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.PrefixUnaryExpressionSyntax = PrefixUnaryExpressionSyntax;

    var ArrayLiteralExpressionSyntax = (function (_super) {
        __extends(ArrayLiteralExpressionSyntax, _super);
        function ArrayLiteralExpressionSyntax(openBracketToken, expressions, closeBracketToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.openBracketToken = openBracketToken;
            this.expressions = expressions;
            this.closeBracketToken = closeBracketToken;
        }
        ArrayLiteralExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitArrayLiteralExpression(this);
        };

        ArrayLiteralExpressionSyntax.prototype.kind = function () {
            return 213 /* ArrayLiteralExpression */;
        };

        ArrayLiteralExpressionSyntax.prototype.childCount = function () {
            return 3;
        };

        ArrayLiteralExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.openBracketToken;
                case 1:
                    return this.expressions;
                case 2:
                    return this.closeBracketToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ArrayLiteralExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        ArrayLiteralExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        ArrayLiteralExpressionSyntax.prototype.update = function (openBracketToken, expressions, closeBracketToken) {
            if (this.openBracketToken === openBracketToken && this.expressions === expressions && this.closeBracketToken === closeBracketToken) {
                return this;
            }

            return new ArrayLiteralExpressionSyntax(openBracketToken, expressions, closeBracketToken, this.parsedInStrictMode());
        };

        ArrayLiteralExpressionSyntax.create = function (openBracketToken, closeBracketToken) {
            return new ArrayLiteralExpressionSyntax(openBracketToken, TypeScript.Syntax.emptySeparatedList, closeBracketToken, false);
        };

        ArrayLiteralExpressionSyntax.create1 = function () {
            return new ArrayLiteralExpressionSyntax(TypeScript.Syntax.token(74 /* OpenBracketToken */), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.token(75 /* CloseBracketToken */), false);
        };

        ArrayLiteralExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ArrayLiteralExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ArrayLiteralExpressionSyntax.prototype.withOpenBracketToken = function (openBracketToken) {
            return this.update(openBracketToken, this.expressions, this.closeBracketToken);
        };

        ArrayLiteralExpressionSyntax.prototype.withExpressions = function (expressions) {
            return this.update(this.openBracketToken, expressions, this.closeBracketToken);
        };

        ArrayLiteralExpressionSyntax.prototype.withExpression = function (expression) {
            return this.withExpressions(TypeScript.Syntax.separatedList([expression]));
        };

        ArrayLiteralExpressionSyntax.prototype.withCloseBracketToken = function (closeBracketToken) {
            return this.update(this.openBracketToken, this.expressions, closeBracketToken);
        };

        ArrayLiteralExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expressions.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ArrayLiteralExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ArrayLiteralExpressionSyntax = ArrayLiteralExpressionSyntax;

    var OmittedExpressionSyntax = (function (_super) {
        __extends(OmittedExpressionSyntax, _super);
        function OmittedExpressionSyntax(parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
        }
        OmittedExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitOmittedExpression(this);
        };

        OmittedExpressionSyntax.prototype.kind = function () {
            return 222 /* OmittedExpression */;
        };

        OmittedExpressionSyntax.prototype.childCount = function () {
            return 0;
        };

        OmittedExpressionSyntax.prototype.childAt = function (slot) {
            throw TypeScript.Errors.invalidOperation();
        };

        OmittedExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        OmittedExpressionSyntax.prototype.update = function () {
            return this;
        };

        OmittedExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        OmittedExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        OmittedExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return OmittedExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.OmittedExpressionSyntax = OmittedExpressionSyntax;

    var ParenthesizedExpressionSyntax = (function (_super) {
        __extends(ParenthesizedExpressionSyntax, _super);
        function ParenthesizedExpressionSyntax(openParenToken, expression, closeParenToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.openParenToken = openParenToken;
            this.expression = expression;
            this.closeParenToken = closeParenToken;
        }
        ParenthesizedExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitParenthesizedExpression(this);
        };

        ParenthesizedExpressionSyntax.prototype.kind = function () {
            return 216 /* ParenthesizedExpression */;
        };

        ParenthesizedExpressionSyntax.prototype.childCount = function () {
            return 3;
        };

        ParenthesizedExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.openParenToken;
                case 1:
                    return this.expression;
                case 2:
                    return this.closeParenToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ParenthesizedExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        ParenthesizedExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        ParenthesizedExpressionSyntax.prototype.update = function (openParenToken, expression, closeParenToken) {
            if (this.openParenToken === openParenToken && this.expression === expression && this.closeParenToken === closeParenToken) {
                return this;
            }

            return new ParenthesizedExpressionSyntax(openParenToken, expression, closeParenToken, this.parsedInStrictMode());
        };

        ParenthesizedExpressionSyntax.create1 = function (expression) {
            return new ParenthesizedExpressionSyntax(TypeScript.Syntax.token(72 /* OpenParenToken */), expression, TypeScript.Syntax.token(73 /* CloseParenToken */), false);
        };

        ParenthesizedExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ParenthesizedExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ParenthesizedExpressionSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(openParenToken, this.expression, this.closeParenToken);
        };

        ParenthesizedExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(this.openParenToken, expression, this.closeParenToken);
        };

        ParenthesizedExpressionSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.openParenToken, this.expression, closeParenToken);
        };

        ParenthesizedExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ParenthesizedExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ParenthesizedExpressionSyntax = ParenthesizedExpressionSyntax;

    var ArrowFunctionExpressionSyntax = (function (_super) {
        __extends(ArrowFunctionExpressionSyntax, _super);
        function ArrowFunctionExpressionSyntax(equalsGreaterThanToken, body, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.equalsGreaterThanToken = equalsGreaterThanToken;
            this.body = body;
        }
        ArrowFunctionExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        ArrowFunctionExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        ArrowFunctionExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ArrowFunctionExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ArrowFunctionExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ArrowFunctionExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ArrowFunctionExpressionSyntax = ArrowFunctionExpressionSyntax;

    var SimpleArrowFunctionExpressionSyntax = (function (_super) {
        __extends(SimpleArrowFunctionExpressionSyntax, _super);
        function SimpleArrowFunctionExpressionSyntax(identifier, equalsGreaterThanToken, body, parsedInStrictMode) {
            _super.call(this, equalsGreaterThanToken, body, parsedInStrictMode);
            this.identifier = identifier;
        }
        SimpleArrowFunctionExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitSimpleArrowFunctionExpression(this);
        };

        SimpleArrowFunctionExpressionSyntax.prototype.kind = function () {
            return 218 /* SimpleArrowFunctionExpression */;
        };

        SimpleArrowFunctionExpressionSyntax.prototype.childCount = function () {
            return 3;
        };

        SimpleArrowFunctionExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.identifier;
                case 1:
                    return this.equalsGreaterThanToken;
                case 2:
                    return this.body;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        SimpleArrowFunctionExpressionSyntax.prototype.update = function (identifier, equalsGreaterThanToken, body) {
            if (this.identifier === identifier && this.equalsGreaterThanToken === equalsGreaterThanToken && this.body === body) {
                return this;
            }

            return new SimpleArrowFunctionExpressionSyntax(identifier, equalsGreaterThanToken, body, this.parsedInStrictMode());
        };

        SimpleArrowFunctionExpressionSyntax.create1 = function (identifier, body) {
            return new SimpleArrowFunctionExpressionSyntax(identifier, TypeScript.Syntax.token(85 /* EqualsGreaterThanToken */), body, false);
        };

        SimpleArrowFunctionExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        SimpleArrowFunctionExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        SimpleArrowFunctionExpressionSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(identifier, this.equalsGreaterThanToken, this.body);
        };

        SimpleArrowFunctionExpressionSyntax.prototype.withEqualsGreaterThanToken = function (equalsGreaterThanToken) {
            return this.update(this.identifier, equalsGreaterThanToken, this.body);
        };

        SimpleArrowFunctionExpressionSyntax.prototype.withBody = function (body) {
            return this.update(this.identifier, this.equalsGreaterThanToken, body);
        };

        SimpleArrowFunctionExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return SimpleArrowFunctionExpressionSyntax;
    })(ArrowFunctionExpressionSyntax);
    TypeScript.SimpleArrowFunctionExpressionSyntax = SimpleArrowFunctionExpressionSyntax;

    var ParenthesizedArrowFunctionExpressionSyntax = (function (_super) {
        __extends(ParenthesizedArrowFunctionExpressionSyntax, _super);
        function ParenthesizedArrowFunctionExpressionSyntax(callSignature, equalsGreaterThanToken, body, parsedInStrictMode) {
            _super.call(this, equalsGreaterThanToken, body, parsedInStrictMode);
            this.callSignature = callSignature;
        }
        ParenthesizedArrowFunctionExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitParenthesizedArrowFunctionExpression(this);
        };

        ParenthesizedArrowFunctionExpressionSyntax.prototype.kind = function () {
            return 217 /* ParenthesizedArrowFunctionExpression */;
        };

        ParenthesizedArrowFunctionExpressionSyntax.prototype.childCount = function () {
            return 3;
        };

        ParenthesizedArrowFunctionExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.callSignature;
                case 1:
                    return this.equalsGreaterThanToken;
                case 2:
                    return this.body;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ParenthesizedArrowFunctionExpressionSyntax.prototype.update = function (callSignature, equalsGreaterThanToken, body) {
            if (this.callSignature === callSignature && this.equalsGreaterThanToken === equalsGreaterThanToken && this.body === body) {
                return this;
            }

            return new ParenthesizedArrowFunctionExpressionSyntax(callSignature, equalsGreaterThanToken, body, this.parsedInStrictMode());
        };

        ParenthesizedArrowFunctionExpressionSyntax.create1 = function (body) {
            return new ParenthesizedArrowFunctionExpressionSyntax(CallSignatureSyntax.create1(), TypeScript.Syntax.token(85 /* EqualsGreaterThanToken */), body, false);
        };

        ParenthesizedArrowFunctionExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ParenthesizedArrowFunctionExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ParenthesizedArrowFunctionExpressionSyntax.prototype.withCallSignature = function (callSignature) {
            return this.update(callSignature, this.equalsGreaterThanToken, this.body);
        };

        ParenthesizedArrowFunctionExpressionSyntax.prototype.withEqualsGreaterThanToken = function (equalsGreaterThanToken) {
            return this.update(this.callSignature, equalsGreaterThanToken, this.body);
        };

        ParenthesizedArrowFunctionExpressionSyntax.prototype.withBody = function (body) {
            return this.update(this.callSignature, this.equalsGreaterThanToken, body);
        };

        ParenthesizedArrowFunctionExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ParenthesizedArrowFunctionExpressionSyntax;
    })(ArrowFunctionExpressionSyntax);
    TypeScript.ParenthesizedArrowFunctionExpressionSyntax = ParenthesizedArrowFunctionExpressionSyntax;

    var QualifiedNameSyntax = (function (_super) {
        __extends(QualifiedNameSyntax, _super);
        function QualifiedNameSyntax(left, dotToken, right, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.left = left;
            this.dotToken = dotToken;
            this.right = right;
        }
        QualifiedNameSyntax.prototype.accept = function (visitor) {
            return visitor.visitQualifiedName(this);
        };

        QualifiedNameSyntax.prototype.kind = function () {
            return 121 /* QualifiedName */;
        };

        QualifiedNameSyntax.prototype.childCount = function () {
            return 3;
        };

        QualifiedNameSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.left;
                case 1:
                    return this.dotToken;
                case 2:
                    return this.right;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        QualifiedNameSyntax.prototype.isName = function () {
            return true;
        };

        QualifiedNameSyntax.prototype.isType = function () {
            return true;
        };

        QualifiedNameSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        QualifiedNameSyntax.prototype.isExpression = function () {
            return true;
        };

        QualifiedNameSyntax.prototype.update = function (left, dotToken, right) {
            if (this.left === left && this.dotToken === dotToken && this.right === right) {
                return this;
            }

            return new QualifiedNameSyntax(left, dotToken, right, this.parsedInStrictMode());
        };

        QualifiedNameSyntax.create1 = function (left, right) {
            return new QualifiedNameSyntax(left, TypeScript.Syntax.token(76 /* DotToken */), right, false);
        };

        QualifiedNameSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        QualifiedNameSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        QualifiedNameSyntax.prototype.withLeft = function (left) {
            return this.update(left, this.dotToken, this.right);
        };

        QualifiedNameSyntax.prototype.withDotToken = function (dotToken) {
            return this.update(this.left, dotToken, this.right);
        };

        QualifiedNameSyntax.prototype.withRight = function (right) {
            return this.update(this.left, this.dotToken, right);
        };

        QualifiedNameSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return QualifiedNameSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.QualifiedNameSyntax = QualifiedNameSyntax;

    var TypeArgumentListSyntax = (function (_super) {
        __extends(TypeArgumentListSyntax, _super);
        function TypeArgumentListSyntax(lessThanToken, typeArguments, greaterThanToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.lessThanToken = lessThanToken;
            this.typeArguments = typeArguments;
            this.greaterThanToken = greaterThanToken;
        }
        TypeArgumentListSyntax.prototype.accept = function (visitor) {
            return visitor.visitTypeArgumentList(this);
        };

        TypeArgumentListSyntax.prototype.kind = function () {
            return 227 /* TypeArgumentList */;
        };

        TypeArgumentListSyntax.prototype.childCount = function () {
            return 3;
        };

        TypeArgumentListSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.lessThanToken;
                case 1:
                    return this.typeArguments;
                case 2:
                    return this.greaterThanToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        TypeArgumentListSyntax.prototype.update = function (lessThanToken, typeArguments, greaterThanToken) {
            if (this.lessThanToken === lessThanToken && this.typeArguments === typeArguments && this.greaterThanToken === greaterThanToken) {
                return this;
            }

            return new TypeArgumentListSyntax(lessThanToken, typeArguments, greaterThanToken, this.parsedInStrictMode());
        };

        TypeArgumentListSyntax.create = function (lessThanToken, greaterThanToken) {
            return new TypeArgumentListSyntax(lessThanToken, TypeScript.Syntax.emptySeparatedList, greaterThanToken, false);
        };

        TypeArgumentListSyntax.create1 = function () {
            return new TypeArgumentListSyntax(TypeScript.Syntax.token(80 /* LessThanToken */), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.token(81 /* GreaterThanToken */), false);
        };

        TypeArgumentListSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        TypeArgumentListSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        TypeArgumentListSyntax.prototype.withLessThanToken = function (lessThanToken) {
            return this.update(lessThanToken, this.typeArguments, this.greaterThanToken);
        };

        TypeArgumentListSyntax.prototype.withTypeArguments = function (typeArguments) {
            return this.update(this.lessThanToken, typeArguments, this.greaterThanToken);
        };

        TypeArgumentListSyntax.prototype.withTypeArgument = function (typeArgument) {
            return this.withTypeArguments(TypeScript.Syntax.separatedList([typeArgument]));
        };

        TypeArgumentListSyntax.prototype.withGreaterThanToken = function (greaterThanToken) {
            return this.update(this.lessThanToken, this.typeArguments, greaterThanToken);
        };

        TypeArgumentListSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return TypeArgumentListSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.TypeArgumentListSyntax = TypeArgumentListSyntax;

    var ConstructorTypeSyntax = (function (_super) {
        __extends(ConstructorTypeSyntax, _super);
        function ConstructorTypeSyntax(newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.newKeyword = newKeyword;
            this.typeParameterList = typeParameterList;
            this.parameterList = parameterList;
            this.equalsGreaterThanToken = equalsGreaterThanToken;
            this.type = type;
        }
        ConstructorTypeSyntax.prototype.accept = function (visitor) {
            return visitor.visitConstructorType(this);
        };

        ConstructorTypeSyntax.prototype.kind = function () {
            return 125 /* ConstructorType */;
        };

        ConstructorTypeSyntax.prototype.childCount = function () {
            return 5;
        };

        ConstructorTypeSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.newKeyword;
                case 1:
                    return this.typeParameterList;
                case 2:
                    return this.parameterList;
                case 3:
                    return this.equalsGreaterThanToken;
                case 4:
                    return this.type;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ConstructorTypeSyntax.prototype.isType = function () {
            return true;
        };

        ConstructorTypeSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        ConstructorTypeSyntax.prototype.isExpression = function () {
            return true;
        };

        ConstructorTypeSyntax.prototype.update = function (newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type) {
            if (this.newKeyword === newKeyword && this.typeParameterList === typeParameterList && this.parameterList === parameterList && this.equalsGreaterThanToken === equalsGreaterThanToken && this.type === type) {
                return this;
            }

            return new ConstructorTypeSyntax(newKeyword, typeParameterList, parameterList, equalsGreaterThanToken, type, this.parsedInStrictMode());
        };

        ConstructorTypeSyntax.create = function (newKeyword, parameterList, equalsGreaterThanToken, type) {
            return new ConstructorTypeSyntax(newKeyword, null, parameterList, equalsGreaterThanToken, type, false);
        };

        ConstructorTypeSyntax.create1 = function (type) {
            return new ConstructorTypeSyntax(TypeScript.Syntax.token(31 /* NewKeyword */), null, ParameterListSyntax.create1(), TypeScript.Syntax.token(85 /* EqualsGreaterThanToken */), type, false);
        };

        ConstructorTypeSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ConstructorTypeSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ConstructorTypeSyntax.prototype.withNewKeyword = function (newKeyword) {
            return this.update(newKeyword, this.typeParameterList, this.parameterList, this.equalsGreaterThanToken, this.type);
        };

        ConstructorTypeSyntax.prototype.withTypeParameterList = function (typeParameterList) {
            return this.update(this.newKeyword, typeParameterList, this.parameterList, this.equalsGreaterThanToken, this.type);
        };

        ConstructorTypeSyntax.prototype.withParameterList = function (parameterList) {
            return this.update(this.newKeyword, this.typeParameterList, parameterList, this.equalsGreaterThanToken, this.type);
        };

        ConstructorTypeSyntax.prototype.withEqualsGreaterThanToken = function (equalsGreaterThanToken) {
            return this.update(this.newKeyword, this.typeParameterList, this.parameterList, equalsGreaterThanToken, this.type);
        };

        ConstructorTypeSyntax.prototype.withType = function (type) {
            return this.update(this.newKeyword, this.typeParameterList, this.parameterList, this.equalsGreaterThanToken, type);
        };

        ConstructorTypeSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ConstructorTypeSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ConstructorTypeSyntax = ConstructorTypeSyntax;

    var FunctionTypeSyntax = (function (_super) {
        __extends(FunctionTypeSyntax, _super);
        function FunctionTypeSyntax(typeParameterList, parameterList, equalsGreaterThanToken, type, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.typeParameterList = typeParameterList;
            this.parameterList = parameterList;
            this.equalsGreaterThanToken = equalsGreaterThanToken;
            this.type = type;
        }
        FunctionTypeSyntax.prototype.accept = function (visitor) {
            return visitor.visitFunctionType(this);
        };

        FunctionTypeSyntax.prototype.kind = function () {
            return 123 /* FunctionType */;
        };

        FunctionTypeSyntax.prototype.childCount = function () {
            return 4;
        };

        FunctionTypeSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.typeParameterList;
                case 1:
                    return this.parameterList;
                case 2:
                    return this.equalsGreaterThanToken;
                case 3:
                    return this.type;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        FunctionTypeSyntax.prototype.isType = function () {
            return true;
        };

        FunctionTypeSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        FunctionTypeSyntax.prototype.isExpression = function () {
            return true;
        };

        FunctionTypeSyntax.prototype.update = function (typeParameterList, parameterList, equalsGreaterThanToken, type) {
            if (this.typeParameterList === typeParameterList && this.parameterList === parameterList && this.equalsGreaterThanToken === equalsGreaterThanToken && this.type === type) {
                return this;
            }

            return new FunctionTypeSyntax(typeParameterList, parameterList, equalsGreaterThanToken, type, this.parsedInStrictMode());
        };

        FunctionTypeSyntax.create = function (parameterList, equalsGreaterThanToken, type) {
            return new FunctionTypeSyntax(null, parameterList, equalsGreaterThanToken, type, false);
        };

        FunctionTypeSyntax.create1 = function (type) {
            return new FunctionTypeSyntax(null, ParameterListSyntax.create1(), TypeScript.Syntax.token(85 /* EqualsGreaterThanToken */), type, false);
        };

        FunctionTypeSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        FunctionTypeSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        FunctionTypeSyntax.prototype.withTypeParameterList = function (typeParameterList) {
            return this.update(typeParameterList, this.parameterList, this.equalsGreaterThanToken, this.type);
        };

        FunctionTypeSyntax.prototype.withParameterList = function (parameterList) {
            return this.update(this.typeParameterList, parameterList, this.equalsGreaterThanToken, this.type);
        };

        FunctionTypeSyntax.prototype.withEqualsGreaterThanToken = function (equalsGreaterThanToken) {
            return this.update(this.typeParameterList, this.parameterList, equalsGreaterThanToken, this.type);
        };

        FunctionTypeSyntax.prototype.withType = function (type) {
            return this.update(this.typeParameterList, this.parameterList, this.equalsGreaterThanToken, type);
        };

        FunctionTypeSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return FunctionTypeSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.FunctionTypeSyntax = FunctionTypeSyntax;

    var ObjectTypeSyntax = (function (_super) {
        __extends(ObjectTypeSyntax, _super);
        function ObjectTypeSyntax(openBraceToken, typeMembers, closeBraceToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.openBraceToken = openBraceToken;
            this.typeMembers = typeMembers;
            this.closeBraceToken = closeBraceToken;
        }
        ObjectTypeSyntax.prototype.accept = function (visitor) {
            return visitor.visitObjectType(this);
        };

        ObjectTypeSyntax.prototype.kind = function () {
            return 122 /* ObjectType */;
        };

        ObjectTypeSyntax.prototype.childCount = function () {
            return 3;
        };

        ObjectTypeSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.openBraceToken;
                case 1:
                    return this.typeMembers;
                case 2:
                    return this.closeBraceToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ObjectTypeSyntax.prototype.isType = function () {
            return true;
        };

        ObjectTypeSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        ObjectTypeSyntax.prototype.isExpression = function () {
            return true;
        };

        ObjectTypeSyntax.prototype.update = function (openBraceToken, typeMembers, closeBraceToken) {
            if (this.openBraceToken === openBraceToken && this.typeMembers === typeMembers && this.closeBraceToken === closeBraceToken) {
                return this;
            }

            return new ObjectTypeSyntax(openBraceToken, typeMembers, closeBraceToken, this.parsedInStrictMode());
        };

        ObjectTypeSyntax.create = function (openBraceToken, closeBraceToken) {
            return new ObjectTypeSyntax(openBraceToken, TypeScript.Syntax.emptySeparatedList, closeBraceToken, false);
        };

        ObjectTypeSyntax.create1 = function () {
            return new ObjectTypeSyntax(TypeScript.Syntax.token(70 /* OpenBraceToken */), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.token(71 /* CloseBraceToken */), false);
        };

        ObjectTypeSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ObjectTypeSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ObjectTypeSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
            return this.update(openBraceToken, this.typeMembers, this.closeBraceToken);
        };

        ObjectTypeSyntax.prototype.withTypeMembers = function (typeMembers) {
            return this.update(this.openBraceToken, typeMembers, this.closeBraceToken);
        };

        ObjectTypeSyntax.prototype.withTypeMember = function (typeMember) {
            return this.withTypeMembers(TypeScript.Syntax.separatedList([typeMember]));
        };

        ObjectTypeSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
            return this.update(this.openBraceToken, this.typeMembers, closeBraceToken);
        };

        ObjectTypeSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ObjectTypeSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ObjectTypeSyntax = ObjectTypeSyntax;

    var ArrayTypeSyntax = (function (_super) {
        __extends(ArrayTypeSyntax, _super);
        function ArrayTypeSyntax(type, openBracketToken, closeBracketToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.type = type;
            this.openBracketToken = openBracketToken;
            this.closeBracketToken = closeBracketToken;
        }
        ArrayTypeSyntax.prototype.accept = function (visitor) {
            return visitor.visitArrayType(this);
        };

        ArrayTypeSyntax.prototype.kind = function () {
            return 124 /* ArrayType */;
        };

        ArrayTypeSyntax.prototype.childCount = function () {
            return 3;
        };

        ArrayTypeSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.type;
                case 1:
                    return this.openBracketToken;
                case 2:
                    return this.closeBracketToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ArrayTypeSyntax.prototype.isType = function () {
            return true;
        };

        ArrayTypeSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        ArrayTypeSyntax.prototype.isExpression = function () {
            return true;
        };

        ArrayTypeSyntax.prototype.update = function (type, openBracketToken, closeBracketToken) {
            if (this.type === type && this.openBracketToken === openBracketToken && this.closeBracketToken === closeBracketToken) {
                return this;
            }

            return new ArrayTypeSyntax(type, openBracketToken, closeBracketToken, this.parsedInStrictMode());
        };

        ArrayTypeSyntax.create1 = function (type) {
            return new ArrayTypeSyntax(type, TypeScript.Syntax.token(74 /* OpenBracketToken */), TypeScript.Syntax.token(75 /* CloseBracketToken */), false);
        };

        ArrayTypeSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ArrayTypeSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ArrayTypeSyntax.prototype.withType = function (type) {
            return this.update(type, this.openBracketToken, this.closeBracketToken);
        };

        ArrayTypeSyntax.prototype.withOpenBracketToken = function (openBracketToken) {
            return this.update(this.type, openBracketToken, this.closeBracketToken);
        };

        ArrayTypeSyntax.prototype.withCloseBracketToken = function (closeBracketToken) {
            return this.update(this.type, this.openBracketToken, closeBracketToken);
        };

        ArrayTypeSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ArrayTypeSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ArrayTypeSyntax = ArrayTypeSyntax;

    var GenericTypeSyntax = (function (_super) {
        __extends(GenericTypeSyntax, _super);
        function GenericTypeSyntax(name, typeArgumentList, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.name = name;
            this.typeArgumentList = typeArgumentList;
        }
        GenericTypeSyntax.prototype.accept = function (visitor) {
            return visitor.visitGenericType(this);
        };

        GenericTypeSyntax.prototype.kind = function () {
            return 126 /* GenericType */;
        };

        GenericTypeSyntax.prototype.childCount = function () {
            return 2;
        };

        GenericTypeSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.name;
                case 1:
                    return this.typeArgumentList;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        GenericTypeSyntax.prototype.isType = function () {
            return true;
        };

        GenericTypeSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        GenericTypeSyntax.prototype.isExpression = function () {
            return true;
        };

        GenericTypeSyntax.prototype.update = function (name, typeArgumentList) {
            if (this.name === name && this.typeArgumentList === typeArgumentList) {
                return this;
            }

            return new GenericTypeSyntax(name, typeArgumentList, this.parsedInStrictMode());
        };

        GenericTypeSyntax.create1 = function (name) {
            return new GenericTypeSyntax(name, TypeArgumentListSyntax.create1(), false);
        };

        GenericTypeSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        GenericTypeSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        GenericTypeSyntax.prototype.withName = function (name) {
            return this.update(name, this.typeArgumentList);
        };

        GenericTypeSyntax.prototype.withTypeArgumentList = function (typeArgumentList) {
            return this.update(this.name, typeArgumentList);
        };

        GenericTypeSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return GenericTypeSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.GenericTypeSyntax = GenericTypeSyntax;

    var TypeQuerySyntax = (function (_super) {
        __extends(TypeQuerySyntax, _super);
        function TypeQuerySyntax(typeOfKeyword, name, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.typeOfKeyword = typeOfKeyword;
            this.name = name;
        }
        TypeQuerySyntax.prototype.accept = function (visitor) {
            return visitor.visitTypeQuery(this);
        };

        TypeQuerySyntax.prototype.kind = function () {
            return 127 /* TypeQuery */;
        };

        TypeQuerySyntax.prototype.childCount = function () {
            return 2;
        };

        TypeQuerySyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.typeOfKeyword;
                case 1:
                    return this.name;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        TypeQuerySyntax.prototype.isType = function () {
            return true;
        };

        TypeQuerySyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        TypeQuerySyntax.prototype.isExpression = function () {
            return true;
        };

        TypeQuerySyntax.prototype.update = function (typeOfKeyword, name) {
            if (this.typeOfKeyword === typeOfKeyword && this.name === name) {
                return this;
            }

            return new TypeQuerySyntax(typeOfKeyword, name, this.parsedInStrictMode());
        };

        TypeQuerySyntax.create1 = function (name) {
            return new TypeQuerySyntax(TypeScript.Syntax.token(39 /* TypeOfKeyword */), name, false);
        };

        TypeQuerySyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        TypeQuerySyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        TypeQuerySyntax.prototype.withTypeOfKeyword = function (typeOfKeyword) {
            return this.update(typeOfKeyword, this.name);
        };

        TypeQuerySyntax.prototype.withName = function (name) {
            return this.update(this.typeOfKeyword, name);
        };

        TypeQuerySyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return TypeQuerySyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.TypeQuerySyntax = TypeQuerySyntax;

    var TypeAnnotationSyntax = (function (_super) {
        __extends(TypeAnnotationSyntax, _super);
        function TypeAnnotationSyntax(colonToken, type, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.colonToken = colonToken;
            this.type = type;
        }
        TypeAnnotationSyntax.prototype.accept = function (visitor) {
            return visitor.visitTypeAnnotation(this);
        };

        TypeAnnotationSyntax.prototype.kind = function () {
            return 244 /* TypeAnnotation */;
        };

        TypeAnnotationSyntax.prototype.childCount = function () {
            return 2;
        };

        TypeAnnotationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.colonToken;
                case 1:
                    return this.type;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        TypeAnnotationSyntax.prototype.update = function (colonToken, type) {
            if (this.colonToken === colonToken && this.type === type) {
                return this;
            }

            return new TypeAnnotationSyntax(colonToken, type, this.parsedInStrictMode());
        };

        TypeAnnotationSyntax.create1 = function (type) {
            return new TypeAnnotationSyntax(TypeScript.Syntax.token(106 /* ColonToken */), type, false);
        };

        TypeAnnotationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        TypeAnnotationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        TypeAnnotationSyntax.prototype.withColonToken = function (colonToken) {
            return this.update(colonToken, this.type);
        };

        TypeAnnotationSyntax.prototype.withType = function (type) {
            return this.update(this.colonToken, type);
        };

        TypeAnnotationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return TypeAnnotationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.TypeAnnotationSyntax = TypeAnnotationSyntax;

    var BlockSyntax = (function (_super) {
        __extends(BlockSyntax, _super);
        function BlockSyntax(openBraceToken, statements, closeBraceToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.openBraceToken = openBraceToken;
            this.statements = statements;
            this.closeBraceToken = closeBraceToken;
        }
        BlockSyntax.prototype.accept = function (visitor) {
            return visitor.visitBlock(this);
        };

        BlockSyntax.prototype.kind = function () {
            return 145 /* Block */;
        };

        BlockSyntax.prototype.childCount = function () {
            return 3;
        };

        BlockSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.openBraceToken;
                case 1:
                    return this.statements;
                case 2:
                    return this.closeBraceToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        BlockSyntax.prototype.isStatement = function () {
            return true;
        };

        BlockSyntax.prototype.isModuleElement = function () {
            return true;
        };

        BlockSyntax.prototype.update = function (openBraceToken, statements, closeBraceToken) {
            if (this.openBraceToken === openBraceToken && this.statements === statements && this.closeBraceToken === closeBraceToken) {
                return this;
            }

            return new BlockSyntax(openBraceToken, statements, closeBraceToken, this.parsedInStrictMode());
        };

        BlockSyntax.create = function (openBraceToken, closeBraceToken) {
            return new BlockSyntax(openBraceToken, TypeScript.Syntax.emptyList, closeBraceToken, false);
        };

        BlockSyntax.create1 = function () {
            return new BlockSyntax(TypeScript.Syntax.token(70 /* OpenBraceToken */), TypeScript.Syntax.emptyList, TypeScript.Syntax.token(71 /* CloseBraceToken */), false);
        };

        BlockSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        BlockSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        BlockSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
            return this.update(openBraceToken, this.statements, this.closeBraceToken);
        };

        BlockSyntax.prototype.withStatements = function (statements) {
            return this.update(this.openBraceToken, statements, this.closeBraceToken);
        };

        BlockSyntax.prototype.withStatement = function (statement) {
            return this.withStatements(TypeScript.Syntax.list([statement]));
        };

        BlockSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
            return this.update(this.openBraceToken, this.statements, closeBraceToken);
        };

        BlockSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.statements.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return BlockSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.BlockSyntax = BlockSyntax;

    var ParameterSyntax = (function (_super) {
        __extends(ParameterSyntax, _super);
        function ParameterSyntax(dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.dotDotDotToken = dotDotDotToken;
            this.publicOrPrivateKeyword = publicOrPrivateKeyword;
            this.identifier = identifier;
            this.questionToken = questionToken;
            this.typeAnnotation = typeAnnotation;
            this.equalsValueClause = equalsValueClause;
        }
        ParameterSyntax.prototype.accept = function (visitor) {
            return visitor.visitParameter(this);
        };

        ParameterSyntax.prototype.kind = function () {
            return 242 /* Parameter */;
        };

        ParameterSyntax.prototype.childCount = function () {
            return 6;
        };

        ParameterSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.dotDotDotToken;
                case 1:
                    return this.publicOrPrivateKeyword;
                case 2:
                    return this.identifier;
                case 3:
                    return this.questionToken;
                case 4:
                    return this.typeAnnotation;
                case 5:
                    return this.equalsValueClause;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ParameterSyntax.prototype.update = function (dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause) {
            if (this.dotDotDotToken === dotDotDotToken && this.publicOrPrivateKeyword === publicOrPrivateKeyword && this.identifier === identifier && this.questionToken === questionToken && this.typeAnnotation === typeAnnotation && this.equalsValueClause === equalsValueClause) {
                return this;
            }

            return new ParameterSyntax(dotDotDotToken, publicOrPrivateKeyword, identifier, questionToken, typeAnnotation, equalsValueClause, this.parsedInStrictMode());
        };

        ParameterSyntax.create = function (identifier) {
            return new ParameterSyntax(null, null, identifier, null, null, null, false);
        };

        ParameterSyntax.create1 = function (identifier) {
            return new ParameterSyntax(null, null, identifier, null, null, null, false);
        };

        ParameterSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ParameterSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ParameterSyntax.prototype.withDotDotDotToken = function (dotDotDotToken) {
            return this.update(dotDotDotToken, this.publicOrPrivateKeyword, this.identifier, this.questionToken, this.typeAnnotation, this.equalsValueClause);
        };

        ParameterSyntax.prototype.withPublicOrPrivateKeyword = function (publicOrPrivateKeyword) {
            return this.update(this.dotDotDotToken, publicOrPrivateKeyword, this.identifier, this.questionToken, this.typeAnnotation, this.equalsValueClause);
        };

        ParameterSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.dotDotDotToken, this.publicOrPrivateKeyword, identifier, this.questionToken, this.typeAnnotation, this.equalsValueClause);
        };

        ParameterSyntax.prototype.withQuestionToken = function (questionToken) {
            return this.update(this.dotDotDotToken, this.publicOrPrivateKeyword, this.identifier, questionToken, this.typeAnnotation, this.equalsValueClause);
        };

        ParameterSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
            return this.update(this.dotDotDotToken, this.publicOrPrivateKeyword, this.identifier, this.questionToken, typeAnnotation, this.equalsValueClause);
        };

        ParameterSyntax.prototype.withEqualsValueClause = function (equalsValueClause) {
            return this.update(this.dotDotDotToken, this.publicOrPrivateKeyword, this.identifier, this.questionToken, this.typeAnnotation, equalsValueClause);
        };

        ParameterSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.dotDotDotToken !== null) {
                return true;
            }
            if (this.publicOrPrivateKeyword !== null) {
                return true;
            }
            if (this.questionToken !== null) {
                return true;
            }
            if (this.typeAnnotation !== null) {
                return true;
            }
            if (this.equalsValueClause !== null) {
                return true;
            }
            return false;
        };
        return ParameterSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ParameterSyntax = ParameterSyntax;

    var MemberAccessExpressionSyntax = (function (_super) {
        __extends(MemberAccessExpressionSyntax, _super);
        function MemberAccessExpressionSyntax(expression, dotToken, name, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.expression = expression;
            this.dotToken = dotToken;
            this.name = name;
        }
        MemberAccessExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitMemberAccessExpression(this);
        };

        MemberAccessExpressionSyntax.prototype.kind = function () {
            return 211 /* MemberAccessExpression */;
        };

        MemberAccessExpressionSyntax.prototype.childCount = function () {
            return 3;
        };

        MemberAccessExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.expression;
                case 1:
                    return this.dotToken;
                case 2:
                    return this.name;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        MemberAccessExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        MemberAccessExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        MemberAccessExpressionSyntax.prototype.update = function (expression, dotToken, name) {
            if (this.expression === expression && this.dotToken === dotToken && this.name === name) {
                return this;
            }

            return new MemberAccessExpressionSyntax(expression, dotToken, name, this.parsedInStrictMode());
        };

        MemberAccessExpressionSyntax.create1 = function (expression, name) {
            return new MemberAccessExpressionSyntax(expression, TypeScript.Syntax.token(76 /* DotToken */), name, false);
        };

        MemberAccessExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        MemberAccessExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        MemberAccessExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(expression, this.dotToken, this.name);
        };

        MemberAccessExpressionSyntax.prototype.withDotToken = function (dotToken) {
            return this.update(this.expression, dotToken, this.name);
        };

        MemberAccessExpressionSyntax.prototype.withName = function (name) {
            return this.update(this.expression, this.dotToken, name);
        };

        MemberAccessExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return MemberAccessExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.MemberAccessExpressionSyntax = MemberAccessExpressionSyntax;

    var PostfixUnaryExpressionSyntax = (function (_super) {
        __extends(PostfixUnaryExpressionSyntax, _super);
        function PostfixUnaryExpressionSyntax(kind, operand, operatorToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.operand = operand;
            this.operatorToken = operatorToken;

            this._kind = kind;
        }
        PostfixUnaryExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitPostfixUnaryExpression(this);
        };

        PostfixUnaryExpressionSyntax.prototype.childCount = function () {
            return 2;
        };

        PostfixUnaryExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.operand;
                case 1:
                    return this.operatorToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        PostfixUnaryExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        PostfixUnaryExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        PostfixUnaryExpressionSyntax.prototype.kind = function () {
            return this._kind;
        };

        PostfixUnaryExpressionSyntax.prototype.update = function (kind, operand, operatorToken) {
            if (this._kind === kind && this.operand === operand && this.operatorToken === operatorToken) {
                return this;
            }

            return new PostfixUnaryExpressionSyntax(kind, operand, operatorToken, this.parsedInStrictMode());
        };

        PostfixUnaryExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        PostfixUnaryExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        PostfixUnaryExpressionSyntax.prototype.withKind = function (kind) {
            return this.update(kind, this.operand, this.operatorToken);
        };

        PostfixUnaryExpressionSyntax.prototype.withOperand = function (operand) {
            return this.update(this._kind, operand, this.operatorToken);
        };

        PostfixUnaryExpressionSyntax.prototype.withOperatorToken = function (operatorToken) {
            return this.update(this._kind, this.operand, operatorToken);
        };

        PostfixUnaryExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.operand.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return PostfixUnaryExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.PostfixUnaryExpressionSyntax = PostfixUnaryExpressionSyntax;

    var ElementAccessExpressionSyntax = (function (_super) {
        __extends(ElementAccessExpressionSyntax, _super);
        function ElementAccessExpressionSyntax(expression, openBracketToken, argumentExpression, closeBracketToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.expression = expression;
            this.openBracketToken = openBracketToken;
            this.argumentExpression = argumentExpression;
            this.closeBracketToken = closeBracketToken;
        }
        ElementAccessExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitElementAccessExpression(this);
        };

        ElementAccessExpressionSyntax.prototype.kind = function () {
            return 220 /* ElementAccessExpression */;
        };

        ElementAccessExpressionSyntax.prototype.childCount = function () {
            return 4;
        };

        ElementAccessExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.expression;
                case 1:
                    return this.openBracketToken;
                case 2:
                    return this.argumentExpression;
                case 3:
                    return this.closeBracketToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ElementAccessExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        ElementAccessExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        ElementAccessExpressionSyntax.prototype.update = function (expression, openBracketToken, argumentExpression, closeBracketToken) {
            if (this.expression === expression && this.openBracketToken === openBracketToken && this.argumentExpression === argumentExpression && this.closeBracketToken === closeBracketToken) {
                return this;
            }

            return new ElementAccessExpressionSyntax(expression, openBracketToken, argumentExpression, closeBracketToken, this.parsedInStrictMode());
        };

        ElementAccessExpressionSyntax.create1 = function (expression, argumentExpression) {
            return new ElementAccessExpressionSyntax(expression, TypeScript.Syntax.token(74 /* OpenBracketToken */), argumentExpression, TypeScript.Syntax.token(75 /* CloseBracketToken */), false);
        };

        ElementAccessExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ElementAccessExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ElementAccessExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(expression, this.openBracketToken, this.argumentExpression, this.closeBracketToken);
        };

        ElementAccessExpressionSyntax.prototype.withOpenBracketToken = function (openBracketToken) {
            return this.update(this.expression, openBracketToken, this.argumentExpression, this.closeBracketToken);
        };

        ElementAccessExpressionSyntax.prototype.withArgumentExpression = function (argumentExpression) {
            return this.update(this.expression, this.openBracketToken, argumentExpression, this.closeBracketToken);
        };

        ElementAccessExpressionSyntax.prototype.withCloseBracketToken = function (closeBracketToken) {
            return this.update(this.expression, this.openBracketToken, this.argumentExpression, closeBracketToken);
        };

        ElementAccessExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            if (this.argumentExpression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ElementAccessExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ElementAccessExpressionSyntax = ElementAccessExpressionSyntax;

    var InvocationExpressionSyntax = (function (_super) {
        __extends(InvocationExpressionSyntax, _super);
        function InvocationExpressionSyntax(expression, argumentList, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.expression = expression;
            this.argumentList = argumentList;
        }
        InvocationExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitInvocationExpression(this);
        };

        InvocationExpressionSyntax.prototype.kind = function () {
            return 212 /* InvocationExpression */;
        };

        InvocationExpressionSyntax.prototype.childCount = function () {
            return 2;
        };

        InvocationExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.expression;
                case 1:
                    return this.argumentList;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        InvocationExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        InvocationExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        InvocationExpressionSyntax.prototype.update = function (expression, argumentList) {
            if (this.expression === expression && this.argumentList === argumentList) {
                return this;
            }

            return new InvocationExpressionSyntax(expression, argumentList, this.parsedInStrictMode());
        };

        InvocationExpressionSyntax.create1 = function (expression) {
            return new InvocationExpressionSyntax(expression, ArgumentListSyntax.create1(), false);
        };

        InvocationExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        InvocationExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        InvocationExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(expression, this.argumentList);
        };

        InvocationExpressionSyntax.prototype.withArgumentList = function (argumentList) {
            return this.update(this.expression, argumentList);
        };

        InvocationExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            if (this.argumentList.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return InvocationExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.InvocationExpressionSyntax = InvocationExpressionSyntax;

    var ArgumentListSyntax = (function (_super) {
        __extends(ArgumentListSyntax, _super);
        function ArgumentListSyntax(typeArgumentList, openParenToken, arguments, closeParenToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.typeArgumentList = typeArgumentList;
            this.openParenToken = openParenToken;
            this.arguments = arguments;
            this.closeParenToken = closeParenToken;
        }
        ArgumentListSyntax.prototype.accept = function (visitor) {
            return visitor.visitArgumentList(this);
        };

        ArgumentListSyntax.prototype.kind = function () {
            return 225 /* ArgumentList */;
        };

        ArgumentListSyntax.prototype.childCount = function () {
            return 4;
        };

        ArgumentListSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.typeArgumentList;
                case 1:
                    return this.openParenToken;
                case 2:
                    return this.arguments;
                case 3:
                    return this.closeParenToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ArgumentListSyntax.prototype.update = function (typeArgumentList, openParenToken, _arguments, closeParenToken) {
            if (this.typeArgumentList === typeArgumentList && this.openParenToken === openParenToken && this.arguments === _arguments && this.closeParenToken === closeParenToken) {
                return this;
            }

            return new ArgumentListSyntax(typeArgumentList, openParenToken, _arguments, closeParenToken, this.parsedInStrictMode());
        };

        ArgumentListSyntax.create = function (openParenToken, closeParenToken) {
            return new ArgumentListSyntax(null, openParenToken, TypeScript.Syntax.emptySeparatedList, closeParenToken, false);
        };

        ArgumentListSyntax.create1 = function () {
            return new ArgumentListSyntax(null, TypeScript.Syntax.token(72 /* OpenParenToken */), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.token(73 /* CloseParenToken */), false);
        };

        ArgumentListSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ArgumentListSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ArgumentListSyntax.prototype.withTypeArgumentList = function (typeArgumentList) {
            return this.update(typeArgumentList, this.openParenToken, this.arguments, this.closeParenToken);
        };

        ArgumentListSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.typeArgumentList, openParenToken, this.arguments, this.closeParenToken);
        };

        ArgumentListSyntax.prototype.withArguments = function (_arguments) {
            return this.update(this.typeArgumentList, this.openParenToken, _arguments, this.closeParenToken);
        };

        ArgumentListSyntax.prototype.withArgument = function (_argument) {
            return this.withArguments(TypeScript.Syntax.separatedList([_argument]));
        };

        ArgumentListSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.typeArgumentList, this.openParenToken, this.arguments, closeParenToken);
        };

        ArgumentListSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.typeArgumentList !== null && this.typeArgumentList.isTypeScriptSpecific()) {
                return true;
            }
            if (this.arguments.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ArgumentListSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ArgumentListSyntax = ArgumentListSyntax;

    var BinaryExpressionSyntax = (function (_super) {
        __extends(BinaryExpressionSyntax, _super);
        function BinaryExpressionSyntax(kind, left, operatorToken, right, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.left = left;
            this.operatorToken = operatorToken;
            this.right = right;

            this._kind = kind;
        }
        BinaryExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitBinaryExpression(this);
        };

        BinaryExpressionSyntax.prototype.childCount = function () {
            return 3;
        };

        BinaryExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.left;
                case 1:
                    return this.operatorToken;
                case 2:
                    return this.right;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        BinaryExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        BinaryExpressionSyntax.prototype.kind = function () {
            return this._kind;
        };

        BinaryExpressionSyntax.prototype.update = function (kind, left, operatorToken, right) {
            if (this._kind === kind && this.left === left && this.operatorToken === operatorToken && this.right === right) {
                return this;
            }

            return new BinaryExpressionSyntax(kind, left, operatorToken, right, this.parsedInStrictMode());
        };

        BinaryExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        BinaryExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        BinaryExpressionSyntax.prototype.withKind = function (kind) {
            return this.update(kind, this.left, this.operatorToken, this.right);
        };

        BinaryExpressionSyntax.prototype.withLeft = function (left) {
            return this.update(this._kind, left, this.operatorToken, this.right);
        };

        BinaryExpressionSyntax.prototype.withOperatorToken = function (operatorToken) {
            return this.update(this._kind, this.left, operatorToken, this.right);
        };

        BinaryExpressionSyntax.prototype.withRight = function (right) {
            return this.update(this._kind, this.left, this.operatorToken, right);
        };

        BinaryExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.left.isTypeScriptSpecific()) {
                return true;
            }
            if (this.right.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return BinaryExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.BinaryExpressionSyntax = BinaryExpressionSyntax;

    var ConditionalExpressionSyntax = (function (_super) {
        __extends(ConditionalExpressionSyntax, _super);
        function ConditionalExpressionSyntax(condition, questionToken, whenTrue, colonToken, whenFalse, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.condition = condition;
            this.questionToken = questionToken;
            this.whenTrue = whenTrue;
            this.colonToken = colonToken;
            this.whenFalse = whenFalse;
        }
        ConditionalExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitConditionalExpression(this);
        };

        ConditionalExpressionSyntax.prototype.kind = function () {
            return 185 /* ConditionalExpression */;
        };

        ConditionalExpressionSyntax.prototype.childCount = function () {
            return 5;
        };

        ConditionalExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.condition;
                case 1:
                    return this.questionToken;
                case 2:
                    return this.whenTrue;
                case 3:
                    return this.colonToken;
                case 4:
                    return this.whenFalse;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ConditionalExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        ConditionalExpressionSyntax.prototype.update = function (condition, questionToken, whenTrue, colonToken, whenFalse) {
            if (this.condition === condition && this.questionToken === questionToken && this.whenTrue === whenTrue && this.colonToken === colonToken && this.whenFalse === whenFalse) {
                return this;
            }

            return new ConditionalExpressionSyntax(condition, questionToken, whenTrue, colonToken, whenFalse, this.parsedInStrictMode());
        };

        ConditionalExpressionSyntax.create1 = function (condition, whenTrue, whenFalse) {
            return new ConditionalExpressionSyntax(condition, TypeScript.Syntax.token(105 /* QuestionToken */), whenTrue, TypeScript.Syntax.token(106 /* ColonToken */), whenFalse, false);
        };

        ConditionalExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ConditionalExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ConditionalExpressionSyntax.prototype.withCondition = function (condition) {
            return this.update(condition, this.questionToken, this.whenTrue, this.colonToken, this.whenFalse);
        };

        ConditionalExpressionSyntax.prototype.withQuestionToken = function (questionToken) {
            return this.update(this.condition, questionToken, this.whenTrue, this.colonToken, this.whenFalse);
        };

        ConditionalExpressionSyntax.prototype.withWhenTrue = function (whenTrue) {
            return this.update(this.condition, this.questionToken, whenTrue, this.colonToken, this.whenFalse);
        };

        ConditionalExpressionSyntax.prototype.withColonToken = function (colonToken) {
            return this.update(this.condition, this.questionToken, this.whenTrue, colonToken, this.whenFalse);
        };

        ConditionalExpressionSyntax.prototype.withWhenFalse = function (whenFalse) {
            return this.update(this.condition, this.questionToken, this.whenTrue, this.colonToken, whenFalse);
        };

        ConditionalExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.condition.isTypeScriptSpecific()) {
                return true;
            }
            if (this.whenTrue.isTypeScriptSpecific()) {
                return true;
            }
            if (this.whenFalse.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ConditionalExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ConditionalExpressionSyntax = ConditionalExpressionSyntax;

    var ConstructSignatureSyntax = (function (_super) {
        __extends(ConstructSignatureSyntax, _super);
        function ConstructSignatureSyntax(newKeyword, callSignature, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.newKeyword = newKeyword;
            this.callSignature = callSignature;
        }
        ConstructSignatureSyntax.prototype.accept = function (visitor) {
            return visitor.visitConstructSignature(this);
        };

        ConstructSignatureSyntax.prototype.kind = function () {
            return 142 /* ConstructSignature */;
        };

        ConstructSignatureSyntax.prototype.childCount = function () {
            return 2;
        };

        ConstructSignatureSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.newKeyword;
                case 1:
                    return this.callSignature;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ConstructSignatureSyntax.prototype.isTypeMember = function () {
            return true;
        };

        ConstructSignatureSyntax.prototype.update = function (newKeyword, callSignature) {
            if (this.newKeyword === newKeyword && this.callSignature === callSignature) {
                return this;
            }

            return new ConstructSignatureSyntax(newKeyword, callSignature, this.parsedInStrictMode());
        };

        ConstructSignatureSyntax.create1 = function () {
            return new ConstructSignatureSyntax(TypeScript.Syntax.token(31 /* NewKeyword */), CallSignatureSyntax.create1(), false);
        };

        ConstructSignatureSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ConstructSignatureSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ConstructSignatureSyntax.prototype.withNewKeyword = function (newKeyword) {
            return this.update(newKeyword, this.callSignature);
        };

        ConstructSignatureSyntax.prototype.withCallSignature = function (callSignature) {
            return this.update(this.newKeyword, callSignature);
        };

        ConstructSignatureSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ConstructSignatureSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ConstructSignatureSyntax = ConstructSignatureSyntax;

    var MethodSignatureSyntax = (function (_super) {
        __extends(MethodSignatureSyntax, _super);
        function MethodSignatureSyntax(propertyName, questionToken, callSignature, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.propertyName = propertyName;
            this.questionToken = questionToken;
            this.callSignature = callSignature;
        }
        MethodSignatureSyntax.prototype.accept = function (visitor) {
            return visitor.visitMethodSignature(this);
        };

        MethodSignatureSyntax.prototype.kind = function () {
            return 144 /* MethodSignature */;
        };

        MethodSignatureSyntax.prototype.childCount = function () {
            return 3;
        };

        MethodSignatureSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.propertyName;
                case 1:
                    return this.questionToken;
                case 2:
                    return this.callSignature;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        MethodSignatureSyntax.prototype.isTypeMember = function () {
            return true;
        };

        MethodSignatureSyntax.prototype.update = function (propertyName, questionToken, callSignature) {
            if (this.propertyName === propertyName && this.questionToken === questionToken && this.callSignature === callSignature) {
                return this;
            }

            return new MethodSignatureSyntax(propertyName, questionToken, callSignature, this.parsedInStrictMode());
        };

        MethodSignatureSyntax.create = function (propertyName, callSignature) {
            return new MethodSignatureSyntax(propertyName, null, callSignature, false);
        };

        MethodSignatureSyntax.create1 = function (propertyName) {
            return new MethodSignatureSyntax(propertyName, null, CallSignatureSyntax.create1(), false);
        };

        MethodSignatureSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        MethodSignatureSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        MethodSignatureSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(propertyName, this.questionToken, this.callSignature);
        };

        MethodSignatureSyntax.prototype.withQuestionToken = function (questionToken) {
            return this.update(this.propertyName, questionToken, this.callSignature);
        };

        MethodSignatureSyntax.prototype.withCallSignature = function (callSignature) {
            return this.update(this.propertyName, this.questionToken, callSignature);
        };

        MethodSignatureSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.callSignature.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return MethodSignatureSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.MethodSignatureSyntax = MethodSignatureSyntax;

    var IndexSignatureSyntax = (function (_super) {
        __extends(IndexSignatureSyntax, _super);
        function IndexSignatureSyntax(openBracketToken, parameter, closeBracketToken, typeAnnotation, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.openBracketToken = openBracketToken;
            this.parameter = parameter;
            this.closeBracketToken = closeBracketToken;
            this.typeAnnotation = typeAnnotation;
        }
        IndexSignatureSyntax.prototype.accept = function (visitor) {
            return visitor.visitIndexSignature(this);
        };

        IndexSignatureSyntax.prototype.kind = function () {
            return 143 /* IndexSignature */;
        };

        IndexSignatureSyntax.prototype.childCount = function () {
            return 4;
        };

        IndexSignatureSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.openBracketToken;
                case 1:
                    return this.parameter;
                case 2:
                    return this.closeBracketToken;
                case 3:
                    return this.typeAnnotation;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        IndexSignatureSyntax.prototype.isTypeMember = function () {
            return true;
        };

        IndexSignatureSyntax.prototype.isClassElement = function () {
            return true;
        };

        IndexSignatureSyntax.prototype.update = function (openBracketToken, parameter, closeBracketToken, typeAnnotation) {
            if (this.openBracketToken === openBracketToken && this.parameter === parameter && this.closeBracketToken === closeBracketToken && this.typeAnnotation === typeAnnotation) {
                return this;
            }

            return new IndexSignatureSyntax(openBracketToken, parameter, closeBracketToken, typeAnnotation, this.parsedInStrictMode());
        };

        IndexSignatureSyntax.create = function (openBracketToken, parameter, closeBracketToken) {
            return new IndexSignatureSyntax(openBracketToken, parameter, closeBracketToken, null, false);
        };

        IndexSignatureSyntax.create1 = function (parameter) {
            return new IndexSignatureSyntax(TypeScript.Syntax.token(74 /* OpenBracketToken */), parameter, TypeScript.Syntax.token(75 /* CloseBracketToken */), null, false);
        };

        IndexSignatureSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        IndexSignatureSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        IndexSignatureSyntax.prototype.withOpenBracketToken = function (openBracketToken) {
            return this.update(openBracketToken, this.parameter, this.closeBracketToken, this.typeAnnotation);
        };

        IndexSignatureSyntax.prototype.withParameter = function (parameter) {
            return this.update(this.openBracketToken, parameter, this.closeBracketToken, this.typeAnnotation);
        };

        IndexSignatureSyntax.prototype.withCloseBracketToken = function (closeBracketToken) {
            return this.update(this.openBracketToken, this.parameter, closeBracketToken, this.typeAnnotation);
        };

        IndexSignatureSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
            return this.update(this.openBracketToken, this.parameter, this.closeBracketToken, typeAnnotation);
        };

        IndexSignatureSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return IndexSignatureSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.IndexSignatureSyntax = IndexSignatureSyntax;

    var PropertySignatureSyntax = (function (_super) {
        __extends(PropertySignatureSyntax, _super);
        function PropertySignatureSyntax(propertyName, questionToken, typeAnnotation, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.propertyName = propertyName;
            this.questionToken = questionToken;
            this.typeAnnotation = typeAnnotation;
        }
        PropertySignatureSyntax.prototype.accept = function (visitor) {
            return visitor.visitPropertySignature(this);
        };

        PropertySignatureSyntax.prototype.kind = function () {
            return 140 /* PropertySignature */;
        };

        PropertySignatureSyntax.prototype.childCount = function () {
            return 3;
        };

        PropertySignatureSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.propertyName;
                case 1:
                    return this.questionToken;
                case 2:
                    return this.typeAnnotation;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        PropertySignatureSyntax.prototype.isTypeMember = function () {
            return true;
        };

        PropertySignatureSyntax.prototype.update = function (propertyName, questionToken, typeAnnotation) {
            if (this.propertyName === propertyName && this.questionToken === questionToken && this.typeAnnotation === typeAnnotation) {
                return this;
            }

            return new PropertySignatureSyntax(propertyName, questionToken, typeAnnotation, this.parsedInStrictMode());
        };

        PropertySignatureSyntax.create = function (propertyName) {
            return new PropertySignatureSyntax(propertyName, null, null, false);
        };

        PropertySignatureSyntax.create1 = function (propertyName) {
            return new PropertySignatureSyntax(propertyName, null, null, false);
        };

        PropertySignatureSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        PropertySignatureSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        PropertySignatureSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(propertyName, this.questionToken, this.typeAnnotation);
        };

        PropertySignatureSyntax.prototype.withQuestionToken = function (questionToken) {
            return this.update(this.propertyName, questionToken, this.typeAnnotation);
        };

        PropertySignatureSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
            return this.update(this.propertyName, this.questionToken, typeAnnotation);
        };

        PropertySignatureSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return PropertySignatureSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.PropertySignatureSyntax = PropertySignatureSyntax;

    var CallSignatureSyntax = (function (_super) {
        __extends(CallSignatureSyntax, _super);
        function CallSignatureSyntax(typeParameterList, parameterList, typeAnnotation, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.typeParameterList = typeParameterList;
            this.parameterList = parameterList;
            this.typeAnnotation = typeAnnotation;
        }
        CallSignatureSyntax.prototype.accept = function (visitor) {
            return visitor.visitCallSignature(this);
        };

        CallSignatureSyntax.prototype.kind = function () {
            return 141 /* CallSignature */;
        };

        CallSignatureSyntax.prototype.childCount = function () {
            return 3;
        };

        CallSignatureSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.typeParameterList;
                case 1:
                    return this.parameterList;
                case 2:
                    return this.typeAnnotation;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        CallSignatureSyntax.prototype.isTypeMember = function () {
            return true;
        };

        CallSignatureSyntax.prototype.update = function (typeParameterList, parameterList, typeAnnotation) {
            if (this.typeParameterList === typeParameterList && this.parameterList === parameterList && this.typeAnnotation === typeAnnotation) {
                return this;
            }

            return new CallSignatureSyntax(typeParameterList, parameterList, typeAnnotation, this.parsedInStrictMode());
        };

        CallSignatureSyntax.create = function (parameterList) {
            return new CallSignatureSyntax(null, parameterList, null, false);
        };

        CallSignatureSyntax.create1 = function () {
            return new CallSignatureSyntax(null, ParameterListSyntax.create1(), null, false);
        };

        CallSignatureSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        CallSignatureSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        CallSignatureSyntax.prototype.withTypeParameterList = function (typeParameterList) {
            return this.update(typeParameterList, this.parameterList, this.typeAnnotation);
        };

        CallSignatureSyntax.prototype.withParameterList = function (parameterList) {
            return this.update(this.typeParameterList, parameterList, this.typeAnnotation);
        };

        CallSignatureSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
            return this.update(this.typeParameterList, this.parameterList, typeAnnotation);
        };

        CallSignatureSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.typeParameterList !== null) {
                return true;
            }
            if (this.parameterList.isTypeScriptSpecific()) {
                return true;
            }
            if (this.typeAnnotation !== null) {
                return true;
            }
            return false;
        };
        return CallSignatureSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.CallSignatureSyntax = CallSignatureSyntax;

    var ParameterListSyntax = (function (_super) {
        __extends(ParameterListSyntax, _super);
        function ParameterListSyntax(openParenToken, parameters, closeParenToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.openParenToken = openParenToken;
            this.parameters = parameters;
            this.closeParenToken = closeParenToken;
        }
        ParameterListSyntax.prototype.accept = function (visitor) {
            return visitor.visitParameterList(this);
        };

        ParameterListSyntax.prototype.kind = function () {
            return 226 /* ParameterList */;
        };

        ParameterListSyntax.prototype.childCount = function () {
            return 3;
        };

        ParameterListSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.openParenToken;
                case 1:
                    return this.parameters;
                case 2:
                    return this.closeParenToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ParameterListSyntax.prototype.update = function (openParenToken, parameters, closeParenToken) {
            if (this.openParenToken === openParenToken && this.parameters === parameters && this.closeParenToken === closeParenToken) {
                return this;
            }

            return new ParameterListSyntax(openParenToken, parameters, closeParenToken, this.parsedInStrictMode());
        };

        ParameterListSyntax.create = function (openParenToken, closeParenToken) {
            return new ParameterListSyntax(openParenToken, TypeScript.Syntax.emptySeparatedList, closeParenToken, false);
        };

        ParameterListSyntax.create1 = function () {
            return new ParameterListSyntax(TypeScript.Syntax.token(72 /* OpenParenToken */), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.token(73 /* CloseParenToken */), false);
        };

        ParameterListSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ParameterListSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ParameterListSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(openParenToken, this.parameters, this.closeParenToken);
        };

        ParameterListSyntax.prototype.withParameters = function (parameters) {
            return this.update(this.openParenToken, parameters, this.closeParenToken);
        };

        ParameterListSyntax.prototype.withParameter = function (parameter) {
            return this.withParameters(TypeScript.Syntax.separatedList([parameter]));
        };

        ParameterListSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.openParenToken, this.parameters, closeParenToken);
        };

        ParameterListSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.parameters.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ParameterListSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ParameterListSyntax = ParameterListSyntax;

    var TypeParameterListSyntax = (function (_super) {
        __extends(TypeParameterListSyntax, _super);
        function TypeParameterListSyntax(lessThanToken, typeParameters, greaterThanToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.lessThanToken = lessThanToken;
            this.typeParameters = typeParameters;
            this.greaterThanToken = greaterThanToken;
        }
        TypeParameterListSyntax.prototype.accept = function (visitor) {
            return visitor.visitTypeParameterList(this);
        };

        TypeParameterListSyntax.prototype.kind = function () {
            return 228 /* TypeParameterList */;
        };

        TypeParameterListSyntax.prototype.childCount = function () {
            return 3;
        };

        TypeParameterListSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.lessThanToken;
                case 1:
                    return this.typeParameters;
                case 2:
                    return this.greaterThanToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        TypeParameterListSyntax.prototype.update = function (lessThanToken, typeParameters, greaterThanToken) {
            if (this.lessThanToken === lessThanToken && this.typeParameters === typeParameters && this.greaterThanToken === greaterThanToken) {
                return this;
            }

            return new TypeParameterListSyntax(lessThanToken, typeParameters, greaterThanToken, this.parsedInStrictMode());
        };

        TypeParameterListSyntax.create = function (lessThanToken, greaterThanToken) {
            return new TypeParameterListSyntax(lessThanToken, TypeScript.Syntax.emptySeparatedList, greaterThanToken, false);
        };

        TypeParameterListSyntax.create1 = function () {
            return new TypeParameterListSyntax(TypeScript.Syntax.token(80 /* LessThanToken */), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.token(81 /* GreaterThanToken */), false);
        };

        TypeParameterListSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        TypeParameterListSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        TypeParameterListSyntax.prototype.withLessThanToken = function (lessThanToken) {
            return this.update(lessThanToken, this.typeParameters, this.greaterThanToken);
        };

        TypeParameterListSyntax.prototype.withTypeParameters = function (typeParameters) {
            return this.update(this.lessThanToken, typeParameters, this.greaterThanToken);
        };

        TypeParameterListSyntax.prototype.withTypeParameter = function (typeParameter) {
            return this.withTypeParameters(TypeScript.Syntax.separatedList([typeParameter]));
        };

        TypeParameterListSyntax.prototype.withGreaterThanToken = function (greaterThanToken) {
            return this.update(this.lessThanToken, this.typeParameters, greaterThanToken);
        };

        TypeParameterListSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return TypeParameterListSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.TypeParameterListSyntax = TypeParameterListSyntax;

    var TypeParameterSyntax = (function (_super) {
        __extends(TypeParameterSyntax, _super);
        function TypeParameterSyntax(identifier, constraint, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.identifier = identifier;
            this.constraint = constraint;
        }
        TypeParameterSyntax.prototype.accept = function (visitor) {
            return visitor.visitTypeParameter(this);
        };

        TypeParameterSyntax.prototype.kind = function () {
            return 236 /* TypeParameter */;
        };

        TypeParameterSyntax.prototype.childCount = function () {
            return 2;
        };

        TypeParameterSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.identifier;
                case 1:
                    return this.constraint;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        TypeParameterSyntax.prototype.update = function (identifier, constraint) {
            if (this.identifier === identifier && this.constraint === constraint) {
                return this;
            }

            return new TypeParameterSyntax(identifier, constraint, this.parsedInStrictMode());
        };

        TypeParameterSyntax.create = function (identifier) {
            return new TypeParameterSyntax(identifier, null, false);
        };

        TypeParameterSyntax.create1 = function (identifier) {
            return new TypeParameterSyntax(identifier, null, false);
        };

        TypeParameterSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        TypeParameterSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        TypeParameterSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(identifier, this.constraint);
        };

        TypeParameterSyntax.prototype.withConstraint = function (constraint) {
            return this.update(this.identifier, constraint);
        };

        TypeParameterSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return TypeParameterSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.TypeParameterSyntax = TypeParameterSyntax;

    var ConstraintSyntax = (function (_super) {
        __extends(ConstraintSyntax, _super);
        function ConstraintSyntax(extendsKeyword, type, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.extendsKeyword = extendsKeyword;
            this.type = type;
        }
        ConstraintSyntax.prototype.accept = function (visitor) {
            return visitor.visitConstraint(this);
        };

        ConstraintSyntax.prototype.kind = function () {
            return 237 /* Constraint */;
        };

        ConstraintSyntax.prototype.childCount = function () {
            return 2;
        };

        ConstraintSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.extendsKeyword;
                case 1:
                    return this.type;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ConstraintSyntax.prototype.update = function (extendsKeyword, type) {
            if (this.extendsKeyword === extendsKeyword && this.type === type) {
                return this;
            }

            return new ConstraintSyntax(extendsKeyword, type, this.parsedInStrictMode());
        };

        ConstraintSyntax.create1 = function (type) {
            return new ConstraintSyntax(TypeScript.Syntax.token(48 /* ExtendsKeyword */), type, false);
        };

        ConstraintSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ConstraintSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ConstraintSyntax.prototype.withExtendsKeyword = function (extendsKeyword) {
            return this.update(extendsKeyword, this.type);
        };

        ConstraintSyntax.prototype.withType = function (type) {
            return this.update(this.extendsKeyword, type);
        };

        ConstraintSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ConstraintSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ConstraintSyntax = ConstraintSyntax;

    var ElseClauseSyntax = (function (_super) {
        __extends(ElseClauseSyntax, _super);
        function ElseClauseSyntax(elseKeyword, statement, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.elseKeyword = elseKeyword;
            this.statement = statement;
        }
        ElseClauseSyntax.prototype.accept = function (visitor) {
            return visitor.visitElseClause(this);
        };

        ElseClauseSyntax.prototype.kind = function () {
            return 233 /* ElseClause */;
        };

        ElseClauseSyntax.prototype.childCount = function () {
            return 2;
        };

        ElseClauseSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.elseKeyword;
                case 1:
                    return this.statement;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ElseClauseSyntax.prototype.update = function (elseKeyword, statement) {
            if (this.elseKeyword === elseKeyword && this.statement === statement) {
                return this;
            }

            return new ElseClauseSyntax(elseKeyword, statement, this.parsedInStrictMode());
        };

        ElseClauseSyntax.create1 = function (statement) {
            return new ElseClauseSyntax(TypeScript.Syntax.token(23 /* ElseKeyword */), statement, false);
        };

        ElseClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ElseClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ElseClauseSyntax.prototype.withElseKeyword = function (elseKeyword) {
            return this.update(elseKeyword, this.statement);
        };

        ElseClauseSyntax.prototype.withStatement = function (statement) {
            return this.update(this.elseKeyword, statement);
        };

        ElseClauseSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.statement.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ElseClauseSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ElseClauseSyntax = ElseClauseSyntax;

    var IfStatementSyntax = (function (_super) {
        __extends(IfStatementSyntax, _super);
        function IfStatementSyntax(ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.ifKeyword = ifKeyword;
            this.openParenToken = openParenToken;
            this.condition = condition;
            this.closeParenToken = closeParenToken;
            this.statement = statement;
            this.elseClause = elseClause;
        }
        IfStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitIfStatement(this);
        };

        IfStatementSyntax.prototype.kind = function () {
            return 146 /* IfStatement */;
        };

        IfStatementSyntax.prototype.childCount = function () {
            return 6;
        };

        IfStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.ifKeyword;
                case 1:
                    return this.openParenToken;
                case 2:
                    return this.condition;
                case 3:
                    return this.closeParenToken;
                case 4:
                    return this.statement;
                case 5:
                    return this.elseClause;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        IfStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        IfStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        IfStatementSyntax.prototype.update = function (ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause) {
            if (this.ifKeyword === ifKeyword && this.openParenToken === openParenToken && this.condition === condition && this.closeParenToken === closeParenToken && this.statement === statement && this.elseClause === elseClause) {
                return this;
            }

            return new IfStatementSyntax(ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause, this.parsedInStrictMode());
        };

        IfStatementSyntax.create = function (ifKeyword, openParenToken, condition, closeParenToken, statement) {
            return new IfStatementSyntax(ifKeyword, openParenToken, condition, closeParenToken, statement, null, false);
        };

        IfStatementSyntax.create1 = function (condition, statement) {
            return new IfStatementSyntax(TypeScript.Syntax.token(28 /* IfKeyword */), TypeScript.Syntax.token(72 /* OpenParenToken */), condition, TypeScript.Syntax.token(73 /* CloseParenToken */), statement, null, false);
        };

        IfStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        IfStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        IfStatementSyntax.prototype.withIfKeyword = function (ifKeyword) {
            return this.update(ifKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, this.elseClause);
        };

        IfStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.ifKeyword, openParenToken, this.condition, this.closeParenToken, this.statement, this.elseClause);
        };

        IfStatementSyntax.prototype.withCondition = function (condition) {
            return this.update(this.ifKeyword, this.openParenToken, condition, this.closeParenToken, this.statement, this.elseClause);
        };

        IfStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.ifKeyword, this.openParenToken, this.condition, closeParenToken, this.statement, this.elseClause);
        };

        IfStatementSyntax.prototype.withStatement = function (statement) {
            return this.update(this.ifKeyword, this.openParenToken, this.condition, this.closeParenToken, statement, this.elseClause);
        };

        IfStatementSyntax.prototype.withElseClause = function (elseClause) {
            return this.update(this.ifKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement, elseClause);
        };

        IfStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.condition.isTypeScriptSpecific()) {
                return true;
            }
            if (this.statement.isTypeScriptSpecific()) {
                return true;
            }
            if (this.elseClause !== null && this.elseClause.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return IfStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.IfStatementSyntax = IfStatementSyntax;

    var ExpressionStatementSyntax = (function (_super) {
        __extends(ExpressionStatementSyntax, _super);
        function ExpressionStatementSyntax(expression, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.expression = expression;
            this.semicolonToken = semicolonToken;
        }
        ExpressionStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitExpressionStatement(this);
        };

        ExpressionStatementSyntax.prototype.kind = function () {
            return 148 /* ExpressionStatement */;
        };

        ExpressionStatementSyntax.prototype.childCount = function () {
            return 2;
        };

        ExpressionStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.expression;
                case 1:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ExpressionStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        ExpressionStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        ExpressionStatementSyntax.prototype.update = function (expression, semicolonToken) {
            if (this.expression === expression && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new ExpressionStatementSyntax(expression, semicolonToken, this.parsedInStrictMode());
        };

        ExpressionStatementSyntax.create1 = function (expression) {
            return new ExpressionStatementSyntax(expression, TypeScript.Syntax.token(78 /* SemicolonToken */), false);
        };

        ExpressionStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ExpressionStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ExpressionStatementSyntax.prototype.withExpression = function (expression) {
            return this.update(expression, this.semicolonToken);
        };

        ExpressionStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.expression, semicolonToken);
        };

        ExpressionStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ExpressionStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ExpressionStatementSyntax = ExpressionStatementSyntax;

    var ConstructorDeclarationSyntax = (function (_super) {
        __extends(ConstructorDeclarationSyntax, _super);
        function ConstructorDeclarationSyntax(constructorKeyword, parameterList, block, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.constructorKeyword = constructorKeyword;
            this.parameterList = parameterList;
            this.block = block;
            this.semicolonToken = semicolonToken;
        }
        ConstructorDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitConstructorDeclaration(this);
        };

        ConstructorDeclarationSyntax.prototype.kind = function () {
            return 137 /* ConstructorDeclaration */;
        };

        ConstructorDeclarationSyntax.prototype.childCount = function () {
            return 4;
        };

        ConstructorDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.constructorKeyword;
                case 1:
                    return this.parameterList;
                case 2:
                    return this.block;
                case 3:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ConstructorDeclarationSyntax.prototype.isClassElement = function () {
            return true;
        };

        ConstructorDeclarationSyntax.prototype.update = function (constructorKeyword, parameterList, block, semicolonToken) {
            if (this.constructorKeyword === constructorKeyword && this.parameterList === parameterList && this.block === block && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new ConstructorDeclarationSyntax(constructorKeyword, parameterList, block, semicolonToken, this.parsedInStrictMode());
        };

        ConstructorDeclarationSyntax.create = function (constructorKeyword, parameterList) {
            return new ConstructorDeclarationSyntax(constructorKeyword, parameterList, null, null, false);
        };

        ConstructorDeclarationSyntax.create1 = function () {
            return new ConstructorDeclarationSyntax(TypeScript.Syntax.token(62 /* ConstructorKeyword */), ParameterListSyntax.create1(), null, null, false);
        };

        ConstructorDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ConstructorDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ConstructorDeclarationSyntax.prototype.withConstructorKeyword = function (constructorKeyword) {
            return this.update(constructorKeyword, this.parameterList, this.block, this.semicolonToken);
        };

        ConstructorDeclarationSyntax.prototype.withParameterList = function (parameterList) {
            return this.update(this.constructorKeyword, parameterList, this.block, this.semicolonToken);
        };

        ConstructorDeclarationSyntax.prototype.withBlock = function (block) {
            return this.update(this.constructorKeyword, this.parameterList, block, this.semicolonToken);
        };

        ConstructorDeclarationSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.constructorKeyword, this.parameterList, this.block, semicolonToken);
        };

        ConstructorDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return ConstructorDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ConstructorDeclarationSyntax = ConstructorDeclarationSyntax;

    var MemberFunctionDeclarationSyntax = (function (_super) {
        __extends(MemberFunctionDeclarationSyntax, _super);
        function MemberFunctionDeclarationSyntax(modifiers, propertyName, callSignature, block, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.modifiers = modifiers;
            this.propertyName = propertyName;
            this.callSignature = callSignature;
            this.block = block;
            this.semicolonToken = semicolonToken;
        }
        MemberFunctionDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitMemberFunctionDeclaration(this);
        };

        MemberFunctionDeclarationSyntax.prototype.kind = function () {
            return 135 /* MemberFunctionDeclaration */;
        };

        MemberFunctionDeclarationSyntax.prototype.childCount = function () {
            return 5;
        };

        MemberFunctionDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.propertyName;
                case 2:
                    return this.callSignature;
                case 3:
                    return this.block;
                case 4:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        MemberFunctionDeclarationSyntax.prototype.isMemberDeclaration = function () {
            return true;
        };

        MemberFunctionDeclarationSyntax.prototype.isClassElement = function () {
            return true;
        };

        MemberFunctionDeclarationSyntax.prototype.update = function (modifiers, propertyName, callSignature, block, semicolonToken) {
            if (this.modifiers === modifiers && this.propertyName === propertyName && this.callSignature === callSignature && this.block === block && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new MemberFunctionDeclarationSyntax(modifiers, propertyName, callSignature, block, semicolonToken, this.parsedInStrictMode());
        };

        MemberFunctionDeclarationSyntax.create = function (propertyName, callSignature) {
            return new MemberFunctionDeclarationSyntax(TypeScript.Syntax.emptyList, propertyName, callSignature, null, null, false);
        };

        MemberFunctionDeclarationSyntax.create1 = function (propertyName) {
            return new MemberFunctionDeclarationSyntax(TypeScript.Syntax.emptyList, propertyName, CallSignatureSyntax.create1(), null, null, false);
        };

        MemberFunctionDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        MemberFunctionDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        MemberFunctionDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.propertyName, this.callSignature, this.block, this.semicolonToken);
        };

        MemberFunctionDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };

        MemberFunctionDeclarationSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(this.modifiers, propertyName, this.callSignature, this.block, this.semicolonToken);
        };

        MemberFunctionDeclarationSyntax.prototype.withCallSignature = function (callSignature) {
            return this.update(this.modifiers, this.propertyName, callSignature, this.block, this.semicolonToken);
        };

        MemberFunctionDeclarationSyntax.prototype.withBlock = function (block) {
            return this.update(this.modifiers, this.propertyName, this.callSignature, block, this.semicolonToken);
        };

        MemberFunctionDeclarationSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.modifiers, this.propertyName, this.callSignature, this.block, semicolonToken);
        };

        MemberFunctionDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return MemberFunctionDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.MemberFunctionDeclarationSyntax = MemberFunctionDeclarationSyntax;

    var MemberAccessorDeclarationSyntax = (function (_super) {
        __extends(MemberAccessorDeclarationSyntax, _super);
        function MemberAccessorDeclarationSyntax(modifiers, propertyName, parameterList, block, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.modifiers = modifiers;
            this.propertyName = propertyName;
            this.parameterList = parameterList;
            this.block = block;
        }
        MemberAccessorDeclarationSyntax.prototype.isMemberDeclaration = function () {
            return true;
        };

        MemberAccessorDeclarationSyntax.prototype.isClassElement = function () {
            return true;
        };

        MemberAccessorDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        MemberAccessorDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        MemberAccessorDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return MemberAccessorDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.MemberAccessorDeclarationSyntax = MemberAccessorDeclarationSyntax;

    var GetMemberAccessorDeclarationSyntax = (function (_super) {
        __extends(GetMemberAccessorDeclarationSyntax, _super);
        function GetMemberAccessorDeclarationSyntax(modifiers, getKeyword, propertyName, parameterList, typeAnnotation, block, parsedInStrictMode) {
            _super.call(this, modifiers, propertyName, parameterList, block, parsedInStrictMode);
            this.getKeyword = getKeyword;
            this.typeAnnotation = typeAnnotation;
        }
        GetMemberAccessorDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitGetMemberAccessorDeclaration(this);
        };

        GetMemberAccessorDeclarationSyntax.prototype.kind = function () {
            return 138 /* GetMemberAccessorDeclaration */;
        };

        GetMemberAccessorDeclarationSyntax.prototype.childCount = function () {
            return 6;
        };

        GetMemberAccessorDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.getKeyword;
                case 2:
                    return this.propertyName;
                case 3:
                    return this.parameterList;
                case 4:
                    return this.typeAnnotation;
                case 5:
                    return this.block;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        GetMemberAccessorDeclarationSyntax.prototype.update = function (modifiers, getKeyword, propertyName, parameterList, typeAnnotation, block) {
            if (this.modifiers === modifiers && this.getKeyword === getKeyword && this.propertyName === propertyName && this.parameterList === parameterList && this.typeAnnotation === typeAnnotation && this.block === block) {
                return this;
            }

            return new GetMemberAccessorDeclarationSyntax(modifiers, getKeyword, propertyName, parameterList, typeAnnotation, block, this.parsedInStrictMode());
        };

        GetMemberAccessorDeclarationSyntax.create = function (getKeyword, propertyName, parameterList, block) {
            return new GetMemberAccessorDeclarationSyntax(TypeScript.Syntax.emptyList, getKeyword, propertyName, parameterList, null, block, false);
        };

        GetMemberAccessorDeclarationSyntax.create1 = function (propertyName) {
            return new GetMemberAccessorDeclarationSyntax(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(64 /* GetKeyword */), propertyName, ParameterListSyntax.create1(), null, BlockSyntax.create1(), false);
        };

        GetMemberAccessorDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        GetMemberAccessorDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        GetMemberAccessorDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.getKeyword, this.propertyName, this.parameterList, this.typeAnnotation, this.block);
        };

        GetMemberAccessorDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };

        GetMemberAccessorDeclarationSyntax.prototype.withGetKeyword = function (getKeyword) {
            return this.update(this.modifiers, getKeyword, this.propertyName, this.parameterList, this.typeAnnotation, this.block);
        };

        GetMemberAccessorDeclarationSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(this.modifiers, this.getKeyword, propertyName, this.parameterList, this.typeAnnotation, this.block);
        };

        GetMemberAccessorDeclarationSyntax.prototype.withParameterList = function (parameterList) {
            return this.update(this.modifiers, this.getKeyword, this.propertyName, parameterList, this.typeAnnotation, this.block);
        };

        GetMemberAccessorDeclarationSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
            return this.update(this.modifiers, this.getKeyword, this.propertyName, this.parameterList, typeAnnotation, this.block);
        };

        GetMemberAccessorDeclarationSyntax.prototype.withBlock = function (block) {
            return this.update(this.modifiers, this.getKeyword, this.propertyName, this.parameterList, this.typeAnnotation, block);
        };

        GetMemberAccessorDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return GetMemberAccessorDeclarationSyntax;
    })(MemberAccessorDeclarationSyntax);
    TypeScript.GetMemberAccessorDeclarationSyntax = GetMemberAccessorDeclarationSyntax;

    var SetMemberAccessorDeclarationSyntax = (function (_super) {
        __extends(SetMemberAccessorDeclarationSyntax, _super);
        function SetMemberAccessorDeclarationSyntax(modifiers, setKeyword, propertyName, parameterList, block, parsedInStrictMode) {
            _super.call(this, modifiers, propertyName, parameterList, block, parsedInStrictMode);
            this.setKeyword = setKeyword;
        }
        SetMemberAccessorDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitSetMemberAccessorDeclaration(this);
        };

        SetMemberAccessorDeclarationSyntax.prototype.kind = function () {
            return 139 /* SetMemberAccessorDeclaration */;
        };

        SetMemberAccessorDeclarationSyntax.prototype.childCount = function () {
            return 5;
        };

        SetMemberAccessorDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.setKeyword;
                case 2:
                    return this.propertyName;
                case 3:
                    return this.parameterList;
                case 4:
                    return this.block;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        SetMemberAccessorDeclarationSyntax.prototype.update = function (modifiers, setKeyword, propertyName, parameterList, block) {
            if (this.modifiers === modifiers && this.setKeyword === setKeyword && this.propertyName === propertyName && this.parameterList === parameterList && this.block === block) {
                return this;
            }

            return new SetMemberAccessorDeclarationSyntax(modifiers, setKeyword, propertyName, parameterList, block, this.parsedInStrictMode());
        };

        SetMemberAccessorDeclarationSyntax.create = function (setKeyword, propertyName, parameterList, block) {
            return new SetMemberAccessorDeclarationSyntax(TypeScript.Syntax.emptyList, setKeyword, propertyName, parameterList, block, false);
        };

        SetMemberAccessorDeclarationSyntax.create1 = function (propertyName) {
            return new SetMemberAccessorDeclarationSyntax(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(68 /* SetKeyword */), propertyName, ParameterListSyntax.create1(), BlockSyntax.create1(), false);
        };

        SetMemberAccessorDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        SetMemberAccessorDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        SetMemberAccessorDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.setKeyword, this.propertyName, this.parameterList, this.block);
        };

        SetMemberAccessorDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };

        SetMemberAccessorDeclarationSyntax.prototype.withSetKeyword = function (setKeyword) {
            return this.update(this.modifiers, setKeyword, this.propertyName, this.parameterList, this.block);
        };

        SetMemberAccessorDeclarationSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(this.modifiers, this.setKeyword, propertyName, this.parameterList, this.block);
        };

        SetMemberAccessorDeclarationSyntax.prototype.withParameterList = function (parameterList) {
            return this.update(this.modifiers, this.setKeyword, this.propertyName, parameterList, this.block);
        };

        SetMemberAccessorDeclarationSyntax.prototype.withBlock = function (block) {
            return this.update(this.modifiers, this.setKeyword, this.propertyName, this.parameterList, block);
        };

        SetMemberAccessorDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return SetMemberAccessorDeclarationSyntax;
    })(MemberAccessorDeclarationSyntax);
    TypeScript.SetMemberAccessorDeclarationSyntax = SetMemberAccessorDeclarationSyntax;

    var MemberVariableDeclarationSyntax = (function (_super) {
        __extends(MemberVariableDeclarationSyntax, _super);
        function MemberVariableDeclarationSyntax(modifiers, variableDeclarator, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.modifiers = modifiers;
            this.variableDeclarator = variableDeclarator;
            this.semicolonToken = semicolonToken;
        }
        MemberVariableDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitMemberVariableDeclaration(this);
        };

        MemberVariableDeclarationSyntax.prototype.kind = function () {
            return 136 /* MemberVariableDeclaration */;
        };

        MemberVariableDeclarationSyntax.prototype.childCount = function () {
            return 3;
        };

        MemberVariableDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.variableDeclarator;
                case 2:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        MemberVariableDeclarationSyntax.prototype.isMemberDeclaration = function () {
            return true;
        };

        MemberVariableDeclarationSyntax.prototype.isClassElement = function () {
            return true;
        };

        MemberVariableDeclarationSyntax.prototype.update = function (modifiers, variableDeclarator, semicolonToken) {
            if (this.modifiers === modifiers && this.variableDeclarator === variableDeclarator && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new MemberVariableDeclarationSyntax(modifiers, variableDeclarator, semicolonToken, this.parsedInStrictMode());
        };

        MemberVariableDeclarationSyntax.create = function (variableDeclarator, semicolonToken) {
            return new MemberVariableDeclarationSyntax(TypeScript.Syntax.emptyList, variableDeclarator, semicolonToken, false);
        };

        MemberVariableDeclarationSyntax.create1 = function (variableDeclarator) {
            return new MemberVariableDeclarationSyntax(TypeScript.Syntax.emptyList, variableDeclarator, TypeScript.Syntax.token(78 /* SemicolonToken */), false);
        };

        MemberVariableDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        MemberVariableDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        MemberVariableDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.variableDeclarator, this.semicolonToken);
        };

        MemberVariableDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };

        MemberVariableDeclarationSyntax.prototype.withVariableDeclarator = function (variableDeclarator) {
            return this.update(this.modifiers, variableDeclarator, this.semicolonToken);
        };

        MemberVariableDeclarationSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.modifiers, this.variableDeclarator, semicolonToken);
        };

        MemberVariableDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return MemberVariableDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.MemberVariableDeclarationSyntax = MemberVariableDeclarationSyntax;

    var ThrowStatementSyntax = (function (_super) {
        __extends(ThrowStatementSyntax, _super);
        function ThrowStatementSyntax(throwKeyword, expression, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.throwKeyword = throwKeyword;
            this.expression = expression;
            this.semicolonToken = semicolonToken;
        }
        ThrowStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitThrowStatement(this);
        };

        ThrowStatementSyntax.prototype.kind = function () {
            return 156 /* ThrowStatement */;
        };

        ThrowStatementSyntax.prototype.childCount = function () {
            return 3;
        };

        ThrowStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.throwKeyword;
                case 1:
                    return this.expression;
                case 2:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ThrowStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        ThrowStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        ThrowStatementSyntax.prototype.update = function (throwKeyword, expression, semicolonToken) {
            if (this.throwKeyword === throwKeyword && this.expression === expression && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new ThrowStatementSyntax(throwKeyword, expression, semicolonToken, this.parsedInStrictMode());
        };

        ThrowStatementSyntax.create1 = function (expression) {
            return new ThrowStatementSyntax(TypeScript.Syntax.token(36 /* ThrowKeyword */), expression, TypeScript.Syntax.token(78 /* SemicolonToken */), false);
        };

        ThrowStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ThrowStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ThrowStatementSyntax.prototype.withThrowKeyword = function (throwKeyword) {
            return this.update(throwKeyword, this.expression, this.semicolonToken);
        };

        ThrowStatementSyntax.prototype.withExpression = function (expression) {
            return this.update(this.throwKeyword, expression, this.semicolonToken);
        };

        ThrowStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.throwKeyword, this.expression, semicolonToken);
        };

        ThrowStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ThrowStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ThrowStatementSyntax = ThrowStatementSyntax;

    var ReturnStatementSyntax = (function (_super) {
        __extends(ReturnStatementSyntax, _super);
        function ReturnStatementSyntax(returnKeyword, expression, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.returnKeyword = returnKeyword;
            this.expression = expression;
            this.semicolonToken = semicolonToken;
        }
        ReturnStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitReturnStatement(this);
        };

        ReturnStatementSyntax.prototype.kind = function () {
            return 149 /* ReturnStatement */;
        };

        ReturnStatementSyntax.prototype.childCount = function () {
            return 3;
        };

        ReturnStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.returnKeyword;
                case 1:
                    return this.expression;
                case 2:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ReturnStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        ReturnStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        ReturnStatementSyntax.prototype.update = function (returnKeyword, expression, semicolonToken) {
            if (this.returnKeyword === returnKeyword && this.expression === expression && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new ReturnStatementSyntax(returnKeyword, expression, semicolonToken, this.parsedInStrictMode());
        };

        ReturnStatementSyntax.create = function (returnKeyword, semicolonToken) {
            return new ReturnStatementSyntax(returnKeyword, null, semicolonToken, false);
        };

        ReturnStatementSyntax.create1 = function () {
            return new ReturnStatementSyntax(TypeScript.Syntax.token(33 /* ReturnKeyword */), null, TypeScript.Syntax.token(78 /* SemicolonToken */), false);
        };

        ReturnStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ReturnStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ReturnStatementSyntax.prototype.withReturnKeyword = function (returnKeyword) {
            return this.update(returnKeyword, this.expression, this.semicolonToken);
        };

        ReturnStatementSyntax.prototype.withExpression = function (expression) {
            return this.update(this.returnKeyword, expression, this.semicolonToken);
        };

        ReturnStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.returnKeyword, this.expression, semicolonToken);
        };

        ReturnStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression !== null && this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ReturnStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ReturnStatementSyntax = ReturnStatementSyntax;

    var ObjectCreationExpressionSyntax = (function (_super) {
        __extends(ObjectCreationExpressionSyntax, _super);
        function ObjectCreationExpressionSyntax(newKeyword, expression, argumentList, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.newKeyword = newKeyword;
            this.expression = expression;
            this.argumentList = argumentList;
        }
        ObjectCreationExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitObjectCreationExpression(this);
        };

        ObjectCreationExpressionSyntax.prototype.kind = function () {
            return 215 /* ObjectCreationExpression */;
        };

        ObjectCreationExpressionSyntax.prototype.childCount = function () {
            return 3;
        };

        ObjectCreationExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.newKeyword;
                case 1:
                    return this.expression;
                case 2:
                    return this.argumentList;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ObjectCreationExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        ObjectCreationExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        ObjectCreationExpressionSyntax.prototype.update = function (newKeyword, expression, argumentList) {
            if (this.newKeyword === newKeyword && this.expression === expression && this.argumentList === argumentList) {
                return this;
            }

            return new ObjectCreationExpressionSyntax(newKeyword, expression, argumentList, this.parsedInStrictMode());
        };

        ObjectCreationExpressionSyntax.create = function (newKeyword, expression) {
            return new ObjectCreationExpressionSyntax(newKeyword, expression, null, false);
        };

        ObjectCreationExpressionSyntax.create1 = function (expression) {
            return new ObjectCreationExpressionSyntax(TypeScript.Syntax.token(31 /* NewKeyword */), expression, null, false);
        };

        ObjectCreationExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ObjectCreationExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ObjectCreationExpressionSyntax.prototype.withNewKeyword = function (newKeyword) {
            return this.update(newKeyword, this.expression, this.argumentList);
        };

        ObjectCreationExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(this.newKeyword, expression, this.argumentList);
        };

        ObjectCreationExpressionSyntax.prototype.withArgumentList = function (argumentList) {
            return this.update(this.newKeyword, this.expression, argumentList);
        };

        ObjectCreationExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            if (this.argumentList !== null && this.argumentList.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ObjectCreationExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ObjectCreationExpressionSyntax = ObjectCreationExpressionSyntax;

    var SwitchStatementSyntax = (function (_super) {
        __extends(SwitchStatementSyntax, _super);
        function SwitchStatementSyntax(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.switchKeyword = switchKeyword;
            this.openParenToken = openParenToken;
            this.expression = expression;
            this.closeParenToken = closeParenToken;
            this.openBraceToken = openBraceToken;
            this.switchClauses = switchClauses;
            this.closeBraceToken = closeBraceToken;
        }
        SwitchStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitSwitchStatement(this);
        };

        SwitchStatementSyntax.prototype.kind = function () {
            return 150 /* SwitchStatement */;
        };

        SwitchStatementSyntax.prototype.childCount = function () {
            return 7;
        };

        SwitchStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.switchKeyword;
                case 1:
                    return this.openParenToken;
                case 2:
                    return this.expression;
                case 3:
                    return this.closeParenToken;
                case 4:
                    return this.openBraceToken;
                case 5:
                    return this.switchClauses;
                case 6:
                    return this.closeBraceToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        SwitchStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        SwitchStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        SwitchStatementSyntax.prototype.update = function (switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken) {
            if (this.switchKeyword === switchKeyword && this.openParenToken === openParenToken && this.expression === expression && this.closeParenToken === closeParenToken && this.openBraceToken === openBraceToken && this.switchClauses === switchClauses && this.closeBraceToken === closeBraceToken) {
                return this;
            }

            return new SwitchStatementSyntax(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken, this.parsedInStrictMode());
        };

        SwitchStatementSyntax.create = function (switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, closeBraceToken) {
            return new SwitchStatementSyntax(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, TypeScript.Syntax.emptyList, closeBraceToken, false);
        };

        SwitchStatementSyntax.create1 = function (expression) {
            return new SwitchStatementSyntax(TypeScript.Syntax.token(34 /* SwitchKeyword */), TypeScript.Syntax.token(72 /* OpenParenToken */), expression, TypeScript.Syntax.token(73 /* CloseParenToken */), TypeScript.Syntax.token(70 /* OpenBraceToken */), TypeScript.Syntax.emptyList, TypeScript.Syntax.token(71 /* CloseBraceToken */), false);
        };

        SwitchStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        SwitchStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        SwitchStatementSyntax.prototype.withSwitchKeyword = function (switchKeyword) {
            return this.update(switchKeyword, this.openParenToken, this.expression, this.closeParenToken, this.openBraceToken, this.switchClauses, this.closeBraceToken);
        };

        SwitchStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.switchKeyword, openParenToken, this.expression, this.closeParenToken, this.openBraceToken, this.switchClauses, this.closeBraceToken);
        };

        SwitchStatementSyntax.prototype.withExpression = function (expression) {
            return this.update(this.switchKeyword, this.openParenToken, expression, this.closeParenToken, this.openBraceToken, this.switchClauses, this.closeBraceToken);
        };

        SwitchStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.switchKeyword, this.openParenToken, this.expression, closeParenToken, this.openBraceToken, this.switchClauses, this.closeBraceToken);
        };

        SwitchStatementSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
            return this.update(this.switchKeyword, this.openParenToken, this.expression, this.closeParenToken, openBraceToken, this.switchClauses, this.closeBraceToken);
        };

        SwitchStatementSyntax.prototype.withSwitchClauses = function (switchClauses) {
            return this.update(this.switchKeyword, this.openParenToken, this.expression, this.closeParenToken, this.openBraceToken, switchClauses, this.closeBraceToken);
        };

        SwitchStatementSyntax.prototype.withSwitchClause = function (switchClause) {
            return this.withSwitchClauses(TypeScript.Syntax.list([switchClause]));
        };

        SwitchStatementSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
            return this.update(this.switchKeyword, this.openParenToken, this.expression, this.closeParenToken, this.openBraceToken, this.switchClauses, closeBraceToken);
        };

        SwitchStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            if (this.switchClauses.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return SwitchStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.SwitchStatementSyntax = SwitchStatementSyntax;

    var SwitchClauseSyntax = (function (_super) {
        __extends(SwitchClauseSyntax, _super);
        function SwitchClauseSyntax(colonToken, statements, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.colonToken = colonToken;
            this.statements = statements;
        }
        SwitchClauseSyntax.prototype.isSwitchClause = function () {
            return true;
        };

        SwitchClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        SwitchClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        SwitchClauseSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return SwitchClauseSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.SwitchClauseSyntax = SwitchClauseSyntax;

    var CaseSwitchClauseSyntax = (function (_super) {
        __extends(CaseSwitchClauseSyntax, _super);
        function CaseSwitchClauseSyntax(caseKeyword, expression, colonToken, statements, parsedInStrictMode) {
            _super.call(this, colonToken, statements, parsedInStrictMode);
            this.caseKeyword = caseKeyword;
            this.expression = expression;
        }
        CaseSwitchClauseSyntax.prototype.accept = function (visitor) {
            return visitor.visitCaseSwitchClause(this);
        };

        CaseSwitchClauseSyntax.prototype.kind = function () {
            return 231 /* CaseSwitchClause */;
        };

        CaseSwitchClauseSyntax.prototype.childCount = function () {
            return 4;
        };

        CaseSwitchClauseSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.caseKeyword;
                case 1:
                    return this.expression;
                case 2:
                    return this.colonToken;
                case 3:
                    return this.statements;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        CaseSwitchClauseSyntax.prototype.update = function (caseKeyword, expression, colonToken, statements) {
            if (this.caseKeyword === caseKeyword && this.expression === expression && this.colonToken === colonToken && this.statements === statements) {
                return this;
            }

            return new CaseSwitchClauseSyntax(caseKeyword, expression, colonToken, statements, this.parsedInStrictMode());
        };

        CaseSwitchClauseSyntax.create = function (caseKeyword, expression, colonToken) {
            return new CaseSwitchClauseSyntax(caseKeyword, expression, colonToken, TypeScript.Syntax.emptyList, false);
        };

        CaseSwitchClauseSyntax.create1 = function (expression) {
            return new CaseSwitchClauseSyntax(TypeScript.Syntax.token(16 /* CaseKeyword */), expression, TypeScript.Syntax.token(106 /* ColonToken */), TypeScript.Syntax.emptyList, false);
        };

        CaseSwitchClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        CaseSwitchClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        CaseSwitchClauseSyntax.prototype.withCaseKeyword = function (caseKeyword) {
            return this.update(caseKeyword, this.expression, this.colonToken, this.statements);
        };

        CaseSwitchClauseSyntax.prototype.withExpression = function (expression) {
            return this.update(this.caseKeyword, expression, this.colonToken, this.statements);
        };

        CaseSwitchClauseSyntax.prototype.withColonToken = function (colonToken) {
            return this.update(this.caseKeyword, this.expression, colonToken, this.statements);
        };

        CaseSwitchClauseSyntax.prototype.withStatements = function (statements) {
            return this.update(this.caseKeyword, this.expression, this.colonToken, statements);
        };

        CaseSwitchClauseSyntax.prototype.withStatement = function (statement) {
            return this.withStatements(TypeScript.Syntax.list([statement]));
        };

        CaseSwitchClauseSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            if (this.statements.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return CaseSwitchClauseSyntax;
    })(SwitchClauseSyntax);
    TypeScript.CaseSwitchClauseSyntax = CaseSwitchClauseSyntax;

    var DefaultSwitchClauseSyntax = (function (_super) {
        __extends(DefaultSwitchClauseSyntax, _super);
        function DefaultSwitchClauseSyntax(defaultKeyword, colonToken, statements, parsedInStrictMode) {
            _super.call(this, colonToken, statements, parsedInStrictMode);
            this.defaultKeyword = defaultKeyword;
        }
        DefaultSwitchClauseSyntax.prototype.accept = function (visitor) {
            return visitor.visitDefaultSwitchClause(this);
        };

        DefaultSwitchClauseSyntax.prototype.kind = function () {
            return 232 /* DefaultSwitchClause */;
        };

        DefaultSwitchClauseSyntax.prototype.childCount = function () {
            return 3;
        };

        DefaultSwitchClauseSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.defaultKeyword;
                case 1:
                    return this.colonToken;
                case 2:
                    return this.statements;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        DefaultSwitchClauseSyntax.prototype.update = function (defaultKeyword, colonToken, statements) {
            if (this.defaultKeyword === defaultKeyword && this.colonToken === colonToken && this.statements === statements) {
                return this;
            }

            return new DefaultSwitchClauseSyntax(defaultKeyword, colonToken, statements, this.parsedInStrictMode());
        };

        DefaultSwitchClauseSyntax.create = function (defaultKeyword, colonToken) {
            return new DefaultSwitchClauseSyntax(defaultKeyword, colonToken, TypeScript.Syntax.emptyList, false);
        };

        DefaultSwitchClauseSyntax.create1 = function () {
            return new DefaultSwitchClauseSyntax(TypeScript.Syntax.token(20 /* DefaultKeyword */), TypeScript.Syntax.token(106 /* ColonToken */), TypeScript.Syntax.emptyList, false);
        };

        DefaultSwitchClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        DefaultSwitchClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        DefaultSwitchClauseSyntax.prototype.withDefaultKeyword = function (defaultKeyword) {
            return this.update(defaultKeyword, this.colonToken, this.statements);
        };

        DefaultSwitchClauseSyntax.prototype.withColonToken = function (colonToken) {
            return this.update(this.defaultKeyword, colonToken, this.statements);
        };

        DefaultSwitchClauseSyntax.prototype.withStatements = function (statements) {
            return this.update(this.defaultKeyword, this.colonToken, statements);
        };

        DefaultSwitchClauseSyntax.prototype.withStatement = function (statement) {
            return this.withStatements(TypeScript.Syntax.list([statement]));
        };

        DefaultSwitchClauseSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.statements.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return DefaultSwitchClauseSyntax;
    })(SwitchClauseSyntax);
    TypeScript.DefaultSwitchClauseSyntax = DefaultSwitchClauseSyntax;

    var BreakStatementSyntax = (function (_super) {
        __extends(BreakStatementSyntax, _super);
        function BreakStatementSyntax(breakKeyword, identifier, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.breakKeyword = breakKeyword;
            this.identifier = identifier;
            this.semicolonToken = semicolonToken;
        }
        BreakStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitBreakStatement(this);
        };

        BreakStatementSyntax.prototype.kind = function () {
            return 151 /* BreakStatement */;
        };

        BreakStatementSyntax.prototype.childCount = function () {
            return 3;
        };

        BreakStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.breakKeyword;
                case 1:
                    return this.identifier;
                case 2:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        BreakStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        BreakStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        BreakStatementSyntax.prototype.update = function (breakKeyword, identifier, semicolonToken) {
            if (this.breakKeyword === breakKeyword && this.identifier === identifier && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new BreakStatementSyntax(breakKeyword, identifier, semicolonToken, this.parsedInStrictMode());
        };

        BreakStatementSyntax.create = function (breakKeyword, semicolonToken) {
            return new BreakStatementSyntax(breakKeyword, null, semicolonToken, false);
        };

        BreakStatementSyntax.create1 = function () {
            return new BreakStatementSyntax(TypeScript.Syntax.token(15 /* BreakKeyword */), null, TypeScript.Syntax.token(78 /* SemicolonToken */), false);
        };

        BreakStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        BreakStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        BreakStatementSyntax.prototype.withBreakKeyword = function (breakKeyword) {
            return this.update(breakKeyword, this.identifier, this.semicolonToken);
        };

        BreakStatementSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.breakKeyword, identifier, this.semicolonToken);
        };

        BreakStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.breakKeyword, this.identifier, semicolonToken);
        };

        BreakStatementSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return BreakStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.BreakStatementSyntax = BreakStatementSyntax;

    var ContinueStatementSyntax = (function (_super) {
        __extends(ContinueStatementSyntax, _super);
        function ContinueStatementSyntax(continueKeyword, identifier, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.continueKeyword = continueKeyword;
            this.identifier = identifier;
            this.semicolonToken = semicolonToken;
        }
        ContinueStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitContinueStatement(this);
        };

        ContinueStatementSyntax.prototype.kind = function () {
            return 152 /* ContinueStatement */;
        };

        ContinueStatementSyntax.prototype.childCount = function () {
            return 3;
        };

        ContinueStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.continueKeyword;
                case 1:
                    return this.identifier;
                case 2:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ContinueStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        ContinueStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        ContinueStatementSyntax.prototype.update = function (continueKeyword, identifier, semicolonToken) {
            if (this.continueKeyword === continueKeyword && this.identifier === identifier && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new ContinueStatementSyntax(continueKeyword, identifier, semicolonToken, this.parsedInStrictMode());
        };

        ContinueStatementSyntax.create = function (continueKeyword, semicolonToken) {
            return new ContinueStatementSyntax(continueKeyword, null, semicolonToken, false);
        };

        ContinueStatementSyntax.create1 = function () {
            return new ContinueStatementSyntax(TypeScript.Syntax.token(18 /* ContinueKeyword */), null, TypeScript.Syntax.token(78 /* SemicolonToken */), false);
        };

        ContinueStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ContinueStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ContinueStatementSyntax.prototype.withContinueKeyword = function (continueKeyword) {
            return this.update(continueKeyword, this.identifier, this.semicolonToken);
        };

        ContinueStatementSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.continueKeyword, identifier, this.semicolonToken);
        };

        ContinueStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.continueKeyword, this.identifier, semicolonToken);
        };

        ContinueStatementSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return ContinueStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ContinueStatementSyntax = ContinueStatementSyntax;

    var IterationStatementSyntax = (function (_super) {
        __extends(IterationStatementSyntax, _super);
        function IterationStatementSyntax(openParenToken, closeParenToken, statement, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.openParenToken = openParenToken;
            this.closeParenToken = closeParenToken;
            this.statement = statement;
        }
        IterationStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        IterationStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        IterationStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        IterationStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        IterationStatementSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return IterationStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.IterationStatementSyntax = IterationStatementSyntax;

    var BaseForStatementSyntax = (function (_super) {
        __extends(BaseForStatementSyntax, _super);
        function BaseForStatementSyntax(forKeyword, openParenToken, variableDeclaration, closeParenToken, statement, parsedInStrictMode) {
            _super.call(this, openParenToken, closeParenToken, statement, parsedInStrictMode);
            this.forKeyword = forKeyword;
            this.variableDeclaration = variableDeclaration;
        }
        BaseForStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        BaseForStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        BaseForStatementSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return BaseForStatementSyntax;
    })(IterationStatementSyntax);
    TypeScript.BaseForStatementSyntax = BaseForStatementSyntax;

    var ForStatementSyntax = (function (_super) {
        __extends(ForStatementSyntax, _super);
        function ForStatementSyntax(forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement, parsedInStrictMode) {
            _super.call(this, forKeyword, openParenToken, variableDeclaration, closeParenToken, statement, parsedInStrictMode);
            this.initializer = initializer;
            this.firstSemicolonToken = firstSemicolonToken;
            this.condition = condition;
            this.secondSemicolonToken = secondSemicolonToken;
            this.incrementor = incrementor;
        }
        ForStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitForStatement(this);
        };

        ForStatementSyntax.prototype.kind = function () {
            return 153 /* ForStatement */;
        };

        ForStatementSyntax.prototype.childCount = function () {
            return 10;
        };

        ForStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.forKeyword;
                case 1:
                    return this.openParenToken;
                case 2:
                    return this.variableDeclaration;
                case 3:
                    return this.initializer;
                case 4:
                    return this.firstSemicolonToken;
                case 5:
                    return this.condition;
                case 6:
                    return this.secondSemicolonToken;
                case 7:
                    return this.incrementor;
                case 8:
                    return this.closeParenToken;
                case 9:
                    return this.statement;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ForStatementSyntax.prototype.update = function (forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement) {
            if (this.forKeyword === forKeyword && this.openParenToken === openParenToken && this.variableDeclaration === variableDeclaration && this.initializer === initializer && this.firstSemicolonToken === firstSemicolonToken && this.condition === condition && this.secondSemicolonToken === secondSemicolonToken && this.incrementor === incrementor && this.closeParenToken === closeParenToken && this.statement === statement) {
                return this;
            }

            return new ForStatementSyntax(forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement, this.parsedInStrictMode());
        };

        ForStatementSyntax.create = function (forKeyword, openParenToken, firstSemicolonToken, secondSemicolonToken, closeParenToken, statement) {
            return new ForStatementSyntax(forKeyword, openParenToken, null, null, firstSemicolonToken, null, secondSemicolonToken, null, closeParenToken, statement, false);
        };

        ForStatementSyntax.create1 = function (statement) {
            return new ForStatementSyntax(TypeScript.Syntax.token(26 /* ForKeyword */), TypeScript.Syntax.token(72 /* OpenParenToken */), null, null, TypeScript.Syntax.token(78 /* SemicolonToken */), null, TypeScript.Syntax.token(78 /* SemicolonToken */), null, TypeScript.Syntax.token(73 /* CloseParenToken */), statement, false);
        };

        ForStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ForStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ForStatementSyntax.prototype.withForKeyword = function (forKeyword) {
            return this.update(forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
        };

        ForStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.forKeyword, openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
        };

        ForStatementSyntax.prototype.withVariableDeclaration = function (variableDeclaration) {
            return this.update(this.forKeyword, this.openParenToken, variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
        };

        ForStatementSyntax.prototype.withInitializer = function (initializer) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
        };

        ForStatementSyntax.prototype.withFirstSemicolonToken = function (firstSemicolonToken) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
        };

        ForStatementSyntax.prototype.withCondition = function (condition) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
        };

        ForStatementSyntax.prototype.withSecondSemicolonToken = function (secondSemicolonToken) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, secondSemicolonToken, this.incrementor, this.closeParenToken, this.statement);
        };

        ForStatementSyntax.prototype.withIncrementor = function (incrementor) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, incrementor, this.closeParenToken, this.statement);
        };

        ForStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, closeParenToken, this.statement);
        };

        ForStatementSyntax.prototype.withStatement = function (statement) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.initializer, this.firstSemicolonToken, this.condition, this.secondSemicolonToken, this.incrementor, this.closeParenToken, statement);
        };

        ForStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.variableDeclaration !== null && this.variableDeclaration.isTypeScriptSpecific()) {
                return true;
            }
            if (this.initializer !== null && this.initializer.isTypeScriptSpecific()) {
                return true;
            }
            if (this.condition !== null && this.condition.isTypeScriptSpecific()) {
                return true;
            }
            if (this.incrementor !== null && this.incrementor.isTypeScriptSpecific()) {
                return true;
            }
            if (this.statement.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ForStatementSyntax;
    })(BaseForStatementSyntax);
    TypeScript.ForStatementSyntax = ForStatementSyntax;

    var ForInStatementSyntax = (function (_super) {
        __extends(ForInStatementSyntax, _super);
        function ForInStatementSyntax(forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement, parsedInStrictMode) {
            _super.call(this, forKeyword, openParenToken, variableDeclaration, closeParenToken, statement, parsedInStrictMode);
            this.left = left;
            this.inKeyword = inKeyword;
            this.expression = expression;
        }
        ForInStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitForInStatement(this);
        };

        ForInStatementSyntax.prototype.kind = function () {
            return 154 /* ForInStatement */;
        };

        ForInStatementSyntax.prototype.childCount = function () {
            return 8;
        };

        ForInStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.forKeyword;
                case 1:
                    return this.openParenToken;
                case 2:
                    return this.variableDeclaration;
                case 3:
                    return this.left;
                case 4:
                    return this.inKeyword;
                case 5:
                    return this.expression;
                case 6:
                    return this.closeParenToken;
                case 7:
                    return this.statement;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ForInStatementSyntax.prototype.update = function (forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement) {
            if (this.forKeyword === forKeyword && this.openParenToken === openParenToken && this.variableDeclaration === variableDeclaration && this.left === left && this.inKeyword === inKeyword && this.expression === expression && this.closeParenToken === closeParenToken && this.statement === statement) {
                return this;
            }

            return new ForInStatementSyntax(forKeyword, openParenToken, variableDeclaration, left, inKeyword, expression, closeParenToken, statement, this.parsedInStrictMode());
        };

        ForInStatementSyntax.create = function (forKeyword, openParenToken, inKeyword, expression, closeParenToken, statement) {
            return new ForInStatementSyntax(forKeyword, openParenToken, null, null, inKeyword, expression, closeParenToken, statement, false);
        };

        ForInStatementSyntax.create1 = function (expression, statement) {
            return new ForInStatementSyntax(TypeScript.Syntax.token(26 /* ForKeyword */), TypeScript.Syntax.token(72 /* OpenParenToken */), null, null, TypeScript.Syntax.token(29 /* InKeyword */), expression, TypeScript.Syntax.token(73 /* CloseParenToken */), statement, false);
        };

        ForInStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ForInStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ForInStatementSyntax.prototype.withForKeyword = function (forKeyword) {
            return this.update(forKeyword, this.openParenToken, this.variableDeclaration, this.left, this.inKeyword, this.expression, this.closeParenToken, this.statement);
        };

        ForInStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.forKeyword, openParenToken, this.variableDeclaration, this.left, this.inKeyword, this.expression, this.closeParenToken, this.statement);
        };

        ForInStatementSyntax.prototype.withVariableDeclaration = function (variableDeclaration) {
            return this.update(this.forKeyword, this.openParenToken, variableDeclaration, this.left, this.inKeyword, this.expression, this.closeParenToken, this.statement);
        };

        ForInStatementSyntax.prototype.withLeft = function (left) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, left, this.inKeyword, this.expression, this.closeParenToken, this.statement);
        };

        ForInStatementSyntax.prototype.withInKeyword = function (inKeyword) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.left, inKeyword, this.expression, this.closeParenToken, this.statement);
        };

        ForInStatementSyntax.prototype.withExpression = function (expression) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.left, this.inKeyword, expression, this.closeParenToken, this.statement);
        };

        ForInStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.left, this.inKeyword, this.expression, closeParenToken, this.statement);
        };

        ForInStatementSyntax.prototype.withStatement = function (statement) {
            return this.update(this.forKeyword, this.openParenToken, this.variableDeclaration, this.left, this.inKeyword, this.expression, this.closeParenToken, statement);
        };

        ForInStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.variableDeclaration !== null && this.variableDeclaration.isTypeScriptSpecific()) {
                return true;
            }
            if (this.left !== null && this.left.isTypeScriptSpecific()) {
                return true;
            }
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            if (this.statement.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ForInStatementSyntax;
    })(BaseForStatementSyntax);
    TypeScript.ForInStatementSyntax = ForInStatementSyntax;

    var WhileStatementSyntax = (function (_super) {
        __extends(WhileStatementSyntax, _super);
        function WhileStatementSyntax(whileKeyword, openParenToken, condition, closeParenToken, statement, parsedInStrictMode) {
            _super.call(this, openParenToken, closeParenToken, statement, parsedInStrictMode);
            this.whileKeyword = whileKeyword;
            this.condition = condition;
        }
        WhileStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitWhileStatement(this);
        };

        WhileStatementSyntax.prototype.kind = function () {
            return 157 /* WhileStatement */;
        };

        WhileStatementSyntax.prototype.childCount = function () {
            return 5;
        };

        WhileStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.whileKeyword;
                case 1:
                    return this.openParenToken;
                case 2:
                    return this.condition;
                case 3:
                    return this.closeParenToken;
                case 4:
                    return this.statement;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        WhileStatementSyntax.prototype.update = function (whileKeyword, openParenToken, condition, closeParenToken, statement) {
            if (this.whileKeyword === whileKeyword && this.openParenToken === openParenToken && this.condition === condition && this.closeParenToken === closeParenToken && this.statement === statement) {
                return this;
            }

            return new WhileStatementSyntax(whileKeyword, openParenToken, condition, closeParenToken, statement, this.parsedInStrictMode());
        };

        WhileStatementSyntax.create1 = function (condition, statement) {
            return new WhileStatementSyntax(TypeScript.Syntax.token(42 /* WhileKeyword */), TypeScript.Syntax.token(72 /* OpenParenToken */), condition, TypeScript.Syntax.token(73 /* CloseParenToken */), statement, false);
        };

        WhileStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        WhileStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        WhileStatementSyntax.prototype.withWhileKeyword = function (whileKeyword) {
            return this.update(whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement);
        };

        WhileStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.whileKeyword, openParenToken, this.condition, this.closeParenToken, this.statement);
        };

        WhileStatementSyntax.prototype.withCondition = function (condition) {
            return this.update(this.whileKeyword, this.openParenToken, condition, this.closeParenToken, this.statement);
        };

        WhileStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.whileKeyword, this.openParenToken, this.condition, closeParenToken, this.statement);
        };

        WhileStatementSyntax.prototype.withStatement = function (statement) {
            return this.update(this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, statement);
        };

        WhileStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.condition.isTypeScriptSpecific()) {
                return true;
            }
            if (this.statement.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return WhileStatementSyntax;
    })(IterationStatementSyntax);
    TypeScript.WhileStatementSyntax = WhileStatementSyntax;

    var WithStatementSyntax = (function (_super) {
        __extends(WithStatementSyntax, _super);
        function WithStatementSyntax(withKeyword, openParenToken, condition, closeParenToken, statement, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.withKeyword = withKeyword;
            this.openParenToken = openParenToken;
            this.condition = condition;
            this.closeParenToken = closeParenToken;
            this.statement = statement;
        }
        WithStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitWithStatement(this);
        };

        WithStatementSyntax.prototype.kind = function () {
            return 162 /* WithStatement */;
        };

        WithStatementSyntax.prototype.childCount = function () {
            return 5;
        };

        WithStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.withKeyword;
                case 1:
                    return this.openParenToken;
                case 2:
                    return this.condition;
                case 3:
                    return this.closeParenToken;
                case 4:
                    return this.statement;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        WithStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        WithStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        WithStatementSyntax.prototype.update = function (withKeyword, openParenToken, condition, closeParenToken, statement) {
            if (this.withKeyword === withKeyword && this.openParenToken === openParenToken && this.condition === condition && this.closeParenToken === closeParenToken && this.statement === statement) {
                return this;
            }

            return new WithStatementSyntax(withKeyword, openParenToken, condition, closeParenToken, statement, this.parsedInStrictMode());
        };

        WithStatementSyntax.create1 = function (condition, statement) {
            return new WithStatementSyntax(TypeScript.Syntax.token(43 /* WithKeyword */), TypeScript.Syntax.token(72 /* OpenParenToken */), condition, TypeScript.Syntax.token(73 /* CloseParenToken */), statement, false);
        };

        WithStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        WithStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        WithStatementSyntax.prototype.withWithKeyword = function (withKeyword) {
            return this.update(withKeyword, this.openParenToken, this.condition, this.closeParenToken, this.statement);
        };

        WithStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.withKeyword, openParenToken, this.condition, this.closeParenToken, this.statement);
        };

        WithStatementSyntax.prototype.withCondition = function (condition) {
            return this.update(this.withKeyword, this.openParenToken, condition, this.closeParenToken, this.statement);
        };

        WithStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.withKeyword, this.openParenToken, this.condition, closeParenToken, this.statement);
        };

        WithStatementSyntax.prototype.withStatement = function (statement) {
            return this.update(this.withKeyword, this.openParenToken, this.condition, this.closeParenToken, statement);
        };

        WithStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.condition.isTypeScriptSpecific()) {
                return true;
            }
            if (this.statement.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return WithStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.WithStatementSyntax = WithStatementSyntax;

    var EnumDeclarationSyntax = (function (_super) {
        __extends(EnumDeclarationSyntax, _super);
        function EnumDeclarationSyntax(modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.modifiers = modifiers;
            this.enumKeyword = enumKeyword;
            this.identifier = identifier;
            this.openBraceToken = openBraceToken;
            this.enumElements = enumElements;
            this.closeBraceToken = closeBraceToken;
        }
        EnumDeclarationSyntax.prototype.accept = function (visitor) {
            return visitor.visitEnumDeclaration(this);
        };

        EnumDeclarationSyntax.prototype.kind = function () {
            return 132 /* EnumDeclaration */;
        };

        EnumDeclarationSyntax.prototype.childCount = function () {
            return 6;
        };

        EnumDeclarationSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.modifiers;
                case 1:
                    return this.enumKeyword;
                case 2:
                    return this.identifier;
                case 3:
                    return this.openBraceToken;
                case 4:
                    return this.enumElements;
                case 5:
                    return this.closeBraceToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        EnumDeclarationSyntax.prototype.isModuleElement = function () {
            return true;
        };

        EnumDeclarationSyntax.prototype.update = function (modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken) {
            if (this.modifiers === modifiers && this.enumKeyword === enumKeyword && this.identifier === identifier && this.openBraceToken === openBraceToken && this.enumElements === enumElements && this.closeBraceToken === closeBraceToken) {
                return this;
            }

            return new EnumDeclarationSyntax(modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken, this.parsedInStrictMode());
        };

        EnumDeclarationSyntax.create = function (enumKeyword, identifier, openBraceToken, closeBraceToken) {
            return new EnumDeclarationSyntax(TypeScript.Syntax.emptyList, enumKeyword, identifier, openBraceToken, TypeScript.Syntax.emptySeparatedList, closeBraceToken, false);
        };

        EnumDeclarationSyntax.create1 = function (identifier) {
            return new EnumDeclarationSyntax(TypeScript.Syntax.emptyList, TypeScript.Syntax.token(46 /* EnumKeyword */), identifier, TypeScript.Syntax.token(70 /* OpenBraceToken */), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.token(71 /* CloseBraceToken */), false);
        };

        EnumDeclarationSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        EnumDeclarationSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        EnumDeclarationSyntax.prototype.withModifiers = function (modifiers) {
            return this.update(modifiers, this.enumKeyword, this.identifier, this.openBraceToken, this.enumElements, this.closeBraceToken);
        };

        EnumDeclarationSyntax.prototype.withModifier = function (modifier) {
            return this.withModifiers(TypeScript.Syntax.list([modifier]));
        };

        EnumDeclarationSyntax.prototype.withEnumKeyword = function (enumKeyword) {
            return this.update(this.modifiers, enumKeyword, this.identifier, this.openBraceToken, this.enumElements, this.closeBraceToken);
        };

        EnumDeclarationSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.modifiers, this.enumKeyword, identifier, this.openBraceToken, this.enumElements, this.closeBraceToken);
        };

        EnumDeclarationSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
            return this.update(this.modifiers, this.enumKeyword, this.identifier, openBraceToken, this.enumElements, this.closeBraceToken);
        };

        EnumDeclarationSyntax.prototype.withEnumElements = function (enumElements) {
            return this.update(this.modifiers, this.enumKeyword, this.identifier, this.openBraceToken, enumElements, this.closeBraceToken);
        };

        EnumDeclarationSyntax.prototype.withEnumElement = function (enumElement) {
            return this.withEnumElements(TypeScript.Syntax.separatedList([enumElement]));
        };

        EnumDeclarationSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
            return this.update(this.modifiers, this.enumKeyword, this.identifier, this.openBraceToken, this.enumElements, closeBraceToken);
        };

        EnumDeclarationSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return EnumDeclarationSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.EnumDeclarationSyntax = EnumDeclarationSyntax;

    var EnumElementSyntax = (function (_super) {
        __extends(EnumElementSyntax, _super);
        function EnumElementSyntax(propertyName, equalsValueClause, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.propertyName = propertyName;
            this.equalsValueClause = equalsValueClause;
        }
        EnumElementSyntax.prototype.accept = function (visitor) {
            return visitor.visitEnumElement(this);
        };

        EnumElementSyntax.prototype.kind = function () {
            return 243 /* EnumElement */;
        };

        EnumElementSyntax.prototype.childCount = function () {
            return 2;
        };

        EnumElementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.propertyName;
                case 1:
                    return this.equalsValueClause;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        EnumElementSyntax.prototype.update = function (propertyName, equalsValueClause) {
            if (this.propertyName === propertyName && this.equalsValueClause === equalsValueClause) {
                return this;
            }

            return new EnumElementSyntax(propertyName, equalsValueClause, this.parsedInStrictMode());
        };

        EnumElementSyntax.create = function (propertyName) {
            return new EnumElementSyntax(propertyName, null, false);
        };

        EnumElementSyntax.create1 = function (propertyName) {
            return new EnumElementSyntax(propertyName, null, false);
        };

        EnumElementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        EnumElementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        EnumElementSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(propertyName, this.equalsValueClause);
        };

        EnumElementSyntax.prototype.withEqualsValueClause = function (equalsValueClause) {
            return this.update(this.propertyName, equalsValueClause);
        };

        EnumElementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.equalsValueClause !== null && this.equalsValueClause.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return EnumElementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.EnumElementSyntax = EnumElementSyntax;

    var CastExpressionSyntax = (function (_super) {
        __extends(CastExpressionSyntax, _super);
        function CastExpressionSyntax(lessThanToken, type, greaterThanToken, expression, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.lessThanToken = lessThanToken;
            this.type = type;
            this.greaterThanToken = greaterThanToken;
            this.expression = expression;
        }
        CastExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitCastExpression(this);
        };

        CastExpressionSyntax.prototype.kind = function () {
            return 219 /* CastExpression */;
        };

        CastExpressionSyntax.prototype.childCount = function () {
            return 4;
        };

        CastExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.lessThanToken;
                case 1:
                    return this.type;
                case 2:
                    return this.greaterThanToken;
                case 3:
                    return this.expression;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        CastExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        CastExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        CastExpressionSyntax.prototype.update = function (lessThanToken, type, greaterThanToken, expression) {
            if (this.lessThanToken === lessThanToken && this.type === type && this.greaterThanToken === greaterThanToken && this.expression === expression) {
                return this;
            }

            return new CastExpressionSyntax(lessThanToken, type, greaterThanToken, expression, this.parsedInStrictMode());
        };

        CastExpressionSyntax.create1 = function (type, expression) {
            return new CastExpressionSyntax(TypeScript.Syntax.token(80 /* LessThanToken */), type, TypeScript.Syntax.token(81 /* GreaterThanToken */), expression, false);
        };

        CastExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        CastExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        CastExpressionSyntax.prototype.withLessThanToken = function (lessThanToken) {
            return this.update(lessThanToken, this.type, this.greaterThanToken, this.expression);
        };

        CastExpressionSyntax.prototype.withType = function (type) {
            return this.update(this.lessThanToken, type, this.greaterThanToken, this.expression);
        };

        CastExpressionSyntax.prototype.withGreaterThanToken = function (greaterThanToken) {
            return this.update(this.lessThanToken, this.type, greaterThanToken, this.expression);
        };

        CastExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(this.lessThanToken, this.type, this.greaterThanToken, expression);
        };

        CastExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            return true;
        };
        return CastExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.CastExpressionSyntax = CastExpressionSyntax;

    var ObjectLiteralExpressionSyntax = (function (_super) {
        __extends(ObjectLiteralExpressionSyntax, _super);
        function ObjectLiteralExpressionSyntax(openBraceToken, propertyAssignments, closeBraceToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.openBraceToken = openBraceToken;
            this.propertyAssignments = propertyAssignments;
            this.closeBraceToken = closeBraceToken;
        }
        ObjectLiteralExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitObjectLiteralExpression(this);
        };

        ObjectLiteralExpressionSyntax.prototype.kind = function () {
            return 214 /* ObjectLiteralExpression */;
        };

        ObjectLiteralExpressionSyntax.prototype.childCount = function () {
            return 3;
        };

        ObjectLiteralExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.openBraceToken;
                case 1:
                    return this.propertyAssignments;
                case 2:
                    return this.closeBraceToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        ObjectLiteralExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        ObjectLiteralExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        ObjectLiteralExpressionSyntax.prototype.update = function (openBraceToken, propertyAssignments, closeBraceToken) {
            if (this.openBraceToken === openBraceToken && this.propertyAssignments === propertyAssignments && this.closeBraceToken === closeBraceToken) {
                return this;
            }

            return new ObjectLiteralExpressionSyntax(openBraceToken, propertyAssignments, closeBraceToken, this.parsedInStrictMode());
        };

        ObjectLiteralExpressionSyntax.create = function (openBraceToken, closeBraceToken) {
            return new ObjectLiteralExpressionSyntax(openBraceToken, TypeScript.Syntax.emptySeparatedList, closeBraceToken, false);
        };

        ObjectLiteralExpressionSyntax.create1 = function () {
            return new ObjectLiteralExpressionSyntax(TypeScript.Syntax.token(70 /* OpenBraceToken */), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.token(71 /* CloseBraceToken */), false);
        };

        ObjectLiteralExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        ObjectLiteralExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        ObjectLiteralExpressionSyntax.prototype.withOpenBraceToken = function (openBraceToken) {
            return this.update(openBraceToken, this.propertyAssignments, this.closeBraceToken);
        };

        ObjectLiteralExpressionSyntax.prototype.withPropertyAssignments = function (propertyAssignments) {
            return this.update(this.openBraceToken, propertyAssignments, this.closeBraceToken);
        };

        ObjectLiteralExpressionSyntax.prototype.withPropertyAssignment = function (propertyAssignment) {
            return this.withPropertyAssignments(TypeScript.Syntax.separatedList([propertyAssignment]));
        };

        ObjectLiteralExpressionSyntax.prototype.withCloseBraceToken = function (closeBraceToken) {
            return this.update(this.openBraceToken, this.propertyAssignments, closeBraceToken);
        };

        ObjectLiteralExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.propertyAssignments.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return ObjectLiteralExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.ObjectLiteralExpressionSyntax = ObjectLiteralExpressionSyntax;

    var PropertyAssignmentSyntax = (function (_super) {
        __extends(PropertyAssignmentSyntax, _super);
        function PropertyAssignmentSyntax(propertyName, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.propertyName = propertyName;
        }
        PropertyAssignmentSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        PropertyAssignmentSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        PropertyAssignmentSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return PropertyAssignmentSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.PropertyAssignmentSyntax = PropertyAssignmentSyntax;

    var SimplePropertyAssignmentSyntax = (function (_super) {
        __extends(SimplePropertyAssignmentSyntax, _super);
        function SimplePropertyAssignmentSyntax(propertyName, colonToken, expression, parsedInStrictMode) {
            _super.call(this, propertyName, parsedInStrictMode);
            this.colonToken = colonToken;
            this.expression = expression;
        }
        SimplePropertyAssignmentSyntax.prototype.accept = function (visitor) {
            return visitor.visitSimplePropertyAssignment(this);
        };

        SimplePropertyAssignmentSyntax.prototype.kind = function () {
            return 238 /* SimplePropertyAssignment */;
        };

        SimplePropertyAssignmentSyntax.prototype.childCount = function () {
            return 3;
        };

        SimplePropertyAssignmentSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.propertyName;
                case 1:
                    return this.colonToken;
                case 2:
                    return this.expression;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        SimplePropertyAssignmentSyntax.prototype.update = function (propertyName, colonToken, expression) {
            if (this.propertyName === propertyName && this.colonToken === colonToken && this.expression === expression) {
                return this;
            }

            return new SimplePropertyAssignmentSyntax(propertyName, colonToken, expression, this.parsedInStrictMode());
        };

        SimplePropertyAssignmentSyntax.create1 = function (propertyName, expression) {
            return new SimplePropertyAssignmentSyntax(propertyName, TypeScript.Syntax.token(106 /* ColonToken */), expression, false);
        };

        SimplePropertyAssignmentSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        SimplePropertyAssignmentSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        SimplePropertyAssignmentSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(propertyName, this.colonToken, this.expression);
        };

        SimplePropertyAssignmentSyntax.prototype.withColonToken = function (colonToken) {
            return this.update(this.propertyName, colonToken, this.expression);
        };

        SimplePropertyAssignmentSyntax.prototype.withExpression = function (expression) {
            return this.update(this.propertyName, this.colonToken, expression);
        };

        SimplePropertyAssignmentSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return SimplePropertyAssignmentSyntax;
    })(PropertyAssignmentSyntax);
    TypeScript.SimplePropertyAssignmentSyntax = SimplePropertyAssignmentSyntax;

    var FunctionPropertyAssignmentSyntax = (function (_super) {
        __extends(FunctionPropertyAssignmentSyntax, _super);
        function FunctionPropertyAssignmentSyntax(propertyName, callSignature, block, parsedInStrictMode) {
            _super.call(this, propertyName, parsedInStrictMode);
            this.callSignature = callSignature;
            this.block = block;
        }
        FunctionPropertyAssignmentSyntax.prototype.accept = function (visitor) {
            return visitor.visitFunctionPropertyAssignment(this);
        };

        FunctionPropertyAssignmentSyntax.prototype.kind = function () {
            return 241 /* FunctionPropertyAssignment */;
        };

        FunctionPropertyAssignmentSyntax.prototype.childCount = function () {
            return 3;
        };

        FunctionPropertyAssignmentSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.propertyName;
                case 1:
                    return this.callSignature;
                case 2:
                    return this.block;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        FunctionPropertyAssignmentSyntax.prototype.update = function (propertyName, callSignature, block) {
            if (this.propertyName === propertyName && this.callSignature === callSignature && this.block === block) {
                return this;
            }

            return new FunctionPropertyAssignmentSyntax(propertyName, callSignature, block, this.parsedInStrictMode());
        };

        FunctionPropertyAssignmentSyntax.create1 = function (propertyName) {
            return new FunctionPropertyAssignmentSyntax(propertyName, CallSignatureSyntax.create1(), BlockSyntax.create1(), false);
        };

        FunctionPropertyAssignmentSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        FunctionPropertyAssignmentSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        FunctionPropertyAssignmentSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(propertyName, this.callSignature, this.block);
        };

        FunctionPropertyAssignmentSyntax.prototype.withCallSignature = function (callSignature) {
            return this.update(this.propertyName, callSignature, this.block);
        };

        FunctionPropertyAssignmentSyntax.prototype.withBlock = function (block) {
            return this.update(this.propertyName, this.callSignature, block);
        };

        FunctionPropertyAssignmentSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.callSignature.isTypeScriptSpecific()) {
                return true;
            }
            if (this.block.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return FunctionPropertyAssignmentSyntax;
    })(PropertyAssignmentSyntax);
    TypeScript.FunctionPropertyAssignmentSyntax = FunctionPropertyAssignmentSyntax;

    var AccessorPropertyAssignmentSyntax = (function (_super) {
        __extends(AccessorPropertyAssignmentSyntax, _super);
        function AccessorPropertyAssignmentSyntax(propertyName, openParenToken, closeParenToken, block, parsedInStrictMode) {
            _super.call(this, propertyName, parsedInStrictMode);
            this.openParenToken = openParenToken;
            this.closeParenToken = closeParenToken;
            this.block = block;
        }
        AccessorPropertyAssignmentSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        AccessorPropertyAssignmentSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        AccessorPropertyAssignmentSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return AccessorPropertyAssignmentSyntax;
    })(PropertyAssignmentSyntax);
    TypeScript.AccessorPropertyAssignmentSyntax = AccessorPropertyAssignmentSyntax;

    var GetAccessorPropertyAssignmentSyntax = (function (_super) {
        __extends(GetAccessorPropertyAssignmentSyntax, _super);
        function GetAccessorPropertyAssignmentSyntax(getKeyword, propertyName, openParenToken, closeParenToken, typeAnnotation, block, parsedInStrictMode) {
            _super.call(this, propertyName, openParenToken, closeParenToken, block, parsedInStrictMode);
            this.getKeyword = getKeyword;
            this.typeAnnotation = typeAnnotation;
        }
        GetAccessorPropertyAssignmentSyntax.prototype.accept = function (visitor) {
            return visitor.visitGetAccessorPropertyAssignment(this);
        };

        GetAccessorPropertyAssignmentSyntax.prototype.kind = function () {
            return 239 /* GetAccessorPropertyAssignment */;
        };

        GetAccessorPropertyAssignmentSyntax.prototype.childCount = function () {
            return 6;
        };

        GetAccessorPropertyAssignmentSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.getKeyword;
                case 1:
                    return this.propertyName;
                case 2:
                    return this.openParenToken;
                case 3:
                    return this.closeParenToken;
                case 4:
                    return this.typeAnnotation;
                case 5:
                    return this.block;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        GetAccessorPropertyAssignmentSyntax.prototype.update = function (getKeyword, propertyName, openParenToken, closeParenToken, typeAnnotation, block) {
            if (this.getKeyword === getKeyword && this.propertyName === propertyName && this.openParenToken === openParenToken && this.closeParenToken === closeParenToken && this.typeAnnotation === typeAnnotation && this.block === block) {
                return this;
            }

            return new GetAccessorPropertyAssignmentSyntax(getKeyword, propertyName, openParenToken, closeParenToken, typeAnnotation, block, this.parsedInStrictMode());
        };

        GetAccessorPropertyAssignmentSyntax.create = function (getKeyword, propertyName, openParenToken, closeParenToken, block) {
            return new GetAccessorPropertyAssignmentSyntax(getKeyword, propertyName, openParenToken, closeParenToken, null, block, false);
        };

        GetAccessorPropertyAssignmentSyntax.create1 = function (propertyName) {
            return new GetAccessorPropertyAssignmentSyntax(TypeScript.Syntax.token(64 /* GetKeyword */), propertyName, TypeScript.Syntax.token(72 /* OpenParenToken */), TypeScript.Syntax.token(73 /* CloseParenToken */), null, BlockSyntax.create1(), false);
        };

        GetAccessorPropertyAssignmentSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        GetAccessorPropertyAssignmentSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        GetAccessorPropertyAssignmentSyntax.prototype.withGetKeyword = function (getKeyword) {
            return this.update(getKeyword, this.propertyName, this.openParenToken, this.closeParenToken, this.typeAnnotation, this.block);
        };

        GetAccessorPropertyAssignmentSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(this.getKeyword, propertyName, this.openParenToken, this.closeParenToken, this.typeAnnotation, this.block);
        };

        GetAccessorPropertyAssignmentSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.getKeyword, this.propertyName, openParenToken, this.closeParenToken, this.typeAnnotation, this.block);
        };

        GetAccessorPropertyAssignmentSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.getKeyword, this.propertyName, this.openParenToken, closeParenToken, this.typeAnnotation, this.block);
        };

        GetAccessorPropertyAssignmentSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
            return this.update(this.getKeyword, this.propertyName, this.openParenToken, this.closeParenToken, typeAnnotation, this.block);
        };

        GetAccessorPropertyAssignmentSyntax.prototype.withBlock = function (block) {
            return this.update(this.getKeyword, this.propertyName, this.openParenToken, this.closeParenToken, this.typeAnnotation, block);
        };

        GetAccessorPropertyAssignmentSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.typeAnnotation !== null && this.typeAnnotation.isTypeScriptSpecific()) {
                return true;
            }
            if (this.block.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return GetAccessorPropertyAssignmentSyntax;
    })(AccessorPropertyAssignmentSyntax);
    TypeScript.GetAccessorPropertyAssignmentSyntax = GetAccessorPropertyAssignmentSyntax;

    var SetAccessorPropertyAssignmentSyntax = (function (_super) {
        __extends(SetAccessorPropertyAssignmentSyntax, _super);
        function SetAccessorPropertyAssignmentSyntax(setKeyword, propertyName, openParenToken, parameter, closeParenToken, block, parsedInStrictMode) {
            _super.call(this, propertyName, openParenToken, closeParenToken, block, parsedInStrictMode);
            this.setKeyword = setKeyword;
            this.parameter = parameter;
        }
        SetAccessorPropertyAssignmentSyntax.prototype.accept = function (visitor) {
            return visitor.visitSetAccessorPropertyAssignment(this);
        };

        SetAccessorPropertyAssignmentSyntax.prototype.kind = function () {
            return 240 /* SetAccessorPropertyAssignment */;
        };

        SetAccessorPropertyAssignmentSyntax.prototype.childCount = function () {
            return 6;
        };

        SetAccessorPropertyAssignmentSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.setKeyword;
                case 1:
                    return this.propertyName;
                case 2:
                    return this.openParenToken;
                case 3:
                    return this.parameter;
                case 4:
                    return this.closeParenToken;
                case 5:
                    return this.block;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        SetAccessorPropertyAssignmentSyntax.prototype.update = function (setKeyword, propertyName, openParenToken, parameter, closeParenToken, block) {
            if (this.setKeyword === setKeyword && this.propertyName === propertyName && this.openParenToken === openParenToken && this.parameter === parameter && this.closeParenToken === closeParenToken && this.block === block) {
                return this;
            }

            return new SetAccessorPropertyAssignmentSyntax(setKeyword, propertyName, openParenToken, parameter, closeParenToken, block, this.parsedInStrictMode());
        };

        SetAccessorPropertyAssignmentSyntax.create1 = function (propertyName, parameter) {
            return new SetAccessorPropertyAssignmentSyntax(TypeScript.Syntax.token(68 /* SetKeyword */), propertyName, TypeScript.Syntax.token(72 /* OpenParenToken */), parameter, TypeScript.Syntax.token(73 /* CloseParenToken */), BlockSyntax.create1(), false);
        };

        SetAccessorPropertyAssignmentSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        SetAccessorPropertyAssignmentSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        SetAccessorPropertyAssignmentSyntax.prototype.withSetKeyword = function (setKeyword) {
            return this.update(setKeyword, this.propertyName, this.openParenToken, this.parameter, this.closeParenToken, this.block);
        };

        SetAccessorPropertyAssignmentSyntax.prototype.withPropertyName = function (propertyName) {
            return this.update(this.setKeyword, propertyName, this.openParenToken, this.parameter, this.closeParenToken, this.block);
        };

        SetAccessorPropertyAssignmentSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.setKeyword, this.propertyName, openParenToken, this.parameter, this.closeParenToken, this.block);
        };

        SetAccessorPropertyAssignmentSyntax.prototype.withParameter = function (parameter) {
            return this.update(this.setKeyword, this.propertyName, this.openParenToken, parameter, this.closeParenToken, this.block);
        };

        SetAccessorPropertyAssignmentSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.setKeyword, this.propertyName, this.openParenToken, this.parameter, closeParenToken, this.block);
        };

        SetAccessorPropertyAssignmentSyntax.prototype.withBlock = function (block) {
            return this.update(this.setKeyword, this.propertyName, this.openParenToken, this.parameter, this.closeParenToken, block);
        };

        SetAccessorPropertyAssignmentSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.parameter.isTypeScriptSpecific()) {
                return true;
            }
            if (this.block.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return SetAccessorPropertyAssignmentSyntax;
    })(AccessorPropertyAssignmentSyntax);
    TypeScript.SetAccessorPropertyAssignmentSyntax = SetAccessorPropertyAssignmentSyntax;

    var FunctionExpressionSyntax = (function (_super) {
        __extends(FunctionExpressionSyntax, _super);
        function FunctionExpressionSyntax(functionKeyword, identifier, callSignature, block, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.functionKeyword = functionKeyword;
            this.identifier = identifier;
            this.callSignature = callSignature;
            this.block = block;
        }
        FunctionExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitFunctionExpression(this);
        };

        FunctionExpressionSyntax.prototype.kind = function () {
            return 221 /* FunctionExpression */;
        };

        FunctionExpressionSyntax.prototype.childCount = function () {
            return 4;
        };

        FunctionExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.functionKeyword;
                case 1:
                    return this.identifier;
                case 2:
                    return this.callSignature;
                case 3:
                    return this.block;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        FunctionExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        FunctionExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        FunctionExpressionSyntax.prototype.update = function (functionKeyword, identifier, callSignature, block) {
            if (this.functionKeyword === functionKeyword && this.identifier === identifier && this.callSignature === callSignature && this.block === block) {
                return this;
            }

            return new FunctionExpressionSyntax(functionKeyword, identifier, callSignature, block, this.parsedInStrictMode());
        };

        FunctionExpressionSyntax.create = function (functionKeyword, callSignature, block) {
            return new FunctionExpressionSyntax(functionKeyword, null, callSignature, block, false);
        };

        FunctionExpressionSyntax.create1 = function () {
            return new FunctionExpressionSyntax(TypeScript.Syntax.token(27 /* FunctionKeyword */), null, CallSignatureSyntax.create1(), BlockSyntax.create1(), false);
        };

        FunctionExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        FunctionExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        FunctionExpressionSyntax.prototype.withFunctionKeyword = function (functionKeyword) {
            return this.update(functionKeyword, this.identifier, this.callSignature, this.block);
        };

        FunctionExpressionSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.functionKeyword, identifier, this.callSignature, this.block);
        };

        FunctionExpressionSyntax.prototype.withCallSignature = function (callSignature) {
            return this.update(this.functionKeyword, this.identifier, callSignature, this.block);
        };

        FunctionExpressionSyntax.prototype.withBlock = function (block) {
            return this.update(this.functionKeyword, this.identifier, this.callSignature, block);
        };

        FunctionExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.callSignature.isTypeScriptSpecific()) {
                return true;
            }
            if (this.block.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return FunctionExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.FunctionExpressionSyntax = FunctionExpressionSyntax;

    var EmptyStatementSyntax = (function (_super) {
        __extends(EmptyStatementSyntax, _super);
        function EmptyStatementSyntax(semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.semicolonToken = semicolonToken;
        }
        EmptyStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitEmptyStatement(this);
        };

        EmptyStatementSyntax.prototype.kind = function () {
            return 155 /* EmptyStatement */;
        };

        EmptyStatementSyntax.prototype.childCount = function () {
            return 1;
        };

        EmptyStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        EmptyStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        EmptyStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        EmptyStatementSyntax.prototype.update = function (semicolonToken) {
            if (this.semicolonToken === semicolonToken) {
                return this;
            }

            return new EmptyStatementSyntax(semicolonToken, this.parsedInStrictMode());
        };

        EmptyStatementSyntax.create1 = function () {
            return new EmptyStatementSyntax(TypeScript.Syntax.token(78 /* SemicolonToken */), false);
        };

        EmptyStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        EmptyStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        EmptyStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(semicolonToken);
        };

        EmptyStatementSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return EmptyStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.EmptyStatementSyntax = EmptyStatementSyntax;

    var TryStatementSyntax = (function (_super) {
        __extends(TryStatementSyntax, _super);
        function TryStatementSyntax(tryKeyword, block, catchClause, finallyClause, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.tryKeyword = tryKeyword;
            this.block = block;
            this.catchClause = catchClause;
            this.finallyClause = finallyClause;
        }
        TryStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitTryStatement(this);
        };

        TryStatementSyntax.prototype.kind = function () {
            return 158 /* TryStatement */;
        };

        TryStatementSyntax.prototype.childCount = function () {
            return 4;
        };

        TryStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.tryKeyword;
                case 1:
                    return this.block;
                case 2:
                    return this.catchClause;
                case 3:
                    return this.finallyClause;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        TryStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        TryStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        TryStatementSyntax.prototype.update = function (tryKeyword, block, catchClause, finallyClause) {
            if (this.tryKeyword === tryKeyword && this.block === block && this.catchClause === catchClause && this.finallyClause === finallyClause) {
                return this;
            }

            return new TryStatementSyntax(tryKeyword, block, catchClause, finallyClause, this.parsedInStrictMode());
        };

        TryStatementSyntax.create = function (tryKeyword, block) {
            return new TryStatementSyntax(tryKeyword, block, null, null, false);
        };

        TryStatementSyntax.create1 = function () {
            return new TryStatementSyntax(TypeScript.Syntax.token(38 /* TryKeyword */), BlockSyntax.create1(), null, null, false);
        };

        TryStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        TryStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        TryStatementSyntax.prototype.withTryKeyword = function (tryKeyword) {
            return this.update(tryKeyword, this.block, this.catchClause, this.finallyClause);
        };

        TryStatementSyntax.prototype.withBlock = function (block) {
            return this.update(this.tryKeyword, block, this.catchClause, this.finallyClause);
        };

        TryStatementSyntax.prototype.withCatchClause = function (catchClause) {
            return this.update(this.tryKeyword, this.block, catchClause, this.finallyClause);
        };

        TryStatementSyntax.prototype.withFinallyClause = function (finallyClause) {
            return this.update(this.tryKeyword, this.block, this.catchClause, finallyClause);
        };

        TryStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.block.isTypeScriptSpecific()) {
                return true;
            }
            if (this.catchClause !== null && this.catchClause.isTypeScriptSpecific()) {
                return true;
            }
            if (this.finallyClause !== null && this.finallyClause.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return TryStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.TryStatementSyntax = TryStatementSyntax;

    var CatchClauseSyntax = (function (_super) {
        __extends(CatchClauseSyntax, _super);
        function CatchClauseSyntax(catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.catchKeyword = catchKeyword;
            this.openParenToken = openParenToken;
            this.identifier = identifier;
            this.typeAnnotation = typeAnnotation;
            this.closeParenToken = closeParenToken;
            this.block = block;
        }
        CatchClauseSyntax.prototype.accept = function (visitor) {
            return visitor.visitCatchClause(this);
        };

        CatchClauseSyntax.prototype.kind = function () {
            return 234 /* CatchClause */;
        };

        CatchClauseSyntax.prototype.childCount = function () {
            return 6;
        };

        CatchClauseSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.catchKeyword;
                case 1:
                    return this.openParenToken;
                case 2:
                    return this.identifier;
                case 3:
                    return this.typeAnnotation;
                case 4:
                    return this.closeParenToken;
                case 5:
                    return this.block;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        CatchClauseSyntax.prototype.update = function (catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block) {
            if (this.catchKeyword === catchKeyword && this.openParenToken === openParenToken && this.identifier === identifier && this.typeAnnotation === typeAnnotation && this.closeParenToken === closeParenToken && this.block === block) {
                return this;
            }

            return new CatchClauseSyntax(catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block, this.parsedInStrictMode());
        };

        CatchClauseSyntax.create = function (catchKeyword, openParenToken, identifier, closeParenToken, block) {
            return new CatchClauseSyntax(catchKeyword, openParenToken, identifier, null, closeParenToken, block, false);
        };

        CatchClauseSyntax.create1 = function (identifier) {
            return new CatchClauseSyntax(TypeScript.Syntax.token(17 /* CatchKeyword */), TypeScript.Syntax.token(72 /* OpenParenToken */), identifier, null, TypeScript.Syntax.token(73 /* CloseParenToken */), BlockSyntax.create1(), false);
        };

        CatchClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        CatchClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        CatchClauseSyntax.prototype.withCatchKeyword = function (catchKeyword) {
            return this.update(catchKeyword, this.openParenToken, this.identifier, this.typeAnnotation, this.closeParenToken, this.block);
        };

        CatchClauseSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.catchKeyword, openParenToken, this.identifier, this.typeAnnotation, this.closeParenToken, this.block);
        };

        CatchClauseSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(this.catchKeyword, this.openParenToken, identifier, this.typeAnnotation, this.closeParenToken, this.block);
        };

        CatchClauseSyntax.prototype.withTypeAnnotation = function (typeAnnotation) {
            return this.update(this.catchKeyword, this.openParenToken, this.identifier, typeAnnotation, this.closeParenToken, this.block);
        };

        CatchClauseSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.catchKeyword, this.openParenToken, this.identifier, this.typeAnnotation, closeParenToken, this.block);
        };

        CatchClauseSyntax.prototype.withBlock = function (block) {
            return this.update(this.catchKeyword, this.openParenToken, this.identifier, this.typeAnnotation, this.closeParenToken, block);
        };

        CatchClauseSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.typeAnnotation !== null && this.typeAnnotation.isTypeScriptSpecific()) {
                return true;
            }
            if (this.block.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return CatchClauseSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.CatchClauseSyntax = CatchClauseSyntax;

    var FinallyClauseSyntax = (function (_super) {
        __extends(FinallyClauseSyntax, _super);
        function FinallyClauseSyntax(finallyKeyword, block, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.finallyKeyword = finallyKeyword;
            this.block = block;
        }
        FinallyClauseSyntax.prototype.accept = function (visitor) {
            return visitor.visitFinallyClause(this);
        };

        FinallyClauseSyntax.prototype.kind = function () {
            return 235 /* FinallyClause */;
        };

        FinallyClauseSyntax.prototype.childCount = function () {
            return 2;
        };

        FinallyClauseSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.finallyKeyword;
                case 1:
                    return this.block;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        FinallyClauseSyntax.prototype.update = function (finallyKeyword, block) {
            if (this.finallyKeyword === finallyKeyword && this.block === block) {
                return this;
            }

            return new FinallyClauseSyntax(finallyKeyword, block, this.parsedInStrictMode());
        };

        FinallyClauseSyntax.create1 = function () {
            return new FinallyClauseSyntax(TypeScript.Syntax.token(25 /* FinallyKeyword */), BlockSyntax.create1(), false);
        };

        FinallyClauseSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        FinallyClauseSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        FinallyClauseSyntax.prototype.withFinallyKeyword = function (finallyKeyword) {
            return this.update(finallyKeyword, this.block);
        };

        FinallyClauseSyntax.prototype.withBlock = function (block) {
            return this.update(this.finallyKeyword, block);
        };

        FinallyClauseSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.block.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return FinallyClauseSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.FinallyClauseSyntax = FinallyClauseSyntax;

    var LabeledStatementSyntax = (function (_super) {
        __extends(LabeledStatementSyntax, _super);
        function LabeledStatementSyntax(identifier, colonToken, statement, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.identifier = identifier;
            this.colonToken = colonToken;
            this.statement = statement;
        }
        LabeledStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitLabeledStatement(this);
        };

        LabeledStatementSyntax.prototype.kind = function () {
            return 159 /* LabeledStatement */;
        };

        LabeledStatementSyntax.prototype.childCount = function () {
            return 3;
        };

        LabeledStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.identifier;
                case 1:
                    return this.colonToken;
                case 2:
                    return this.statement;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        LabeledStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        LabeledStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        LabeledStatementSyntax.prototype.update = function (identifier, colonToken, statement) {
            if (this.identifier === identifier && this.colonToken === colonToken && this.statement === statement) {
                return this;
            }

            return new LabeledStatementSyntax(identifier, colonToken, statement, this.parsedInStrictMode());
        };

        LabeledStatementSyntax.create1 = function (identifier, statement) {
            return new LabeledStatementSyntax(identifier, TypeScript.Syntax.token(106 /* ColonToken */), statement, false);
        };

        LabeledStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        LabeledStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        LabeledStatementSyntax.prototype.withIdentifier = function (identifier) {
            return this.update(identifier, this.colonToken, this.statement);
        };

        LabeledStatementSyntax.prototype.withColonToken = function (colonToken) {
            return this.update(this.identifier, colonToken, this.statement);
        };

        LabeledStatementSyntax.prototype.withStatement = function (statement) {
            return this.update(this.identifier, this.colonToken, statement);
        };

        LabeledStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.statement.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return LabeledStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.LabeledStatementSyntax = LabeledStatementSyntax;

    var DoStatementSyntax = (function (_super) {
        __extends(DoStatementSyntax, _super);
        function DoStatementSyntax(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken, parsedInStrictMode) {
            _super.call(this, openParenToken, closeParenToken, statement, parsedInStrictMode);
            this.doKeyword = doKeyword;
            this.whileKeyword = whileKeyword;
            this.condition = condition;
            this.semicolonToken = semicolonToken;
        }
        DoStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitDoStatement(this);
        };

        DoStatementSyntax.prototype.kind = function () {
            return 160 /* DoStatement */;
        };

        DoStatementSyntax.prototype.childCount = function () {
            return 7;
        };

        DoStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.doKeyword;
                case 1:
                    return this.statement;
                case 2:
                    return this.whileKeyword;
                case 3:
                    return this.openParenToken;
                case 4:
                    return this.condition;
                case 5:
                    return this.closeParenToken;
                case 6:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        DoStatementSyntax.prototype.update = function (doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken) {
            if (this.doKeyword === doKeyword && this.statement === statement && this.whileKeyword === whileKeyword && this.openParenToken === openParenToken && this.condition === condition && this.closeParenToken === closeParenToken && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new DoStatementSyntax(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken, this.parsedInStrictMode());
        };

        DoStatementSyntax.create1 = function (statement, condition) {
            return new DoStatementSyntax(TypeScript.Syntax.token(22 /* DoKeyword */), statement, TypeScript.Syntax.token(42 /* WhileKeyword */), TypeScript.Syntax.token(72 /* OpenParenToken */), condition, TypeScript.Syntax.token(73 /* CloseParenToken */), TypeScript.Syntax.token(78 /* SemicolonToken */), false);
        };

        DoStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        DoStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        DoStatementSyntax.prototype.withDoKeyword = function (doKeyword) {
            return this.update(doKeyword, this.statement, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.semicolonToken);
        };

        DoStatementSyntax.prototype.withStatement = function (statement) {
            return this.update(this.doKeyword, statement, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.semicolonToken);
        };

        DoStatementSyntax.prototype.withWhileKeyword = function (whileKeyword) {
            return this.update(this.doKeyword, this.statement, whileKeyword, this.openParenToken, this.condition, this.closeParenToken, this.semicolonToken);
        };

        DoStatementSyntax.prototype.withOpenParenToken = function (openParenToken) {
            return this.update(this.doKeyword, this.statement, this.whileKeyword, openParenToken, this.condition, this.closeParenToken, this.semicolonToken);
        };

        DoStatementSyntax.prototype.withCondition = function (condition) {
            return this.update(this.doKeyword, this.statement, this.whileKeyword, this.openParenToken, condition, this.closeParenToken, this.semicolonToken);
        };

        DoStatementSyntax.prototype.withCloseParenToken = function (closeParenToken) {
            return this.update(this.doKeyword, this.statement, this.whileKeyword, this.openParenToken, this.condition, closeParenToken, this.semicolonToken);
        };

        DoStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.doKeyword, this.statement, this.whileKeyword, this.openParenToken, this.condition, this.closeParenToken, semicolonToken);
        };

        DoStatementSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.statement.isTypeScriptSpecific()) {
                return true;
            }
            if (this.condition.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return DoStatementSyntax;
    })(IterationStatementSyntax);
    TypeScript.DoStatementSyntax = DoStatementSyntax;

    var TypeOfExpressionSyntax = (function (_super) {
        __extends(TypeOfExpressionSyntax, _super);
        function TypeOfExpressionSyntax(typeOfKeyword, expression, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.typeOfKeyword = typeOfKeyword;
            this.expression = expression;
        }
        TypeOfExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitTypeOfExpression(this);
        };

        TypeOfExpressionSyntax.prototype.kind = function () {
            return 170 /* TypeOfExpression */;
        };

        TypeOfExpressionSyntax.prototype.childCount = function () {
            return 2;
        };

        TypeOfExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.typeOfKeyword;
                case 1:
                    return this.expression;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        TypeOfExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        TypeOfExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        TypeOfExpressionSyntax.prototype.update = function (typeOfKeyword, expression) {
            if (this.typeOfKeyword === typeOfKeyword && this.expression === expression) {
                return this;
            }

            return new TypeOfExpressionSyntax(typeOfKeyword, expression, this.parsedInStrictMode());
        };

        TypeOfExpressionSyntax.create1 = function (expression) {
            return new TypeOfExpressionSyntax(TypeScript.Syntax.token(39 /* TypeOfKeyword */), expression, false);
        };

        TypeOfExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        TypeOfExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        TypeOfExpressionSyntax.prototype.withTypeOfKeyword = function (typeOfKeyword) {
            return this.update(typeOfKeyword, this.expression);
        };

        TypeOfExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(this.typeOfKeyword, expression);
        };

        TypeOfExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return TypeOfExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.TypeOfExpressionSyntax = TypeOfExpressionSyntax;

    var DeleteExpressionSyntax = (function (_super) {
        __extends(DeleteExpressionSyntax, _super);
        function DeleteExpressionSyntax(deleteKeyword, expression, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.deleteKeyword = deleteKeyword;
            this.expression = expression;
        }
        DeleteExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitDeleteExpression(this);
        };

        DeleteExpressionSyntax.prototype.kind = function () {
            return 169 /* DeleteExpression */;
        };

        DeleteExpressionSyntax.prototype.childCount = function () {
            return 2;
        };

        DeleteExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.deleteKeyword;
                case 1:
                    return this.expression;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        DeleteExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        DeleteExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        DeleteExpressionSyntax.prototype.update = function (deleteKeyword, expression) {
            if (this.deleteKeyword === deleteKeyword && this.expression === expression) {
                return this;
            }

            return new DeleteExpressionSyntax(deleteKeyword, expression, this.parsedInStrictMode());
        };

        DeleteExpressionSyntax.create1 = function (expression) {
            return new DeleteExpressionSyntax(TypeScript.Syntax.token(21 /* DeleteKeyword */), expression, false);
        };

        DeleteExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        DeleteExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        DeleteExpressionSyntax.prototype.withDeleteKeyword = function (deleteKeyword) {
            return this.update(deleteKeyword, this.expression);
        };

        DeleteExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(this.deleteKeyword, expression);
        };

        DeleteExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return DeleteExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.DeleteExpressionSyntax = DeleteExpressionSyntax;

    var VoidExpressionSyntax = (function (_super) {
        __extends(VoidExpressionSyntax, _super);
        function VoidExpressionSyntax(voidKeyword, expression, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.voidKeyword = voidKeyword;
            this.expression = expression;
        }
        VoidExpressionSyntax.prototype.accept = function (visitor) {
            return visitor.visitVoidExpression(this);
        };

        VoidExpressionSyntax.prototype.kind = function () {
            return 171 /* VoidExpression */;
        };

        VoidExpressionSyntax.prototype.childCount = function () {
            return 2;
        };

        VoidExpressionSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.voidKeyword;
                case 1:
                    return this.expression;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        VoidExpressionSyntax.prototype.isUnaryExpression = function () {
            return true;
        };

        VoidExpressionSyntax.prototype.isExpression = function () {
            return true;
        };

        VoidExpressionSyntax.prototype.update = function (voidKeyword, expression) {
            if (this.voidKeyword === voidKeyword && this.expression === expression) {
                return this;
            }

            return new VoidExpressionSyntax(voidKeyword, expression, this.parsedInStrictMode());
        };

        VoidExpressionSyntax.create1 = function (expression) {
            return new VoidExpressionSyntax(TypeScript.Syntax.token(41 /* VoidKeyword */), expression, false);
        };

        VoidExpressionSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        VoidExpressionSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        VoidExpressionSyntax.prototype.withVoidKeyword = function (voidKeyword) {
            return this.update(voidKeyword, this.expression);
        };

        VoidExpressionSyntax.prototype.withExpression = function (expression) {
            return this.update(this.voidKeyword, expression);
        };

        VoidExpressionSyntax.prototype.isTypeScriptSpecific = function () {
            if (this.expression.isTypeScriptSpecific()) {
                return true;
            }
            return false;
        };
        return VoidExpressionSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.VoidExpressionSyntax = VoidExpressionSyntax;

    var DebuggerStatementSyntax = (function (_super) {
        __extends(DebuggerStatementSyntax, _super);
        function DebuggerStatementSyntax(debuggerKeyword, semicolonToken, parsedInStrictMode) {
            _super.call(this, parsedInStrictMode);
            this.debuggerKeyword = debuggerKeyword;
            this.semicolonToken = semicolonToken;
        }
        DebuggerStatementSyntax.prototype.accept = function (visitor) {
            return visitor.visitDebuggerStatement(this);
        };

        DebuggerStatementSyntax.prototype.kind = function () {
            return 161 /* DebuggerStatement */;
        };

        DebuggerStatementSyntax.prototype.childCount = function () {
            return 2;
        };

        DebuggerStatementSyntax.prototype.childAt = function (slot) {
            switch (slot) {
                case 0:
                    return this.debuggerKeyword;
                case 1:
                    return this.semicolonToken;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        DebuggerStatementSyntax.prototype.isStatement = function () {
            return true;
        };

        DebuggerStatementSyntax.prototype.isModuleElement = function () {
            return true;
        };

        DebuggerStatementSyntax.prototype.update = function (debuggerKeyword, semicolonToken) {
            if (this.debuggerKeyword === debuggerKeyword && this.semicolonToken === semicolonToken) {
                return this;
            }

            return new DebuggerStatementSyntax(debuggerKeyword, semicolonToken, this.parsedInStrictMode());
        };

        DebuggerStatementSyntax.create1 = function () {
            return new DebuggerStatementSyntax(TypeScript.Syntax.token(19 /* DebuggerKeyword */), TypeScript.Syntax.token(78 /* SemicolonToken */), false);
        };

        DebuggerStatementSyntax.prototype.withLeadingTrivia = function (trivia) {
            return _super.prototype.withLeadingTrivia.call(this, trivia);
        };

        DebuggerStatementSyntax.prototype.withTrailingTrivia = function (trivia) {
            return _super.prototype.withTrailingTrivia.call(this, trivia);
        };

        DebuggerStatementSyntax.prototype.withDebuggerKeyword = function (debuggerKeyword) {
            return this.update(debuggerKeyword, this.semicolonToken);
        };

        DebuggerStatementSyntax.prototype.withSemicolonToken = function (semicolonToken) {
            return this.update(this.debuggerKeyword, semicolonToken);
        };

        DebuggerStatementSyntax.prototype.isTypeScriptSpecific = function () {
            return false;
        };
        return DebuggerStatementSyntax;
    })(TypeScript.SyntaxNode);
    TypeScript.DebuggerStatementSyntax = DebuggerStatementSyntax;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxRewriter = (function () {
        function SyntaxRewriter() {
        }
        SyntaxRewriter.prototype.visitToken = function (token) {
            return token;
        };

        SyntaxRewriter.prototype.visitNode = function (node) {
            return node.accept(this);
        };

        SyntaxRewriter.prototype.visitNodeOrToken = function (node) {
            return node.isToken() ? this.visitToken(node) : this.visitNode(node);
        };

        SyntaxRewriter.prototype.visitList = function (list) {
            var newItems = null;

            for (var i = 0, n = list.childCount(); i < n; i++) {
                var item = list.childAt(i);
                var newItem = this.visitNodeOrToken(item);

                if (item !== newItem && newItems === null) {
                    newItems = [];
                    for (var j = 0; j < i; j++) {
                        newItems.push(list.childAt(j));
                    }
                }

                if (newItems) {
                    newItems.push(newItem);
                }
            }

            return newItems === null ? list : TypeScript.Syntax.list(newItems);
        };

        SyntaxRewriter.prototype.visitSeparatedList = function (list) {
            var newItems = null;

            for (var i = 0, n = list.childCount(); i < n; i++) {
                var item = list.childAt(i);
                var newItem = item.isToken() ? this.visitToken(item) : this.visitNode(item);

                if (item !== newItem && newItems === null) {
                    newItems = [];
                    for (var j = 0; j < i; j++) {
                        newItems.push(list.childAt(j));
                    }
                }

                if (newItems) {
                    newItems.push(newItem);
                }
            }

            return newItems === null ? list : TypeScript.Syntax.separatedList(newItems);
        };

        SyntaxRewriter.prototype.visitSourceUnit = function (node) {
            return node.update(this.visitList(node.moduleElements), this.visitToken(node.endOfFileToken));
        };

        SyntaxRewriter.prototype.visitExternalModuleReference = function (node) {
            return node.update(this.visitToken(node.requireKeyword), this.visitToken(node.openParenToken), this.visitToken(node.stringLiteral), this.visitToken(node.closeParenToken));
        };

        SyntaxRewriter.prototype.visitModuleNameModuleReference = function (node) {
            return node.update(this.visitNodeOrToken(node.moduleName));
        };

        SyntaxRewriter.prototype.visitImportDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.importKeyword), this.visitToken(node.identifier), this.visitToken(node.equalsToken), this.visitNode(node.moduleReference), this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitExportAssignment = function (node) {
            return node.update(this.visitToken(node.exportKeyword), this.visitToken(node.equalsToken), this.visitToken(node.identifier), this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitClassDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.classKeyword), this.visitToken(node.identifier), node.typeParameterList === null ? null : this.visitNode(node.typeParameterList), this.visitList(node.heritageClauses), this.visitToken(node.openBraceToken), this.visitList(node.classElements), this.visitToken(node.closeBraceToken));
        };

        SyntaxRewriter.prototype.visitInterfaceDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.interfaceKeyword), this.visitToken(node.identifier), node.typeParameterList === null ? null : this.visitNode(node.typeParameterList), this.visitList(node.heritageClauses), this.visitNode(node.body));
        };

        SyntaxRewriter.prototype.visitHeritageClause = function (node) {
            return node.update(this.visitToken(node.extendsOrImplementsKeyword), this.visitSeparatedList(node.typeNames));
        };

        SyntaxRewriter.prototype.visitModuleDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.moduleKeyword), node.moduleName === null ? null : this.visitNodeOrToken(node.moduleName), node.stringLiteral === null ? null : this.visitToken(node.stringLiteral), this.visitToken(node.openBraceToken), this.visitList(node.moduleElements), this.visitToken(node.closeBraceToken));
        };

        SyntaxRewriter.prototype.visitFunctionDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.functionKeyword), this.visitToken(node.identifier), this.visitNode(node.callSignature), node.block === null ? null : this.visitNode(node.block), node.semicolonToken === null ? null : this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitVariableStatement = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitNode(node.variableDeclaration), this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitVariableDeclaration = function (node) {
            return node.update(this.visitToken(node.varKeyword), this.visitSeparatedList(node.variableDeclarators));
        };

        SyntaxRewriter.prototype.visitVariableDeclarator = function (node) {
            return node.update(this.visitToken(node.identifier), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation), node.equalsValueClause === null ? null : this.visitNode(node.equalsValueClause));
        };

        SyntaxRewriter.prototype.visitEqualsValueClause = function (node) {
            return node.update(this.visitToken(node.equalsToken), this.visitNodeOrToken(node.value));
        };

        SyntaxRewriter.prototype.visitPrefixUnaryExpression = function (node) {
            return node.update(node.kind(), this.visitToken(node.operatorToken), this.visitNodeOrToken(node.operand));
        };

        SyntaxRewriter.prototype.visitArrayLiteralExpression = function (node) {
            return node.update(this.visitToken(node.openBracketToken), this.visitSeparatedList(node.expressions), this.visitToken(node.closeBracketToken));
        };

        SyntaxRewriter.prototype.visitOmittedExpression = function (node) {
            return node;
        };

        SyntaxRewriter.prototype.visitParenthesizedExpression = function (node) {
            return node.update(this.visitToken(node.openParenToken), this.visitNodeOrToken(node.expression), this.visitToken(node.closeParenToken));
        };

        SyntaxRewriter.prototype.visitSimpleArrowFunctionExpression = function (node) {
            return node.update(this.visitToken(node.identifier), this.visitToken(node.equalsGreaterThanToken), this.visitNodeOrToken(node.body));
        };

        SyntaxRewriter.prototype.visitParenthesizedArrowFunctionExpression = function (node) {
            return node.update(this.visitNode(node.callSignature), this.visitToken(node.equalsGreaterThanToken), this.visitNodeOrToken(node.body));
        };

        SyntaxRewriter.prototype.visitQualifiedName = function (node) {
            return node.update(this.visitNodeOrToken(node.left), this.visitToken(node.dotToken), this.visitToken(node.right));
        };

        SyntaxRewriter.prototype.visitTypeArgumentList = function (node) {
            return node.update(this.visitToken(node.lessThanToken), this.visitSeparatedList(node.typeArguments), this.visitToken(node.greaterThanToken));
        };

        SyntaxRewriter.prototype.visitConstructorType = function (node) {
            return node.update(this.visitToken(node.newKeyword), node.typeParameterList === null ? null : this.visitNode(node.typeParameterList), this.visitNode(node.parameterList), this.visitToken(node.equalsGreaterThanToken), this.visitNodeOrToken(node.type));
        };

        SyntaxRewriter.prototype.visitFunctionType = function (node) {
            return node.update(node.typeParameterList === null ? null : this.visitNode(node.typeParameterList), this.visitNode(node.parameterList), this.visitToken(node.equalsGreaterThanToken), this.visitNodeOrToken(node.type));
        };

        SyntaxRewriter.prototype.visitObjectType = function (node) {
            return node.update(this.visitToken(node.openBraceToken), this.visitSeparatedList(node.typeMembers), this.visitToken(node.closeBraceToken));
        };

        SyntaxRewriter.prototype.visitArrayType = function (node) {
            return node.update(this.visitNodeOrToken(node.type), this.visitToken(node.openBracketToken), this.visitToken(node.closeBracketToken));
        };

        SyntaxRewriter.prototype.visitGenericType = function (node) {
            return node.update(this.visitNodeOrToken(node.name), this.visitNode(node.typeArgumentList));
        };

        SyntaxRewriter.prototype.visitTypeQuery = function (node) {
            return node.update(this.visitToken(node.typeOfKeyword), this.visitNodeOrToken(node.name));
        };

        SyntaxRewriter.prototype.visitTypeAnnotation = function (node) {
            return node.update(this.visitToken(node.colonToken), this.visitNodeOrToken(node.type));
        };

        SyntaxRewriter.prototype.visitBlock = function (node) {
            return node.update(this.visitToken(node.openBraceToken), this.visitList(node.statements), this.visitToken(node.closeBraceToken));
        };

        SyntaxRewriter.prototype.visitParameter = function (node) {
            return node.update(node.dotDotDotToken === null ? null : this.visitToken(node.dotDotDotToken), node.publicOrPrivateKeyword === null ? null : this.visitToken(node.publicOrPrivateKeyword), this.visitToken(node.identifier), node.questionToken === null ? null : this.visitToken(node.questionToken), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation), node.equalsValueClause === null ? null : this.visitNode(node.equalsValueClause));
        };

        SyntaxRewriter.prototype.visitMemberAccessExpression = function (node) {
            return node.update(this.visitNodeOrToken(node.expression), this.visitToken(node.dotToken), this.visitToken(node.name));
        };

        SyntaxRewriter.prototype.visitPostfixUnaryExpression = function (node) {
            return node.update(node.kind(), this.visitNodeOrToken(node.operand), this.visitToken(node.operatorToken));
        };

        SyntaxRewriter.prototype.visitElementAccessExpression = function (node) {
            return node.update(this.visitNodeOrToken(node.expression), this.visitToken(node.openBracketToken), this.visitNodeOrToken(node.argumentExpression), this.visitToken(node.closeBracketToken));
        };

        SyntaxRewriter.prototype.visitInvocationExpression = function (node) {
            return node.update(this.visitNodeOrToken(node.expression), this.visitNode(node.argumentList));
        };

        SyntaxRewriter.prototype.visitArgumentList = function (node) {
            return node.update(node.typeArgumentList === null ? null : this.visitNode(node.typeArgumentList), this.visitToken(node.openParenToken), this.visitSeparatedList(node.arguments), this.visitToken(node.closeParenToken));
        };

        SyntaxRewriter.prototype.visitBinaryExpression = function (node) {
            return node.update(node.kind(), this.visitNodeOrToken(node.left), this.visitToken(node.operatorToken), this.visitNodeOrToken(node.right));
        };

        SyntaxRewriter.prototype.visitConditionalExpression = function (node) {
            return node.update(this.visitNodeOrToken(node.condition), this.visitToken(node.questionToken), this.visitNodeOrToken(node.whenTrue), this.visitToken(node.colonToken), this.visitNodeOrToken(node.whenFalse));
        };

        SyntaxRewriter.prototype.visitConstructSignature = function (node) {
            return node.update(this.visitToken(node.newKeyword), this.visitNode(node.callSignature));
        };

        SyntaxRewriter.prototype.visitMethodSignature = function (node) {
            return node.update(this.visitToken(node.propertyName), node.questionToken === null ? null : this.visitToken(node.questionToken), this.visitNode(node.callSignature));
        };

        SyntaxRewriter.prototype.visitIndexSignature = function (node) {
            return node.update(this.visitToken(node.openBracketToken), this.visitNode(node.parameter), this.visitToken(node.closeBracketToken), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation));
        };

        SyntaxRewriter.prototype.visitPropertySignature = function (node) {
            return node.update(this.visitToken(node.propertyName), node.questionToken === null ? null : this.visitToken(node.questionToken), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation));
        };

        SyntaxRewriter.prototype.visitCallSignature = function (node) {
            return node.update(node.typeParameterList === null ? null : this.visitNode(node.typeParameterList), this.visitNode(node.parameterList), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation));
        };

        SyntaxRewriter.prototype.visitParameterList = function (node) {
            return node.update(this.visitToken(node.openParenToken), this.visitSeparatedList(node.parameters), this.visitToken(node.closeParenToken));
        };

        SyntaxRewriter.prototype.visitTypeParameterList = function (node) {
            return node.update(this.visitToken(node.lessThanToken), this.visitSeparatedList(node.typeParameters), this.visitToken(node.greaterThanToken));
        };

        SyntaxRewriter.prototype.visitTypeParameter = function (node) {
            return node.update(this.visitToken(node.identifier), node.constraint === null ? null : this.visitNode(node.constraint));
        };

        SyntaxRewriter.prototype.visitConstraint = function (node) {
            return node.update(this.visitToken(node.extendsKeyword), this.visitNodeOrToken(node.type));
        };

        SyntaxRewriter.prototype.visitElseClause = function (node) {
            return node.update(this.visitToken(node.elseKeyword), this.visitNodeOrToken(node.statement));
        };

        SyntaxRewriter.prototype.visitIfStatement = function (node) {
            return node.update(this.visitToken(node.ifKeyword), this.visitToken(node.openParenToken), this.visitNodeOrToken(node.condition), this.visitToken(node.closeParenToken), this.visitNodeOrToken(node.statement), node.elseClause === null ? null : this.visitNode(node.elseClause));
        };

        SyntaxRewriter.prototype.visitExpressionStatement = function (node) {
            return node.update(this.visitNodeOrToken(node.expression), this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitConstructorDeclaration = function (node) {
            return node.update(this.visitToken(node.constructorKeyword), this.visitNode(node.parameterList), node.block === null ? null : this.visitNode(node.block), node.semicolonToken === null ? null : this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitMemberFunctionDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.propertyName), this.visitNode(node.callSignature), node.block === null ? null : this.visitNode(node.block), node.semicolonToken === null ? null : this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitGetMemberAccessorDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.getKeyword), this.visitToken(node.propertyName), this.visitNode(node.parameterList), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation), this.visitNode(node.block));
        };

        SyntaxRewriter.prototype.visitSetMemberAccessorDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.setKeyword), this.visitToken(node.propertyName), this.visitNode(node.parameterList), this.visitNode(node.block));
        };

        SyntaxRewriter.prototype.visitMemberVariableDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitNode(node.variableDeclarator), this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitThrowStatement = function (node) {
            return node.update(this.visitToken(node.throwKeyword), this.visitNodeOrToken(node.expression), this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitReturnStatement = function (node) {
            return node.update(this.visitToken(node.returnKeyword), node.expression === null ? null : this.visitNodeOrToken(node.expression), this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitObjectCreationExpression = function (node) {
            return node.update(this.visitToken(node.newKeyword), this.visitNodeOrToken(node.expression), node.argumentList === null ? null : this.visitNode(node.argumentList));
        };

        SyntaxRewriter.prototype.visitSwitchStatement = function (node) {
            return node.update(this.visitToken(node.switchKeyword), this.visitToken(node.openParenToken), this.visitNodeOrToken(node.expression), this.visitToken(node.closeParenToken), this.visitToken(node.openBraceToken), this.visitList(node.switchClauses), this.visitToken(node.closeBraceToken));
        };

        SyntaxRewriter.prototype.visitCaseSwitchClause = function (node) {
            return node.update(this.visitToken(node.caseKeyword), this.visitNodeOrToken(node.expression), this.visitToken(node.colonToken), this.visitList(node.statements));
        };

        SyntaxRewriter.prototype.visitDefaultSwitchClause = function (node) {
            return node.update(this.visitToken(node.defaultKeyword), this.visitToken(node.colonToken), this.visitList(node.statements));
        };

        SyntaxRewriter.prototype.visitBreakStatement = function (node) {
            return node.update(this.visitToken(node.breakKeyword), node.identifier === null ? null : this.visitToken(node.identifier), this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitContinueStatement = function (node) {
            return node.update(this.visitToken(node.continueKeyword), node.identifier === null ? null : this.visitToken(node.identifier), this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitForStatement = function (node) {
            return node.update(this.visitToken(node.forKeyword), this.visitToken(node.openParenToken), node.variableDeclaration === null ? null : this.visitNode(node.variableDeclaration), node.initializer === null ? null : this.visitNodeOrToken(node.initializer), this.visitToken(node.firstSemicolonToken), node.condition === null ? null : this.visitNodeOrToken(node.condition), this.visitToken(node.secondSemicolonToken), node.incrementor === null ? null : this.visitNodeOrToken(node.incrementor), this.visitToken(node.closeParenToken), this.visitNodeOrToken(node.statement));
        };

        SyntaxRewriter.prototype.visitForInStatement = function (node) {
            return node.update(this.visitToken(node.forKeyword), this.visitToken(node.openParenToken), node.variableDeclaration === null ? null : this.visitNode(node.variableDeclaration), node.left === null ? null : this.visitNodeOrToken(node.left), this.visitToken(node.inKeyword), this.visitNodeOrToken(node.expression), this.visitToken(node.closeParenToken), this.visitNodeOrToken(node.statement));
        };

        SyntaxRewriter.prototype.visitWhileStatement = function (node) {
            return node.update(this.visitToken(node.whileKeyword), this.visitToken(node.openParenToken), this.visitNodeOrToken(node.condition), this.visitToken(node.closeParenToken), this.visitNodeOrToken(node.statement));
        };

        SyntaxRewriter.prototype.visitWithStatement = function (node) {
            return node.update(this.visitToken(node.withKeyword), this.visitToken(node.openParenToken), this.visitNodeOrToken(node.condition), this.visitToken(node.closeParenToken), this.visitNodeOrToken(node.statement));
        };

        SyntaxRewriter.prototype.visitEnumDeclaration = function (node) {
            return node.update(this.visitList(node.modifiers), this.visitToken(node.enumKeyword), this.visitToken(node.identifier), this.visitToken(node.openBraceToken), this.visitSeparatedList(node.enumElements), this.visitToken(node.closeBraceToken));
        };

        SyntaxRewriter.prototype.visitEnumElement = function (node) {
            return node.update(this.visitToken(node.propertyName), node.equalsValueClause === null ? null : this.visitNode(node.equalsValueClause));
        };

        SyntaxRewriter.prototype.visitCastExpression = function (node) {
            return node.update(this.visitToken(node.lessThanToken), this.visitNodeOrToken(node.type), this.visitToken(node.greaterThanToken), this.visitNodeOrToken(node.expression));
        };

        SyntaxRewriter.prototype.visitObjectLiteralExpression = function (node) {
            return node.update(this.visitToken(node.openBraceToken), this.visitSeparatedList(node.propertyAssignments), this.visitToken(node.closeBraceToken));
        };

        SyntaxRewriter.prototype.visitSimplePropertyAssignment = function (node) {
            return node.update(this.visitToken(node.propertyName), this.visitToken(node.colonToken), this.visitNodeOrToken(node.expression));
        };

        SyntaxRewriter.prototype.visitFunctionPropertyAssignment = function (node) {
            return node.update(this.visitToken(node.propertyName), this.visitNode(node.callSignature), this.visitNode(node.block));
        };

        SyntaxRewriter.prototype.visitGetAccessorPropertyAssignment = function (node) {
            return node.update(this.visitToken(node.getKeyword), this.visitToken(node.propertyName), this.visitToken(node.openParenToken), this.visitToken(node.closeParenToken), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation), this.visitNode(node.block));
        };

        SyntaxRewriter.prototype.visitSetAccessorPropertyAssignment = function (node) {
            return node.update(this.visitToken(node.setKeyword), this.visitToken(node.propertyName), this.visitToken(node.openParenToken), this.visitNode(node.parameter), this.visitToken(node.closeParenToken), this.visitNode(node.block));
        };

        SyntaxRewriter.prototype.visitFunctionExpression = function (node) {
            return node.update(this.visitToken(node.functionKeyword), node.identifier === null ? null : this.visitToken(node.identifier), this.visitNode(node.callSignature), this.visitNode(node.block));
        };

        SyntaxRewriter.prototype.visitEmptyStatement = function (node) {
            return node.update(this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitTryStatement = function (node) {
            return node.update(this.visitToken(node.tryKeyword), this.visitNode(node.block), node.catchClause === null ? null : this.visitNode(node.catchClause), node.finallyClause === null ? null : this.visitNode(node.finallyClause));
        };

        SyntaxRewriter.prototype.visitCatchClause = function (node) {
            return node.update(this.visitToken(node.catchKeyword), this.visitToken(node.openParenToken), this.visitToken(node.identifier), node.typeAnnotation === null ? null : this.visitNode(node.typeAnnotation), this.visitToken(node.closeParenToken), this.visitNode(node.block));
        };

        SyntaxRewriter.prototype.visitFinallyClause = function (node) {
            return node.update(this.visitToken(node.finallyKeyword), this.visitNode(node.block));
        };

        SyntaxRewriter.prototype.visitLabeledStatement = function (node) {
            return node.update(this.visitToken(node.identifier), this.visitToken(node.colonToken), this.visitNodeOrToken(node.statement));
        };

        SyntaxRewriter.prototype.visitDoStatement = function (node) {
            return node.update(this.visitToken(node.doKeyword), this.visitNodeOrToken(node.statement), this.visitToken(node.whileKeyword), this.visitToken(node.openParenToken), this.visitNodeOrToken(node.condition), this.visitToken(node.closeParenToken), this.visitToken(node.semicolonToken));
        };

        SyntaxRewriter.prototype.visitTypeOfExpression = function (node) {
            return node.update(this.visitToken(node.typeOfKeyword), this.visitNodeOrToken(node.expression));
        };

        SyntaxRewriter.prototype.visitDeleteExpression = function (node) {
            return node.update(this.visitToken(node.deleteKeyword), this.visitNodeOrToken(node.expression));
        };

        SyntaxRewriter.prototype.visitVoidExpression = function (node) {
            return node.update(this.visitToken(node.voidKeyword), this.visitNodeOrToken(node.expression));
        };

        SyntaxRewriter.prototype.visitDebuggerStatement = function (node) {
            return node.update(this.visitToken(node.debuggerKeyword), this.visitToken(node.semicolonToken));
        };
        return SyntaxRewriter;
    })();
    TypeScript.SyntaxRewriter = SyntaxRewriter;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxDedenter = (function (_super) {
        __extends(SyntaxDedenter, _super);
        function SyntaxDedenter(dedentFirstToken, dedentationAmount, minimumIndent, options) {
            _super.call(this);
            this.dedentationAmount = dedentationAmount;
            this.minimumIndent = minimumIndent;
            this.options = options;
            this.lastTriviaWasNewLine = dedentFirstToken;
        }
        SyntaxDedenter.prototype.abort = function () {
            this.lastTriviaWasNewLine = false;
            this.dedentationAmount = 0;
        };

        SyntaxDedenter.prototype.isAborted = function () {
            return this.dedentationAmount === 0;
        };

        SyntaxDedenter.prototype.visitToken = function (token) {
            if (token.width() === 0) {
                return token;
            }

            var result = token;
            if (this.lastTriviaWasNewLine) {
                result = token.withLeadingTrivia(this.dedentTriviaList(token.leadingTrivia()));
            }

            if (this.isAborted()) {
                return token;
            }

            this.lastTriviaWasNewLine = token.hasTrailingNewLine();
            return result;
        };

        SyntaxDedenter.prototype.dedentTriviaList = function (triviaList) {
            var result = [];
            var dedentNextWhitespace = true;

            for (var i = 0, n = triviaList.count(); i < n && !this.isAborted(); i++) {
                var trivia = triviaList.syntaxTriviaAt(i);

                var dedentThisTrivia = dedentNextWhitespace;
                dedentNextWhitespace = false;

                if (dedentThisTrivia) {
                    if (trivia.kind() === 4 /* WhitespaceTrivia */) {
                        var hasFollowingNewLine = (i < triviaList.count() - 1) && triviaList.syntaxTriviaAt(i + 1).kind() === 5 /* NewLineTrivia */;
                        result.push(this.dedentWhitespace(trivia, hasFollowingNewLine));
                        continue;
                    } else if (trivia.kind() !== 5 /* NewLineTrivia */) {
                        this.abort();
                        break;
                    }
                }

                if (trivia.kind() === 6 /* MultiLineCommentTrivia */) {
                    result.push(this.dedentMultiLineComment(trivia));
                    continue;
                }

                result.push(trivia);
                if (trivia.kind() === 5 /* NewLineTrivia */) {
                    dedentNextWhitespace = true;
                }
            }

            if (dedentNextWhitespace) {
                this.abort();
            }

            if (this.isAborted()) {
                return triviaList;
            }

            return TypeScript.Syntax.triviaList(result);
        };

        SyntaxDedenter.prototype.dedentSegment = function (segment, hasFollowingNewLineTrivia) {
            var firstNonWhitespacePosition = TypeScript.Indentation.firstNonWhitespacePosition(segment);

            if (firstNonWhitespacePosition === segment.length) {
                if (hasFollowingNewLineTrivia) {
                    return "";
                }
            } else if (TypeScript.CharacterInfo.isLineTerminator(segment.charCodeAt(firstNonWhitespacePosition))) {
                return segment.substring(firstNonWhitespacePosition);
            }

            var firstNonWhitespaceColumn = TypeScript.Indentation.columnForPositionInString(segment, firstNonWhitespacePosition, this.options);

            var newFirstNonWhitespaceColumn = TypeScript.MathPrototype.min(firstNonWhitespaceColumn, TypeScript.MathPrototype.max(firstNonWhitespaceColumn - this.dedentationAmount, this.minimumIndent));

            if (newFirstNonWhitespaceColumn === firstNonWhitespaceColumn) {
                this.abort();
                return segment;
            }

            this.dedentationAmount = firstNonWhitespaceColumn - newFirstNonWhitespaceColumn;
            TypeScript.Debug.assert(this.dedentationAmount >= 0);

            var indentationString = TypeScript.Indentation.indentationString(newFirstNonWhitespaceColumn, this.options);

            return indentationString + segment.substring(firstNonWhitespacePosition);
        };

        SyntaxDedenter.prototype.dedentWhitespace = function (trivia, hasFollowingNewLineTrivia) {
            var newIndentation = this.dedentSegment(trivia.fullText(), hasFollowingNewLineTrivia);
            return TypeScript.Syntax.whitespace(newIndentation);
        };

        SyntaxDedenter.prototype.dedentMultiLineComment = function (trivia) {
            var segments = TypeScript.Syntax.splitMultiLineCommentTriviaIntoMultipleLines(trivia);
            if (segments.length === 1) {
                return trivia;
            }

            for (var i = 1; i < segments.length; i++) {
                var segment = segments[i];
                segments[i] = this.dedentSegment(segment, false);
            }

            var result = segments.join("");

            return TypeScript.Syntax.multiLineComment(result);
        };

        SyntaxDedenter.dedentNode = function (node, dedentFirstToken, dedentAmount, minimumIndent, options) {
            var dedenter = new SyntaxDedenter(dedentFirstToken, dedentAmount, minimumIndent, options);
            var result = node.accept(dedenter);

            if (dedenter.isAborted()) {
                return node;
            }

            return result;
        };
        return SyntaxDedenter;
    })(TypeScript.SyntaxRewriter);
    TypeScript.SyntaxDedenter = SyntaxDedenter;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxIndenter = (function (_super) {
        __extends(SyntaxIndenter, _super);
        function SyntaxIndenter(indentFirstToken, indentationAmount, options) {
            _super.call(this);
            this.indentationAmount = indentationAmount;
            this.options = options;
            this.lastTriviaWasNewLine = indentFirstToken;
            this.indentationTrivia = TypeScript.Indentation.indentationTrivia(this.indentationAmount, this.options);
        }
        SyntaxIndenter.prototype.visitToken = function (token) {
            if (token.width() === 0) {
                return token;
            }

            var result = token;
            if (this.lastTriviaWasNewLine) {
                result = token.withLeadingTrivia(this.indentTriviaList(token.leadingTrivia()));
            }

            this.lastTriviaWasNewLine = token.hasTrailingNewLine();
            return result;
        };

        SyntaxIndenter.prototype.indentTriviaList = function (triviaList) {
            var result = [];

            var indentNextTrivia = true;
            for (var i = 0, n = triviaList.count(); i < n; i++) {
                var trivia = triviaList.syntaxTriviaAt(i);

                var indentThisTrivia = indentNextTrivia;
                indentNextTrivia = false;

                switch (trivia.kind()) {
                    case 6 /* MultiLineCommentTrivia */:
                        this.indentMultiLineComment(trivia, indentThisTrivia, result);
                        continue;

                    case 7 /* SingleLineCommentTrivia */:
                    case 8 /* SkippedTokenTrivia */:
                        this.indentSingleLineOrSkippedText(trivia, indentThisTrivia, result);
                        continue;

                    case 4 /* WhitespaceTrivia */:
                        this.indentWhitespace(trivia, indentThisTrivia, result);
                        continue;

                    case 5 /* NewLineTrivia */:
                        result.push(trivia);
                        indentNextTrivia = true;
                        continue;

                    default:
                        throw TypeScript.Errors.invalidOperation();
                }
            }

            if (indentNextTrivia) {
                result.push(this.indentationTrivia);
            }

            return TypeScript.Syntax.triviaList(result);
        };

        SyntaxIndenter.prototype.indentSegment = function (segment) {
            var firstNonWhitespacePosition = TypeScript.Indentation.firstNonWhitespacePosition(segment);

            if (firstNonWhitespacePosition < segment.length && TypeScript.CharacterInfo.isLineTerminator(segment.charCodeAt(firstNonWhitespacePosition))) {
                return segment;
            }

            var firstNonWhitespaceColumn = TypeScript.Indentation.columnForPositionInString(segment, firstNonWhitespacePosition, this.options);

            var newFirstNonWhitespaceColumn = firstNonWhitespaceColumn + this.indentationAmount;

            var indentationString = TypeScript.Indentation.indentationString(newFirstNonWhitespaceColumn, this.options);

            return indentationString + segment.substring(firstNonWhitespacePosition);
        };

        SyntaxIndenter.prototype.indentWhitespace = function (trivia, indentThisTrivia, result) {
            if (!indentThisTrivia) {
                result.push(trivia);
                return;
            }

            var newIndentation = this.indentSegment(trivia.fullText());
            result.push(TypeScript.Syntax.whitespace(newIndentation));
        };

        SyntaxIndenter.prototype.indentSingleLineOrSkippedText = function (trivia, indentThisTrivia, result) {
            if (indentThisTrivia) {
                result.push(this.indentationTrivia);
            }

            result.push(trivia);
        };

        SyntaxIndenter.prototype.indentMultiLineComment = function (trivia, indentThisTrivia, result) {
            if (indentThisTrivia) {
                result.push(this.indentationTrivia);
            }

            var segments = TypeScript.Syntax.splitMultiLineCommentTriviaIntoMultipleLines(trivia);

            for (var i = 1; i < segments.length; i++) {
                segments[i] = this.indentSegment(segments[i]);
            }

            var newText = segments.join("");
            result.push(TypeScript.Syntax.multiLineComment(newText));
        };

        SyntaxIndenter.indentNode = function (node, indentFirstToken, indentAmount, options) {
            var indenter = new SyntaxIndenter(indentFirstToken, indentAmount, options);
            return node.accept(indenter);
        };

        SyntaxIndenter.indentNodes = function (nodes, indentFirstToken, indentAmount, options) {
            var indenter = new SyntaxIndenter(indentFirstToken, indentAmount, options);
            var result = TypeScript.ArrayUtilities.select(nodes, function (n) {
                return n.accept(indenter);
            });

            return result;
        };
        return SyntaxIndenter;
    })(TypeScript.SyntaxRewriter);
    TypeScript.SyntaxIndenter = SyntaxIndenter;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Syntax) {
        var VariableWidthTokenWithNoTrivia = (function () {
            function VariableWidthTokenWithNoTrivia(sourceText, fullStart, kind, textOrWidth) {
                this._sourceText = sourceText;
                this._fullStart = fullStart;
                this.tokenKind = kind;
                this._textOrWidth = textOrWidth;
            }
            VariableWidthTokenWithNoTrivia.prototype.clone = function () {
                return new VariableWidthTokenWithNoTrivia(this._sourceText, this._fullStart, this.tokenKind, this._textOrWidth);
            };

            VariableWidthTokenWithNoTrivia.prototype.isNode = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.isToken = function () {
                return true;
            };
            VariableWidthTokenWithNoTrivia.prototype.isList = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.isSeparatedList = function () {
                return false;
            };

            VariableWidthTokenWithNoTrivia.prototype.kind = function () {
                return this.tokenKind;
            };

            VariableWidthTokenWithNoTrivia.prototype.childCount = function () {
                return 0;
            };
            VariableWidthTokenWithNoTrivia.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange('index');
            };

            VariableWidthTokenWithNoTrivia.prototype.fullWidth = function () {
                return this.width();
            };
            VariableWidthTokenWithNoTrivia.prototype.start = function () {
                return this._fullStart;
            };
            VariableWidthTokenWithNoTrivia.prototype.end = function () {
                return this.start() + this.width();
            };

            VariableWidthTokenWithNoTrivia.prototype.width = function () {
                return typeof this._textOrWidth === 'number' ? this._textOrWidth : this._textOrWidth.length;
            };

            VariableWidthTokenWithNoTrivia.prototype.text = function () {
                if (typeof this._textOrWidth === 'number') {
                    this._textOrWidth = this._sourceText.substr(this.start(), this._textOrWidth, this.tokenKind === 11 /* IdentifierName */);
                }

                return this._textOrWidth;
            };

            VariableWidthTokenWithNoTrivia.prototype.fullText = function () {
                return this._sourceText.substr(this._fullStart, this.fullWidth(), false);
            };

            VariableWidthTokenWithNoTrivia.prototype.value = function () {
                if ((this)._value === undefined) {
                    (this)._value = Syntax.value(this);
                }

                return (this)._value;
            };

            VariableWidthTokenWithNoTrivia.prototype.valueText = function () {
                if ((this)._valueText === undefined) {
                    (this)._valueText = Syntax.valueText(this);
                }

                return (this)._valueText;
            };

            VariableWidthTokenWithNoTrivia.prototype.hasLeadingTrivia = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.hasLeadingComment = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.hasLeadingNewLine = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.hasLeadingSkippedText = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.leadingTriviaWidth = function () {
                return 0;
            };
            VariableWidthTokenWithNoTrivia.prototype.leadingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };

            VariableWidthTokenWithNoTrivia.prototype.hasTrailingTrivia = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.hasTrailingComment = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.hasTrailingNewLine = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.hasTrailingSkippedText = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.trailingTriviaWidth = function () {
                return 0;
            };
            VariableWidthTokenWithNoTrivia.prototype.trailingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };

            VariableWidthTokenWithNoTrivia.prototype.hasSkippedToken = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.toJSON = function (key) {
                return Syntax.tokenToJSON(this);
            };
            VariableWidthTokenWithNoTrivia.prototype.firstToken = function () {
                return this;
            };
            VariableWidthTokenWithNoTrivia.prototype.lastToken = function () {
                return this;
            };
            VariableWidthTokenWithNoTrivia.prototype.isTypeScriptSpecific = function () {
                return false;
            };
            VariableWidthTokenWithNoTrivia.prototype.isIncrementallyUnusable = function () {
                return this.fullWidth() === 0 || TypeScript.SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
            };
            VariableWidthTokenWithNoTrivia.prototype.accept = function (visitor) {
                return visitor.visitToken(this);
            };
            VariableWidthTokenWithNoTrivia.prototype.realize = function () {
                return Syntax.realizeToken(this);
            };
            VariableWidthTokenWithNoTrivia.prototype.collectTextElements = function (elements) {
                collectTokenTextElements(this, elements);
            };

            VariableWidthTokenWithNoTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };

            VariableWidthTokenWithNoTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };

            VariableWidthTokenWithNoTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };
            return VariableWidthTokenWithNoTrivia;
        })();
        Syntax.VariableWidthTokenWithNoTrivia = VariableWidthTokenWithNoTrivia;

        var VariableWidthTokenWithLeadingTrivia = (function () {
            function VariableWidthTokenWithLeadingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, textOrWidth) {
                this._sourceText = sourceText;
                this._fullStart = fullStart;
                this.tokenKind = kind;
                this._leadingTriviaInfo = leadingTriviaInfo;
                this._textOrWidth = textOrWidth;
            }
            VariableWidthTokenWithLeadingTrivia.prototype.clone = function () {
                return new VariableWidthTokenWithLeadingTrivia(this._sourceText, this._fullStart, this.tokenKind, this._leadingTriviaInfo, this._textOrWidth);
            };

            VariableWidthTokenWithLeadingTrivia.prototype.isNode = function () {
                return false;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.isToken = function () {
                return true;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.isList = function () {
                return false;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.isSeparatedList = function () {
                return false;
            };

            VariableWidthTokenWithLeadingTrivia.prototype.kind = function () {
                return this.tokenKind;
            };

            VariableWidthTokenWithLeadingTrivia.prototype.childCount = function () {
                return 0;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange('index');
            };

            VariableWidthTokenWithLeadingTrivia.prototype.fullWidth = function () {
                return getTriviaWidth(this._leadingTriviaInfo) + this.width();
            };
            VariableWidthTokenWithLeadingTrivia.prototype.start = function () {
                return this._fullStart + getTriviaWidth(this._leadingTriviaInfo);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.end = function () {
                return this.start() + this.width();
            };

            VariableWidthTokenWithLeadingTrivia.prototype.width = function () {
                return typeof this._textOrWidth === 'number' ? this._textOrWidth : this._textOrWidth.length;
            };

            VariableWidthTokenWithLeadingTrivia.prototype.text = function () {
                if (typeof this._textOrWidth === 'number') {
                    this._textOrWidth = this._sourceText.substr(this.start(), this._textOrWidth, this.tokenKind === 11 /* IdentifierName */);
                }

                return this._textOrWidth;
            };

            VariableWidthTokenWithLeadingTrivia.prototype.fullText = function () {
                return this._sourceText.substr(this._fullStart, this.fullWidth(), false);
            };

            VariableWidthTokenWithLeadingTrivia.prototype.value = function () {
                if ((this)._value === undefined) {
                    (this)._value = Syntax.value(this);
                }

                return (this)._value;
            };

            VariableWidthTokenWithLeadingTrivia.prototype.valueText = function () {
                if ((this)._valueText === undefined) {
                    (this)._valueText = Syntax.valueText(this);
                }

                return (this)._valueText;
            };

            VariableWidthTokenWithLeadingTrivia.prototype.hasLeadingTrivia = function () {
                return true;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.hasLeadingComment = function () {
                return hasTriviaComment(this._leadingTriviaInfo);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.hasLeadingNewLine = function () {
                return hasTriviaNewLine(this._leadingTriviaInfo);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.hasLeadingSkippedText = function () {
                return false;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.leadingTriviaWidth = function () {
                return getTriviaWidth(this._leadingTriviaInfo);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.leadingTrivia = function () {
                return TypeScript.Scanner.scanTrivia(this._sourceText, this._fullStart, getTriviaWidth(this._leadingTriviaInfo), false);
            };

            VariableWidthTokenWithLeadingTrivia.prototype.hasTrailingTrivia = function () {
                return false;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.hasTrailingComment = function () {
                return false;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.hasTrailingNewLine = function () {
                return false;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.hasTrailingSkippedText = function () {
                return false;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.trailingTriviaWidth = function () {
                return 0;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.trailingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };

            VariableWidthTokenWithLeadingTrivia.prototype.hasSkippedToken = function () {
                return false;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.toJSON = function (key) {
                return Syntax.tokenToJSON(this);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.firstToken = function () {
                return this;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.lastToken = function () {
                return this;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.isTypeScriptSpecific = function () {
                return false;
            };
            VariableWidthTokenWithLeadingTrivia.prototype.isIncrementallyUnusable = function () {
                return this.fullWidth() === 0 || TypeScript.SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.accept = function (visitor) {
                return visitor.visitToken(this);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.realize = function () {
                return Syntax.realizeToken(this);
            };
            VariableWidthTokenWithLeadingTrivia.prototype.collectTextElements = function (elements) {
                collectTokenTextElements(this, elements);
            };

            VariableWidthTokenWithLeadingTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };

            VariableWidthTokenWithLeadingTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };

            VariableWidthTokenWithLeadingTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };
            return VariableWidthTokenWithLeadingTrivia;
        })();
        Syntax.VariableWidthTokenWithLeadingTrivia = VariableWidthTokenWithLeadingTrivia;

        var VariableWidthTokenWithTrailingTrivia = (function () {
            function VariableWidthTokenWithTrailingTrivia(sourceText, fullStart, kind, textOrWidth, trailingTriviaInfo) {
                this._sourceText = sourceText;
                this._fullStart = fullStart;
                this.tokenKind = kind;
                this._textOrWidth = textOrWidth;
                this._trailingTriviaInfo = trailingTriviaInfo;
            }
            VariableWidthTokenWithTrailingTrivia.prototype.clone = function () {
                return new VariableWidthTokenWithTrailingTrivia(this._sourceText, this._fullStart, this.tokenKind, this._textOrWidth, this._trailingTriviaInfo);
            };

            VariableWidthTokenWithTrailingTrivia.prototype.isNode = function () {
                return false;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.isToken = function () {
                return true;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.isList = function () {
                return false;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.isSeparatedList = function () {
                return false;
            };

            VariableWidthTokenWithTrailingTrivia.prototype.kind = function () {
                return this.tokenKind;
            };

            VariableWidthTokenWithTrailingTrivia.prototype.childCount = function () {
                return 0;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange('index');
            };

            VariableWidthTokenWithTrailingTrivia.prototype.fullWidth = function () {
                return this.width() + getTriviaWidth(this._trailingTriviaInfo);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.start = function () {
                return this._fullStart;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.end = function () {
                return this.start() + this.width();
            };

            VariableWidthTokenWithTrailingTrivia.prototype.width = function () {
                return typeof this._textOrWidth === 'number' ? this._textOrWidth : this._textOrWidth.length;
            };

            VariableWidthTokenWithTrailingTrivia.prototype.text = function () {
                if (typeof this._textOrWidth === 'number') {
                    this._textOrWidth = this._sourceText.substr(this.start(), this._textOrWidth, this.tokenKind === 11 /* IdentifierName */);
                }

                return this._textOrWidth;
            };

            VariableWidthTokenWithTrailingTrivia.prototype.fullText = function () {
                return this._sourceText.substr(this._fullStart, this.fullWidth(), false);
            };

            VariableWidthTokenWithTrailingTrivia.prototype.value = function () {
                if ((this)._value === undefined) {
                    (this)._value = Syntax.value(this);
                }

                return (this)._value;
            };

            VariableWidthTokenWithTrailingTrivia.prototype.valueText = function () {
                if ((this)._valueText === undefined) {
                    (this)._valueText = Syntax.valueText(this);
                }

                return (this)._valueText;
            };

            VariableWidthTokenWithTrailingTrivia.prototype.hasLeadingTrivia = function () {
                return false;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.hasLeadingComment = function () {
                return false;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.hasLeadingNewLine = function () {
                return false;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.hasLeadingSkippedText = function () {
                return false;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.leadingTriviaWidth = function () {
                return 0;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.leadingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };

            VariableWidthTokenWithTrailingTrivia.prototype.hasTrailingTrivia = function () {
                return true;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.hasTrailingComment = function () {
                return hasTriviaComment(this._trailingTriviaInfo);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.hasTrailingNewLine = function () {
                return hasTriviaNewLine(this._trailingTriviaInfo);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.hasTrailingSkippedText = function () {
                return false;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.trailingTriviaWidth = function () {
                return getTriviaWidth(this._trailingTriviaInfo);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.trailingTrivia = function () {
                return TypeScript.Scanner.scanTrivia(this._sourceText, this.end(), getTriviaWidth(this._trailingTriviaInfo), true);
            };

            VariableWidthTokenWithTrailingTrivia.prototype.hasSkippedToken = function () {
                return false;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.toJSON = function (key) {
                return Syntax.tokenToJSON(this);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.firstToken = function () {
                return this;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.lastToken = function () {
                return this;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.isTypeScriptSpecific = function () {
                return false;
            };
            VariableWidthTokenWithTrailingTrivia.prototype.isIncrementallyUnusable = function () {
                return this.fullWidth() === 0 || TypeScript.SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.accept = function (visitor) {
                return visitor.visitToken(this);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.realize = function () {
                return Syntax.realizeToken(this);
            };
            VariableWidthTokenWithTrailingTrivia.prototype.collectTextElements = function (elements) {
                collectTokenTextElements(this, elements);
            };

            VariableWidthTokenWithTrailingTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };

            VariableWidthTokenWithTrailingTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };

            VariableWidthTokenWithTrailingTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };
            return VariableWidthTokenWithTrailingTrivia;
        })();
        Syntax.VariableWidthTokenWithTrailingTrivia = VariableWidthTokenWithTrailingTrivia;

        var VariableWidthTokenWithLeadingAndTrailingTrivia = (function () {
            function VariableWidthTokenWithLeadingAndTrailingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, textOrWidth, trailingTriviaInfo) {
                this._sourceText = sourceText;
                this._fullStart = fullStart;
                this.tokenKind = kind;
                this._leadingTriviaInfo = leadingTriviaInfo;
                this._textOrWidth = textOrWidth;
                this._trailingTriviaInfo = trailingTriviaInfo;
            }
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.clone = function () {
                return new VariableWidthTokenWithLeadingAndTrailingTrivia(this._sourceText, this._fullStart, this.tokenKind, this._leadingTriviaInfo, this._textOrWidth, this._trailingTriviaInfo);
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isNode = function () {
                return false;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isToken = function () {
                return true;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isList = function () {
                return false;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isSeparatedList = function () {
                return false;
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.kind = function () {
                return this.tokenKind;
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.childCount = function () {
                return 0;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange('index');
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.fullWidth = function () {
                return getTriviaWidth(this._leadingTriviaInfo) + this.width() + getTriviaWidth(this._trailingTriviaInfo);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.start = function () {
                return this._fullStart + getTriviaWidth(this._leadingTriviaInfo);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.end = function () {
                return this.start() + this.width();
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.width = function () {
                return typeof this._textOrWidth === 'number' ? this._textOrWidth : this._textOrWidth.length;
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.text = function () {
                if (typeof this._textOrWidth === 'number') {
                    this._textOrWidth = this._sourceText.substr(this.start(), this._textOrWidth, this.tokenKind === 11 /* IdentifierName */);
                }

                return this._textOrWidth;
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.fullText = function () {
                return this._sourceText.substr(this._fullStart, this.fullWidth(), false);
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.value = function () {
                if ((this)._value === undefined) {
                    (this)._value = Syntax.value(this);
                }

                return (this)._value;
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.valueText = function () {
                if ((this)._valueText === undefined) {
                    (this)._valueText = Syntax.valueText(this);
                }

                return (this)._valueText;
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingTrivia = function () {
                return true;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingComment = function () {
                return hasTriviaComment(this._leadingTriviaInfo);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingNewLine = function () {
                return hasTriviaNewLine(this._leadingTriviaInfo);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingSkippedText = function () {
                return false;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.leadingTriviaWidth = function () {
                return getTriviaWidth(this._leadingTriviaInfo);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.leadingTrivia = function () {
                return TypeScript.Scanner.scanTrivia(this._sourceText, this._fullStart, getTriviaWidth(this._leadingTriviaInfo), false);
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingTrivia = function () {
                return true;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingComment = function () {
                return hasTriviaComment(this._trailingTriviaInfo);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingNewLine = function () {
                return hasTriviaNewLine(this._trailingTriviaInfo);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingSkippedText = function () {
                return false;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.trailingTriviaWidth = function () {
                return getTriviaWidth(this._trailingTriviaInfo);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.trailingTrivia = function () {
                return TypeScript.Scanner.scanTrivia(this._sourceText, this.end(), getTriviaWidth(this._trailingTriviaInfo), true);
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.hasSkippedToken = function () {
                return false;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.toJSON = function (key) {
                return Syntax.tokenToJSON(this);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.firstToken = function () {
                return this;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.lastToken = function () {
                return this;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isTypeScriptSpecific = function () {
                return false;
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.isIncrementallyUnusable = function () {
                return this.fullWidth() === 0 || TypeScript.SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.accept = function (visitor) {
                return visitor.visitToken(this);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.realize = function () {
                return Syntax.realizeToken(this);
            };
            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.collectTextElements = function (elements) {
                collectTokenTextElements(this, elements);
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };

            VariableWidthTokenWithLeadingAndTrailingTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };
            return VariableWidthTokenWithLeadingAndTrailingTrivia;
        })();
        Syntax.VariableWidthTokenWithLeadingAndTrailingTrivia = VariableWidthTokenWithLeadingAndTrailingTrivia;

        var FixedWidthTokenWithNoTrivia = (function () {
            function FixedWidthTokenWithNoTrivia(kind) {
                this.tokenKind = kind;
            }
            FixedWidthTokenWithNoTrivia.prototype.clone = function () {
                return new FixedWidthTokenWithNoTrivia(this.tokenKind);
            };

            FixedWidthTokenWithNoTrivia.prototype.isNode = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.isToken = function () {
                return true;
            };
            FixedWidthTokenWithNoTrivia.prototype.isList = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.isSeparatedList = function () {
                return false;
            };

            FixedWidthTokenWithNoTrivia.prototype.kind = function () {
                return this.tokenKind;
            };

            FixedWidthTokenWithNoTrivia.prototype.childCount = function () {
                return 0;
            };
            FixedWidthTokenWithNoTrivia.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange('index');
            };

            FixedWidthTokenWithNoTrivia.prototype.fullWidth = function () {
                return this.width();
            };
            FixedWidthTokenWithNoTrivia.prototype.width = function () {
                return this.text().length;
            };
            FixedWidthTokenWithNoTrivia.prototype.text = function () {
                return TypeScript.SyntaxFacts.getText(this.tokenKind);
            };
            FixedWidthTokenWithNoTrivia.prototype.fullText = function () {
                return this.text();
            };

            FixedWidthTokenWithNoTrivia.prototype.value = function () {
                return Syntax.value(this);
            };
            FixedWidthTokenWithNoTrivia.prototype.valueText = function () {
                return Syntax.valueText(this);
            };
            FixedWidthTokenWithNoTrivia.prototype.hasLeadingTrivia = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.hasLeadingComment = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.hasLeadingNewLine = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.hasLeadingSkippedText = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.leadingTriviaWidth = function () {
                return 0;
            };
            FixedWidthTokenWithNoTrivia.prototype.leadingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };

            FixedWidthTokenWithNoTrivia.prototype.hasTrailingTrivia = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.hasTrailingComment = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.hasTrailingNewLine = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.hasTrailingSkippedText = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.trailingTriviaWidth = function () {
                return 0;
            };
            FixedWidthTokenWithNoTrivia.prototype.trailingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };

            FixedWidthTokenWithNoTrivia.prototype.hasSkippedToken = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.toJSON = function (key) {
                return Syntax.tokenToJSON(this);
            };
            FixedWidthTokenWithNoTrivia.prototype.firstToken = function () {
                return this;
            };
            FixedWidthTokenWithNoTrivia.prototype.lastToken = function () {
                return this;
            };
            FixedWidthTokenWithNoTrivia.prototype.isTypeScriptSpecific = function () {
                return false;
            };
            FixedWidthTokenWithNoTrivia.prototype.isIncrementallyUnusable = function () {
                return this.fullWidth() === 0 || TypeScript.SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
            };
            FixedWidthTokenWithNoTrivia.prototype.accept = function (visitor) {
                return visitor.visitToken(this);
            };
            FixedWidthTokenWithNoTrivia.prototype.realize = function () {
                return Syntax.realizeToken(this);
            };
            FixedWidthTokenWithNoTrivia.prototype.collectTextElements = function (elements) {
                collectTokenTextElements(this, elements);
            };

            FixedWidthTokenWithNoTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };

            FixedWidthTokenWithNoTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };

            FixedWidthTokenWithNoTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };
            return FixedWidthTokenWithNoTrivia;
        })();
        Syntax.FixedWidthTokenWithNoTrivia = FixedWidthTokenWithNoTrivia;

        var FixedWidthTokenWithLeadingTrivia = (function () {
            function FixedWidthTokenWithLeadingTrivia(sourceText, fullStart, kind, leadingTriviaInfo) {
                this._sourceText = sourceText;
                this._fullStart = fullStart;
                this.tokenKind = kind;
                this._leadingTriviaInfo = leadingTriviaInfo;
            }
            FixedWidthTokenWithLeadingTrivia.prototype.clone = function () {
                return new FixedWidthTokenWithLeadingTrivia(this._sourceText, this._fullStart, this.tokenKind, this._leadingTriviaInfo);
            };

            FixedWidthTokenWithLeadingTrivia.prototype.isNode = function () {
                return false;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.isToken = function () {
                return true;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.isList = function () {
                return false;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.isSeparatedList = function () {
                return false;
            };

            FixedWidthTokenWithLeadingTrivia.prototype.kind = function () {
                return this.tokenKind;
            };

            FixedWidthTokenWithLeadingTrivia.prototype.childCount = function () {
                return 0;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange('index');
            };

            FixedWidthTokenWithLeadingTrivia.prototype.fullWidth = function () {
                return getTriviaWidth(this._leadingTriviaInfo) + this.width();
            };
            FixedWidthTokenWithLeadingTrivia.prototype.start = function () {
                return this._fullStart + getTriviaWidth(this._leadingTriviaInfo);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.end = function () {
                return this.start() + this.width();
            };

            FixedWidthTokenWithLeadingTrivia.prototype.width = function () {
                return this.text().length;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.text = function () {
                return TypeScript.SyntaxFacts.getText(this.tokenKind);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.fullText = function () {
                return this._sourceText.substr(this._fullStart, this.fullWidth(), false);
            };

            FixedWidthTokenWithLeadingTrivia.prototype.value = function () {
                return Syntax.value(this);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.valueText = function () {
                return Syntax.valueText(this);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.hasLeadingTrivia = function () {
                return true;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.hasLeadingComment = function () {
                return hasTriviaComment(this._leadingTriviaInfo);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.hasLeadingNewLine = function () {
                return hasTriviaNewLine(this._leadingTriviaInfo);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.hasLeadingSkippedText = function () {
                return false;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.leadingTriviaWidth = function () {
                return getTriviaWidth(this._leadingTriviaInfo);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.leadingTrivia = function () {
                return TypeScript.Scanner.scanTrivia(this._sourceText, this._fullStart, getTriviaWidth(this._leadingTriviaInfo), false);
            };

            FixedWidthTokenWithLeadingTrivia.prototype.hasTrailingTrivia = function () {
                return false;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.hasTrailingComment = function () {
                return false;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.hasTrailingNewLine = function () {
                return false;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.hasTrailingSkippedText = function () {
                return false;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.trailingTriviaWidth = function () {
                return 0;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.trailingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };

            FixedWidthTokenWithLeadingTrivia.prototype.hasSkippedToken = function () {
                return false;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.toJSON = function (key) {
                return Syntax.tokenToJSON(this);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.firstToken = function () {
                return this;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.lastToken = function () {
                return this;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.isTypeScriptSpecific = function () {
                return false;
            };
            FixedWidthTokenWithLeadingTrivia.prototype.isIncrementallyUnusable = function () {
                return this.fullWidth() === 0 || TypeScript.SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.accept = function (visitor) {
                return visitor.visitToken(this);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.realize = function () {
                return Syntax.realizeToken(this);
            };
            FixedWidthTokenWithLeadingTrivia.prototype.collectTextElements = function (elements) {
                collectTokenTextElements(this, elements);
            };

            FixedWidthTokenWithLeadingTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };

            FixedWidthTokenWithLeadingTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };

            FixedWidthTokenWithLeadingTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };
            return FixedWidthTokenWithLeadingTrivia;
        })();
        Syntax.FixedWidthTokenWithLeadingTrivia = FixedWidthTokenWithLeadingTrivia;

        var FixedWidthTokenWithTrailingTrivia = (function () {
            function FixedWidthTokenWithTrailingTrivia(sourceText, fullStart, kind, trailingTriviaInfo) {
                this._sourceText = sourceText;
                this._fullStart = fullStart;
                this.tokenKind = kind;
                this._trailingTriviaInfo = trailingTriviaInfo;
            }
            FixedWidthTokenWithTrailingTrivia.prototype.clone = function () {
                return new FixedWidthTokenWithTrailingTrivia(this._sourceText, this._fullStart, this.tokenKind, this._trailingTriviaInfo);
            };

            FixedWidthTokenWithTrailingTrivia.prototype.isNode = function () {
                return false;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.isToken = function () {
                return true;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.isList = function () {
                return false;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.isSeparatedList = function () {
                return false;
            };

            FixedWidthTokenWithTrailingTrivia.prototype.kind = function () {
                return this.tokenKind;
            };

            FixedWidthTokenWithTrailingTrivia.prototype.childCount = function () {
                return 0;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange('index');
            };

            FixedWidthTokenWithTrailingTrivia.prototype.fullWidth = function () {
                return this.width() + getTriviaWidth(this._trailingTriviaInfo);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.start = function () {
                return this._fullStart;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.end = function () {
                return this.start() + this.width();
            };

            FixedWidthTokenWithTrailingTrivia.prototype.width = function () {
                return this.text().length;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.text = function () {
                return TypeScript.SyntaxFacts.getText(this.tokenKind);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.fullText = function () {
                return this._sourceText.substr(this._fullStart, this.fullWidth(), false);
            };

            FixedWidthTokenWithTrailingTrivia.prototype.value = function () {
                return Syntax.value(this);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.valueText = function () {
                return Syntax.valueText(this);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.hasLeadingTrivia = function () {
                return false;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.hasLeadingComment = function () {
                return false;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.hasLeadingNewLine = function () {
                return false;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.hasLeadingSkippedText = function () {
                return false;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.leadingTriviaWidth = function () {
                return 0;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.leadingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };

            FixedWidthTokenWithTrailingTrivia.prototype.hasTrailingTrivia = function () {
                return true;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.hasTrailingComment = function () {
                return hasTriviaComment(this._trailingTriviaInfo);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.hasTrailingNewLine = function () {
                return hasTriviaNewLine(this._trailingTriviaInfo);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.hasTrailingSkippedText = function () {
                return false;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.trailingTriviaWidth = function () {
                return getTriviaWidth(this._trailingTriviaInfo);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.trailingTrivia = function () {
                return TypeScript.Scanner.scanTrivia(this._sourceText, this.end(), getTriviaWidth(this._trailingTriviaInfo), true);
            };

            FixedWidthTokenWithTrailingTrivia.prototype.hasSkippedToken = function () {
                return false;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.toJSON = function (key) {
                return Syntax.tokenToJSON(this);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.firstToken = function () {
                return this;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.lastToken = function () {
                return this;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.isTypeScriptSpecific = function () {
                return false;
            };
            FixedWidthTokenWithTrailingTrivia.prototype.isIncrementallyUnusable = function () {
                return this.fullWidth() === 0 || TypeScript.SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.accept = function (visitor) {
                return visitor.visitToken(this);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.realize = function () {
                return Syntax.realizeToken(this);
            };
            FixedWidthTokenWithTrailingTrivia.prototype.collectTextElements = function (elements) {
                collectTokenTextElements(this, elements);
            };

            FixedWidthTokenWithTrailingTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };

            FixedWidthTokenWithTrailingTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };

            FixedWidthTokenWithTrailingTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };
            return FixedWidthTokenWithTrailingTrivia;
        })();
        Syntax.FixedWidthTokenWithTrailingTrivia = FixedWidthTokenWithTrailingTrivia;

        var FixedWidthTokenWithLeadingAndTrailingTrivia = (function () {
            function FixedWidthTokenWithLeadingAndTrailingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, trailingTriviaInfo) {
                this._sourceText = sourceText;
                this._fullStart = fullStart;
                this.tokenKind = kind;
                this._leadingTriviaInfo = leadingTriviaInfo;
                this._trailingTriviaInfo = trailingTriviaInfo;
            }
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.clone = function () {
                return new FixedWidthTokenWithLeadingAndTrailingTrivia(this._sourceText, this._fullStart, this.tokenKind, this._leadingTriviaInfo, this._trailingTriviaInfo);
            };

            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isNode = function () {
                return false;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isToken = function () {
                return true;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isList = function () {
                return false;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isSeparatedList = function () {
                return false;
            };

            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.kind = function () {
                return this.tokenKind;
            };

            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.childCount = function () {
                return 0;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange('index');
            };

            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.fullWidth = function () {
                return getTriviaWidth(this._leadingTriviaInfo) + this.width() + getTriviaWidth(this._trailingTriviaInfo);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.start = function () {
                return this._fullStart + getTriviaWidth(this._leadingTriviaInfo);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.end = function () {
                return this.start() + this.width();
            };

            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.width = function () {
                return this.text().length;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.text = function () {
                return TypeScript.SyntaxFacts.getText(this.tokenKind);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.fullText = function () {
                return this._sourceText.substr(this._fullStart, this.fullWidth(), false);
            };

            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.value = function () {
                return Syntax.value(this);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.valueText = function () {
                return Syntax.valueText(this);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingTrivia = function () {
                return true;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingComment = function () {
                return hasTriviaComment(this._leadingTriviaInfo);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingNewLine = function () {
                return hasTriviaNewLine(this._leadingTriviaInfo);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasLeadingSkippedText = function () {
                return false;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.leadingTriviaWidth = function () {
                return getTriviaWidth(this._leadingTriviaInfo);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.leadingTrivia = function () {
                return TypeScript.Scanner.scanTrivia(this._sourceText, this._fullStart, getTriviaWidth(this._leadingTriviaInfo), false);
            };

            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingTrivia = function () {
                return true;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingComment = function () {
                return hasTriviaComment(this._trailingTriviaInfo);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingNewLine = function () {
                return hasTriviaNewLine(this._trailingTriviaInfo);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasTrailingSkippedText = function () {
                return false;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.trailingTriviaWidth = function () {
                return getTriviaWidth(this._trailingTriviaInfo);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.trailingTrivia = function () {
                return TypeScript.Scanner.scanTrivia(this._sourceText, this.end(), getTriviaWidth(this._trailingTriviaInfo), true);
            };

            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.hasSkippedToken = function () {
                return false;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.toJSON = function (key) {
                return Syntax.tokenToJSON(this);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.firstToken = function () {
                return this;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.lastToken = function () {
                return this;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isTypeScriptSpecific = function () {
                return false;
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.isIncrementallyUnusable = function () {
                return this.fullWidth() === 0 || TypeScript.SyntaxFacts.isAnyDivideOrRegularExpressionToken(this.tokenKind);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.accept = function (visitor) {
                return visitor.visitToken(this);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.realize = function () {
                return Syntax.realizeToken(this);
            };
            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.collectTextElements = function (elements) {
                collectTokenTextElements(this, elements);
            };

            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };

            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };

            FixedWidthTokenWithLeadingAndTrailingTrivia.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };
            return FixedWidthTokenWithLeadingAndTrailingTrivia;
        })();
        Syntax.FixedWidthTokenWithLeadingAndTrailingTrivia = FixedWidthTokenWithLeadingAndTrailingTrivia;

        function collectTokenTextElements(token, elements) {
            token.leadingTrivia().collectTextElements(elements);
            elements.push(token.text());
            token.trailingTrivia().collectTextElements(elements);
        }

        function fixedWidthToken(sourceText, fullStart, kind, leadingTriviaInfo, trailingTriviaInfo) {
            if (leadingTriviaInfo === 0) {
                if (trailingTriviaInfo === 0) {
                    return new FixedWidthTokenWithNoTrivia(kind);
                } else {
                    return new FixedWidthTokenWithTrailingTrivia(sourceText, fullStart, kind, trailingTriviaInfo);
                }
            } else if (trailingTriviaInfo === 0) {
                return new FixedWidthTokenWithLeadingTrivia(sourceText, fullStart, kind, leadingTriviaInfo);
            } else {
                return new FixedWidthTokenWithLeadingAndTrailingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, trailingTriviaInfo);
            }
        }
        Syntax.fixedWidthToken = fixedWidthToken;

        function variableWidthToken(sourceText, fullStart, kind, leadingTriviaInfo, width, trailingTriviaInfo) {
            if (leadingTriviaInfo === 0) {
                if (trailingTriviaInfo === 0) {
                    return new VariableWidthTokenWithNoTrivia(sourceText, fullStart, kind, width);
                } else {
                    return new VariableWidthTokenWithTrailingTrivia(sourceText, fullStart, kind, width, trailingTriviaInfo);
                }
            } else if (trailingTriviaInfo === 0) {
                return new VariableWidthTokenWithLeadingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, width);
            } else {
                return new VariableWidthTokenWithLeadingAndTrailingTrivia(sourceText, fullStart, kind, leadingTriviaInfo, width, trailingTriviaInfo);
            }
        }
        Syntax.variableWidthToken = variableWidthToken;

        function getTriviaWidth(value) {
            return value >>> 2 /* TriviaFullWidthShift */;
        }

        function hasTriviaComment(value) {
            return (value & 2 /* TriviaCommentMask */) !== 0;
        }

        function hasTriviaNewLine(value) {
            return (value & 1 /* TriviaNewLineMask */) !== 0;
        }
    })(TypeScript.Syntax || (TypeScript.Syntax = {}));
    var Syntax = TypeScript.Syntax;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Syntax) {
        function realizeToken(token) {
            return new RealizedToken(token.tokenKind, token.leadingTrivia(), token.text(), token.value(), token.valueText(), token.trailingTrivia());
        }
        Syntax.realizeToken = realizeToken;

        function convertToIdentifierName(token) {
            TypeScript.Debug.assert(TypeScript.SyntaxFacts.isAnyKeyword(token.tokenKind));
            return new RealizedToken(11 /* IdentifierName */, token.leadingTrivia(), token.text(), token.text(), token.text(), token.trailingTrivia());
        }
        Syntax.convertToIdentifierName = convertToIdentifierName;

        function tokenToJSON(token) {
            var result = {};

            for (var name in TypeScript.SyntaxKind) {
                if (TypeScript.SyntaxKind[name] === token.kind()) {
                    result.kind = name;
                    break;
                }
            }

            result.width = token.width();
            if (token.fullWidth() !== token.width()) {
                result.fullWidth = token.fullWidth();
            }

            result.text = token.text();

            var value = token.value();
            if (value !== null) {
                result.value = value;
                result.valueText = token.valueText();
            }

            if (token.hasLeadingTrivia()) {
                result.hasLeadingTrivia = true;
            }

            if (token.hasLeadingComment()) {
                result.hasLeadingComment = true;
            }

            if (token.hasLeadingNewLine()) {
                result.hasLeadingNewLine = true;
            }

            if (token.hasLeadingSkippedText()) {
                result.hasLeadingSkippedText = true;
            }

            if (token.hasTrailingTrivia()) {
                result.hasTrailingTrivia = true;
            }

            if (token.hasTrailingComment()) {
                result.hasTrailingComment = true;
            }

            if (token.hasTrailingNewLine()) {
                result.hasTrailingNewLine = true;
            }

            if (token.hasTrailingSkippedText()) {
                result.hasTrailingSkippedText = true;
            }

            var trivia = token.leadingTrivia();
            if (trivia.count() > 0) {
                result.leadingTrivia = trivia;
            }

            trivia = token.trailingTrivia();
            if (trivia.count() > 0) {
                result.trailingTrivia = trivia;
            }

            return result;
        }
        Syntax.tokenToJSON = tokenToJSON;

        function value(token) {
            return value1(token.tokenKind, token.text());
        }
        Syntax.value = value;

        function hexValue(text, start, length) {
            var intChar = 0;
            for (var i = 0; i < length; i++) {
                var ch2 = text.charCodeAt(start + i);
                if (!TypeScript.CharacterInfo.isHexDigit(ch2)) {
                    break;
                }

                intChar = (intChar << 4) + TypeScript.CharacterInfo.hexValue(ch2);
            }

            return intChar;
        }

        var characterArray = [];

        function convertEscapes(text) {
            characterArray.length = 0;
            var result = "";

            for (var i = 0, n = text.length; i < n; i++) {
                var ch = text.charCodeAt(i);

                if (ch === 92 /* backslash */) {
                    i++;
                    if (i < n) {
                        ch = text.charCodeAt(i);
                        switch (ch) {
                            case 48 /* _0 */:
                                characterArray.push(0 /* nullCharacter */);
                                continue;

                            case 98 /* b */:
                                characterArray.push(8 /* backspace */);
                                continue;

                            case 102 /* f */:
                                characterArray.push(12 /* formFeed */);
                                continue;

                            case 110 /* n */:
                                characterArray.push(10 /* lineFeed */);
                                continue;

                            case 114 /* r */:
                                characterArray.push(13 /* carriageReturn */);
                                continue;

                            case 116 /* t */:
                                characterArray.push(9 /* tab */);
                                continue;

                            case 118 /* v */:
                                characterArray.push(11 /* verticalTab */);
                                continue;

                            case 120 /* x */:
                                characterArray.push(hexValue(text, i + 1, 2));
                                i += 2;
                                continue;

                            case 117 /* u */:
                                characterArray.push(hexValue(text, i + 1, 4));
                                i += 4;
                                continue;

                            default:
                        }
                    }
                }

                characterArray.push(ch);

                if (i && !(i % 1024)) {
                    result = result.concat(String.fromCharCode.apply(null, characterArray));
                    characterArray.length = 0;
                }
            }

            if (characterArray.length) {
                result = result.concat(String.fromCharCode.apply(null, characterArray));
            }

            return result;
        }

        function massageEscapes(text) {
            return text.indexOf("\\") >= 0 ? convertEscapes(text) : text;
        }
        Syntax.massageEscapes = massageEscapes;

        function value1(kind, text) {
            if (kind === 11 /* IdentifierName */) {
                return massageEscapes(text);
            }

            switch (kind) {
                case 37 /* TrueKeyword */:
                    return true;
                case 24 /* FalseKeyword */:
                    return false;
                case 32 /* NullKeyword */:
                    return null;
            }

            if (TypeScript.SyntaxFacts.isAnyKeyword(kind) || TypeScript.SyntaxFacts.isAnyPunctuation(kind)) {
                return TypeScript.SyntaxFacts.getText(kind);
            }

            if (kind === 13 /* NumericLiteral */) {
                return Syntax.isHexInteger(text) ? parseInt(text, 16) : parseFloat(text);
            } else if (kind === 14 /* StringLiteral */) {
                if (text.length > 1 && text.charCodeAt(text.length - 1) === text.charCodeAt(0)) {
                    return massageEscapes(text.substr(1, text.length - 2));
                } else {
                    return massageEscapes(text.substr(1));
                }
            } else if (kind === 12 /* RegularExpressionLiteral */) {
                try  {
                    var lastSlash = text.lastIndexOf("/");
                    var body = text.substring(1, lastSlash);
                    var flags = text.substring(lastSlash + 1);
                    return new RegExp(body, flags);
                } catch (e) {
                    return null;
                }
            } else if (kind === 10 /* EndOfFileToken */ || kind === 9 /* ErrorToken */) {
                return null;
            } else {
                throw TypeScript.Errors.invalidOperation();
            }
        }

        function valueText1(kind, text) {
            var value = value1(kind, text);
            return value === null ? "" : value.toString();
        }

        function valueText(token) {
            var value = token.value();
            return value === null ? "" : value.toString();
        }
        Syntax.valueText = valueText;

        var EmptyToken = (function () {
            function EmptyToken(kind) {
                this.tokenKind = kind;
            }
            EmptyToken.prototype.clone = function () {
                return new EmptyToken(this.tokenKind);
            };

            EmptyToken.prototype.kind = function () {
                return this.tokenKind;
            };

            EmptyToken.prototype.isToken = function () {
                return true;
            };
            EmptyToken.prototype.isNode = function () {
                return false;
            };
            EmptyToken.prototype.isList = function () {
                return false;
            };
            EmptyToken.prototype.isSeparatedList = function () {
                return false;
            };

            EmptyToken.prototype.childCount = function () {
                return 0;
            };

            EmptyToken.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            };

            EmptyToken.prototype.toJSON = function (key) {
                return tokenToJSON(this);
            };
            EmptyToken.prototype.accept = function (visitor) {
                return visitor.visitToken(this);
            };

            EmptyToken.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };

            EmptyToken.prototype.firstToken = function () {
                return this;
            };
            EmptyToken.prototype.lastToken = function () {
                return this;
            };
            EmptyToken.prototype.isTypeScriptSpecific = function () {
                return false;
            };

            EmptyToken.prototype.isIncrementallyUnusable = function () {
                return true;
            };

            EmptyToken.prototype.fullWidth = function () {
                return 0;
            };
            EmptyToken.prototype.width = function () {
                return 0;
            };
            EmptyToken.prototype.text = function () {
                return "";
            };
            EmptyToken.prototype.fullText = function () {
                return "";
            };
            EmptyToken.prototype.value = function () {
                return null;
            };
            EmptyToken.prototype.valueText = function () {
                return "";
            };

            EmptyToken.prototype.hasLeadingTrivia = function () {
                return false;
            };
            EmptyToken.prototype.hasLeadingComment = function () {
                return false;
            };
            EmptyToken.prototype.hasLeadingNewLine = function () {
                return false;
            };
            EmptyToken.prototype.hasLeadingSkippedText = function () {
                return false;
            };
            EmptyToken.prototype.leadingTriviaWidth = function () {
                return 0;
            };
            EmptyToken.prototype.hasTrailingTrivia = function () {
                return false;
            };
            EmptyToken.prototype.hasTrailingComment = function () {
                return false;
            };
            EmptyToken.prototype.hasTrailingNewLine = function () {
                return false;
            };
            EmptyToken.prototype.hasTrailingSkippedText = function () {
                return false;
            };
            EmptyToken.prototype.hasSkippedToken = function () {
                return false;
            };

            EmptyToken.prototype.trailingTriviaWidth = function () {
                return 0;
            };
            EmptyToken.prototype.leadingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };
            EmptyToken.prototype.trailingTrivia = function () {
                return TypeScript.Syntax.emptyTriviaList;
            };
            EmptyToken.prototype.realize = function () {
                return realizeToken(this);
            };
            EmptyToken.prototype.collectTextElements = function (elements) {
            };

            EmptyToken.prototype.withLeadingTrivia = function (leadingTrivia) {
                return this.realize().withLeadingTrivia(leadingTrivia);
            };

            EmptyToken.prototype.withTrailingTrivia = function (trailingTrivia) {
                return this.realize().withTrailingTrivia(trailingTrivia);
            };
            return EmptyToken;
        })();

        function emptyToken(kind) {
            return new EmptyToken(kind);
        }
        Syntax.emptyToken = emptyToken;

        var RealizedToken = (function () {
            function RealizedToken(tokenKind, leadingTrivia, text, value, valueText, trailingTrivia) {
                this.tokenKind = tokenKind;
                this._leadingTrivia = leadingTrivia;
                this._text = text;
                this._value = value;
                this._valueText = valueText;
                this._trailingTrivia = trailingTrivia;
            }
            RealizedToken.prototype.clone = function () {
                return new RealizedToken(this.tokenKind, this._leadingTrivia, this._text, this._value, this._valueText, this._trailingTrivia);
            };

            RealizedToken.prototype.kind = function () {
                return this.tokenKind;
            };
            RealizedToken.prototype.toJSON = function (key) {
                return tokenToJSON(this);
            };
            RealizedToken.prototype.firstToken = function () {
                return this;
            };
            RealizedToken.prototype.lastToken = function () {
                return this;
            };
            RealizedToken.prototype.isTypeScriptSpecific = function () {
                return false;
            };

            RealizedToken.prototype.isIncrementallyUnusable = function () {
                return true;
            };

            RealizedToken.prototype.accept = function (visitor) {
                return visitor.visitToken(this);
            };

            RealizedToken.prototype.childCount = function () {
                return 0;
            };

            RealizedToken.prototype.childAt = function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            };

            RealizedToken.prototype.isToken = function () {
                return true;
            };
            RealizedToken.prototype.isNode = function () {
                return false;
            };
            RealizedToken.prototype.isList = function () {
                return false;
            };
            RealizedToken.prototype.isSeparatedList = function () {
                return false;
            };
            RealizedToken.prototype.isTrivia = function () {
                return false;
            };
            RealizedToken.prototype.isTriviaList = function () {
                return false;
            };

            RealizedToken.prototype.fullWidth = function () {
                return this._leadingTrivia.fullWidth() + this.width() + this._trailingTrivia.fullWidth();
            };
            RealizedToken.prototype.width = function () {
                return this.text().length;
            };

            RealizedToken.prototype.text = function () {
                return this._text;
            };
            RealizedToken.prototype.fullText = function () {
                return this._leadingTrivia.fullText() + this.text() + this._trailingTrivia.fullText();
            };

            RealizedToken.prototype.value = function () {
                return this._value;
            };
            RealizedToken.prototype.valueText = function () {
                return this._valueText;
            };

            RealizedToken.prototype.hasLeadingTrivia = function () {
                return this._leadingTrivia.count() > 0;
            };
            RealizedToken.prototype.hasLeadingComment = function () {
                return this._leadingTrivia.hasComment();
            };
            RealizedToken.prototype.hasLeadingNewLine = function () {
                return this._leadingTrivia.hasNewLine();
            };
            RealizedToken.prototype.hasLeadingSkippedText = function () {
                return this._leadingTrivia.hasSkippedToken();
            };
            RealizedToken.prototype.leadingTriviaWidth = function () {
                return this._leadingTrivia.fullWidth();
            };

            RealizedToken.prototype.hasTrailingTrivia = function () {
                return this._trailingTrivia.count() > 0;
            };
            RealizedToken.prototype.hasTrailingComment = function () {
                return this._trailingTrivia.hasComment();
            };
            RealizedToken.prototype.hasTrailingNewLine = function () {
                return this._trailingTrivia.hasNewLine();
            };
            RealizedToken.prototype.hasTrailingSkippedText = function () {
                return this._trailingTrivia.hasSkippedToken();
            };
            RealizedToken.prototype.trailingTriviaWidth = function () {
                return this._trailingTrivia.fullWidth();
            };

            RealizedToken.prototype.hasSkippedToken = function () {
                return this.hasLeadingSkippedText() || this.hasTrailingSkippedText();
            };

            RealizedToken.prototype.leadingTrivia = function () {
                return this._leadingTrivia;
            };
            RealizedToken.prototype.trailingTrivia = function () {
                return this._trailingTrivia;
            };

            RealizedToken.prototype.findTokenInternal = function (parent, position, fullStart) {
                return new TypeScript.PositionedToken(parent, this, fullStart);
            };

            RealizedToken.prototype.collectTextElements = function (elements) {
                this.leadingTrivia().collectTextElements(elements);
                elements.push(this.text());
                this.trailingTrivia().collectTextElements(elements);
            };

            RealizedToken.prototype.withLeadingTrivia = function (leadingTrivia) {
                return new RealizedToken(this.tokenKind, leadingTrivia, this._text, this._value, this._valueText, this._trailingTrivia);
            };

            RealizedToken.prototype.withTrailingTrivia = function (trailingTrivia) {
                return new RealizedToken(this.tokenKind, this._leadingTrivia, this._text, this._value, this._valueText, trailingTrivia);
            };
            return RealizedToken;
        })();

        function token(kind, info) {
            if (typeof info === "undefined") { info = null; }
            var text = (info !== null && info.text !== undefined) ? info.text : TypeScript.SyntaxFacts.getText(kind);

            return new RealizedToken(kind, TypeScript.Syntax.triviaList(info === null ? null : info.leadingTrivia), text, value1(kind, text), valueText1(kind, text), TypeScript.Syntax.triviaList(info === null ? null : info.trailingTrivia));
        }
        Syntax.token = token;

        function identifier(text, info) {
            if (typeof info === "undefined") { info = null; }
            info = info || {};
            info.text = text;
            return token(11 /* IdentifierName */, info);
        }
        Syntax.identifier = identifier;
    })(TypeScript.Syntax || (TypeScript.Syntax = {}));
    var Syntax = TypeScript.Syntax;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxTokenReplacer = (function (_super) {
        __extends(SyntaxTokenReplacer, _super);
        function SyntaxTokenReplacer(token1, token2) {
            _super.call(this);
            this.token1 = token1;
            this.token2 = token2;
        }
        SyntaxTokenReplacer.prototype.visitToken = function (token) {
            if (token === this.token1) {
                var result = this.token2;
                this.token1 = null;
                this.token2 = null;

                return result;
            }

            return token;
        };

        SyntaxTokenReplacer.prototype.visitNode = function (node) {
            if (this.token1 === null) {
                return node;
            }

            return _super.prototype.visitNode.call(this, node);
        };

        SyntaxTokenReplacer.prototype.visitList = function (list) {
            if (this.token1 === null) {
                return list;
            }

            return _super.prototype.visitList.call(this, list);
        };

        SyntaxTokenReplacer.prototype.visitSeparatedList = function (list) {
            if (this.token1 === null) {
                return list;
            }

            return _super.prototype.visitSeparatedList.call(this, list);
        };
        return SyntaxTokenReplacer;
    })(TypeScript.SyntaxRewriter);
    TypeScript.SyntaxTokenReplacer = SyntaxTokenReplacer;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Syntax) {
        var SyntaxTrivia = (function () {
            function SyntaxTrivia(kind, textOrToken) {
                this._kind = kind;
                this._textOrToken = textOrToken;
            }
            SyntaxTrivia.prototype.toJSON = function (key) {
                var result = {};
                result.kind = TypeScript.SyntaxKind[this._kind];

                if (this.isSkippedToken()) {
                    result.skippedToken = this._textOrToken;
                } else {
                    result.text = this._textOrToken;
                }
                return result;
            };

            SyntaxTrivia.prototype.kind = function () {
                return this._kind;
            };

            SyntaxTrivia.prototype.fullWidth = function () {
                return this.fullText().length;
            };

            SyntaxTrivia.prototype.fullText = function () {
                return this.isSkippedToken() ? this.skippedToken().fullText() : this._textOrToken;
            };

            SyntaxTrivia.prototype.isWhitespace = function () {
                return this.kind() === 4 /* WhitespaceTrivia */;
            };

            SyntaxTrivia.prototype.isComment = function () {
                return this.kind() === 7 /* SingleLineCommentTrivia */ || this.kind() === 6 /* MultiLineCommentTrivia */;
            };

            SyntaxTrivia.prototype.isNewLine = function () {
                return this.kind() === 5 /* NewLineTrivia */;
            };

            SyntaxTrivia.prototype.isSkippedToken = function () {
                return this.kind() === 8 /* SkippedTokenTrivia */;
            };

            SyntaxTrivia.prototype.skippedToken = function () {
                TypeScript.Debug.assert(this.isSkippedToken());
                return this._textOrToken;
            };

            SyntaxTrivia.prototype.collectTextElements = function (elements) {
                elements.push(this.fullText());
            };
            return SyntaxTrivia;
        })();

        function trivia(kind, text) {
            return new SyntaxTrivia(kind, text);
        }
        Syntax.trivia = trivia;

        function skippedTokenTrivia(token) {
            TypeScript.Debug.assert(!token.hasLeadingTrivia());
            TypeScript.Debug.assert(!token.hasTrailingTrivia());
            TypeScript.Debug.assert(token.fullWidth() > 0);
            return new SyntaxTrivia(8 /* SkippedTokenTrivia */, token);
        }
        Syntax.skippedTokenTrivia = skippedTokenTrivia;

        function spaces(count) {
            return trivia(4 /* WhitespaceTrivia */, TypeScript.StringUtilities.repeat(" ", count));
        }
        Syntax.spaces = spaces;

        function whitespace(text) {
            return trivia(4 /* WhitespaceTrivia */, text);
        }
        Syntax.whitespace = whitespace;

        function multiLineComment(text) {
            return trivia(6 /* MultiLineCommentTrivia */, text);
        }
        Syntax.multiLineComment = multiLineComment;

        function singleLineComment(text) {
            return trivia(7 /* SingleLineCommentTrivia */, text);
        }
        Syntax.singleLineComment = singleLineComment;

        Syntax.spaceTrivia = spaces(1);
        Syntax.lineFeedTrivia = trivia(5 /* NewLineTrivia */, "\n");
        Syntax.carriageReturnTrivia = trivia(5 /* NewLineTrivia */, "\r");
        Syntax.carriageReturnLineFeedTrivia = trivia(5 /* NewLineTrivia */, "\r\n");

        function splitMultiLineCommentTriviaIntoMultipleLines(trivia) {
            var result = [];

            var triviaText = trivia.fullText();
            var currentIndex = 0;

            for (var i = 0; i < triviaText.length; i++) {
                var ch = triviaText.charCodeAt(i);

                var isCarriageReturnLineFeed = false;
                switch (ch) {
                    case 13 /* carriageReturn */:
                        if (i < triviaText.length - 1 && triviaText.charCodeAt(i + 1) === 10 /* lineFeed */) {
                            i++;
                        }

                    case 10 /* lineFeed */:
                    case 8233 /* paragraphSeparator */:
                    case 8232 /* lineSeparator */:
                        result.push(triviaText.substring(currentIndex, i + 1));

                        currentIndex = i + 1;
                        continue;
                }
            }

            result.push(triviaText.substring(currentIndex));
            return result;
        }
        Syntax.splitMultiLineCommentTriviaIntoMultipleLines = splitMultiLineCommentTriviaIntoMultipleLines;
    })(TypeScript.Syntax || (TypeScript.Syntax = {}));
    var Syntax = TypeScript.Syntax;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Syntax) {
        Syntax.emptyTriviaList = {
            kind: function () {
                return 3 /* TriviaList */;
            },
            count: function () {
                return 0;
            },
            syntaxTriviaAt: function (index) {
                throw TypeScript.Errors.argumentOutOfRange("index");
            },
            last: function () {
                throw TypeScript.Errors.argumentOutOfRange("index");
            },
            fullWidth: function () {
                return 0;
            },
            fullText: function () {
                return "";
            },
            hasComment: function () {
                return false;
            },
            hasNewLine: function () {
                return false;
            },
            hasSkippedToken: function () {
                return false;
            },
            toJSON: function (key) {
                return [];
            },
            collectTextElements: function (elements) {
            },
            toArray: function () {
                return [];
            },
            concat: function (trivia) {
                return trivia;
            }
        };

        function concatTrivia(list1, list2) {
            if (list1.count() === 0) {
                return list2;
            }

            if (list2.count() === 0) {
                return list1;
            }

            var trivia = list1.toArray();
            trivia.push.apply(trivia, list2.toArray());

            return triviaList(trivia);
        }

        function isComment(trivia) {
            return trivia.kind() === 6 /* MultiLineCommentTrivia */ || trivia.kind() === 7 /* SingleLineCommentTrivia */;
        }

        var SingletonSyntaxTriviaList = (function () {
            function SingletonSyntaxTriviaList(item) {
                this.item = item;
            }
            SingletonSyntaxTriviaList.prototype.kind = function () {
                return 3 /* TriviaList */;
            };

            SingletonSyntaxTriviaList.prototype.count = function () {
                return 1;
            };

            SingletonSyntaxTriviaList.prototype.syntaxTriviaAt = function (index) {
                if (index !== 0) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }

                return this.item;
            };

            SingletonSyntaxTriviaList.prototype.last = function () {
                return this.item;
            };

            SingletonSyntaxTriviaList.prototype.fullWidth = function () {
                return this.item.fullWidth();
            };

            SingletonSyntaxTriviaList.prototype.fullText = function () {
                return this.item.fullText();
            };

            SingletonSyntaxTriviaList.prototype.hasComment = function () {
                return isComment(this.item);
            };

            SingletonSyntaxTriviaList.prototype.hasNewLine = function () {
                return this.item.kind() === 5 /* NewLineTrivia */;
            };

            SingletonSyntaxTriviaList.prototype.hasSkippedToken = function () {
                return this.item.kind() === 8 /* SkippedTokenTrivia */;
            };

            SingletonSyntaxTriviaList.prototype.toJSON = function (key) {
                return [this.item];
            };

            SingletonSyntaxTriviaList.prototype.collectTextElements = function (elements) {
                (this.item).collectTextElements(elements);
            };

            SingletonSyntaxTriviaList.prototype.toArray = function () {
                return [this.item];
            };

            SingletonSyntaxTriviaList.prototype.concat = function (trivia) {
                return concatTrivia(this, trivia);
            };
            return SingletonSyntaxTriviaList;
        })();

        var NormalSyntaxTriviaList = (function () {
            function NormalSyntaxTriviaList(trivia) {
                this.trivia = trivia;
            }
            NormalSyntaxTriviaList.prototype.kind = function () {
                return 3 /* TriviaList */;
            };

            NormalSyntaxTriviaList.prototype.count = function () {
                return this.trivia.length;
            };

            NormalSyntaxTriviaList.prototype.syntaxTriviaAt = function (index) {
                if (index < 0 || index >= this.trivia.length) {
                    throw TypeScript.Errors.argumentOutOfRange("index");
                }

                return this.trivia[index];
            };

            NormalSyntaxTriviaList.prototype.last = function () {
                return this.trivia[this.trivia.length - 1];
            };

            NormalSyntaxTriviaList.prototype.fullWidth = function () {
                return TypeScript.ArrayUtilities.sum(this.trivia, function (t) {
                    return t.fullWidth();
                });
            };

            NormalSyntaxTriviaList.prototype.fullText = function () {
                var result = "";

                for (var i = 0, n = this.trivia.length; i < n; i++) {
                    result += this.trivia[i].fullText();
                }

                return result;
            };

            NormalSyntaxTriviaList.prototype.hasComment = function () {
                for (var i = 0; i < this.trivia.length; i++) {
                    if (isComment(this.trivia[i])) {
                        return true;
                    }
                }

                return false;
            };

            NormalSyntaxTriviaList.prototype.hasNewLine = function () {
                for (var i = 0; i < this.trivia.length; i++) {
                    if (this.trivia[i].kind() === 5 /* NewLineTrivia */) {
                        return true;
                    }
                }

                return false;
            };

            NormalSyntaxTriviaList.prototype.hasSkippedToken = function () {
                for (var i = 0; i < this.trivia.length; i++) {
                    if (this.trivia[i].kind() === 8 /* SkippedTokenTrivia */) {
                        return true;
                    }
                }

                return false;
            };

            NormalSyntaxTriviaList.prototype.toJSON = function (key) {
                return this.trivia;
            };

            NormalSyntaxTriviaList.prototype.collectTextElements = function (elements) {
                for (var i = 0; i < this.trivia.length; i++) {
                    (this.trivia[i]).collectTextElements(elements);
                }
            };

            NormalSyntaxTriviaList.prototype.toArray = function () {
                return this.trivia.slice(0);
            };

            NormalSyntaxTriviaList.prototype.concat = function (trivia) {
                return concatTrivia(this, trivia);
            };
            return NormalSyntaxTriviaList;
        })();

        function triviaList(trivia) {
            if (trivia === undefined || trivia === null || trivia.length === 0) {
                return TypeScript.Syntax.emptyTriviaList;
            }

            if (trivia.length === 1) {
                return new SingletonSyntaxTriviaList(trivia[0]);
            }

            return new NormalSyntaxTriviaList(trivia);
        }
        Syntax.triviaList = triviaList;

        Syntax.spaceTriviaList = triviaList([TypeScript.Syntax.spaceTrivia]);
    })(TypeScript.Syntax || (TypeScript.Syntax = {}));
    var Syntax = TypeScript.Syntax;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxUtilities = (function () {
        function SyntaxUtilities() {
        }
        SyntaxUtilities.isAngleBracket = function (positionedElement) {
            var element = positionedElement.element();
            var parent = positionedElement.parentElement();
            if (parent !== null && (element.kind() === 80 /* LessThanToken */ || element.kind() === 81 /* GreaterThanToken */)) {
                switch (parent.kind()) {
                    case 227 /* TypeArgumentList */:
                    case 228 /* TypeParameterList */:
                    case 219 /* CastExpression */:
                        return true;
                }
            }

            return false;
        };

        SyntaxUtilities.getToken = function (list, kind) {
            for (var i = 0, n = list.childCount(); i < n; i++) {
                var token = list.childAt(i);
                if (token.tokenKind === kind) {
                    return token;
                }
            }

            return null;
        };

        SyntaxUtilities.containsToken = function (list, kind) {
            return SyntaxUtilities.getToken(list, kind) !== null;
        };

        SyntaxUtilities.hasExportKeyword = function (moduleElement) {
            return SyntaxUtilities.getExportKeyword(moduleElement) !== null;
        };

        SyntaxUtilities.getExportKeyword = function (moduleElement) {
            switch (moduleElement.kind()) {
                case 130 /* ModuleDeclaration */:
                case 131 /* ClassDeclaration */:
                case 129 /* FunctionDeclaration */:
                case 147 /* VariableStatement */:
                case 132 /* EnumDeclaration */:
                case 128 /* InterfaceDeclaration */:
                case 133 /* ImportDeclaration */:
                    return SyntaxUtilities.getToken((moduleElement).modifiers, 47 /* ExportKeyword */);
                default:
                    return null;
            }
        };

        SyntaxUtilities.isAmbientDeclarationSyntax = function (positionNode) {
            if (!positionNode) {
                return false;
            }

            var node = positionNode.node();
            switch (node.kind()) {
                case 130 /* ModuleDeclaration */:
                case 131 /* ClassDeclaration */:
                case 129 /* FunctionDeclaration */:
                case 147 /* VariableStatement */:
                case 132 /* EnumDeclaration */:
                    if (SyntaxUtilities.containsToken((node).modifiers, 63 /* DeclareKeyword */)) {
                        return true;
                    }

                case 133 /* ImportDeclaration */:
                case 137 /* ConstructorDeclaration */:
                case 135 /* MemberFunctionDeclaration */:
                case 138 /* GetMemberAccessorDeclaration */:
                case 139 /* SetMemberAccessorDeclaration */:
                case 136 /* MemberVariableDeclaration */:
                    if (node.isClassElement() || node.isModuleElement()) {
                        return SyntaxUtilities.isAmbientDeclarationSyntax(positionNode.containingNode());
                    }

                case 243 /* EnumElement */:
                    return SyntaxUtilities.isAmbientDeclarationSyntax(positionNode.containingNode().containingNode());

                default:
                    return SyntaxUtilities.isAmbientDeclarationSyntax(positionNode.containingNode());
            }
        };
        return SyntaxUtilities;
    })();
    TypeScript.SyntaxUtilities = SyntaxUtilities;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxVisitor = (function () {
        function SyntaxVisitor() {
        }
        SyntaxVisitor.prototype.defaultVisit = function (node) {
            return null;
        };

        SyntaxVisitor.prototype.visitToken = function (token) {
            return this.defaultVisit(token);
        };

        SyntaxVisitor.prototype.visitSourceUnit = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitExternalModuleReference = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitModuleNameModuleReference = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitImportDeclaration = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitExportAssignment = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitClassDeclaration = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitInterfaceDeclaration = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitHeritageClause = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitModuleDeclaration = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitFunctionDeclaration = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitVariableStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitVariableDeclaration = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitVariableDeclarator = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitEqualsValueClause = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitPrefixUnaryExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitArrayLiteralExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitOmittedExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitParenthesizedExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitSimpleArrowFunctionExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitParenthesizedArrowFunctionExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitQualifiedName = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitTypeArgumentList = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitConstructorType = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitFunctionType = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitObjectType = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitArrayType = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitGenericType = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitTypeQuery = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitTypeAnnotation = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitBlock = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitParameter = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitMemberAccessExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitPostfixUnaryExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitElementAccessExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitInvocationExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitArgumentList = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitBinaryExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitConditionalExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitConstructSignature = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitMethodSignature = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitIndexSignature = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitPropertySignature = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitCallSignature = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitParameterList = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitTypeParameterList = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitTypeParameter = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitConstraint = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitElseClause = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitIfStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitExpressionStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitConstructorDeclaration = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitMemberFunctionDeclaration = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitGetMemberAccessorDeclaration = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitSetMemberAccessorDeclaration = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitMemberVariableDeclaration = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitThrowStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitReturnStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitObjectCreationExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitSwitchStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitCaseSwitchClause = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitDefaultSwitchClause = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitBreakStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitContinueStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitForStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitForInStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitWhileStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitWithStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitEnumDeclaration = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitEnumElement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitCastExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitObjectLiteralExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitSimplePropertyAssignment = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitFunctionPropertyAssignment = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitGetAccessorPropertyAssignment = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitSetAccessorPropertyAssignment = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitFunctionExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitEmptyStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitTryStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitCatchClause = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitFinallyClause = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitLabeledStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitDoStatement = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitTypeOfExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitDeleteExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitVoidExpression = function (node) {
            return this.defaultVisit(node);
        };

        SyntaxVisitor.prototype.visitDebuggerStatement = function (node) {
            return this.defaultVisit(node);
        };
        return SyntaxVisitor;
    })();
    TypeScript.SyntaxVisitor = SyntaxVisitor;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxWalker = (function () {
        function SyntaxWalker() {
        }
        SyntaxWalker.prototype.visitToken = function (token) {
        };

        SyntaxWalker.prototype.visitNode = function (node) {
            node.accept(this);
        };

        SyntaxWalker.prototype.visitNodeOrToken = function (nodeOrToken) {
            if (nodeOrToken.isToken()) {
                this.visitToken(nodeOrToken);
            } else {
                this.visitNode(nodeOrToken);
            }
        };

        SyntaxWalker.prototype.visitOptionalToken = function (token) {
            if (token === null) {
                return;
            }

            this.visitToken(token);
        };

        SyntaxWalker.prototype.visitOptionalNode = function (node) {
            if (node === null) {
                return;
            }

            this.visitNode(node);
        };

        SyntaxWalker.prototype.visitOptionalNodeOrToken = function (nodeOrToken) {
            if (nodeOrToken === null) {
                return;
            }

            this.visitNodeOrToken(nodeOrToken);
        };

        SyntaxWalker.prototype.visitList = function (list) {
            for (var i = 0, n = list.childCount(); i < n; i++) {
                this.visitNodeOrToken(list.childAt(i));
            }
        };

        SyntaxWalker.prototype.visitSeparatedList = function (list) {
            for (var i = 0, n = list.childCount(); i < n; i++) {
                var item = list.childAt(i);
                this.visitNodeOrToken(item);
            }
        };

        SyntaxWalker.prototype.visitSourceUnit = function (node) {
            this.visitList(node.moduleElements);
            this.visitToken(node.endOfFileToken);
        };

        SyntaxWalker.prototype.visitExternalModuleReference = function (node) {
            this.visitToken(node.requireKeyword);
            this.visitToken(node.openParenToken);
            this.visitToken(node.stringLiteral);
            this.visitToken(node.closeParenToken);
        };

        SyntaxWalker.prototype.visitModuleNameModuleReference = function (node) {
            this.visitNodeOrToken(node.moduleName);
        };

        SyntaxWalker.prototype.visitImportDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.importKeyword);
            this.visitToken(node.identifier);
            this.visitToken(node.equalsToken);
            this.visitNode(node.moduleReference);
            this.visitToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitExportAssignment = function (node) {
            this.visitToken(node.exportKeyword);
            this.visitToken(node.equalsToken);
            this.visitToken(node.identifier);
            this.visitToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitClassDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.classKeyword);
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.typeParameterList);
            this.visitList(node.heritageClauses);
            this.visitToken(node.openBraceToken);
            this.visitList(node.classElements);
            this.visitToken(node.closeBraceToken);
        };

        SyntaxWalker.prototype.visitInterfaceDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.interfaceKeyword);
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.typeParameterList);
            this.visitList(node.heritageClauses);
            this.visitNode(node.body);
        };

        SyntaxWalker.prototype.visitHeritageClause = function (node) {
            this.visitToken(node.extendsOrImplementsKeyword);
            this.visitSeparatedList(node.typeNames);
        };

        SyntaxWalker.prototype.visitModuleDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.moduleKeyword);
            this.visitOptionalNodeOrToken(node.moduleName);
            this.visitOptionalToken(node.stringLiteral);
            this.visitToken(node.openBraceToken);
            this.visitList(node.moduleElements);
            this.visitToken(node.closeBraceToken);
        };

        SyntaxWalker.prototype.visitFunctionDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.functionKeyword);
            this.visitToken(node.identifier);
            this.visitNode(node.callSignature);
            this.visitOptionalNode(node.block);
            this.visitOptionalToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitVariableStatement = function (node) {
            this.visitList(node.modifiers);
            this.visitNode(node.variableDeclaration);
            this.visitToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitVariableDeclaration = function (node) {
            this.visitToken(node.varKeyword);
            this.visitSeparatedList(node.variableDeclarators);
        };

        SyntaxWalker.prototype.visitVariableDeclarator = function (node) {
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.typeAnnotation);
            this.visitOptionalNode(node.equalsValueClause);
        };

        SyntaxWalker.prototype.visitEqualsValueClause = function (node) {
            this.visitToken(node.equalsToken);
            this.visitNodeOrToken(node.value);
        };

        SyntaxWalker.prototype.visitPrefixUnaryExpression = function (node) {
            this.visitToken(node.operatorToken);
            this.visitNodeOrToken(node.operand);
        };

        SyntaxWalker.prototype.visitArrayLiteralExpression = function (node) {
            this.visitToken(node.openBracketToken);
            this.visitSeparatedList(node.expressions);
            this.visitToken(node.closeBracketToken);
        };

        SyntaxWalker.prototype.visitOmittedExpression = function (node) {
        };

        SyntaxWalker.prototype.visitParenthesizedExpression = function (node) {
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.closeParenToken);
        };

        SyntaxWalker.prototype.visitSimpleArrowFunctionExpression = function (node) {
            this.visitToken(node.identifier);
            this.visitToken(node.equalsGreaterThanToken);
            this.visitNodeOrToken(node.body);
        };

        SyntaxWalker.prototype.visitParenthesizedArrowFunctionExpression = function (node) {
            this.visitNode(node.callSignature);
            this.visitToken(node.equalsGreaterThanToken);
            this.visitNodeOrToken(node.body);
        };

        SyntaxWalker.prototype.visitQualifiedName = function (node) {
            this.visitNodeOrToken(node.left);
            this.visitToken(node.dotToken);
            this.visitToken(node.right);
        };

        SyntaxWalker.prototype.visitTypeArgumentList = function (node) {
            this.visitToken(node.lessThanToken);
            this.visitSeparatedList(node.typeArguments);
            this.visitToken(node.greaterThanToken);
        };

        SyntaxWalker.prototype.visitConstructorType = function (node) {
            this.visitToken(node.newKeyword);
            this.visitOptionalNode(node.typeParameterList);
            this.visitNode(node.parameterList);
            this.visitToken(node.equalsGreaterThanToken);
            this.visitNodeOrToken(node.type);
        };

        SyntaxWalker.prototype.visitFunctionType = function (node) {
            this.visitOptionalNode(node.typeParameterList);
            this.visitNode(node.parameterList);
            this.visitToken(node.equalsGreaterThanToken);
            this.visitNodeOrToken(node.type);
        };

        SyntaxWalker.prototype.visitObjectType = function (node) {
            this.visitToken(node.openBraceToken);
            this.visitSeparatedList(node.typeMembers);
            this.visitToken(node.closeBraceToken);
        };

        SyntaxWalker.prototype.visitArrayType = function (node) {
            this.visitNodeOrToken(node.type);
            this.visitToken(node.openBracketToken);
            this.visitToken(node.closeBracketToken);
        };

        SyntaxWalker.prototype.visitGenericType = function (node) {
            this.visitNodeOrToken(node.name);
            this.visitNode(node.typeArgumentList);
        };

        SyntaxWalker.prototype.visitTypeQuery = function (node) {
            this.visitToken(node.typeOfKeyword);
            this.visitNodeOrToken(node.name);
        };

        SyntaxWalker.prototype.visitTypeAnnotation = function (node) {
            this.visitToken(node.colonToken);
            this.visitNodeOrToken(node.type);
        };

        SyntaxWalker.prototype.visitBlock = function (node) {
            this.visitToken(node.openBraceToken);
            this.visitList(node.statements);
            this.visitToken(node.closeBraceToken);
        };

        SyntaxWalker.prototype.visitParameter = function (node) {
            this.visitOptionalToken(node.dotDotDotToken);
            this.visitOptionalToken(node.publicOrPrivateKeyword);
            this.visitToken(node.identifier);
            this.visitOptionalToken(node.questionToken);
            this.visitOptionalNode(node.typeAnnotation);
            this.visitOptionalNode(node.equalsValueClause);
        };

        SyntaxWalker.prototype.visitMemberAccessExpression = function (node) {
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.dotToken);
            this.visitToken(node.name);
        };

        SyntaxWalker.prototype.visitPostfixUnaryExpression = function (node) {
            this.visitNodeOrToken(node.operand);
            this.visitToken(node.operatorToken);
        };

        SyntaxWalker.prototype.visitElementAccessExpression = function (node) {
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.openBracketToken);
            this.visitNodeOrToken(node.argumentExpression);
            this.visitToken(node.closeBracketToken);
        };

        SyntaxWalker.prototype.visitInvocationExpression = function (node) {
            this.visitNodeOrToken(node.expression);
            this.visitNode(node.argumentList);
        };

        SyntaxWalker.prototype.visitArgumentList = function (node) {
            this.visitOptionalNode(node.typeArgumentList);
            this.visitToken(node.openParenToken);
            this.visitSeparatedList(node.arguments);
            this.visitToken(node.closeParenToken);
        };

        SyntaxWalker.prototype.visitBinaryExpression = function (node) {
            this.visitNodeOrToken(node.left);
            this.visitToken(node.operatorToken);
            this.visitNodeOrToken(node.right);
        };

        SyntaxWalker.prototype.visitConditionalExpression = function (node) {
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.questionToken);
            this.visitNodeOrToken(node.whenTrue);
            this.visitToken(node.colonToken);
            this.visitNodeOrToken(node.whenFalse);
        };

        SyntaxWalker.prototype.visitConstructSignature = function (node) {
            this.visitToken(node.newKeyword);
            this.visitNode(node.callSignature);
        };

        SyntaxWalker.prototype.visitMethodSignature = function (node) {
            this.visitToken(node.propertyName);
            this.visitOptionalToken(node.questionToken);
            this.visitNode(node.callSignature);
        };

        SyntaxWalker.prototype.visitIndexSignature = function (node) {
            this.visitToken(node.openBracketToken);
            this.visitNode(node.parameter);
            this.visitToken(node.closeBracketToken);
            this.visitOptionalNode(node.typeAnnotation);
        };

        SyntaxWalker.prototype.visitPropertySignature = function (node) {
            this.visitToken(node.propertyName);
            this.visitOptionalToken(node.questionToken);
            this.visitOptionalNode(node.typeAnnotation);
        };

        SyntaxWalker.prototype.visitCallSignature = function (node) {
            this.visitOptionalNode(node.typeParameterList);
            this.visitNode(node.parameterList);
            this.visitOptionalNode(node.typeAnnotation);
        };

        SyntaxWalker.prototype.visitParameterList = function (node) {
            this.visitToken(node.openParenToken);
            this.visitSeparatedList(node.parameters);
            this.visitToken(node.closeParenToken);
        };

        SyntaxWalker.prototype.visitTypeParameterList = function (node) {
            this.visitToken(node.lessThanToken);
            this.visitSeparatedList(node.typeParameters);
            this.visitToken(node.greaterThanToken);
        };

        SyntaxWalker.prototype.visitTypeParameter = function (node) {
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.constraint);
        };

        SyntaxWalker.prototype.visitConstraint = function (node) {
            this.visitToken(node.extendsKeyword);
            this.visitNodeOrToken(node.type);
        };

        SyntaxWalker.prototype.visitElseClause = function (node) {
            this.visitToken(node.elseKeyword);
            this.visitNodeOrToken(node.statement);
        };

        SyntaxWalker.prototype.visitIfStatement = function (node) {
            this.visitToken(node.ifKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
            this.visitOptionalNode(node.elseClause);
        };

        SyntaxWalker.prototype.visitExpressionStatement = function (node) {
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitConstructorDeclaration = function (node) {
            this.visitToken(node.constructorKeyword);
            this.visitNode(node.parameterList);
            this.visitOptionalNode(node.block);
            this.visitOptionalToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitMemberFunctionDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.propertyName);
            this.visitNode(node.callSignature);
            this.visitOptionalNode(node.block);
            this.visitOptionalToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitGetMemberAccessorDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.getKeyword);
            this.visitToken(node.propertyName);
            this.visitNode(node.parameterList);
            this.visitOptionalNode(node.typeAnnotation);
            this.visitNode(node.block);
        };

        SyntaxWalker.prototype.visitSetMemberAccessorDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.setKeyword);
            this.visitToken(node.propertyName);
            this.visitNode(node.parameterList);
            this.visitNode(node.block);
        };

        SyntaxWalker.prototype.visitMemberVariableDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitNode(node.variableDeclarator);
            this.visitToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitThrowStatement = function (node) {
            this.visitToken(node.throwKeyword);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitReturnStatement = function (node) {
            this.visitToken(node.returnKeyword);
            this.visitOptionalNodeOrToken(node.expression);
            this.visitToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitObjectCreationExpression = function (node) {
            this.visitToken(node.newKeyword);
            this.visitNodeOrToken(node.expression);
            this.visitOptionalNode(node.argumentList);
        };

        SyntaxWalker.prototype.visitSwitchStatement = function (node) {
            this.visitToken(node.switchKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.closeParenToken);
            this.visitToken(node.openBraceToken);
            this.visitList(node.switchClauses);
            this.visitToken(node.closeBraceToken);
        };

        SyntaxWalker.prototype.visitCaseSwitchClause = function (node) {
            this.visitToken(node.caseKeyword);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.colonToken);
            this.visitList(node.statements);
        };

        SyntaxWalker.prototype.visitDefaultSwitchClause = function (node) {
            this.visitToken(node.defaultKeyword);
            this.visitToken(node.colonToken);
            this.visitList(node.statements);
        };

        SyntaxWalker.prototype.visitBreakStatement = function (node) {
            this.visitToken(node.breakKeyword);
            this.visitOptionalToken(node.identifier);
            this.visitToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitContinueStatement = function (node) {
            this.visitToken(node.continueKeyword);
            this.visitOptionalToken(node.identifier);
            this.visitToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitForStatement = function (node) {
            this.visitToken(node.forKeyword);
            this.visitToken(node.openParenToken);
            this.visitOptionalNode(node.variableDeclaration);
            this.visitOptionalNodeOrToken(node.initializer);
            this.visitToken(node.firstSemicolonToken);
            this.visitOptionalNodeOrToken(node.condition);
            this.visitToken(node.secondSemicolonToken);
            this.visitOptionalNodeOrToken(node.incrementor);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
        };

        SyntaxWalker.prototype.visitForInStatement = function (node) {
            this.visitToken(node.forKeyword);
            this.visitToken(node.openParenToken);
            this.visitOptionalNode(node.variableDeclaration);
            this.visitOptionalNodeOrToken(node.left);
            this.visitToken(node.inKeyword);
            this.visitNodeOrToken(node.expression);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
        };

        SyntaxWalker.prototype.visitWhileStatement = function (node) {
            this.visitToken(node.whileKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
        };

        SyntaxWalker.prototype.visitWithStatement = function (node) {
            this.visitToken(node.withKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.closeParenToken);
            this.visitNodeOrToken(node.statement);
        };

        SyntaxWalker.prototype.visitEnumDeclaration = function (node) {
            this.visitList(node.modifiers);
            this.visitToken(node.enumKeyword);
            this.visitToken(node.identifier);
            this.visitToken(node.openBraceToken);
            this.visitSeparatedList(node.enumElements);
            this.visitToken(node.closeBraceToken);
        };

        SyntaxWalker.prototype.visitEnumElement = function (node) {
            this.visitToken(node.propertyName);
            this.visitOptionalNode(node.equalsValueClause);
        };

        SyntaxWalker.prototype.visitCastExpression = function (node) {
            this.visitToken(node.lessThanToken);
            this.visitNodeOrToken(node.type);
            this.visitToken(node.greaterThanToken);
            this.visitNodeOrToken(node.expression);
        };

        SyntaxWalker.prototype.visitObjectLiteralExpression = function (node) {
            this.visitToken(node.openBraceToken);
            this.visitSeparatedList(node.propertyAssignments);
            this.visitToken(node.closeBraceToken);
        };

        SyntaxWalker.prototype.visitSimplePropertyAssignment = function (node) {
            this.visitToken(node.propertyName);
            this.visitToken(node.colonToken);
            this.visitNodeOrToken(node.expression);
        };

        SyntaxWalker.prototype.visitFunctionPropertyAssignment = function (node) {
            this.visitToken(node.propertyName);
            this.visitNode(node.callSignature);
            this.visitNode(node.block);
        };

        SyntaxWalker.prototype.visitGetAccessorPropertyAssignment = function (node) {
            this.visitToken(node.getKeyword);
            this.visitToken(node.propertyName);
            this.visitToken(node.openParenToken);
            this.visitToken(node.closeParenToken);
            this.visitOptionalNode(node.typeAnnotation);
            this.visitNode(node.block);
        };

        SyntaxWalker.prototype.visitSetAccessorPropertyAssignment = function (node) {
            this.visitToken(node.setKeyword);
            this.visitToken(node.propertyName);
            this.visitToken(node.openParenToken);
            this.visitNode(node.parameter);
            this.visitToken(node.closeParenToken);
            this.visitNode(node.block);
        };

        SyntaxWalker.prototype.visitFunctionExpression = function (node) {
            this.visitToken(node.functionKeyword);
            this.visitOptionalToken(node.identifier);
            this.visitNode(node.callSignature);
            this.visitNode(node.block);
        };

        SyntaxWalker.prototype.visitEmptyStatement = function (node) {
            this.visitToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitTryStatement = function (node) {
            this.visitToken(node.tryKeyword);
            this.visitNode(node.block);
            this.visitOptionalNode(node.catchClause);
            this.visitOptionalNode(node.finallyClause);
        };

        SyntaxWalker.prototype.visitCatchClause = function (node) {
            this.visitToken(node.catchKeyword);
            this.visitToken(node.openParenToken);
            this.visitToken(node.identifier);
            this.visitOptionalNode(node.typeAnnotation);
            this.visitToken(node.closeParenToken);
            this.visitNode(node.block);
        };

        SyntaxWalker.prototype.visitFinallyClause = function (node) {
            this.visitToken(node.finallyKeyword);
            this.visitNode(node.block);
        };

        SyntaxWalker.prototype.visitLabeledStatement = function (node) {
            this.visitToken(node.identifier);
            this.visitToken(node.colonToken);
            this.visitNodeOrToken(node.statement);
        };

        SyntaxWalker.prototype.visitDoStatement = function (node) {
            this.visitToken(node.doKeyword);
            this.visitNodeOrToken(node.statement);
            this.visitToken(node.whileKeyword);
            this.visitToken(node.openParenToken);
            this.visitNodeOrToken(node.condition);
            this.visitToken(node.closeParenToken);
            this.visitToken(node.semicolonToken);
        };

        SyntaxWalker.prototype.visitTypeOfExpression = function (node) {
            this.visitToken(node.typeOfKeyword);
            this.visitNodeOrToken(node.expression);
        };

        SyntaxWalker.prototype.visitDeleteExpression = function (node) {
            this.visitToken(node.deleteKeyword);
            this.visitNodeOrToken(node.expression);
        };

        SyntaxWalker.prototype.visitVoidExpression = function (node) {
            this.visitToken(node.voidKeyword);
            this.visitNodeOrToken(node.expression);
        };

        SyntaxWalker.prototype.visitDebuggerStatement = function (node) {
            this.visitToken(node.debuggerKeyword);
            this.visitToken(node.semicolonToken);
        };
        return SyntaxWalker;
    })();
    TypeScript.SyntaxWalker = SyntaxWalker;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var PositionTrackingWalker = (function (_super) {
        __extends(PositionTrackingWalker, _super);
        function PositionTrackingWalker() {
            _super.apply(this, arguments);
            this._position = 0;
        }
        PositionTrackingWalker.prototype.visitToken = function (token) {
            this._position += token.fullWidth();
        };

        PositionTrackingWalker.prototype.position = function () {
            return this._position;
        };

        PositionTrackingWalker.prototype.skip = function (element) {
            this._position += element.fullWidth();
        };
        return PositionTrackingWalker;
    })(TypeScript.SyntaxWalker);
    TypeScript.PositionTrackingWalker = PositionTrackingWalker;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxInformationMap = (function (_super) {
        __extends(SyntaxInformationMap, _super);
        function SyntaxInformationMap(trackParents, trackPreviousToken) {
            _super.call(this);
            this.trackParents = trackParents;
            this.trackPreviousToken = trackPreviousToken;
            this.tokenToInformation = TypeScript.Collections.createHashTable(TypeScript.Collections.DefaultHashTableCapacity, TypeScript.Collections.identityHashCode);
            this.elementToPosition = TypeScript.Collections.createHashTable(TypeScript.Collections.DefaultHashTableCapacity, TypeScript.Collections.identityHashCode);
            this._previousToken = null;
            this._previousTokenInformation = null;
            this._currentPosition = 0;
            this._elementToParent = TypeScript.Collections.createHashTable(TypeScript.Collections.DefaultHashTableCapacity, TypeScript.Collections.identityHashCode);
            this._parentStack = [];
            this._parentStack.push(null);
        }
        SyntaxInformationMap.create = function (node, trackParents, trackPreviousToken) {
            var map = new SyntaxInformationMap(trackParents, trackPreviousToken);
            map.visitNode(node);
            return map;
        };

        SyntaxInformationMap.prototype.visitNode = function (node) {
            this.trackParents && this._elementToParent.add(node, TypeScript.ArrayUtilities.last(this._parentStack));
            this.elementToPosition.add(node, this._currentPosition);

            this.trackParents && this._parentStack.push(node);
            _super.prototype.visitNode.call(this, node);
            this.trackParents && this._parentStack.pop();
        };

        SyntaxInformationMap.prototype.visitToken = function (token) {
            this.trackParents && this._elementToParent.add(token, TypeScript.ArrayUtilities.last(this._parentStack));

            if (this.trackPreviousToken) {
                var tokenInformation = {
                    previousToken: this._previousToken,
                    nextToken: null
                };

                if (this._previousTokenInformation !== null) {
                    this._previousTokenInformation.nextToken = token;
                }

                this._previousToken = token;
                this._previousTokenInformation = tokenInformation;

                this.tokenToInformation.add(token, tokenInformation);
            }

            this.elementToPosition.add(token, this._currentPosition);
            this._currentPosition += token.fullWidth();
        };

        SyntaxInformationMap.prototype.parent = function (element) {
            return this._elementToParent.get(element);
        };

        SyntaxInformationMap.prototype.fullStart = function (element) {
            return this.elementToPosition.get(element);
        };

        SyntaxInformationMap.prototype.start = function (element) {
            return this.fullStart(element) + element.leadingTriviaWidth();
        };

        SyntaxInformationMap.prototype.end = function (element) {
            return this.start(element) + element.width();
        };

        SyntaxInformationMap.prototype.previousToken = function (token) {
            return this.tokenInformation(token).previousToken;
        };

        SyntaxInformationMap.prototype.tokenInformation = function (token) {
            return this.tokenToInformation.get(token);
        };

        SyntaxInformationMap.prototype.firstTokenInLineContainingToken = function (token) {
            var current = token;
            while (true) {
                var information = this.tokenInformation(current);
                if (this.isFirstTokenInLineWorker(information)) {
                    break;
                }

                current = information.previousToken;
            }

            return current;
        };

        SyntaxInformationMap.prototype.isFirstTokenInLine = function (token) {
            var information = this.tokenInformation(token);
            return this.isFirstTokenInLineWorker(information);
        };

        SyntaxInformationMap.prototype.isFirstTokenInLineWorker = function (information) {
            return information.previousToken === null || information.previousToken.hasTrailingNewLine();
        };
        return SyntaxInformationMap;
    })(TypeScript.SyntaxWalker);
    TypeScript.SyntaxInformationMap = SyntaxInformationMap;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxNodeInvariantsChecker = (function (_super) {
        __extends(SyntaxNodeInvariantsChecker, _super);
        function SyntaxNodeInvariantsChecker() {
            _super.apply(this, arguments);
            this.tokenTable = TypeScript.Collections.createHashTable(TypeScript.Collections.DefaultHashTableCapacity, TypeScript.Collections.identityHashCode);
        }
        SyntaxNodeInvariantsChecker.checkInvariants = function (node) {
            node.accept(new SyntaxNodeInvariantsChecker());
        };

        SyntaxNodeInvariantsChecker.prototype.visitToken = function (token) {
            this.tokenTable.add(token, token);
        };
        return SyntaxNodeInvariantsChecker;
    })(TypeScript.SyntaxWalker);
    TypeScript.SyntaxNodeInvariantsChecker = SyntaxNodeInvariantsChecker;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var DepthLimitedWalker = (function (_super) {
        __extends(DepthLimitedWalker, _super);
        function DepthLimitedWalker(maximumDepth) {
            _super.call(this);
            this._depth = 0;
            this._maximumDepth = 0;
            this._maximumDepth = maximumDepth;
        }
        DepthLimitedWalker.prototype.visitNode = function (node) {
            if (this._depth < this._maximumDepth) {
                this._depth++;
                _super.prototype.visitNode.call(this, node);
                this._depth--;
            } else {
                this.skip(node);
            }
        };
        return DepthLimitedWalker;
    })(TypeScript.PositionTrackingWalker);
    TypeScript.DepthLimitedWalker = DepthLimitedWalker;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (Parser) {
        var ExpressionPrecedence;
        (function (ExpressionPrecedence) {
            ExpressionPrecedence[ExpressionPrecedence["CommaExpressionPrecedence"] = 1] = "CommaExpressionPrecedence";

            ExpressionPrecedence[ExpressionPrecedence["AssignmentExpressionPrecedence"] = 2] = "AssignmentExpressionPrecedence";

            ExpressionPrecedence[ExpressionPrecedence["ConditionalExpressionPrecedence"] = 3] = "ConditionalExpressionPrecedence";

            ExpressionPrecedence[ExpressionPrecedence["ArrowFunctionPrecedence"] = 4] = "ArrowFunctionPrecedence";

            ExpressionPrecedence[ExpressionPrecedence["LogicalOrExpressionPrecedence"] = 5] = "LogicalOrExpressionPrecedence";
            ExpressionPrecedence[ExpressionPrecedence["LogicalAndExpressionPrecedence"] = 6] = "LogicalAndExpressionPrecedence";
            ExpressionPrecedence[ExpressionPrecedence["BitwiseOrExpressionPrecedence"] = 7] = "BitwiseOrExpressionPrecedence";
            ExpressionPrecedence[ExpressionPrecedence["BitwiseExclusiveOrExpressionPrecedence"] = 8] = "BitwiseExclusiveOrExpressionPrecedence";
            ExpressionPrecedence[ExpressionPrecedence["BitwiseAndExpressionPrecedence"] = 9] = "BitwiseAndExpressionPrecedence";
            ExpressionPrecedence[ExpressionPrecedence["EqualityExpressionPrecedence"] = 10] = "EqualityExpressionPrecedence";
            ExpressionPrecedence[ExpressionPrecedence["RelationalExpressionPrecedence"] = 11] = "RelationalExpressionPrecedence";
            ExpressionPrecedence[ExpressionPrecedence["ShiftExpressionPrecdence"] = 12] = "ShiftExpressionPrecdence";
            ExpressionPrecedence[ExpressionPrecedence["AdditiveExpressionPrecedence"] = 13] = "AdditiveExpressionPrecedence";
            ExpressionPrecedence[ExpressionPrecedence["MultiplicativeExpressionPrecedence"] = 14] = "MultiplicativeExpressionPrecedence";

            ExpressionPrecedence[ExpressionPrecedence["UnaryExpressionPrecedence"] = 15] = "UnaryExpressionPrecedence";
        })(ExpressionPrecedence || (ExpressionPrecedence = {}));

        var ListParsingState;
        (function (ListParsingState) {
            ListParsingState[ListParsingState["SourceUnit_ModuleElements"] = 1 << 0] = "SourceUnit_ModuleElements";
            ListParsingState[ListParsingState["ClassDeclaration_ClassElements"] = 1 << 1] = "ClassDeclaration_ClassElements";
            ListParsingState[ListParsingState["ModuleDeclaration_ModuleElements"] = 1 << 2] = "ModuleDeclaration_ModuleElements";
            ListParsingState[ListParsingState["SwitchStatement_SwitchClauses"] = 1 << 3] = "SwitchStatement_SwitchClauses";
            ListParsingState[ListParsingState["SwitchClause_Statements"] = 1 << 4] = "SwitchClause_Statements";
            ListParsingState[ListParsingState["Block_Statements"] = 1 << 5] = "Block_Statements";
            ListParsingState[ListParsingState["TryBlock_Statements"] = 1 << 6] = "TryBlock_Statements";
            ListParsingState[ListParsingState["CatchBlock_Statements"] = 1 << 7] = "CatchBlock_Statements";
            ListParsingState[ListParsingState["EnumDeclaration_EnumElements"] = 1 << 8] = "EnumDeclaration_EnumElements";
            ListParsingState[ListParsingState["ObjectType_TypeMembers"] = 1 << 9] = "ObjectType_TypeMembers";
            ListParsingState[ListParsingState["ClassOrInterfaceDeclaration_HeritageClauses"] = 1 << 10] = "ClassOrInterfaceDeclaration_HeritageClauses";
            ListParsingState[ListParsingState["HeritageClause_TypeNameList"] = 1 << 11] = "HeritageClause_TypeNameList";
            ListParsingState[ListParsingState["VariableDeclaration_VariableDeclarators_AllowIn"] = 1 << 12] = "VariableDeclaration_VariableDeclarators_AllowIn";
            ListParsingState[ListParsingState["VariableDeclaration_VariableDeclarators_DisallowIn"] = 1 << 13] = "VariableDeclaration_VariableDeclarators_DisallowIn";
            ListParsingState[ListParsingState["ArgumentList_AssignmentExpressions"] = 1 << 14] = "ArgumentList_AssignmentExpressions";
            ListParsingState[ListParsingState["ObjectLiteralExpression_PropertyAssignments"] = 1 << 15] = "ObjectLiteralExpression_PropertyAssignments";
            ListParsingState[ListParsingState["ArrayLiteralExpression_AssignmentExpressions"] = 1 << 16] = "ArrayLiteralExpression_AssignmentExpressions";
            ListParsingState[ListParsingState["ParameterList_Parameters"] = 1 << 17] = "ParameterList_Parameters";
            ListParsingState[ListParsingState["TypeArgumentList_Types"] = 1 << 18] = "TypeArgumentList_Types";
            ListParsingState[ListParsingState["TypeParameterList_TypeParameters"] = 1 << 19] = "TypeParameterList_TypeParameters";

            ListParsingState[ListParsingState["FirstListParsingState"] = ListParsingState.SourceUnit_ModuleElements] = "FirstListParsingState";
            ListParsingState[ListParsingState["LastListParsingState"] = ListParsingState.TypeArgumentList_Types] = "LastListParsingState";
        })(ListParsingState || (ListParsingState = {}));

        var SyntaxCursor = (function () {
            function SyntaxCursor(sourceUnit) {
                this._elements = [];
                this._index = 0;
                this._pinCount = 0;
                sourceUnit.insertChildrenInto(this._elements, 0);
            }
            SyntaxCursor.prototype.isFinished = function () {
                return this._index === this._elements.length;
            };

            SyntaxCursor.prototype.currentElement = function () {
                if (this.isFinished()) {
                    return null;
                }

                return this._elements[this._index];
            };

            SyntaxCursor.prototype.currentNode = function () {
                var element = this.currentElement();
                return element !== null && element.isNode() ? element : null;
            };

            SyntaxCursor.prototype.moveToFirstChild = function () {
                if (this.isFinished()) {
                    return;
                }

                var element = this._elements[this._index];
                if (element.isToken()) {
                    return;
                }

                var node = element;

                this._elements.splice(this._index, 1);

                node.insertChildrenInto(this._elements, this._index);
            };

            SyntaxCursor.prototype.moveToNextSibling = function () {
                if (this.isFinished()) {
                    return;
                }

                if (this._pinCount > 0) {
                    this._index++;
                    return;
                }

                this._elements.shift();
            };

            SyntaxCursor.prototype.getAndPinCursorIndex = function () {
                this._pinCount++;
                return this._index;
            };

            SyntaxCursor.prototype.releaseAndUnpinCursorIndex = function (index) {
                this._pinCount--;
                if (this._pinCount === 0) {
                }
            };

            SyntaxCursor.prototype.rewindToPinnedCursorIndex = function (index) {
                this._index = index;
            };

            SyntaxCursor.prototype.pinCount = function () {
                return this._pinCount;
            };

            SyntaxCursor.prototype.moveToFirstToken = function () {
                var element;

                while (!this.isFinished()) {
                    element = this.currentElement();
                    if (element.isNode()) {
                        this.moveToFirstChild();
                        continue;
                    }

                    return;
                }
            };

            SyntaxCursor.prototype.currentToken = function () {
                this.moveToFirstToken();
                if (this.isFinished()) {
                    return null;
                }

                var element = this.currentElement();

                return element;
            };

            SyntaxCursor.prototype.peekToken = function (n) {
                this.moveToFirstToken();
                var pin = this.getAndPinCursorIndex();
                try  {
                    for (var i = 0; i < n; i++) {
                        this.moveToNextSibling();
                        this.moveToFirstToken();
                    }

                    return this.currentToken();
                } finally {
                    this.rewindToPinnedCursorIndex(pin);
                    this.releaseAndUnpinCursorIndex(pin);
                }
            };
            return SyntaxCursor;
        })();

        var NormalParserSource = (function () {
            function NormalParserSource(fileName, text, languageVersion) {
                this._previousToken = null;
                this._absolutePosition = 0;
                this._tokenDiagnostics = [];
                this.rewindPointPool = [];
                this.rewindPointPoolCount = 0;
                this.slidingWindow = new TypeScript.SlidingWindow(this, TypeScript.ArrayUtilities.createArray(32, null), null);
                this.scanner = new TypeScript.Scanner(fileName, text, languageVersion);
            }
            NormalParserSource.prototype.currentNode = function () {
                return null;
            };

            NormalParserSource.prototype.moveToNextNode = function () {
                throw TypeScript.Errors.invalidOperation();
            };

            NormalParserSource.prototype.absolutePosition = function () {
                return this._absolutePosition;
            };

            NormalParserSource.prototype.previousToken = function () {
                return this._previousToken;
            };

            NormalParserSource.prototype.tokenDiagnostics = function () {
                return this._tokenDiagnostics;
            };

            NormalParserSource.prototype.getOrCreateRewindPoint = function () {
                if (this.rewindPointPoolCount === 0) {
                    return {};
                }

                this.rewindPointPoolCount--;
                var result = this.rewindPointPool[this.rewindPointPoolCount];
                this.rewindPointPool[this.rewindPointPoolCount] = null;
                return result;
            };

            NormalParserSource.prototype.getRewindPoint = function () {
                var slidingWindowIndex = this.slidingWindow.getAndPinAbsoluteIndex();

                var rewindPoint = this.getOrCreateRewindPoint();

                rewindPoint.slidingWindowIndex = slidingWindowIndex;
                rewindPoint.previousToken = this._previousToken;
                rewindPoint.absolutePosition = this._absolutePosition;

                rewindPoint.pinCount = this.slidingWindow.pinCount();

                return rewindPoint;
            };

            NormalParserSource.prototype.isPinned = function () {
                return this.slidingWindow.pinCount() > 0;
            };

            NormalParserSource.prototype.rewind = function (rewindPoint) {
                this.slidingWindow.rewindToPinnedIndex(rewindPoint.slidingWindowIndex);

                this._previousToken = rewindPoint.previousToken;
                this._absolutePosition = rewindPoint.absolutePosition;
            };

            NormalParserSource.prototype.releaseRewindPoint = function (rewindPoint) {
                this.slidingWindow.releaseAndUnpinAbsoluteIndex((rewindPoint).absoluteIndex);

                this.rewindPointPool[this.rewindPointPoolCount] = rewindPoint;
                this.rewindPointPoolCount++;
            };

            NormalParserSource.prototype.fetchMoreItems = function (allowRegularExpression, sourceIndex, window, destinationIndex, spaceAvailable) {
                window[destinationIndex] = this.scanner.scan(this._tokenDiagnostics, allowRegularExpression);
                return 1;
            };

            NormalParserSource.prototype.peekToken = function (n) {
                return this.slidingWindow.peekItemN(n);
            };

            NormalParserSource.prototype.moveToNextToken = function () {
                var currentToken = this.currentToken();
                this._absolutePosition += currentToken.fullWidth();
                this._previousToken = currentToken;

                this.slidingWindow.moveToNextItem();
            };

            NormalParserSource.prototype.currentToken = function () {
                return this.slidingWindow.currentItem(false);
            };

            NormalParserSource.prototype.removeDiagnosticsOnOrAfterPosition = function (position) {
                var tokenDiagnosticsLength = this._tokenDiagnostics.length;
                while (tokenDiagnosticsLength > 0) {
                    var diagnostic = this._tokenDiagnostics[tokenDiagnosticsLength - 1];
                    if (diagnostic.start() >= position) {
                        tokenDiagnosticsLength--;
                    } else {
                        break;
                    }
                }

                this._tokenDiagnostics.length = tokenDiagnosticsLength;
            };

            NormalParserSource.prototype.resetToPosition = function (absolutePosition, previousToken) {
                this._absolutePosition = absolutePosition;
                this._previousToken = previousToken;

                this.removeDiagnosticsOnOrAfterPosition(absolutePosition);

                this.slidingWindow.disgardAllItemsFromCurrentIndexOnwards();

                this.scanner.setAbsoluteIndex(absolutePosition);
            };

            NormalParserSource.prototype.currentTokenAllowingRegularExpression = function () {
                this.resetToPosition(this._absolutePosition, this._previousToken);

                var token = this.slidingWindow.currentItem(true);

                return token;
            };
            return NormalParserSource;
        })();

        var IncrementalParserSource = (function () {
            function IncrementalParserSource(oldSyntaxTree, textChangeRange, newText) {
                this._changeDelta = 0;
                var oldSourceUnit = oldSyntaxTree.sourceUnit();
                this._oldSourceUnitCursor = new SyntaxCursor(oldSourceUnit);

                this._changeRange = IncrementalParserSource.extendToAffectedRange(textChangeRange, oldSourceUnit);

                this._normalParserSource = new NormalParserSource(oldSyntaxTree.fileName(), newText, oldSyntaxTree.parseOptions().languageVersion());
            }
            IncrementalParserSource.extendToAffectedRange = function (changeRange, sourceUnit) {
                var maxLookahead = 1;

                var start = changeRange.span().start();

                for (var i = 0; start > 0 && i <= maxLookahead; i++) {
                    var token = sourceUnit.findToken(start);

                    var position = token.fullStart();

                    start = TypeScript.MathPrototype.max(0, position - 1);
                }

                var finalSpan = TypeScript.TextSpan.fromBounds(start, changeRange.span().end());
                var finalLength = changeRange.newLength() + (changeRange.span().start() - start);

                return new TypeScript.TextChangeRange(finalSpan, finalLength);
            };

            IncrementalParserSource.prototype.absolutePosition = function () {
                return this._normalParserSource.absolutePosition();
            };

            IncrementalParserSource.prototype.previousToken = function () {
                return this._normalParserSource.previousToken();
            };

            IncrementalParserSource.prototype.tokenDiagnostics = function () {
                return this._normalParserSource.tokenDiagnostics();
            };

            IncrementalParserSource.prototype.getRewindPoint = function () {
                var rewindPoint = this._normalParserSource.getRewindPoint();
                var oldSourceUnitCursorIndex = this._oldSourceUnitCursor.getAndPinCursorIndex();

                rewindPoint.changeDelta = this._changeDelta;
                rewindPoint.changeRange = this._changeRange;
                rewindPoint.oldSourceUnitCursorIndex = oldSourceUnitCursorIndex;

                return rewindPoint;
            };

            IncrementalParserSource.prototype.rewind = function (rewindPoint) {
                this._changeRange = rewindPoint.changeRange;
                this._changeDelta = rewindPoint.changeDelta;
                this._oldSourceUnitCursor.rewindToPinnedCursorIndex(rewindPoint.oldSourceUnitCursorIndex);

                this._normalParserSource.rewind(rewindPoint);
            };

            IncrementalParserSource.prototype.releaseRewindPoint = function (rewindPoint) {
                this._oldSourceUnitCursor.releaseAndUnpinCursorIndex(rewindPoint.oldSourceUnitCursorIndex);
                this._normalParserSource.releaseRewindPoint(rewindPoint);
            };

            IncrementalParserSource.prototype.canReadFromOldSourceUnit = function () {
                if (this._normalParserSource.isPinned()) {
                    return false;
                }

                if (this._changeRange !== null && this._changeRange.newSpan().intersectsWithPosition(this.absolutePosition())) {
                    return false;
                }

                this.syncCursorToNewTextIfBehind();

                return this._changeDelta === 0 && !this._oldSourceUnitCursor.isFinished();
            };

            IncrementalParserSource.prototype.currentNode = function () {
                if (this.canReadFromOldSourceUnit()) {
                    return this.tryGetNodeFromOldSourceUnit();
                }

                return null;
            };

            IncrementalParserSource.prototype.currentToken = function () {
                if (this.canReadFromOldSourceUnit()) {
                    var token = this.tryGetTokenFromOldSourceUnit();
                    if (token !== null) {
                        return token;
                    }
                }

                return this._normalParserSource.currentToken();
            };

            IncrementalParserSource.prototype.currentTokenAllowingRegularExpression = function () {
                return this._normalParserSource.currentTokenAllowingRegularExpression();
            };

            IncrementalParserSource.prototype.syncCursorToNewTextIfBehind = function () {
                while (true) {
                    if (this._oldSourceUnitCursor.isFinished()) {
                        break;
                    }

                    if (this._changeDelta >= 0) {
                        break;
                    }

                    var currentElement = this._oldSourceUnitCursor.currentElement();

                    if (currentElement.isNode() && (currentElement.fullWidth() > Math.abs(this._changeDelta))) {
                        this._oldSourceUnitCursor.moveToFirstChild();
                    } else {
                        this._oldSourceUnitCursor.moveToNextSibling();

                        this._changeDelta += currentElement.fullWidth();
                    }
                }
            };

            IncrementalParserSource.prototype.intersectsWithChangeRangeSpanInOriginalText = function (start, length) {
                return this._changeRange !== null && this._changeRange.span().intersectsWith(start, length);
            };

            IncrementalParserSource.prototype.tryGetNodeFromOldSourceUnit = function () {
                while (true) {
                    var node = this._oldSourceUnitCursor.currentNode();
                    if (node === null) {
                        return null;
                    }

                    if (!this.intersectsWithChangeRangeSpanInOriginalText(this.absolutePosition(), node.fullWidth())) {
                        if (!node.isIncrementallyUnusable()) {
                            return node;
                        }
                    }

                    this._oldSourceUnitCursor.moveToFirstChild();
                }
            };

            IncrementalParserSource.prototype.canReuseTokenFromOldSourceUnit = function (position, token) {
                if (token !== null) {
                    if (!this.intersectsWithChangeRangeSpanInOriginalText(position, token.fullWidth())) {
                        if (!token.isIncrementallyUnusable()) {
                            return true;
                        }
                    }
                }

                return false;
            };

            IncrementalParserSource.prototype.tryGetTokenFromOldSourceUnit = function () {
                var token = this._oldSourceUnitCursor.currentToken();

                return this.canReuseTokenFromOldSourceUnit(this.absolutePosition(), token) ? token : null;
            };

            IncrementalParserSource.prototype.peekToken = function (n) {
                if (this.canReadFromOldSourceUnit()) {
                    var token = this.tryPeekTokenFromOldSourceUnit(n);
                    if (token !== null) {
                        return token;
                    }
                }

                return this._normalParserSource.peekToken(n);
            };

            IncrementalParserSource.prototype.tryPeekTokenFromOldSourceUnit = function (n) {
                var currentPosition = this.absolutePosition();
                for (var i = 0; i < n; i++) {
                    var interimToken = this._oldSourceUnitCursor.peekToken(i);
                    if (!this.canReuseTokenFromOldSourceUnit(currentPosition, interimToken)) {
                        return null;
                    }

                    currentPosition += interimToken.fullWidth();
                }

                var token = this._oldSourceUnitCursor.peekToken(n);
                return this.canReuseTokenFromOldSourceUnit(currentPosition, token) ? token : null;
            };

            IncrementalParserSource.prototype.moveToNextNode = function () {
                var currentElement = this._oldSourceUnitCursor.currentElement();
                var currentNode = this._oldSourceUnitCursor.currentNode();

                this._oldSourceUnitCursor.moveToNextSibling();

                var absolutePosition = this.absolutePosition() + currentNode.fullWidth();
                var previousToken = currentNode.lastToken();
                this._normalParserSource.resetToPosition(absolutePosition, previousToken);

                if (this._changeRange !== null) {
                }
            };

            IncrementalParserSource.prototype.moveToNextToken = function () {
                var currentToken = this.currentToken();

                if (this._oldSourceUnitCursor.currentToken() === currentToken) {
                    this._oldSourceUnitCursor.moveToNextSibling();

                    var absolutePosition = this.absolutePosition() + currentToken.fullWidth();
                    var previousToken = currentToken;
                    this._normalParserSource.resetToPosition(absolutePosition, previousToken);

                    if (this._changeRange !== null) {
                    }
                } else {
                    this._changeDelta -= currentToken.fullWidth();

                    this._normalParserSource.moveToNextToken();

                    if (this._changeRange !== null) {
                        var changeRangeSpanInNewText = this._changeRange.newSpan();
                        if (this.absolutePosition() >= changeRangeSpanInNewText.end()) {
                            this._changeDelta += this._changeRange.newLength() - this._changeRange.span().length();
                            this._changeRange = null;
                        }
                    }
                }
            };
            return IncrementalParserSource;
        })();

        var ParserImpl = (function () {
            function ParserImpl(fileName, lineMap, source, parseOptions) {
                this.listParsingState = 0;
                this.isInStrictMode = false;
                this.diagnostics = [];
                this.factory = TypeScript.Syntax.normalModeFactory;
                this.mergeTokensStorage = [];
                this.arrayPool = [];
                this.fileName = fileName;
                this.lineMap = lineMap;
                this.source = source;
                this.parseOptions = parseOptions;
            }
            ParserImpl.prototype.getRewindPoint = function () {
                var rewindPoint = this.source.getRewindPoint();

                rewindPoint.diagnosticsCount = this.diagnostics.length;

                rewindPoint.isInStrictMode = this.isInStrictMode;
                rewindPoint.listParsingState = this.listParsingState;

                return rewindPoint;
            };

            ParserImpl.prototype.rewind = function (rewindPoint) {
                this.source.rewind(rewindPoint);

                this.diagnostics.length = rewindPoint.diagnosticsCount;
            };

            ParserImpl.prototype.releaseRewindPoint = function (rewindPoint) {
                this.source.releaseRewindPoint(rewindPoint);
            };

            ParserImpl.prototype.currentTokenStart = function () {
                return this.source.absolutePosition() + this.currentToken().leadingTriviaWidth();
            };

            ParserImpl.prototype.previousTokenStart = function () {
                if (this.previousToken() === null) {
                    return 0;
                }

                return this.source.absolutePosition() - this.previousToken().fullWidth() + this.previousToken().leadingTriviaWidth();
            };

            ParserImpl.prototype.previousTokenEnd = function () {
                if (this.previousToken() === null) {
                    return 0;
                }

                return this.previousTokenStart() + this.previousToken().width();
            };

            ParserImpl.prototype.currentNode = function () {
                var node = this.source.currentNode();

                if (node === null || node.parsedInStrictMode() !== this.isInStrictMode) {
                    return null;
                }

                return node;
            };

            ParserImpl.prototype.currentToken = function () {
                return this.source.currentToken();
            };

            ParserImpl.prototype.currentTokenAllowingRegularExpression = function () {
                return this.source.currentTokenAllowingRegularExpression();
            };

            ParserImpl.prototype.peekToken = function (n) {
                return this.source.peekToken(n);
            };

            ParserImpl.prototype.eatAnyToken = function () {
                var token = this.currentToken();
                this.moveToNextToken();
                return token;
            };

            ParserImpl.prototype.moveToNextToken = function () {
                this.source.moveToNextToken();
            };

            ParserImpl.prototype.previousToken = function () {
                return this.source.previousToken();
            };

            ParserImpl.prototype.eatNode = function () {
                var node = this.source.currentNode();
                this.source.moveToNextNode();
                return node;
            };

            ParserImpl.prototype.eatToken = function (kind) {
                var token = this.currentToken();
                if (token.tokenKind === kind) {
                    this.moveToNextToken();
                    return token;
                }

                return this.createMissingToken(kind, token);
            };

            ParserImpl.prototype.tryEatToken = function (kind) {
                if (this.currentToken().tokenKind === kind) {
                    return this.eatToken(kind);
                }

                return null;
            };

            ParserImpl.prototype.tryEatKeyword = function (kind) {
                if (this.currentToken().tokenKind === kind) {
                    return this.eatKeyword(kind);
                }

                return null;
            };

            ParserImpl.prototype.eatKeyword = function (kind) {
                var token = this.currentToken();
                if (token.tokenKind === kind) {
                    this.moveToNextToken();
                    return token;
                }

                return this.createMissingToken(kind, token);
            };

            ParserImpl.prototype.isIdentifier = function (token) {
                var tokenKind = token.tokenKind;

                if (tokenKind === 11 /* IdentifierName */) {
                    return true;
                }

                if (tokenKind >= 51 /* FirstFutureReservedStrictKeyword */) {
                    if (tokenKind <= 59 /* LastFutureReservedStrictKeyword */) {
                        return !this.isInStrictMode;
                    }

                    return tokenKind <= 69 /* LastTypeScriptKeyword */;
                }

                return false;
            };

            ParserImpl.prototype.eatIdentifierNameToken = function () {
                var token = this.currentToken();

                if (token.tokenKind === 11 /* IdentifierName */) {
                    this.moveToNextToken();
                    return token;
                }

                if (TypeScript.SyntaxFacts.isAnyKeyword(token.tokenKind)) {
                    this.moveToNextToken();
                    return TypeScript.Syntax.convertToIdentifierName(token);
                }

                return this.createMissingToken(11 /* IdentifierName */, token);
            };

            ParserImpl.prototype.eatIdentifierToken = function () {
                var token = this.currentToken();
                if (this.isIdentifier(token)) {
                    this.moveToNextToken();

                    if (token.tokenKind === 11 /* IdentifierName */) {
                        return token;
                    }

                    return TypeScript.Syntax.convertToIdentifierName(token);
                }

                return this.createMissingToken(11 /* IdentifierName */, token);
            };

            ParserImpl.prototype.canEatAutomaticSemicolon = function (allowWithoutNewLine) {
                var token = this.currentToken();

                if (token.tokenKind === 10 /* EndOfFileToken */) {
                    return true;
                }

                if (token.tokenKind === 71 /* CloseBraceToken */) {
                    return true;
                }

                if (allowWithoutNewLine) {
                    return true;
                }

                if (this.previousToken() !== null && this.previousToken().hasTrailingNewLine()) {
                    return true;
                }

                return false;
            };

            ParserImpl.prototype.canEatExplicitOrAutomaticSemicolon = function (allowWithoutNewline) {
                var token = this.currentToken();

                if (token.tokenKind === 78 /* SemicolonToken */) {
                    return true;
                }

                return this.canEatAutomaticSemicolon(allowWithoutNewline);
            };

            ParserImpl.prototype.eatExplicitOrAutomaticSemicolon = function (allowWithoutNewline) {
                var token = this.currentToken();

                if (token.tokenKind === 78 /* SemicolonToken */) {
                    return this.eatToken(78 /* SemicolonToken */);
                }

                if (this.canEatAutomaticSemicolon(allowWithoutNewline)) {
                    var semicolonToken = TypeScript.Syntax.emptyToken(78 /* SemicolonToken */);

                    if (!this.parseOptions.allowAutomaticSemicolonInsertion()) {
                        this.addDiagnostic(new TypeScript.Diagnostic(this.fileName, this.previousTokenEnd(), 0, TypeScript.DiagnosticCode.Automatic_semicolon_insertion_not_allowed, null));
                    }

                    return semicolonToken;
                }

                return this.eatToken(78 /* SemicolonToken */);
            };

            ParserImpl.prototype.isKeyword = function (kind) {
                if (kind >= 15 /* FirstKeyword */) {
                    if (kind <= 50 /* LastFutureReservedKeyword */) {
                        return true;
                    }

                    if (this.isInStrictMode) {
                        return kind <= 59 /* LastFutureReservedStrictKeyword */;
                    }
                }

                return false;
            };

            ParserImpl.prototype.createMissingToken = function (expectedKind, actual) {
                var diagnostic = this.getExpectedTokenDiagnostic(expectedKind, actual);
                this.addDiagnostic(diagnostic);

                return TypeScript.Syntax.emptyToken(expectedKind);
            };

            ParserImpl.prototype.getExpectedTokenDiagnostic = function (expectedKind, actual) {
                var token = this.currentToken();

                if (TypeScript.SyntaxFacts.isAnyKeyword(expectedKind) || TypeScript.SyntaxFacts.isAnyPunctuation(expectedKind)) {
                    return new TypeScript.Diagnostic(this.fileName, this.currentTokenStart(), token.width(), TypeScript.DiagnosticCode._0_expected, [TypeScript.SyntaxFacts.getText(expectedKind)]);
                } else {
                    if (actual !== null && TypeScript.SyntaxFacts.isAnyKeyword(actual.tokenKind)) {
                        return new TypeScript.Diagnostic(this.fileName, this.currentTokenStart(), token.width(), TypeScript.DiagnosticCode.Identifier_expected_0_is_a_keyword, [TypeScript.SyntaxFacts.getText(actual.tokenKind)]);
                    } else {
                        return new TypeScript.Diagnostic(this.fileName, this.currentTokenStart(), token.width(), TypeScript.DiagnosticCode.Identifier_expected, null);
                    }
                }
            };

            ParserImpl.getPrecedence = function (expressionKind) {
                switch (expressionKind) {
                    case 172 /* CommaExpression */:
                        return 1 /* CommaExpressionPrecedence */;

                    case 173 /* AssignmentExpression */:
                    case 174 /* AddAssignmentExpression */:
                    case 175 /* SubtractAssignmentExpression */:
                    case 176 /* MultiplyAssignmentExpression */:
                    case 177 /* DivideAssignmentExpression */:
                    case 178 /* ModuloAssignmentExpression */:
                    case 179 /* AndAssignmentExpression */:
                    case 180 /* ExclusiveOrAssignmentExpression */:
                    case 181 /* OrAssignmentExpression */:
                    case 182 /* LeftShiftAssignmentExpression */:
                    case 183 /* SignedRightShiftAssignmentExpression */:
                    case 184 /* UnsignedRightShiftAssignmentExpression */:
                        return 2 /* AssignmentExpressionPrecedence */;

                    case 185 /* ConditionalExpression */:
                        return 3 /* ConditionalExpressionPrecedence */;

                    case 186 /* LogicalOrExpression */:
                        return 5 /* LogicalOrExpressionPrecedence */;

                    case 187 /* LogicalAndExpression */:
                        return 6 /* LogicalAndExpressionPrecedence */;

                    case 188 /* BitwiseOrExpression */:
                        return 7 /* BitwiseOrExpressionPrecedence */;

                    case 189 /* BitwiseExclusiveOrExpression */:
                        return 8 /* BitwiseExclusiveOrExpressionPrecedence */;

                    case 190 /* BitwiseAndExpression */:
                        return 9 /* BitwiseAndExpressionPrecedence */;

                    case 191 /* EqualsWithTypeConversionExpression */:
                    case 192 /* NotEqualsWithTypeConversionExpression */:
                    case 193 /* EqualsExpression */:
                    case 194 /* NotEqualsExpression */:
                        return 10 /* EqualityExpressionPrecedence */;

                    case 195 /* LessThanExpression */:
                    case 196 /* GreaterThanExpression */:
                    case 197 /* LessThanOrEqualExpression */:
                    case 198 /* GreaterThanOrEqualExpression */:
                    case 199 /* InstanceOfExpression */:
                    case 200 /* InExpression */:
                        return 11 /* RelationalExpressionPrecedence */;

                    case 201 /* LeftShiftExpression */:
                    case 202 /* SignedRightShiftExpression */:
                    case 203 /* UnsignedRightShiftExpression */:
                        return 12 /* ShiftExpressionPrecdence */;

                    case 207 /* AddExpression */:
                    case 208 /* SubtractExpression */:
                        return 13 /* AdditiveExpressionPrecedence */;

                    case 204 /* MultiplyExpression */:
                    case 205 /* DivideExpression */:
                    case 206 /* ModuloExpression */:
                        return 14 /* MultiplicativeExpressionPrecedence */;

                    case 163 /* PlusExpression */:
                    case 164 /* NegateExpression */:
                    case 165 /* BitwiseNotExpression */:
                    case 166 /* LogicalNotExpression */:
                    case 169 /* DeleteExpression */:
                    case 170 /* TypeOfExpression */:
                    case 171 /* VoidExpression */:
                    case 167 /* PreIncrementExpression */:
                    case 168 /* PreDecrementExpression */:
                        return 15 /* UnaryExpressionPrecedence */;
                }

                throw TypeScript.Errors.invalidOperation();
            };

            ParserImpl.prototype.addSkippedTokenAfterNodeOrToken = function (nodeOrToken, skippedToken) {
                if (nodeOrToken.isToken()) {
                    return this.addSkippedTokenAfterToken(nodeOrToken, skippedToken);
                } else if (nodeOrToken.isNode()) {
                    return this.addSkippedTokenAfterNode(nodeOrToken, skippedToken);
                } else {
                    throw TypeScript.Errors.invalidOperation();
                }
            };

            ParserImpl.prototype.addSkippedTokenAfterNode = function (node, skippedToken) {
                var oldToken = node.lastToken();
                var newToken = this.addSkippedTokenAfterToken(oldToken, skippedToken);

                return node.replaceToken(oldToken, newToken);
            };

            ParserImpl.prototype.addSkippedTokensBeforeNode = function (node, skippedTokens) {
                if (skippedTokens.length > 0) {
                    var oldToken = node.firstToken();
                    var newToken = this.addSkippedTokensBeforeToken(oldToken, skippedTokens);

                    return node.replaceToken(oldToken, newToken);
                }

                return node;
            };

            ParserImpl.prototype.addSkippedTokensBeforeToken = function (token, skippedTokens) {
                var leadingTrivia = [];
                for (var i = 0, n = skippedTokens.length; i < n; i++) {
                    this.addSkippedTokenToTriviaArray(leadingTrivia, skippedTokens[i]);
                }

                this.addTriviaTo(token.leadingTrivia(), leadingTrivia);

                this.returnArray(skippedTokens);
                return token.withLeadingTrivia(TypeScript.Syntax.triviaList(leadingTrivia));
            };

            ParserImpl.prototype.addSkippedTokensAfterToken = function (token, skippedTokens) {
                if (skippedTokens.length === 0) {
                    this.returnArray(skippedTokens);
                    return token;
                }

                var trailingTrivia = token.trailingTrivia().toArray();

                for (var i = 0, n = skippedTokens.length; i < n; i++) {
                    this.addSkippedTokenToTriviaArray(trailingTrivia, skippedTokens[i]);
                }

                this.returnArray(skippedTokens);
                return token.withTrailingTrivia(TypeScript.Syntax.triviaList(trailingTrivia));
            };

            ParserImpl.prototype.addSkippedTokenAfterToken = function (token, skippedToken) {
                var trailingTrivia = token.trailingTrivia().toArray();
                this.addSkippedTokenToTriviaArray(trailingTrivia, skippedToken);

                return token.withTrailingTrivia(TypeScript.Syntax.triviaList(trailingTrivia));
            };

            ParserImpl.prototype.addSkippedTokenToTriviaArray = function (array, skippedToken) {
                this.addTriviaTo(skippedToken.leadingTrivia(), array);

                var trimmedToken = skippedToken.withLeadingTrivia(TypeScript.Syntax.emptyTriviaList).withTrailingTrivia(TypeScript.Syntax.emptyTriviaList);
                array.push(TypeScript.Syntax.skippedTokenTrivia(trimmedToken));

                this.addTriviaTo(skippedToken.trailingTrivia(), array);
            };

            ParserImpl.prototype.addTriviaTo = function (list, array) {
                for (var i = 0, n = list.count(); i < n; i++) {
                    array.push(list.syntaxTriviaAt(i));
                }
            };

            ParserImpl.prototype.parseSyntaxTree = function (isDeclaration) {
                var sourceUnit = this.parseSourceUnit();

                var allDiagnostics = this.source.tokenDiagnostics().concat(this.diagnostics);
                allDiagnostics.sort(function (a, b) {
                    return a.start() - b.start();
                });

                return new TypeScript.SyntaxTree(sourceUnit, isDeclaration, allDiagnostics, this.fileName, this.lineMap, this.parseOptions);
            };

            ParserImpl.prototype.setStrictMode = function (isInStrictMode) {
                this.isInStrictMode = isInStrictMode;
                this.factory = isInStrictMode ? TypeScript.Syntax.strictModeFactory : TypeScript.Syntax.normalModeFactory;
            };

            ParserImpl.prototype.parseSourceUnit = function () {
                var savedIsInStrictMode = this.isInStrictMode;

                var result = this.parseSyntaxList(1 /* SourceUnit_ModuleElements */, ParserImpl.updateStrictModeState);
                var moduleElements = result.list;

                this.setStrictMode(savedIsInStrictMode);

                var sourceUnit = this.factory.sourceUnit(moduleElements, this.currentToken());
                sourceUnit = this.addSkippedTokensBeforeNode(sourceUnit, result.skippedTokens);

                return sourceUnit;
            };

            ParserImpl.updateStrictModeState = function (parser, items) {
                if (!parser.isInStrictMode) {
                    for (var i = 0; i < items.length; i++) {
                        var item = items[i];
                        if (!TypeScript.SyntaxFacts.isDirectivePrologueElement(item)) {
                            return;
                        }
                    }

                    parser.setStrictMode(TypeScript.SyntaxFacts.isUseStrictDirective(items[items.length - 1]));
                }
            };

            ParserImpl.prototype.isModuleElement = function (inErrorRecovery) {
                if (this.currentNode() !== null && this.currentNode().isModuleElement()) {
                    return true;
                }

                return this.isImportDeclaration() || this.isExportAssignment() || this.isModuleDeclaration() || this.isInterfaceDeclaration() || this.isClassDeclaration() || this.isEnumDeclaration() || this.isStatement(inErrorRecovery);
            };

            ParserImpl.prototype.parseModuleElement = function () {
                if (this.currentNode() !== null && this.currentNode().isModuleElement()) {
                    return this.eatNode();
                }

                if (this.isImportDeclaration()) {
                    return this.parseImportDeclaration();
                } else if (this.isExportAssignment()) {
                    return this.parseExportAssignment();
                } else if (this.isModuleDeclaration()) {
                    return this.parseModuleDeclaration();
                } else if (this.isInterfaceDeclaration()) {
                    return this.parseInterfaceDeclaration();
                } else if (this.isClassDeclaration()) {
                    return this.parseClassDeclaration();
                } else if (this.isEnumDeclaration()) {
                    return this.parseEnumDeclaration();
                } else if (this.isStatement(false)) {
                    return this.parseStatement();
                } else {
                    throw TypeScript.Errors.invalidOperation();
                }
            };

            ParserImpl.prototype.isImportDeclaration = function () {
                var index = this.modifierCount();

                if (index > 0 && this.peekToken(index).tokenKind === 49 /* ImportKeyword */) {
                    return true;
                }

                return this.currentToken().tokenKind === 49 /* ImportKeyword */ && this.isIdentifier(this.peekToken(1));
            };

            ParserImpl.prototype.parseImportDeclaration = function () {
                var modifiers = this.parseModifiers();
                var importKeyword = this.eatKeyword(49 /* ImportKeyword */);
                var identifier = this.eatIdentifierToken();
                var equalsToken = this.eatToken(107 /* EqualsToken */);
                var moduleReference = this.parseModuleReference();
                var semicolonToken = this.eatExplicitOrAutomaticSemicolon(false);

                return this.factory.importDeclaration(modifiers, importKeyword, identifier, equalsToken, moduleReference, semicolonToken);
            };

            ParserImpl.prototype.isExportAssignment = function () {
                return this.currentToken().tokenKind === 47 /* ExportKeyword */ && this.peekToken(1).tokenKind === 107 /* EqualsToken */;
            };

            ParserImpl.prototype.parseExportAssignment = function () {
                var exportKeyword = this.eatKeyword(47 /* ExportKeyword */);
                var equalsToken = this.eatToken(107 /* EqualsToken */);
                var identifier = this.eatIdentifierToken();
                var semicolonToken = this.eatExplicitOrAutomaticSemicolon(false);

                return this.factory.exportAssignment(exportKeyword, equalsToken, identifier, semicolonToken);
            };

            ParserImpl.prototype.parseModuleReference = function () {
                if (this.isExternalModuleReference()) {
                    return this.parseExternalModuleReference();
                } else {
                    return this.parseModuleNameModuleReference();
                }
            };

            ParserImpl.prototype.isExternalModuleReference = function () {
                var token0 = this.currentToken();
                if (token0.tokenKind === 66 /* RequireKeyword */) {
                    return this.peekToken(1).tokenKind === 72 /* OpenParenToken */;
                }

                return false;
            };

            ParserImpl.prototype.parseExternalModuleReference = function () {
                var requireKeyword = this.eatKeyword(66 /* RequireKeyword */);
                var openParenToken = this.eatToken(72 /* OpenParenToken */);
                var stringLiteral = this.eatToken(14 /* StringLiteral */);
                var closeParenToken = this.eatToken(73 /* CloseParenToken */);

                return this.factory.externalModuleReference(requireKeyword, openParenToken, stringLiteral, closeParenToken);
            };

            ParserImpl.prototype.parseModuleNameModuleReference = function () {
                var name = this.parseName();
                return this.factory.moduleNameModuleReference(name);
            };

            ParserImpl.prototype.parseIdentifierName = function () {
                var identifierName = this.eatIdentifierNameToken();
                return identifierName;
            };

            ParserImpl.prototype.isName = function () {
                return this.isIdentifier(this.currentToken());
            };

            ParserImpl.prototype.tryParseTypeArgumentList = function (inExpression) {
                if (this.currentToken().kind() !== 80 /* LessThanToken */) {
                    return null;
                }

                var lessThanToken;
                var greaterThanToken;
                var result;
                var typeArguments;

                if (!inExpression) {
                    lessThanToken = this.eatToken(80 /* LessThanToken */);

                    result = this.parseSeparatedSyntaxList(262144 /* TypeArgumentList_Types */);
                    typeArguments = result.list;
                    lessThanToken = this.addSkippedTokensAfterToken(lessThanToken, result.skippedTokens);

                    greaterThanToken = this.eatToken(81 /* GreaterThanToken */);

                    return this.factory.typeArgumentList(lessThanToken, typeArguments, greaterThanToken);
                }

                var rewindPoint = this.getRewindPoint();
                try  {
                    lessThanToken = this.eatToken(80 /* LessThanToken */);

                    result = this.parseSeparatedSyntaxList(262144 /* TypeArgumentList_Types */);
                    typeArguments = result.list;
                    lessThanToken = this.addSkippedTokensAfterToken(lessThanToken, result.skippedTokens);

                    greaterThanToken = this.eatToken(81 /* GreaterThanToken */);

                    if (greaterThanToken.fullWidth() === 0 || !this.canFollowTypeArgumentListInExpression(this.currentToken().kind())) {
                        this.rewind(rewindPoint);
                        return null;
                    }

                    return this.factory.typeArgumentList(lessThanToken, typeArguments, greaterThanToken);
                } finally {
                    this.releaseRewindPoint(rewindPoint);
                }
            };

            ParserImpl.prototype.canFollowTypeArgumentListInExpression = function (kind) {
                switch (kind) {
                    case 72 /* OpenParenToken */:
                    case 76 /* DotToken */:

                    case 73 /* CloseParenToken */:
                    case 75 /* CloseBracketToken */:
                    case 106 /* ColonToken */:
                    case 78 /* SemicolonToken */:
                    case 79 /* CommaToken */:
                    case 105 /* QuestionToken */:
                    case 84 /* EqualsEqualsToken */:
                    case 87 /* EqualsEqualsEqualsToken */:
                    case 86 /* ExclamationEqualsToken */:
                    case 88 /* ExclamationEqualsEqualsToken */:
                    case 103 /* AmpersandAmpersandToken */:
                    case 104 /* BarBarToken */:
                    case 100 /* CaretToken */:
                    case 98 /* AmpersandToken */:
                    case 99 /* BarToken */:
                    case 71 /* CloseBraceToken */:
                    case 10 /* EndOfFileToken */:
                        return true;

                    default:
                        return false;
                }
            };

            ParserImpl.prototype.parseName = function () {
                var shouldContinue = this.isIdentifier(this.currentToken());
                var current = this.eatIdentifierToken();

                while (shouldContinue && this.currentToken().tokenKind === 76 /* DotToken */) {
                    var dotToken = this.eatToken(76 /* DotToken */);

                    var currentToken = this.currentToken();
                    var identifierName;

                    if (TypeScript.SyntaxFacts.isAnyKeyword(currentToken.tokenKind) && this.previousToken().hasTrailingNewLine() && !currentToken.hasTrailingNewLine() && TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(this.peekToken(1))) {
                        identifierName = this.createMissingToken(11 /* IdentifierName */, currentToken);
                    } else {
                        identifierName = this.eatIdentifierNameToken();
                    }

                    current = this.factory.qualifiedName(current, dotToken, identifierName);

                    shouldContinue = identifierName.fullWidth() > 0;
                }

                return current;
            };

            ParserImpl.prototype.isEnumDeclaration = function () {
                var index = this.modifierCount();

                if (index > 0 && this.peekToken(index).tokenKind === 46 /* EnumKeyword */) {
                    return true;
                }

                return this.currentToken().tokenKind === 46 /* EnumKeyword */ && this.isIdentifier(this.peekToken(1));
            };

            ParserImpl.prototype.parseEnumDeclaration = function () {
                var modifiers = this.parseModifiers();
                var enumKeyword = this.eatKeyword(46 /* EnumKeyword */);
                var identifier = this.eatIdentifierToken();

                var openBraceToken = this.eatToken(70 /* OpenBraceToken */);
                var enumElements = TypeScript.Syntax.emptySeparatedList;

                if (openBraceToken.width() > 0) {
                    var result = this.parseSeparatedSyntaxList(256 /* EnumDeclaration_EnumElements */);
                    enumElements = result.list;
                    openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);
                }

                var closeBraceToken = this.eatToken(71 /* CloseBraceToken */);

                return this.factory.enumDeclaration(modifiers, enumKeyword, identifier, openBraceToken, enumElements, closeBraceToken);
            };

            ParserImpl.prototype.isEnumElement = function (inErrorRecovery) {
                if (this.currentNode() !== null && this.currentNode().kind() === 243 /* EnumElement */) {
                    return true;
                }

                return this.isPropertyName(this.currentToken(), inErrorRecovery);
            };

            ParserImpl.prototype.parseEnumElement = function () {
                if (this.currentNode() !== null && this.currentNode().kind() === 243 /* EnumElement */) {
                    return this.eatNode();
                }

                var propertyName = this.eatPropertyName();
                var equalsValueClause = null;
                if (this.isEqualsValueClause(false)) {
                    equalsValueClause = this.parseEqualsValueClause(true);
                }

                return this.factory.enumElement(propertyName, equalsValueClause);
            };

            ParserImpl.isModifier = function (token) {
                switch (token.tokenKind) {
                    case 57 /* PublicKeyword */:
                    case 55 /* PrivateKeyword */:
                    case 58 /* StaticKeyword */:
                    case 47 /* ExportKeyword */:
                    case 63 /* DeclareKeyword */:
                        return true;

                    default:
                        return false;
                }
            };

            ParserImpl.prototype.modifierCount = function () {
                var modifierCount = 0;
                while (true) {
                    if (ParserImpl.isModifier(this.peekToken(modifierCount))) {
                        modifierCount++;
                        continue;
                    }

                    break;
                }

                return modifierCount;
            };

            ParserImpl.prototype.parseModifiers = function () {
                var tokens = this.getArray();

                while (true) {
                    if (ParserImpl.isModifier(this.currentToken())) {
                        tokens.push(this.eatAnyToken());
                        continue;
                    }

                    break;
                }

                var result = TypeScript.Syntax.list(tokens);

                this.returnZeroOrOneLengthArray(tokens);

                return result;
            };

            ParserImpl.prototype.isClassDeclaration = function () {
                var index = this.modifierCount();

                if (index > 0 && this.peekToken(index).tokenKind === 44 /* ClassKeyword */) {
                    return true;
                }

                return this.currentToken().tokenKind === 44 /* ClassKeyword */ && this.isIdentifier(this.peekToken(1));
            };

            ParserImpl.prototype.parseHeritageClauses = function () {
                var heritageClauses = TypeScript.Syntax.emptyList;

                if (this.isHeritageClause()) {
                    var result = this.parseSyntaxList(1024 /* ClassOrInterfaceDeclaration_HeritageClauses */);
                    heritageClauses = result.list;
                    TypeScript.Debug.assert(result.skippedTokens.length === 0);
                }

                return heritageClauses;
            };

            ParserImpl.prototype.parseClassDeclaration = function () {
                var modifiers = this.parseModifiers();

                var classKeyword = this.eatKeyword(44 /* ClassKeyword */);
                var identifier = this.eatIdentifierToken();
                var typeParameterList = this.parseOptionalTypeParameterList(false);
                var heritageClauses = this.parseHeritageClauses();
                var openBraceToken = this.eatToken(70 /* OpenBraceToken */);
                var classElements = TypeScript.Syntax.emptyList;

                if (openBraceToken.width() > 0) {
                    var result = this.parseSyntaxList(2 /* ClassDeclaration_ClassElements */);

                    classElements = result.list;
                    openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);
                }

                var closeBraceToken = this.eatToken(71 /* CloseBraceToken */);
                return this.factory.classDeclaration(modifiers, classKeyword, identifier, typeParameterList, heritageClauses, openBraceToken, classElements, closeBraceToken);
            };

            ParserImpl.prototype.isConstructorDeclaration = function () {
                return this.currentToken().tokenKind === 62 /* ConstructorKeyword */;
            };

            ParserImpl.isPublicOrPrivateKeyword = function (token) {
                return token.tokenKind === 57 /* PublicKeyword */ || token.tokenKind === 55 /* PrivateKeyword */;
            };

            ParserImpl.prototype.isMemberAccessorDeclaration = function (inErrorRecovery) {
                var index = this.modifierCount();

                if (this.peekToken(index).tokenKind !== 64 /* GetKeyword */ && this.peekToken(index).tokenKind !== 68 /* SetKeyword */) {
                    return false;
                }

                index++;
                return this.isPropertyName(this.peekToken(index), inErrorRecovery);
            };

            ParserImpl.prototype.parseMemberAccessorDeclaration = function () {
                var modifiers = this.parseModifiers();

                if (this.currentToken().tokenKind === 64 /* GetKeyword */) {
                    return this.parseGetMemberAccessorDeclaration(modifiers);
                } else if (this.currentToken().tokenKind === 68 /* SetKeyword */) {
                    return this.parseSetMemberAccessorDeclaration(modifiers);
                } else {
                    throw TypeScript.Errors.invalidOperation();
                }
            };

            ParserImpl.prototype.parseGetMemberAccessorDeclaration = function (modifiers) {
                var getKeyword = this.eatKeyword(64 /* GetKeyword */);
                var propertyName = this.eatPropertyName();
                var parameterList = this.parseParameterList();
                var typeAnnotation = this.parseOptionalTypeAnnotation(false);
                var block = this.parseBlock(false, false);

                return this.factory.getMemberAccessorDeclaration(modifiers, getKeyword, propertyName, parameterList, typeAnnotation, block);
            };

            ParserImpl.prototype.parseSetMemberAccessorDeclaration = function (modifiers) {
                var setKeyword = this.eatKeyword(68 /* SetKeyword */);
                var propertyName = this.eatPropertyName();
                var parameterList = this.parseParameterList();
                var block = this.parseBlock(false, false);

                return this.factory.setMemberAccessorDeclaration(modifiers, setKeyword, propertyName, parameterList, block);
            };

            ParserImpl.prototype.isClassElement = function (inErrorRecovery) {
                if (this.currentNode() !== null && this.currentNode().isClassElement()) {
                    return true;
                }

                return this.isConstructorDeclaration() || this.isMemberFunctionDeclaration(inErrorRecovery) || this.isMemberAccessorDeclaration(inErrorRecovery) || this.isMemberVariableDeclaration(inErrorRecovery) || this.isIndexSignature();
            };

            ParserImpl.prototype.parseConstructorDeclaration = function () {
                var constructorKeyword = this.eatKeyword(62 /* ConstructorKeyword */);
                var parameterList = this.parseParameterList();

                var semicolonToken = null;
                var block = null;

                if (this.isBlock()) {
                    block = this.parseBlock(false, true);
                } else {
                    semicolonToken = this.eatExplicitOrAutomaticSemicolon(false);
                }

                return this.factory.constructorDeclaration(constructorKeyword, parameterList, block, semicolonToken);
            };

            ParserImpl.prototype.isMemberFunctionDeclaration = function (inErrorRecovery) {
                var index = 0;

                while (true) {
                    var token = this.peekToken(index);
                    if (this.isPropertyName(token, inErrorRecovery) && this.isCallSignature(index + 1)) {
                        return true;
                    }

                    if (ParserImpl.isModifier(token)) {
                        index++;
                        continue;
                    }

                    return false;
                }
            };

            ParserImpl.prototype.parseMemberFunctionDeclaration = function () {
                var modifierArray = this.getArray();

                while (true) {
                    var currentToken = this.currentToken();
                    if (this.isPropertyName(currentToken, false) && this.isCallSignature(1)) {
                        break;
                    }

                    TypeScript.Debug.assert(ParserImpl.isModifier(currentToken));
                    modifierArray.push(this.eatAnyToken());
                }

                var modifiers = TypeScript.Syntax.list(modifierArray);
                this.returnZeroOrOneLengthArray(modifierArray);

                var propertyName = this.eatPropertyName();
                var callSignature = this.parseCallSignature(false);

                var newCallSignature = this.tryAddUnexpectedEqualsGreaterThanToken(callSignature);
                var parseBlockEvenWithNoOpenBrace = callSignature !== newCallSignature;
                callSignature = newCallSignature;

                var block = null;
                var semicolon = null;

                if (parseBlockEvenWithNoOpenBrace || this.isBlock()) {
                    block = this.parseBlock(parseBlockEvenWithNoOpenBrace, true);
                } else {
                    semicolon = this.eatExplicitOrAutomaticSemicolon(false);
                }

                return this.factory.memberFunctionDeclaration(modifiers, propertyName, callSignature, block, semicolon);
            };

            ParserImpl.prototype.isDefinitelyMemberVariablePropertyName = function (index) {
                if (TypeScript.SyntaxFacts.isAnyKeyword(this.peekToken(index).tokenKind)) {
                    switch (this.peekToken(index + 1).tokenKind) {
                        case 78 /* SemicolonToken */:
                        case 107 /* EqualsToken */:
                        case 106 /* ColonToken */:
                        case 71 /* CloseBraceToken */:
                        case 10 /* EndOfFileToken */:
                            return true;
                        default:
                            return false;
                    }
                } else {
                    return true;
                }
            };

            ParserImpl.prototype.isMemberVariableDeclaration = function (inErrorRecovery) {
                var index = 0;

                while (true) {
                    var token = this.peekToken(index);
                    if (this.isPropertyName(token, inErrorRecovery) && this.isDefinitelyMemberVariablePropertyName(index)) {
                        return true;
                    }

                    if (ParserImpl.isModifier(this.peekToken(index))) {
                        index++;
                        continue;
                    }

                    return false;
                }
            };

            ParserImpl.prototype.parseMemberVariableDeclaration = function () {
                var modifierArray = this.getArray();

                while (true) {
                    var currentToken = this.currentToken();
                    if (this.isPropertyName(currentToken, false) && this.isDefinitelyMemberVariablePropertyName(0)) {
                        break;
                    }

                    TypeScript.Debug.assert(ParserImpl.isModifier(currentToken));
                    modifierArray.push(this.eatAnyToken());
                }

                var modifiers = TypeScript.Syntax.list(modifierArray);
                this.returnZeroOrOneLengthArray(modifierArray);

                var variableDeclarator = this.parseVariableDeclarator(true, true);
                var semicolon = this.eatExplicitOrAutomaticSemicolon(false);

                return this.factory.memberVariableDeclaration(modifiers, variableDeclarator, semicolon);
            };

            ParserImpl.prototype.parseClassElement = function (inErrorRecovery) {
                if (this.currentNode() !== null && this.currentNode().isClassElement()) {
                    return this.eatNode();
                }

                if (this.isConstructorDeclaration()) {
                    return this.parseConstructorDeclaration();
                } else if (this.isMemberFunctionDeclaration(inErrorRecovery)) {
                    return this.parseMemberFunctionDeclaration();
                } else if (this.isMemberAccessorDeclaration(inErrorRecovery)) {
                    return this.parseMemberAccessorDeclaration();
                } else if (this.isMemberVariableDeclaration(inErrorRecovery)) {
                    return this.parseMemberVariableDeclaration();
                } else if (this.isIndexSignature()) {
                    return this.parseIndexSignature();
                } else {
                    throw TypeScript.Errors.invalidOperation();
                }
            };

            ParserImpl.prototype.tryAddUnexpectedEqualsGreaterThanToken = function (callSignature) {
                var token0 = this.currentToken();

                var hasEqualsGreaterThanToken = token0.tokenKind === 85 /* EqualsGreaterThanToken */;
                if (hasEqualsGreaterThanToken) {
                    var diagnostic = new TypeScript.Diagnostic(this.fileName, this.currentTokenStart(), token0.width(), TypeScript.DiagnosticCode.Unexpected_token_0_expected, [TypeScript.SyntaxFacts.getText(70 /* OpenBraceToken */)]);
                    this.addDiagnostic(diagnostic);

                    var token = this.eatAnyToken();
                    return this.addSkippedTokenAfterNode(callSignature, token0);
                }

                return callSignature;
            };

            ParserImpl.prototype.isFunctionDeclaration = function () {
                var index = this.modifierCount();
                return this.peekToken(index).tokenKind === 27 /* FunctionKeyword */;
            };

            ParserImpl.prototype.parseFunctionDeclaration = function () {
                var modifiers = this.parseModifiers();
                var functionKeyword = this.eatKeyword(27 /* FunctionKeyword */);
                var identifier = this.eatIdentifierToken();
                var callSignature = this.parseCallSignature(false);

                var newCallSignature = this.tryAddUnexpectedEqualsGreaterThanToken(callSignature);
                var parseBlockEvenWithNoOpenBrace = callSignature !== newCallSignature;
                callSignature = newCallSignature;

                var semicolonToken = null;
                var block = null;

                if (parseBlockEvenWithNoOpenBrace || this.isBlock()) {
                    block = this.parseBlock(parseBlockEvenWithNoOpenBrace, true);
                } else {
                    semicolonToken = this.eatExplicitOrAutomaticSemicolon(false);
                }

                return this.factory.functionDeclaration(modifiers, functionKeyword, identifier, callSignature, block, semicolonToken);
            };

            ParserImpl.prototype.isModuleDeclaration = function () {
                var index = this.modifierCount();

                if (index > 0 && this.peekToken(index).tokenKind === 65 /* ModuleKeyword */) {
                    return true;
                }

                if (this.currentToken().tokenKind === 65 /* ModuleKeyword */) {
                    var token1 = this.peekToken(1);
                    return this.isIdentifier(token1) || token1.tokenKind === 14 /* StringLiteral */;
                }

                return false;
            };

            ParserImpl.prototype.parseModuleDeclaration = function () {
                var modifiers = this.parseModifiers();
                var moduleKeyword = this.eatKeyword(65 /* ModuleKeyword */);

                var moduleName = null;
                var stringLiteral = null;

                if (this.currentToken().tokenKind === 14 /* StringLiteral */) {
                    stringLiteral = this.eatToken(14 /* StringLiteral */);
                } else {
                    moduleName = this.parseName();
                }

                var openBraceToken = this.eatToken(70 /* OpenBraceToken */);

                var moduleElements = TypeScript.Syntax.emptyList;
                if (openBraceToken.width() > 0) {
                    var result = this.parseSyntaxList(4 /* ModuleDeclaration_ModuleElements */);
                    moduleElements = result.list;
                    openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);
                }

                var closeBraceToken = this.eatToken(71 /* CloseBraceToken */);

                return this.factory.moduleDeclaration(modifiers, moduleKeyword, moduleName, stringLiteral, openBraceToken, moduleElements, closeBraceToken);
            };

            ParserImpl.prototype.isInterfaceDeclaration = function () {
                var index = this.modifierCount();

                if (index > 0 && this.peekToken(index).tokenKind === 52 /* InterfaceKeyword */) {
                    return true;
                }

                return this.currentToken().tokenKind === 52 /* InterfaceKeyword */ && this.isIdentifier(this.peekToken(1));
            };

            ParserImpl.prototype.parseInterfaceDeclaration = function () {
                var modifiers = this.parseModifiers();
                var interfaceKeyword = this.eatKeyword(52 /* InterfaceKeyword */);
                var identifier = this.eatIdentifierToken();
                var typeParameterList = this.parseOptionalTypeParameterList(false);
                var heritageClauses = this.parseHeritageClauses();

                var objectType = this.parseObjectType();
                return this.factory.interfaceDeclaration(modifiers, interfaceKeyword, identifier, typeParameterList, heritageClauses, objectType);
            };

            ParserImpl.prototype.parseObjectType = function () {
                var openBraceToken = this.eatToken(70 /* OpenBraceToken */);

                var typeMembers = TypeScript.Syntax.emptySeparatedList;
                if (openBraceToken.width() > 0) {
                    var result = this.parseSeparatedSyntaxList(512 /* ObjectType_TypeMembers */);
                    typeMembers = result.list;
                    openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);
                }

                var closeBraceToken = this.eatToken(71 /* CloseBraceToken */);
                return this.factory.objectType(openBraceToken, typeMembers, closeBraceToken);
            };

            ParserImpl.prototype.isTypeMember = function (inErrorRecovery) {
                if (this.currentNode() !== null && this.currentNode().isTypeMember()) {
                    return true;
                }

                return this.isCallSignature(0) || this.isConstructSignature() || this.isIndexSignature() || this.isMethodSignature(inErrorRecovery) || this.isPropertySignature(inErrorRecovery);
            };

            ParserImpl.prototype.parseTypeMember = function () {
                if (this.currentNode() !== null && this.currentNode().isTypeMember()) {
                    return this.eatNode();
                }

                if (this.isCallSignature(0)) {
                    return this.parseCallSignature(false);
                } else if (this.isConstructSignature()) {
                    return this.parseConstructSignature();
                } else if (this.isIndexSignature()) {
                    return this.parseIndexSignature();
                } else if (this.isMethodSignature(false)) {
                    return this.parseMethodSignature();
                } else if (this.isPropertySignature(false)) {
                    return this.parsePropertySignature();
                } else {
                    throw TypeScript.Errors.invalidOperation();
                }
            };

            ParserImpl.prototype.parseConstructSignature = function () {
                var newKeyword = this.eatKeyword(31 /* NewKeyword */);
                var callSignature = this.parseCallSignature(false);

                return this.factory.constructSignature(newKeyword, callSignature);
            };

            ParserImpl.prototype.parseIndexSignature = function () {
                var openBracketToken = this.eatToken(74 /* OpenBracketToken */);
                var parameter = this.parseParameter();
                var closeBracketToken = this.eatToken(75 /* CloseBracketToken */);
                var typeAnnotation = this.parseOptionalTypeAnnotation(false);

                return this.factory.indexSignature(openBracketToken, parameter, closeBracketToken, typeAnnotation);
            };

            ParserImpl.prototype.parseMethodSignature = function () {
                var propertyName = this.eatPropertyName();
                var questionToken = this.tryEatToken(105 /* QuestionToken */);
                var callSignature = this.parseCallSignature(false);

                return this.factory.methodSignature(propertyName, questionToken, callSignature);
            };

            ParserImpl.prototype.parsePropertySignature = function () {
                var propertyName = this.eatPropertyName();
                var questionToken = this.tryEatToken(105 /* QuestionToken */);
                var typeAnnotation = this.parseOptionalTypeAnnotation(false);

                return this.factory.propertySignature(propertyName, questionToken, typeAnnotation);
            };

            ParserImpl.prototype.isCallSignature = function (tokenIndex) {
                var tokenKind = this.peekToken(tokenIndex).tokenKind;
                return tokenKind === 72 /* OpenParenToken */ || tokenKind === 80 /* LessThanToken */;
            };

            ParserImpl.prototype.isConstructSignature = function () {
                if (this.currentToken().tokenKind !== 31 /* NewKeyword */) {
                    return false;
                }

                var token1 = this.peekToken(1);
                return token1.tokenKind === 80 /* LessThanToken */ || token1.tokenKind === 72 /* OpenParenToken */;
            };

            ParserImpl.prototype.isIndexSignature = function () {
                return this.currentToken().tokenKind === 74 /* OpenBracketToken */;
            };

            ParserImpl.prototype.isMethodSignature = function (inErrorRecovery) {
                if (this.isPropertyName(this.currentToken(), inErrorRecovery)) {
                    if (this.isCallSignature(1)) {
                        return true;
                    }

                    if (this.peekToken(1).tokenKind === 105 /* QuestionToken */ && this.isCallSignature(2)) {
                        return true;
                    }
                }

                return false;
            };

            ParserImpl.prototype.isPropertySignature = function (inErrorRecovery) {
                var currentToken = this.currentToken();

                if (ParserImpl.isModifier(currentToken) && !currentToken.hasTrailingNewLine() && this.isPropertyName(this.peekToken(1), inErrorRecovery)) {
                    return false;
                }

                return this.isPropertyName(currentToken, inErrorRecovery);
            };

            ParserImpl.prototype.isHeritageClause = function () {
                var token0 = this.currentToken();
                return token0.tokenKind === 48 /* ExtendsKeyword */ || token0.tokenKind === 51 /* ImplementsKeyword */;
            };

            ParserImpl.prototype.isNotHeritageClauseTypeName = function () {
                if (this.currentToken().tokenKind === 51 /* ImplementsKeyword */ || this.currentToken().tokenKind === 48 /* ExtendsKeyword */) {
                    return this.isIdentifier(this.peekToken(1));
                }

                return false;
            };

            ParserImpl.prototype.isHeritageClauseTypeName = function () {
                if (this.isName()) {
                    return !this.isNotHeritageClauseTypeName();
                }

                return false;
            };

            ParserImpl.prototype.parseHeritageClause = function () {
                var extendsOrImplementsKeyword = this.eatAnyToken();
                TypeScript.Debug.assert(extendsOrImplementsKeyword.tokenKind === 48 /* ExtendsKeyword */ || extendsOrImplementsKeyword.tokenKind === 51 /* ImplementsKeyword */);

                var result = this.parseSeparatedSyntaxList(2048 /* HeritageClause_TypeNameList */);
                var typeNames = result.list;
                extendsOrImplementsKeyword = this.addSkippedTokensAfterToken(extendsOrImplementsKeyword, result.skippedTokens);

                return this.factory.heritageClause(extendsOrImplementsKeyword, typeNames);
            };

            ParserImpl.prototype.isStatement = function (inErrorRecovery) {
                if (this.currentNode() !== null && this.currentNode().isStatement()) {
                    return true;
                }

                switch (this.currentToken().tokenKind) {
                    case 57 /* PublicKeyword */:
                    case 55 /* PrivateKeyword */:
                    case 58 /* StaticKeyword */:
                        var token1 = this.peekToken(1);
                        if (TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(token1)) {
                            return false;
                        }
                }

                return this.isVariableStatement() || this.isLabeledStatement() || this.isFunctionDeclaration() || this.isIfStatement() || this.isBlock() || this.isExpressionStatement() || this.isReturnStatement() || this.isSwitchStatement() || this.isThrowStatement() || this.isBreakStatement() || this.isContinueStatement() || this.isForOrForInStatement() || this.isEmptyStatement(inErrorRecovery) || this.isWhileStatement() || this.isWithStatement() || this.isDoStatement() || this.isTryStatement() || this.isDebuggerStatement();
            };

            ParserImpl.prototype.parseStatement = function () {
                if (this.currentNode() !== null && this.currentNode().isStatement()) {
                    return this.eatNode();
                }

                if (this.isVariableStatement()) {
                    return this.parseVariableStatement();
                } else if (this.isLabeledStatement()) {
                    return this.parseLabeledStatement();
                } else if (this.isFunctionDeclaration()) {
                    return this.parseFunctionDeclaration();
                } else if (this.isIfStatement()) {
                    return this.parseIfStatement();
                } else if (this.isBlock()) {
                    return this.parseBlock(false, false);
                } else if (this.isReturnStatement()) {
                    return this.parseReturnStatement();
                } else if (this.isSwitchStatement()) {
                    return this.parseSwitchStatement();
                } else if (this.isThrowStatement()) {
                    return this.parseThrowStatement();
                } else if (this.isBreakStatement()) {
                    return this.parseBreakStatement();
                } else if (this.isContinueStatement()) {
                    return this.parseContinueStatement();
                } else if (this.isForOrForInStatement()) {
                    return this.parseForOrForInStatement();
                } else if (this.isEmptyStatement(false)) {
                    return this.parseEmptyStatement();
                } else if (this.isWhileStatement()) {
                    return this.parseWhileStatement();
                } else if (this.isWithStatement()) {
                    return this.parseWithStatement();
                } else if (this.isDoStatement()) {
                    return this.parseDoStatement();
                } else if (this.isTryStatement()) {
                    return this.parseTryStatement();
                } else if (this.isDebuggerStatement()) {
                    return this.parseDebuggerStatement();
                } else {
                    return this.parseExpressionStatement();
                }
            };

            ParserImpl.prototype.isDebuggerStatement = function () {
                return this.currentToken().tokenKind === 19 /* DebuggerKeyword */;
            };

            ParserImpl.prototype.parseDebuggerStatement = function () {
                var debuggerKeyword = this.eatKeyword(19 /* DebuggerKeyword */);
                var semicolonToken = this.eatExplicitOrAutomaticSemicolon(false);

                return this.factory.debuggerStatement(debuggerKeyword, semicolonToken);
            };

            ParserImpl.prototype.isDoStatement = function () {
                return this.currentToken().tokenKind === 22 /* DoKeyword */;
            };

            ParserImpl.prototype.parseDoStatement = function () {
                var doKeyword = this.eatKeyword(22 /* DoKeyword */);
                var statement = this.parseStatement();
                var whileKeyword = this.eatKeyword(42 /* WhileKeyword */);
                var openParenToken = this.eatToken(72 /* OpenParenToken */);
                var condition = this.parseExpression(true);
                var closeParenToken = this.eatToken(73 /* CloseParenToken */);

                var semicolonToken = this.eatExplicitOrAutomaticSemicolon(true);

                return this.factory.doStatement(doKeyword, statement, whileKeyword, openParenToken, condition, closeParenToken, semicolonToken);
            };

            ParserImpl.prototype.isLabeledStatement = function () {
                return this.isIdentifier(this.currentToken()) && this.peekToken(1).tokenKind === 106 /* ColonToken */;
            };

            ParserImpl.prototype.parseLabeledStatement = function () {
                var identifier = this.eatIdentifierToken();
                var colonToken = this.eatToken(106 /* ColonToken */);
                var statement = this.parseStatement();

                return this.factory.labeledStatement(identifier, colonToken, statement);
            };

            ParserImpl.prototype.isTryStatement = function () {
                return this.currentToken().tokenKind === 38 /* TryKeyword */;
            };

            ParserImpl.prototype.parseTryStatement = function () {
                var tryKeyword = this.eatKeyword(38 /* TryKeyword */);

                var savedListParsingState = this.listParsingState;
                this.listParsingState |= 64 /* TryBlock_Statements */;
                var block = this.parseBlock(false, false);
                this.listParsingState = savedListParsingState;

                var catchClause = null;
                if (this.isCatchClause()) {
                    catchClause = this.parseCatchClause();
                }

                var finallyClause = null;
                if (catchClause === null || this.isFinallyClause()) {
                    finallyClause = this.parseFinallyClause();
                }

                return this.factory.tryStatement(tryKeyword, block, catchClause, finallyClause);
            };

            ParserImpl.prototype.isCatchClause = function () {
                return this.currentToken().tokenKind === 17 /* CatchKeyword */;
            };

            ParserImpl.prototype.parseCatchClause = function () {
                var catchKeyword = this.eatKeyword(17 /* CatchKeyword */);
                var openParenToken = this.eatToken(72 /* OpenParenToken */);
                var identifier = this.eatIdentifierToken();
                var typeAnnotation = this.parseOptionalTypeAnnotation(false);
                var closeParenToken = this.eatToken(73 /* CloseParenToken */);

                var savedListParsingState = this.listParsingState;
                this.listParsingState |= 128 /* CatchBlock_Statements */;
                var block = this.parseBlock(false, false);
                this.listParsingState = savedListParsingState;

                return this.factory.catchClause(catchKeyword, openParenToken, identifier, typeAnnotation, closeParenToken, block);
            };

            ParserImpl.prototype.isFinallyClause = function () {
                return this.currentToken().tokenKind === 25 /* FinallyKeyword */;
            };

            ParserImpl.prototype.parseFinallyClause = function () {
                var finallyKeyword = this.eatKeyword(25 /* FinallyKeyword */);
                var block = this.parseBlock(false, false);

                return this.factory.finallyClause(finallyKeyword, block);
            };

            ParserImpl.prototype.isWithStatement = function () {
                return this.currentToken().tokenKind === 43 /* WithKeyword */;
            };

            ParserImpl.prototype.parseWithStatement = function () {
                var withKeyword = this.eatKeyword(43 /* WithKeyword */);
                var openParenToken = this.eatToken(72 /* OpenParenToken */);
                var condition = this.parseExpression(true);
                var closeParenToken = this.eatToken(73 /* CloseParenToken */);
                var statement = this.parseStatement();

                return this.factory.withStatement(withKeyword, openParenToken, condition, closeParenToken, statement);
            };

            ParserImpl.prototype.isWhileStatement = function () {
                return this.currentToken().tokenKind === 42 /* WhileKeyword */;
            };

            ParserImpl.prototype.parseWhileStatement = function () {
                var whileKeyword = this.eatKeyword(42 /* WhileKeyword */);
                var openParenToken = this.eatToken(72 /* OpenParenToken */);
                var condition = this.parseExpression(true);
                var closeParenToken = this.eatToken(73 /* CloseParenToken */);
                var statement = this.parseStatement();

                return this.factory.whileStatement(whileKeyword, openParenToken, condition, closeParenToken, statement);
            };

            ParserImpl.prototype.isEmptyStatement = function (inErrorRecovery) {
                if (inErrorRecovery) {
                    return false;
                }

                return this.currentToken().tokenKind === 78 /* SemicolonToken */;
            };

            ParserImpl.prototype.parseEmptyStatement = function () {
                var semicolonToken = this.eatToken(78 /* SemicolonToken */);
                return this.factory.emptyStatement(semicolonToken);
            };

            ParserImpl.prototype.isForOrForInStatement = function () {
                return this.currentToken().tokenKind === 26 /* ForKeyword */;
            };

            ParserImpl.prototype.parseForOrForInStatement = function () {
                var forKeyword = this.eatKeyword(26 /* ForKeyword */);
                var openParenToken = this.eatToken(72 /* OpenParenToken */);

                var currentToken = this.currentToken();
                if (currentToken.tokenKind === 40 /* VarKeyword */) {
                    return this.parseForOrForInStatementWithVariableDeclaration(forKeyword, openParenToken);
                } else if (currentToken.tokenKind === 78 /* SemicolonToken */) {
                    return this.parseForStatement(forKeyword, openParenToken);
                } else {
                    return this.parseForOrForInStatementWithInitializer(forKeyword, openParenToken);
                }
            };

            ParserImpl.prototype.parseForOrForInStatementWithVariableDeclaration = function (forKeyword, openParenToken) {
                var variableDeclaration = this.parseVariableDeclaration(false);

                if (this.currentToken().tokenKind === 29 /* InKeyword */) {
                    return this.parseForInStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, variableDeclaration, null);
                }

                return this.parseForStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, variableDeclaration, null);
            };

            ParserImpl.prototype.parseForInStatementWithVariableDeclarationOrInitializer = function (forKeyword, openParenToken, variableDeclaration, initializer) {
                var inKeyword = this.eatKeyword(29 /* InKeyword */);
                var expression = this.parseExpression(true);
                var closeParenToken = this.eatToken(73 /* CloseParenToken */);
                var statement = this.parseStatement();

                return this.factory.forInStatement(forKeyword, openParenToken, variableDeclaration, initializer, inKeyword, expression, closeParenToken, statement);
            };

            ParserImpl.prototype.parseForOrForInStatementWithInitializer = function (forKeyword, openParenToken) {
                var initializer = this.parseExpression(false);
                if (this.currentToken().tokenKind === 29 /* InKeyword */) {
                    return this.parseForInStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, null, initializer);
                } else {
                    return this.parseForStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, null, initializer);
                }
            };

            ParserImpl.prototype.parseForStatement = function (forKeyword, openParenToken) {
                var initializer = null;

                if (this.currentToken().tokenKind !== 78 /* SemicolonToken */ && this.currentToken().tokenKind !== 73 /* CloseParenToken */ && this.currentToken().tokenKind !== 10 /* EndOfFileToken */) {
                    initializer = this.parseExpression(false);
                }

                return this.parseForStatementWithVariableDeclarationOrInitializer(forKeyword, openParenToken, null, initializer);
            };

            ParserImpl.prototype.parseForStatementWithVariableDeclarationOrInitializer = function (forKeyword, openParenToken, variableDeclaration, initializer) {
                var firstSemicolonToken = this.eatToken(78 /* SemicolonToken */);

                var condition = null;
                if (this.currentToken().tokenKind !== 78 /* SemicolonToken */ && this.currentToken().tokenKind !== 73 /* CloseParenToken */ && this.currentToken().tokenKind !== 10 /* EndOfFileToken */) {
                    condition = this.parseExpression(true);
                }

                var secondSemicolonToken = this.eatToken(78 /* SemicolonToken */);

                var incrementor = null;
                if (this.currentToken().tokenKind !== 73 /* CloseParenToken */ && this.currentToken().tokenKind !== 10 /* EndOfFileToken */) {
                    incrementor = this.parseExpression(true);
                }

                var closeParenToken = this.eatToken(73 /* CloseParenToken */);
                var statement = this.parseStatement();

                return this.factory.forStatement(forKeyword, openParenToken, variableDeclaration, initializer, firstSemicolonToken, condition, secondSemicolonToken, incrementor, closeParenToken, statement);
            };

            ParserImpl.prototype.isBreakStatement = function () {
                return this.currentToken().tokenKind === 15 /* BreakKeyword */;
            };

            ParserImpl.prototype.parseBreakStatement = function () {
                var breakKeyword = this.eatKeyword(15 /* BreakKeyword */);

                var identifier = null;
                if (!this.canEatExplicitOrAutomaticSemicolon(false)) {
                    if (this.isIdentifier(this.currentToken())) {
                        identifier = this.eatIdentifierToken();
                    }
                }

                var semicolon = this.eatExplicitOrAutomaticSemicolon(false);
                return this.factory.breakStatement(breakKeyword, identifier, semicolon);
            };

            ParserImpl.prototype.isContinueStatement = function () {
                return this.currentToken().tokenKind === 18 /* ContinueKeyword */;
            };

            ParserImpl.prototype.parseContinueStatement = function () {
                var continueKeyword = this.eatKeyword(18 /* ContinueKeyword */);

                var identifier = null;
                if (!this.canEatExplicitOrAutomaticSemicolon(false)) {
                    if (this.isIdentifier(this.currentToken())) {
                        identifier = this.eatIdentifierToken();
                    }
                }

                var semicolon = this.eatExplicitOrAutomaticSemicolon(false);
                return this.factory.continueStatement(continueKeyword, identifier, semicolon);
            };

            ParserImpl.prototype.isSwitchStatement = function () {
                return this.currentToken().tokenKind === 34 /* SwitchKeyword */;
            };

            ParserImpl.prototype.parseSwitchStatement = function () {
                var switchKeyword = this.eatKeyword(34 /* SwitchKeyword */);
                var openParenToken = this.eatToken(72 /* OpenParenToken */);
                var expression = this.parseExpression(true);
                var closeParenToken = this.eatToken(73 /* CloseParenToken */);

                var openBraceToken = this.eatToken(70 /* OpenBraceToken */);

                var switchClauses = TypeScript.Syntax.emptyList;
                if (openBraceToken.width() > 0) {
                    var result = this.parseSyntaxList(8 /* SwitchStatement_SwitchClauses */);
                    switchClauses = result.list;
                    openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);
                }

                var closeBraceToken = this.eatToken(71 /* CloseBraceToken */);
                return this.factory.switchStatement(switchKeyword, openParenToken, expression, closeParenToken, openBraceToken, switchClauses, closeBraceToken);
            };

            ParserImpl.prototype.isCaseSwitchClause = function () {
                return this.currentToken().tokenKind === 16 /* CaseKeyword */;
            };

            ParserImpl.prototype.isDefaultSwitchClause = function () {
                return this.currentToken().tokenKind === 20 /* DefaultKeyword */;
            };

            ParserImpl.prototype.isSwitchClause = function () {
                if (this.currentNode() !== null && this.currentNode().isSwitchClause()) {
                    return true;
                }

                return this.isCaseSwitchClause() || this.isDefaultSwitchClause();
            };

            ParserImpl.prototype.parseSwitchClause = function () {
                if (this.currentNode() !== null && this.currentNode().isSwitchClause()) {
                    return this.eatNode();
                }

                if (this.isCaseSwitchClause()) {
                    return this.parseCaseSwitchClause();
                } else if (this.isDefaultSwitchClause()) {
                    return this.parseDefaultSwitchClause();
                } else {
                    throw TypeScript.Errors.invalidOperation();
                }
            };

            ParserImpl.prototype.parseCaseSwitchClause = function () {
                var caseKeyword = this.eatKeyword(16 /* CaseKeyword */);
                var expression = this.parseExpression(true);
                var colonToken = this.eatToken(106 /* ColonToken */);
                var statements = TypeScript.Syntax.emptyList;

                if (colonToken.fullWidth() > 0) {
                    var result = this.parseSyntaxList(16 /* SwitchClause_Statements */);
                    statements = result.list;
                    colonToken = this.addSkippedTokensAfterToken(colonToken, result.skippedTokens);
                }

                return this.factory.caseSwitchClause(caseKeyword, expression, colonToken, statements);
            };

            ParserImpl.prototype.parseDefaultSwitchClause = function () {
                var defaultKeyword = this.eatKeyword(20 /* DefaultKeyword */);
                var colonToken = this.eatToken(106 /* ColonToken */);
                var statements = TypeScript.Syntax.emptyList;

                if (colonToken.fullWidth() > 0) {
                    var result = this.parseSyntaxList(16 /* SwitchClause_Statements */);
                    statements = result.list;
                    colonToken = this.addSkippedTokensAfterToken(colonToken, result.skippedTokens);
                }

                return this.factory.defaultSwitchClause(defaultKeyword, colonToken, statements);
            };

            ParserImpl.prototype.isThrowStatement = function () {
                return this.currentToken().tokenKind === 36 /* ThrowKeyword */;
            };

            ParserImpl.prototype.parseThrowStatement = function () {
                var throwKeyword = this.eatKeyword(36 /* ThrowKeyword */);

                var expression = null;
                if (this.canEatExplicitOrAutomaticSemicolon(false)) {
                    var token = this.createMissingToken(11 /* IdentifierName */, null);
                    expression = token;
                } else {
                    expression = this.parseExpression(true);
                }

                var semicolonToken = this.eatExplicitOrAutomaticSemicolon(false);

                return this.factory.throwStatement(throwKeyword, expression, semicolonToken);
            };

            ParserImpl.prototype.isReturnStatement = function () {
                return this.currentToken().tokenKind === 33 /* ReturnKeyword */;
            };

            ParserImpl.prototype.parseReturnStatement = function () {
                var returnKeyword = this.eatKeyword(33 /* ReturnKeyword */);

                var expression = null;
                if (!this.canEatExplicitOrAutomaticSemicolon(false)) {
                    expression = this.parseExpression(true);
                }

                var semicolonToken = this.eatExplicitOrAutomaticSemicolon(false);

                return this.factory.returnStatement(returnKeyword, expression, semicolonToken);
            };

            ParserImpl.prototype.isExpressionStatement = function () {
                var currentToken = this.currentToken();

                var kind = currentToken.tokenKind;
                if (kind === 70 /* OpenBraceToken */ || kind === 27 /* FunctionKeyword */) {
                    return false;
                }

                return this.isExpression();
            };

            ParserImpl.prototype.isAssignmentOrOmittedExpression = function () {
                if (this.currentToken().tokenKind === 79 /* CommaToken */) {
                    return true;
                }

                return this.isExpression();
            };

            ParserImpl.prototype.parseAssignmentOrOmittedExpression = function () {
                if (this.currentToken().tokenKind === 79 /* CommaToken */) {
                    return this.factory.omittedExpression();
                }

                return this.parseAssignmentExpression(true);
            };

            ParserImpl.prototype.isExpression = function () {
                var currentToken = this.currentToken();
                var kind = currentToken.tokenKind;

                switch (kind) {
                    case 13 /* NumericLiteral */:
                    case 14 /* StringLiteral */:
                    case 12 /* RegularExpressionLiteral */:
                        return true;

                    case 74 /* OpenBracketToken */:
                    case 72 /* OpenParenToken */:
                        return true;

                    case 80 /* LessThanToken */:
                        return true;

                    case 93 /* PlusPlusToken */:
                    case 94 /* MinusMinusToken */:
                    case 89 /* PlusToken */:
                    case 90 /* MinusToken */:
                    case 102 /* TildeToken */:
                    case 101 /* ExclamationToken */:
                        return true;

                    case 70 /* OpenBraceToken */:
                        return true;

                    case 85 /* EqualsGreaterThanToken */:
                        return true;

                    case 118 /* SlashToken */:
                    case 119 /* SlashEqualsToken */:
                        return true;

                    case 50 /* SuperKeyword */:
                    case 35 /* ThisKeyword */:
                    case 37 /* TrueKeyword */:
                    case 24 /* FalseKeyword */:
                    case 32 /* NullKeyword */:
                        return true;

                    case 31 /* NewKeyword */:
                        return true;

                    case 21 /* DeleteKeyword */:
                    case 41 /* VoidKeyword */:
                    case 39 /* TypeOfKeyword */:
                        return true;

                    case 27 /* FunctionKeyword */:
                        return true;
                }

                if (this.isIdentifier(this.currentToken())) {
                    return true;
                }

                return false;
            };

            ParserImpl.prototype.parseExpressionStatement = function () {
                var expression = this.parseExpression(true);

                var semicolon = this.eatExplicitOrAutomaticSemicolon(false);

                return this.factory.expressionStatement(expression, semicolon);
            };

            ParserImpl.prototype.isIfStatement = function () {
                return this.currentToken().tokenKind === 28 /* IfKeyword */;
            };

            ParserImpl.prototype.parseIfStatement = function () {
                var ifKeyword = this.eatKeyword(28 /* IfKeyword */);
                var openParenToken = this.eatToken(72 /* OpenParenToken */);
                var condition = this.parseExpression(true);
                var closeParenToken = this.eatToken(73 /* CloseParenToken */);
                var statement = this.parseStatement();

                var elseClause = null;
                if (this.isElseClause()) {
                    elseClause = this.parseElseClause();
                }

                return this.factory.ifStatement(ifKeyword, openParenToken, condition, closeParenToken, statement, elseClause);
            };

            ParserImpl.prototype.isElseClause = function () {
                return this.currentToken().tokenKind === 23 /* ElseKeyword */;
            };

            ParserImpl.prototype.parseElseClause = function () {
                var elseKeyword = this.eatKeyword(23 /* ElseKeyword */);
                var statement = this.parseStatement();

                return this.factory.elseClause(elseKeyword, statement);
            };

            ParserImpl.prototype.isVariableStatement = function () {
                var index = this.modifierCount();
                return this.peekToken(index).tokenKind === 40 /* VarKeyword */;
            };

            ParserImpl.prototype.parseVariableStatement = function () {
                var modifiers = this.parseModifiers();
                var variableDeclaration = this.parseVariableDeclaration(true);
                var semicolonToken = this.eatExplicitOrAutomaticSemicolon(false);

                return this.factory.variableStatement(modifiers, variableDeclaration, semicolonToken);
            };

            ParserImpl.prototype.parseVariableDeclaration = function (allowIn) {
                var varKeyword = this.eatKeyword(40 /* VarKeyword */);

                var listParsingState = allowIn ? 4096 /* VariableDeclaration_VariableDeclarators_AllowIn */ : 8192 /* VariableDeclaration_VariableDeclarators_DisallowIn */;

                var result = this.parseSeparatedSyntaxList(listParsingState);
                var variableDeclarators = result.list;
                varKeyword = this.addSkippedTokensAfterToken(varKeyword, result.skippedTokens);

                return this.factory.variableDeclaration(varKeyword, variableDeclarators);
            };

            ParserImpl.prototype.isVariableDeclarator = function () {
                if (this.currentNode() !== null && this.currentNode().kind() === 224 /* VariableDeclarator */) {
                    return true;
                }

                return this.isIdentifier(this.currentToken());
            };

            ParserImpl.prototype.canReuseVariableDeclaratorNode = function (node) {
                if (node === null || node.kind() !== 224 /* VariableDeclarator */) {
                    return false;
                }

                var variableDeclarator = node;
                return variableDeclarator.equalsValueClause === null;
            };

            ParserImpl.prototype.parseVariableDeclarator = function (allowIn, allowPropertyName) {
                if (this.canReuseVariableDeclaratorNode(this.currentNode())) {
                    return this.eatNode();
                }

                var propertyName = allowPropertyName ? this.eatPropertyName() : this.eatIdentifierToken();
                var equalsValueClause = null;
                var typeAnnotation = null;

                if (propertyName.width() > 0) {
                    typeAnnotation = this.parseOptionalTypeAnnotation(false);

                    if (this.isEqualsValueClause(false)) {
                        equalsValueClause = this.parseEqualsValueClause(allowIn);
                    }
                }

                return this.factory.variableDeclarator(propertyName, typeAnnotation, equalsValueClause);
            };

            ParserImpl.prototype.isColonValueClause = function () {
                return this.currentToken().tokenKind === 106 /* ColonToken */;
            };

            ParserImpl.prototype.isEqualsValueClause = function (inParameter) {
                var token0 = this.currentToken();
                if (token0.tokenKind === 107 /* EqualsToken */) {
                    return true;
                }

                if (!this.previousToken().hasTrailingNewLine()) {
                    if (token0.tokenKind === 85 /* EqualsGreaterThanToken */) {
                        return false;
                    }

                    if (token0.tokenKind === 70 /* OpenBraceToken */ && inParameter) {
                        return false;
                    }

                    return this.isExpression();
                }

                return false;
            };

            ParserImpl.prototype.parseEqualsValueClause = function (allowIn) {
                var equalsToken = this.eatToken(107 /* EqualsToken */);
                var value = this.parseAssignmentExpression(allowIn);

                return this.factory.equalsValueClause(equalsToken, value);
            };

            ParserImpl.prototype.parseExpression = function (allowIn) {
                return this.parseSubExpression(0, allowIn);
            };

            ParserImpl.prototype.parseAssignmentExpression = function (allowIn) {
                return this.parseSubExpression(2 /* AssignmentExpressionPrecedence */, allowIn);
            };

            ParserImpl.prototype.parseUnaryExpression = function () {
                var currentTokenKind = this.currentToken().tokenKind;
                if (TypeScript.SyntaxFacts.isPrefixUnaryExpressionOperatorToken(currentTokenKind)) {
                    var operatorKind = TypeScript.SyntaxFacts.getPrefixUnaryExpressionFromOperatorToken(currentTokenKind);

                    var operatorToken = this.eatAnyToken();

                    var operand = this.parseUnaryExpression();
                    return this.factory.prefixUnaryExpression(operatorKind, operatorToken, operand);
                } else {
                    return this.parseTerm(false);
                }
            };

            ParserImpl.prototype.parseSubExpression = function (precedence, allowIn) {
                var leftOperand = this.parseUnaryExpression();
                leftOperand = this.parseBinaryOrConditionalExpressions(precedence, allowIn, leftOperand);

                return leftOperand;
            };

            ParserImpl.prototype.parseBinaryOrConditionalExpressions = function (precedence, allowIn, leftOperand) {
                while (true) {
                    var token0 = this.currentToken();
                    var token0Kind = token0.tokenKind;

                    if (TypeScript.SyntaxFacts.isBinaryExpressionOperatorToken(token0Kind)) {
                        if (token0Kind === 29 /* InKeyword */ && !allowIn) {
                            break;
                        }

                        var mergedToken = this.tryMergeBinaryExpressionTokens();
                        var tokenKind = mergedToken === null ? token0Kind : mergedToken.syntaxKind;

                        var binaryExpressionKind = TypeScript.SyntaxFacts.getBinaryExpressionFromOperatorToken(tokenKind);
                        var newPrecedence = ParserImpl.getPrecedence(binaryExpressionKind);

                        if (newPrecedence < precedence) {
                            break;
                        }

                        if (newPrecedence === precedence && !this.isRightAssociative(binaryExpressionKind)) {
                            break;
                        }

                        var operatorToken = mergedToken === null ? token0 : TypeScript.Syntax.token(mergedToken.syntaxKind).withLeadingTrivia(token0.leadingTrivia()).withTrailingTrivia(this.peekToken(mergedToken.tokenCount - 1).trailingTrivia());

                        var skipCount = mergedToken === null ? 1 : mergedToken.tokenCount;
                        for (var i = 0; i < skipCount; i++) {
                            this.eatAnyToken();
                        }

                        leftOperand = this.factory.binaryExpression(binaryExpressionKind, leftOperand, operatorToken, this.parseSubExpression(newPrecedence, allowIn));
                        continue;
                    }

                    if (token0Kind === 105 /* QuestionToken */ && precedence <= 3 /* ConditionalExpressionPrecedence */) {
                        var questionToken = this.eatToken(105 /* QuestionToken */);

                        var whenTrueExpression = this.parseAssignmentExpression(allowIn);
                        var colon = this.eatToken(106 /* ColonToken */);

                        var whenFalseExpression = this.parseAssignmentExpression(allowIn);
                        leftOperand = this.factory.conditionalExpression(leftOperand, questionToken, whenTrueExpression, colon, whenFalseExpression);
                        continue;
                    }

                    break;
                }

                return leftOperand;
            };

            ParserImpl.prototype.tryMergeBinaryExpressionTokens = function () {
                var token0 = this.currentToken();

                if (token0.tokenKind === 81 /* GreaterThanToken */ && !token0.hasTrailingTrivia()) {
                    var storage = this.mergeTokensStorage;
                    storage[0] = 0 /* None */;
                    storage[1] = 0 /* None */;
                    storage[2] = 0 /* None */;

                    for (var i = 0; i < storage.length; i++) {
                        var nextToken = this.peekToken(i + 1);

                        if (!nextToken.hasLeadingTrivia()) {
                            storage[i] = nextToken.tokenKind;
                        }

                        if (nextToken.hasTrailingTrivia()) {
                            break;
                        }
                    }

                    if (storage[0] === 81 /* GreaterThanToken */) {
                        if (storage[1] === 81 /* GreaterThanToken */) {
                            if (storage[2] === 107 /* EqualsToken */) {
                                return { tokenCount: 4, syntaxKind: 114 /* GreaterThanGreaterThanGreaterThanEqualsToken */ };
                            } else {
                                return { tokenCount: 3, syntaxKind: 97 /* GreaterThanGreaterThanGreaterThanToken */ };
                            }
                        } else if (storage[1] === 107 /* EqualsToken */) {
                            return { tokenCount: 3, syntaxKind: 113 /* GreaterThanGreaterThanEqualsToken */ };
                        } else {
                            return { tokenCount: 2, syntaxKind: 96 /* GreaterThanGreaterThanToken */ };
                        }
                    } else if (storage[0] === 107 /* EqualsToken */) {
                        return { tokenCount: 2, syntaxKind: 83 /* GreaterThanEqualsToken */ };
                    }
                }

                return null;
            };

            ParserImpl.prototype.isRightAssociative = function (expressionKind) {
                switch (expressionKind) {
                    case 173 /* AssignmentExpression */:
                    case 174 /* AddAssignmentExpression */:
                    case 175 /* SubtractAssignmentExpression */:
                    case 176 /* MultiplyAssignmentExpression */:
                    case 177 /* DivideAssignmentExpression */:
                    case 178 /* ModuloAssignmentExpression */:
                    case 179 /* AndAssignmentExpression */:
                    case 180 /* ExclusiveOrAssignmentExpression */:
                    case 181 /* OrAssignmentExpression */:
                    case 182 /* LeftShiftAssignmentExpression */:
                    case 183 /* SignedRightShiftAssignmentExpression */:
                    case 184 /* UnsignedRightShiftAssignmentExpression */:
                        return true;
                    default:
                        return false;
                }
            };

            ParserImpl.prototype.parseTerm = function (inObjectCreation) {
                var term = this.parseTermWorker();
                if (term === null) {
                    return this.eatIdentifierToken();
                }

                return this.parsePostFixExpression(term, inObjectCreation);
            };

            ParserImpl.prototype.parsePostFixExpression = function (expression, inObjectCreation) {
                while (true) {
                    var currentTokenKind = this.currentToken().tokenKind;
                    switch (currentTokenKind) {
                        case 72 /* OpenParenToken */:
                            if (inObjectCreation) {
                                return expression;
                            }

                            expression = this.factory.invocationExpression(expression, this.parseArgumentList(null));
                            continue;

                        case 80 /* LessThanToken */:
                            if (inObjectCreation) {
                                return expression;
                            }

                            var argumentList = this.tryParseArgumentList();
                            if (argumentList !== null) {
                                expression = this.factory.invocationExpression(expression, argumentList);
                                continue;
                            }

                            break;

                        case 74 /* OpenBracketToken */:
                            expression = this.parseElementAccessExpression(expression, inObjectCreation);
                            continue;

                        case 93 /* PlusPlusToken */:
                        case 94 /* MinusMinusToken */:
                            if (this.previousToken() !== null && this.previousToken().hasTrailingNewLine()) {
                                break;
                            }

                            expression = this.factory.postfixUnaryExpression(TypeScript.SyntaxFacts.getPostfixUnaryExpressionFromOperatorToken(currentTokenKind), expression, this.eatAnyToken());
                            continue;

                        case 76 /* DotToken */:
                            expression = this.factory.memberAccessExpression(expression, this.eatToken(76 /* DotToken */), this.eatIdentifierNameToken());
                            continue;
                    }

                    return expression;
                }
            };

            ParserImpl.prototype.tryParseArgumentList = function () {
                var typeArgumentList = null;

                if (this.currentToken().tokenKind === 80 /* LessThanToken */) {
                    var rewindPoint = this.getRewindPoint();
                    try  {
                        typeArgumentList = this.tryParseTypeArgumentList(true);
                        var token0 = this.currentToken();

                        var isOpenParen = token0.tokenKind === 72 /* OpenParenToken */;
                        var isDot = token0.tokenKind === 76 /* DotToken */;
                        var isOpenParenOrDot = isOpenParen || isDot;
                        if (typeArgumentList === null || !isOpenParenOrDot) {
                            this.rewind(rewindPoint);
                            return null;
                        }

                        if (isDot) {
                            var diagnostic = new TypeScript.Diagnostic(this.fileName, this.currentTokenStart(), token0.width(), TypeScript.DiagnosticCode.A_parameter_list_must_follow_a_generic_type_argument_list_expected, null);
                            this.addDiagnostic(diagnostic);

                            return this.factory.argumentList(typeArgumentList, TypeScript.Syntax.emptyToken(72 /* OpenParenToken */), TypeScript.Syntax.emptySeparatedList, TypeScript.Syntax.emptyToken(73 /* CloseParenToken */));
                        }
                    } finally {
                        this.releaseRewindPoint(rewindPoint);
                    }
                }

                if (this.currentToken().tokenKind === 72 /* OpenParenToken */) {
                    return this.parseArgumentList(typeArgumentList);
                }

                return null;
            };

            ParserImpl.prototype.parseArgumentList = function (typeArgumentList) {
                var openParenToken = this.eatToken(72 /* OpenParenToken */);
                var arguments = TypeScript.Syntax.emptySeparatedList;

                if (openParenToken.fullWidth() > 0) {
                    var result = this.parseSeparatedSyntaxList(16384 /* ArgumentList_AssignmentExpressions */);
                    arguments = result.list;
                    openParenToken = this.addSkippedTokensAfterToken(openParenToken, result.skippedTokens);
                }

                var closeParenToken = this.eatToken(73 /* CloseParenToken */);

                return this.factory.argumentList(typeArgumentList, openParenToken, arguments, closeParenToken);
            };

            ParserImpl.prototype.parseElementAccessExpression = function (expression, inObjectCreation) {
                var start = this.currentTokenStart();
                var openBracketToken = this.eatToken(74 /* OpenBracketToken */);
                var argumentExpression;

                if (this.currentToken().tokenKind === 75 /* CloseBracketToken */ && inObjectCreation) {
                    var end = this.currentTokenStart() + this.currentToken().width();
                    var diagnostic = new TypeScript.Diagnostic(this.fileName, start, end - start, TypeScript.DiagnosticCode.new_T_cannot_be_used_to_create_an_array_Use_new_Array_T_instead, null);
                    this.addDiagnostic(diagnostic);

                    argumentExpression = TypeScript.Syntax.emptyToken(11 /* IdentifierName */);
                } else {
                    argumentExpression = this.parseExpression(true);
                }

                var closeBracketToken = this.eatToken(75 /* CloseBracketToken */);

                return this.factory.elementAccessExpression(expression, openBracketToken, argumentExpression, closeBracketToken);
            };

            ParserImpl.prototype.parseTermWorker = function () {
                var currentToken = this.currentToken();

                if (currentToken.tokenKind === 85 /* EqualsGreaterThanToken */) {
                    return this.parseSimpleArrowFunctionExpression();
                }

                if (this.isIdentifier(currentToken)) {
                    if (this.isSimpleArrowFunctionExpression()) {
                        return this.parseSimpleArrowFunctionExpression();
                    } else {
                        var identifier = this.eatIdentifierToken();
                        return identifier;
                    }
                }

                var currentTokenKind = currentToken.tokenKind;
                switch (currentTokenKind) {
                    case 35 /* ThisKeyword */:
                        return this.parseThisExpression();

                    case 37 /* TrueKeyword */:
                    case 24 /* FalseKeyword */:
                        return this.parseLiteralExpression();

                    case 32 /* NullKeyword */:
                        return this.parseLiteralExpression();

                    case 31 /* NewKeyword */:
                        return this.parseObjectCreationExpression();

                    case 27 /* FunctionKeyword */:
                        return this.parseFunctionExpression();

                    case 50 /* SuperKeyword */:
                        return this.parseSuperExpression();

                    case 39 /* TypeOfKeyword */:
                        return this.parseTypeOfExpression();

                    case 21 /* DeleteKeyword */:
                        return this.parseDeleteExpression();

                    case 41 /* VoidKeyword */:
                        return this.parseVoidExpression();

                    case 13 /* NumericLiteral */:
                        return this.parseLiteralExpression();

                    case 12 /* RegularExpressionLiteral */:
                        return this.parseLiteralExpression();

                    case 14 /* StringLiteral */:
                        return this.parseLiteralExpression();

                    case 74 /* OpenBracketToken */:
                        return this.parseArrayLiteralExpression();

                    case 70 /* OpenBraceToken */:
                        return this.parseObjectLiteralExpression();

                    case 72 /* OpenParenToken */:
                        return this.parseParenthesizedOrArrowFunctionExpression();

                    case 80 /* LessThanToken */:
                        return this.parseCastOrArrowFunctionExpression();

                    case 118 /* SlashToken */:
                    case 119 /* SlashEqualsToken */:
                        var result = this.tryReparseDivideAsRegularExpression();
                        if (result !== null) {
                            return result;
                        }
                        break;
                }

                return null;
            };

            ParserImpl.prototype.tryReparseDivideAsRegularExpression = function () {
                var currentToken = this.currentToken();

                if (this.previousToken() !== null) {
                    var previousTokenKind = this.previousToken().tokenKind;
                    switch (previousTokenKind) {
                        case 11 /* IdentifierName */:
                            return null;

                        case 35 /* ThisKeyword */:
                        case 37 /* TrueKeyword */:
                        case 24 /* FalseKeyword */:
                            return null;

                        case 14 /* StringLiteral */:
                        case 13 /* NumericLiteral */:
                        case 12 /* RegularExpressionLiteral */:
                        case 93 /* PlusPlusToken */:
                        case 94 /* MinusMinusToken */:
                        case 75 /* CloseBracketToken */:
                        case 71 /* CloseBraceToken */:
                            return null;
                    }
                }

                currentToken = this.currentTokenAllowingRegularExpression();

                if (currentToken.tokenKind === 118 /* SlashToken */ || currentToken.tokenKind === 119 /* SlashEqualsToken */) {
                    return null;
                } else if (currentToken.tokenKind === 12 /* RegularExpressionLiteral */) {
                    return this.parseLiteralExpression();
                } else {
                    throw TypeScript.Errors.invalidOperation();
                }
            };

            ParserImpl.prototype.parseTypeOfExpression = function () {
                var typeOfKeyword = this.eatKeyword(39 /* TypeOfKeyword */);
                var expression = this.parseUnaryExpression();

                return this.factory.typeOfExpression(typeOfKeyword, expression);
            };

            ParserImpl.prototype.parseDeleteExpression = function () {
                var deleteKeyword = this.eatKeyword(21 /* DeleteKeyword */);
                var expression = this.parseUnaryExpression();

                return this.factory.deleteExpression(deleteKeyword, expression);
            };

            ParserImpl.prototype.parseVoidExpression = function () {
                var voidKeyword = this.eatKeyword(41 /* VoidKeyword */);
                var expression = this.parseUnaryExpression();

                return this.factory.voidExpression(voidKeyword, expression);
            };

            ParserImpl.prototype.parseSuperExpression = function () {
                var superKeyword = this.eatKeyword(50 /* SuperKeyword */);
                return superKeyword;
            };

            ParserImpl.prototype.parseFunctionExpression = function () {
                var functionKeyword = this.eatKeyword(27 /* FunctionKeyword */);
                var identifier = null;

                if (this.isIdentifier(this.currentToken())) {
                    identifier = this.eatIdentifierToken();
                }

                var callSignature = this.parseCallSignature(false);
                var block = this.parseBlock(false, true);

                return this.factory.functionExpression(functionKeyword, identifier, callSignature, block);
            };

            ParserImpl.prototype.parseObjectCreationExpression = function () {
                var newKeyword = this.eatKeyword(31 /* NewKeyword */);

                var expression = this.parseTerm(true);
                var argumentList = this.tryParseArgumentList();

                return this.factory.objectCreationExpression(newKeyword, expression, argumentList);
            };

            ParserImpl.prototype.parseCastOrArrowFunctionExpression = function () {
                var rewindPoint = this.getRewindPoint();
                try  {
                    var arrowFunction = this.tryParseArrowFunctionExpression();
                    if (arrowFunction !== null) {
                        return arrowFunction;
                    }

                    this.rewind(rewindPoint);
                    return this.parseCastExpression();
                } finally {
                    this.releaseRewindPoint(rewindPoint);
                }
            };

            ParserImpl.prototype.parseCastExpression = function () {
                var lessThanToken = this.eatToken(80 /* LessThanToken */);
                var type = this.parseType();
                var greaterThanToken = this.eatToken(81 /* GreaterThanToken */);
                var expression = this.parseUnaryExpression();

                return this.factory.castExpression(lessThanToken, type, greaterThanToken, expression);
            };

            ParserImpl.prototype.parseParenthesizedOrArrowFunctionExpression = function () {
                var result = this.tryParseArrowFunctionExpression();
                if (result !== null) {
                    return result;
                }

                var openParenToken = this.eatToken(72 /* OpenParenToken */);
                var expression = this.parseExpression(true);
                var closeParenToken = this.eatToken(73 /* CloseParenToken */);

                return this.factory.parenthesizedExpression(openParenToken, expression, closeParenToken);
            };

            ParserImpl.prototype.tryParseArrowFunctionExpression = function () {
                var tokenKind = this.currentToken().tokenKind;

                if (this.isDefinitelyArrowFunctionExpression()) {
                    return this.parseParenthesizedArrowFunctionExpression(false);
                }

                if (!this.isPossiblyArrowFunctionExpression()) {
                    return null;
                }

                var rewindPoint = this.getRewindPoint();
                try  {
                    var arrowFunction = this.parseParenthesizedArrowFunctionExpression(true);
                    if (arrowFunction === null) {
                        this.rewind(rewindPoint);
                    }
                    return arrowFunction;
                } finally {
                    this.releaseRewindPoint(rewindPoint);
                }
            };

            ParserImpl.prototype.parseParenthesizedArrowFunctionExpression = function (requireArrow) {
                var currentToken = this.currentToken();

                var callSignature = this.parseCallSignature(true);

                if (requireArrow && this.currentToken().tokenKind !== 85 /* EqualsGreaterThanToken */) {
                    return null;
                }

                var equalsGreaterThanToken = this.eatToken(85 /* EqualsGreaterThanToken */);
                var body = this.parseArrowFunctionBody();

                return this.factory.parenthesizedArrowFunctionExpression(callSignature, equalsGreaterThanToken, body);
            };

            ParserImpl.prototype.parseArrowFunctionBody = function () {
                if (this.isBlock()) {
                    return this.parseBlock(false, false);
                } else {
                    return this.parseAssignmentExpression(true);
                }
            };

            ParserImpl.prototype.isSimpleArrowFunctionExpression = function () {
                if (this.currentToken().tokenKind === 85 /* EqualsGreaterThanToken */) {
                    return true;
                }

                return this.isIdentifier(this.currentToken()) && this.peekToken(1).tokenKind === 85 /* EqualsGreaterThanToken */;
            };

            ParserImpl.prototype.parseSimpleArrowFunctionExpression = function () {
                var identifier = this.eatIdentifierToken();
                var equalsGreaterThanToken = this.eatToken(85 /* EqualsGreaterThanToken */);
                var body = this.parseArrowFunctionBody();

                return this.factory.simpleArrowFunctionExpression(identifier, equalsGreaterThanToken, body);
            };

            ParserImpl.prototype.isBlock = function () {
                return this.currentToken().tokenKind === 70 /* OpenBraceToken */;
            };

            ParserImpl.prototype.isDefinitelyArrowFunctionExpression = function () {
                var token0 = this.currentToken();
                if (token0.tokenKind !== 72 /* OpenParenToken */) {
                    return false;
                }

                var token1 = this.peekToken(1);
                var token2;

                if (token1.tokenKind === 73 /* CloseParenToken */) {
                    token2 = this.peekToken(2);
                    return token2.tokenKind === 106 /* ColonToken */ || token2.tokenKind === 85 /* EqualsGreaterThanToken */ || token2.tokenKind === 70 /* OpenBraceToken */;
                }

                if (token1.tokenKind === 77 /* DotDotDotToken */) {
                    return true;
                }

                if (!this.isIdentifier(token1)) {
                    return false;
                }

                token2 = this.peekToken(2);
                if (token2.tokenKind === 106 /* ColonToken */) {
                    return true;
                }

                var token3 = this.peekToken(3);
                if (token2.tokenKind === 105 /* QuestionToken */) {
                    if (token3.tokenKind === 106 /* ColonToken */ || token3.tokenKind === 73 /* CloseParenToken */ || token3.tokenKind === 79 /* CommaToken */) {
                        return true;
                    }
                }

                if (token2.tokenKind === 73 /* CloseParenToken */) {
                    if (token3.tokenKind === 85 /* EqualsGreaterThanToken */) {
                        return true;
                    }
                }

                return false;
            };

            ParserImpl.prototype.isPossiblyArrowFunctionExpression = function () {
                var token0 = this.currentToken();
                if (token0.tokenKind !== 72 /* OpenParenToken */) {
                    return true;
                }

                var token1 = this.peekToken(1);

                if (!this.isIdentifier(token1)) {
                    return false;
                }

                var token2 = this.peekToken(2);
                if (token2.tokenKind === 107 /* EqualsToken */) {
                    return true;
                }

                if (token2.tokenKind === 79 /* CommaToken */) {
                    return true;
                }

                if (token2.tokenKind === 73 /* CloseParenToken */) {
                    var token3 = this.peekToken(3);
                    if (token3.tokenKind === 106 /* ColonToken */) {
                        return true;
                    }
                }

                return false;
            };

            ParserImpl.prototype.parseObjectLiteralExpression = function () {
                var openBraceToken = this.eatToken(70 /* OpenBraceToken */);

                var result = this.parseSeparatedSyntaxList(32768 /* ObjectLiteralExpression_PropertyAssignments */);
                var propertyAssignments = result.list;
                openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);

                var closeBraceToken = this.eatToken(71 /* CloseBraceToken */);

                return this.factory.objectLiteralExpression(openBraceToken, propertyAssignments, closeBraceToken);
            };

            ParserImpl.prototype.parsePropertyAssignment = function () {
                if (this.isGetAccessorPropertyAssignment(false)) {
                    return this.parseGetAccessorPropertyAssignment();
                } else if (this.isSetAccessorPropertyAssignment(false)) {
                    return this.parseSetAccessorPropertyAssignment();
                } else if (this.isFunctionPropertyAssignment(false)) {
                    return this.parseFunctionPropertyAssignment();
                } else if (this.isSimplePropertyAssignment(false)) {
                    return this.parseSimplePropertyAssignment();
                } else {
                    throw TypeScript.Errors.invalidOperation();
                }
            };

            ParserImpl.prototype.isPropertyAssignment = function (inErrorRecovery) {
                return this.isGetAccessorPropertyAssignment(inErrorRecovery) || this.isSetAccessorPropertyAssignment(inErrorRecovery) || this.isFunctionPropertyAssignment(inErrorRecovery) || this.isSimplePropertyAssignment(inErrorRecovery);
            };

            ParserImpl.prototype.isGetAccessorPropertyAssignment = function (inErrorRecovery) {
                return this.currentToken().tokenKind === 64 /* GetKeyword */ && this.isPropertyName(this.peekToken(1), inErrorRecovery);
            };

            ParserImpl.prototype.parseGetAccessorPropertyAssignment = function () {
                var getKeyword = this.eatKeyword(64 /* GetKeyword */);
                var propertyName = this.eatPropertyName();
                var openParenToken = this.eatToken(72 /* OpenParenToken */);
                var closeParenToken = this.eatToken(73 /* CloseParenToken */);
                var typeAnnotation = this.parseOptionalTypeAnnotation(false);
                var block = this.parseBlock(false, true);

                return this.factory.getAccessorPropertyAssignment(getKeyword, propertyName, openParenToken, closeParenToken, typeAnnotation, block);
            };

            ParserImpl.prototype.isSetAccessorPropertyAssignment = function (inErrorRecovery) {
                return this.currentToken().tokenKind === 68 /* SetKeyword */ && this.isPropertyName(this.peekToken(1), inErrorRecovery);
            };

            ParserImpl.prototype.parseSetAccessorPropertyAssignment = function () {
                var setKeyword = this.eatKeyword(68 /* SetKeyword */);
                var propertyName = this.eatPropertyName();
                var openParenToken = this.eatToken(72 /* OpenParenToken */);
                var parameter = this.parseParameter();
                var closeParenToken = this.eatToken(73 /* CloseParenToken */);
                var block = this.parseBlock(false, true);

                return this.factory.setAccessorPropertyAssignment(setKeyword, propertyName, openParenToken, parameter, closeParenToken, block);
            };

            ParserImpl.prototype.eatPropertyName = function () {
                return TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(this.currentToken()) ? this.eatIdentifierNameToken() : this.eatAnyToken();
            };

            ParserImpl.prototype.isFunctionPropertyAssignment = function (inErrorRecovery) {
                return this.isPropertyName(this.currentToken(), inErrorRecovery) && this.isCallSignature(1);
            };

            ParserImpl.prototype.parseFunctionPropertyAssignment = function () {
                var propertyName = this.eatPropertyName();
                var callSignature = this.parseCallSignature(false);
                var block = this.parseBlock(false, true);

                return this.factory.functionPropertyAssignment(propertyName, callSignature, block);
            };

            ParserImpl.prototype.isSimplePropertyAssignment = function (inErrorRecovery) {
                return this.isPropertyName(this.currentToken(), inErrorRecovery);
            };

            ParserImpl.prototype.parseSimplePropertyAssignment = function () {
                var propertyName = this.eatPropertyName();
                var colonToken = this.eatToken(106 /* ColonToken */);
                var expression = this.parseAssignmentExpression(true);

                return this.factory.simplePropertyAssignment(propertyName, colonToken, expression);
            };

            ParserImpl.prototype.isPropertyName = function (token, inErrorRecovery) {
                if (TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(token)) {
                    if (inErrorRecovery) {
                        return this.isIdentifier(token);
                    } else {
                        return true;
                    }
                }

                switch (token.tokenKind) {
                    case 14 /* StringLiteral */:
                    case 13 /* NumericLiteral */:
                        return true;

                    default:
                        return false;
                }
            };

            ParserImpl.prototype.parseArrayLiteralExpression = function () {
                var openBracketToken = this.eatToken(74 /* OpenBracketToken */);

                var result = this.parseSeparatedSyntaxList(65536 /* ArrayLiteralExpression_AssignmentExpressions */);
                var expressions = result.list;
                openBracketToken = this.addSkippedTokensAfterToken(openBracketToken, result.skippedTokens);

                var closeBracketToken = this.eatToken(75 /* CloseBracketToken */);

                return this.factory.arrayLiteralExpression(openBracketToken, expressions, closeBracketToken);
            };

            ParserImpl.prototype.parseLiteralExpression = function () {
                return this.eatAnyToken();
            };

            ParserImpl.prototype.parseThisExpression = function () {
                var thisKeyword = this.eatKeyword(35 /* ThisKeyword */);
                return thisKeyword;
            };

            ParserImpl.prototype.parseBlock = function (parseBlockEvenWithNoOpenBrace, checkForStrictMode) {
                var openBraceToken = this.eatToken(70 /* OpenBraceToken */);

                var statements = TypeScript.Syntax.emptyList;

                if (parseBlockEvenWithNoOpenBrace || openBraceToken.width() > 0) {
                    var savedIsInStrictMode = this.isInStrictMode;

                    var processItems = checkForStrictMode ? ParserImpl.updateStrictModeState : null;
                    var result = this.parseSyntaxList(32 /* Block_Statements */, processItems);
                    statements = result.list;
                    openBraceToken = this.addSkippedTokensAfterToken(openBraceToken, result.skippedTokens);

                    this.setStrictMode(savedIsInStrictMode);
                }

                var closeBraceToken = this.eatToken(71 /* CloseBraceToken */);

                return this.factory.block(openBraceToken, statements, closeBraceToken);
            };

            ParserImpl.prototype.parseCallSignature = function (requireCompleteTypeParameterList) {
                var typeParameterList = this.parseOptionalTypeParameterList(requireCompleteTypeParameterList);
                var parameterList = this.parseParameterList();
                var typeAnnotation = this.parseOptionalTypeAnnotation(false);

                return this.factory.callSignature(typeParameterList, parameterList, typeAnnotation);
            };

            ParserImpl.prototype.parseOptionalTypeParameterList = function (requireCompleteTypeParameterList) {
                if (this.currentToken().tokenKind !== 80 /* LessThanToken */) {
                    return null;
                }

                var rewindPoint = this.getRewindPoint();
                try  {
                    var lessThanToken = this.eatToken(80 /* LessThanToken */);

                    var result = this.parseSeparatedSyntaxList(524288 /* TypeParameterList_TypeParameters */);
                    var typeParameterList = result.list;
                    lessThanToken = this.addSkippedTokensAfterToken(lessThanToken, result.skippedTokens);

                    var greaterThanToken = this.eatToken(81 /* GreaterThanToken */);

                    if (requireCompleteTypeParameterList && greaterThanToken.fullWidth() === 0) {
                        this.rewind(rewindPoint);
                        return null;
                    }

                    return this.factory.typeParameterList(lessThanToken, typeParameterList, greaterThanToken);
                } finally {
                    this.releaseRewindPoint(rewindPoint);
                }
            };

            ParserImpl.prototype.isTypeParameter = function () {
                return this.isIdentifier(this.currentToken());
            };

            ParserImpl.prototype.parseTypeParameter = function () {
                var identifier = this.eatIdentifierToken();
                var constraint = this.parseOptionalConstraint();

                return this.factory.typeParameter(identifier, constraint);
            };

            ParserImpl.prototype.parseOptionalConstraint = function () {
                if (this.currentToken().kind() !== 48 /* ExtendsKeyword */) {
                    return null;
                }

                var extendsKeyword = this.eatKeyword(48 /* ExtendsKeyword */);
                var type = this.parseType();

                return this.factory.constraint(extendsKeyword, type);
            };

            ParserImpl.prototype.parseParameterList = function () {
                var openParenToken = this.eatToken(72 /* OpenParenToken */);
                var parameters = TypeScript.Syntax.emptySeparatedList;

                if (openParenToken.width() > 0) {
                    var result = this.parseSeparatedSyntaxList(131072 /* ParameterList_Parameters */);
                    parameters = result.list;
                    openParenToken = this.addSkippedTokensAfterToken(openParenToken, result.skippedTokens);
                }

                var closeParenToken = this.eatToken(73 /* CloseParenToken */);
                return this.factory.parameterList(openParenToken, parameters, closeParenToken);
            };

            ParserImpl.prototype.isTypeAnnotation = function () {
                return this.currentToken().tokenKind === 106 /* ColonToken */;
            };

            ParserImpl.prototype.parseOptionalTypeAnnotation = function (allowStringLiteral) {
                return this.isTypeAnnotation() ? this.parseTypeAnnotation(allowStringLiteral) : null;
            };

            ParserImpl.prototype.parseTypeAnnotation = function (allowStringLiteral) {
                var colonToken = this.eatToken(106 /* ColonToken */);
                var type = allowStringLiteral && this.currentToken().tokenKind === 14 /* StringLiteral */ ? this.eatToken(14 /* StringLiteral */) : this.parseType();

                return this.factory.typeAnnotation(colonToken, type);
            };

            ParserImpl.prototype.isType = function () {
                return this.isPredefinedType() || this.isTypeLiteral() || this.isTypeQuery() || this.isName();
            };

            ParserImpl.prototype.parseType = function () {
                if (this.isTypeQuery()) {
                    return this.parseTypeQuery();
                } else {
                    var type = this.parseNonArrayType();

                    while (this.currentToken().tokenKind === 74 /* OpenBracketToken */) {
                        var openBracketToken = this.eatToken(74 /* OpenBracketToken */);
                        var closeBracketToken = this.eatToken(75 /* CloseBracketToken */);

                        type = this.factory.arrayType(type, openBracketToken, closeBracketToken);
                    }

                    return type;
                }
            };

            ParserImpl.prototype.isTypeQuery = function () {
                return this.currentToken().tokenKind === 39 /* TypeOfKeyword */;
            };

            ParserImpl.prototype.parseTypeQuery = function () {
                var typeOfKeyword = this.eatToken(39 /* TypeOfKeyword */);
                var name = this.parseName();

                return this.factory.typeQuery(typeOfKeyword, name);
            };

            ParserImpl.prototype.parseNonArrayType = function () {
                if (this.isPredefinedType()) {
                    return this.parsePredefinedType();
                } else if (this.isTypeLiteral()) {
                    return this.parseTypeLiteral();
                } else {
                    return this.parseNameOrGenericType();
                }
            };

            ParserImpl.prototype.parseNameOrGenericType = function () {
                var name = this.parseName();
                var typeArgumentList = this.tryParseTypeArgumentList(false);

                return typeArgumentList === null ? name : this.factory.genericType(name, typeArgumentList);
            };

            ParserImpl.prototype.parseTypeLiteral = function () {
                if (this.isObjectType()) {
                    return this.parseObjectType();
                } else if (this.isFunctionType()) {
                    return this.parseFunctionType();
                } else if (this.isConstructorType()) {
                    return this.parseConstructorType();
                } else {
                    throw TypeScript.Errors.invalidOperation();
                }
            };

            ParserImpl.prototype.parseFunctionType = function () {
                var typeParameterList = this.parseOptionalTypeParameterList(false);
                var parameterList = this.parseParameterList();
                var equalsGreaterThanToken = this.eatToken(85 /* EqualsGreaterThanToken */);
                var returnType = this.parseType();

                return this.factory.functionType(typeParameterList, parameterList, equalsGreaterThanToken, returnType);
            };

            ParserImpl.prototype.parseConstructorType = function () {
                var newKeyword = this.eatKeyword(31 /* NewKeyword */);
                var parameterList = this.parseParameterList();
                var equalsGreaterThanToken = this.eatToken(85 /* EqualsGreaterThanToken */);
                var type = this.parseType();

                return this.factory.constructorType(newKeyword, null, parameterList, equalsGreaterThanToken, type);
            };

            ParserImpl.prototype.isTypeLiteral = function () {
                return this.isObjectType() || this.isFunctionType() || this.isConstructorType();
            };

            ParserImpl.prototype.isObjectType = function () {
                return this.currentToken().tokenKind === 70 /* OpenBraceToken */;
            };

            ParserImpl.prototype.isFunctionType = function () {
                var tokenKind = this.currentToken().tokenKind;
                return tokenKind === 72 /* OpenParenToken */ || tokenKind === 80 /* LessThanToken */;
            };

            ParserImpl.prototype.isConstructorType = function () {
                return this.currentToken().tokenKind === 31 /* NewKeyword */;
            };

            ParserImpl.prototype.parsePredefinedType = function () {
                return this.eatAnyToken();
            };

            ParserImpl.prototype.isPredefinedType = function () {
                switch (this.currentToken().tokenKind) {
                    case 60 /* AnyKeyword */:
                    case 67 /* NumberKeyword */:
                    case 61 /* BooleanKeyword */:
                    case 69 /* StringKeyword */:
                    case 41 /* VoidKeyword */:
                        return true;
                }

                return false;
            };

            ParserImpl.prototype.isParameter = function () {
                if (this.currentNode() !== null && this.currentNode().kind() === 242 /* Parameter */) {
                    return true;
                }

                var token = this.currentToken();
                if (token.tokenKind === 77 /* DotDotDotToken */) {
                    return true;
                }

                if (ParserImpl.isPublicOrPrivateKeyword(token)) {
                    return true;
                }

                return this.isIdentifier(token);
            };

            ParserImpl.prototype.parseParameter = function () {
                if (this.currentNode() !== null && this.currentNode().kind() === 242 /* Parameter */) {
                    return this.eatNode();
                }

                var dotDotDotToken = this.tryEatToken(77 /* DotDotDotToken */);

                var publicOrPrivateToken = null;
                if (ParserImpl.isPublicOrPrivateKeyword(this.currentToken())) {
                    publicOrPrivateToken = this.eatAnyToken();
                }

                var identifier = this.eatIdentifierToken();
                var questionToken = this.tryEatToken(105 /* QuestionToken */);
                var typeAnnotation = this.parseOptionalTypeAnnotation(true);

                var equalsValueClause = null;
                if (this.isEqualsValueClause(true)) {
                    equalsValueClause = this.parseEqualsValueClause(true);
                }

                return this.factory.parameter(dotDotDotToken, publicOrPrivateToken, identifier, questionToken, typeAnnotation, equalsValueClause);
            };

            ParserImpl.prototype.parseSyntaxList = function (currentListType, processItems) {
                if (typeof processItems === "undefined") { processItems = null; }
                var savedListParsingState = this.listParsingState;
                this.listParsingState |= currentListType;

                var result = this.parseSyntaxListWorker(currentListType, processItems);

                this.listParsingState = savedListParsingState;

                return result;
            };

            ParserImpl.prototype.parseSeparatedSyntaxList = function (currentListType) {
                var savedListParsingState = this.listParsingState;
                this.listParsingState |= currentListType;

                var result = this.parseSeparatedSyntaxListWorker(currentListType);

                this.listParsingState = savedListParsingState;

                return result;
            };

            ParserImpl.prototype.abortParsingListOrMoveToNextToken = function (currentListType, items, skippedTokens) {
                this.reportUnexpectedTokenDiagnostic(currentListType);

                for (var state = 262144 /* LastListParsingState */; state >= 1 /* FirstListParsingState */; state >>= 1) {
                    if ((this.listParsingState & state) !== 0) {
                        if (this.isExpectedListTerminator(state) || this.isExpectedListItem(state, true)) {
                            return true;
                        }
                    }
                }

                var skippedToken = this.currentToken();

                this.moveToNextToken();

                this.addSkippedTokenToList(items, skippedTokens, skippedToken);

                return false;
            };

            ParserImpl.prototype.addSkippedTokenToList = function (items, skippedTokens, skippedToken) {
                for (var i = items.length - 1; i >= 0; i--) {
                    var item = items[i];
                    var lastToken = item.lastToken();
                    if (lastToken.fullWidth() > 0) {
                        items[i] = this.addSkippedTokenAfterNodeOrToken(item, skippedToken);
                        return;
                    }
                }

                skippedTokens.push(skippedToken);
            };

            ParserImpl.prototype.tryParseExpectedListItem = function (currentListType, inErrorRecovery, items, processItems) {
                if (this.isExpectedListItem(currentListType, inErrorRecovery)) {
                    var item = this.parseExpectedListItem(currentListType);

                    items.push(item);

                    if (processItems !== null) {
                        processItems(this, items);
                    }
                }
            };

            ParserImpl.prototype.listIsTerminated = function (currentListType) {
                return this.isExpectedListTerminator(currentListType) || this.currentToken().tokenKind === 10 /* EndOfFileToken */;
            };

            ParserImpl.prototype.getArray = function () {
                if (this.arrayPool.length > 0) {
                    return this.arrayPool.pop();
                }

                return [];
            };

            ParserImpl.prototype.returnZeroOrOneLengthArray = function (array) {
                if (array.length <= 1) {
                    this.returnArray(array);
                }
            };

            ParserImpl.prototype.returnArray = function (array) {
                array.length = 0;
                this.arrayPool.push(array);
            };

            ParserImpl.prototype.parseSyntaxListWorker = function (currentListType, processItems) {
                var items = this.getArray();
                var skippedTokens = this.getArray();

                while (true) {
                    var oldItemsCount = items.length;
                    this.tryParseExpectedListItem(currentListType, false, items, processItems);

                    var newItemsCount = items.length;
                    if (newItemsCount === oldItemsCount) {
                        if (this.listIsTerminated(currentListType)) {
                            break;
                        }

                        var abort = this.abortParsingListOrMoveToNextToken(currentListType, items, skippedTokens);
                        if (abort) {
                            break;
                        }
                    }
                }

                var result = TypeScript.Syntax.list(items);

                this.returnZeroOrOneLengthArray(items);

                return { skippedTokens: skippedTokens, list: result };
            };

            ParserImpl.prototype.parseSeparatedSyntaxListWorker = function (currentListType) {
                var items = this.getArray();
                var skippedTokens = this.getArray();
                TypeScript.Debug.assert(items.length === 0);
                TypeScript.Debug.assert(skippedTokens.length === 0);
                TypeScript.Debug.assert(skippedTokens !== items);

                var separatorKind = this.separatorKind(currentListType);
                var allowAutomaticSemicolonInsertion = separatorKind === 78 /* SemicolonToken */;

                var inErrorRecovery = false;
                var listWasTerminated = false;
                while (true) {
                    var oldItemsCount = items.length;

                    this.tryParseExpectedListItem(currentListType, inErrorRecovery, items, null);

                    var newItemsCount = items.length;
                    if (newItemsCount === oldItemsCount) {
                        if (this.listIsTerminated(currentListType)) {
                            listWasTerminated = true;
                            break;
                        }

                        var abort = this.abortParsingListOrMoveToNextToken(currentListType, items, skippedTokens);
                        if (abort) {
                            break;
                        } else {
                            inErrorRecovery = true;
                            continue;
                        }
                    }

                    inErrorRecovery = false;

                    var currentToken = this.currentToken();
                    if (currentToken.tokenKind === separatorKind || currentToken.tokenKind === 79 /* CommaToken */) {
                        items.push(this.eatAnyToken());
                        continue;
                    }

                    if (this.listIsTerminated(currentListType)) {
                        listWasTerminated = true;
                        break;
                    }

                    if (allowAutomaticSemicolonInsertion && this.canEatAutomaticSemicolon(false)) {
                        items.push(this.eatExplicitOrAutomaticSemicolon(false));

                        continue;
                    }

                    items.push(this.eatToken(separatorKind));

                    inErrorRecovery = true;
                }

                var result = TypeScript.Syntax.separatedList(items);

                this.returnZeroOrOneLengthArray(items);

                return { skippedTokens: skippedTokens, list: result };
            };

            ParserImpl.prototype.separatorKind = function (currentListType) {
                switch (currentListType) {
                    case 2048 /* HeritageClause_TypeNameList */:
                    case 16384 /* ArgumentList_AssignmentExpressions */:
                    case 256 /* EnumDeclaration_EnumElements */:
                    case 4096 /* VariableDeclaration_VariableDeclarators_AllowIn */:
                    case 8192 /* VariableDeclaration_VariableDeclarators_DisallowIn */:
                    case 32768 /* ObjectLiteralExpression_PropertyAssignments */:
                    case 131072 /* ParameterList_Parameters */:
                    case 65536 /* ArrayLiteralExpression_AssignmentExpressions */:
                    case 262144 /* TypeArgumentList_Types */:
                    case 524288 /* TypeParameterList_TypeParameters */:
                        return 79 /* CommaToken */;

                    case 512 /* ObjectType_TypeMembers */:
                        return 78 /* SemicolonToken */;

                    case 1 /* SourceUnit_ModuleElements */:
                    case 1024 /* ClassOrInterfaceDeclaration_HeritageClauses */:
                    case 2 /* ClassDeclaration_ClassElements */:
                    case 4 /* ModuleDeclaration_ModuleElements */:
                    case 8 /* SwitchStatement_SwitchClauses */:
                    case 16 /* SwitchClause_Statements */:
                    case 32 /* Block_Statements */:
                    default:
                        throw TypeScript.Errors.notYetImplemented();
                }
            };

            ParserImpl.prototype.reportUnexpectedTokenDiagnostic = function (listType) {
                var token = this.currentToken();

                var diagnostic = new TypeScript.Diagnostic(this.fileName, this.currentTokenStart(), token.width(), TypeScript.DiagnosticCode.Unexpected_token_0_expected, [this.getExpectedListElementType(listType)]);
                this.addDiagnostic(diagnostic);
            };

            ParserImpl.prototype.addDiagnostic = function (diagnostic) {
                if (this.diagnostics.length > 0 && this.diagnostics[this.diagnostics.length - 1].start() === diagnostic.start()) {
                    return;
                }

                this.diagnostics.push(diagnostic);
            };

            ParserImpl.prototype.isExpectedListTerminator = function (currentListType) {
                switch (currentListType) {
                    case 1 /* SourceUnit_ModuleElements */:
                        return this.isExpectedSourceUnit_ModuleElementsTerminator();

                    case 1024 /* ClassOrInterfaceDeclaration_HeritageClauses */:
                        return this.isExpectedClassOrInterfaceDeclaration_HeritageClausesTerminator();

                    case 2 /* ClassDeclaration_ClassElements */:
                        return this.isExpectedClassDeclaration_ClassElementsTerminator();

                    case 4 /* ModuleDeclaration_ModuleElements */:
                        return this.isExpectedModuleDeclaration_ModuleElementsTerminator();

                    case 8 /* SwitchStatement_SwitchClauses */:
                        return this.isExpectedSwitchStatement_SwitchClausesTerminator();

                    case 16 /* SwitchClause_Statements */:
                        return this.isExpectedSwitchClause_StatementsTerminator();

                    case 32 /* Block_Statements */:
                        return this.isExpectedBlock_StatementsTerminator();

                    case 64 /* TryBlock_Statements */:
                        return this.isExpectedTryBlock_StatementsTerminator();

                    case 128 /* CatchBlock_Statements */:
                        return this.isExpectedCatchBlock_StatementsTerminator();

                    case 256 /* EnumDeclaration_EnumElements */:
                        return this.isExpectedEnumDeclaration_EnumElementsTerminator();

                    case 512 /* ObjectType_TypeMembers */:
                        return this.isExpectedObjectType_TypeMembersTerminator();

                    case 16384 /* ArgumentList_AssignmentExpressions */:
                        return this.isExpectedArgumentList_AssignmentExpressionsTerminator();

                    case 2048 /* HeritageClause_TypeNameList */:
                        return this.isExpectedHeritageClause_TypeNameListTerminator();

                    case 4096 /* VariableDeclaration_VariableDeclarators_AllowIn */:
                        return this.isExpectedVariableDeclaration_VariableDeclarators_AllowInTerminator();

                    case 8192 /* VariableDeclaration_VariableDeclarators_DisallowIn */:
                        return this.isExpectedVariableDeclaration_VariableDeclarators_DisallowInTerminator();

                    case 32768 /* ObjectLiteralExpression_PropertyAssignments */:
                        return this.isExpectedObjectLiteralExpression_PropertyAssignmentsTerminator();

                    case 131072 /* ParameterList_Parameters */:
                        return this.isExpectedParameterList_ParametersTerminator();

                    case 262144 /* TypeArgumentList_Types */:
                        return this.isExpectedTypeArgumentList_TypesTerminator();

                    case 524288 /* TypeParameterList_TypeParameters */:
                        return this.isExpectedTypeParameterList_TypeParametersTerminator();

                    case 65536 /* ArrayLiteralExpression_AssignmentExpressions */:
                        return this.isExpectedLiteralExpression_AssignmentExpressionsTerminator();

                    default:
                        throw TypeScript.Errors.invalidOperation();
                }
            };

            ParserImpl.prototype.isExpectedSourceUnit_ModuleElementsTerminator = function () {
                return this.currentToken().tokenKind === 10 /* EndOfFileToken */;
            };

            ParserImpl.prototype.isExpectedEnumDeclaration_EnumElementsTerminator = function () {
                return this.currentToken().tokenKind === 71 /* CloseBraceToken */;
            };

            ParserImpl.prototype.isExpectedModuleDeclaration_ModuleElementsTerminator = function () {
                return this.currentToken().tokenKind === 71 /* CloseBraceToken */;
            };

            ParserImpl.prototype.isExpectedObjectType_TypeMembersTerminator = function () {
                return this.currentToken().tokenKind === 71 /* CloseBraceToken */;
            };

            ParserImpl.prototype.isExpectedObjectLiteralExpression_PropertyAssignmentsTerminator = function () {
                return this.currentToken().tokenKind === 71 /* CloseBraceToken */;
            };

            ParserImpl.prototype.isExpectedLiteralExpression_AssignmentExpressionsTerminator = function () {
                return this.currentToken().tokenKind === 75 /* CloseBracketToken */;
            };

            ParserImpl.prototype.isExpectedTypeArgumentList_TypesTerminator = function () {
                var token = this.currentToken();
                if (token.tokenKind === 81 /* GreaterThanToken */) {
                    return true;
                }

                if (this.canFollowTypeArgumentListInExpression(token.tokenKind)) {
                    return true;
                }

                return false;
            };

            ParserImpl.prototype.isExpectedTypeParameterList_TypeParametersTerminator = function () {
                var token = this.currentToken();
                if (token.tokenKind === 81 /* GreaterThanToken */) {
                    return true;
                }

                if (token.tokenKind === 72 /* OpenParenToken */ || token.tokenKind === 70 /* OpenBraceToken */ || token.tokenKind === 48 /* ExtendsKeyword */ || token.tokenKind === 51 /* ImplementsKeyword */) {
                    return true;
                }

                return false;
            };

            ParserImpl.prototype.isExpectedParameterList_ParametersTerminator = function () {
                var token = this.currentToken();
                if (token.tokenKind === 73 /* CloseParenToken */) {
                    return true;
                }

                if (token.tokenKind === 70 /* OpenBraceToken */) {
                    return true;
                }

                if (token.tokenKind === 85 /* EqualsGreaterThanToken */) {
                    return true;
                }

                return false;
            };

            ParserImpl.prototype.isExpectedVariableDeclaration_VariableDeclarators_DisallowInTerminator = function () {
                if (this.currentToken().tokenKind === 78 /* SemicolonToken */ || this.currentToken().tokenKind === 73 /* CloseParenToken */) {
                    return true;
                }

                if (this.currentToken().tokenKind === 29 /* InKeyword */) {
                    return true;
                }

                return false;
            };

            ParserImpl.prototype.isExpectedVariableDeclaration_VariableDeclarators_AllowInTerminator = function () {
                if (this.previousToken().tokenKind === 79 /* CommaToken */) {
                    return false;
                }

                if (this.currentToken().tokenKind === 85 /* EqualsGreaterThanToken */) {
                    return true;
                }

                return this.canEatExplicitOrAutomaticSemicolon(false);
            };

            ParserImpl.prototype.isExpectedClassOrInterfaceDeclaration_HeritageClausesTerminator = function () {
                var token0 = this.currentToken();
                if (token0.tokenKind === 70 /* OpenBraceToken */ || token0.tokenKind === 71 /* CloseBraceToken */) {
                    return true;
                }

                return false;
            };

            ParserImpl.prototype.isExpectedHeritageClause_TypeNameListTerminator = function () {
                var token0 = this.currentToken();
                if (token0.tokenKind === 48 /* ExtendsKeyword */ || token0.tokenKind === 51 /* ImplementsKeyword */) {
                    return true;
                }

                if (this.isExpectedClassOrInterfaceDeclaration_HeritageClausesTerminator()) {
                    return true;
                }

                return false;
            };

            ParserImpl.prototype.isExpectedArgumentList_AssignmentExpressionsTerminator = function () {
                var token0 = this.currentToken();
                return token0.tokenKind === 73 /* CloseParenToken */ || token0.tokenKind === 78 /* SemicolonToken */;
            };

            ParserImpl.prototype.isExpectedClassDeclaration_ClassElementsTerminator = function () {
                return this.currentToken().tokenKind === 71 /* CloseBraceToken */;
            };

            ParserImpl.prototype.isExpectedSwitchStatement_SwitchClausesTerminator = function () {
                return this.currentToken().tokenKind === 71 /* CloseBraceToken */;
            };

            ParserImpl.prototype.isExpectedSwitchClause_StatementsTerminator = function () {
                return this.currentToken().tokenKind === 71 /* CloseBraceToken */ || this.isSwitchClause();
            };

            ParserImpl.prototype.isExpectedBlock_StatementsTerminator = function () {
                return this.currentToken().tokenKind === 71 /* CloseBraceToken */;
            };

            ParserImpl.prototype.isExpectedTryBlock_StatementsTerminator = function () {
                return this.currentToken().tokenKind === 17 /* CatchKeyword */ || this.currentToken().tokenKind === 25 /* FinallyKeyword */;
            };

            ParserImpl.prototype.isExpectedCatchBlock_StatementsTerminator = function () {
                return this.currentToken().tokenKind === 25 /* FinallyKeyword */;
            };

            ParserImpl.prototype.isExpectedListItem = function (currentListType, inErrorRecovery) {
                switch (currentListType) {
                    case 1 /* SourceUnit_ModuleElements */:
                        return this.isModuleElement(inErrorRecovery);

                    case 1024 /* ClassOrInterfaceDeclaration_HeritageClauses */:
                        return this.isHeritageClause();

                    case 2 /* ClassDeclaration_ClassElements */:
                        return this.isClassElement(inErrorRecovery);

                    case 4 /* ModuleDeclaration_ModuleElements */:
                        return this.isModuleElement(inErrorRecovery);

                    case 8 /* SwitchStatement_SwitchClauses */:
                        return this.isSwitchClause();

                    case 16 /* SwitchClause_Statements */:
                        return this.isStatement(inErrorRecovery);

                    case 32 /* Block_Statements */:
                        return this.isStatement(inErrorRecovery);

                    case 64 /* TryBlock_Statements */:
                    case 128 /* CatchBlock_Statements */:
                        return false;

                    case 256 /* EnumDeclaration_EnumElements */:
                        return this.isEnumElement(inErrorRecovery);

                    case 4096 /* VariableDeclaration_VariableDeclarators_AllowIn */:
                    case 8192 /* VariableDeclaration_VariableDeclarators_DisallowIn */:
                        return this.isVariableDeclarator();

                    case 512 /* ObjectType_TypeMembers */:
                        return this.isTypeMember(inErrorRecovery);

                    case 16384 /* ArgumentList_AssignmentExpressions */:
                        return this.isExpectedArgumentList_AssignmentExpression();

                    case 2048 /* HeritageClause_TypeNameList */:
                        return this.isHeritageClauseTypeName();

                    case 32768 /* ObjectLiteralExpression_PropertyAssignments */:
                        return this.isPropertyAssignment(inErrorRecovery);

                    case 131072 /* ParameterList_Parameters */:
                        return this.isParameter();

                    case 262144 /* TypeArgumentList_Types */:
                        return this.isType();

                    case 524288 /* TypeParameterList_TypeParameters */:
                        return this.isTypeParameter();

                    case 65536 /* ArrayLiteralExpression_AssignmentExpressions */:
                        return this.isAssignmentOrOmittedExpression();

                    default:
                        throw TypeScript.Errors.invalidOperation();
                }
            };

            ParserImpl.prototype.isExpectedArgumentList_AssignmentExpression = function () {
                if (this.isExpression()) {
                    return true;
                }

                if (this.currentToken().tokenKind === 79 /* CommaToken */) {
                    return true;
                }

                return false;
            };

            ParserImpl.prototype.parseExpectedListItem = function (currentListType) {
                switch (currentListType) {
                    case 1 /* SourceUnit_ModuleElements */:
                        return this.parseModuleElement();

                    case 1024 /* ClassOrInterfaceDeclaration_HeritageClauses */:
                        return this.parseHeritageClause();

                    case 2 /* ClassDeclaration_ClassElements */:
                        return this.parseClassElement(false);

                    case 4 /* ModuleDeclaration_ModuleElements */:
                        return this.parseModuleElement();

                    case 8 /* SwitchStatement_SwitchClauses */:
                        return this.parseSwitchClause();

                    case 16 /* SwitchClause_Statements */:
                        return this.parseStatement();

                    case 32 /* Block_Statements */:
                        return this.parseStatement();

                    case 256 /* EnumDeclaration_EnumElements */:
                        return this.parseEnumElement();

                    case 512 /* ObjectType_TypeMembers */:
                        return this.parseTypeMember();

                    case 16384 /* ArgumentList_AssignmentExpressions */:
                        return this.parseAssignmentExpression(true);

                    case 2048 /* HeritageClause_TypeNameList */:
                        return this.parseNameOrGenericType();

                    case 4096 /* VariableDeclaration_VariableDeclarators_AllowIn */:
                        return this.parseVariableDeclarator(true, false);

                    case 8192 /* VariableDeclaration_VariableDeclarators_DisallowIn */:
                        return this.parseVariableDeclarator(false, false);

                    case 32768 /* ObjectLiteralExpression_PropertyAssignments */:
                        return this.parsePropertyAssignment();

                    case 65536 /* ArrayLiteralExpression_AssignmentExpressions */:
                        return this.parseAssignmentOrOmittedExpression();

                    case 131072 /* ParameterList_Parameters */:
                        return this.parseParameter();

                    case 262144 /* TypeArgumentList_Types */:
                        return this.parseType();

                    case 524288 /* TypeParameterList_TypeParameters */:
                        return this.parseTypeParameter();

                    default:
                        throw TypeScript.Errors.invalidOperation();
                }
            };

            ParserImpl.prototype.getExpectedListElementType = function (currentListType) {
                switch (currentListType) {
                    case 1 /* SourceUnit_ModuleElements */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.module_class_interface_enum_import_or_statement, null);

                    case 1024 /* ClassOrInterfaceDeclaration_HeritageClauses */:
                        return '{';

                    case 2 /* ClassDeclaration_ClassElements */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.constructor_function_accessor_or_variable, null);

                    case 4 /* ModuleDeclaration_ModuleElements */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.module_class_interface_enum_import_or_statement, null);

                    case 8 /* SwitchStatement_SwitchClauses */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.case_or_default_clause, null);

                    case 16 /* SwitchClause_Statements */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.statement, null);

                    case 32 /* Block_Statements */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.statement, null);

                    case 4096 /* VariableDeclaration_VariableDeclarators_AllowIn */:
                    case 8192 /* VariableDeclaration_VariableDeclarators_DisallowIn */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.identifier, null);

                    case 256 /* EnumDeclaration_EnumElements */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.identifier, null);

                    case 512 /* ObjectType_TypeMembers */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.call_construct_index_property_or_function_signature, null);

                    case 16384 /* ArgumentList_AssignmentExpressions */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.expression, null);

                    case 2048 /* HeritageClause_TypeNameList */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.type_name, null);

                    case 32768 /* ObjectLiteralExpression_PropertyAssignments */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.property_or_accessor, null);

                    case 131072 /* ParameterList_Parameters */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.parameter, null);

                    case 262144 /* TypeArgumentList_Types */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.type, null);

                    case 524288 /* TypeParameterList_TypeParameters */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.type_parameter, null);

                    case 65536 /* ArrayLiteralExpression_AssignmentExpressions */:
                        return TypeScript.getLocalizedText(TypeScript.DiagnosticCode.expression, null);

                    default:
                        throw TypeScript.Errors.invalidOperation();
                }
            };
            return ParserImpl;
        })();

        function parse(fileName, text, isDeclaration, options) {
            var source = new NormalParserSource(fileName, text, options.languageVersion());

            return new ParserImpl(fileName, text.lineMap(), source, options).parseSyntaxTree(isDeclaration);
        }
        Parser.parse = parse;

        function incrementalParse(oldSyntaxTree, textChangeRange, newText) {
            if (textChangeRange.isUnchanged()) {
                return oldSyntaxTree;
            }

            var source = new IncrementalParserSource(oldSyntaxTree, textChangeRange, newText);

            return new ParserImpl(oldSyntaxTree.fileName(), newText.lineMap(), source, oldSyntaxTree.parseOptions()).parseSyntaxTree(oldSyntaxTree.isDeclaration());
        }
        Parser.incrementalParse = incrementalParse;
    })(TypeScript.Parser || (TypeScript.Parser = {}));
    var Parser = TypeScript.Parser;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxTree = (function () {
        function SyntaxTree(sourceUnit, isDeclaration, diagnostics, fileName, lineMap, parseOtions) {
            this._allDiagnostics = null;
            this._sourceUnit = sourceUnit;
            this._isDeclaration = isDeclaration;
            this._parserDiagnostics = diagnostics;
            this._fileName = fileName;
            this._lineMap = lineMap;
            this._parseOptions = parseOtions;
        }
        SyntaxTree.prototype.toJSON = function (key) {
            var result = {};

            result.isDeclaration = this._isDeclaration;
            result.languageVersion = TypeScript.LanguageVersion[this._parseOptions.languageVersion()];
            result.parseOptions = this._parseOptions;

            if (this.diagnostics().length > 0) {
                result.diagnostics = this.diagnostics();
            }

            result.sourceUnit = this._sourceUnit;
            result.lineMap = this._lineMap;

            return result;
        };

        SyntaxTree.prototype.sourceUnit = function () {
            return this._sourceUnit;
        };

        SyntaxTree.prototype.isDeclaration = function () {
            return this._isDeclaration;
        };

        SyntaxTree.prototype.computeDiagnostics = function () {
            if (this._parserDiagnostics.length > 0) {
                return this._parserDiagnostics;
            }

            var diagnostics = [];
            this.sourceUnit().accept(new GrammarCheckerWalker(this, diagnostics));

            return diagnostics;
        };

        SyntaxTree.prototype.diagnostics = function () {
            if (this._allDiagnostics === null) {
                this._allDiagnostics = this.computeDiagnostics();
            }

            return this._allDiagnostics;
        };

        SyntaxTree.prototype.fileName = function () {
            return this._fileName;
        };

        SyntaxTree.prototype.lineMap = function () {
            return this._lineMap;
        };

        SyntaxTree.prototype.parseOptions = function () {
            return this._parseOptions;
        };

        SyntaxTree.prototype.structuralEquals = function (tree) {
            return TypeScript.ArrayUtilities.sequenceEquals(this.diagnostics(), tree.diagnostics(), TypeScript.Diagnostic.equals) && this.sourceUnit().structuralEquals(tree.sourceUnit());
        };
        return SyntaxTree;
    })();
    TypeScript.SyntaxTree = SyntaxTree;

    var GrammarCheckerWalker = (function (_super) {
        __extends(GrammarCheckerWalker, _super);
        function GrammarCheckerWalker(syntaxTree, diagnostics) {
            _super.call(this);
            this.syntaxTree = syntaxTree;
            this.diagnostics = diagnostics;
            this.inAmbientDeclaration = false;
            this.inBlock = false;
            this.currentConstructor = null;
        }
        GrammarCheckerWalker.prototype.childFullStart = function (parent, child) {
            return this.position() + TypeScript.Syntax.childOffset(parent, child);
        };

        GrammarCheckerWalker.prototype.childStart = function (parent, child) {
            return this.childFullStart(parent, child) + child.leadingTriviaWidth();
        };

        GrammarCheckerWalker.prototype.pushDiagnostic = function (start, length, diagnosticKey, args) {
            if (typeof args === "undefined") { args = null; }
            this.diagnostics.push(new TypeScript.Diagnostic(this.syntaxTree.fileName(), start, length, diagnosticKey, args));
        };

        GrammarCheckerWalker.prototype.pushDiagnostic1 = function (elementFullStart, element, diagnosticKey, args) {
            if (typeof args === "undefined") { args = null; }
            this.diagnostics.push(new TypeScript.Diagnostic(this.syntaxTree.fileName(), elementFullStart + element.leadingTriviaWidth(), element.width(), diagnosticKey, args));
        };

        GrammarCheckerWalker.prototype.visitCatchClause = function (node) {
            if (node.typeAnnotation) {
                this.pushDiagnostic(this.childStart(node, node.typeAnnotation), node.typeAnnotation.width(), TypeScript.DiagnosticCode.Catch_clause_parameter_cannot_have_a_type_annotation);
            }

            _super.prototype.visitCatchClause.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkParameterListOrder = function (node) {
            var parameterFullStart = this.childFullStart(node, node.parameters);

            var seenOptionalParameter = false;
            var parameterCount = node.parameters.nonSeparatorCount();

            for (var i = 0, n = node.parameters.childCount(); i < n; i++) {
                var nodeOrToken = node.parameters.childAt(i);
                if (i % 2 === 0) {
                    var parameterIndex = i / 2;
                    var parameter = node.parameters.childAt(i);

                    if (parameter.dotDotDotToken) {
                        if (parameterIndex !== (parameterCount - 1)) {
                            this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Rest_parameter_must_be_last_in_list);
                            return true;
                        }

                        if (parameter.questionToken) {
                            this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Rest_parameter_cannot_be_optional);
                            return true;
                        }

                        if (parameter.equalsValueClause) {
                            this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Rest_parameter_cannot_have_an_initializer);
                            return true;
                        }
                    } else if (parameter.questionToken || parameter.equalsValueClause) {
                        seenOptionalParameter = true;

                        if (parameter.questionToken && parameter.equalsValueClause) {
                            this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Parameter_cannot_have_question_mark_and_initializer);
                            return true;
                        }
                    } else {
                        if (seenOptionalParameter) {
                            this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Required_parameter_cannot_follow_optional_parameter);
                            return true;
                        }
                    }
                }

                parameterFullStart += nodeOrToken.fullWidth();
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkParameterListAcessibilityModifiers = function (node) {
            if (this.currentConstructor !== null && this.currentConstructor.parameterList === node && this.currentConstructor.block && !this.inAmbientDeclaration) {
                return false;
            }

            var parameterFullStart = this.childFullStart(node, node.parameters);

            for (var i = 0, n = node.parameters.childCount(); i < n; i++) {
                var nodeOrToken = node.parameters.childAt(i);
                if (i % 2 === 0) {
                    var parameter = node.parameters.childAt(i);

                    if (parameter.publicOrPrivateKeyword) {
                        var keywordFullStart = parameterFullStart + TypeScript.Syntax.childOffset(parameter, parameter.publicOrPrivateKeyword);

                        if (this.inAmbientDeclaration) {
                            this.pushDiagnostic1(keywordFullStart, parameter.publicOrPrivateKeyword, TypeScript.DiagnosticCode.Parameter_property_declarations_cannot_be_used_in_an_ambient_context);
                        } else if (!this.currentConstructor.block) {
                            this.pushDiagnostic1(keywordFullStart, parameter.publicOrPrivateKeyword, TypeScript.DiagnosticCode.Parameter_property_declarations_cannot_be_used_in_a_constructor_overload);
                        } else {
                            this.pushDiagnostic1(keywordFullStart, parameter.publicOrPrivateKeyword, TypeScript.DiagnosticCode.Parameter_property_declarations_can_only_be_used_in_constructors);
                        }
                    }
                }

                parameterFullStart += nodeOrToken.fullWidth();
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkForTrailingSeparator = function (parent, list) {
            if (list.childCount() === 0 || list.childCount() % 2 === 1) {
                return false;
            }

            var currentElementFullStart = this.childFullStart(parent, list);

            for (var i = 0, n = list.childCount(); i < n; i++) {
                var child = list.childAt(i);
                if (i === n - 1) {
                    this.pushDiagnostic1(currentElementFullStart, child, TypeScript.DiagnosticCode.Trailing_separator_not_allowed);
                }

                currentElementFullStart += child.fullWidth();
            }

            return true;
        };

        GrammarCheckerWalker.prototype.checkForAtLeastOneElement = function (parent, list, expected) {
            if (list.childCount() > 0) {
                return false;
            }

            var listFullStart = this.childFullStart(parent, list);
            var tokenAtStart = this.syntaxTree.sourceUnit().findToken(listFullStart);

            this.pushDiagnostic1(listFullStart, tokenAtStart.token(), TypeScript.DiagnosticCode.Unexpected_token_0_expected, [expected]);

            return true;
        };

        GrammarCheckerWalker.prototype.visitParameterList = function (node) {
            if (this.checkParameterListAcessibilityModifiers(node) || this.checkParameterListOrder(node) || this.checkForTrailingSeparator(node, node.parameters)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitParameterList.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitHeritageClause = function (node) {
            if (this.checkForTrailingSeparator(node, node.typeNames) || this.checkForAtLeastOneElement(node, node.typeNames, TypeScript.getLocalizedText(TypeScript.DiagnosticCode.type_name, null))) {
                this.skip(node);
                return;
            }

            _super.prototype.visitHeritageClause.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitArgumentList = function (node) {
            if (this.checkForTrailingSeparator(node, node.arguments)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitArgumentList.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitVariableDeclaration = function (node) {
            if (this.checkForTrailingSeparator(node, node.variableDeclarators) || this.checkForAtLeastOneElement(node, node.variableDeclarators, TypeScript.getLocalizedText(TypeScript.DiagnosticCode.identifier, null))) {
                this.skip(node);
                return;
            }

            _super.prototype.visitVariableDeclaration.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitTypeArgumentList = function (node) {
            if (this.checkForTrailingSeparator(node, node.typeArguments) || this.checkForAtLeastOneElement(node, node.typeArguments, TypeScript.getLocalizedText(TypeScript.DiagnosticCode.identifier, null))) {
                this.skip(node);
                return;
            }

            _super.prototype.visitTypeArgumentList.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitTypeParameterList = function (node) {
            if (this.checkForTrailingSeparator(node, node.typeParameters) || this.checkForAtLeastOneElement(node, node.typeParameters, TypeScript.getLocalizedText(TypeScript.DiagnosticCode.identifier, null))) {
                this.skip(node);
                return;
            }

            _super.prototype.visitTypeParameterList.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkIndexSignatureParameter = function (node) {
            var parameterFullStart = this.childFullStart(node, node.parameter);
            var parameter = node.parameter;

            if (parameter.dotDotDotToken) {
                this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Index_signatures_cannot_have_rest_parameters);
                return true;
            } else if (parameter.publicOrPrivateKeyword) {
                this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Index_signature_parameter_cannot_have_accessibility_modifiers);
                return true;
            } else if (parameter.questionToken) {
                this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Index_signature_parameter_cannot_have_a_question_mark);
                return true;
            } else if (parameter.equalsValueClause) {
                this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Index_signature_parameter_cannot_have_an_initializer);
                return true;
            } else if (!parameter.typeAnnotation) {
                this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Index_signature_parameter_must_have_a_type_annotation);
                return true;
            } else if (parameter.typeAnnotation.type.kind() !== 69 /* StringKeyword */ && parameter.typeAnnotation.type.kind() !== 67 /* NumberKeyword */) {
                this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.Index_signature_parameter_type_must_be_string_or_number);
                return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitIndexSignature = function (node) {
            if (this.checkIndexSignatureParameter(node)) {
                this.skip(node);
                return;
            }

            if (!node.typeAnnotation) {
                this.pushDiagnostic1(this.position(), node, TypeScript.DiagnosticCode.Index_signature_must_have_a_type_annotation);
                this.skip(node);
                return;
            }

            _super.prototype.visitIndexSignature.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkClassDeclarationHeritageClauses = function (node) {
            var heritageClauseFullStart = this.childFullStart(node, node.heritageClauses);

            var seenExtendsClause = false;
            var seenImplementsClause = false;

            for (var i = 0, n = node.heritageClauses.childCount(); i < n; i++) {
                TypeScript.Debug.assert(i <= 2);
                var heritageClause = node.heritageClauses.childAt(i);

                if (heritageClause.extendsOrImplementsKeyword.tokenKind === 48 /* ExtendsKeyword */) {
                    if (seenExtendsClause) {
                        this.pushDiagnostic1(heritageClauseFullStart, heritageClause, TypeScript.DiagnosticCode.extends_clause_already_seen);
                        return true;
                    }

                    if (seenImplementsClause) {
                        this.pushDiagnostic1(heritageClauseFullStart, heritageClause, TypeScript.DiagnosticCode.extends_clause_must_precede_implements_clause);
                        return true;
                    }

                    if (heritageClause.typeNames.nonSeparatorCount() > 1) {
                        this.pushDiagnostic1(heritageClauseFullStart, heritageClause, TypeScript.DiagnosticCode.Classes_can_only_extend_a_single_class);
                        return true;
                    }

                    seenExtendsClause = true;
                } else {
                    TypeScript.Debug.assert(heritageClause.extendsOrImplementsKeyword.tokenKind === 51 /* ImplementsKeyword */);
                    if (seenImplementsClause) {
                        this.pushDiagnostic1(heritageClauseFullStart, heritageClause, TypeScript.DiagnosticCode.implements_clause_already_seen);
                        return true;
                    }

                    seenImplementsClause = true;
                }

                heritageClauseFullStart += heritageClause.fullWidth();
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkForDisallowedDeclareModifier = function (modifiers) {
            if (this.inAmbientDeclaration) {
                var declareToken = TypeScript.SyntaxUtilities.getToken(modifiers, 63 /* DeclareKeyword */);

                if (declareToken) {
                    this.pushDiagnostic1(this.childFullStart(modifiers, declareToken), declareToken, TypeScript.DiagnosticCode.declare_modifier_not_allowed_for_code_already_in_an_ambient_context);
                    return true;
                }
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkForRequiredDeclareModifier = function (moduleElement, typeKeyword, modifiers) {
            if (!this.inAmbientDeclaration && this.syntaxTree.isDeclaration()) {
                if (!TypeScript.SyntaxUtilities.containsToken(modifiers, 63 /* DeclareKeyword */)) {
                    this.pushDiagnostic1(this.childFullStart(moduleElement, typeKeyword), typeKeyword.firstToken(), TypeScript.DiagnosticCode.declare_modifier_required_for_top_level_element);
                    return true;
                }
            }
        };

        GrammarCheckerWalker.prototype.checkFunctionOverloads = function (node, moduleElements) {
            if (!this.inAmbientDeclaration && !this.syntaxTree.isDeclaration()) {
                var moduleElementFullStart = this.childFullStart(node, moduleElements);

                var inFunctionOverloadChain = false;
                var functionOverloadChainName = null;

                for (var i = 0, n = moduleElements.childCount(); i < n; i++) {
                    var moduleElement = moduleElements.childAt(i);
                    var lastElement = i === (n - 1);

                    if (inFunctionOverloadChain) {
                        if (moduleElement.kind() !== 129 /* FunctionDeclaration */) {
                            this.pushDiagnostic1(moduleElementFullStart, moduleElement.firstToken(), TypeScript.DiagnosticCode.Function_implementation_expected);
                            return true;
                        }

                        var functionDeclaration = moduleElement;
                        if (functionDeclaration.identifier.valueText() !== functionOverloadChainName) {
                            var identifierFullStart = moduleElementFullStart + TypeScript.Syntax.childOffset(moduleElement, functionDeclaration.identifier);
                            this.pushDiagnostic1(identifierFullStart, functionDeclaration.identifier, TypeScript.DiagnosticCode.Function_overload_name_must_be_0, [functionOverloadChainName]);
                            return true;
                        }
                    }

                    if (moduleElement.kind() === 129 /* FunctionDeclaration */) {
                        functionDeclaration = moduleElement;
                        if (!TypeScript.SyntaxUtilities.containsToken(functionDeclaration.modifiers, 63 /* DeclareKeyword */)) {
                            inFunctionOverloadChain = functionDeclaration.block === null;
                            functionOverloadChainName = functionDeclaration.identifier.valueText();

                            if (lastElement && inFunctionOverloadChain) {
                                this.pushDiagnostic1(moduleElementFullStart, moduleElement.firstToken(), TypeScript.DiagnosticCode.Function_implementation_expected);
                                return true;
                            }
                        } else {
                            inFunctionOverloadChain = false;
                            functionOverloadChainName = "";
                        }
                    }

                    moduleElementFullStart += moduleElement.fullWidth();
                }
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkClassOverloads = function (node) {
            if (!this.inAmbientDeclaration && !TypeScript.SyntaxUtilities.containsToken(node.modifiers, 63 /* DeclareKeyword */)) {
                var classElementFullStart = this.childFullStart(node, node.classElements);

                var inFunctionOverloadChain = false;
                var inConstructorOverloadChain = false;

                var functionOverloadChainName = null;
                var isInStaticOverloadChain = null;
                var memberFunctionDeclaration = null;

                for (var i = 0, n = node.classElements.childCount(); i < n; i++) {
                    var classElement = node.classElements.childAt(i);
                    var lastElement = i === (n - 1);
                    var isStaticOverload = null;

                    if (inFunctionOverloadChain) {
                        if (classElement.kind() !== 135 /* MemberFunctionDeclaration */) {
                            this.pushDiagnostic1(classElementFullStart, classElement.firstToken(), TypeScript.DiagnosticCode.Function_implementation_expected);
                            return true;
                        }

                        memberFunctionDeclaration = classElement;
                        if (memberFunctionDeclaration.propertyName.valueText() !== functionOverloadChainName) {
                            var propertyNameFullStart = classElementFullStart + TypeScript.Syntax.childOffset(classElement, memberFunctionDeclaration.propertyName);
                            this.pushDiagnostic1(propertyNameFullStart, memberFunctionDeclaration.propertyName, TypeScript.DiagnosticCode.Function_overload_name_must_be_0, [functionOverloadChainName]);
                            return true;
                        }
                        isStaticOverload = TypeScript.SyntaxUtilities.containsToken(memberFunctionDeclaration.modifiers, 58 /* StaticKeyword */);
                        if (isStaticOverload !== isInStaticOverloadChain) {
                            propertyNameFullStart = classElementFullStart + TypeScript.Syntax.childOffset(classElement, memberFunctionDeclaration.propertyName);
                            var diagnostic = isInStaticOverloadChain ? TypeScript.DiagnosticCode.Function_overload_must_be_static : TypeScript.DiagnosticCode.Function_overload_must_not_be_static;
                            this.pushDiagnostic1(propertyNameFullStart, memberFunctionDeclaration.propertyName, diagnostic, null);
                            return true;
                        }
                    } else if (inConstructorOverloadChain) {
                        if (classElement.kind() !== 137 /* ConstructorDeclaration */) {
                            this.pushDiagnostic1(classElementFullStart, classElement.firstToken(), TypeScript.DiagnosticCode.Constructor_implementation_expected);
                            return true;
                        }
                    }

                    if (classElement.kind() === 135 /* MemberFunctionDeclaration */) {
                        memberFunctionDeclaration = classElement;

                        inFunctionOverloadChain = memberFunctionDeclaration.block === null;
                        functionOverloadChainName = memberFunctionDeclaration.propertyName.valueText();
                        isInStaticOverloadChain = TypeScript.SyntaxUtilities.containsToken(memberFunctionDeclaration.modifiers, 58 /* StaticKeyword */);

                        if (lastElement && inFunctionOverloadChain) {
                            this.pushDiagnostic1(classElementFullStart, classElement.firstToken(), TypeScript.DiagnosticCode.Function_implementation_expected);
                            return true;
                        }
                    } else if (classElement.kind() === 137 /* ConstructorDeclaration */) {
                        var constructorDeclaration = classElement;

                        inConstructorOverloadChain = constructorDeclaration.block === null;
                        if (lastElement && inConstructorOverloadChain) {
                            this.pushDiagnostic1(classElementFullStart, classElement.firstToken(), TypeScript.DiagnosticCode.Constructor_implementation_expected);
                            return true;
                        }
                    }

                    classElementFullStart += classElement.fullWidth();
                }
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkForReservedName = function (parent, name, diagnosticKey) {
            var nameFullStart = this.childFullStart(parent, name);
            var token;
            var tokenFullStart;

            var current = name;
            while (current !== null) {
                if (current.kind() === 121 /* QualifiedName */) {
                    var qualifiedName = current;
                    token = qualifiedName.right;
                    tokenFullStart = nameFullStart + this.childFullStart(qualifiedName, token);
                    current = qualifiedName.left;
                } else {
                    TypeScript.Debug.assert(current.kind() === 11 /* IdentifierName */);
                    token = current;
                    tokenFullStart = nameFullStart;
                    current = null;
                }

                switch (token.valueText()) {
                    case "any":
                    case "number":
                    case "boolean":
                    case "string":
                    case "void":
                        this.pushDiagnostic(tokenFullStart + token.leadingTriviaWidth(), token.width(), diagnosticKey, [token.valueText()]);
                        return true;
                }
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitClassDeclaration = function (node) {
            if (this.checkForReservedName(node, node.identifier, TypeScript.DiagnosticCode.Class_name_cannot_be_0) || this.checkForDisallowedDeclareModifier(node.modifiers) || this.checkForRequiredDeclareModifier(node, node.classKeyword, node.modifiers) || this.checkModuleElementModifiers(node.modifiers) || this.checkClassDeclarationHeritageClauses(node) || this.checkClassOverloads(node)) {
                this.skip(node);
                return;
            }

            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.syntaxTree.isDeclaration() || TypeScript.SyntaxUtilities.containsToken(node.modifiers, 63 /* DeclareKeyword */);
            _super.prototype.visitClassDeclaration.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };

        GrammarCheckerWalker.prototype.checkInterfaceDeclarationHeritageClauses = function (node) {
            var heritageClauseFullStart = this.childFullStart(node, node.heritageClauses);

            var seenExtendsClause = false;

            for (var i = 0, n = node.heritageClauses.childCount(); i < n; i++) {
                TypeScript.Debug.assert(i <= 1);
                var heritageClause = node.heritageClauses.childAt(i);

                if (heritageClause.extendsOrImplementsKeyword.tokenKind === 48 /* ExtendsKeyword */) {
                    if (seenExtendsClause) {
                        this.pushDiagnostic1(heritageClauseFullStart, heritageClause, TypeScript.DiagnosticCode.extends_clause_already_seen);
                        return true;
                    }

                    seenExtendsClause = true;
                } else {
                    TypeScript.Debug.assert(heritageClause.extendsOrImplementsKeyword.tokenKind === 51 /* ImplementsKeyword */);
                    this.pushDiagnostic1(heritageClauseFullStart, heritageClause, TypeScript.DiagnosticCode.Interface_declaration_cannot_have_implements_clause);
                    return true;
                }

                heritageClauseFullStart += heritageClause.fullWidth();
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkInterfaceModifiers = function (modifiers) {
            var modifierFullStart = this.position();

            for (var i = 0, n = modifiers.childCount(); i < n; i++) {
                var modifier = modifiers.childAt(i);
                if (modifier.tokenKind === 63 /* DeclareKeyword */) {
                    this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode.declare_modifier_cannot_appear_on_an_interface_declaration);
                    return true;
                }

                modifierFullStart += modifier.fullWidth();
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitInterfaceDeclaration = function (node) {
            if (this.checkForReservedName(node, node.identifier, TypeScript.DiagnosticCode.Interface_name_cannot_be_0) || this.checkInterfaceModifiers(node.modifiers) || this.checkModuleElementModifiers(node.modifiers) || this.checkInterfaceDeclarationHeritageClauses(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitInterfaceDeclaration.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkClassElementModifiers = function (list) {
            var modifierFullStart = this.position();

            var seenAccessibilityModifier = false;
            var seenStaticModifier = false;

            for (var i = 0, n = list.childCount(); i < n; i++) {
                var modifier = list.childAt(i);
                if (modifier.tokenKind === 57 /* PublicKeyword */ || modifier.tokenKind === 55 /* PrivateKeyword */) {
                    if (seenAccessibilityModifier) {
                        this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode.Accessibility_modifier_already_seen);
                        return true;
                    }

                    if (seenStaticModifier) {
                        var previousToken = list.childAt(i - 1);
                        this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode._0_modifier_must_precede_1_modifier, [modifier.text(), previousToken.text()]);
                        return true;
                    }

                    seenAccessibilityModifier = true;
                } else if (modifier.tokenKind === 58 /* StaticKeyword */) {
                    if (seenStaticModifier) {
                        this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode._0_modifier_already_seen, [modifier.text()]);
                        return true;
                    }

                    seenStaticModifier = true;
                } else {
                    this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode._0_modifier_cannot_appear_on_a_class_element, [modifier.text()]);
                    return true;
                }

                modifierFullStart += modifier.fullWidth();
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitMemberVariableDeclaration = function (node) {
            if (this.checkClassElementModifiers(node.modifiers)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitMemberVariableDeclaration.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitMemberFunctionDeclaration = function (node) {
            if (this.checkClassElementModifiers(node.modifiers)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitMemberFunctionDeclaration.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkGetMemberAccessorParameter = function (node) {
            var getKeywordFullStart = this.childFullStart(node, node.getKeyword);
            if (node.parameterList.parameters.childCount() !== 0) {
                this.pushDiagnostic1(getKeywordFullStart, node.getKeyword, TypeScript.DiagnosticCode.get_accessor_cannot_have_parameters);
                return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkEcmaScriptVersionIsAtLeast = function (parent, node, languageVersion, diagnosticKey) {
            if (this.syntaxTree.parseOptions().languageVersion() < languageVersion) {
                var nodeFullStart = this.childFullStart(parent, node);
                this.pushDiagnostic1(nodeFullStart, node, diagnosticKey);
                return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitGetMemberAccessorDeclaration = function (node) {
            if (this.checkEcmaScriptVersionIsAtLeast(node, node.getKeyword, 1 /* EcmaScript5 */, TypeScript.DiagnosticCode.Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher) || this.checkClassElementModifiers(node.modifiers) || this.checkGetMemberAccessorParameter(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitGetMemberAccessorDeclaration.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkSetMemberAccessorParameter = function (node) {
            var setKeywordFullStart = this.childFullStart(node, node.setKeyword);
            if (node.parameterList.parameters.childCount() !== 1) {
                this.pushDiagnostic1(setKeywordFullStart, node.setKeyword, TypeScript.DiagnosticCode.set_accessor_must_have_one_and_only_one_parameter);
                return true;
            }

            var parameterListFullStart = this.childFullStart(node, node.parameterList);
            var parameterFullStart = parameterListFullStart + TypeScript.Syntax.childOffset(node.parameterList, node.parameterList.openParenToken);
            var parameter = node.parameterList.parameters.childAt(0);

            if (parameter.publicOrPrivateKeyword) {
                this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.set_accessor_parameter_cannot_have_accessibility_modifier);
                return true;
            }

            if (parameter.questionToken) {
                this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.set_accessor_parameter_cannot_be_optional);
                return true;
            }

            if (parameter.equalsValueClause) {
                this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.set_accessor_parameter_cannot_have_an_initializer);
                return true;
            }

            if (parameter.dotDotDotToken) {
                this.pushDiagnostic1(parameterFullStart, parameter, TypeScript.DiagnosticCode.set_accessor_cannot_have_rest_parameter);
                return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitSetMemberAccessorDeclaration = function (node) {
            if (this.checkEcmaScriptVersionIsAtLeast(node, node.setKeyword, 1 /* EcmaScript5 */, TypeScript.DiagnosticCode.Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher) || this.checkClassElementModifiers(node.modifiers) || this.checkSetMemberAccessorParameter(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitSetMemberAccessorDeclaration.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitGetAccessorPropertyAssignment = function (node) {
            if (this.checkEcmaScriptVersionIsAtLeast(node, node.getKeyword, 1 /* EcmaScript5 */, TypeScript.DiagnosticCode.Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitGetAccessorPropertyAssignment.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitSetAccessorPropertyAssignment = function (node) {
            if (this.checkEcmaScriptVersionIsAtLeast(node, node.setKeyword, 1 /* EcmaScript5 */, TypeScript.DiagnosticCode.Accessors_are_only_available_when_targeting_ECMAScript_5_and_higher)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitSetAccessorPropertyAssignment.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitEnumDeclaration = function (node) {
            if (this.checkForReservedName(node, node.identifier, TypeScript.DiagnosticCode.Enum_name_cannot_be_0) || this.checkForDisallowedDeclareModifier(node.modifiers) || this.checkForRequiredDeclareModifier(node, node.enumKeyword, node.modifiers) || this.checkModuleElementModifiers(node.modifiers), this.checkEnumElements(node)) {
                this.skip(node);
                return;
            }

            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.syntaxTree.isDeclaration() || TypeScript.SyntaxUtilities.containsToken(node.modifiers, 63 /* DeclareKeyword */);
            _super.prototype.visitEnumDeclaration.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };

        GrammarCheckerWalker.prototype.checkEnumElements = function (node) {
            var enumElementFullStart = this.childFullStart(node, node.enumElements);

            var seenComputedValue = false;
            for (var i = 0, n = node.enumElements.childCount(); i < n; i++) {
                var child = node.enumElements.childAt(i);

                if (i % 2 === 0) {
                    var enumElement = child;

                    if (!enumElement.equalsValueClause && seenComputedValue) {
                        this.pushDiagnostic1(enumElementFullStart, enumElement, TypeScript.DiagnosticCode.Enum_member_must_have_initializer, null);
                        return true;
                    }

                    if (enumElement.equalsValueClause) {
                        var value = enumElement.equalsValueClause.value;
                        if (!TypeScript.Syntax.isIntegerLiteral(value)) {
                            seenComputedValue = true;
                        }
                    }
                }

                enumElementFullStart += child.fullWidth();
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitEnumElement = function (node) {
            if (this.inAmbientDeclaration && node.equalsValueClause) {
                var expression = node.equalsValueClause.value;
                if (!TypeScript.Syntax.isIntegerLiteral(expression)) {
                    this.pushDiagnostic1(this.childFullStart(node, node.equalsValueClause), node.equalsValueClause.firstToken(), TypeScript.DiagnosticCode.Ambient_enum_elements_can_only_have_integer_literal_initializers);
                    this.skip(node);
                    return;
                }
            }

            _super.prototype.visitEnumElement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitInvocationExpression = function (node) {
            if (node.expression.kind() === 50 /* SuperKeyword */ && node.argumentList.typeArgumentList !== null) {
                this.pushDiagnostic1(this.position(), node, TypeScript.DiagnosticCode.super_invocation_cannot_have_type_arguments);
            }

            _super.prototype.visitInvocationExpression.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkModuleElementModifiers = function (modifiers) {
            var modifierFullStart = this.position();
            var seenExportModifier = false;
            var seenDeclareModifier = false;

            for (var i = 0, n = modifiers.childCount(); i < n; i++) {
                var modifier = modifiers.childAt(i);
                if (modifier.tokenKind === 57 /* PublicKeyword */ || modifier.tokenKind === 55 /* PrivateKeyword */ || modifier.tokenKind === 58 /* StaticKeyword */) {
                    this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode._0_modifier_cannot_appear_on_a_module_element, [modifier.text()]);
                    return true;
                }

                if (modifier.tokenKind === 63 /* DeclareKeyword */) {
                    if (seenDeclareModifier) {
                        this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode.Accessibility_modifier_already_seen);
                        return;
                    }

                    seenDeclareModifier = true;
                } else if (modifier.tokenKind === 47 /* ExportKeyword */) {
                    if (seenExportModifier) {
                        this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode._0_modifier_already_seen, [modifier.text()]);
                        return;
                    }

                    if (seenDeclareModifier) {
                        this.pushDiagnostic1(modifierFullStart, modifier, TypeScript.DiagnosticCode._0_modifier_must_precede_1_modifier, [TypeScript.SyntaxFacts.getText(47 /* ExportKeyword */), TypeScript.SyntaxFacts.getText(63 /* DeclareKeyword */)]);
                        return;
                    }

                    seenExportModifier = true;
                }

                modifierFullStart += modifier.fullWidth();
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkForDisallowedImportDeclaration = function (node) {
            if (node.stringLiteral === null) {
                var currentElementFullStart = this.childFullStart(node, node.moduleElements);

                for (var i = 0, n = node.moduleElements.childCount(); i < n; i++) {
                    var child = node.moduleElements.childAt(i);
                    if (child.kind() === 133 /* ImportDeclaration */) {
                        var importDeclaration = child;
                        if (importDeclaration.moduleReference.kind() === 245 /* ExternalModuleReference */) {
                            this.pushDiagnostic1(currentElementFullStart, importDeclaration, TypeScript.DiagnosticCode.Import_declarations_in_an_internal_module_cannot_reference_an_external_module, null);
                        }
                    }

                    currentElementFullStart += child.fullWidth();
                }
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkForDisallowedDeclareModifierOnImportDeclaration = function (modifiers) {
            var declareToken = TypeScript.SyntaxUtilities.getToken(modifiers, 63 /* DeclareKeyword */);

            if (declareToken) {
                this.pushDiagnostic1(this.childFullStart(modifiers, declareToken), declareToken, TypeScript.DiagnosticCode.declare_modifier_not_allowed_on_import_declaration);
                return true;
            }
        };

        GrammarCheckerWalker.prototype.visitImportDeclaration = function (node) {
            if (this.checkForDisallowedDeclareModifierOnImportDeclaration(node.modifiers) || this.checkModuleElementModifiers(node.modifiers)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitImportDeclaration.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitModuleDeclaration = function (node) {
            if (this.checkForReservedName(node, node.moduleName, TypeScript.DiagnosticCode.Module_name_cannot_be_0) || this.checkForDisallowedDeclareModifier(node.modifiers) || this.checkForRequiredDeclareModifier(node, node.moduleKeyword, node.modifiers) || this.checkModuleElementModifiers(node.modifiers) || this.checkForDisallowedImportDeclaration(node) || this.checkForDisallowedExports(node, node.moduleElements) || this.checkForMultipleExportAssignments(node, node.moduleElements)) {
                this.skip(node);
                return;
            }

            if (!TypeScript.SyntaxUtilities.containsToken(node.modifiers, 63 /* DeclareKeyword */) && this.checkFunctionOverloads(node, node.moduleElements)) {
                this.skip(node);
                return;
            }

            if (node.stringLiteral) {
                if (!this.inAmbientDeclaration && !TypeScript.SyntaxUtilities.containsToken(node.modifiers, 63 /* DeclareKeyword */)) {
                    var stringLiteralFullStart = this.childFullStart(node, node.stringLiteral);
                    this.pushDiagnostic1(stringLiteralFullStart, node.stringLiteral, TypeScript.DiagnosticCode.Only_ambient_modules_can_use_quoted_names);
                    this.skip(node);
                    return;
                }
            }

            if (!node.stringLiteral && this.checkForDisallowedExportAssignment(node)) {
                this.skip(node);
                return;
            }

            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.syntaxTree.isDeclaration() || TypeScript.SyntaxUtilities.containsToken(node.modifiers, 63 /* DeclareKeyword */);
            _super.prototype.visitModuleDeclaration.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };

        GrammarCheckerWalker.prototype.checkForDisallowedExports = function (node, moduleElements) {
            var seenExportedElement = false;
            for (var i = 0, n = moduleElements.childCount(); i < n; i++) {
                var child = moduleElements.childAt(i);

                if (TypeScript.SyntaxUtilities.hasExportKeyword(child)) {
                    seenExportedElement = true;
                    break;
                }
            }

            var moduleElementFullStart = this.childFullStart(node, moduleElements);
            if (seenExportedElement) {
                for (var i = 0, n = moduleElements.childCount(); i < n; i++) {
                    var child = moduleElements.childAt(i);

                    if (child.kind() === 134 /* ExportAssignment */) {
                        this.pushDiagnostic1(moduleElementFullStart, child, TypeScript.DiagnosticCode.Export_assignment_not_allowed_in_module_with_exported_element);
                        return true;
                    }

                    moduleElementFullStart += child.fullWidth();
                }
            }

            return false;
        };

        GrammarCheckerWalker.prototype.checkForMultipleExportAssignments = function (node, moduleElements) {
            var moduleElementFullStart = this.childFullStart(node, moduleElements);
            var seenExportAssignment = false;
            var errorFound = false;
            for (var i = 0, n = moduleElements.childCount(); i < n; i++) {
                var child = moduleElements.childAt(i);
                if (child.kind() === 134 /* ExportAssignment */) {
                    if (seenExportAssignment) {
                        this.pushDiagnostic1(moduleElementFullStart, child, TypeScript.DiagnosticCode.Module_cannot_have_multiple_export_assignments);
                        errorFound = true;
                    }
                    seenExportAssignment = true;
                }

                moduleElementFullStart += child.fullWidth();
            }

            return errorFound;
        };

        GrammarCheckerWalker.prototype.checkForDisallowedExportAssignment = function (node) {
            var moduleElementFullStart = this.childFullStart(node, node.moduleElements);

            for (var i = 0, n = node.moduleElements.childCount(); i < n; i++) {
                var child = node.moduleElements.childAt(i);

                if (child.kind() === 134 /* ExportAssignment */) {
                    this.pushDiagnostic1(moduleElementFullStart, child, TypeScript.DiagnosticCode.Export_assignment_cannot_be_used_in_internal_modules);

                    return true;
                }

                moduleElementFullStart += child.fullWidth();
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitBlock = function (node) {
            if (this.inAmbientDeclaration || this.syntaxTree.isDeclaration()) {
                this.pushDiagnostic1(this.position(), node.firstToken(), TypeScript.DiagnosticCode.Implementations_are_not_allowed_in_ambient_contexts);
                this.skip(node);
                return;
            }

            if (this.checkFunctionOverloads(node, node.statements)) {
                this.skip(node);
                return;
            }

            var savedInBlock = this.inBlock;
            this.inBlock = true;
            _super.prototype.visitBlock.call(this, node);
            this.inBlock = savedInBlock;
        };

        GrammarCheckerWalker.prototype.checkForStatementInAmbientContxt = function (node) {
            if (this.inAmbientDeclaration || this.syntaxTree.isDeclaration()) {
                this.pushDiagnostic1(this.position(), node.firstToken(), TypeScript.DiagnosticCode.Statements_are_not_allowed_in_ambient_contexts);
                return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitBreakStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitBreakStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitContinueStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitContinueStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitDebuggerStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitDebuggerStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitDoStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitDoStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitEmptyStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitEmptyStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitExpressionStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitExpressionStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitForInStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitForInStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitForStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitForStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitIfStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitIfStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitLabeledStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitLabeledStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitReturnStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitReturnStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitSwitchStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitSwitchStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitThrowStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitThrowStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitTryStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitTryStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitWhileStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitWhileStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitWithStatement = function (node) {
            if (this.checkForStatementInAmbientContxt(node)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitWithStatement.call(this, node);
        };

        GrammarCheckerWalker.prototype.checkForDisallowedModifiers = function (parent, modifiers) {
            if (this.inBlock && modifiers.childCount() > 0) {
                var modifierFullStart = this.childFullStart(parent, modifiers);
                this.pushDiagnostic1(modifierFullStart, modifiers.childAt(0), TypeScript.DiagnosticCode.Modifiers_cannot_appear_here);
                return true;
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitFunctionDeclaration = function (node) {
            if (this.checkForDisallowedDeclareModifier(node.modifiers) || this.checkForDisallowedModifiers(node, node.modifiers) || this.checkForRequiredDeclareModifier(node, node.functionKeyword, node.modifiers) || this.checkModuleElementModifiers(node.modifiers)) {
                this.skip(node);
                return;
            }

            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.syntaxTree.isDeclaration() || TypeScript.SyntaxUtilities.containsToken(node.modifiers, 63 /* DeclareKeyword */);
            _super.prototype.visitFunctionDeclaration.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };

        GrammarCheckerWalker.prototype.visitVariableStatement = function (node) {
            if (this.checkForDisallowedDeclareModifier(node.modifiers) || this.checkForDisallowedModifiers(node, node.modifiers) || this.checkForRequiredDeclareModifier(node, node.variableDeclaration, node.modifiers) || this.checkModuleElementModifiers(node.modifiers)) {
                this.skip(node);
                return;
            }

            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = this.inAmbientDeclaration || this.syntaxTree.isDeclaration() || TypeScript.SyntaxUtilities.containsToken(node.modifiers, 63 /* DeclareKeyword */);
            _super.prototype.visitVariableStatement.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };

        GrammarCheckerWalker.prototype.checkListSeparators = function (parent, list, kind) {
            var currentElementFullStart = this.childFullStart(parent, list);

            for (var i = 0, n = list.childCount(); i < n; i++) {
                var child = list.childAt(i);
                if (i % 2 === 1 && child.kind() !== kind) {
                    this.pushDiagnostic1(currentElementFullStart, child, TypeScript.DiagnosticCode._0_expected, [TypeScript.SyntaxFacts.getText(kind)]);
                }

                currentElementFullStart += child.fullWidth();
            }

            return false;
        };

        GrammarCheckerWalker.prototype.visitObjectType = function (node) {
            if (this.checkListSeparators(node, node.typeMembers, 78 /* SemicolonToken */)) {
                this.skip(node);
                return;
            }

            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = true;
            _super.prototype.visitObjectType.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };

        GrammarCheckerWalker.prototype.visitArrayType = function (node) {
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = true;
            _super.prototype.visitArrayType.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };

        GrammarCheckerWalker.prototype.visitFunctionType = function (node) {
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = true;
            _super.prototype.visitFunctionType.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };

        GrammarCheckerWalker.prototype.visitConstructorType = function (node) {
            var savedInAmbientDeclaration = this.inAmbientDeclaration;
            this.inAmbientDeclaration = true;
            _super.prototype.visitConstructorType.call(this, node);
            this.inAmbientDeclaration = savedInAmbientDeclaration;
        };

        GrammarCheckerWalker.prototype.visitVariableDeclarator = function (node) {
            if (this.inAmbientDeclaration && node.equalsValueClause) {
                this.pushDiagnostic1(this.childFullStart(node, node.equalsValueClause), node.equalsValueClause.firstToken(), TypeScript.DiagnosticCode.Initializers_are_not_allowed_in_ambient_contexts);
                this.skip(node);
                return;
            }

            _super.prototype.visitVariableDeclarator.call(this, node);
        };

        GrammarCheckerWalker.prototype.visitConstructorDeclaration = function (node) {
            var savedCurrentConstructor = this.currentConstructor;
            this.currentConstructor = node;
            _super.prototype.visitConstructorDeclaration.call(this, node);
            this.currentConstructor = savedCurrentConstructor;
        };

        GrammarCheckerWalker.prototype.visitSourceUnit = function (node) {
            if (this.checkFunctionOverloads(node, node.moduleElements) || this.checkForDisallowedExports(node, node.moduleElements) || this.checkForMultipleExportAssignments(node, node.moduleElements)) {
                this.skip(node);
                return;
            }

            _super.prototype.visitSourceUnit.call(this, node);
        };
        return GrammarCheckerWalker;
    })(TypeScript.PositionTrackingWalker);
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var TextSpanWalker = (function (_super) {
        __extends(TextSpanWalker, _super);
        function TextSpanWalker(textSpan) {
            _super.call(this);
            this.textSpan = textSpan;
            this._position = 0;
        }
        TextSpanWalker.prototype.visitToken = function (token) {
            this._position += token.fullWidth();
        };

        TextSpanWalker.prototype.visitNode = function (node) {
            var nodeSpan = new TypeScript.TextSpan(this.position(), node.fullWidth());

            if (nodeSpan.intersectsWithTextSpan(this.textSpan)) {
                node.accept(this);
            } else {
                this._position += node.fullWidth();
            }
        };

        TextSpanWalker.prototype.position = function () {
            return this._position;
        };
        return TextSpanWalker;
    })(TypeScript.SyntaxWalker);
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Unicode = (function () {
        function Unicode() {
        }
        Unicode.lookupInUnicodeMap = function (code, map) {
            if (code < map[0]) {
                return false;
            }

            var lo = 0;
            var hi = map.length;
            var mid;

            while (lo + 1 < hi) {
                mid = lo + (hi - lo) / 2;

                mid -= mid % 2;
                if (map[mid] <= code && code <= map[mid + 1]) {
                    return true;
                }

                if (code < map[mid]) {
                    hi = mid;
                } else {
                    lo = mid + 2;
                }
            }

            return false;
        };

        Unicode.isIdentifierStart = function (code, languageVersion) {
            if (languageVersion === 0 /* EcmaScript3 */) {
                return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES3IdentifierStart);
            } else if (languageVersion === 1 /* EcmaScript5 */) {
                return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES5IdentifierStart);
            } else {
                throw TypeScript.Errors.argumentOutOfRange("languageVersion");
            }
        };

        Unicode.isIdentifierPart = function (code, languageVersion) {
            if (languageVersion === 0 /* EcmaScript3 */) {
                return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES3IdentifierPart);
            } else if (languageVersion === 1 /* EcmaScript5 */) {
                return Unicode.lookupInUnicodeMap(code, Unicode.unicodeES5IdentifierPart);
            } else {
                throw TypeScript.Errors.argumentOutOfRange("languageVersion");
            }
        };
        Unicode.unicodeES3IdentifierStart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1569, 1594, 1600, 1610, 1649, 1747, 1749, 1749, 1765, 1766, 1786, 1788, 1808, 1808, 1810, 1836, 1920, 1957, 2309, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2784, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3294, 3294, 3296, 3297, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3424, 3425, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3805, 3840, 3840, 3904, 3911, 3913, 3946, 3976, 3979, 4096, 4129, 4131, 4135, 4137, 4138, 4176, 4181, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6067, 6176, 6263, 6272, 6312, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8319, 8319, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12346, 12353, 12436, 12445, 12446, 12449, 12538, 12540, 12542, 12549, 12588, 12593, 12686, 12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65138, 65140, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500];
        Unicode.unicodeES3IdentifierPart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 543, 546, 563, 592, 685, 688, 696, 699, 705, 720, 721, 736, 740, 750, 750, 768, 846, 864, 866, 890, 890, 902, 902, 904, 906, 908, 908, 910, 929, 931, 974, 976, 983, 986, 1011, 1024, 1153, 1155, 1158, 1164, 1220, 1223, 1224, 1227, 1228, 1232, 1269, 1272, 1273, 1329, 1366, 1369, 1369, 1377, 1415, 1425, 1441, 1443, 1465, 1467, 1469, 1471, 1471, 1473, 1474, 1476, 1476, 1488, 1514, 1520, 1522, 1569, 1594, 1600, 1621, 1632, 1641, 1648, 1747, 1749, 1756, 1759, 1768, 1770, 1773, 1776, 1788, 1808, 1836, 1840, 1866, 1920, 1968, 2305, 2307, 2309, 2361, 2364, 2381, 2384, 2388, 2392, 2403, 2406, 2415, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2492, 2494, 2500, 2503, 2504, 2507, 2509, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2562, 2562, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2649, 2652, 2654, 2654, 2662, 2676, 2689, 2691, 2693, 2699, 2701, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2784, 2790, 2799, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2870, 2873, 2876, 2883, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2913, 2918, 2927, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 2997, 2999, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3031, 3031, 3047, 3055, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3134, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3168, 3169, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3262, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3297, 3302, 3311, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3368, 3370, 3385, 3390, 3395, 3398, 3400, 3402, 3405, 3415, 3415, 3424, 3425, 3430, 3439, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3805, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3946, 3953, 3972, 3974, 3979, 3984, 3991, 3993, 4028, 4038, 4038, 4096, 4129, 4131, 4135, 4137, 4138, 4140, 4146, 4150, 4153, 4160, 4169, 4176, 4185, 4256, 4293, 4304, 4342, 4352, 4441, 4447, 4514, 4520, 4601, 4608, 4614, 4616, 4678, 4680, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4742, 4744, 4744, 4746, 4749, 4752, 4782, 4784, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4814, 4816, 4822, 4824, 4846, 4848, 4878, 4880, 4880, 4882, 4885, 4888, 4894, 4896, 4934, 4936, 4954, 4969, 4977, 5024, 5108, 5121, 5740, 5743, 5750, 5761, 5786, 5792, 5866, 6016, 6099, 6112, 6121, 6160, 6169, 6176, 6263, 6272, 6313, 7680, 7835, 7840, 7929, 7936, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8255, 8256, 8319, 8319, 8400, 8412, 8417, 8417, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8497, 8499, 8505, 8544, 8579, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12346, 12353, 12436, 12441, 12442, 12445, 12446, 12449, 12542, 12549, 12588, 12593, 12686, 12704, 12727, 13312, 19893, 19968, 40869, 40960, 42124, 44032, 55203, 63744, 64045, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65056, 65059, 65075, 65076, 65101, 65103, 65136, 65138, 65140, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65381, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500];

        Unicode.unicodeES5IdentifierStart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 880, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1488, 1514, 1520, 1522, 1568, 1610, 1646, 1647, 1649, 1747, 1749, 1749, 1765, 1766, 1774, 1775, 1786, 1788, 1791, 1791, 1808, 1808, 1810, 1839, 1869, 1957, 1969, 1969, 1994, 2026, 2036, 2037, 2042, 2042, 2048, 2069, 2074, 2074, 2084, 2084, 2088, 2088, 2112, 2136, 2208, 2208, 2210, 2220, 2308, 2361, 2365, 2365, 2384, 2384, 2392, 2401, 2417, 2423, 2425, 2431, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2493, 2493, 2510, 2510, 2524, 2525, 2527, 2529, 2544, 2545, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2649, 2652, 2654, 2654, 2674, 2676, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2749, 2749, 2768, 2768, 2784, 2785, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2877, 2877, 2908, 2909, 2911, 2913, 2929, 2929, 2947, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3024, 3024, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3133, 3160, 3161, 3168, 3169, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3261, 3261, 3294, 3294, 3296, 3297, 3313, 3314, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3389, 3406, 3406, 3424, 3425, 3450, 3455, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3585, 3632, 3634, 3635, 3648, 3654, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3760, 3762, 3763, 3773, 3773, 3776, 3780, 3782, 3782, 3804, 3807, 3840, 3840, 3904, 3911, 3913, 3948, 3976, 3980, 4096, 4138, 4159, 4159, 4176, 4181, 4186, 4189, 4193, 4193, 4197, 4198, 4206, 4208, 4213, 4225, 4238, 4238, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5905, 5920, 5937, 5952, 5969, 5984, 5996, 5998, 6000, 6016, 6067, 6103, 6103, 6108, 6108, 6176, 6263, 6272, 6312, 6314, 6314, 6320, 6389, 6400, 6428, 6480, 6509, 6512, 6516, 6528, 6571, 6593, 6599, 6656, 6678, 6688, 6740, 6823, 6823, 6917, 6963, 6981, 6987, 7043, 7072, 7086, 7087, 7098, 7141, 7168, 7203, 7245, 7247, 7258, 7293, 7401, 7404, 7406, 7409, 7413, 7414, 7424, 7615, 7680, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8305, 8305, 8319, 8319, 8336, 8348, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11502, 11506, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11648, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11823, 11823, 12293, 12295, 12321, 12329, 12337, 12341, 12344, 12348, 12353, 12438, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42527, 42538, 42539, 42560, 42606, 42623, 42647, 42656, 42735, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43009, 43011, 43013, 43015, 43018, 43020, 43042, 43072, 43123, 43138, 43187, 43250, 43255, 43259, 43259, 43274, 43301, 43312, 43334, 43360, 43388, 43396, 43442, 43471, 43471, 43520, 43560, 43584, 43586, 43588, 43595, 43616, 43638, 43642, 43642, 43648, 43695, 43697, 43697, 43701, 43702, 43705, 43709, 43712, 43712, 43714, 43714, 43739, 43741, 43744, 43754, 43762, 43764, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44002, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64285, 64287, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65136, 65140, 65142, 65276, 65313, 65338, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500];
        Unicode.unicodeES5IdentifierPart = [170, 170, 181, 181, 186, 186, 192, 214, 216, 246, 248, 705, 710, 721, 736, 740, 748, 748, 750, 750, 768, 884, 886, 887, 890, 893, 902, 902, 904, 906, 908, 908, 910, 929, 931, 1013, 1015, 1153, 1155, 1159, 1162, 1319, 1329, 1366, 1369, 1369, 1377, 1415, 1425, 1469, 1471, 1471, 1473, 1474, 1476, 1477, 1479, 1479, 1488, 1514, 1520, 1522, 1552, 1562, 1568, 1641, 1646, 1747, 1749, 1756, 1759, 1768, 1770, 1788, 1791, 1791, 1808, 1866, 1869, 1969, 1984, 2037, 2042, 2042, 2048, 2093, 2112, 2139, 2208, 2208, 2210, 2220, 2276, 2302, 2304, 2403, 2406, 2415, 2417, 2423, 2425, 2431, 2433, 2435, 2437, 2444, 2447, 2448, 2451, 2472, 2474, 2480, 2482, 2482, 2486, 2489, 2492, 2500, 2503, 2504, 2507, 2510, 2519, 2519, 2524, 2525, 2527, 2531, 2534, 2545, 2561, 2563, 2565, 2570, 2575, 2576, 2579, 2600, 2602, 2608, 2610, 2611, 2613, 2614, 2616, 2617, 2620, 2620, 2622, 2626, 2631, 2632, 2635, 2637, 2641, 2641, 2649, 2652, 2654, 2654, 2662, 2677, 2689, 2691, 2693, 2701, 2703, 2705, 2707, 2728, 2730, 2736, 2738, 2739, 2741, 2745, 2748, 2757, 2759, 2761, 2763, 2765, 2768, 2768, 2784, 2787, 2790, 2799, 2817, 2819, 2821, 2828, 2831, 2832, 2835, 2856, 2858, 2864, 2866, 2867, 2869, 2873, 2876, 2884, 2887, 2888, 2891, 2893, 2902, 2903, 2908, 2909, 2911, 2915, 2918, 2927, 2929, 2929, 2946, 2947, 2949, 2954, 2958, 2960, 2962, 2965, 2969, 2970, 2972, 2972, 2974, 2975, 2979, 2980, 2984, 2986, 2990, 3001, 3006, 3010, 3014, 3016, 3018, 3021, 3024, 3024, 3031, 3031, 3046, 3055, 3073, 3075, 3077, 3084, 3086, 3088, 3090, 3112, 3114, 3123, 3125, 3129, 3133, 3140, 3142, 3144, 3146, 3149, 3157, 3158, 3160, 3161, 3168, 3171, 3174, 3183, 3202, 3203, 3205, 3212, 3214, 3216, 3218, 3240, 3242, 3251, 3253, 3257, 3260, 3268, 3270, 3272, 3274, 3277, 3285, 3286, 3294, 3294, 3296, 3299, 3302, 3311, 3313, 3314, 3330, 3331, 3333, 3340, 3342, 3344, 3346, 3386, 3389, 3396, 3398, 3400, 3402, 3406, 3415, 3415, 3424, 3427, 3430, 3439, 3450, 3455, 3458, 3459, 3461, 3478, 3482, 3505, 3507, 3515, 3517, 3517, 3520, 3526, 3530, 3530, 3535, 3540, 3542, 3542, 3544, 3551, 3570, 3571, 3585, 3642, 3648, 3662, 3664, 3673, 3713, 3714, 3716, 3716, 3719, 3720, 3722, 3722, 3725, 3725, 3732, 3735, 3737, 3743, 3745, 3747, 3749, 3749, 3751, 3751, 3754, 3755, 3757, 3769, 3771, 3773, 3776, 3780, 3782, 3782, 3784, 3789, 3792, 3801, 3804, 3807, 3840, 3840, 3864, 3865, 3872, 3881, 3893, 3893, 3895, 3895, 3897, 3897, 3902, 3911, 3913, 3948, 3953, 3972, 3974, 3991, 3993, 4028, 4038, 4038, 4096, 4169, 4176, 4253, 4256, 4293, 4295, 4295, 4301, 4301, 4304, 4346, 4348, 4680, 4682, 4685, 4688, 4694, 4696, 4696, 4698, 4701, 4704, 4744, 4746, 4749, 4752, 4784, 4786, 4789, 4792, 4798, 4800, 4800, 4802, 4805, 4808, 4822, 4824, 4880, 4882, 4885, 4888, 4954, 4957, 4959, 4992, 5007, 5024, 5108, 5121, 5740, 5743, 5759, 5761, 5786, 5792, 5866, 5870, 5872, 5888, 5900, 5902, 5908, 5920, 5940, 5952, 5971, 5984, 5996, 5998, 6000, 6002, 6003, 6016, 6099, 6103, 6103, 6108, 6109, 6112, 6121, 6155, 6157, 6160, 6169, 6176, 6263, 6272, 6314, 6320, 6389, 6400, 6428, 6432, 6443, 6448, 6459, 6470, 6509, 6512, 6516, 6528, 6571, 6576, 6601, 6608, 6617, 6656, 6683, 6688, 6750, 6752, 6780, 6783, 6793, 6800, 6809, 6823, 6823, 6912, 6987, 6992, 7001, 7019, 7027, 7040, 7155, 7168, 7223, 7232, 7241, 7245, 7293, 7376, 7378, 7380, 7414, 7424, 7654, 7676, 7957, 7960, 7965, 7968, 8005, 8008, 8013, 8016, 8023, 8025, 8025, 8027, 8027, 8029, 8029, 8031, 8061, 8064, 8116, 8118, 8124, 8126, 8126, 8130, 8132, 8134, 8140, 8144, 8147, 8150, 8155, 8160, 8172, 8178, 8180, 8182, 8188, 8204, 8205, 8255, 8256, 8276, 8276, 8305, 8305, 8319, 8319, 8336, 8348, 8400, 8412, 8417, 8417, 8421, 8432, 8450, 8450, 8455, 8455, 8458, 8467, 8469, 8469, 8473, 8477, 8484, 8484, 8486, 8486, 8488, 8488, 8490, 8493, 8495, 8505, 8508, 8511, 8517, 8521, 8526, 8526, 8544, 8584, 11264, 11310, 11312, 11358, 11360, 11492, 11499, 11507, 11520, 11557, 11559, 11559, 11565, 11565, 11568, 11623, 11631, 11631, 11647, 11670, 11680, 11686, 11688, 11694, 11696, 11702, 11704, 11710, 11712, 11718, 11720, 11726, 11728, 11734, 11736, 11742, 11744, 11775, 11823, 11823, 12293, 12295, 12321, 12335, 12337, 12341, 12344, 12348, 12353, 12438, 12441, 12442, 12445, 12447, 12449, 12538, 12540, 12543, 12549, 12589, 12593, 12686, 12704, 12730, 12784, 12799, 13312, 19893, 19968, 40908, 40960, 42124, 42192, 42237, 42240, 42508, 42512, 42539, 42560, 42607, 42612, 42621, 42623, 42647, 42655, 42737, 42775, 42783, 42786, 42888, 42891, 42894, 42896, 42899, 42912, 42922, 43000, 43047, 43072, 43123, 43136, 43204, 43216, 43225, 43232, 43255, 43259, 43259, 43264, 43309, 43312, 43347, 43360, 43388, 43392, 43456, 43471, 43481, 43520, 43574, 43584, 43597, 43600, 43609, 43616, 43638, 43642, 43643, 43648, 43714, 43739, 43741, 43744, 43759, 43762, 43766, 43777, 43782, 43785, 43790, 43793, 43798, 43808, 43814, 43816, 43822, 43968, 44010, 44012, 44013, 44016, 44025, 44032, 55203, 55216, 55238, 55243, 55291, 63744, 64109, 64112, 64217, 64256, 64262, 64275, 64279, 64285, 64296, 64298, 64310, 64312, 64316, 64318, 64318, 64320, 64321, 64323, 64324, 64326, 64433, 64467, 64829, 64848, 64911, 64914, 64967, 65008, 65019, 65024, 65039, 65056, 65062, 65075, 65076, 65101, 65103, 65136, 65140, 65142, 65276, 65296, 65305, 65313, 65338, 65343, 65343, 65345, 65370, 65382, 65470, 65474, 65479, 65482, 65487, 65490, 65495, 65498, 65500];
        return Unicode;
    })();
    TypeScript.Unicode = Unicode;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (CompilerDiagnostics) {
        CompilerDiagnostics.debug = false;

        CompilerDiagnostics.diagnosticWriter = null;

        CompilerDiagnostics.analysisPass = 0;

        function Alert(output) {
            if (CompilerDiagnostics.diagnosticWriter) {
                CompilerDiagnostics.diagnosticWriter.Alert(output);
            }
        }
        CompilerDiagnostics.Alert = Alert;

        function debugPrint(s) {
            if (CompilerDiagnostics.debug) {
                Alert(s);
            }
        }
        CompilerDiagnostics.debugPrint = debugPrint;

        function assert(condition, s) {
            if (CompilerDiagnostics.debug) {
                if (!condition) {
                    Alert(s);
                }
            }
        }
        CompilerDiagnostics.assert = assert;
    })(TypeScript.CompilerDiagnostics || (TypeScript.CompilerDiagnostics = {}));
    var CompilerDiagnostics = TypeScript.CompilerDiagnostics;

    var NullLogger = (function () {
        function NullLogger() {
        }
        NullLogger.prototype.information = function () {
            return false;
        };
        NullLogger.prototype.debug = function () {
            return false;
        };
        NullLogger.prototype.warning = function () {
            return false;
        };
        NullLogger.prototype.error = function () {
            return false;
        };
        NullLogger.prototype.fatal = function () {
            return false;
        };
        NullLogger.prototype.log = function (s) {
        };
        return NullLogger;
    })();
    TypeScript.NullLogger = NullLogger;

    function timeFunction(logger, funcDescription, func) {
        var start = (new Date()).getTime();
        var result = func();
        var end = (new Date()).getTime();
        logger.log(funcDescription + " completed in " + (end - start) + " msec");
        return result;
    }
    TypeScript.timeFunction = timeFunction;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    function hasFlag(val, flag) {
        return (val & flag) !== 0;
    }
    TypeScript.hasFlag = hasFlag;

    function withoutFlag(val, flag) {
        return val & ~flag;
    }
    TypeScript.withoutFlag = withoutFlag;

    (function (ASTFlags) {
        ASTFlags[ASTFlags["None"] = 0] = "None";
        ASTFlags[ASTFlags["SingleLine"] = 1 << 1] = "SingleLine";
        ASTFlags[ASTFlags["OptionalName"] = 1 << 2] = "OptionalName";
        ASTFlags[ASTFlags["TypeReference"] = 1 << 3] = "TypeReference";
        ASTFlags[ASTFlags["EnumElement"] = 1 << 4] = "EnumElement";
    })(TypeScript.ASTFlags || (TypeScript.ASTFlags = {}));
    var ASTFlags = TypeScript.ASTFlags;

    (function (DeclFlags) {
        DeclFlags[DeclFlags["None"] = 0] = "None";
        DeclFlags[DeclFlags["Exported"] = 1] = "Exported";
        DeclFlags[DeclFlags["Private"] = 1 << 1] = "Private";
        DeclFlags[DeclFlags["Public"] = 1 << 2] = "Public";
        DeclFlags[DeclFlags["Ambient"] = 1 << 3] = "Ambient";
        DeclFlags[DeclFlags["Static"] = 1 << 4] = "Static";
    })(TypeScript.DeclFlags || (TypeScript.DeclFlags = {}));
    var DeclFlags = TypeScript.DeclFlags;

    (function (ModuleFlags) {
        ModuleFlags[ModuleFlags["None"] = 0] = "None";
        ModuleFlags[ModuleFlags["Exported"] = 1] = "Exported";
        ModuleFlags[ModuleFlags["Private"] = 1 << 1] = "Private";
        ModuleFlags[ModuleFlags["Public"] = 1 << 2] = "Public";
        ModuleFlags[ModuleFlags["Ambient"] = 1 << 3] = "Ambient";
        ModuleFlags[ModuleFlags["Static"] = 1 << 4] = "Static";
        ModuleFlags[ModuleFlags["IsEnum"] = 1 << 7] = "IsEnum";
        ModuleFlags[ModuleFlags["IsWholeFile"] = 1 << 8] = "IsWholeFile";
        ModuleFlags[ModuleFlags["IsDynamic"] = 1 << 9] = "IsDynamic";
    })(TypeScript.ModuleFlags || (TypeScript.ModuleFlags = {}));
    var ModuleFlags = TypeScript.ModuleFlags;

    (function (VariableFlags) {
        VariableFlags[VariableFlags["None"] = 0] = "None";
        VariableFlags[VariableFlags["Exported"] = 1] = "Exported";
        VariableFlags[VariableFlags["Private"] = 1 << 1] = "Private";
        VariableFlags[VariableFlags["Public"] = 1 << 2] = "Public";
        VariableFlags[VariableFlags["Ambient"] = 1 << 3] = "Ambient";
        VariableFlags[VariableFlags["Static"] = 1 << 4] = "Static";
        VariableFlags[VariableFlags["Property"] = 1 << 8] = "Property";
        VariableFlags[VariableFlags["ClassProperty"] = 1 << 11] = "ClassProperty";
        VariableFlags[VariableFlags["EnumElement"] = 1 << 13] = "EnumElement";
        VariableFlags[VariableFlags["ForInVariable"] = 1 << 14] = "ForInVariable";
    })(TypeScript.VariableFlags || (TypeScript.VariableFlags = {}));
    var VariableFlags = TypeScript.VariableFlags;

    (function (FunctionFlags) {
        FunctionFlags[FunctionFlags["None"] = 0] = "None";
        FunctionFlags[FunctionFlags["Exported"] = 1] = "Exported";
        FunctionFlags[FunctionFlags["Private"] = 1 << 1] = "Private";
        FunctionFlags[FunctionFlags["Public"] = 1 << 2] = "Public";
        FunctionFlags[FunctionFlags["Ambient"] = 1 << 3] = "Ambient";
        FunctionFlags[FunctionFlags["Static"] = 1 << 4] = "Static";
        FunctionFlags[FunctionFlags["GetAccessor"] = 1 << 5] = "GetAccessor";
        FunctionFlags[FunctionFlags["SetAccessor"] = 1 << 6] = "SetAccessor";
        FunctionFlags[FunctionFlags["Signature"] = 1 << 7] = "Signature";
        FunctionFlags[FunctionFlags["Method"] = 1 << 8] = "Method";
        FunctionFlags[FunctionFlags["CallMember"] = 1 << 9] = "CallMember";
        FunctionFlags[FunctionFlags["ConstructMember"] = 1 << 10] = "ConstructMember";
        FunctionFlags[FunctionFlags["IsFatArrowFunction"] = 1 << 11] = "IsFatArrowFunction";
        FunctionFlags[FunctionFlags["IndexerMember"] = 1 << 12] = "IndexerMember";
        FunctionFlags[FunctionFlags["IsFunctionExpression"] = 1 << 13] = "IsFunctionExpression";
        FunctionFlags[FunctionFlags["IsFunctionProperty"] = 1 << 14] = "IsFunctionProperty";
    })(TypeScript.FunctionFlags || (TypeScript.FunctionFlags = {}));
    var FunctionFlags = TypeScript.FunctionFlags;

    function ToDeclFlags(fncOrVarOrModuleFlags) {
        return fncOrVarOrModuleFlags;
    }
    TypeScript.ToDeclFlags = ToDeclFlags;

    (function (TypeRelationshipFlags) {
        TypeRelationshipFlags[TypeRelationshipFlags["SuccessfulComparison"] = 0] = "SuccessfulComparison";
        TypeRelationshipFlags[TypeRelationshipFlags["RequiredPropertyIsMissing"] = 1 << 1] = "RequiredPropertyIsMissing";
        TypeRelationshipFlags[TypeRelationshipFlags["IncompatibleSignatures"] = 1 << 2] = "IncompatibleSignatures";
        TypeRelationshipFlags[TypeRelationshipFlags["SourceSignatureHasTooManyParameters"] = 3] = "SourceSignatureHasTooManyParameters";
        TypeRelationshipFlags[TypeRelationshipFlags["IncompatibleReturnTypes"] = 1 << 4] = "IncompatibleReturnTypes";
        TypeRelationshipFlags[TypeRelationshipFlags["IncompatiblePropertyTypes"] = 1 << 5] = "IncompatiblePropertyTypes";
        TypeRelationshipFlags[TypeRelationshipFlags["IncompatibleParameterTypes"] = 1 << 6] = "IncompatibleParameterTypes";
        TypeRelationshipFlags[TypeRelationshipFlags["InconsistantPropertyAccesibility"] = 1 << 7] = "InconsistantPropertyAccesibility";
    })(TypeScript.TypeRelationshipFlags || (TypeScript.TypeRelationshipFlags = {}));
    var TypeRelationshipFlags = TypeScript.TypeRelationshipFlags;

    (function (ModuleGenTarget) {
        ModuleGenTarget[ModuleGenTarget["Unspecified"] = 0] = "Unspecified";
        ModuleGenTarget[ModuleGenTarget["Synchronous"] = 1] = "Synchronous";
        ModuleGenTarget[ModuleGenTarget["Asynchronous"] = 2] = "Asynchronous";
    })(TypeScript.ModuleGenTarget || (TypeScript.ModuleGenTarget = {}));
    var ModuleGenTarget = TypeScript.ModuleGenTarget;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (NodeType) {
        NodeType[NodeType["None"] = 0] = "None";
        NodeType[NodeType["List"] = 1] = "List";
        NodeType[NodeType["Script"] = 2] = "Script";

        NodeType[NodeType["TrueLiteral"] = 3] = "TrueLiteral";
        NodeType[NodeType["FalseLiteral"] = 4] = "FalseLiteral";
        NodeType[NodeType["StringLiteral"] = 5] = "StringLiteral";
        NodeType[NodeType["RegularExpressionLiteral"] = 6] = "RegularExpressionLiteral";
        NodeType[NodeType["NumericLiteral"] = 7] = "NumericLiteral";
        NodeType[NodeType["NullLiteral"] = 8] = "NullLiteral";

        NodeType[NodeType["TypeParameter"] = 9] = "TypeParameter";
        NodeType[NodeType["GenericType"] = 10] = "GenericType";
        NodeType[NodeType["TypeRef"] = 11] = "TypeRef";
        NodeType[NodeType["TypeQuery"] = 12] = "TypeQuery";

        NodeType[NodeType["FunctionDeclaration"] = 13] = "FunctionDeclaration";
        NodeType[NodeType["ClassDeclaration"] = 14] = "ClassDeclaration";
        NodeType[NodeType["InterfaceDeclaration"] = 15] = "InterfaceDeclaration";
        NodeType[NodeType["ModuleDeclaration"] = 16] = "ModuleDeclaration";
        NodeType[NodeType["ImportDeclaration"] = 17] = "ImportDeclaration";
        NodeType[NodeType["VariableDeclarator"] = 18] = "VariableDeclarator";
        NodeType[NodeType["VariableDeclaration"] = 19] = "VariableDeclaration";
        NodeType[NodeType["Parameter"] = 20] = "Parameter";

        NodeType[NodeType["Name"] = 21] = "Name";
        NodeType[NodeType["ArrayLiteralExpression"] = 22] = "ArrayLiteralExpression";
        NodeType[NodeType["ObjectLiteralExpression"] = 23] = "ObjectLiteralExpression";
        NodeType[NodeType["OmittedExpression"] = 24] = "OmittedExpression";
        NodeType[NodeType["VoidExpression"] = 25] = "VoidExpression";
        NodeType[NodeType["CommaExpression"] = 26] = "CommaExpression";
        NodeType[NodeType["PlusExpression"] = 27] = "PlusExpression";
        NodeType[NodeType["NegateExpression"] = 28] = "NegateExpression";
        NodeType[NodeType["DeleteExpression"] = 29] = "DeleteExpression";
        NodeType[NodeType["ThisExpression"] = 30] = "ThisExpression";
        NodeType[NodeType["SuperExpression"] = 31] = "SuperExpression";
        NodeType[NodeType["InExpression"] = 32] = "InExpression";
        NodeType[NodeType["MemberAccessExpression"] = 33] = "MemberAccessExpression";
        NodeType[NodeType["InstanceOfExpression"] = 34] = "InstanceOfExpression";
        NodeType[NodeType["TypeOfExpression"] = 35] = "TypeOfExpression";
        NodeType[NodeType["ElementAccessExpression"] = 36] = "ElementAccessExpression";
        NodeType[NodeType["InvocationExpression"] = 37] = "InvocationExpression";
        NodeType[NodeType["ObjectCreationExpression"] = 38] = "ObjectCreationExpression";
        NodeType[NodeType["AssignmentExpression"] = 39] = "AssignmentExpression";
        NodeType[NodeType["AddAssignmentExpression"] = 40] = "AddAssignmentExpression";
        NodeType[NodeType["SubtractAssignmentExpression"] = 41] = "SubtractAssignmentExpression";
        NodeType[NodeType["DivideAssignmentExpression"] = 42] = "DivideAssignmentExpression";
        NodeType[NodeType["MultiplyAssignmentExpression"] = 43] = "MultiplyAssignmentExpression";
        NodeType[NodeType["ModuloAssignmentExpression"] = 44] = "ModuloAssignmentExpression";
        NodeType[NodeType["AndAssignmentExpression"] = 45] = "AndAssignmentExpression";
        NodeType[NodeType["ExclusiveOrAssignmentExpression"] = 46] = "ExclusiveOrAssignmentExpression";
        NodeType[NodeType["OrAssignmentExpression"] = 47] = "OrAssignmentExpression";
        NodeType[NodeType["LeftShiftAssignmentExpression"] = 48] = "LeftShiftAssignmentExpression";
        NodeType[NodeType["SignedRightShiftAssignmentExpression"] = 49] = "SignedRightShiftAssignmentExpression";
        NodeType[NodeType["UnsignedRightShiftAssignmentExpression"] = 50] = "UnsignedRightShiftAssignmentExpression";
        NodeType[NodeType["ConditionalExpression"] = 51] = "ConditionalExpression";
        NodeType[NodeType["LogicalOrExpression"] = 52] = "LogicalOrExpression";
        NodeType[NodeType["LogicalAndExpression"] = 53] = "LogicalAndExpression";
        NodeType[NodeType["BitwiseOrExpression"] = 54] = "BitwiseOrExpression";
        NodeType[NodeType["BitwiseExclusiveOrExpression"] = 55] = "BitwiseExclusiveOrExpression";
        NodeType[NodeType["BitwiseAndExpression"] = 56] = "BitwiseAndExpression";
        NodeType[NodeType["EqualsWithTypeConversionExpression"] = 57] = "EqualsWithTypeConversionExpression";
        NodeType[NodeType["NotEqualsWithTypeConversionExpression"] = 58] = "NotEqualsWithTypeConversionExpression";
        NodeType[NodeType["EqualsExpression"] = 59] = "EqualsExpression";
        NodeType[NodeType["NotEqualsExpression"] = 60] = "NotEqualsExpression";
        NodeType[NodeType["LessThanExpression"] = 61] = "LessThanExpression";
        NodeType[NodeType["LessThanOrEqualExpression"] = 62] = "LessThanOrEqualExpression";
        NodeType[NodeType["GreaterThanExpression"] = 63] = "GreaterThanExpression";
        NodeType[NodeType["GreaterThanOrEqualExpression"] = 64] = "GreaterThanOrEqualExpression";
        NodeType[NodeType["AddExpression"] = 65] = "AddExpression";
        NodeType[NodeType["SubtractExpression"] = 66] = "SubtractExpression";
        NodeType[NodeType["MultiplyExpression"] = 67] = "MultiplyExpression";
        NodeType[NodeType["DivideExpression"] = 68] = "DivideExpression";
        NodeType[NodeType["ModuloExpression"] = 69] = "ModuloExpression";
        NodeType[NodeType["LeftShiftExpression"] = 70] = "LeftShiftExpression";
        NodeType[NodeType["SignedRightShiftExpression"] = 71] = "SignedRightShiftExpression";
        NodeType[NodeType["UnsignedRightShiftExpression"] = 72] = "UnsignedRightShiftExpression";
        NodeType[NodeType["BitwiseNotExpression"] = 73] = "BitwiseNotExpression";
        NodeType[NodeType["LogicalNotExpression"] = 74] = "LogicalNotExpression";
        NodeType[NodeType["PreIncrementExpression"] = 75] = "PreIncrementExpression";
        NodeType[NodeType["PreDecrementExpression"] = 76] = "PreDecrementExpression";
        NodeType[NodeType["PostIncrementExpression"] = 77] = "PostIncrementExpression";
        NodeType[NodeType["PostDecrementExpression"] = 78] = "PostDecrementExpression";
        NodeType[NodeType["CastExpression"] = 79] = "CastExpression";
        NodeType[NodeType["ParenthesizedExpression"] = 80] = "ParenthesizedExpression";
        NodeType[NodeType["Member"] = 81] = "Member";

        NodeType[NodeType["Block"] = 82] = "Block";
        NodeType[NodeType["BreakStatement"] = 83] = "BreakStatement";
        NodeType[NodeType["ContinueStatement"] = 84] = "ContinueStatement";
        NodeType[NodeType["DebuggerStatement"] = 85] = "DebuggerStatement";
        NodeType[NodeType["DoStatement"] = 86] = "DoStatement";
        NodeType[NodeType["EmptyStatement"] = 87] = "EmptyStatement";
        NodeType[NodeType["ExportAssignment"] = 88] = "ExportAssignment";
        NodeType[NodeType["ExpressionStatement"] = 89] = "ExpressionStatement";
        NodeType[NodeType["ForInStatement"] = 90] = "ForInStatement";
        NodeType[NodeType["ForStatement"] = 91] = "ForStatement";
        NodeType[NodeType["IfStatement"] = 92] = "IfStatement";
        NodeType[NodeType["LabeledStatement"] = 93] = "LabeledStatement";
        NodeType[NodeType["ReturnStatement"] = 94] = "ReturnStatement";
        NodeType[NodeType["SwitchStatement"] = 95] = "SwitchStatement";
        NodeType[NodeType["ThrowStatement"] = 96] = "ThrowStatement";
        NodeType[NodeType["TryStatement"] = 97] = "TryStatement";
        NodeType[NodeType["VariableStatement"] = 98] = "VariableStatement";
        NodeType[NodeType["WhileStatement"] = 99] = "WhileStatement";
        NodeType[NodeType["WithStatement"] = 100] = "WithStatement";

        NodeType[NodeType["CaseClause"] = 101] = "CaseClause";
        NodeType[NodeType["CatchClause"] = 102] = "CatchClause";

        NodeType[NodeType["Comment"] = 103] = "Comment";
    })(TypeScript.NodeType || (TypeScript.NodeType = {}));
    var NodeType = TypeScript.NodeType;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var BlockIntrinsics = (function () {
        function BlockIntrinsics() {
            this.prototype = undefined;
            this.toString = undefined;
            this.toLocaleString = undefined;
            this.valueOf = undefined;
            this.hasOwnProperty = undefined;
            this.propertyIsEnumerable = undefined;
            this.isPrototypeOf = undefined;
            this["constructor"] = undefined;
        }
        return BlockIntrinsics;
    })();
    TypeScript.BlockIntrinsics = BlockIntrinsics;

    var StringHashTable = (function () {
        function StringHashTable() {
            this.itemCount = 0;
            this.table = (new BlockIntrinsics());
        }
        StringHashTable.prototype.getAllKeys = function () {
            var result = [];

            for (var k in this.table) {
                if (this.table[k] !== undefined) {
                    result.push(k);
                }
            }

            return result;
        };

        StringHashTable.prototype.add = function (key, data) {
            if (this.table[key] !== undefined) {
                return false;
            }

            this.table[key] = data;
            this.itemCount++;
            return true;
        };

        StringHashTable.prototype.addOrUpdate = function (key, data) {
            if (this.table[key] !== undefined) {
                this.table[key] = data;
                return false;
            }

            this.table[key] = data;
            this.itemCount++;
            return true;
        };

        StringHashTable.prototype.map = function (fn, context) {
            for (var k in this.table) {
                var data = this.table[k];

                if (data !== undefined) {
                    fn(k, this.table[k], context);
                }
            }
        };

        StringHashTable.prototype.every = function (fn, context) {
            for (var k in this.table) {
                var data = this.table[k];

                if (data !== undefined) {
                    if (!fn(k, this.table[k], context)) {
                        return false;
                    }
                }
            }

            return true;
        };

        StringHashTable.prototype.some = function (fn, context) {
            for (var k in this.table) {
                var data = this.table[k];

                if (data !== undefined) {
                    if (fn(k, this.table[k], context)) {
                        return true;
                    }
                }
            }

            return false;
        };

        StringHashTable.prototype.count = function () {
            return this.itemCount;
        };

        StringHashTable.prototype.lookup = function (key) {
            var data = this.table[key];
            return data === undefined ? null : data;
        };
        return StringHashTable;
    })();
    TypeScript.StringHashTable = StringHashTable;

    var IdentiferNameHashTable = (function (_super) {
        __extends(IdentiferNameHashTable, _super);
        function IdentiferNameHashTable() {
            _super.apply(this, arguments);
        }
        IdentiferNameHashTable.prototype.getAllKeys = function () {
            var result = [];

            _super.prototype.map.call(this, function (k, v, c) {
                if (v !== undefined) {
                    result.push(k.substring(1));
                }
            }, null);

            return result;
        };

        IdentiferNameHashTable.prototype.add = function (key, data) {
            return _super.prototype.add.call(this, "#" + key, data);
        };

        IdentiferNameHashTable.prototype.addOrUpdate = function (key, data) {
            return _super.prototype.addOrUpdate.call(this, "#" + key, data);
        };

        IdentiferNameHashTable.prototype.map = function (fn, context) {
            return _super.prototype.map.call(this, function (k, v, c) {
                return fn(k.substring(1), v, c);
            }, context);
        };

        IdentiferNameHashTable.prototype.every = function (fn, context) {
            return _super.prototype.every.call(this, function (k, v, c) {
                return fn(k.substring(1), v, c);
            }, context);
        };

        IdentiferNameHashTable.prototype.some = function (fn, context) {
            return _super.prototype.some.call(this, function (k, v, c) {
                return fn(k.substring(1), v, c);
            }, context);
        };

        IdentiferNameHashTable.prototype.lookup = function (key) {
            return _super.prototype.lookup.call(this, "#" + key);
        };
        return IdentiferNameHashTable;
    })(StringHashTable);
    TypeScript.IdentiferNameHashTable = IdentiferNameHashTable;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var AstWalkOptions = (function () {
        function AstWalkOptions() {
            this.goChildren = true;
        }
        return AstWalkOptions;
    })();
    TypeScript.AstWalkOptions = AstWalkOptions;

    var AstWalker = (function () {
        function AstWalker(childrenWalkers, pre, post, options, state) {
            this.childrenWalkers = childrenWalkers;
            this.pre = pre;
            this.post = post;
            this.options = options;
            this.state = state;
        }
        AstWalker.prototype.walk = function (ast, parent) {
            var preAst = this.pre(ast, parent, this);
            if (preAst === undefined) {
                preAst = ast;
            }
            if (this.options.goChildren) {
                this.childrenWalkers[ast.nodeType()](ast, parent, this);
            } else {
                this.options.goChildren = true;
            }

            if (this.post) {
                var postAst = this.post(preAst, parent, this);
                if (postAst === undefined) {
                    postAst = preAst;
                }
                return postAst;
            } else {
                return preAst;
            }
        };
        return AstWalker;
    })();

    var AstWalkerFactory = (function () {
        function AstWalkerFactory() {
            this.childrenWalkers = [];
            this.initChildrenWalkers();
        }
        AstWalkerFactory.prototype.walk = function (ast, pre, post, options, state) {
            return this.getWalker(pre, post, options, state).walk(ast, null);
        };

        AstWalkerFactory.prototype.getWalker = function (pre, post, options, state) {
            return this.getSlowWalker(pre, post, options, state);
        };

        AstWalkerFactory.prototype.getSlowWalker = function (pre, post, options, state) {
            if (!options) {
                options = new AstWalkOptions();
            }

            return new AstWalker(this.childrenWalkers, pre, post, options, state);
        };

        AstWalkerFactory.prototype.initChildrenWalkers = function () {
            this.childrenWalkers[0 /* None */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[87 /* EmptyStatement */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[24 /* OmittedExpression */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[3 /* TrueLiteral */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[4 /* FalseLiteral */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[30 /* ThisExpression */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[31 /* SuperExpression */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[5 /* StringLiteral */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[6 /* RegularExpressionLiteral */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[8 /* NullLiteral */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[22 /* ArrayLiteralExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[23 /* ObjectLiteralExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[25 /* VoidExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[26 /* CommaExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[27 /* PlusExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[28 /* NegateExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[29 /* DeleteExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[32 /* InExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[33 /* MemberAccessExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[34 /* InstanceOfExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[35 /* TypeOfExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[7 /* NumericLiteral */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[21 /* Name */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[9 /* TypeParameter */] = ChildrenWalkers.walkTypeParameterChildren;
            this.childrenWalkers[10 /* GenericType */] = ChildrenWalkers.walkGenericTypeChildren;
            this.childrenWalkers[11 /* TypeRef */] = ChildrenWalkers.walkTypeReferenceChildren;
            this.childrenWalkers[12 /* TypeQuery */] = ChildrenWalkers.walkTypeQueryChildren;
            this.childrenWalkers[36 /* ElementAccessExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[37 /* InvocationExpression */] = ChildrenWalkers.walkInvocationExpressionChildren;
            this.childrenWalkers[38 /* ObjectCreationExpression */] = ChildrenWalkers.walkObjectCreationExpressionChildren;
            this.childrenWalkers[39 /* AssignmentExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[40 /* AddAssignmentExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[41 /* SubtractAssignmentExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[42 /* DivideAssignmentExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[43 /* MultiplyAssignmentExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[44 /* ModuloAssignmentExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[45 /* AndAssignmentExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[46 /* ExclusiveOrAssignmentExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[47 /* OrAssignmentExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[48 /* LeftShiftAssignmentExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[49 /* SignedRightShiftAssignmentExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[50 /* UnsignedRightShiftAssignmentExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[51 /* ConditionalExpression */] = ChildrenWalkers.walkTrinaryExpressionChildren;
            this.childrenWalkers[52 /* LogicalOrExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[53 /* LogicalAndExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[54 /* BitwiseOrExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[55 /* BitwiseExclusiveOrExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[56 /* BitwiseAndExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[57 /* EqualsWithTypeConversionExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[58 /* NotEqualsWithTypeConversionExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[59 /* EqualsExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[60 /* NotEqualsExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[61 /* LessThanExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[62 /* LessThanOrEqualExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[63 /* GreaterThanExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[64 /* GreaterThanOrEqualExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[65 /* AddExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[66 /* SubtractExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[67 /* MultiplyExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[68 /* DivideExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[69 /* ModuloExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[70 /* LeftShiftExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[71 /* SignedRightShiftExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[72 /* UnsignedRightShiftExpression */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[73 /* BitwiseNotExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[74 /* LogicalNotExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[75 /* PreIncrementExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[76 /* PreDecrementExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[77 /* PostIncrementExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[78 /* PostDecrementExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[79 /* CastExpression */] = ChildrenWalkers.walkUnaryExpressionChildren;
            this.childrenWalkers[80 /* ParenthesizedExpression */] = ChildrenWalkers.walkParenthesizedExpressionChildren;
            this.childrenWalkers[13 /* FunctionDeclaration */] = ChildrenWalkers.walkFuncDeclChildren;
            this.childrenWalkers[81 /* Member */] = ChildrenWalkers.walkBinaryExpressionChildren;
            this.childrenWalkers[18 /* VariableDeclarator */] = ChildrenWalkers.walkBoundDeclChildren;
            this.childrenWalkers[19 /* VariableDeclaration */] = ChildrenWalkers.walkVariableDeclarationChildren;
            this.childrenWalkers[20 /* Parameter */] = ChildrenWalkers.walkBoundDeclChildren;
            this.childrenWalkers[94 /* ReturnStatement */] = ChildrenWalkers.walkReturnStatementChildren;
            this.childrenWalkers[83 /* BreakStatement */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[84 /* ContinueStatement */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[96 /* ThrowStatement */] = ChildrenWalkers.walkThrowStatementChildren;
            this.childrenWalkers[91 /* ForStatement */] = ChildrenWalkers.walkForStatementChildren;
            this.childrenWalkers[90 /* ForInStatement */] = ChildrenWalkers.walkForInStatementChildren;
            this.childrenWalkers[92 /* IfStatement */] = ChildrenWalkers.walkIfStatementChildren;
            this.childrenWalkers[99 /* WhileStatement */] = ChildrenWalkers.walkWhileStatementChildren;
            this.childrenWalkers[86 /* DoStatement */] = ChildrenWalkers.walkDoStatementChildren;
            this.childrenWalkers[82 /* Block */] = ChildrenWalkers.walkBlockChildren;
            this.childrenWalkers[101 /* CaseClause */] = ChildrenWalkers.walkCaseClauseChildren;
            this.childrenWalkers[95 /* SwitchStatement */] = ChildrenWalkers.walkSwitchStatementChildren;
            this.childrenWalkers[97 /* TryStatement */] = ChildrenWalkers.walkTryStatementChildren;
            this.childrenWalkers[102 /* CatchClause */] = ChildrenWalkers.walkCatchClauseChildren;
            this.childrenWalkers[1 /* List */] = ChildrenWalkers.walkListChildren;
            this.childrenWalkers[2 /* Script */] = ChildrenWalkers.walkScriptChildren;
            this.childrenWalkers[14 /* ClassDeclaration */] = ChildrenWalkers.walkClassDeclChildren;
            this.childrenWalkers[15 /* InterfaceDeclaration */] = ChildrenWalkers.walkTypeDeclChildren;
            this.childrenWalkers[16 /* ModuleDeclaration */] = ChildrenWalkers.walkModuleDeclChildren;
            this.childrenWalkers[17 /* ImportDeclaration */] = ChildrenWalkers.walkImportDeclChildren;
            this.childrenWalkers[88 /* ExportAssignment */] = ChildrenWalkers.walkExportAssignmentChildren;
            this.childrenWalkers[100 /* WithStatement */] = ChildrenWalkers.walkWithStatementChildren;
            this.childrenWalkers[89 /* ExpressionStatement */] = ChildrenWalkers.walkExpressionStatementChildren;
            this.childrenWalkers[93 /* LabeledStatement */] = ChildrenWalkers.walkLabeledStatementChildren;
            this.childrenWalkers[98 /* VariableStatement */] = ChildrenWalkers.walkVariableStatementChildren;
            this.childrenWalkers[103 /* Comment */] = ChildrenWalkers.walkNone;
            this.childrenWalkers[85 /* DebuggerStatement */] = ChildrenWalkers.walkNone;

            for (var e in TypeScript.NodeType) {
                if (TypeScript.NodeType.hasOwnProperty(e) && TypeScript.StringUtilities.isString(TypeScript.NodeType[e])) {
                    TypeScript.CompilerDiagnostics.assert(this.childrenWalkers[e] !== undefined, "initWalkers function is not up to date with enum content!");
                }
            }
        };
        return AstWalkerFactory;
    })();
    TypeScript.AstWalkerFactory = AstWalkerFactory;

    var globalAstWalkerFactory;

    function getAstWalkerFactory() {
        if (!globalAstWalkerFactory) {
            globalAstWalkerFactory = new AstWalkerFactory();
        }
        return globalAstWalkerFactory;
    }
    TypeScript.getAstWalkerFactory = getAstWalkerFactory;

    var ChildrenWalkers;
    (function (ChildrenWalkers) {
        function walkNone(preAst, parent, walker) {
        }
        ChildrenWalkers.walkNone = walkNone;

        function walkListChildren(preAst, parent, walker) {
            var len = preAst.members.length;

            for (var i = 0; i < len; i++) {
                preAst.members[i] = walker.walk(preAst.members[i], preAst);
            }
        }
        ChildrenWalkers.walkListChildren = walkListChildren;

        function walkThrowStatementChildren(preAst, parent, walker) {
            if (preAst.expression) {
                preAst.expression = walker.walk(preAst.expression, preAst);
            }
        }
        ChildrenWalkers.walkThrowStatementChildren = walkThrowStatementChildren;

        function walkUnaryExpressionChildren(preAst, parent, walker) {
            if (preAst.castTerm) {
                preAst.castTerm = walker.walk(preAst.castTerm, preAst);
            }
            if (preAst.operand) {
                preAst.operand = walker.walk(preAst.operand, preAst);
            }
        }
        ChildrenWalkers.walkUnaryExpressionChildren = walkUnaryExpressionChildren;

        function walkParenthesizedExpressionChildren(preAst, parent, walker) {
            if (preAst.expression) {
                preAst.expression = walker.walk(preAst.expression, preAst);
            }
        }
        ChildrenWalkers.walkParenthesizedExpressionChildren = walkParenthesizedExpressionChildren;

        function walkBinaryExpressionChildren(preAst, parent, walker) {
            if (preAst.operand1) {
                preAst.operand1 = walker.walk(preAst.operand1, preAst);
            }
            if (preAst.operand2) {
                preAst.operand2 = walker.walk(preAst.operand2, preAst);
            }
        }
        ChildrenWalkers.walkBinaryExpressionChildren = walkBinaryExpressionChildren;

        function walkTypeParameterChildren(preAst, parent, walker) {
            if (preAst.name) {
                preAst.name = walker.walk(preAst.name, preAst);
            }

            if (preAst.constraint) {
                preAst.constraint = walker.walk(preAst.constraint, preAst);
            }
        }
        ChildrenWalkers.walkTypeParameterChildren = walkTypeParameterChildren;

        function walkGenericTypeChildren(preAst, parent, walker) {
            if (preAst.name) {
                preAst.name = walker.walk(preAst.name, preAst);
            }

            if (preAst.typeArguments) {
                preAst.typeArguments = walker.walk(preAst.typeArguments, preAst);
            }
        }
        ChildrenWalkers.walkGenericTypeChildren = walkGenericTypeChildren;

        function walkTypeReferenceChildren(preAst, parent, walker) {
            if (preAst.term) {
                preAst.term = walker.walk(preAst.term, preAst);
            }
        }
        ChildrenWalkers.walkTypeReferenceChildren = walkTypeReferenceChildren;

        function walkTypeQueryChildren(preAst, parent, walker) {
            if (preAst.name) {
                preAst.name = walker.walk(preAst.name, preAst);
            }
        }
        ChildrenWalkers.walkTypeQueryChildren = walkTypeQueryChildren;

        function walkInvocationExpressionChildren(preAst, parent, walker) {
            preAst.target = walker.walk(preAst.target, preAst);

            if (preAst.typeArguments) {
                preAst.typeArguments = walker.walk(preAst.typeArguments, preAst);
            }

            if (preAst.arguments) {
                preAst.arguments = walker.walk(preAst.arguments, preAst);
            }
        }
        ChildrenWalkers.walkInvocationExpressionChildren = walkInvocationExpressionChildren;

        function walkObjectCreationExpressionChildren(preAst, parent, walker) {
            preAst.target = walker.walk(preAst.target, preAst);

            if (preAst.typeArguments) {
                preAst.typeArguments = walker.walk(preAst.typeArguments, preAst);
            }

            if (preAst.arguments) {
                preAst.arguments = walker.walk(preAst.arguments, preAst);
            }
        }
        ChildrenWalkers.walkObjectCreationExpressionChildren = walkObjectCreationExpressionChildren;

        function walkTrinaryExpressionChildren(preAst, parent, walker) {
            if (preAst.operand1) {
                preAst.operand1 = walker.walk(preAst.operand1, preAst);
            }
            if (preAst.operand2) {
                preAst.operand2 = walker.walk(preAst.operand2, preAst);
            }
            if (preAst.operand3) {
                preAst.operand3 = walker.walk(preAst.operand3, preAst);
            }
        }
        ChildrenWalkers.walkTrinaryExpressionChildren = walkTrinaryExpressionChildren;

        function walkFuncDeclChildren(preAst, parent, walker) {
            if (preAst.name) {
                preAst.name = walker.walk(preAst.name, preAst);
            }
            if (preAst.typeArguments) {
                preAst.typeArguments = walker.walk(preAst.typeArguments, preAst);
            }
            if (preAst.arguments) {
                preAst.arguments = walker.walk(preAst.arguments, preAst);
            }
            if (preAst.returnTypeAnnotation) {
                preAst.returnTypeAnnotation = walker.walk(preAst.returnTypeAnnotation, preAst);
            }
            if (preAst.block) {
                preAst.block = walker.walk(preAst.block, preAst);
            }
        }
        ChildrenWalkers.walkFuncDeclChildren = walkFuncDeclChildren;

        function walkBoundDeclChildren(preAst, parent, walker) {
            if (preAst.id) {
                preAst.id = walker.walk(preAst.id, preAst);
            }
            if (preAst.init) {
                preAst.init = walker.walk(preAst.init, preAst);
            }
            if (preAst.typeExpr) {
                preAst.typeExpr = walker.walk(preAst.typeExpr, preAst);
            }
        }
        ChildrenWalkers.walkBoundDeclChildren = walkBoundDeclChildren;

        function walkReturnStatementChildren(preAst, parent, walker) {
            if (preAst.returnExpression) {
                preAst.returnExpression = walker.walk(preAst.returnExpression, preAst);
            }
        }
        ChildrenWalkers.walkReturnStatementChildren = walkReturnStatementChildren;

        function walkForStatementChildren(preAst, parent, walker) {
            if (preAst.init) {
                preAst.init = walker.walk(preAst.init, preAst);
            }

            if (preAst.cond) {
                preAst.cond = walker.walk(preAst.cond, preAst);
            }

            if (preAst.incr) {
                preAst.incr = walker.walk(preAst.incr, preAst);
            }

            if (preAst.body) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }
        ChildrenWalkers.walkForStatementChildren = walkForStatementChildren;

        function walkForInStatementChildren(preAst, parent, walker) {
            preAst.lval = walker.walk(preAst.lval, preAst);
            preAst.obj = walker.walk(preAst.obj, preAst);

            if (preAst.body) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }
        ChildrenWalkers.walkForInStatementChildren = walkForInStatementChildren;

        function walkIfStatementChildren(preAst, parent, walker) {
            preAst.cond = walker.walk(preAst.cond, preAst);
            if (preAst.thenBod) {
                preAst.thenBod = walker.walk(preAst.thenBod, preAst);
            }
            if (preAst.elseBod) {
                preAst.elseBod = walker.walk(preAst.elseBod, preAst);
            }
        }
        ChildrenWalkers.walkIfStatementChildren = walkIfStatementChildren;

        function walkWhileStatementChildren(preAst, parent, walker) {
            preAst.cond = walker.walk(preAst.cond, preAst);
            if (preAst.body) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }
        ChildrenWalkers.walkWhileStatementChildren = walkWhileStatementChildren;

        function walkDoStatementChildren(preAst, parent, walker) {
            preAst.cond = walker.walk(preAst.cond, preAst);
            if (preAst.body) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }
        ChildrenWalkers.walkDoStatementChildren = walkDoStatementChildren;

        function walkBlockChildren(preAst, parent, walker) {
            if (preAst.statements) {
                preAst.statements = walker.walk(preAst.statements, preAst);
            }
        }
        ChildrenWalkers.walkBlockChildren = walkBlockChildren;

        function walkVariableDeclarationChildren(preAst, parent, walker) {
            if (preAst.declarators) {
                preAst.declarators = walker.walk(preAst.declarators, preAst);
            }
        }
        ChildrenWalkers.walkVariableDeclarationChildren = walkVariableDeclarationChildren;

        function walkCaseClauseChildren(preAst, parent, walker) {
            if (preAst.expr) {
                preAst.expr = walker.walk(preAst.expr, preAst);
            }

            if (preAst.body) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }
        ChildrenWalkers.walkCaseClauseChildren = walkCaseClauseChildren;

        function walkSwitchStatementChildren(preAst, parent, walker) {
            if (preAst.val) {
                preAst.val = walker.walk(preAst.val, preAst);
            }

            if (preAst.caseList) {
                preAst.caseList = walker.walk(preAst.caseList, preAst);
            }
        }
        ChildrenWalkers.walkSwitchStatementChildren = walkSwitchStatementChildren;

        function walkTryStatementChildren(preAst, parent, walker) {
            if (preAst.tryBody) {
                preAst.tryBody = walker.walk(preAst.tryBody, preAst);
            }
            if (preAst.catchClause) {
                preAst.catchClause = walker.walk(preAst.catchClause, preAst);
            }
            if (preAst.finallyBody) {
                preAst.finallyBody = walker.walk(preAst.finallyBody, preAst);
            }
        }
        ChildrenWalkers.walkTryStatementChildren = walkTryStatementChildren;

        function walkCatchClauseChildren(preAst, parent, walker) {
            if (preAst.param) {
                preAst.param = walker.walk(preAst.param, preAst);
            }

            if (preAst.body) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }
        ChildrenWalkers.walkCatchClauseChildren = walkCatchClauseChildren;

        function walkClassDeclChildren(preAst, parent, walker) {
            preAst.name = walker.walk(preAst.name, preAst);

            if (preAst.members) {
                preAst.members = walker.walk(preAst.members, preAst);
            }

            if (preAst.typeParameters) {
                preAst.typeParameters = walker.walk(preAst.typeParameters, preAst);
            }

            if (preAst.extendsList) {
                preAst.extendsList = walker.walk(preAst.extendsList, preAst);
            }

            if (preAst.implementsList) {
                preAst.implementsList = walker.walk(preAst.implementsList, preAst);
            }
        }
        ChildrenWalkers.walkClassDeclChildren = walkClassDeclChildren;

        function walkScriptChildren(preAst, parent, walker) {
            if (preAst.moduleElements) {
                preAst.moduleElements = walker.walk(preAst.moduleElements, preAst);
            }
        }
        ChildrenWalkers.walkScriptChildren = walkScriptChildren;

        function walkTypeDeclChildren(preAst, parent, walker) {
            preAst.name = walker.walk(preAst.name, preAst);
            if (preAst.members) {
                preAst.members = walker.walk(preAst.members, preAst);
            }

            if (preAst.typeParameters) {
                preAst.typeParameters = walker.walk(preAst.typeParameters, preAst);
            }

            if (preAst.extendsList) {
                preAst.extendsList = walker.walk(preAst.extendsList, preAst);
            }

            if (preAst.implementsList) {
                preAst.implementsList = walker.walk(preAst.implementsList, preAst);
            }
        }
        ChildrenWalkers.walkTypeDeclChildren = walkTypeDeclChildren;

        function walkModuleDeclChildren(preAst, parent, walker) {
            preAst.name = walker.walk(preAst.name, preAst);
            if (preAst.members) {
                preAst.members = walker.walk(preAst.members, preAst);
            }
        }
        ChildrenWalkers.walkModuleDeclChildren = walkModuleDeclChildren;

        function walkImportDeclChildren(preAst, parent, walker) {
            if (preAst.id) {
                preAst.id = walker.walk(preAst.id, preAst);
            }
            if (preAst.alias) {
                preAst.alias = walker.walk(preAst.alias, preAst);
            }
        }
        ChildrenWalkers.walkImportDeclChildren = walkImportDeclChildren;

        function walkExportAssignmentChildren(preAst, parent, walker) {
            if (preAst.id) {
                preAst.id = walker.walk(preAst.id, preAst);
            }
        }
        ChildrenWalkers.walkExportAssignmentChildren = walkExportAssignmentChildren;

        function walkWithStatementChildren(preAst, parent, walker) {
            if (preAst.expr) {
                preAst.expr = walker.walk(preAst.expr, preAst);
            }

            if (preAst.body) {
                preAst.body = walker.walk(preAst.body, preAst);
            }
        }
        ChildrenWalkers.walkWithStatementChildren = walkWithStatementChildren;

        function walkExpressionStatementChildren(preAst, parent, walker) {
            preAst.expression = walker.walk(preAst.expression, preAst);
        }
        ChildrenWalkers.walkExpressionStatementChildren = walkExpressionStatementChildren;

        function walkLabeledStatementChildren(preAst, parent, walker) {
            preAst.identifier = walker.walk(preAst.identifier, preAst);
            preAst.statement = walker.walk(preAst.statement, preAst);
        }
        ChildrenWalkers.walkLabeledStatementChildren = walkLabeledStatementChildren;

        function walkVariableStatementChildren(preAst, parent, walker) {
            preAst.declaration = walker.walk(preAst.declaration, preAst);
        }
        ChildrenWalkers.walkVariableStatementChildren = walkVariableStatementChildren;
    })(ChildrenWalkers || (ChildrenWalkers = {}));
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    function max(a, b) {
        return a >= b ? a : b;
    }
    TypeScript.max = max;

    function min(a, b) {
        return a <= b ? a : b;
    }
    TypeScript.min = min;

    var AstPath = (function () {
        function AstPath() {
            this.asts = new Array();
            this.top = -1;
        }
        AstPath.reverseIndexOf = function (items, index) {
            return (items === null || items.length <= index) ? null : items[items.length - index - 1];
        };

        AstPath.prototype.clone = function () {
            var clone = new AstPath();
            clone.asts = this.asts.map(function (value) {
                return value;
            });
            clone.top = this.top;
            return clone;
        };

        AstPath.prototype.pop = function () {
            var head = this.ast();
            this.up();

            while (this.asts.length > this.count()) {
                this.asts.pop();
            }
            return head;
        };

        AstPath.prototype.push = function (ast) {
            while (this.asts.length > this.count()) {
                this.asts.pop();
            }
            this.top = this.asts.length;
            this.asts.push(ast);
        };

        AstPath.prototype.up = function () {
            if (this.top <= -1)
                throw TypeScript.Errors.invalidOperation(TypeScript.getLocalizedText(TypeScript.DiagnosticCode.Invalid_call_to_up, null));
            this.top--;
        };

        AstPath.prototype.down = function () {
            if (this.top === this.ast.length - 1)
                throw TypeScript.Errors.invalidOperation(TypeScript.getLocalizedText(TypeScript.DiagnosticCode.Invalid_call_to_down, null));
            this.top++;
        };

        AstPath.prototype.nodeType = function () {
            if (this.ast() === null)
                return 0 /* None */;
            return this.ast().nodeType();
        };

        AstPath.prototype.ast = function () {
            return AstPath.reverseIndexOf(this.asts, this.asts.length - (this.top + 1));
        };

        AstPath.prototype.parent = function () {
            return AstPath.reverseIndexOf(this.asts, this.asts.length - this.top);
        };

        AstPath.prototype.count = function () {
            return this.top + 1;
        };

        AstPath.prototype.get = function (index) {
            return this.asts[index];
        };

        AstPath.prototype.isNameOfClass = function () {
            if (this.ast() === null || this.parent() === null)
                return false;

            return (this.ast().nodeType() === 21 /* Name */) && (this.parent().nodeType() === 14 /* ClassDeclaration */) && ((this.parent()).name === this.ast());
        };

        AstPath.prototype.isNameOfInterface = function () {
            if (this.ast() === null || this.parent() === null)
                return false;

            return (this.ast().nodeType() === 21 /* Name */) && (this.parent().nodeType() === 15 /* InterfaceDeclaration */) && ((this.parent()).name === this.ast());
        };

        AstPath.prototype.isNameOfArgument = function () {
            if (this.ast() === null || this.parent() === null)
                return false;

            return (this.ast().nodeType() === 21 /* Name */) && (this.parent().nodeType() === 20 /* Parameter */) && ((this.parent()).id === this.ast());
        };

        AstPath.prototype.isNameOfVariable = function () {
            if (this.ast() === null || this.parent() === null)
                return false;

            return (this.ast().nodeType() === 21 /* Name */) && (this.parent().nodeType() === 18 /* VariableDeclarator */) && ((this.parent()).id === this.ast());
        };

        AstPath.prototype.isNameOfModule = function () {
            if (this.ast() === null || this.parent() === null)
                return false;

            return (this.ast().nodeType() === 21 /* Name */) && (this.parent().nodeType() === 16 /* ModuleDeclaration */) && ((this.parent()).name === this.ast());
        };

        AstPath.prototype.isNameOfFunction = function () {
            if (this.ast() === null || this.parent() === null)
                return false;

            return (this.ast().nodeType() === 21 /* Name */) && (this.parent().nodeType() === 13 /* FunctionDeclaration */) && ((this.parent()).name === this.ast());
        };

        AstPath.prototype.isBodyOfFunction = function () {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType() === 13 /* FunctionDeclaration */ && (this.asts[this.top - 1]).block === this.asts[this.top - 0];
        };

        AstPath.prototype.isArgumentListOfFunction = function () {
            return this.count() >= 2 && this.asts[this.top - 0].nodeType() === 1 /* List */ && this.asts[this.top - 1].nodeType() === 13 /* FunctionDeclaration */ && (this.asts[this.top - 1]).arguments === this.asts[this.top - 0];
        };

        AstPath.prototype.isTargetOfCall = function () {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType() === 37 /* InvocationExpression */ && (this.asts[this.top - 1]).target === this.asts[this.top];
        };

        AstPath.prototype.isTargetOfNew = function () {
            return this.count() >= 2 && this.asts[this.top - 1].nodeType() === 38 /* ObjectCreationExpression */ && (this.asts[this.top - 1]).target === this.asts[this.top];
        };

        AstPath.prototype.isInClassImplementsList = function () {
            if (this.ast() === null || this.parent() === null)
                return false;

            return (this.parent().nodeType() === 14 /* ClassDeclaration */) && (this.isMemberOfList((this.parent()).implementsList, this.ast()));
        };

        AstPath.prototype.isInInterfaceExtendsList = function () {
            if (this.ast() === null || this.parent() === null)
                return false;

            return (this.parent().nodeType() === 15 /* InterfaceDeclaration */) && (this.isMemberOfList((this.parent()).extendsList, this.ast()));
        };

        AstPath.prototype.isMemberOfMemberAccessExpression = function () {
            if (this.count() > 1 && this.parent().nodeType() === 33 /* MemberAccessExpression */ && (this.parent()).operand2 === this.asts[this.top]) {
                return true;
            }

            return false;
        };

        AstPath.prototype.isCallExpression = function () {
            return this.count() >= 1 && (this.asts[this.top - 0].nodeType() === 37 /* InvocationExpression */ || this.asts[this.top - 0].nodeType() === 38 /* ObjectCreationExpression */);
        };

        AstPath.prototype.isCallExpressionTarget = function () {
            if (this.count() < 2) {
                return false;
            }

            var current = this.top;

            var nodeType = this.asts[current].nodeType();
            if (nodeType === 30 /* ThisExpression */ || nodeType === 31 /* SuperExpression */ || nodeType === 21 /* Name */) {
                current--;
            }

            while (current >= 0) {
                if (current < this.top && this.asts[current].nodeType() === 33 /* MemberAccessExpression */ && (this.asts[current]).operand2 === this.asts[current + 1]) {
                    current--;
                    continue;
                }

                break;
            }

            return current < this.top && (this.asts[current].nodeType() === 37 /* InvocationExpression */ || this.asts[current].nodeType() === 38 /* ObjectCreationExpression */) && this.asts[current + 1] === (this.asts[current]).target;
        };

        AstPath.prototype.isDeclaration = function () {
            if (this.ast() !== null) {
                switch (this.ast().nodeType()) {
                    case 14 /* ClassDeclaration */:
                    case 15 /* InterfaceDeclaration */:
                    case 16 /* ModuleDeclaration */:
                    case 13 /* FunctionDeclaration */:
                    case 18 /* VariableDeclarator */:
                        return true;
                }
            }

            return false;
        };

        AstPath.prototype.isMemberOfList = function (list, item) {
            if (list && list.members) {
                for (var i = 0, n = list.members.length; i < n; i++) {
                    if (list.members[i] === item) {
                        return true;
                    }
                }
            }

            return false;
        };
        return AstPath;
    })();
    TypeScript.AstPath = AstPath;

    function isValidAstNode(ast) {
        if (ast === null)
            return false;

        if (ast.minChar === -1 || ast.limChar === -1)
            return false;

        return true;
    }
    TypeScript.isValidAstNode = isValidAstNode;

    var AstPathContext = (function () {
        function AstPathContext() {
            this.path = new TypeScript.AstPath();
        }
        return AstPathContext;
    })();
    TypeScript.AstPathContext = AstPathContext;

    function getAstPathToPosition(script, pos, useTrailingTriviaAsLimChar) {
        if (typeof useTrailingTriviaAsLimChar === "undefined") { useTrailingTriviaAsLimChar = true; }
        var lookInComments = function (comments) {
            if (comments && comments.length > 0) {
                for (var i = 0; i < comments.length; i++) {
                    var minChar = comments[i].minChar;
                    var limChar = comments[i].limChar + (useTrailingTriviaAsLimChar ? comments[i].trailingTriviaWidth : 0);
                    if (!comments[i].isBlockComment) {
                        limChar++;
                    }
                    if (pos >= minChar && pos < limChar) {
                        ctx.path.push(comments[i]);
                    }
                }
            }
        };

        var pre = function (cur, parent, walker) {
            if (isValidAstNode(cur)) {
                var isInvalid1 = cur.nodeType() === 89 /* ExpressionStatement */ && cur.getLength() === 0;

                if (isInvalid1) {
                    walker.options.goChildren = false;
                } else {
                    var inclusive = cur.nodeType() === 21 /* Name */ || cur.nodeType() === 33 /* MemberAccessExpression */ || cur.nodeType() === 11 /* TypeRef */ || cur.nodeType() === 19 /* VariableDeclaration */ || cur.nodeType() === 18 /* VariableDeclarator */ || cur.nodeType() === 37 /* InvocationExpression */ || pos === script.limChar + script.trailingTriviaWidth;

                    var minChar = cur.minChar;
                    var limChar = cur.limChar + (useTrailingTriviaAsLimChar ? cur.trailingTriviaWidth : 0) + (inclusive ? 1 : 0);
                    if (pos >= minChar && pos < limChar) {
                        var previous = ctx.path.ast();
                        if (previous === null || (cur.minChar >= previous.minChar && (cur.limChar + (useTrailingTriviaAsLimChar ? cur.trailingTriviaWidth : 0)) <= (previous.limChar + (useTrailingTriviaAsLimChar ? previous.trailingTriviaWidth : 0)))) {
                            ctx.path.push(cur);
                        } else {
                        }
                    }

                    if (pos < limChar) {
                        lookInComments(cur.preComments());
                    }
                    if (pos >= minChar) {
                        lookInComments(cur.postComments());
                    }

                    walker.options.goChildren = (minChar <= pos && pos <= limChar);
                }
            }

            return cur;
        };

        var ctx = new AstPathContext();
        TypeScript.getAstWalkerFactory().walk(script, pre, null, null, ctx);
        return ctx.path;
    }
    TypeScript.getAstPathToPosition = getAstPathToPosition;

    function walkAST(ast, callback) {
        var pre = function (cur, parent, walker) {
            var path = walker.state;
            path.push(cur);
            callback(path, walker);
            return cur;
        };
        var post = function (cur, parent, walker) {
            var path = walker.state;
            path.pop();
            return cur;
        };

        var path = new AstPath();
        TypeScript.getAstWalkerFactory().walk(ast, pre, post, null, path);
    }
    TypeScript.walkAST = walkAST;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var Base64Format = (function () {
        function Base64Format() {
        }
        Base64Format.encode = function (inValue) {
            if (inValue < 64) {
                return Base64Format.encodedValues.charAt(inValue);
            }
            throw TypeError(inValue + ": not a 64 based value");
        };

        Base64Format.decodeChar = function (inChar) {
            if (inChar.length === 1) {
                return Base64Format.encodedValues.indexOf(inChar);
            } else {
                throw TypeError('"' + inChar + '" must have length 1');
            }
        };
        Base64Format.encodedValues = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/';
        return Base64Format;
    })();

    var Base64VLQFormat = (function () {
        function Base64VLQFormat() {
        }
        Base64VLQFormat.encode = function (inValue) {
            if (inValue < 0) {
                inValue = ((-inValue) << 1) + 1;
            } else {
                inValue = inValue << 1;
            }

            var encodedStr = "";
            do {
                var currentDigit = inValue & 31;
                inValue = inValue >> 5;
                if (inValue > 0) {
                    currentDigit = currentDigit | 32;
                }
                encodedStr = encodedStr + Base64Format.encode(currentDigit);
            } while(inValue > 0);

            return encodedStr;
        };

        Base64VLQFormat.decode = function (inString) {
            var result = 0;
            var negative = false;

            var shift = 0;
            for (var i = 0; i < inString.length; i++) {
                var byte = Base64Format.decodeChar(inString[i]);
                if (i === 0) {
                    if ((byte & 1) === 1) {
                        negative = true;
                    }
                    result = (byte >> 1) & 15;
                } else {
                    result = result | ((byte & 31) << shift);
                }

                shift += (i === 0) ? 4 : 5;

                if ((byte & 32) === 32) {
                } else {
                    return { value: negative ? -(result) : result, rest: inString.substr(i + 1) };
                }
            }

            throw new Error(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Base64_value_0_finished_with_a_continuation_bit, [inString]));
        };
        return Base64VLQFormat;
    })();
    TypeScript.Base64VLQFormat = Base64VLQFormat;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SourceMapPosition = (function () {
        function SourceMapPosition() {
        }
        return SourceMapPosition;
    })();
    TypeScript.SourceMapPosition = SourceMapPosition;

    var SourceMapping = (function () {
        function SourceMapping() {
            this.start = new SourceMapPosition();
            this.end = new SourceMapPosition();
            this.nameIndex = -1;
            this.childMappings = [];
        }
        return SourceMapping;
    })();
    TypeScript.SourceMapping = SourceMapping;

    var SourceMapSourceInfo = (function () {
        function SourceMapSourceInfo(oldSourceMapSourceInfo) {
            if (oldSourceMapSourceInfo) {
                this.jsFileName = oldSourceMapSourceInfo.jsFileName;
                this.sourceMapPath = oldSourceMapSourceInfo.sourceMapPath;
                this.sourceMapDirectory = oldSourceMapSourceInfo.sourceMapDirectory;

                this.sourceRoot = oldSourceMapSourceInfo.sourceRoot;
            }
        }
        return SourceMapSourceInfo;
    })();
    TypeScript.SourceMapSourceInfo = SourceMapSourceInfo;

    var SourceMapper = (function () {
        function SourceMapper(jsFile, sourceMapOut, sourceMapSourceInfo) {
            this.jsFile = jsFile;
            this.sourceMapOut = sourceMapOut;
            this.sourceMapSourceInfo = sourceMapSourceInfo;
            this.sourceMappings = [];
            this.currentMappings = [];
            this.names = [];
            this.currentNameIndex = [];
            this.currentMappings.push(this.sourceMappings);
        }
        SourceMapper.emitSourceMapping = function (allSourceMappers) {
            var sourceMapper = allSourceMappers[0];
            sourceMapper.jsFile.WriteLine("//# sourceMappingURL=" + sourceMapper.sourceMapSourceInfo.sourceMapPath);

            var sourceMapOut = sourceMapper.sourceMapOut;
            var mappingsString = "";
            var tsFiles = [];

            var prevEmittedColumn = 0;
            var prevEmittedLine = 0;
            var prevSourceColumn = 0;
            var prevSourceLine = 0;
            var prevSourceIndex = 0;
            var prevNameIndex = 0;
            var namesList = [];
            var namesCount = 0;
            var emitComma = false;

            var recordedPosition = null;
            for (var sourceMapperIndex = 0; sourceMapperIndex < allSourceMappers.length; sourceMapperIndex++) {
                sourceMapper = allSourceMappers[sourceMapperIndex];

                var currentSourceIndex = tsFiles.length;
                tsFiles.push(sourceMapper.sourceMapSourceInfo.tsFilePath);

                if (sourceMapper.names.length > 0) {
                    namesList.push.apply(namesList, sourceMapper.names);
                }

                var recordSourceMapping = function (mappedPosition, nameIndex) {
                    if (recordedPosition !== null && recordedPosition.emittedColumn === mappedPosition.emittedColumn && recordedPosition.emittedLine === mappedPosition.emittedLine) {
                        return;
                    }

                    if (prevEmittedLine !== mappedPosition.emittedLine) {
                        while (prevEmittedLine < mappedPosition.emittedLine) {
                            prevEmittedColumn = 0;
                            mappingsString = mappingsString + ";";
                            prevEmittedLine++;
                        }
                        emitComma = false;
                    } else if (emitComma) {
                        mappingsString = mappingsString + ",";
                    }

                    mappingsString = mappingsString + TypeScript.Base64VLQFormat.encode(mappedPosition.emittedColumn - prevEmittedColumn);
                    prevEmittedColumn = mappedPosition.emittedColumn;

                    mappingsString = mappingsString + TypeScript.Base64VLQFormat.encode(currentSourceIndex - prevSourceIndex);
                    prevSourceIndex = currentSourceIndex;

                    mappingsString = mappingsString + TypeScript.Base64VLQFormat.encode(mappedPosition.sourceLine - 1 - prevSourceLine);
                    prevSourceLine = mappedPosition.sourceLine - 1;

                    mappingsString = mappingsString + TypeScript.Base64VLQFormat.encode(mappedPosition.sourceColumn - prevSourceColumn);
                    prevSourceColumn = mappedPosition.sourceColumn;

                    if (nameIndex >= 0) {
                        mappingsString = mappingsString + TypeScript.Base64VLQFormat.encode(namesCount + nameIndex - prevNameIndex);
                        prevNameIndex = namesCount + nameIndex;
                    }

                    emitComma = true;
                    recordedPosition = mappedPosition;
                };

                var recordSourceMappingSiblings = function (sourceMappings) {
                    for (var i = 0; i < sourceMappings.length; i++) {
                        var sourceMapping = sourceMappings[i];
                        recordSourceMapping(sourceMapping.start, sourceMapping.nameIndex);
                        recordSourceMappingSiblings(sourceMapping.childMappings);
                        recordSourceMapping(sourceMapping.end, sourceMapping.nameIndex);
                    }
                };

                recordSourceMappingSiblings(sourceMapper.sourceMappings);
                namesCount = namesCount + sourceMapper.names.length;
            }

            sourceMapOut.Write(JSON.stringify({
                version: 3,
                file: sourceMapper.sourceMapSourceInfo.jsFileName,
                sourceRoot: sourceMapper.sourceMapSourceInfo.sourceRoot,
                sources: tsFiles,
                names: namesList,
                mappings: mappingsString
            }));

            sourceMapOut.Close();
        };
        SourceMapper.MapFileExtension = ".map";
        return SourceMapper;
    })();
    TypeScript.SourceMapper = SourceMapper;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (EmitContainer) {
        EmitContainer[EmitContainer["Prog"] = 0] = "Prog";
        EmitContainer[EmitContainer["Module"] = 1] = "Module";
        EmitContainer[EmitContainer["DynamicModule"] = 2] = "DynamicModule";
        EmitContainer[EmitContainer["Class"] = 3] = "Class";
        EmitContainer[EmitContainer["Constructor"] = 4] = "Constructor";
        EmitContainer[EmitContainer["Function"] = 5] = "Function";
        EmitContainer[EmitContainer["Args"] = 6] = "Args";
        EmitContainer[EmitContainer["Interface"] = 7] = "Interface";
    })(TypeScript.EmitContainer || (TypeScript.EmitContainer = {}));
    var EmitContainer = TypeScript.EmitContainer;

    var EmitState = (function () {
        function EmitState() {
            this.column = 0;
            this.line = 0;
            this.container = 0 /* Prog */;
        }
        return EmitState;
    })();
    TypeScript.EmitState = EmitState;

    var EmitOptions = (function () {
        function EmitOptions(compilationSettings) {
            this.compilationSettings = compilationSettings;
            this.ioHost = null;
            this.outputMany = true;
            this.commonDirectoryPath = "";
        }
        EmitOptions.prototype.mapOutputFileName = function (document, extensionChanger) {
            if (this.outputMany || document.script.topLevelMod) {
                var updatedFileName = document.fileName;
                if (this.compilationSettings.outDirOption !== "") {
                    updatedFileName = document.fileName.replace(this.commonDirectoryPath, "");
                    updatedFileName = this.compilationSettings.outDirOption + updatedFileName;
                }
                return extensionChanger(updatedFileName, false);
            } else {
                return extensionChanger(this.compilationSettings.outFileOption, true);
            }
        };

        EmitOptions.prototype.decodeSourceMapOptions = function (document, jsFilePath, oldSourceMapSourceInfo) {
            var sourceMapSourceInfo = new TypeScript.SourceMapSourceInfo(oldSourceMapSourceInfo);

            var tsFilePath = TypeScript.switchToForwardSlashes(document.fileName);

            if (!oldSourceMapSourceInfo) {
                var prettyJsFileName = TypeScript.getPrettyName(jsFilePath, false, true);
                var prettyMapFileName = prettyJsFileName + TypeScript.SourceMapper.MapFileExtension;
                sourceMapSourceInfo.jsFileName = prettyJsFileName;

                if (this.compilationSettings.mapRoot) {
                    if (this.outputMany || document.script.topLevelMod) {
                        var sourceMapPath = tsFilePath.replace(this.commonDirectoryPath, "");
                        sourceMapPath = this.compilationSettings.mapRoot + sourceMapPath;
                        sourceMapPath = TypeScript.TypeScriptCompiler.mapToJSFileName(sourceMapPath, false) + TypeScript.SourceMapper.MapFileExtension;
                        sourceMapSourceInfo.sourceMapPath = sourceMapPath;

                        if (TypeScript.isRelative(sourceMapSourceInfo.sourceMapPath)) {
                            sourceMapPath = this.commonDirectoryPath + sourceMapSourceInfo.sourceMapPath;
                        }
                        sourceMapSourceInfo.sourceMapDirectory = TypeScript.getRootFilePath(sourceMapPath);
                    } else {
                        sourceMapSourceInfo.sourceMapPath = this.compilationSettings.mapRoot + prettyMapFileName;
                        sourceMapSourceInfo.sourceMapDirectory = this.compilationSettings.mapRoot;
                        if (TypeScript.isRelative(sourceMapSourceInfo.sourceMapDirectory)) {
                            sourceMapSourceInfo.sourceMapDirectory = TypeScript.getRootFilePath(jsFilePath) + this.compilationSettings.mapRoot;
                        }
                    }
                } else {
                    sourceMapSourceInfo.sourceMapPath = prettyMapFileName;
                    sourceMapSourceInfo.sourceMapDirectory = TypeScript.getRootFilePath(jsFilePath);
                }
                sourceMapSourceInfo.sourceRoot = this.compilationSettings.sourceRoot;
            }

            if (this.compilationSettings.sourceRoot) {
                sourceMapSourceInfo.tsFilePath = TypeScript.getRelativePathToFixedPath(this.commonDirectoryPath, tsFilePath);
            } else {
                sourceMapSourceInfo.tsFilePath = TypeScript.getRelativePathToFixedPath(sourceMapSourceInfo.sourceMapDirectory, tsFilePath);
            }
            return sourceMapSourceInfo;
        };
        return EmitOptions;
    })();
    TypeScript.EmitOptions = EmitOptions;

    var Indenter = (function () {
        function Indenter() {
            this.indentAmt = 0;
        }
        Indenter.prototype.increaseIndent = function () {
            this.indentAmt += Indenter.indentStep;
        };

        Indenter.prototype.decreaseIndent = function () {
            this.indentAmt -= Indenter.indentStep;
        };

        Indenter.prototype.getIndent = function () {
            var indentString = Indenter.indentStrings[this.indentAmt];
            if (indentString === undefined) {
                indentString = "";
                for (var i = 0; i < this.indentAmt; i = i + Indenter.indentStep) {
                    indentString += Indenter.indentStepString;
                }
                Indenter.indentStrings[this.indentAmt] = indentString;
            }
            return indentString;
        };
        Indenter.indentStep = 4;
        Indenter.indentStepString = "    ";
        Indenter.indentStrings = [];
        return Indenter;
    })();
    TypeScript.Indenter = Indenter;

    var Emitter = (function () {
        function Emitter(emittingFileName, outfile, emitOptions, semanticInfoChain) {
            this.emittingFileName = emittingFileName;
            this.outfile = outfile;
            this.emitOptions = emitOptions;
            this.semanticInfoChain = semanticInfoChain;
            this.globalThisCapturePrologueEmitted = false;
            this.extendsPrologueEmitted = false;
            this.thisClassNode = null;
            this.thisFunctionDeclaration = null;
            this.moduleName = "";
            this.emitState = new EmitState();
            this.indenter = new Indenter();
            this.modAliasId = null;
            this.firstModAlias = null;
            this.allSourceMappers = [];
            this.sourceMapper = null;
            this.captureThisStmtString = "var _this = this;";
            this.varListCountStack = [0];
            this.declStack = [];
            this.resolvingContext = new TypeScript.PullTypeResolutionContext();
            this.exportAssignmentIdentifier = null;
            this.document = null;
            this.copyrightElement = null;
            TypeScript.globalSemanticInfoChain = semanticInfoChain;
            TypeScript.globalBinder.semanticInfoChain = semanticInfoChain;
        }
        Emitter.prototype.pushDecl = function (decl) {
            if (decl) {
                this.declStack[this.declStack.length] = decl;
            }
        };

        Emitter.prototype.popDecl = function (decl) {
            if (decl) {
                this.declStack.length--;
            }
        };

        Emitter.prototype.getEnclosingDecl = function () {
            var declStackLen = this.declStack.length;
            var enclosingDecl = declStackLen > 0 ? this.declStack[declStackLen - 1] : null;
            return enclosingDecl;
        };

        Emitter.prototype.setExportAssignmentIdentifier = function (id) {
            this.exportAssignmentIdentifier = id;
        };

        Emitter.prototype.getExportAssignmentIdentifier = function () {
            return this.exportAssignmentIdentifier;
        };

        Emitter.prototype.setDocument = function (document) {
            this.document = document;
        };

        Emitter.prototype.importStatementShouldBeEmitted = function (importDeclAST, unitPath) {
            var importDecl = this.semanticInfoChain.getDeclForAST(importDeclAST, this.document.fileName);
            var pullSymbol = importDecl.getSymbol();
            if (!importDeclAST.isExternalImportDeclaration()) {
                if (pullSymbol.getExportAssignedValueSymbol()) {
                    return true;
                }
                var containerSymbol = pullSymbol.getExportAssignedContainerSymbol();
                if (containerSymbol && containerSymbol.getInstanceSymbol()) {
                    return true;
                }
            }

            return pullSymbol.isUsedAsValue;
        };

        Emitter.prototype.emitImportDeclaration = function (importDeclAST) {
            if (this.importStatementShouldBeEmitted(importDeclAST)) {
                var prevModAliasId = this.modAliasId;
                var prevFirstModAlias = this.firstModAlias;

                this.emitComments(importDeclAST, true);

                var importDecl = this.semanticInfoChain.getDeclForAST(importDeclAST, this.document.fileName);
                var importSymbol = importDecl.getSymbol();

                var parentSymbol = importSymbol.getContainer();
                var parentKind = parentSymbol ? parentSymbol.kind : 0 /* None */;
                var associatedParentSymbol = parentSymbol ? parentSymbol.getAssociatedContainerType() : null;
                var associatedParentSymbolKind = associatedParentSymbol ? associatedParentSymbol.kind : 0 /* None */;

                var needsPropertyAssignment = false;
                var usePropertyAssignmentInsteadOfVarDecl = false;
                var moduleNamePrefix;

                if (TypeScript.hasFlag(importDecl.flags, 1 /* Exported */) && (parentKind == 4 /* Container */ || parentKind === 32 /* DynamicModule */ || associatedParentSymbolKind === 4 /* Container */ || associatedParentSymbolKind === 32 /* DynamicModule */)) {
                    if (importSymbol.getExportAssignedTypeSymbol() || importSymbol.getExportAssignedContainerSymbol()) {
                        needsPropertyAssignment = true;
                    } else {
                        var valueSymbol = importSymbol.getExportAssignedValueSymbol();
                        if (valueSymbol && (valueSymbol.kind == 65536 /* Method */ || valueSymbol.kind == 16384 /* Function */)) {
                            needsPropertyAssignment = true;
                        } else {
                            usePropertyAssignmentInsteadOfVarDecl = true;
                        }
                    }

                    if (this.emitState.container === 2 /* DynamicModule */) {
                        moduleNamePrefix = "exports.";
                    } else {
                        moduleNamePrefix = this.moduleName + ".";
                    }
                }

                this.recordSourceMappingStart(importDeclAST);
                if (usePropertyAssignmentInsteadOfVarDecl) {
                    this.writeToOutput(moduleNamePrefix);
                } else {
                    this.writeToOutput("var ");
                }
                this.writeToOutput(importDeclAST.id.actualText + " = ");
                this.modAliasId = importDeclAST.id.actualText;
                this.firstModAlias = importDeclAST.firstAliasedModToString();
                var aliasAST = importDeclAST.alias.nodeType() === 11 /* TypeRef */ ? (importDeclAST.alias).term : importDeclAST.alias;

                this.emitJavascript(aliasAST, false);
                this.recordSourceMappingEnd(importDeclAST);
                this.writeToOutput(";");

                if (needsPropertyAssignment) {
                    this.writeLineToOutput("");
                    this.emitIndent();
                    this.recordSourceMappingStart(importDeclAST);
                    this.writeToOutput(moduleNamePrefix + importDeclAST.id.actualText + " = " + importDeclAST.id.actualText);
                    this.recordSourceMappingEnd(importDeclAST);
                    this.writeToOutput(";");
                }
                this.emitComments(importDeclAST, false);

                this.modAliasId = prevModAliasId;
                this.firstModAlias = prevFirstModAlias;
            }
        };

        Emitter.prototype.setSourceMappings = function (mapper) {
            this.allSourceMappers.push(mapper);
            this.sourceMapper = mapper;
        };

        Emitter.prototype.updateLineAndColumn = function (s) {
            var lineNumbers = TypeScript.TextUtilities.parseLineStarts(TypeScript.TextFactory.createText(s));
            if (lineNumbers.length > 1) {
                this.emitState.line += lineNumbers.length - 1;
                this.emitState.column = s.length - lineNumbers[lineNumbers.length - 1];
            } else {
                this.emitState.column += s.length;
            }
        };

        Emitter.prototype.writeToOutput = function (s) {
            this.outfile.Write(s);
            this.updateLineAndColumn(s);
        };

        Emitter.prototype.writeToOutputTrimmable = function (s) {
            this.writeToOutput(s);
        };

        Emitter.prototype.writeLineToOutput = function (s) {
            this.outfile.WriteLine(s);
            this.updateLineAndColumn(s);
            this.emitState.column = 0;
            this.emitState.line++;
        };

        Emitter.prototype.writeCaptureThisStatement = function (ast) {
            this.emitIndent();
            this.recordSourceMappingStart(ast);
            this.writeToOutput(this.captureThisStmtString);
            this.recordSourceMappingEnd(ast);
            this.writeLineToOutput("");
        };

        Emitter.prototype.setInVarBlock = function (count) {
            this.varListCountStack[this.varListCountStack.length - 1] = count;
        };

        Emitter.prototype.setContainer = function (c) {
            var temp = this.emitState.container;
            this.emitState.container = c;
            return temp;
        };

        Emitter.prototype.getIndentString = function () {
            return this.indenter.getIndent();
        };

        Emitter.prototype.emitIndent = function () {
            this.writeToOutput(this.getIndentString());
        };

        Emitter.prototype.emitComment = function (comment) {
            if (this.emitOptions.compilationSettings.removeComments) {
                return;
            }

            var text = comment.getText();
            var emitColumn = this.emitState.column;

            if (emitColumn === 0) {
                this.emitIndent();
            }

            if (comment.isBlockComment) {
                this.recordSourceMappingStart(comment);
                this.writeToOutput(text[0]);

                if (text.length > 1 || comment.endsLine) {
                    for (var i = 1; i < text.length; i++) {
                        this.writeLineToOutput("");
                        this.emitIndent();
                        this.writeToOutput(text[i]);
                    }
                    this.recordSourceMappingEnd(comment);
                    this.writeLineToOutput("");
                } else {
                    this.recordSourceMappingEnd(comment);
                    this.writeToOutput(" ");
                    return;
                }
            } else {
                this.recordSourceMappingStart(comment);
                this.writeToOutput(text[0]);
                this.recordSourceMappingEnd(comment);
                this.writeLineToOutput("");
            }

            if (emitColumn != 0) {
                this.emitIndent();
            }
        };

        Emitter.prototype.emitComments = function (ast, pre) {
            var comments;
            if (pre) {
                var preComments = ast.preComments();
                if (preComments && ast === this.copyrightElement) {
                    var copyrightComments = this.getCopyrightComments();
                    comments = preComments.slice(copyrightComments.length);
                } else {
                    comments = preComments;
                }
            } else {
                comments = ast.postComments();
            }

            this.emitCommentsArray(comments);
        };

        Emitter.prototype.emitCommentsArray = function (comments) {
            if (!this.emitOptions.compilationSettings.removeComments && comments) {
                for (var i = 0, n = comments.length; i < n; i++) {
                    this.emitComment(comments[i]);
                }
            }
        };

        Emitter.prototype.emitObjectLiteral = function (objectLiteral) {
            var useNewLines = !TypeScript.hasFlag(objectLiteral.getFlags(), 2 /* SingleLine */);

            this.writeToOutput("{");
            var list = objectLiteral.operand;
            if (list.members.length > 0) {
                if (useNewLines) {
                    this.writeLineToOutput("");
                } else {
                    this.writeToOutput(" ");
                }

                this.indenter.increaseIndent();
                this.emitCommaSeparatedList(list, useNewLines);
                this.indenter.decreaseIndent();
                if (useNewLines) {
                    this.emitIndent();
                } else {
                    this.writeToOutput(" ");
                }
            }
            this.writeToOutput("}");
        };

        Emitter.prototype.emitArrayLiteral = function (arrayLiteral) {
            var useNewLines = !TypeScript.hasFlag(arrayLiteral.getFlags(), 2 /* SingleLine */);

            this.writeToOutput("[");
            var list = arrayLiteral.operand;
            if (list.members.length > 0) {
                if (useNewLines) {
                    this.writeLineToOutput("");
                }

                this.indenter.increaseIndent();
                this.emitCommaSeparatedList(list, useNewLines);
                this.indenter.decreaseIndent();
                if (useNewLines) {
                    this.emitIndent();
                }
            }
            this.writeToOutput("]");
        };

        Emitter.prototype.emitNew = function (objectCreationExpression, target, args) {
            this.writeToOutput("new ");
            if (target.nodeType() === 11 /* TypeRef */) {
                var typeRef = target;
                if (typeRef.arrayCount) {
                    this.writeToOutput("Array()");
                } else {
                    typeRef.term.emit(this);
                    this.writeToOutput("()");
                }
            } else {
                target.emit(this);
                this.recordSourceMappingStart(args);
                this.writeToOutput("(");
                this.emitCommaSeparatedList(args);
                this.recordSourceMappingStart(objectCreationExpression.closeParenSpan);
                this.writeToOutput(")");
                this.recordSourceMappingEnd(objectCreationExpression.closeParenSpan);
                this.recordSourceMappingEnd(args);
            }
        };

        Emitter.prototype.getVarDeclFromIdentifier = function (boundDeclInfo) {
            TypeScript.CompilerDiagnostics.assert(boundDeclInfo.boundDecl && boundDeclInfo.boundDecl.init && boundDeclInfo.boundDecl.init.nodeType() === 21 /* Name */, "The init expression of bound declaration when emitting as constant has to be indentifier");

            var init = boundDeclInfo.boundDecl.init;
            var ident = init;

            var pullSymbol = this.semanticInfoChain.getSymbolForAST(boundDeclInfo.boundDecl, this.document.fileName);

            if (pullSymbol) {
                var pullDecls = pullSymbol.getDeclarations();
                if (pullDecls.length === 1) {
                    var pullDecl = pullDecls[0];
                    var ast = this.semanticInfoChain.getASTForDecl(pullDecl);
                    if (ast && ast.nodeType() === 18 /* VariableDeclarator */) {
                        return { boundDecl: ast, pullDecl: pullDecl };
                    }
                }
            }

            return null;
        };

        Emitter.prototype.getConstantDecl = function (dotExpr) {
            var pullSymbol = this.semanticInfoChain.getSymbolForAST(dotExpr, this.document.fileName);
            if (pullSymbol && pullSymbol.hasFlag(524288 /* Constant */)) {
                var pullDecls = pullSymbol.getDeclarations();
                if (pullDecls.length === 1) {
                    var pullDecl = pullDecls[0];
                    var ast = this.semanticInfoChain.getASTForDecl(pullDecl);
                    if (ast && ast.nodeType() === 18 /* VariableDeclarator */) {
                        return { boundDecl: ast, pullDecl: pullDecl };
                    }
                }
            }

            return null;
        };

        Emitter.prototype.tryEmitConstant = function (dotExpr) {
            if (!this.emitOptions.compilationSettings.propagateEnumConstants) {
                return false;
            }
            var propertyName = dotExpr.operand2;
            var boundDeclInfo = this.getConstantDecl(dotExpr);
            if (boundDeclInfo) {
                var value = boundDeclInfo.boundDecl.constantValue;
                if (value !== null) {
                    this.writeToOutput(value.toString());
                    var comment = " /* ";
                    comment += propertyName.actualText;
                    comment += " */";
                    this.writeToOutput(comment);
                    return true;
                }
            }

            return false;
        };

        Emitter.prototype.emitCall = function (callNode, target, args) {
            if (!this.emitSuperCall(callNode)) {
                if (target.nodeType() === 13 /* FunctionDeclaration */) {
                    this.writeToOutput("(");
                }
                if (callNode.target.nodeType() === 31 /* SuperExpression */ && this.emitState.container === 4 /* Constructor */) {
                    this.writeToOutput("_super.call");
                } else {
                    this.emitJavascript(target, false);
                }
                if (target.nodeType() === 13 /* FunctionDeclaration */) {
                    this.writeToOutput(")");
                }
                this.recordSourceMappingStart(args);
                this.writeToOutput("(");
                if (callNode.target.nodeType() === 31 /* SuperExpression */ && this.emitState.container === 4 /* Constructor */) {
                    this.writeToOutput("this");
                    if (args && args.members.length) {
                        this.writeToOutput(", ");
                    }
                }
                this.emitCommaSeparatedList(args);
                this.recordSourceMappingStart(callNode.closeParenSpan);
                this.writeToOutput(")");
                this.recordSourceMappingEnd(callNode.closeParenSpan);
                this.recordSourceMappingEnd(args);
            }
        };

        Emitter.prototype.emitInnerFunction = function (funcDecl, printName, includePreComments) {
            if (typeof includePreComments === "undefined") { includePreComments = true; }
            var pullDecl = this.semanticInfoChain.getDeclForAST(funcDecl, this.document.fileName);
            this.pushDecl(pullDecl);

            var shouldParenthesize = false;

            if (includePreComments) {
                this.emitComments(funcDecl, true);
            }

            if (shouldParenthesize) {
                this.writeToOutput("(");
            }
            this.recordSourceMappingStart(funcDecl);
            var accessorSymbol = funcDecl.isAccessor() ? TypeScript.PullHelpers.getAccessorSymbol(funcDecl, this.semanticInfoChain, this.document.fileName) : null;
            var container = accessorSymbol ? accessorSymbol.getContainer() : null;
            var containerKind = container ? container.kind : 0 /* None */;
            if (!(funcDecl.isAccessor() && containerKind !== 8 /* Class */ && containerKind !== 33554432 /* ConstructorType */)) {
                this.writeToOutput("function ");
            }

            if (funcDecl.isConstructor) {
                this.writeToOutput(this.thisClassNode.name.actualText);
            }

            if (printName) {
                var id = funcDecl.getNameText();
                if (id && !funcDecl.isAccessor()) {
                    if (funcDecl.name) {
                        this.recordSourceMappingStart(funcDecl.name);
                    }
                    this.writeToOutput(id);
                    if (funcDecl.name) {
                        this.recordSourceMappingEnd(funcDecl.name);
                    }
                }
            }

            this.writeToOutput("(");
            var argsLen = 0;
            if (funcDecl.arguments) {
                this.emitComments(funcDecl.arguments, true);

                var tempContainer = this.setContainer(6 /* Args */);
                argsLen = funcDecl.arguments.members.length;
                var printLen = argsLen;
                if (funcDecl.variableArgList) {
                    printLen--;
                }
                for (var i = 0; i < printLen; i++) {
                    var arg = funcDecl.arguments.members[i];
                    arg.emit(this);

                    if (i < (printLen - 1)) {
                        this.writeToOutput(", ");
                    }
                }
                this.setContainer(tempContainer);

                this.emitComments(funcDecl.arguments, false);
            }
            this.writeLineToOutput(") {");

            if (funcDecl.isConstructor) {
                this.recordSourceMappingNameStart("constructor");
            } else if (funcDecl.isGetAccessor()) {
                this.recordSourceMappingNameStart("get_" + funcDecl.getNameText());
            } else if (funcDecl.isSetAccessor()) {
                this.recordSourceMappingNameStart("set_" + funcDecl.getNameText());
            } else {
                this.recordSourceMappingNameStart(funcDecl.getNameText());
            }
            this.indenter.increaseIndent();

            this.emitDefaultValueAssignments(funcDecl);
            this.emitRestParameterInitializer(funcDecl);

            if (this.shouldCaptureThis(funcDecl)) {
                this.writeCaptureThisStatement(funcDecl);
            }

            if (funcDecl.isConstructor) {
                this.emitConstructorStatements(funcDecl);
            } else {
                this.emitModuleElements(funcDecl.block.statements);
            }

            this.emitCommentsArray(funcDecl.block.closeBraceLeadingComments);

            this.indenter.decreaseIndent();
            this.emitIndent();
            this.recordSourceMappingStart(funcDecl.block.closeBraceSpan);
            this.writeToOutput("}");

            this.recordSourceMappingNameEnd();
            this.recordSourceMappingEnd(funcDecl.block.closeBraceSpan);
            this.recordSourceMappingEnd(funcDecl);

            if (shouldParenthesize) {
                this.writeToOutput(")");
            }

            this.recordSourceMappingEnd(funcDecl);

            this.emitComments(funcDecl, false);

            this.popDecl(pullDecl);
        };

        Emitter.prototype.emitDefaultValueAssignments = function (funcDecl) {
            var n = funcDecl.arguments.members.length;
            if (funcDecl.variableArgList) {
                n--;
            }

            for (var i = 0; i < n; i++) {
                var arg = funcDecl.arguments.members[i];
                if (arg.init) {
                    this.emitIndent();
                    this.recordSourceMappingStart(arg);
                    this.writeToOutput("if (typeof " + arg.id.actualText + " === \"undefined\") { ");
                    this.recordSourceMappingStart(arg.id);
                    this.writeToOutput(arg.id.actualText);
                    this.recordSourceMappingEnd(arg.id);
                    this.writeToOutput(" = ");
                    this.emitJavascript(arg.init, false);
                    this.writeLineToOutput("; }");
                    this.recordSourceMappingEnd(arg);
                }
            }
        };

        Emitter.prototype.emitRestParameterInitializer = function (funcDecl) {
            if (funcDecl.variableArgList) {
                var n = funcDecl.arguments.members.length;
                var lastArg = funcDecl.arguments.members[n - 1];
                this.emitIndent();
                this.recordSourceMappingStart(lastArg);
                this.writeToOutput("var ");
                this.recordSourceMappingStart(lastArg.id);
                this.writeToOutput(lastArg.id.actualText);
                this.recordSourceMappingEnd(lastArg.id);
                this.writeLineToOutput(" = [];");
                this.recordSourceMappingEnd(lastArg);
                this.emitIndent();
                this.writeToOutput("for (");
                this.recordSourceMappingStart(lastArg);
                this.writeToOutput("var _i = 0;");
                this.recordSourceMappingEnd(lastArg);
                this.writeToOutput(" ");
                this.recordSourceMappingStart(lastArg);
                this.writeToOutput("_i < (arguments.length - " + (n - 1) + ")");
                this.recordSourceMappingEnd(lastArg);
                this.writeToOutput("; ");
                this.recordSourceMappingStart(lastArg);
                this.writeToOutput("_i++");
                this.recordSourceMappingEnd(lastArg);
                this.writeLineToOutput(") {");
                this.indenter.increaseIndent();
                this.emitIndent();

                this.recordSourceMappingStart(lastArg);
                this.writeToOutput(lastArg.id.actualText + "[_i] = arguments[_i + " + (n - 1) + "];");
                this.recordSourceMappingEnd(lastArg);
                this.writeLineToOutput("");
                this.indenter.decreaseIndent();
                this.emitIndent();
                this.writeLineToOutput("}");
            }
        };

        Emitter.prototype.getImportDecls = function (fileName) {
            var semanticInfo = this.semanticInfoChain.getUnit(this.document.fileName);
            var result = [];

            var queue = semanticInfo.getTopLevelDecls();

            while (queue.length > 0) {
                var decl = queue.shift();

                if (decl.kind & 256 /* TypeAlias */) {
                    var importStatementAST = semanticInfo.getASTForDecl(decl);
                    if (importStatementAST.alias.nodeType() === 21 /* Name */) {
                        var text = (importStatementAST.alias).actualText;
                        if (TypeScript.isQuoted(text)) {
                            var symbol = decl.getSymbol();
                            var typeSymbol = symbol && symbol.type;
                            if (typeSymbol && typeSymbol !== this.semanticInfoChain.anyTypeSymbol && !typeSymbol.isError()) {
                                result.push(decl);
                            }
                        }
                    }
                }

                queue = queue.concat(decl.getChildDecls());
            }

            return result;
        };

        Emitter.prototype.getModuleImportAndDependencyList = function (moduleDecl) {
            var importList = "";
            var dependencyList = "";

            var semanticInfo = this.semanticInfoChain.getUnit(this.document.fileName);
            var importDecls = this.getImportDecls(this.document.fileName);

            if (importDecls.length) {
                for (var i = 0; i < importDecls.length; i++) {
                    var importStatementDecl = importDecls[i];
                    var importStatementSymbol = importStatementDecl.getSymbol();
                    var importStatementAST = semanticInfo.getASTForDecl(importStatementDecl);

                    if (importStatementSymbol.isUsedAsValue) {
                        if (i <= importDecls.length - 1) {
                            dependencyList += ", ";
                            importList += ", ";
                        }

                        importList += "__" + importStatementDecl.name + "__";
                        dependencyList += importStatementAST.firstAliasedModToString();
                    }
                }
            }

            for (var i = 0; i < moduleDecl.amdDependencies.length; i++) {
                dependencyList += ", \"" + moduleDecl.amdDependencies[i] + "\"";
            }

            return {
                importList: importList,
                dependencyList: dependencyList
            };
        };

        Emitter.prototype.shouldCaptureThis = function (ast) {
            if (ast.nodeType() === 2 /* Script */) {
                var scriptDecl = this.semanticInfoChain.getUnit(this.document.fileName).getTopLevelDecls()[0];
                return (scriptDecl.flags & 262144 /* MustCaptureThis */) === 262144 /* MustCaptureThis */;
            }

            var decl = this.semanticInfoChain.getDeclForAST(ast, this.document.fileName);
            if (decl) {
                return (decl.flags & 262144 /* MustCaptureThis */) === 262144 /* MustCaptureThis */;
            }

            return false;
        };

        Emitter.prototype.emitModule = function (moduleDecl) {
            var pullDecl = this.semanticInfoChain.getDeclForAST(moduleDecl, this.document.fileName);
            this.pushDecl(pullDecl);

            var svModuleName = this.moduleName;
            this.moduleName = moduleDecl.name.actualText;
            if (TypeScript.isTSFile(this.moduleName)) {
                this.moduleName = this.moduleName.substring(0, this.moduleName.length - ".ts".length);
            }

            var isDynamicMod = TypeScript.hasFlag(moduleDecl.getModuleFlags(), 512 /* IsDynamic */);
            var prevOutFile = this.outfile;
            var prevOutFileName = this.emittingFileName;
            var prevAllSourceMappers = this.allSourceMappers;
            var prevSourceMapper = this.sourceMapper;
            var prevColumn = this.emitState.column;
            var prevLine = this.emitState.line;
            var temp = this.setContainer(1 /* Module */);
            var isExported = TypeScript.hasFlag(pullDecl.flags, 1 /* Exported */);
            var isWholeFile = TypeScript.hasFlag(moduleDecl.getModuleFlags(), 256 /* IsWholeFile */);

            if (isDynamicMod) {
                this.setExportAssignmentIdentifier(null);
                this.setContainer(2 /* DynamicModule */);

                this.recordSourceMappingStart(moduleDecl);
                if (this.emitOptions.compilationSettings.moduleGenTarget === 2 /* Asynchronous */) {
                    var dependencyList = "[\"require\", \"exports\"";
                    var importList = "require, exports";

                    var importAndDependencyList = this.getModuleImportAndDependencyList(moduleDecl);
                    importList += importAndDependencyList.importList;
                    dependencyList += importAndDependencyList.dependencyList + "]";

                    this.writeLineToOutput("define(" + dependencyList + "," + " function(" + importList + ") {");
                }
            } else {
                if (!isExported) {
                    this.recordSourceMappingStart(moduleDecl);
                    this.writeToOutput("var ");
                    this.recordSourceMappingStart(moduleDecl.name);
                    this.writeToOutput(this.moduleName);
                    this.recordSourceMappingEnd(moduleDecl.name);
                    this.writeLineToOutput(";");
                    this.recordSourceMappingEnd(moduleDecl);
                    this.emitIndent();
                }

                this.writeToOutput("(");
                this.recordSourceMappingStart(moduleDecl);
                this.writeToOutput("function (");
                this.recordSourceMappingStart(moduleDecl.name);
                this.writeToOutput(this.moduleName);
                this.recordSourceMappingEnd(moduleDecl.name);
                this.writeLineToOutput(") {");
            }

            if (!isWholeFile) {
                this.recordSourceMappingNameStart(this.moduleName);
            }

            if (!isDynamicMod || this.emitOptions.compilationSettings.moduleGenTarget === 2 /* Asynchronous */) {
                this.indenter.increaseIndent();
            }

            if (this.shouldCaptureThis(moduleDecl)) {
                this.writeCaptureThisStatement(moduleDecl);
            }

            this.emitModuleElements(moduleDecl.members);
            if (!isDynamicMod || this.emitOptions.compilationSettings.moduleGenTarget === 2 /* Asynchronous */) {
                this.indenter.decreaseIndent();
            }
            this.emitIndent();

            if (isDynamicMod) {
                var exportAssignmentIdentifier = this.getExportAssignmentIdentifier();
                var exportAssignmentValueSymbol = (pullDecl.getSymbol()).getExportAssignedValueSymbol();

                if (this.emitOptions.compilationSettings.moduleGenTarget === 2 /* Asynchronous */) {
                    if (exportAssignmentIdentifier && exportAssignmentValueSymbol && !(exportAssignmentValueSymbol.kind & TypeScript.PullElementKind.SomeTypeReference)) {
                        this.indenter.increaseIndent();
                        this.emitIndent();
                        this.writeLineToOutput("return " + exportAssignmentIdentifier + ";");
                        this.indenter.decreaseIndent();
                    }
                    this.writeToOutput("});");
                } else if (exportAssignmentIdentifier && exportAssignmentValueSymbol && !(exportAssignmentValueSymbol.kind & TypeScript.PullElementKind.SomeTypeReference)) {
                    this.emitIndent();
                    this.writeLineToOutput("module.exports = " + exportAssignmentIdentifier + ";");
                }

                if (!isWholeFile) {
                    this.recordSourceMappingNameEnd();
                }
                this.recordSourceMappingEnd(moduleDecl);

                if (this.outfile !== prevOutFile) {
                    this.emitSourceMapsAndClose();
                    if (prevSourceMapper !== null) {
                        this.allSourceMappers = prevAllSourceMappers;
                        this.sourceMapper = prevSourceMapper;
                        this.emitState.column = prevColumn;
                        this.emitState.line = prevLine;
                    }
                    this.outfile = prevOutFile;
                    this.emittingFileName = prevOutFileName;
                }
            } else {
                var parentIsDynamic = temp === 2 /* DynamicModule */;
                this.recordSourceMappingStart(moduleDecl.endingToken);
                if (temp === 0 /* Prog */ && isExported) {
                    this.writeToOutput("}");
                    if (!isWholeFile) {
                        this.recordSourceMappingNameEnd();
                    }
                    this.recordSourceMappingEnd(moduleDecl.endingToken);
                    this.writeToOutput(")(this." + this.moduleName + " || (this." + this.moduleName + " = {}));");
                } else if (isExported || temp === 0 /* Prog */) {
                    var dotMod = svModuleName !== "" ? (parentIsDynamic ? "exports" : svModuleName) + "." : svModuleName;
                    this.writeToOutput("}");
                    if (!isWholeFile) {
                        this.recordSourceMappingNameEnd();
                    }
                    this.recordSourceMappingEnd(moduleDecl.endingToken);
                    this.writeToOutput(")(" + dotMod + this.moduleName + " || (" + dotMod + this.moduleName + " = {}));");
                } else if (!isExported && temp !== 0 /* Prog */) {
                    this.writeToOutput("}");
                    if (!isWholeFile) {
                        this.recordSourceMappingNameEnd();
                    }
                    this.recordSourceMappingEnd(moduleDecl.endingToken);
                    this.writeToOutput(")(" + this.moduleName + " || (" + this.moduleName + " = {}));");
                } else {
                    this.writeToOutput("}");
                    if (!isWholeFile) {
                        this.recordSourceMappingNameEnd();
                    }
                    this.recordSourceMappingEnd(moduleDecl.endingToken);
                    this.writeToOutput(")();");
                }

                this.recordSourceMappingEnd(moduleDecl);
                if (temp !== 0 /* Prog */ && isExported) {
                    this.recordSourceMappingStart(moduleDecl);
                    if (parentIsDynamic) {
                        this.writeLineToOutput("");
                        this.emitIndent();
                        this.writeToOutput("var " + this.moduleName + " = exports." + this.moduleName + ";");
                    } else {
                        this.writeLineToOutput("");
                        this.emitIndent();
                        this.writeToOutput("var " + this.moduleName + " = " + svModuleName + "." + this.moduleName + ";");
                    }
                    this.recordSourceMappingEnd(moduleDecl);
                }
            }

            this.setContainer(temp);
            this.moduleName = svModuleName;

            this.popDecl(pullDecl);
        };

        Emitter.prototype.emitEnumElement = function (varDecl) {
            this.emitComments(varDecl, true);
            this.recordSourceMappingStart(varDecl);
            var name = varDecl.id.actualText;
            var quoted = TypeScript.isQuoted(name);
            this.writeToOutput(this.moduleName);
            this.writeToOutput('[');
            this.writeToOutput(this.moduleName);
            this.writeToOutput('[');
            this.writeToOutput(quoted ? name : '"' + name + '"');
            this.writeToOutput('] = ');

            if (varDecl.init) {
                varDecl.init.emit(this);
            } else if (varDecl.constantValue !== null) {
                this.writeToOutput(varDecl.constantValue.toString());
            } else {
                this.writeToOutput("null");
            }

            this.writeToOutput('] = ');
            this.writeToOutput(quoted ? name : '"' + name + '"');
            this.recordSourceMappingEnd(varDecl);
            this.emitComments(varDecl, false);
            this.writeToOutput(';');
        };

        Emitter.prototype.emitIndex = function (operand1, operand2) {
            operand1.emit(this);
            this.writeToOutput("[");
            operand2.emit(this);
            this.writeToOutput("]");
        };

        Emitter.prototype.emitFunction = function (funcDecl) {
            if (TypeScript.hasFlag(funcDecl.getFunctionFlags(), 128 /* Signature */)) {
                return;
            }
            var temp;
            var tempFnc = this.thisFunctionDeclaration;
            this.thisFunctionDeclaration = funcDecl;

            if (funcDecl.isConstructor) {
                temp = this.setContainer(4 /* Constructor */);
            } else {
                temp = this.setContainer(5 /* Function */);
            }

            var funcName = funcDecl.getNameText();

            if (((temp !== 4 /* Constructor */) || ((funcDecl.getFunctionFlags() & 256 /* Method */) === 0 /* None */))) {
                this.recordSourceMappingStart(funcDecl);
                this.emitInnerFunction(funcDecl, (funcDecl.name && !funcDecl.name.isMissing()));
            }
            this.setContainer(temp);
            this.thisFunctionDeclaration = tempFnc;

            if (!TypeScript.hasFlag(funcDecl.getFunctionFlags(), 128 /* Signature */)) {
                var pullFunctionDecl = this.semanticInfoChain.getDeclForAST(funcDecl, this.document.fileName);
                if (TypeScript.hasFlag(funcDecl.getFunctionFlags(), 16 /* Static */)) {
                    if (this.thisClassNode) {
                        this.writeLineToOutput("");
                        if (funcDecl.isAccessor()) {
                            this.emitPropertyAccessor(funcDecl, this.thisClassNode.name.actualText, false);
                        } else {
                            this.emitIndent();
                            this.recordSourceMappingStart(funcDecl);
                            this.writeToOutput(this.thisClassNode.name.actualText + "." + funcName + " = " + funcName + ";");
                            this.recordSourceMappingEnd(funcDecl);
                        }
                    }
                } else if ((this.emitState.container === 1 /* Module */ || this.emitState.container === 2 /* DynamicModule */) && TypeScript.hasFlag(pullFunctionDecl.flags, 1 /* Exported */)) {
                    this.writeLineToOutput("");
                    this.emitIndent();
                    var modName = this.emitState.container === 1 /* Module */ ? this.moduleName : "exports";
                    this.recordSourceMappingStart(funcDecl);
                    this.writeToOutput(modName + "." + funcName + " = " + funcName + ";");
                    this.recordSourceMappingEnd(funcDecl);
                }
            }
        };

        Emitter.prototype.emitAmbientVarDecl = function (varDecl) {
            if (varDecl.init) {
                this.emitComments(varDecl, true);
                this.recordSourceMappingStart(varDecl);
                this.recordSourceMappingStart(varDecl.id);
                this.writeToOutput(varDecl.id.actualText);
                this.recordSourceMappingEnd(varDecl.id);
                this.writeToOutput(" = ");
                this.emitJavascript(varDecl.init, false);
                this.recordSourceMappingEnd(varDecl);
                this.emitComments(varDecl, false);
            }
        };

        Emitter.prototype.varListCount = function () {
            return this.varListCountStack[this.varListCountStack.length - 1];
        };

        Emitter.prototype.emitVarDeclVar = function () {
            if (this.varListCount() >= 0) {
                this.writeToOutput("var ");
                this.setInVarBlock(-this.varListCount());
            }
            return true;
        };

        Emitter.prototype.onEmitVar = function () {
            if (this.varListCount() > 0) {
                this.setInVarBlock(this.varListCount() - 1);
            } else if (this.varListCount() < 0) {
                this.setInVarBlock(this.varListCount() + 1);
            }
        };

        Emitter.prototype.emitVariableDeclaration = function (declaration) {
            var varDecl = declaration.declarators.members[0];

            var symbol = this.semanticInfoChain.getSymbolForAST(varDecl, this.document.fileName);

            var parentSymbol = symbol ? symbol.getContainer() : null;
            var parentKind = parentSymbol ? parentSymbol.kind : 0 /* None */;
            var inClass = parentKind === 8 /* Class */;

            this.emitComments(declaration, true);
            this.recordSourceMappingStart(declaration);
            this.setInVarBlock(declaration.declarators.members.length);

            var pullVarDecl = this.semanticInfoChain.getDeclForAST(varDecl, this.document.fileName);
            var isAmbientWithoutInit = pullVarDecl && TypeScript.hasFlag(pullVarDecl.flags, 8 /* Ambient */) && varDecl.init === null;
            if (!isAmbientWithoutInit) {
                for (var i = 0, n = declaration.declarators.members.length; i < n; i++) {
                    var declarator = declaration.declarators.members[i];

                    if (i > 0) {
                        if (inClass) {
                            this.writeToOutputTrimmable(";");
                        } else {
                            this.writeToOutputTrimmable(", ");
                        }
                    }

                    declarator.emit(this);
                }
            }

            this.recordSourceMappingEnd(declaration);
            this.emitComments(declaration, false);
        };

        Emitter.prototype.emitVariableDeclarator = function (varDecl) {
            var pullDecl = this.semanticInfoChain.getDeclForAST(varDecl, this.document.fileName);
            this.pushDecl(pullDecl);
            if ((pullDecl.flags & 8 /* Ambient */) === 8 /* Ambient */) {
                this.emitAmbientVarDecl(varDecl);
                this.onEmitVar();
            } else {
                this.emitComments(varDecl, true);
                this.recordSourceMappingStart(varDecl);

                var symbol = this.semanticInfoChain.getSymbolForAST(varDecl, this.document.fileName);
                var parentSymbol = symbol ? symbol.getContainer() : null;
                var parentKind = parentSymbol ? parentSymbol.kind : 0 /* None */;
                var associatedParentSymbol = parentSymbol ? parentSymbol.getAssociatedContainerType() : null;
                var associatedParentSymbolKind = associatedParentSymbol ? associatedParentSymbol.kind : 0 /* None */;
                if (parentKind === 8 /* Class */) {
                    if (this.emitState.container !== 6 /* Args */) {
                        if (varDecl.isStatic()) {
                            this.writeToOutput(parentSymbol.getName() + ".");
                        } else {
                            this.writeToOutput("this.");
                        }
                    }
                } else if (TypeScript.PullHelpers.symbolIsModule(parentSymbol) || TypeScript.PullHelpers.symbolIsEnum(parentSymbol) || TypeScript.PullHelpers.symbolIsModule(associatedParentSymbol) || TypeScript.PullHelpers.symbolIsEnum(associatedParentSymbol) || parentKind === 32 /* DynamicModule */ || associatedParentSymbolKind === 32 /* DynamicModule */) {
                    if (!TypeScript.hasFlag(pullDecl.flags, 1 /* Exported */) && !varDecl.isProperty()) {
                        this.emitVarDeclVar();
                    } else {
                        if (this.emitState.container === 2 /* DynamicModule */) {
                            this.writeToOutput("exports.");
                        } else {
                            this.writeToOutput(this.moduleName + ".");
                        }
                    }
                } else {
                    this.emitVarDeclVar();
                }

                this.recordSourceMappingStart(varDecl.id);
                this.writeToOutput(varDecl.id.actualText);
                this.recordSourceMappingEnd(varDecl.id);
                var hasInitializer = (varDecl.init !== null);
                if (hasInitializer) {
                    this.writeToOutputTrimmable(" = ");

                    this.varListCountStack.push(0);
                    varDecl.init.emit(this);
                    this.varListCountStack.pop();
                }

                if (parentKind === 8 /* Class */) {
                    if (this.emitState.container !== 6 /* Args */) {
                        this.writeToOutput(";");
                    }
                }

                this.onEmitVar();

                this.recordSourceMappingEnd(varDecl);
                this.emitComments(varDecl, false);
            }
            this.popDecl(pullDecl);
        };

        Emitter.prototype.symbolIsUsedInItsEnclosingContainer = function (symbol, dynamic) {
            if (typeof dynamic === "undefined") { dynamic = false; }
            var symDecls = symbol.getDeclarations();

            if (symDecls.length) {
                var enclosingDecl = this.getEnclosingDecl();
                if (enclosingDecl) {
                    var parentDecl = symDecls[0].getParentDecl();
                    if (parentDecl) {
                        var symbolDeclarationEnclosingContainer = parentDecl;
                        var enclosingContainer = enclosingDecl;

                        while (symbolDeclarationEnclosingContainer) {
                            if (symbolDeclarationEnclosingContainer.kind === (dynamic ? 32 /* DynamicModule */ : 4 /* Container */)) {
                                break;
                            }
                            symbolDeclarationEnclosingContainer = symbolDeclarationEnclosingContainer.getParentDecl();
                        }

                        if (symbolDeclarationEnclosingContainer) {
                            while (enclosingContainer) {
                                if (enclosingContainer.kind === (dynamic ? 32 /* DynamicModule */ : 4 /* Container */)) {
                                    break;
                                }

                                enclosingContainer = enclosingContainer.getParentDecl();
                            }
                        }

                        if (symbolDeclarationEnclosingContainer && enclosingContainer) {
                            var same = symbolDeclarationEnclosingContainer === enclosingContainer;

                            if (!same && symbol.hasFlag(32768 /* InitializedModule */)) {
                                same = symbolDeclarationEnclosingContainer === enclosingContainer.getParentDecl();
                            }

                            return same;
                        }
                    }
                }
            }

            return false;
        };

        Emitter.prototype.emitName = function (name, addThis) {
            this.emitComments(name, true);
            this.recordSourceMappingStart(name);
            if (!name.isMissing()) {
                var pullSymbol = this.semanticInfoChain.getSymbolForAST(name, this.document.fileName);
                if (!pullSymbol) {
                    pullSymbol = this.semanticInfoChain.anyTypeSymbol;
                }
                var pullSymbolAlias = this.semanticInfoChain.getAliasSymbolForAST(name, this.document.fileName);
                if (pullSymbol && pullSymbolAlias) {
                    var symbolToCompare = this.resolvingContext.resolvingTypeReference ? pullSymbolAlias.getExportAssignedTypeSymbol() : pullSymbolAlias.getExportAssignedValueSymbol();

                    if (pullSymbol == symbolToCompare) {
                        pullSymbol = pullSymbolAlias;
                        pullSymbolAlias = null;
                    }
                }

                var pullSymbolKind = pullSymbol.kind;
                var isLocalAlias = pullSymbolAlias && (pullSymbolAlias.getDeclarations()[0].getParentDecl() == this.getEnclosingDecl());
                if (addThis && (this.emitState.container !== 6 /* Args */) && pullSymbol) {
                    var pullSymbolContainer = pullSymbol.getContainer();

                    if (pullSymbolContainer) {
                        var pullSymbolContainerKind = pullSymbolContainer.kind;

                        if (pullSymbolContainerKind === 8 /* Class */) {
                            if (pullSymbol.hasFlag(16 /* Static */)) {
                                this.writeToOutput(pullSymbolContainer.getName() + ".");
                            } else if (pullSymbolKind === 4096 /* Property */) {
                                this.emitThis();
                                this.writeToOutput(".");
                            }
                        } else if (TypeScript.PullHelpers.symbolIsModule(pullSymbolContainer) || pullSymbolContainerKind === 64 /* Enum */ || pullSymbolContainer.hasFlag(32768 /* InitializedModule */ | 131072 /* InitializedEnum */)) {
                            if (pullSymbolKind === 4096 /* Property */ || pullSymbolKind === 67108864 /* EnumMember */) {
                                this.writeToOutput(pullSymbolContainer.getDisplayName() + ".");
                            } else if (pullSymbol.hasFlag(1 /* Exported */) && pullSymbolKind === 1024 /* Variable */ && !pullSymbol.hasFlag(32768 /* InitializedModule */ | 131072 /* InitializedEnum */)) {
                                this.writeToOutput(pullSymbolContainer.getDisplayName() + ".");
                            } else if (pullSymbol.hasFlag(1 /* Exported */) && !this.symbolIsUsedInItsEnclosingContainer(pullSymbol)) {
                                this.writeToOutput(pullSymbolContainer.getDisplayName() + ".");
                            }
                        } else if (pullSymbolContainerKind === 32 /* DynamicModule */ || pullSymbolContainer.hasFlag(65536 /* InitializedDynamicModule */)) {
                            if (pullSymbolKind === 4096 /* Property */) {
                                this.writeToOutput("exports.");
                            } else if (pullSymbol.hasFlag(1 /* Exported */) && !isLocalAlias && !pullSymbol.hasFlag(TypeScript.PullElementFlags.ImplicitVariable) && pullSymbol.kind !== 32768 /* ConstructorMethod */ && pullSymbol.kind !== 8 /* Class */ && pullSymbol.kind !== 64 /* Enum */) {
                                this.writeToOutput("exports.");
                            }
                        } else if (pullSymbolKind === 4096 /* Property */) {
                            if (pullSymbolContainer.kind === 8 /* Class */) {
                                this.emitThis();
                                this.writeToOutput(".");
                            }
                        } else {
                            var pullDecls = pullSymbol.getDeclarations();
                            var emitContainerName = true;
                            for (var i = 0; i < pullDecls.length; i++) {
                                if (pullDecls[i].getScriptName() === this.document.fileName) {
                                    emitContainerName = false;
                                }
                            }
                            if (emitContainerName) {
                                this.writeToOutput(pullSymbolContainer.getName() + ".");
                            }
                        }
                    }
                }

                if (pullSymbol && pullSymbolKind === 32 /* DynamicModule */) {
                    if (this.emitOptions.compilationSettings.moduleGenTarget === 2 /* Asynchronous */) {
                        this.writeToOutput("__" + this.modAliasId + "__");
                    } else {
                        var moduleDecl = this.semanticInfoChain.getASTForSymbol(pullSymbol, this.document.fileName);
                        var modPath = name.actualText;
                        var isAmbient = pullSymbol.hasFlag(8 /* Ambient */);
                        modPath = isAmbient ? modPath : this.firstModAlias ? this.firstModAlias : TypeScript.quoteBaseName(modPath);
                        modPath = isAmbient ? modPath : (!TypeScript.isRelative(TypeScript.stripQuotes(modPath)) ? TypeScript.quoteStr("./" + TypeScript.stripQuotes(modPath)) : modPath);
                        this.writeToOutput("require(" + modPath + ")");
                    }
                } else {
                    this.writeToOutput(name.actualText);
                }
            }

            this.recordSourceMappingEnd(name);
            this.emitComments(name, false);
        };

        Emitter.prototype.recordSourceMappingNameStart = function (name) {
            if (this.sourceMapper) {
                var finalName = name;
                if (!name) {
                    finalName = "";
                } else if (this.sourceMapper.currentNameIndex.length > 0) {
                    finalName = this.sourceMapper.names[this.sourceMapper.currentNameIndex[this.sourceMapper.currentNameIndex.length - 1]] + "." + name;
                }

                this.sourceMapper.names.push(finalName);
                this.sourceMapper.currentNameIndex.push(this.sourceMapper.names.length - 1);
            }
        };

        Emitter.prototype.recordSourceMappingNameEnd = function () {
            if (this.sourceMapper) {
                this.sourceMapper.currentNameIndex.pop();
            }
        };

        Emitter.prototype.recordSourceMappingStart = function (ast) {
            if (this.sourceMapper && TypeScript.isValidAstNode(ast)) {
                var lineCol = { line: -1, character: -1 };
                var sourceMapping = new TypeScript.SourceMapping();
                sourceMapping.start.emittedColumn = this.emitState.column;
                sourceMapping.start.emittedLine = this.emitState.line;

                var lineMap = this.document.lineMap;
                lineMap.fillLineAndCharacterFromPosition(ast.minChar, lineCol);
                sourceMapping.start.sourceColumn = lineCol.character;
                sourceMapping.start.sourceLine = lineCol.line + 1;
                lineMap.fillLineAndCharacterFromPosition(ast.limChar, lineCol);
                sourceMapping.end.sourceColumn = lineCol.character;
                sourceMapping.end.sourceLine = lineCol.line + 1;
                if (this.sourceMapper.currentNameIndex.length > 0) {
                    sourceMapping.nameIndex = this.sourceMapper.currentNameIndex[this.sourceMapper.currentNameIndex.length - 1];
                }

                var siblings = this.sourceMapper.currentMappings[this.sourceMapper.currentMappings.length - 1];
                siblings.push(sourceMapping);
                this.sourceMapper.currentMappings.push(sourceMapping.childMappings);
            }
        };

        Emitter.prototype.recordSourceMappingEnd = function (ast) {
            if (this.sourceMapper && TypeScript.isValidAstNode(ast)) {
                this.sourceMapper.currentMappings.pop();

                var siblings = this.sourceMapper.currentMappings[this.sourceMapper.currentMappings.length - 1];
                var sourceMapping = siblings[siblings.length - 1];

                sourceMapping.end.emittedColumn = this.emitState.column;
                sourceMapping.end.emittedLine = this.emitState.line;
            }
        };

        Emitter.prototype.emitSourceMapsAndClose = function () {
            if (this.sourceMapper !== null) {
                TypeScript.SourceMapper.emitSourceMapping(this.allSourceMappers);
            }

            try  {
                this.outfile.Close();
            } catch (e) {
                Emitter.throwEmitterError(e);
            }
        };

        Emitter.prototype.emitParameterPropertyAndMemberVariableAssignments = function () {
            var constructorDecl = this.thisClassNode.constructorDecl;

            if (constructorDecl && constructorDecl.arguments) {
                for (var i = 0, n = constructorDecl.arguments.members.length; i < n; i++) {
                    var arg = constructorDecl.arguments.members[i];
                    if ((arg.getVarFlags() & 256 /* Property */) !== 0 /* None */) {
                        this.emitIndent();
                        this.recordSourceMappingStart(arg);
                        this.recordSourceMappingStart(arg.id);
                        this.writeToOutput("this." + arg.id.actualText);
                        this.recordSourceMappingEnd(arg.id);
                        this.writeToOutput(" = ");
                        this.recordSourceMappingStart(arg.id);
                        this.writeToOutput(arg.id.actualText);
                        this.recordSourceMappingEnd(arg.id);
                        this.writeLineToOutput(";");
                        this.recordSourceMappingEnd(arg);
                    }
                }
            }

            for (var i = 0, n = this.thisClassNode.members.members.length; i < n; i++) {
                if (this.thisClassNode.members.members[i].nodeType() === 18 /* VariableDeclarator */) {
                    var varDecl = this.thisClassNode.members.members[i];
                    if (!TypeScript.hasFlag(varDecl.getVarFlags(), 16 /* Static */) && varDecl.init) {
                        this.emitIndent();
                        this.emitVariableDeclarator(varDecl);
                        this.writeLineToOutput("");
                    }
                }
            }
        };

        Emitter.prototype.emitCommaSeparatedList = function (list, startLine) {
            if (typeof startLine === "undefined") { startLine = false; }
            if (list === null) {
                return;
            } else {
                for (var i = 0, n = list.members.length; i < n; i++) {
                    var emitNode = list.members[i];
                    this.emitJavascript(emitNode, startLine);

                    if (i < (n - 1)) {
                        this.writeToOutput(startLine ? "," : ", ");
                    }

                    if (startLine) {
                        this.writeLineToOutput("");
                    }
                }
            }
        };

        Emitter.prototype.emitModuleElements = function (list) {
            if (list === null) {
                return;
            }

            this.emitComments(list, true);
            var lastEmittedNode = null;

            for (var i = 0, n = list.members.length; i < n; i++) {
                var node = list.members[i];

                if (node.shouldEmit()) {
                    this.emitSpaceBetweenConstructs(lastEmittedNode, node);

                    this.emitJavascript(node, true);
                    this.writeLineToOutput("");

                    lastEmittedNode = node;
                }
            }

            this.emitComments(list, false);
        };

        Emitter.prototype.isDirectivePrologueElement = function (node) {
            if (node.nodeType() === 89 /* ExpressionStatement */) {
                var exprStatement = node;
                return exprStatement.expression.nodeType() === 5 /* StringLiteral */;
            }

            return false;
        };

        Emitter.prototype.emitSpaceBetweenConstructs = function (node1, node2) {
            if (node1 === null || node2 === null) {
                return;
            }

            if (node1.minChar === -1 || node1.limChar === -1 || node2.minChar === -1 || node2.limChar === -1) {
                return;
            }

            var lineMap = this.document.lineMap;
            var node1EndLine = lineMap.getLineNumberFromPosition(node1.limChar);
            var node2StartLine = lineMap.getLineNumberFromPosition(node2.minChar);

            if ((node2StartLine - node1EndLine) > 1) {
                this.writeLineToOutput("");
            }
        };

        Emitter.prototype.getCopyrightComments = function () {
            var preComments = this.copyrightElement.preComments();
            if (preComments) {
                var lineMap = this.document.lineMap;

                var copyrightComments = [];
                var lastComment = null;

                for (var i = 0, n = preComments.length; i < n; i++) {
                    var comment = preComments[i];

                    if (lastComment) {
                        var lastCommentLine = lineMap.getLineNumberFromPosition(lastComment.limChar);
                        var commentLine = lineMap.getLineNumberFromPosition(comment.minChar);

                        if (commentLine >= lastCommentLine + 2) {
                            return copyrightComments;
                        }
                    }

                    copyrightComments.push(comment);
                    lastComment = comment;
                }

                var lastCommentLine = lineMap.getLineNumberFromPosition(TypeScript.ArrayUtilities.last(copyrightComments).limChar);
                var astLine = lineMap.getLineNumberFromPosition(this.copyrightElement.minChar);
                if (astLine >= lastCommentLine + 2) {
                    return copyrightComments;
                }
            }

            return [];
        };

        Emitter.prototype.emitPossibleCopyrightHeaders = function (script) {
            var list = script.moduleElements;
            if (list.members.length > 0) {
                var firstElement = list.members[0];
                if (firstElement.nodeType() === 16 /* ModuleDeclaration */) {
                    var moduleDeclaration = firstElement;
                    if (moduleDeclaration.isWholeFile()) {
                        firstElement = moduleDeclaration.members.members[0];
                    }
                }

                this.copyrightElement = firstElement;
                this.emitCommentsArray(this.getCopyrightComments());
            }
        };

        Emitter.prototype.emitScriptElements = function (script) {
            var list = script.moduleElements;

            this.emitPossibleCopyrightHeaders(script);

            for (var i = 0, n = list.members.length; i < n; i++) {
                var node = list.members[i];

                if (!this.isDirectivePrologueElement(node)) {
                    break;
                }

                this.emitJavascript(node, true);
                this.writeLineToOutput("");
            }

            this.emitPrologue(script);
            var lastEmittedNode = null;

            for (; i < n; i++) {
                var node = list.members[i];

                if (node.shouldEmit()) {
                    this.emitSpaceBetweenConstructs(lastEmittedNode, node);

                    this.emitJavascript(node, true);
                    this.writeLineToOutput("");

                    lastEmittedNode = node;
                }
            }
        };

        Emitter.prototype.emitConstructorStatements = function (funcDecl) {
            var list = funcDecl.block.statements;

            if (list === null) {
                return;
            }

            this.emitComments(list, true);

            var emitPropertyAssignmentsAfterSuperCall = this.thisClassNode.extendsList && this.thisClassNode.extendsList.members.length > 0;
            var propertyAssignmentIndex = emitPropertyAssignmentsAfterSuperCall ? 1 : 0;
            var lastEmittedNode = null;

            for (var i = 0, n = list.members.length; i < n; i++) {
                if (i === propertyAssignmentIndex) {
                    this.emitParameterPropertyAndMemberVariableAssignments();
                }

                var node = list.members[i];

                if (node.shouldEmit()) {
                    this.emitSpaceBetweenConstructs(lastEmittedNode, node);

                    this.emitJavascript(node, true);
                    this.writeLineToOutput("");

                    lastEmittedNode = node;
                }
            }

            if (i === propertyAssignmentIndex) {
                this.emitParameterPropertyAndMemberVariableAssignments();
            }

            this.emitComments(list, false);
        };

        Emitter.prototype.emitJavascript = function (ast, startLine) {
            if (ast === null) {
                return;
            }

            if (startLine && this.indenter.indentAmt > 0) {
                this.emitIndent();
            }

            ast.emit(this);
        };

        Emitter.prototype.emitPropertyAccessor = function (funcDecl, className, isProto) {
            if (!TypeScript.hasFlag(funcDecl.getFunctionFlags(), 32 /* GetAccessor */)) {
                var accessorSymbol = TypeScript.PullHelpers.getAccessorSymbol(funcDecl, this.semanticInfoChain, this.document.fileName);
                if (accessorSymbol.getGetter()) {
                    return;
                }
            }

            this.emitIndent();
            this.recordSourceMappingStart(funcDecl);
            this.writeLineToOutput("Object.defineProperty(" + className + (isProto ? ".prototype, \"" : ", \"") + funcDecl.name.actualText + "\"" + ", {");
            this.indenter.increaseIndent();

            var accessors = TypeScript.PullHelpers.getGetterAndSetterFunction(funcDecl, this.semanticInfoChain, this.document.fileName);
            if (accessors.getter) {
                this.emitIndent();
                this.recordSourceMappingStart(accessors.getter);
                this.writeToOutput("get: ");
                this.emitInnerFunction(accessors.getter, false);
                this.writeLineToOutput(",");
            }

            if (accessors.setter) {
                this.emitIndent();
                this.recordSourceMappingStart(accessors.setter);
                this.writeToOutput("set: ");
                this.emitInnerFunction(accessors.setter, false);
                this.writeLineToOutput(",");
            }

            this.emitIndent();
            this.writeLineToOutput("enumerable: true,");
            this.emitIndent();
            this.writeLineToOutput("configurable: true");
            this.indenter.decreaseIndent();
            this.emitIndent();
            this.writeLineToOutput("});");
            this.recordSourceMappingEnd(funcDecl);
        };

        Emitter.prototype.emitPrototypeMember = function (funcDecl, className) {
            if (funcDecl.isAccessor()) {
                this.emitPropertyAccessor(funcDecl, className, true);
            } else {
                this.emitIndent();
                this.recordSourceMappingStart(funcDecl);
                this.emitComments(funcDecl, true);
                this.writeToOutput(className + ".prototype." + funcDecl.getNameText() + " = ");
                this.emitInnerFunction(funcDecl, false, false);
                this.writeLineToOutput(";");
            }
        };

        Emitter.prototype.emitClass = function (classDecl) {
            var pullDecl = this.semanticInfoChain.getDeclForAST(classDecl, this.document.fileName);
            this.pushDecl(pullDecl);

            var svClassNode = this.thisClassNode;
            this.thisClassNode = classDecl;
            var className = classDecl.name.actualText;
            this.emitComments(classDecl, true);
            var temp = this.setContainer(3 /* Class */);

            this.recordSourceMappingStart(classDecl);
            this.writeToOutput("var " + className);

            var hasBaseClass = classDecl.extendsList && classDecl.extendsList.members.length;
            var baseNameDecl = null;
            var baseName = null;
            var varDecl = null;

            if (hasBaseClass) {
                this.writeLineToOutput(" = (function (_super) {");
            } else {
                this.writeLineToOutput(" = (function () {");
            }

            this.recordSourceMappingNameStart(className);
            this.indenter.increaseIndent();

            if (hasBaseClass) {
                baseNameDecl = classDecl.extendsList.members[0];
                baseName = baseNameDecl.nodeType() === 37 /* InvocationExpression */ ? (baseNameDecl).target : baseNameDecl;
                this.emitIndent();
                this.writeLineToOutput("__extends(" + className + ", _super);");
            }

            this.emitIndent();

            var constrDecl = classDecl.constructorDecl;

            if (constrDecl) {
                constrDecl.emit(this);
                this.writeLineToOutput("");
            } else {
                this.recordSourceMappingStart(classDecl);

                this.indenter.increaseIndent();
                this.writeLineToOutput("function " + classDecl.name.actualText + "() {");
                this.recordSourceMappingNameStart("constructor");
                if (hasBaseClass) {
                    this.emitIndent();
                    this.writeLineToOutput("_super.apply(this, arguments);");
                }

                if (this.shouldCaptureThis(classDecl)) {
                    this.writeCaptureThisStatement(classDecl);
                }

                this.emitParameterPropertyAndMemberVariableAssignments();

                this.indenter.decreaseIndent();
                this.emitIndent();
                this.writeLineToOutput("}");

                this.recordSourceMappingNameEnd();
                this.recordSourceMappingEnd(classDecl);
            }

            this.emitClassMembers(classDecl);

            this.emitIndent();
            this.recordSourceMappingStart(classDecl.endingToken);
            this.writeLineToOutput("return " + className + ";");
            this.recordSourceMappingEnd(classDecl.endingToken);
            this.indenter.decreaseIndent();
            this.emitIndent();
            this.recordSourceMappingStart(classDecl.endingToken);
            this.writeToOutput("}");
            this.recordSourceMappingNameEnd();
            this.recordSourceMappingEnd(classDecl.endingToken);
            this.recordSourceMappingStart(classDecl);
            this.writeToOutput(")(");
            if (hasBaseClass) {
                this.resolvingContext.resolvingTypeReference = true;
                this.emitJavascript(baseName, false);
                this.resolvingContext.resolvingTypeReference = false;
            }
            this.writeToOutput(");");
            this.recordSourceMappingEnd(classDecl);

            if ((temp === 1 /* Module */ || temp === 2 /* DynamicModule */) && TypeScript.hasFlag(pullDecl.flags, 1 /* Exported */)) {
                this.writeLineToOutput("");
                this.emitIndent();
                var modName = temp === 1 /* Module */ ? this.moduleName : "exports";
                this.recordSourceMappingStart(classDecl);
                this.writeToOutput(modName + "." + className + " = " + className + ";");
                this.recordSourceMappingEnd(classDecl);
            }

            this.recordSourceMappingEnd(classDecl);
            this.emitComments(classDecl, false);
            this.setContainer(temp);
            this.thisClassNode = svClassNode;

            this.popDecl(pullDecl);
        };

        Emitter.prototype.emitClassMembers = function (classDecl) {
            var lastEmittedMember = null;

            for (var i = 0, n = classDecl.members.members.length; i < n; i++) {
                var memberDecl = classDecl.members.members[i];

                if (memberDecl.nodeType() === 13 /* FunctionDeclaration */) {
                    var fn = memberDecl;

                    if (TypeScript.hasFlag(fn.getFunctionFlags(), 256 /* Method */) && !fn.isSignature()) {
                        this.emitSpaceBetweenConstructs(lastEmittedMember, fn);

                        if (!TypeScript.hasFlag(fn.getFunctionFlags(), 16 /* Static */)) {
                            this.emitPrototypeMember(fn, classDecl.name.actualText);
                        } else {
                            if (fn.isAccessor()) {
                                this.emitPropertyAccessor(fn, this.thisClassNode.name.actualText, false);
                            } else {
                                this.emitIndent();
                                this.recordSourceMappingStart(fn);
                                this.writeToOutput(classDecl.name.actualText + "." + fn.name.actualText + " = ");
                                this.emitInnerFunction(fn, false);
                                this.writeLineToOutput(";");
                            }
                        }

                        lastEmittedMember = fn;
                    }
                }
            }

            for (var i = 0, n = classDecl.members.members.length; i < n; i++) {
                var memberDecl = classDecl.members.members[i];

                if (memberDecl.nodeType() === 18 /* VariableDeclarator */) {
                    var varDecl = memberDecl;

                    if (TypeScript.hasFlag(varDecl.getVarFlags(), 16 /* Static */) && varDecl.init) {
                        this.emitSpaceBetweenConstructs(lastEmittedMember, varDecl);

                        this.emitIndent();
                        this.recordSourceMappingStart(varDecl);
                        this.writeToOutput(classDecl.name.actualText + "." + varDecl.id.actualText + " = ");
                        varDecl.init.emit(this);

                        this.writeLineToOutput(";");
                        this.recordSourceMappingEnd(varDecl);

                        lastEmittedMember = varDecl;
                    }
                }
            }
        };

        Emitter.prototype.requiresExtendsBlock = function (moduleElements) {
            for (var i = 0, n = moduleElements.members.length; i < n; i++) {
                var moduleElement = moduleElements.members[i];

                if (moduleElement.nodeType() === 16 /* ModuleDeclaration */) {
                    if (this.requiresExtendsBlock((moduleElement).members)) {
                        return true;
                    }
                } else if (moduleElement.nodeType() === 14 /* ClassDeclaration */) {
                    var classDeclaration = moduleElement;

                    if (classDeclaration.extendsList && classDeclaration.extendsList.members.length > 0) {
                        return true;
                    }
                }
            }

            return false;
        };

        Emitter.prototype.emitPrologue = function (script) {
            if (!this.extendsPrologueEmitted) {
                if (this.requiresExtendsBlock(script.moduleElements)) {
                    this.extendsPrologueEmitted = true;
                    this.writeLineToOutput("var __extends = this.__extends || function (d, b) {");
                    this.writeLineToOutput("    for (var p in b) if (b.hasOwnProperty(p)) d[p] = b[p];");
                    this.writeLineToOutput("    function __() { this.constructor = d; }");
                    this.writeLineToOutput("    __.prototype = b.prototype;");
                    this.writeLineToOutput("    d.prototype = new __();");
                    this.writeLineToOutput("};");
                }
            }

            if (!this.globalThisCapturePrologueEmitted) {
                if (this.shouldCaptureThis(script)) {
                    this.globalThisCapturePrologueEmitted = true;
                    this.writeLineToOutput(this.captureThisStmtString);
                }
            }
        };

        Emitter.prototype.emitSuperReference = function () {
            this.writeToOutput("_super.prototype");
        };

        Emitter.prototype.emitSuperCall = function (callEx) {
            if (callEx.target.nodeType() === 33 /* MemberAccessExpression */) {
                var dotNode = callEx.target;
                if (dotNode.operand1.nodeType() === 31 /* SuperExpression */) {
                    dotNode.emit(this);
                    this.writeToOutput(".call(");
                    this.emitThis();
                    if (callEx.arguments && callEx.arguments.members.length > 0) {
                        this.writeToOutput(", ");
                        this.emitCommaSeparatedList(callEx.arguments);
                    }
                    this.writeToOutput(")");
                    return true;
                }
            }
            return false;
        };

        Emitter.prototype.emitThis = function () {
            if (this.thisFunctionDeclaration && !this.thisFunctionDeclaration.isMethod() && (!this.thisFunctionDeclaration.isConstructor)) {
                this.writeToOutput("_this");
            } else {
                this.writeToOutput("this");
            }
        };

        Emitter.prototype.emitBlockOrStatement = function (node) {
            if (node.nodeType() === 82 /* Block */) {
                node.emit(this);
            } else {
                this.writeLineToOutput("");
                this.indenter.increaseIndent();
                this.emitJavascript(node, true);
                this.indenter.decreaseIndent();
            }
        };

        Emitter.throwEmitterError = function (e) {
            var error = new Error(e.message);
            error.isEmitterError = true;
            throw error;
        };

        Emitter.handleEmitterError = function (fileName, e) {
            if ((e).isEmitterError === true) {
                return [new TypeScript.Diagnostic(fileName, 0, 0, TypeScript.DiagnosticCode.Emit_Error_0, [e.message])];
            }

            throw e;
        };
        return Emitter;
    })();
    TypeScript.Emitter = Emitter;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var MemberName = (function () {
        function MemberName() {
            this.prefix = "";
            this.suffix = "";
        }
        MemberName.prototype.isString = function () {
            return false;
        };
        MemberName.prototype.isArray = function () {
            return false;
        };
        MemberName.prototype.isMarker = function () {
            return !this.isString() && !this.isArray();
        };

        MemberName.prototype.toString = function () {
            return MemberName.memberNameToString(this);
        };

        MemberName.memberNameToString = function (memberName, markerInfo, markerBaseLength) {
            if (typeof markerBaseLength === "undefined") { markerBaseLength = 0; }
            var result = memberName.prefix;

            if (memberName.isString()) {
                result += (memberName).text;
            } else if (memberName.isArray()) {
                var ar = memberName;
                for (var index = 0; index < ar.entries.length; index++) {
                    if (ar.entries[index].isMarker()) {
                        if (markerInfo) {
                            markerInfo.push(markerBaseLength + result.length);
                        }
                        continue;
                    }

                    result += MemberName.memberNameToString(ar.entries[index], markerInfo, markerBaseLength + result.length);
                    result += ar.delim;
                }
            }

            result += memberName.suffix;
            return result;
        };

        MemberName.create = function (arg1, arg2, arg3) {
            if (typeof arg1 === "string") {
                return new MemberNameString(arg1);
            } else {
                var result = new MemberNameArray();
                if (arg2)
                    result.prefix = arg2;
                if (arg3)
                    result.suffix = arg3;
                result.entries.push(arg1);
                return result;
            }
        };
        return MemberName;
    })();
    TypeScript.MemberName = MemberName;

    var MemberNameString = (function (_super) {
        __extends(MemberNameString, _super);
        function MemberNameString(text) {
            _super.call(this);
            this.text = text;
        }
        MemberNameString.prototype.isString = function () {
            return true;
        };
        return MemberNameString;
    })(MemberName);
    TypeScript.MemberNameString = MemberNameString;

    var MemberNameArray = (function (_super) {
        __extends(MemberNameArray, _super);
        function MemberNameArray() {
            _super.call(this);
            this.delim = "";
            this.entries = [];
        }
        MemberNameArray.prototype.isArray = function () {
            return true;
        };

        MemberNameArray.prototype.add = function (entry) {
            this.entries.push(entry);
        };

        MemberNameArray.prototype.addAll = function (entries) {
            for (var i = 0; i < entries.length; i++) {
                this.entries.push(entries[i]);
            }
        };
        return MemberNameArray;
    })(MemberName);
    TypeScript.MemberNameArray = MemberNameArray;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var quoteRegEx = /["']/g;
    function stripQuotes(str) {
        return str.replace(quoteRegEx, "");
    }
    TypeScript.stripQuotes = stripQuotes;

    function isSingleQuoted(str) {
        return str.indexOf("'") !== -1;
    }
    TypeScript.isSingleQuoted = isSingleQuoted;

    function isQuoted(str) {
        return str.indexOf("\"") !== -1 || isSingleQuoted(str);
    }
    TypeScript.isQuoted = isQuoted;

    function quoteStr(str) {
        return "\"" + str + "\"";
    }
    TypeScript.quoteStr = quoteStr;

    function swapQuotes(str) {
        if (str.indexOf("\"") !== -1) {
            str = str.replace("\"", "'");
            str = str.replace("\"", "'");
        } else {
            str = str.replace("'", "\"");
            str = str.replace("'", "\"");
        }

        return str;
    }
    TypeScript.swapQuotes = swapQuotes;

    var switchToForwardSlashesRegEx = /\\/g;
    function switchToForwardSlashes(path) {
        return path.replace(switchToForwardSlashesRegEx, "/");
    }
    TypeScript.switchToForwardSlashes = switchToForwardSlashes;

    function trimModName(modName) {
        if (modName.length > 5 && modName.substring(modName.length - 5, modName.length) === ".d.ts") {
            return modName.substring(0, modName.length - 5);
        }
        if (modName.length > 3 && modName.substring(modName.length - 3, modName.length) === ".ts") {
            return modName.substring(0, modName.length - 3);
        }

        if (modName.length > 3 && modName.substring(modName.length - 3, modName.length) === ".js") {
            return modName.substring(0, modName.length - 3);
        }

        return modName;
    }
    TypeScript.trimModName = trimModName;

    function getDeclareFilePath(fname) {
        return isTSFile(fname) ? changePathToDTS(fname) : changePathToDTS(fname);
    }
    TypeScript.getDeclareFilePath = getDeclareFilePath;

    function isFileOfExtension(fname, ext) {
        var invariantFname = fname.toLocaleUpperCase();
        var invariantExt = ext.toLocaleUpperCase();
        var extLength = invariantExt.length;
        return invariantFname.length > extLength && invariantFname.substring(invariantFname.length - extLength, invariantFname.length) === invariantExt;
    }

    function isJSFile(fname) {
        return isFileOfExtension(fname, ".js");
    }
    TypeScript.isJSFile = isJSFile;

    function isTSFile(fname) {
        return isFileOfExtension(fname, ".ts");
    }
    TypeScript.isTSFile = isTSFile;

    function isDTSFile(fname) {
        return isFileOfExtension(fname, ".d.ts");
    }
    TypeScript.isDTSFile = isDTSFile;

    function getPrettyName(modPath, quote, treatAsFileName) {
        if (typeof quote === "undefined") { quote = true; }
        if (typeof treatAsFileName === "undefined") { treatAsFileName = false; }
        var modName = treatAsFileName ? switchToForwardSlashes(modPath) : trimModName(stripQuotes(modPath));
        var components = this.getPathComponents(modName);
        return components.length ? (quote ? quoteStr(components[components.length - 1]) : components[components.length - 1]) : modPath;
    }
    TypeScript.getPrettyName = getPrettyName;

    function getPathComponents(path) {
        return path.split("/");
    }
    TypeScript.getPathComponents = getPathComponents;

    function getRelativePathToFixedPath(fixedModFilePath, absoluteModPath, isAbsoultePathURL) {
        if (typeof isAbsoultePathURL === "undefined") { isAbsoultePathURL = true; }
        absoluteModPath = switchToForwardSlashes(absoluteModPath);

        var modComponents = this.getPathComponents(absoluteModPath);
        var fixedModComponents = this.getPathComponents(fixedModFilePath);

        var joinStartIndex = 0;
        for (; joinStartIndex < modComponents.length && joinStartIndex < fixedModComponents.length; joinStartIndex++) {
            if (fixedModComponents[joinStartIndex] !== modComponents[joinStartIndex]) {
                break;
            }
        }

        if (joinStartIndex !== 0) {
            var relativePath = "";
            var relativePathComponents = modComponents.slice(joinStartIndex, modComponents.length);
            for (; joinStartIndex < fixedModComponents.length; joinStartIndex++) {
                if (fixedModComponents[joinStartIndex] !== "") {
                    relativePath = relativePath + "../";
                }
            }

            return relativePath + relativePathComponents.join("/");
        }

        if (isAbsoultePathURL && absoluteModPath.indexOf("://") === -1) {
            absoluteModPath = "file:///" + absoluteModPath;
        }

        return absoluteModPath;
    }
    TypeScript.getRelativePathToFixedPath = getRelativePathToFixedPath;

    function quoteBaseName(modPath) {
        var modName = trimModName(stripQuotes(modPath));
        var path = getRootFilePath(modName);
        if (path === "") {
            return modPath;
        } else {
            var components = modName.split(path);
            var fileIndex = components.length > 1 ? 1 : 0;
            return quoteStr(components[fileIndex]);
        }
    }
    TypeScript.quoteBaseName = quoteBaseName;

    function changePathToDTS(modPath) {
        return trimModName(stripQuotes(modPath)) + ".d.ts";
    }
    TypeScript.changePathToDTS = changePathToDTS;

    function isRelative(path) {
        return path.length > 0 && path.charAt(0) === ".";
    }
    TypeScript.isRelative = isRelative;
    function isRooted(path) {
        return path.length > 0 && (path.charAt(0) === "\\" || path.charAt(0) === "/" || (path.indexOf(":\\") !== -1) || (path.indexOf(":/") !== -1));
    }
    TypeScript.isRooted = isRooted;

    function getRootFilePath(outFname) {
        if (outFname === "") {
            return outFname;
        } else {
            var isPath = outFname.indexOf("/") !== -1;
            return isPath ? filePath(outFname) : "";
        }
    }
    TypeScript.getRootFilePath = getRootFilePath;

    function filePathComponents(fullPath) {
        fullPath = switchToForwardSlashes(fullPath);
        var components = getPathComponents(fullPath);
        return components.slice(0, components.length - 1);
    }
    TypeScript.filePathComponents = filePathComponents;

    function filePath(fullPath) {
        var path = filePathComponents(fullPath);
        return path.join("/") + "/";
    }
    TypeScript.filePath = filePath;

    var normalizePathRegEx = /^\\\\[^\\]/;
    function normalizePath(path) {
        if (normalizePathRegEx.test(path)) {
            path = "file:" + path;
        }
        var parts = this.getPathComponents(switchToForwardSlashes(path));
        var normalizedParts = [];

        for (var i = 0; i < parts.length; i++) {
            var part = parts[i];
            if (part === ".") {
                continue;
            }

            if (normalizedParts.length > 0 && TypeScript.ArrayUtilities.last(normalizedParts) !== ".." && part === "..") {
                normalizedParts.pop();
                continue;
            }

            normalizedParts.push(part);
        }

        return normalizedParts.join("/");
    }
    TypeScript.normalizePath = normalizePath;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var CompilationSettings = (function () {
        function CompilationSettings() {
            this.propagateEnumConstants = false;
            this.removeComments = false;
            this.watch = false;
            this.noResolve = false;
            this.allowAutomaticSemicolonInsertion = true;
            this.noImplicitAny = false;
            this.noLib = false;
            this.codeGenTarget = 0 /* EcmaScript3 */;
            this.moduleGenTarget = 0 /* Unspecified */;
            this.outFileOption = "";
            this.outDirOption = "";
            this.mapSourceFiles = false;
            this.mapRoot = "";
            this.sourceRoot = "";
            this.generateDeclarationFiles = false;
            this.useCaseSensitiveFileResolution = false;
            this.gatherDiagnostics = false;
            this.updateTC = false;
        }
        return CompilationSettings;
    })();
    TypeScript.CompilationSettings = CompilationSettings;

    function getFileReferenceFromReferencePath(comment) {
        var referencesRegEx = /^(\/\/\/\s*<reference\s+path=)('|")(.+?)\2\s*(static=('|")(.+?)\2\s*)*\/>/gim;
        var match = referencesRegEx.exec(comment);

        if (match) {
            var path = TypeScript.normalizePath(match[3]);
            var adjustedPath = TypeScript.normalizePath(path);

            var isResident = match.length >= 7 && match[6] === "true";
            if (isResident) {
                TypeScript.CompilerDiagnostics.debugPrint(path + " is resident");
            }
            return {
                line: 0,
                character: 0,
                position: 0,
                length: 0,
                path: TypeScript.switchToForwardSlashes(adjustedPath),
                isResident: isResident
            };
        } else {
            return null;
        }
    }

    function getImplicitImport(comment) {
        var implicitImportRegEx = /^(\/\/\/\s*<implicit-import\s*)*\/>/gim;
        var match = implicitImportRegEx.exec(comment);

        if (match) {
            return true;
        }

        return false;
    }
    TypeScript.getImplicitImport = getImplicitImport;

    function getReferencedFiles(fileName, sourceText) {
        var preProcessInfo = preProcessFile(fileName, sourceText, null, false);
        return preProcessInfo.referencedFiles;
    }
    TypeScript.getReferencedFiles = getReferencedFiles;

    var scannerWindow = TypeScript.ArrayUtilities.createArray(2048, 0);
    var scannerDiagnostics = [];

    function processImports(lineMap, scanner, token, importedFiles) {
        var position = 0;
        var lineChar = { line: -1, character: -1 };

        while (token.tokenKind !== 10 /* EndOfFileToken */) {
            if (token.tokenKind === 49 /* ImportKeyword */) {
                var importStart = position + token.leadingTriviaWidth();
                token = scanner.scan(scannerDiagnostics, false);

                if (TypeScript.SyntaxFacts.isIdentifierNameOrAnyKeyword(token)) {
                    token = scanner.scan(scannerDiagnostics, false);

                    if (token.tokenKind === 107 /* EqualsToken */) {
                        token = scanner.scan(scannerDiagnostics, false);

                        if (token.tokenKind === 65 /* ModuleKeyword */ || token.tokenKind === 66 /* RequireKeyword */) {
                            token = scanner.scan(scannerDiagnostics, false);

                            if (token.tokenKind === 72 /* OpenParenToken */) {
                                var afterOpenParenPosition = scanner.absoluteIndex();
                                token = scanner.scan(scannerDiagnostics, false);

                                lineMap.fillLineAndCharacterFromPosition(importStart, lineChar);

                                if (token.tokenKind === 14 /* StringLiteral */) {
                                    var ref = {
                                        line: lineChar.line,
                                        character: lineChar.character,
                                        position: afterOpenParenPosition + token.leadingTriviaWidth(),
                                        length: token.width(),
                                        path: TypeScript.stripQuotes(TypeScript.switchToForwardSlashes(token.text())),
                                        isResident: false
                                    };
                                    importedFiles.push(ref);
                                }
                            }
                        }
                    }
                }
            }

            position = scanner.absoluteIndex();
            token = scanner.scan(scannerDiagnostics, false);
        }
    }

    function processTripleSlashDirectives(lineMap, firstToken, settings, referencedFiles) {
        var leadingTrivia = firstToken.leadingTrivia();

        var position = 0;
        var lineChar = { line: -1, character: -1 };
        var noDefaultLib = false;

        for (var i = 0, n = leadingTrivia.count(); i < n; i++) {
            var trivia = leadingTrivia.syntaxTriviaAt(i);

            if (trivia.kind() === 7 /* SingleLineCommentTrivia */) {
                var triviaText = trivia.fullText();
                var referencedCode = getFileReferenceFromReferencePath(triviaText);

                if (referencedCode) {
                    lineMap.fillLineAndCharacterFromPosition(position, lineChar);
                    referencedCode.position = position;
                    referencedCode.length = trivia.fullWidth();
                    referencedCode.line = lineChar.line;
                    referencedCode.character = lineChar.character;

                    referencedFiles.push(referencedCode);
                }

                if (settings) {
                    var isNoDefaultLibRegex = /^(\/\/\/\s*<reference\s+no-default-lib=)('|")(.+?)\2\s*\/>/gim;
                    var isNoDefaultLibMatch = isNoDefaultLibRegex.exec(triviaText);
                    if (isNoDefaultLibMatch) {
                        noDefaultLib = (isNoDefaultLibMatch[3] === "true");
                    }
                }
            }

            position += trivia.fullWidth();
        }

        return { noDefaultLib: noDefaultLib };
    }

    function preProcessFile(fileName, sourceText, settings, readImportFiles) {
        if (typeof readImportFiles === "undefined") { readImportFiles = true; }
        settings = settings || new CompilationSettings();

        var text = TypeScript.SimpleText.fromScriptSnapshot(sourceText);
        var scanner = new TypeScript.Scanner(fileName, text, settings.codeGenTarget, scannerWindow);

        var firstToken = scanner.scan(scannerDiagnostics, false);

        var importedFiles = [];
        if (readImportFiles) {
            processImports(text.lineMap(), scanner, firstToken, importedFiles);
        }

        var referencedFiles = [];
        var properties = processTripleSlashDirectives(text.lineMap(), firstToken, settings, referencedFiles);

        scannerDiagnostics.length = 0;
        return { settings: settings, referencedFiles: referencedFiles, importedFiles: importedFiles, isLibFile: properties.noDefaultLib };
    }
    TypeScript.preProcessFile = preProcessFile;

    function getParseOptions(settings) {
        return new TypeScript.ParseOptions(settings.codeGenTarget, settings.allowAutomaticSemicolonInsertion);
    }
    TypeScript.getParseOptions = getParseOptions;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var ReferenceResolutionResult = (function () {
        function ReferenceResolutionResult() {
            this.resolvedFiles = [];
            this.diagnostics = [];
            this.seenNoDefaultLibTag = false;
        }
        return ReferenceResolutionResult;
    })();
    TypeScript.ReferenceResolutionResult = ReferenceResolutionResult;

    var ReferenceLocation = (function () {
        function ReferenceLocation(filePath, position, length, isImported) {
            this.filePath = filePath;
            this.position = position;
            this.length = length;
            this.isImported = isImported;
        }
        return ReferenceLocation;
    })();

    var ReferenceResolver = (function () {
        function ReferenceResolver(inputFileNames, host, settings) {
            this.inputFileNames = inputFileNames;
            this.host = host;
            this.settings = settings;
            this.visited = {};
        }
        ReferenceResolver.resolve = function (inputFileNames, host, settings) {
            var resolver = new ReferenceResolver(inputFileNames, host, settings);
            return resolver.resolveInputFiles();
        };

        ReferenceResolver.prototype.resolveInputFiles = function () {
            var result = new ReferenceResolutionResult();

            if (!this.inputFileNames || this.inputFileNames.length <= 0) {
                return result;
            }

            var referenceLocation = new ReferenceLocation(null, 0, 0, false);
            for (var i = 0, n = this.inputFileNames.length; i < n; i++) {
                this.resolveIncludedFile(this.inputFileNames[i], referenceLocation, result);
            }

            return result;
        };

        ReferenceResolver.prototype.resolveIncludedFile = function (path, referenceLocation, resolutionResult) {
            var normalizedPath = this.getNormalizedFilePath(path, referenceLocation.filePath);

            if (this.isSameFile(normalizedPath, referenceLocation.filePath)) {
                if (!referenceLocation.isImported) {
                    resolutionResult.diagnostics.push(new TypeScript.Diagnostic(referenceLocation.filePath, referenceLocation.position, referenceLocation.length, TypeScript.DiagnosticCode.A_file_cannot_have_a_reference_to_itself, null));
                }

                return normalizedPath;
            }

            if (!TypeScript.isTSFile(normalizedPath) && !TypeScript.isDTSFile(normalizedPath)) {
                var dtsFile = normalizedPath + ".d.ts";
                var tsFile = normalizedPath + ".ts";

                if (this.host.fileExists(dtsFile)) {
                    normalizedPath = dtsFile;
                } else {
                    normalizedPath = tsFile;
                }
            }

            if (!this.host.fileExists(normalizedPath)) {
                if (!referenceLocation.isImported) {
                    resolutionResult.diagnostics.push(new TypeScript.Diagnostic(referenceLocation.filePath, referenceLocation.position, referenceLocation.length, TypeScript.DiagnosticCode.Cannot_resolve_referenced_file_0, [path]));
                }

                return normalizedPath;
            }

            return this.resolveFile(normalizedPath, resolutionResult);
        };

        ReferenceResolver.prototype.resolveImportedFile = function (path, referenceLocation, resolutionResult) {
            var isRelativePath = TypeScript.isRelative(path);
            var isRootedPath = isRelativePath ? false : TypeScript.isRooted(path);

            if (isRelativePath || isRootedPath) {
                return this.resolveIncludedFile(path, referenceLocation, resolutionResult);
            } else {
                var parentDirectory = this.host.getParentDirectory(referenceLocation.filePath);
                var searchFilePath = null;
                var dtsFileName = path + ".d.ts";
                var tsFilePath = path + ".ts";

                do {
                    var currentFilePath = this.host.resolveRelativePath(dtsFileName, parentDirectory);
                    if (this.host.fileExists(currentFilePath)) {
                        searchFilePath = currentFilePath;
                        break;
                    }

                    currentFilePath = this.host.resolveRelativePath(tsFilePath, parentDirectory);
                    if (this.host.fileExists(currentFilePath)) {
                        searchFilePath = currentFilePath;
                        break;
                    }

                    parentDirectory = this.host.getParentDirectory(parentDirectory);
                } while(parentDirectory);

                if (!searchFilePath) {
                    return path;
                }

                return this.resolveFile(searchFilePath, resolutionResult);
            }
        };

        ReferenceResolver.prototype.resolveFile = function (normalizedPath, resolutionResult) {
            var visitedPath = this.isVisited(normalizedPath);
            if (!visitedPath) {
                this.recordVisitedFile(normalizedPath);

                var preprocessedFileInformation = TypeScript.preProcessFile(normalizedPath, this.host.getScriptSnapshot(normalizedPath), this.settings);

                if (preprocessedFileInformation.isLibFile) {
                    resolutionResult.seenNoDefaultLibTag = true;
                }

                var normalizedReferencePaths = [];
                for (var i = 0, n = preprocessedFileInformation.referencedFiles.length; i < n; i++) {
                    var fileReference = preprocessedFileInformation.referencedFiles[i];
                    var currentReferenceLocation = new ReferenceLocation(normalizedPath, fileReference.position, fileReference.length, false);
                    var normalizedReferencePath = this.resolveIncludedFile(fileReference.path, currentReferenceLocation, resolutionResult);
                    normalizedReferencePaths.push(normalizedReferencePath);
                }

                var normalizedImportPaths = [];
                for (var i = 0; i < preprocessedFileInformation.importedFiles.length; i++) {
                    var fileImport = preprocessedFileInformation.importedFiles[i];
                    var currentReferenceLocation = new ReferenceLocation(normalizedPath, fileImport.position, fileImport.length, true);
                    var normalizedImportPath = this.resolveImportedFile(fileImport.path, currentReferenceLocation, resolutionResult);
                    normalizedImportPaths.push(normalizedImportPath);
                }

                resolutionResult.resolvedFiles.push({
                    path: normalizedPath,
                    referencedFiles: normalizedReferencePaths,
                    importedFiles: normalizedImportPaths
                });
            } else {
                normalizedPath = visitedPath;
            }

            return normalizedPath;
        };

        ReferenceResolver.prototype.getNormalizedFilePath = function (path, parentFilePath) {
            var parentFileDirectory = parentFilePath ? this.host.getParentDirectory(parentFilePath) : "";
            var normalizedPath = this.host.resolveRelativePath(path, parentFileDirectory);
            return normalizedPath;
        };

        ReferenceResolver.prototype.getUniqueFileId = function (filePath) {
            return this.settings.useCaseSensitiveFileResolution ? filePath : filePath.toLocaleUpperCase();
        };

        ReferenceResolver.prototype.recordVisitedFile = function (filePath) {
            this.visited[this.getUniqueFileId(filePath)] = filePath;
        };

        ReferenceResolver.prototype.isVisited = function (filePath) {
            return this.visited[this.getUniqueFileId(filePath)];
        };

        ReferenceResolver.prototype.isSameFile = function (filePath1, filePath2) {
            if (!filePath1 || !filePath2) {
                return false;
            }

            if (this.settings.useCaseSensitiveFileResolution) {
                return filePath1 === filePath2;
            } else {
                return filePath1.toLocaleUpperCase() === filePath2.toLocaleUpperCase();
            }
        };
        return ReferenceResolver;
    })();
    TypeScript.ReferenceResolver = ReferenceResolver;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var TextWriter = (function () {
        function TextWriter(ioHost, path, writeByteOrderMark) {
            this.ioHost = ioHost;
            this.path = path;
            this.writeByteOrderMark = writeByteOrderMark;
            this.contents = "";
            this.onNewLine = true;
        }
        TextWriter.prototype.Write = function (s) {
            this.contents += s;
            this.onNewLine = false;
        };

        TextWriter.prototype.WriteLine = function (s) {
            this.contents += s;
            this.contents += TypeScript.newLine();
            this.onNewLine = true;
        };

        TextWriter.prototype.Close = function () {
            try  {
                this.ioHost.writeFile(this.path, this.contents, this.writeByteOrderMark);
            } catch (e) {
                TypeScript.Emitter.throwEmitterError(e);
            }
        };
        return TextWriter;
    })();
    TypeScript.TextWriter = TextWriter;

    var DeclarationEmitter = (function () {
        function DeclarationEmitter(emittingFileName, document, compiler) {
            this.emittingFileName = emittingFileName;
            this.document = document;
            this.compiler = compiler;
            this.declFile = null;
            this.indenter = new TypeScript.Indenter();
            this.declarationContainerStack = [];
            this.isDottedModuleName = [];
            this.ignoreCallbackAst = null;
            this.varListCount = 0;
            this.emittedReferencePaths = false;
            this.declFile = new TextWriter(this.compiler.emitOptions.ioHost, emittingFileName, this.document.byteOrderMark !== 0 /* None */);
        }
        DeclarationEmitter.prototype.widenType = function (type) {
            if (type === this.compiler.semanticInfoChain.undefinedTypeSymbol || type === this.compiler.semanticInfoChain.nullTypeSymbol) {
                return this.compiler.semanticInfoChain.anyTypeSymbol;
            }

            return type;
        };

        DeclarationEmitter.prototype.close = function () {
            try  {
                this.declFile.Close();
            } catch (e) {
                TypeScript.Emitter.throwEmitterError(e);
            }
        };

        DeclarationEmitter.prototype.emitDeclarations = function (script) {
            var _this = this;
            var walk = function (pre, ast) {
                switch (ast.nodeType()) {
                    case 98 /* VariableStatement */:
                        return _this.variableStatementCallback(pre, ast);
                    case 19 /* VariableDeclaration */:
                        return _this.variableDeclarationCallback(pre, ast);
                    case 18 /* VariableDeclarator */:
                        return _this.variableDeclaratorCallback(pre, ast);
                    case 82 /* Block */:
                        return _this.blockCallback(pre, ast);
                    case 13 /* FunctionDeclaration */:
                        return _this.functionDeclarationCallback(pre, ast);
                    case 14 /* ClassDeclaration */:
                        return _this.classDeclarationCallback(pre, ast);
                    case 15 /* InterfaceDeclaration */:
                        return _this.interfaceDeclarationCallback(pre, ast);
                    case 17 /* ImportDeclaration */:
                        return _this.importDeclarationCallback(pre, ast);
                    case 16 /* ModuleDeclaration */:
                        return _this.moduleDeclarationCallback(pre, ast);
                    case 88 /* ExportAssignment */:
                        return _this.exportAssignmentCallback(pre, ast);
                    case 2 /* Script */:
                        return _this.scriptCallback(pre, ast);
                    default:
                        return _this.defaultCallback(pre, ast);
                }
            };

            TypeScript.getAstWalkerFactory().walk(script, function (ast, parent, walker) {
                walker.options.goChildren = walk(true, ast);
                return ast;
            }, function (ast, parent, walker) {
                walker.options.goChildren = walk(false, ast);
                return ast;
            });
        };

        DeclarationEmitter.prototype.getAstDeclarationContainer = function () {
            return this.declarationContainerStack[this.declarationContainerStack.length - 1];
        };

        DeclarationEmitter.prototype.emitDottedModuleName = function () {
            return (this.isDottedModuleName.length === 0) ? false : this.isDottedModuleName[this.isDottedModuleName.length - 1];
        };

        DeclarationEmitter.prototype.getIndentString = function (declIndent) {
            if (typeof declIndent === "undefined") { declIndent = false; }
            return this.indenter.getIndent();
        };

        DeclarationEmitter.prototype.emitIndent = function () {
            this.declFile.Write(this.getIndentString());
        };

        DeclarationEmitter.prototype.canEmitSignature = function (declFlags, declAST, canEmitGlobalAmbientDecl, useDeclarationContainerTop) {
            if (typeof canEmitGlobalAmbientDecl === "undefined") { canEmitGlobalAmbientDecl = true; }
            if (typeof useDeclarationContainerTop === "undefined") { useDeclarationContainerTop = true; }
            var container;
            if (useDeclarationContainerTop) {
                container = this.getAstDeclarationContainer();
            } else {
                container = this.declarationContainerStack[this.declarationContainerStack.length - 2];
            }

            var pullDecl = this.compiler.semanticInfoChain.getDeclForAST(declAST, this.document.fileName);
            if (container.nodeType() === 16 /* ModuleDeclaration */) {
                if (!TypeScript.hasFlag(pullDecl.flags, 1 /* Exported */)) {
                    var start = new Date().getTime();
                    var declSymbol = this.compiler.semanticInfoChain.getSymbolForAST(declAST, this.document.fileName);
                    var result = declSymbol && declSymbol.isExternallyVisible();
                    TypeScript.declarationEmitIsExternallyVisibleTime += new Date().getTime() - start;

                    return result;
                }
            }

            if (!canEmitGlobalAmbientDecl && container.nodeType() === 2 /* Script */ && TypeScript.hasFlag(pullDecl.flags, 8 /* Ambient */)) {
                return false;
            }

            return true;
        };

        DeclarationEmitter.prototype.canEmitPrePostAstSignature = function (declFlags, astWithPrePostCallback, preCallback) {
            if (this.ignoreCallbackAst) {
                TypeScript.CompilerDiagnostics.assert(this.ignoreCallbackAst !== astWithPrePostCallback, "Ignore Callback AST mismatch");
                this.ignoreCallbackAst = null;
                return false;
            } else if (preCallback && !this.canEmitSignature(declFlags, astWithPrePostCallback, true, preCallback)) {
                this.ignoreCallbackAst = astWithPrePostCallback;
                return false;
            }

            return true;
        };

        DeclarationEmitter.prototype.getDeclFlagsString = function (declFlags, pullDecl, typeString) {
            var result = this.getIndentString();
            var pullFlags = pullDecl.flags;

            if (TypeScript.hasFlag(declFlags, 16 /* Static */)) {
                if (TypeScript.hasFlag(declFlags, 2 /* Private */)) {
                    result += "private ";
                }
                result += "static ";
            } else {
                if (TypeScript.hasFlag(declFlags, 2 /* Private */)) {
                    result += "private ";
                } else if (TypeScript.hasFlag(declFlags, 4 /* Public */)) {
                    result += "public ";
                } else {
                    var emitDeclare = !TypeScript.hasFlag(pullFlags, 1 /* Exported */);

                    var container = this.getAstDeclarationContainer();
                    if (container.nodeType() === 16 /* ModuleDeclaration */ && TypeScript.hasFlag((container).getModuleFlags(), 256 /* IsWholeFile */) && TypeScript.hasFlag(pullFlags, 1 /* Exported */)) {
                        result += "export ";
                        emitDeclare = true;
                    }

                    if (emitDeclare && typeString !== "interface" && typeString != "import") {
                        result += "declare ";
                    }

                    result += typeString + " ";
                }
            }

            return result;
        };

        DeclarationEmitter.prototype.emitDeclFlags = function (declFlags, pullDecl, typeString) {
            this.declFile.Write(this.getDeclFlagsString(declFlags, pullDecl, typeString));
        };

        DeclarationEmitter.prototype.canEmitTypeAnnotationSignature = function (declFlag) {
            if (typeof declFlag === "undefined") { declFlag = 0 /* None */; }
            return !TypeScript.hasFlag(declFlag, 2 /* Private */);
        };

        DeclarationEmitter.prototype.pushDeclarationContainer = function (ast) {
            this.declarationContainerStack.push(ast);
        };

        DeclarationEmitter.prototype.popDeclarationContainer = function (ast) {
            TypeScript.CompilerDiagnostics.assert(ast !== this.getAstDeclarationContainer(), 'Declaration container mismatch');
            this.declarationContainerStack.pop();
        };

        DeclarationEmitter.prototype.emitTypeNamesMember = function (memberName, emitIndent) {
            if (typeof emitIndent === "undefined") { emitIndent = false; }
            if (memberName.prefix === "{ ") {
                if (emitIndent) {
                    this.emitIndent();
                }

                this.declFile.WriteLine("{");
                this.indenter.increaseIndent();
                emitIndent = true;
            } else if (memberName.prefix !== "") {
                if (emitIndent) {
                    this.emitIndent();
                }

                this.declFile.Write(memberName.prefix);
                emitIndent = false;
            }

            if (memberName.isString()) {
                if (emitIndent) {
                    this.emitIndent();
                }

                this.declFile.Write((memberName).text);
            } else if (memberName.isArray()) {
                var ar = memberName;
                for (var index = 0; index < ar.entries.length; index++) {
                    this.emitTypeNamesMember(ar.entries[index], emitIndent);
                    if (ar.delim === "; ") {
                        this.declFile.WriteLine(";");
                    }
                }
            }

            if (memberName.suffix === "}") {
                this.indenter.decreaseIndent();
                this.emitIndent();
                this.declFile.Write(memberName.suffix);
            } else {
                this.declFile.Write(memberName.suffix);
            }
        };

        DeclarationEmitter.prototype.emitTypeSignature = function (type) {
            var declarationContainerAst = this.getAstDeclarationContainer();

            var start = new Date().getTime();
            var declarationContainerDecl = this.compiler.semanticInfoChain.getDeclForAST(declarationContainerAst, this.document.fileName);
            var declarationPullSymbol = declarationContainerDecl.getSymbol();
            TypeScript.declarationEmitTypeSignatureTime += new Date().getTime() - start;

            var typeNameMembers = type.getScopedNameEx(declarationPullSymbol);
            this.emitTypeNamesMember(typeNameMembers);
        };

        DeclarationEmitter.prototype.emitComment = function (comment) {
            var text = comment.getText();
            if (this.declFile.onNewLine) {
                this.emitIndent();
            } else if (!comment.isBlockComment) {
                this.declFile.WriteLine("");
                this.emitIndent();
            }

            this.declFile.Write(text[0]);

            for (var i = 1; i < text.length; i++) {
                this.declFile.WriteLine("");
                this.emitIndent();
                this.declFile.Write(text[i]);
            }

            if (comment.endsLine || !comment.isBlockComment) {
                this.declFile.WriteLine("");
            } else {
                this.declFile.Write(" ");
            }
        };

        DeclarationEmitter.prototype.emitDeclarationComments = function (astOrSymbol, endLine) {
            if (typeof endLine === "undefined") { endLine = true; }
            if (this.compiler.emitOptions.compilationSettings.removeComments) {
                return;
            }

            var declComments = astOrSymbol.docComments();
            this.writeDeclarationComments(declComments, endLine);
        };

        DeclarationEmitter.prototype.writeDeclarationComments = function (declComments, endLine) {
            if (typeof endLine === "undefined") { endLine = true; }
            if (declComments.length > 0) {
                for (var i = 0; i < declComments.length; i++) {
                    this.emitComment(declComments[i]);
                }

                if (endLine) {
                    if (!this.declFile.onNewLine) {
                        this.declFile.WriteLine("");
                    }
                } else {
                    if (this.declFile.onNewLine) {
                        this.emitIndent();
                    }
                }
            }
        };

        DeclarationEmitter.prototype.emitTypeOfBoundDecl = function (boundDecl) {
            var start = new Date().getTime();
            var decl = this.compiler.semanticInfoChain.getDeclForAST(boundDecl, this.document.fileName);
            var pullSymbol = decl.getSymbol();
            TypeScript.declarationEmitGetBoundDeclTypeTime += new Date().getTime() - start;

            var type = this.widenType(pullSymbol.type);
            if (!type) {
                return;
            }

            if (boundDecl.typeExpr || (boundDecl.init && type !== this.compiler.semanticInfoChain.anyTypeSymbol)) {
                this.declFile.Write(": ");
                this.emitTypeSignature(type);
            }
        };

        DeclarationEmitter.prototype.variableDeclaratorCallback = function (pre, varDecl) {
            if (pre && this.canEmitSignature(TypeScript.ToDeclFlags(varDecl.getVarFlags()), varDecl, false)) {
                var interfaceMember = (this.getAstDeclarationContainer().nodeType() === 15 /* InterfaceDeclaration */);
                this.emitDeclarationComments(varDecl);
                if (!interfaceMember) {
                    if (this.varListCount >= 0) {
                        this.emitDeclFlags(TypeScript.ToDeclFlags(varDecl.getVarFlags()), this.compiler.semanticInfoChain.getDeclForAST(varDecl, this.document.fileName), "var");
                        this.varListCount = -this.varListCount;
                    }

                    this.declFile.Write(varDecl.id.actualText);
                } else {
                    this.emitIndent();
                    this.declFile.Write(varDecl.id.actualText);
                    if (TypeScript.hasFlag(varDecl.id.getFlags(), 4 /* OptionalName */)) {
                        this.declFile.Write("?");
                    }
                }

                if (this.canEmitTypeAnnotationSignature(TypeScript.ToDeclFlags(varDecl.getVarFlags()))) {
                    this.emitTypeOfBoundDecl(varDecl);
                }

                if (this.varListCount > 0) {
                    this.varListCount--;
                } else if (this.varListCount < 0) {
                    this.varListCount++;
                }

                if (this.varListCount < 0) {
                    this.declFile.Write(", ");
                } else {
                    this.declFile.WriteLine(";");
                }
            }
            return false;
        };

        DeclarationEmitter.prototype.blockCallback = function (pre, block) {
            return false;
        };

        DeclarationEmitter.prototype.variableStatementCallback = function (pre, variableStatement) {
            return true;
        };

        DeclarationEmitter.prototype.variableDeclarationCallback = function (pre, variableDeclaration) {
            if (pre) {
                this.varListCount = variableDeclaration.declarators.members.length;
            } else {
                this.varListCount = 0;
            }

            return true;
        };

        DeclarationEmitter.prototype.emitArgDecl = function (argDecl, funcDecl) {
            this.indenter.increaseIndent();

            this.emitDeclarationComments(argDecl, false);
            this.declFile.Write(argDecl.id.actualText);
            if (argDecl.isOptionalArg()) {
                this.declFile.Write("?");
            }

            this.indenter.decreaseIndent();

            if (this.canEmitTypeAnnotationSignature(TypeScript.ToDeclFlags(funcDecl.getFunctionFlags()))) {
                this.emitTypeOfBoundDecl(argDecl);
            }
        };

        DeclarationEmitter.prototype.isOverloadedCallSignature = function (funcDecl) {
            var start = new Date().getTime();
            var functionDecl = this.compiler.semanticInfoChain.getDeclForAST(funcDecl, this.document.fileName);
            var funcSymbol = functionDecl.getSymbol();
            TypeScript.declarationEmitIsOverloadedCallSignatureTime += new Date().getTime() - start;

            var funcTypeSymbol = funcSymbol.type;
            var signatures = funcTypeSymbol.getCallSignatures();
            var result = signatures && signatures.length > 1;

            return result;
        };

        DeclarationEmitter.prototype.functionDeclarationCallback = function (pre, funcDecl) {
            if (!pre) {
                return false;
            }

            if (funcDecl.isAccessor()) {
                return this.emitPropertyAccessorSignature(funcDecl);
            }

            var isInterfaceMember = (this.getAstDeclarationContainer().nodeType() === 15 /* InterfaceDeclaration */);

            var start = new Date().getTime();
            var funcSymbol = this.compiler.semanticInfoChain.getSymbolForAST(funcDecl, this.document.fileName);

            TypeScript.declarationEmitFunctionDeclarationGetSymbolTime += new Date().getTime() - start;

            var funcTypeSymbol = funcSymbol.type;
            if (funcDecl.block) {
                var constructSignatures = funcTypeSymbol.getConstructSignatures();
                if (constructSignatures && constructSignatures.length > 1) {
                    return false;
                } else if (this.isOverloadedCallSignature(funcDecl)) {
                    return false;
                }
            } else if (!isInterfaceMember && TypeScript.hasFlag(funcDecl.getFunctionFlags(), 2 /* Private */) && this.isOverloadedCallSignature(funcDecl)) {
                var callSignatures = funcTypeSymbol.getCallSignatures();
                TypeScript.Debug.assert(callSignatures && callSignatures.length > 1);
                var firstSignature = callSignatures[0].isDefinition() ? callSignatures[1] : callSignatures[0];
                var firstSignatureDecl = firstSignature.getDeclarations()[0];
                var firstFuncDecl = this.compiler.semanticInfoChain.getASTForDecl(firstSignatureDecl);
                if (firstFuncDecl !== funcDecl) {
                    return false;
                }
            }

            if (!this.canEmitSignature(TypeScript.ToDeclFlags(funcDecl.getFunctionFlags()), funcDecl, false)) {
                return false;
            }

            var funcPullDecl = this.compiler.semanticInfoChain.getDeclForAST(funcDecl, this.document.fileName);
            var funcSignature = funcPullDecl.getSignatureSymbol();
            this.emitDeclarationComments(funcDecl);
            if (funcDecl.isConstructor) {
                this.emitIndent();
                this.declFile.Write("constructor");
                this.emitTypeParameters(funcDecl.typeArguments, funcSignature);
            } else {
                var id = funcDecl.getNameText();
                if (!isInterfaceMember) {
                    this.emitDeclFlags(TypeScript.ToDeclFlags(funcDecl.getFunctionFlags()), funcPullDecl, "function");
                    if (id !== "__missing" || !funcDecl.name || !funcDecl.name.isMissing()) {
                        this.declFile.Write(id);
                    } else if (funcDecl.isConstructMember()) {
                        this.declFile.Write("new");
                    }

                    this.emitTypeParameters(funcDecl.typeArguments, funcSignature);
                } else {
                    this.emitIndent();
                    if (funcDecl.isConstructMember()) {
                        this.declFile.Write("new");
                        this.emitTypeParameters(funcDecl.typeArguments, funcSignature);
                    } else if (!funcDecl.isCallMember() && !funcDecl.isIndexerMember()) {
                        this.declFile.Write(id);
                        this.emitTypeParameters(funcDecl.typeArguments, funcSignature);
                        if (TypeScript.hasFlag(funcDecl.name.getFlags(), 4 /* OptionalName */)) {
                            this.declFile.Write("? ");
                        }
                    } else {
                        this.emitTypeParameters(funcDecl.typeArguments, funcSignature);
                    }
                }
            }

            if (!funcDecl.isIndexerMember()) {
                this.declFile.Write("(");
            } else {
                this.declFile.Write("[");
            }

            if (funcDecl.arguments) {
                var argsLen = funcDecl.arguments.members.length;
                if (funcDecl.variableArgList) {
                    argsLen--;
                }

                for (var i = 0; i < argsLen; i++) {
                    var argDecl = funcDecl.arguments.members[i];
                    this.emitArgDecl(argDecl, funcDecl);
                    if (i < (argsLen - 1)) {
                        this.declFile.Write(", ");
                    }
                }
            }

            if (funcDecl.variableArgList) {
                var lastArg = funcDecl.arguments.members[funcDecl.arguments.members.length - 1];
                if (funcDecl.arguments.members.length > 1) {
                    this.declFile.Write(", ...");
                } else {
                    this.declFile.Write("...");
                }

                this.emitArgDecl(lastArg, funcDecl);
            }

            if (!funcDecl.isIndexerMember()) {
                this.declFile.Write(")");
            } else {
                this.declFile.Write("]");
            }

            if (!funcDecl.isConstructor && this.canEmitTypeAnnotationSignature(TypeScript.ToDeclFlags(funcDecl.getFunctionFlags()))) {
                var returnType = funcSignature.returnType;
                if (funcDecl.returnTypeAnnotation || (returnType && returnType !== this.compiler.semanticInfoChain.anyTypeSymbol)) {
                    this.declFile.Write(": ");
                    this.emitTypeSignature(returnType);
                }
            }

            this.declFile.WriteLine(";");

            return false;
        };

        DeclarationEmitter.prototype.emitBaseExpression = function (bases, index) {
            var start = new Date().getTime();
            var baseTypeAndDiagnostics = this.compiler.semanticInfoChain.getSymbolForAST(bases.members[index], this.document.fileName);
            TypeScript.declarationEmitGetBaseTypeTime += new Date().getTime() - start;

            var baseType = baseTypeAndDiagnostics && baseTypeAndDiagnostics;
            this.emitTypeSignature(baseType);
        };

        DeclarationEmitter.prototype.emitBaseList = function (typeDecl, useExtendsList) {
            var bases = useExtendsList ? typeDecl.extendsList : typeDecl.implementsList;
            if (bases && (bases.members.length > 0)) {
                var qual = useExtendsList ? "extends" : "implements";
                this.declFile.Write(" " + qual + " ");
                var basesLen = bases.members.length;
                for (var i = 0; i < basesLen; i++) {
                    if (i > 0) {
                        this.declFile.Write(", ");
                    }
                    this.emitBaseExpression(bases, i);
                }
            }
        };

        DeclarationEmitter.prototype.emitAccessorDeclarationComments = function (funcDecl) {
            if (this.compiler.emitOptions.compilationSettings.removeComments) {
                return;
            }

            var start = new Date().getTime();
            var accessors = TypeScript.PullHelpers.getGetterAndSetterFunction(funcDecl, this.compiler.semanticInfoChain, this.document.fileName);
            TypeScript.declarationEmitGetAccessorFunctionTime += new Date().getTime();

            var comments = [];
            if (accessors.getter) {
                comments = comments.concat(accessors.getter.docComments());
            }
            if (accessors.setter) {
                comments = comments.concat(accessors.setter.docComments());
            }

            this.writeDeclarationComments(comments);
        };

        DeclarationEmitter.prototype.emitPropertyAccessorSignature = function (funcDecl) {
            var start = new Date().getTime();
            var accessorSymbol = TypeScript.PullHelpers.getAccessorSymbol(funcDecl, this.compiler.semanticInfoChain, this.document.fileName);
            TypeScript.declarationEmitGetAccessorFunctionTime += new Date().getTime();

            if (!TypeScript.hasFlag(funcDecl.getFunctionFlags(), 32 /* GetAccessor */) && accessorSymbol.getGetter()) {
                return false;
            }

            this.emitAccessorDeclarationComments(funcDecl);
            this.emitDeclFlags(TypeScript.ToDeclFlags(funcDecl.getFunctionFlags()), this.compiler.semanticInfoChain.getDeclForAST(funcDecl, this.document.fileName), "var");
            this.declFile.Write(funcDecl.name.actualText);
            if (this.canEmitTypeAnnotationSignature(TypeScript.ToDeclFlags(funcDecl.getFunctionFlags()))) {
                this.declFile.Write(" : ");
                var type = accessorSymbol.type;
                this.emitTypeSignature(type);
            }
            this.declFile.WriteLine(";");

            return false;
        };

        DeclarationEmitter.prototype.emitClassMembersFromConstructorDefinition = function (funcDecl) {
            if (funcDecl.arguments) {
                var argsLen = funcDecl.arguments.members.length;
                if (funcDecl.variableArgList) {
                    argsLen--;
                }

                for (var i = 0; i < argsLen; i++) {
                    var argDecl = funcDecl.arguments.members[i];
                    if (TypeScript.hasFlag(argDecl.getVarFlags(), 256 /* Property */)) {
                        var funcPullDecl = this.compiler.semanticInfoChain.getDeclForAST(funcDecl, this.document.fileName);
                        this.emitDeclarationComments(argDecl);
                        this.emitDeclFlags(TypeScript.ToDeclFlags(argDecl.getVarFlags()), funcPullDecl, "var");
                        this.declFile.Write(argDecl.id.actualText);

                        if (this.canEmitTypeAnnotationSignature(TypeScript.ToDeclFlags(argDecl.getVarFlags()))) {
                            this.emitTypeOfBoundDecl(argDecl);
                        }
                        this.declFile.WriteLine(";");
                    }
                }
            }
        };

        DeclarationEmitter.prototype.classDeclarationCallback = function (pre, classDecl) {
            if (!this.canEmitPrePostAstSignature(TypeScript.ToDeclFlags(classDecl.getVarFlags()), classDecl, pre)) {
                return false;
            }

            if (pre) {
                var className = classDecl.name.actualText;
                this.emitDeclarationComments(classDecl);
                var classPullDecl = this.compiler.semanticInfoChain.getDeclForAST(classDecl, this.document.fileName);
                this.emitDeclFlags(TypeScript.ToDeclFlags(classDecl.getVarFlags()), classPullDecl, "class");
                this.declFile.Write(className);
                this.pushDeclarationContainer(classDecl);
                this.emitTypeParameters(classDecl.typeParameters);
                this.emitBaseList(classDecl, true);
                this.emitBaseList(classDecl, false);
                this.declFile.WriteLine(" {");

                this.indenter.increaseIndent();
                if (classDecl.constructorDecl) {
                    this.emitClassMembersFromConstructorDefinition(classDecl.constructorDecl);
                }
            } else {
                this.indenter.decreaseIndent();
                this.popDeclarationContainer(classDecl);

                this.emitIndent();
                this.declFile.WriteLine("}");
            }

            return true;
        };

        DeclarationEmitter.prototype.emitTypeParameters = function (typeParams, funcSignature) {
            if (!typeParams || !typeParams.members.length) {
                return;
            }

            this.declFile.Write("<");
            var containerAst = this.getAstDeclarationContainer();

            var start = new Date().getTime();
            var containerDecl = this.compiler.semanticInfoChain.getDeclForAST(containerAst, this.document.fileName);
            var containerSymbol = containerDecl.getSymbol();
            TypeScript.declarationEmitGetTypeParameterSymbolTime += new Date().getTime() - start;

            var typars;
            if (funcSignature) {
                typars = funcSignature.getTypeParameters();
            } else {
                typars = containerSymbol.getTypeArguments();
                if (!typars || !typars.length) {
                    typars = containerSymbol.getTypeParameters();
                }
            }

            for (var i = 0; i < typars.length; i++) {
                if (i) {
                    this.declFile.Write(", ");
                }

                var memberName = typars[i].getScopedNameEx(containerSymbol, true);
                this.emitTypeNamesMember(memberName);
            }

            this.declFile.Write(">");
        };

        DeclarationEmitter.prototype.interfaceDeclarationCallback = function (pre, interfaceDecl) {
            if (!this.canEmitPrePostAstSignature(TypeScript.ToDeclFlags(interfaceDecl.getVarFlags()), interfaceDecl, pre)) {
                return false;
            }

            if (interfaceDecl.isObjectTypeLiteral) {
                return false;
            }

            if (pre) {
                var interfaceName = interfaceDecl.name.actualText;
                this.emitDeclarationComments(interfaceDecl);
                var interfacePullDecl = this.compiler.semanticInfoChain.getDeclForAST(interfaceDecl, this.document.fileName);
                this.emitDeclFlags(TypeScript.ToDeclFlags(interfaceDecl.getVarFlags()), interfacePullDecl, "interface");
                this.declFile.Write(interfaceName);
                this.pushDeclarationContainer(interfaceDecl);
                this.emitTypeParameters(interfaceDecl.typeParameters);
                this.emitBaseList(interfaceDecl, true);
                this.declFile.WriteLine(" {");

                this.indenter.increaseIndent();
            } else {
                this.indenter.decreaseIndent();
                this.popDeclarationContainer(interfaceDecl);

                this.emitIndent();
                this.declFile.WriteLine("}");
            }

            return true;
        };

        DeclarationEmitter.prototype.importDeclarationCallback = function (pre, importDeclAST) {
            if (pre) {
                var importDecl = this.compiler.semanticInfoChain.getDeclForAST(importDeclAST, this.document.fileName);
                var importSymbol = importDecl.getSymbol();
                var isExportedImportDecl = TypeScript.hasFlag(importDeclAST.getVarFlags(), 1 /* Exported */);

                if (isExportedImportDecl || importSymbol.typeUsedExternally || TypeScript.PullContainerTypeSymbol.usedAsSymbol(importSymbol.getContainer(), importSymbol)) {
                    this.emitDeclarationComments(importDeclAST);
                    this.emitIndent();
                    if (isExportedImportDecl) {
                        this.declFile.Write("export ");
                    }
                    this.declFile.Write("import ");
                    this.declFile.Write(importDeclAST.id.actualText + " = ");
                    if (importDeclAST.isExternalImportDeclaration()) {
                        this.declFile.WriteLine("require(" + importDeclAST.getAliasName() + ");");
                    } else {
                        this.declFile.WriteLine(importDeclAST.getAliasName() + ";");
                    }
                }
            }

            return false;
        };

        DeclarationEmitter.prototype.emitEnumSignature = function (moduleDecl) {
            if (!this.canEmitSignature(TypeScript.ToDeclFlags(moduleDecl.getModuleFlags()), moduleDecl)) {
                return false;
            }

            this.emitDeclarationComments(moduleDecl);
            var modulePullDecl = this.compiler.semanticInfoChain.getDeclForAST(moduleDecl, this.document.fileName);
            this.emitDeclFlags(TypeScript.ToDeclFlags(moduleDecl.getModuleFlags()), modulePullDecl, "enum");
            this.declFile.WriteLine(moduleDecl.name.actualText + " {");

            this.indenter.increaseIndent();
            var membersLen = moduleDecl.members.members.length;
            for (var j = 0; j < membersLen; j++) {
                var memberDecl = moduleDecl.members.members[j];
                var variableStatement = memberDecl;
                var varDeclarator = variableStatement.declaration.declarators.members[0];
                this.emitDeclarationComments(varDeclarator);
                this.emitIndent();
                this.declFile.Write(varDeclarator.id.actualText);
                if (varDeclarator.init && varDeclarator.init.nodeType() == 7 /* NumericLiteral */) {
                    this.declFile.Write(" = " + (varDeclarator.init).text());
                }
                this.declFile.WriteLine(",");
            }
            this.indenter.decreaseIndent();

            this.emitIndent();
            this.declFile.WriteLine("}");

            return false;
        };

        DeclarationEmitter.prototype.moduleDeclarationCallback = function (pre, moduleDecl) {
            if (TypeScript.hasFlag(moduleDecl.getModuleFlags(), 256 /* IsWholeFile */)) {
                if (TypeScript.hasFlag(moduleDecl.getModuleFlags(), 512 /* IsDynamic */)) {
                    if (pre) {
                        this.pushDeclarationContainer(moduleDecl);
                    } else {
                        this.popDeclarationContainer(moduleDecl);
                    }
                }

                return true;
            }

            if (moduleDecl.isEnum()) {
                if (pre) {
                    this.emitEnumSignature(moduleDecl);
                }
                return false;
            }

            if (!this.canEmitPrePostAstSignature(TypeScript.ToDeclFlags(moduleDecl.getModuleFlags()), moduleDecl, pre)) {
                return false;
            }

            if (pre) {
                if (this.emitDottedModuleName()) {
                    this.dottedModuleEmit += ".";
                } else {
                    var modulePullDecl = this.compiler.semanticInfoChain.getDeclForAST(moduleDecl, this.document.fileName);
                    this.dottedModuleEmit = this.getDeclFlagsString(TypeScript.ToDeclFlags(moduleDecl.getModuleFlags()), modulePullDecl, "module");
                }

                this.dottedModuleEmit += moduleDecl.name.actualText;

                var isCurrentModuleDotted = (moduleDecl.members.members.length === 1 && moduleDecl.members.members[0].nodeType() === 16 /* ModuleDeclaration */ && !(moduleDecl.members.members[0]).isEnum() && TypeScript.hasFlag((moduleDecl.members.members[0]).getModuleFlags(), 1 /* Exported */));

                var moduleDeclComments = moduleDecl.docComments();
                isCurrentModuleDotted = isCurrentModuleDotted && (moduleDeclComments === null || moduleDeclComments.length === 0);

                this.isDottedModuleName.push(isCurrentModuleDotted);
                this.pushDeclarationContainer(moduleDecl);

                if (!isCurrentModuleDotted) {
                    this.emitDeclarationComments(moduleDecl);
                    this.declFile.Write(this.dottedModuleEmit);
                    this.declFile.WriteLine(" {");
                    this.indenter.increaseIndent();
                }
            } else {
                if (!this.emitDottedModuleName()) {
                    this.indenter.decreaseIndent();
                    this.emitIndent();
                    this.declFile.WriteLine("}");
                }

                this.popDeclarationContainer(moduleDecl);
                this.isDottedModuleName.pop();
            }

            return true;
        };

        DeclarationEmitter.prototype.exportAssignmentCallback = function (pre, ast) {
            if (pre) {
                this.emitIndent();
                this.declFile.Write("export = ");
                this.declFile.Write(ast.id.actualText);
                this.declFile.WriteLine(";");
            }

            return false;
        };

        DeclarationEmitter.prototype.emitReferencePaths = function (script) {
            if (this.emittedReferencePaths) {
                return;
            }

            var documents = [];
            if (this.compiler.emitOptions.outputMany || script.topLevelMod) {
                var scriptReferences = script.referencedFiles;
                var addedGlobalDocument = false;
                for (var j = 0; j < scriptReferences.length; j++) {
                    var currentReference = scriptReferences[j];
                    var document = this.compiler.getDocument(currentReference);

                    if (this.compiler.emitOptions.outputMany || document.script.isDeclareFile || document.script.topLevelMod || !addedGlobalDocument) {
                        documents = documents.concat(document);
                        if (!document.script.isDeclareFile && document.script.topLevelMod) {
                            addedGlobalDocument = true;
                        }
                    }
                }
            } else {
                var allDocuments = this.compiler.getDocuments();
                for (var i = 0; i < allDocuments.length; i++) {
                    if (!allDocuments[i].script.isDeclareFile && !allDocuments[i].script.topLevelMod) {
                        var scriptReferences = allDocuments[i].script.referencedFiles;
                        for (var j = 0; j < scriptReferences.length; j++) {
                            var currentReference = scriptReferences[j];
                            var document = this.compiler.getDocument(currentReference);

                            if (document.script.isDeclareFile || document.script.topLevelMod) {
                                for (var k = 0; k < documents.length; k++) {
                                    if (documents[k] == document) {
                                        break;
                                    }
                                }

                                if (k == documents.length) {
                                    documents = documents.concat(document);
                                }
                            }
                        }
                    }
                }
            }

            var emittingFilePath = documents.length ? TypeScript.getRootFilePath(this.emittingFileName) : null;
            for (var i = 0; i < documents.length; i++) {
                var document = documents[i];
                var declFileName;
                if (document.script.isDeclareFile) {
                    declFileName = document.fileName;
                } else {
                    declFileName = this.compiler.emitOptions.mapOutputFileName(document, TypeScript.TypeScriptCompiler.mapToDTSFileName);
                }

                declFileName = TypeScript.getRelativePathToFixedPath(emittingFilePath, declFileName, false);
                this.declFile.WriteLine('/// <reference path="' + declFileName + '" />');
            }

            this.emittedReferencePaths = true;
        };

        DeclarationEmitter.prototype.scriptCallback = function (pre, script) {
            if (pre) {
                this.emitReferencePaths(script);
                this.pushDeclarationContainer(script);
            } else {
                this.popDeclarationContainer(script);
            }
            return true;
        };

        DeclarationEmitter.prototype.defaultCallback = function (pre, ast) {
            return !ast.isStatement();
        };
        return DeclarationEmitter;
    })();
    TypeScript.DeclarationEmitter = DeclarationEmitter;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var BloomFilter = (function () {
        function BloomFilter(expectedCount) {
            var m = Math.max(1, BloomFilter.computeM(expectedCount));
            var k = Math.max(1, BloomFilter.computeK(expectedCount));
            ;

            var sizeInEvenBytes = (m + 7) & ~7;

            this.bitArray = [];
            for (var i = 0, len = sizeInEvenBytes; i < len; i++) {
                this.bitArray[i] = false;
            }
            this.hashFunctionCount = k;
        }
        BloomFilter.computeM = function (expectedCount) {
            var p = BloomFilter.falsePositiveProbability;
            var n = expectedCount;

            var numerator = n * Math.log(p);
            var denominator = Math.log(1.0 / Math.pow(2.0, Math.log(2.0)));
            return Math.ceil(numerator / denominator);
        };

        BloomFilter.computeK = function (expectedCount) {
            var n = expectedCount;
            var m = BloomFilter.computeM(expectedCount);

            var temp = Math.log(2.0) * m / n;
            return Math.round(temp);
        };

        BloomFilter.prototype.computeHash = function (key, seed) {
            return TypeScript.Hash.computeMurmur2StringHashCode(key, seed);
        };

        BloomFilter.prototype.addKeys = function (keys) {
            for (var name in keys) {
                if (keys[name]) {
                    this.add(name);
                }
            }
        };

        BloomFilter.prototype.add = function (value) {
            for (var i = 0; i < this.hashFunctionCount; i++) {
                var hash = this.computeHash(value, i);
                hash = hash % this.bitArray.length;
                this.bitArray[Math.abs(hash)] = true;
            }
        };

        BloomFilter.prototype.probablyContains = function (value) {
            for (var i = 0; i < this.hashFunctionCount; i++) {
                var hash = this.computeHash(value, i);
                hash = hash % this.bitArray.length;
                if (!this.bitArray[Math.abs(hash)]) {
                    return false;
                }
            }

            return true;
        };

        BloomFilter.prototype.isEquivalent = function (filter) {
            return BloomFilter.isEquivalent(this.bitArray, filter.bitArray) && this.hashFunctionCount == filter.hashFunctionCount;
        };

        BloomFilter.isEquivalent = function (array1, array2) {
            if (array1.length != array2.length) {
                return false;
            }

            for (var i = 0; i < array1.length; i++) {
                if (array1[i] != array2[i]) {
                    return false;
                }
            }

            return true;
        };
        BloomFilter.falsePositiveProbability = 0.0001;
        return BloomFilter;
    })();
    TypeScript.BloomFilter = BloomFilter;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var IdentifierWalker = (function (_super) {
        __extends(IdentifierWalker, _super);
        function IdentifierWalker(list) {
            _super.call(this);
            this.list = list;
        }
        IdentifierWalker.prototype.visitToken = function (token) {
            this.list[token.text()] = true;
        };
        return IdentifierWalker;
    })(TypeScript.SyntaxWalker);
    TypeScript.IdentifierWalker = IdentifierWalker;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var DataMap = (function () {
        function DataMap() {
            this.map = {};
        }
        DataMap.prototype.link = function (id, data) {
            this.map[id] = data;
        };

        DataMap.prototype.unlink = function (id) {
            this.map[id] = undefined;
        };

        DataMap.prototype.read = function (id) {
            return this.map[id];
        };
        return DataMap;
    })();
    TypeScript.DataMap = DataMap;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (PullElementFlags) {
        PullElementFlags[PullElementFlags["None"] = 0] = "None";
        PullElementFlags[PullElementFlags["Exported"] = 1] = "Exported";
        PullElementFlags[PullElementFlags["Private"] = 1 << 1] = "Private";
        PullElementFlags[PullElementFlags["Public"] = 1 << 2] = "Public";
        PullElementFlags[PullElementFlags["Ambient"] = 1 << 3] = "Ambient";
        PullElementFlags[PullElementFlags["Static"] = 1 << 4] = "Static";
        PullElementFlags[PullElementFlags["GetAccessor"] = 1 << 5] = "GetAccessor";
        PullElementFlags[PullElementFlags["SetAccessor"] = 1 << 6] = "SetAccessor";
        PullElementFlags[PullElementFlags["Optional"] = 1 << 7] = "Optional";
        PullElementFlags[PullElementFlags["Call"] = 1 << 8] = "Call";
        PullElementFlags[PullElementFlags["Constructor"] = 1 << 9] = "Constructor";
        PullElementFlags[PullElementFlags["Index"] = 1 << 10] = "Index";
        PullElementFlags[PullElementFlags["Signature"] = 1 << 11] = "Signature";
        PullElementFlags[PullElementFlags["Enum"] = 1 << 12] = "Enum";
        PullElementFlags[PullElementFlags["FatArrow"] = 1 << 13] = "FatArrow";

        PullElementFlags[PullElementFlags["ClassConstructorVariable"] = 1 << 14] = "ClassConstructorVariable";
        PullElementFlags[PullElementFlags["InitializedModule"] = 1 << 15] = "InitializedModule";
        PullElementFlags[PullElementFlags["InitializedDynamicModule"] = 1 << 16] = "InitializedDynamicModule";
        PullElementFlags[PullElementFlags["InitializedEnum"] = 1 << 17] = "InitializedEnum";

        PullElementFlags[PullElementFlags["MustCaptureThis"] = 1 << 18] = "MustCaptureThis";
        PullElementFlags[PullElementFlags["Constant"] = 1 << 19] = "Constant";

        PullElementFlags[PullElementFlags["ExpressionElement"] = 1 << 20] = "ExpressionElement";

        PullElementFlags[PullElementFlags["DeclaredInAWithBlock"] = 1 << 21] = "DeclaredInAWithBlock";

        PullElementFlags[PullElementFlags["HasReturnStatement"] = 1 << 22] = "HasReturnStatement";

        PullElementFlags[PullElementFlags["PropertyParameter"] = 1 << 23] = "PropertyParameter";

        PullElementFlags[PullElementFlags["IsAnnotatedWithAny"] = 1 << 24] = "IsAnnotatedWithAny";

        PullElementFlags[PullElementFlags["ImplicitVariable"] = PullElementFlags.ClassConstructorVariable | PullElementFlags.InitializedModule | PullElementFlags.InitializedDynamicModule | PullElementFlags.InitializedEnum] = "ImplicitVariable";
        PullElementFlags[PullElementFlags["SomeInitializedModule"] = PullElementFlags.InitializedModule | PullElementFlags.InitializedDynamicModule | PullElementFlags.InitializedEnum] = "SomeInitializedModule";
    })(TypeScript.PullElementFlags || (TypeScript.PullElementFlags = {}));
    var PullElementFlags = TypeScript.PullElementFlags;

    (function (PullElementKind) {
        PullElementKind[PullElementKind["None"] = 0] = "None";
        PullElementKind[PullElementKind["Global"] = 0] = "Global";

        PullElementKind[PullElementKind["Script"] = 1] = "Script";
        PullElementKind[PullElementKind["Primitive"] = 1 << 1] = "Primitive";

        PullElementKind[PullElementKind["Container"] = 1 << 2] = "Container";
        PullElementKind[PullElementKind["Class"] = 1 << 3] = "Class";
        PullElementKind[PullElementKind["Interface"] = 1 << 4] = "Interface";
        PullElementKind[PullElementKind["DynamicModule"] = 1 << 5] = "DynamicModule";
        PullElementKind[PullElementKind["Enum"] = 1 << 6] = "Enum";
        PullElementKind[PullElementKind["Array"] = 1 << 7] = "Array";
        PullElementKind[PullElementKind["TypeAlias"] = 1 << 8] = "TypeAlias";
        PullElementKind[PullElementKind["ObjectLiteral"] = 1 << 9] = "ObjectLiteral";

        PullElementKind[PullElementKind["Variable"] = 1 << 10] = "Variable";
        PullElementKind[PullElementKind["Parameter"] = 1 << 11] = "Parameter";
        PullElementKind[PullElementKind["Property"] = 1 << 12] = "Property";
        PullElementKind[PullElementKind["TypeParameter"] = 1 << 13] = "TypeParameter";

        PullElementKind[PullElementKind["Function"] = 1 << 14] = "Function";
        PullElementKind[PullElementKind["ConstructorMethod"] = 1 << 15] = "ConstructorMethod";
        PullElementKind[PullElementKind["Method"] = 1 << 16] = "Method";
        PullElementKind[PullElementKind["FunctionExpression"] = 1 << 17] = "FunctionExpression";

        PullElementKind[PullElementKind["GetAccessor"] = 1 << 18] = "GetAccessor";
        PullElementKind[PullElementKind["SetAccessor"] = 1 << 19] = "SetAccessor";

        PullElementKind[PullElementKind["CallSignature"] = 1 << 20] = "CallSignature";
        PullElementKind[PullElementKind["ConstructSignature"] = 1 << 21] = "ConstructSignature";
        PullElementKind[PullElementKind["IndexSignature"] = 1 << 22] = "IndexSignature";

        PullElementKind[PullElementKind["ObjectType"] = 1 << 23] = "ObjectType";
        PullElementKind[PullElementKind["FunctionType"] = 1 << 24] = "FunctionType";
        PullElementKind[PullElementKind["ConstructorType"] = 1 << 25] = "ConstructorType";

        PullElementKind[PullElementKind["EnumMember"] = 1 << 26] = "EnumMember";
        PullElementKind[PullElementKind["ErrorType"] = 1 << 27] = "ErrorType";

        PullElementKind[PullElementKind["Expression"] = 1 << 28] = "Expression";

        PullElementKind[PullElementKind["WithBlock"] = 1 << 29] = "WithBlock";
        PullElementKind[PullElementKind["CatchBlock"] = 1 << 30] = "CatchBlock";

        PullElementKind[PullElementKind["All"] = PullElementKind.Script | PullElementKind.Global | PullElementKind.Primitive | PullElementKind.Container | PullElementKind.Class | PullElementKind.Interface | PullElementKind.DynamicModule | PullElementKind.Enum | PullElementKind.Array | PullElementKind.TypeAlias | PullElementKind.ObjectLiteral | PullElementKind.Variable | PullElementKind.Parameter | PullElementKind.Property | PullElementKind.TypeParameter | PullElementKind.Function | PullElementKind.ConstructorMethod | PullElementKind.Method | PullElementKind.FunctionExpression | PullElementKind.GetAccessor | PullElementKind.SetAccessor | PullElementKind.CallSignature | PullElementKind.ConstructSignature | PullElementKind.IndexSignature | PullElementKind.ObjectType | PullElementKind.FunctionType | PullElementKind.ConstructorType | PullElementKind.EnumMember | PullElementKind.ErrorType | PullElementKind.Expression | PullElementKind.WithBlock | PullElementKind.CatchBlock] = "All";

        PullElementKind[PullElementKind["SomeFunction"] = PullElementKind.Function | PullElementKind.ConstructorMethod | PullElementKind.Method | PullElementKind.FunctionExpression | PullElementKind.GetAccessor | PullElementKind.SetAccessor | PullElementKind.CallSignature | PullElementKind.ConstructSignature | PullElementKind.IndexSignature] = "SomeFunction";

        PullElementKind[PullElementKind["SomeValue"] = PullElementKind.Variable | PullElementKind.Parameter | PullElementKind.Property | PullElementKind.EnumMember | PullElementKind.SomeFunction] = "SomeValue";

        PullElementKind[PullElementKind["SomeType"] = PullElementKind.Script | PullElementKind.Global | PullElementKind.Primitive | PullElementKind.Class | PullElementKind.Interface | PullElementKind.Enum | PullElementKind.Array | PullElementKind.ObjectType | PullElementKind.FunctionType | PullElementKind.ConstructorType | PullElementKind.TypeParameter | PullElementKind.ErrorType] = "SomeType";

        PullElementKind[PullElementKind["AcceptableAlias"] = PullElementKind.Variable | PullElementKind.SomeFunction | PullElementKind.Class | PullElementKind.Interface | PullElementKind.Enum | PullElementKind.Container | PullElementKind.ObjectType | PullElementKind.FunctionType | PullElementKind.ConstructorType] = "AcceptableAlias";

        PullElementKind[PullElementKind["SomeContainer"] = PullElementKind.Container | PullElementKind.DynamicModule | PullElementKind.TypeAlias] = "SomeContainer";

        PullElementKind[PullElementKind["SomeBlock"] = PullElementKind.WithBlock | PullElementKind.CatchBlock] = "SomeBlock";

        PullElementKind[PullElementKind["SomeSignature"] = PullElementKind.CallSignature | PullElementKind.ConstructSignature | PullElementKind.IndexSignature] = "SomeSignature";

        PullElementKind[PullElementKind["SomeAccessor"] = PullElementKind.GetAccessor | PullElementKind.SetAccessor] = "SomeAccessor";

        PullElementKind[PullElementKind["SomeTypeReference"] = PullElementKind.Interface | PullElementKind.ObjectType | PullElementKind.FunctionType | PullElementKind.ConstructorType] = "SomeTypeReference";

        PullElementKind[PullElementKind["SomeLHS"] = PullElementKind.Variable | PullElementKind.Property | PullElementKind.Parameter | PullElementKind.SetAccessor | PullElementKind.Method] = "SomeLHS";

        PullElementKind[PullElementKind["InterfaceTypeExtension"] = PullElementKind.Interface | PullElementKind.Class | PullElementKind.Enum] = "InterfaceTypeExtension";
        PullElementKind[PullElementKind["ClassTypeExtension"] = PullElementKind.Interface | PullElementKind.Class] = "ClassTypeExtension";
        PullElementKind[PullElementKind["EnumTypeExtension"] = PullElementKind.Interface | PullElementKind.Enum] = "EnumTypeExtension";
    })(TypeScript.PullElementKind || (TypeScript.PullElementKind = {}));
    var PullElementKind = TypeScript.PullElementKind;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.pullDeclID = 0;
    TypeScript.lastBoundPullDeclId = 0;
    var sentinelEmptyPullDeclArray = [];

    var PullDecl = (function () {
        function PullDecl(declName, displayName, kind, declFlags, span, scriptName) {
            this.symbol = null;
            this.declGroups = new TypeScript.BlockIntrinsics();
            this.signatureSymbol = null;
            this.specializingSignatureSymbol = null;
            this.childDecls = null;
            this.typeParameters = null;
            this.childDeclTypeCache = new TypeScript.BlockIntrinsics();
            this.childDeclValueCache = new TypeScript.BlockIntrinsics();
            this.childDeclNamespaceCache = new TypeScript.BlockIntrinsics();
            this.childDeclTypeParameterCache = new TypeScript.BlockIntrinsics();
            this.declID = TypeScript.pullDeclID++;
            this.declIDString = null;
            this.flags = 0 /* None */;
            this.diagnostics = null;
            this.parentDecl = null;
            this._parentPath = null;
            this._isBound = false;
            this.synthesizedValDecl = null;
            this.hashCode = -1;
            this.ast = null;
            this.name = declName;
            this.kind = kind;
            this.flags = declFlags;
            this.span = span;
            this.scriptName = scriptName;

            if (displayName !== this.name) {
                this.declDisplayName = displayName;
            }

            this.hashCode = this.declID ^ this.kind;
            this.declIDString = this.declID.toString();
        }
        PullDecl.prototype.getDisplayName = function () {
            return this.declDisplayName === undefined ? this.name : this.declDisplayName;
        };

        PullDecl.prototype.setSymbol = function (symbol) {
            this.symbol = symbol;
        };

        PullDecl.prototype.ensureSymbolIsBound = function (bindSignatureSymbol) {
            if (typeof bindSignatureSymbol === "undefined") { bindSignatureSymbol = false; }
            if (!((bindSignatureSymbol && this.signatureSymbol) || this.symbol) && !this._isBound && this.kind != 1 /* Script */) {
                var prevUnit = TypeScript.globalBinder.semanticInfo;
                TypeScript.globalBinder.setUnit(this.scriptName);
                TypeScript.globalBinder.bindDeclToPullSymbol(this);
                if (prevUnit) {
                    TypeScript.globalBinder.setUnit(prevUnit.getPath());
                }
            }
        };

        PullDecl.prototype.getSymbol = function () {
            if (this.kind == 1 /* Script */) {
                return null;
            }

            this.ensureSymbolIsBound();

            return this.symbol;
        };

        PullDecl.prototype.hasSymbol = function () {
            return this.symbol != null;
        };

        PullDecl.prototype.setSignatureSymbol = function (signature) {
            this.signatureSymbol = signature;
        };
        PullDecl.prototype.getSignatureSymbol = function () {
            this.ensureSymbolIsBound(true);

            return this.signatureSymbol;
        };

        PullDecl.prototype.hasSignature = function () {
            return this.signatureSymbol != null;
        };

        PullDecl.prototype.setSpecializingSignatureSymbol = function (signature) {
            this.specializingSignatureSymbol = signature;
        };
        PullDecl.prototype.getSpecializingSignatureSymbol = function () {
            if (this.specializingSignatureSymbol) {
                return this.specializingSignatureSymbol;
            }

            return this.signatureSymbol;
        };

        PullDecl.prototype.setFlags = function (flags) {
            this.flags = flags;
        };
        PullDecl.prototype.setFlag = function (flags) {
            this.flags |= flags;
        };

        PullDecl.prototype.getSpan = function () {
            return this.span;
        };
        PullDecl.prototype.setSpan = function (span) {
            this.span = span;
        };

        PullDecl.prototype.getScriptName = function () {
            return this.scriptName;
        };

        PullDecl.prototype.setValueDecl = function (valDecl) {
            this.synthesizedValDecl = valDecl;
        };
        PullDecl.prototype.getValueDecl = function () {
            return this.synthesizedValDecl;
        };

        PullDecl.prototype.isEqual = function (other) {
            return (this.name === other.name) && (this.kind === other.kind) && (this.flags === other.flags) && (this.scriptName === other.scriptName) && (this.span.start() === other.span.start()) && (this.span.end() === other.span.end());
        };

        PullDecl.prototype.getParentDecl = function () {
            return this.parentDecl;
        };

        PullDecl.prototype.setParentDecl = function (parentDecl) {
            this.parentDecl = parentDecl;
        };

        PullDecl.prototype.addDiagnostic = function (diagnostic) {
            if (diagnostic) {
                if (!this.diagnostics) {
                    this.diagnostics = [];
                }

                this.diagnostics[this.diagnostics.length] = diagnostic;
            }
        };

        PullDecl.prototype.getDiagnostics = function () {
            return this.diagnostics ? this.diagnostics : sentinelEmptyPullDeclArray;
        };

        PullDecl.prototype.resetErrors = function () {
            this.diagnostics = null;
        };

        PullDecl.prototype.getChildDeclCache = function (declKind) {
            return declKind === 8192 /* TypeParameter */ ? this.childDeclTypeParameterCache : TypeScript.hasFlag(declKind, TypeScript.PullElementKind.SomeContainer) ? this.childDeclNamespaceCache : TypeScript.hasFlag(declKind, TypeScript.PullElementKind.SomeType) ? this.childDeclTypeCache : this.childDeclValueCache;
        };

        PullDecl.prototype.addChildDecl = function (childDecl) {
            if (childDecl.kind === 8192 /* TypeParameter */) {
                if (!this.typeParameters) {
                    this.typeParameters = [];
                }
                this.typeParameters[this.typeParameters.length] = childDecl;
            } else {
                if (!this.childDecls) {
                    this.childDecls = [];
                }
                this.childDecls[this.childDecls.length] = childDecl;
            }

            var declName = childDecl.name;
            var cache = this.getChildDeclCache(childDecl.kind);
            var childrenOfName = cache[declName];
            if (!childrenOfName) {
                childrenOfName = [];
            }

            childrenOfName.push(childDecl);
            cache[declName] = childrenOfName;
        };

        PullDecl.prototype.searchChildDecls = function (declName, searchKind) {
            var cacheVal = null;

            if (searchKind & TypeScript.PullElementKind.SomeType) {
                cacheVal = this.childDeclTypeCache[declName];
            } else if (searchKind & TypeScript.PullElementKind.SomeContainer) {
                cacheVal = this.childDeclNamespaceCache[declName];
            } else {
                cacheVal = this.childDeclValueCache[declName];
            }

            if (cacheVal) {
                return cacheVal;
            } else {
                if (searchKind & TypeScript.PullElementKind.SomeType) {
                    cacheVal = this.childDeclTypeParameterCache[declName];

                    if (cacheVal) {
                        return cacheVal;
                    }
                }

                return sentinelEmptyPullDeclArray;
            }
        };

        PullDecl.prototype.getChildDecls = function () {
            return this.childDecls ? this.childDecls : sentinelEmptyPullDeclArray;
        };
        PullDecl.prototype.getTypeParameters = function () {
            return this.typeParameters ? this.typeParameters : sentinelEmptyPullDeclArray;
        };

        PullDecl.prototype.addVariableDeclToGroup = function (decl) {
            var declGroup = this.declGroups[decl.name];
            if (declGroup) {
                declGroup.addDecl(decl);
            } else {
                declGroup = new PullDeclGroup(decl.name);
                declGroup.addDecl(decl);
                this.declGroups[decl.name] = declGroup;
            }
        };

        PullDecl.prototype.getVariableDeclGroups = function () {
            var declGroups = null;

            for (var declName in this.declGroups) {
                if (this.declGroups[declName]) {
                    if (!declGroups) {
                        declGroups = [];
                    }

                    declGroups[declGroups.length] = this.declGroups[declName].getDecls();
                }
            }

            return declGroups ? declGroups : sentinelEmptyPullDeclArray;
        };

        PullDecl.prototype.getParentPath = function () {
            return this._parentPath;
        };

        PullDecl.prototype.setParentPath = function (path) {
            this._parentPath = path;
        };

        PullDecl.prototype.setIsBound = function (isBinding) {
            this._isBound = isBinding;
        };

        PullDecl.prototype.isBound = function () {
            return this._isBound;
        };
        return PullDecl;
    })();
    TypeScript.PullDecl = PullDecl;

    var PullFunctionExpressionDecl = (function (_super) {
        __extends(PullFunctionExpressionDecl, _super);
        function PullFunctionExpressionDecl(expressionName, declFlags, span, scriptName) {
            _super.call(this, "", "", 131072 /* FunctionExpression */, declFlags, span, scriptName);
            this.functionExpressionName = expressionName;
        }
        PullFunctionExpressionDecl.prototype.getFunctionExpressionName = function () {
            return this.functionExpressionName;
        };
        return PullFunctionExpressionDecl;
    })(PullDecl);
    TypeScript.PullFunctionExpressionDecl = PullFunctionExpressionDecl;

    var PullDeclGroup = (function () {
        function PullDeclGroup(name) {
            this.name = name;
            this._decls = [];
        }
        PullDeclGroup.prototype.addDecl = function (decl) {
            if (decl.name === this.name) {
                this._decls[this._decls.length] = decl;
            }
        };

        PullDeclGroup.prototype.getDecls = function () {
            return this._decls;
        };
        return PullDeclGroup;
    })();
    TypeScript.PullDeclGroup = PullDeclGroup;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.pullSymbolID = 0;
    TypeScript.globalTyvarID = 0;
    TypeScript.sentinelEmptyArray = [];

    var PullSymbol = (function () {
        function PullSymbol(name, declKind) {
            this.pullSymbolID = TypeScript.pullSymbolID++;
            this.pullSymbolIDString = null;
            this.cachedPathIDs = {};
            this._container = null;
            this.type = null;
            this._declarations = null;
            this.isResolved = false;
            this.isOptional = false;
            this.inResolution = false;
            this.isSynthesized = false;
            this.isVarArg = false;
            this.isSpecialized = false;
            this.isBeingSpecialized = false;
            this.rootSymbol = null;
            this._parentAccessorSymbol = null;
            this._enclosingSignature = null;
            this.docComments = null;
            this.isPrinting = false;
            this.ast = null;
            this.name = name;
            this.kind = declKind;
            this.pullSymbolIDString = this.pullSymbolID.toString();
        }
        PullSymbol.prototype.isType = function () {
            return (this.kind & TypeScript.PullElementKind.SomeType) != 0;
        };

        PullSymbol.prototype.isSignature = function () {
            return (this.kind & TypeScript.PullElementKind.SomeSignature) != 0;
        };

        PullSymbol.prototype.isArray = function () {
            return (this.kind & 128 /* Array */) != 0;
        };

        PullSymbol.prototype.isPrimitive = function () {
            return this.kind === 2 /* Primitive */;
        };

        PullSymbol.prototype.isAccessor = function () {
            return false;
        };

        PullSymbol.prototype.isError = function () {
            return false;
        };

        PullSymbol.prototype.isInterface = function () {
            return this.kind === 16 /* Interface */;
        };

        PullSymbol.prototype.isMethod = function () {
            return this.kind === 65536 /* Method */;
        };

        PullSymbol.prototype.isProperty = function () {
            return this.kind === 4096 /* Property */;
        };

        PullSymbol.prototype.isAlias = function () {
            return false;
        };
        PullSymbol.prototype.isContainer = function () {
            return false;
        };

        PullSymbol.prototype.setAccessorSymbol = function (accessor) {
            this._parentAccessorSymbol = accessor;
        };

        PullSymbol.prototype.getAccessorySymbol = function () {
            return this._parentAccessorSymbol;
        };

        PullSymbol.prototype.findAliasedType = function (decls) {
            for (var i = 0; i < decls.length; i++) {
                var childDecls = decls[i].getChildDecls();
                for (var j = 0; j < childDecls.length; j++) {
                    if (childDecls[j].kind === 256 /* TypeAlias */) {
                        var symbol = childDecls[j].getSymbol();
                        if (PullContainerTypeSymbol.usedAsSymbol(symbol, this)) {
                            return symbol;
                        }
                    }
                }
            }

            return null;
        };

        PullSymbol.prototype.getAliasedSymbol = function (scopeSymbol) {
            if (!scopeSymbol) {
                return null;
            }

            var scopePath = scopeSymbol.pathToRoot();
            if (scopePath.length && scopePath[scopePath.length - 1].kind === 32 /* DynamicModule */) {
                var decls = scopePath[scopePath.length - 1].getDeclarations();
                var symbol = this.findAliasedType(decls);
                return symbol;
            }

            return null;
        };

        PullSymbol.prototype.getScopedDynamicModuleAlias = function (scopeSymbol) {
            var aliasSymbol = this.getAliasedSymbol(scopeSymbol);

            if (aliasSymbol) {
                if (aliasSymbol.assignedValue) {
                    return null;
                }

                if (aliasSymbol.assignedType && aliasSymbol.assignedType != aliasSymbol.assignedContainer) {
                    return null;
                }

                if (aliasSymbol.assignedContainer.kind != 32 /* DynamicModule */) {
                    return null;
                }
            }
            return aliasSymbol;
        };

        PullSymbol.prototype.getName = function (scopeSymbol, useConstraintInName) {
            var symbol = this.getScopedDynamicModuleAlias(scopeSymbol);
            if (symbol) {
                return symbol.getName();
            }

            return this.name;
        };

        PullSymbol.prototype.getDisplayName = function (scopeSymbol, useConstraintInName) {
            var symbol = this.getScopedDynamicModuleAlias(scopeSymbol);
            if (symbol) {
                return symbol.getDisplayName();
            }

            var decls = this.getDeclarations();
            return decls.length ? this.getDeclarations()[0].getDisplayName() : this.name;
        };

        PullSymbol.prototype.setIsSpecialized = function () {
            this.isSpecialized = true;
            this.isBeingSpecialized = false;
        };
        PullSymbol.prototype.getIsSpecialized = function () {
            return this.isSpecialized;
        };
        PullSymbol.prototype.currentlyBeingSpecialized = function () {
            return this.isBeingSpecialized;
        };
        PullSymbol.prototype.setIsBeingSpecialized = function () {
            this.isBeingSpecialized = true;
        };
        PullSymbol.prototype.setValueIsBeingSpecialized = function (val) {
            this.isBeingSpecialized = val;
        };

        PullSymbol.prototype.getRootSymbol = function () {
            if (!this.rootSymbol) {
                return this;
            }
            return this.rootSymbol;
        };
        PullSymbol.prototype.setRootSymbol = function (symbol) {
            this.rootSymbol = symbol;
        };

        PullSymbol.prototype.setIsSynthesized = function (value) {
            if (typeof value === "undefined") { value = true; }
            this.isSynthesized = value;
        };
        PullSymbol.prototype.getIsSynthesized = function () {
            return this.isSynthesized;
        };

        PullSymbol.prototype.setEnclosingSignature = function (signature) {
            this._enclosingSignature = signature;
        };

        PullSymbol.prototype.getEnclosingSignature = function () {
            return this._enclosingSignature;
        };

        PullSymbol.prototype.addCacheID = function (cacheID) {
            if (!this.cachedPathIDs[cacheID]) {
                this.cachedPathIDs[cacheID] = true;
            }
        };

        PullSymbol.prototype.invalidateCachedIDs = function (cache) {
            for (var id in this.cachedPathIDs) {
                if (cache[id]) {
                    cache[id] = undefined;
                }
            }
        };

        PullSymbol.prototype.addDeclaration = function (decl) {
            TypeScript.Debug.assert(!!decl);

            if (this.rootSymbol) {
                return;
            }

            if (!this._declarations) {
                this._declarations = [decl];
            } else {
                this._declarations[this._declarations.length] = decl;
            }
        };

        PullSymbol.prototype.getDeclarations = function () {
            if (this.rootSymbol) {
                return this.rootSymbol.getDeclarations();
            }

            if (!this._declarations) {
                this._declarations = [];
            }

            return this._declarations;
        };

        PullSymbol.prototype.setContainer = function (containerSymbol) {
            if (this.rootSymbol) {
                return;
            }

            this._container = containerSymbol;
        };

        PullSymbol.prototype.getContainer = function () {
            if (this.rootSymbol) {
                return this.rootSymbol.getContainer();
            }

            return this._container;
        };

        PullSymbol.prototype.setResolved = function () {
            this.isResolved = true;
            this.inResolution = false;
        };

        PullSymbol.prototype.startResolving = function () {
            this.inResolution = true;
        };

        PullSymbol.prototype.setUnresolved = function () {
            this.isResolved = false;
            this.inResolution = false;
        };

        PullSymbol.prototype.invalidate = function () {
            this.isResolved = false;

            var declarations = this.getDeclarations();
        };

        PullSymbol.prototype.hasFlag = function (flag) {
            var declarations = this.getDeclarations();
            for (var i = 0, n = declarations.length; i < n; i++) {
                if ((declarations[i].flags & flag) !== 0 /* None */) {
                    return true;
                }
            }
            return false;
        };

        PullSymbol.prototype.allDeclsHaveFlag = function (flag) {
            var declarations = this.getDeclarations();
            for (var i = 0, n = declarations.length; i < n; i++) {
                if (!((declarations[i].flags & flag) !== 0 /* None */)) {
                    return false;
                }
            }
            return true;
        };

        PullSymbol.prototype.pathToRoot = function () {
            var path = [];
            var node = this;
            while (node) {
                if (node.isType()) {
                    var associatedContainerSymbol = (node).getAssociatedContainerType();
                    if (associatedContainerSymbol) {
                        node = associatedContainerSymbol;
                    }
                }
                path[path.length] = node;
                var nodeKind = node.kind;
                if (nodeKind == 2048 /* Parameter */) {
                    break;
                } else {
                    node = node.getContainer();
                }
            }
            return path;
        };

        PullSymbol.prototype.findCommonAncestorPath = function (b) {
            var aPath = this.pathToRoot();
            if (aPath.length === 1) {
                return aPath;
            }

            var bPath;
            if (b) {
                bPath = b.pathToRoot();
            } else {
                return aPath;
            }

            var commonNodeIndex = -1;
            for (var i = 0, aLen = aPath.length; i < aLen; i++) {
                var aNode = aPath[i];
                for (var j = 0, bLen = bPath.length; j < bLen; j++) {
                    var bNode = bPath[j];
                    if (aNode === bNode) {
                        var aDecl = null;
                        if (i > 0) {
                            var decls = aPath[i - 1].getDeclarations();
                            if (decls.length) {
                                aDecl = decls[0].getParentDecl();
                            }
                        }
                        var bDecl = null;
                        if (j > 0) {
                            var decls = bPath[j - 1].getDeclarations();
                            if (decls.length) {
                                bDecl = decls[0].getParentDecl();
                            }
                        }
                        if (!aDecl || !bDecl || aDecl == bDecl) {
                            commonNodeIndex = i;
                            break;
                        }
                    }
                }
                if (commonNodeIndex >= 0) {
                    break;
                }
            }

            if (commonNodeIndex >= 0) {
                return aPath.slice(0, commonNodeIndex);
            } else {
                return aPath;
            }
        };

        PullSymbol.prototype.toString = function (scopeSymbol, useConstraintInName) {
            var str = this.getNameAndTypeName(scopeSymbol);
            return str;
        };

        PullSymbol.prototype.getNamePartForFullName = function () {
            return this.getDisplayName(null, true);
        };

        PullSymbol.prototype.fullName = function (scopeSymbol) {
            var path = this.pathToRoot();
            var fullName = "";
            var aliasedSymbol = this.getScopedDynamicModuleAlias(scopeSymbol);
            if (aliasedSymbol) {
                return aliasedSymbol.fullName(scopeSymbol);
            }

            for (var i = 1; i < path.length; i++) {
                aliasedSymbol = path[i].getScopedDynamicModuleAlias(scopeSymbol);
                if (aliasedSymbol) {
                    fullName = aliasedSymbol.fullName(scopeSymbol) + "." + fullName;
                    break;
                } else {
                    var scopedName = path[i].getNamePartForFullName();
                    if (path[i].kind == 32 /* DynamicModule */ && !TypeScript.isQuoted(scopedName)) {
                        break;
                    }

                    if (scopedName === "") {
                        break;
                    }

                    fullName = scopedName + "." + fullName;
                }
            }

            fullName = fullName + this.getNamePartForFullName();
            return fullName;
        };

        PullSymbol.prototype.getScopedName = function (scopeSymbol, useConstraintInName) {
            var path = this.findCommonAncestorPath(scopeSymbol);
            var fullName = "";
            var aliasedSymbol = this.getScopedDynamicModuleAlias(scopeSymbol);
            if (aliasedSymbol) {
                return aliasedSymbol.getScopedName(scopeSymbol);
            }

            for (var i = 1; i < path.length; i++) {
                var kind = path[i].kind;
                if (kind === 4 /* Container */ || kind === 32 /* DynamicModule */) {
                    aliasedSymbol = path[i].getScopedDynamicModuleAlias(scopeSymbol);
                    if (aliasedSymbol) {
                        fullName = aliasedSymbol.getScopedName(scopeSymbol) + "." + fullName;
                        break;
                    } else if (kind === 4 /* Container */) {
                        fullName = path[i].getDisplayName() + "." + fullName;
                    } else {
                        var displayName = path[i].getDisplayName();
                        if (TypeScript.isQuoted(displayName)) {
                            fullName = displayName + "." + fullName;
                        }
                        break;
                    }
                } else {
                    break;
                }
            }
            fullName = fullName + this.getDisplayName(scopeSymbol, useConstraintInName);
            return fullName;
        };

        PullSymbol.prototype.getScopedNameEx = function (scopeSymbol, useConstraintInName, getPrettyTypeName, getTypeParamMarkerInfo) {
            var name = this.getScopedName(scopeSymbol, useConstraintInName);
            return TypeScript.MemberName.create(name);
        };

        PullSymbol.prototype.getTypeName = function (scopeSymbol, getPrettyTypeName) {
            var memberName = this.getTypeNameEx(scopeSymbol, getPrettyTypeName);
            return memberName.toString();
        };

        PullSymbol.prototype.getTypeNameEx = function (scopeSymbol, getPrettyTypeName) {
            var type = this.type;
            if (type) {
                var memberName = getPrettyTypeName ? this.getTypeNameForFunctionSignature("", scopeSymbol, getPrettyTypeName) : null;
                if (!memberName) {
                    memberName = type.getScopedNameEx(scopeSymbol, true, getPrettyTypeName);
                }

                return memberName;
            }
            return TypeScript.MemberName.create("");
        };

        PullSymbol.prototype.getTypeNameForFunctionSignature = function (prefix, scopeSymbol, getPrettyTypeName) {
            var type = this.type;
            if (type && !type.isNamedTypeSymbol() && this.kind != 4096 /* Property */ && this.kind != 1024 /* Variable */ && this.kind != 2048 /* Parameter */) {
                var signatures = type.getCallSignatures();
                if (signatures.length == 1 || (getPrettyTypeName && signatures.length)) {
                    var typeName = new TypeScript.MemberNameArray();
                    var signatureName = PullSignatureSymbol.getSignaturesTypeNameEx(signatures, prefix, false, false, scopeSymbol, getPrettyTypeName);
                    typeName.addAll(signatureName);
                    return typeName;
                }
            }

            return null;
        };

        PullSymbol.prototype.getNameAndTypeName = function (scopeSymbol) {
            var nameAndTypeName = this.getNameAndTypeNameEx(scopeSymbol);
            return nameAndTypeName.toString();
        };

        PullSymbol.prototype.getNameAndTypeNameEx = function (scopeSymbol) {
            var type = this.type;
            var nameStr = this.getDisplayName(scopeSymbol);
            if (type) {
                nameStr = nameStr + (this.isOptional ? "?" : "");
                var memberName = this.getTypeNameForFunctionSignature(nameStr, scopeSymbol);
                if (!memberName) {
                    var typeNameEx = type.getScopedNameEx(scopeSymbol);
                    memberName = TypeScript.MemberName.create(typeNameEx, nameStr + ": ", "");
                }
                return memberName;
            }
            return TypeScript.MemberName.create(nameStr);
        };

        PullSymbol.getTypeParameterString = function (typars, scopeSymbol, useContraintInName) {
            return PullSymbol.getTypeParameterStringEx(typars, scopeSymbol, undefined, useContraintInName).toString();
        };

        PullSymbol.getTypeParameterStringEx = function (typeParameters, scopeSymbol, getTypeParamMarkerInfo, useContraintInName) {
            var builder = new TypeScript.MemberNameArray();
            builder.prefix = "";

            if (typeParameters && typeParameters.length) {
                builder.add(TypeScript.MemberName.create("<"));

                for (var i = 0; i < typeParameters.length; i++) {
                    if (i) {
                        builder.add(TypeScript.MemberName.create(", "));
                    }

                    if (getTypeParamMarkerInfo) {
                        builder.add(new TypeScript.MemberName());
                    }

                    builder.add(typeParameters[i].getScopedNameEx(scopeSymbol, useContraintInName));

                    if (getTypeParamMarkerInfo) {
                        builder.add(new TypeScript.MemberName());
                    }
                }

                builder.add(TypeScript.MemberName.create(">"));
            }

            return builder;
        };

        PullSymbol.getIsExternallyVisible = function (symbol, fromIsExternallyVisibleSymbol, inIsExternallyVisibleSymbols) {
            if (inIsExternallyVisibleSymbols) {
                for (var i = 0; i < inIsExternallyVisibleSymbols.length; i++) {
                    if (inIsExternallyVisibleSymbols[i] === symbol) {
                        return true;
                    }
                }
            } else {
                inIsExternallyVisibleSymbols = [];
            }

            if (fromIsExternallyVisibleSymbol === symbol) {
                return true;
            }
            inIsExternallyVisibleSymbols = inIsExternallyVisibleSymbols.concat(fromIsExternallyVisibleSymbol);

            return symbol.isExternallyVisible(inIsExternallyVisibleSymbols);
        };

        PullSymbol.prototype.isExternallyVisible = function (inIsExternallyVisibleSymbols) {
            var kind = this.kind;
            if (kind === 2 /* Primitive */) {
                return true;
            }

            if (this.isType()) {
                var associatedContainerSymbol = (this).getAssociatedContainerType();
                if (associatedContainerSymbol) {
                    return PullSymbol.getIsExternallyVisible(associatedContainerSymbol, this, inIsExternallyVisibleSymbols);
                }
            }

            if (this.hasFlag(2 /* Private */)) {
                return false;
            }

            var container = this.getContainer();
            if (container === null) {
                return true;
            }

            if (container.kind == 32 /* DynamicModule */ || (container.getAssociatedContainerType() && container.getAssociatedContainerType().kind == 32 /* DynamicModule */)) {
                var containerTypeSymbol = container.kind == 32 /* DynamicModule */ ? container : container.getAssociatedContainerType();
                if (PullContainerTypeSymbol.usedAsSymbol(containerTypeSymbol, this)) {
                    return true;
                }
            }

            if (!this.hasFlag(1 /* Exported */) && kind != 4096 /* Property */ && kind != 65536 /* Method */) {
                return false;
            }

            return PullSymbol.getIsExternallyVisible(container, this, inIsExternallyVisibleSymbols);
        };
        return PullSymbol;
    })();
    TypeScript.PullSymbol = PullSymbol;

    var PullSignatureSymbol = (function (_super) {
        __extends(PullSignatureSymbol, _super);
        function PullSignatureSymbol(kind) {
            _super.call(this, "", kind);
            this.parameters = TypeScript.sentinelEmptyArray;
            this.typeParameters = null;
            this.returnType = null;
            this.functionType = null;
            this.hasOptionalParam = false;
            this.nonOptionalParamCount = 0;
            this.hasVarArgs = false;
            this.specializationCache = {};
            this.memberTypeParameterNameCache = null;
            this.hasAGenericParameter = false;
            this.stringConstantOverload = undefined;
            this.hasBeenChecked = false;
        }
        PullSignatureSymbol.prototype.isDefinition = function () {
            return false;
        };

        PullSignatureSymbol.prototype.isGeneric = function () {
            return this.hasAGenericParameter || (this.typeParameters && this.typeParameters.length != 0);
        };

        PullSignatureSymbol.prototype.addParameter = function (parameter, isOptional) {
            if (typeof isOptional === "undefined") { isOptional = false; }
            if (this.parameters == TypeScript.sentinelEmptyArray) {
                this.parameters = [];
            }

            this.parameters[this.parameters.length] = parameter;
            this.hasOptionalParam = isOptional;

            if (!parameter.getEnclosingSignature()) {
                parameter.setEnclosingSignature(this);
            }

            if (!isOptional) {
                this.nonOptionalParamCount++;
            }
        };

        PullSignatureSymbol.prototype.addSpecialization = function (signature, typeArguments) {
            if (typeArguments && typeArguments.length) {
                this.specializationCache[getIDForTypeSubstitutions(typeArguments)] = signature;
            }
        };

        PullSignatureSymbol.prototype.getSpecialization = function (typeArguments) {
            if (typeArguments) {
                var sig = this.specializationCache[getIDForTypeSubstitutions(typeArguments)];

                if (sig) {
                    return sig;
                }
            }

            return null;
        };

        PullSignatureSymbol.prototype.addTypeParameter = function (typeParameter) {
            if (!this.typeParameters) {
                this.typeParameters = [];
            }

            if (!this.memberTypeParameterNameCache) {
                this.memberTypeParameterNameCache = new TypeScript.BlockIntrinsics();
            }

            this.typeParameters[this.typeParameters.length] = typeParameter;

            this.memberTypeParameterNameCache[typeParameter.getName()] = typeParameter;
        };

        PullSignatureSymbol.prototype.getTypeParameters = function () {
            if (!this.typeParameters) {
                this.typeParameters = [];
            }

            return this.typeParameters;
        };

        PullSignatureSymbol.prototype.findTypeParameter = function (name) {
            var memberSymbol;

            if (!this.memberTypeParameterNameCache) {
                this.memberTypeParameterNameCache = new TypeScript.BlockIntrinsics();

                if (this.typeParameters) {
                    for (var i = 0; i < this.typeParameters.length; i++) {
                        this.memberTypeParameterNameCache[this.typeParameters[i].getName()] = this.typeParameters[i];
                    }
                }
            }

            memberSymbol = this.memberTypeParameterNameCache[name];

            return memberSymbol;
        };

        PullSignatureSymbol.prototype.mimicSignature = function (signature, resolver) {
            var typeParameters = signature.getTypeParameters();
            var typeParameter;

            if (typeParameters) {
                for (var i = 0; i < typeParameters.length; i++) {
                    this.addTypeParameter(typeParameters[i]);
                }
            }

            var parameters = signature.parameters;
            var parameter;

            if (parameters) {
                for (var j = 0; j < parameters.length; j++) {
                    parameter = new PullSymbol(parameters[j].name, 2048 /* Parameter */);
                    parameter.setRootSymbol(parameters[j]);

                    if (parameters[j].isOptional) {
                        parameter.isOptional = true;
                    }
                    if (parameters[j].isVarArg) {
                        parameter.isVarArg = true;
                        this.hasVarArgs = true;
                    }
                    this.addParameter(parameter);
                }
            }

            var returnType = signature.returnType;

            if (!resolver.isTypeArgumentOrWrapper(returnType)) {
                this.returnType = returnType;
            }
        };

        PullSignatureSymbol.prototype.isFixed = function () {
            if (!this.isGeneric()) {
                return true;
            }

            if (this.parameters) {
                var paramType;
                for (var i = 0; i < this.parameters.length; i++) {
                    paramType = this.parameters[i].type;

                    if (paramType && !paramType.isFixed()) {
                        return false;
                    }
                }
            }

            if (this.returnType) {
                if (!this.returnType.isFixed()) {
                    return false;
                }
            }

            return true;
        };

        PullSignatureSymbol.prototype.invalidate = function () {
            this.nonOptionalParamCount = 0;
            this.hasOptionalParam = false;
            this.hasAGenericParameter = false;
            this.stringConstantOverload = undefined;

            _super.prototype.invalidate.call(this);
        };

        PullSignatureSymbol.prototype.isStringConstantOverloadSignature = function () {
            if (this.stringConstantOverload === undefined) {
                var params = this.parameters;
                this.stringConstantOverload = false;
                for (var i = 0; i < params.length; i++) {
                    var paramType = params[i].type;
                    if (paramType && paramType.isPrimitive() && (paramType).isStringConstant()) {
                        this.stringConstantOverload = true;
                    }
                }
            }

            return this.stringConstantOverload;
        };

        PullSignatureSymbol.getSignatureTypeMemberName = function (candidateSignature, signatures, scopeSymbol) {
            var allMemberNames = new TypeScript.MemberNameArray();
            var signatureMemberName = PullSignatureSymbol.getSignaturesTypeNameEx(signatures, "", false, false, scopeSymbol, true, candidateSignature);
            allMemberNames.addAll(signatureMemberName);
            return allMemberNames;
        };

        PullSignatureSymbol.getSignaturesTypeNameEx = function (signatures, prefix, shortform, brackets, scopeSymbol, getPrettyTypeName, candidateSignature) {
            var result = [];
            if (!signatures) {
                return result;
            }

            var len = signatures.length;
            if (!getPrettyTypeName && len > 1) {
                shortform = false;
            }

            var foundDefinition = false;
            if (candidateSignature && candidateSignature.isDefinition() && len > 1) {
                candidateSignature = null;
            }

            for (var i = 0; i < len; i++) {
                if (len > 1 && signatures[i].isDefinition()) {
                    foundDefinition = true;
                    continue;
                }

                var signature = signatures[i];
                if (getPrettyTypeName && candidateSignature) {
                    signature = candidateSignature;
                }

                result.push(signature.getSignatureTypeNameEx(prefix, shortform, brackets, scopeSymbol));
                if (getPrettyTypeName) {
                    break;
                }
            }

            if (getPrettyTypeName && result.length && len > 1) {
                var lastMemberName = result[result.length - 1];
                for (var i = i + 1; i < len; i++) {
                    if (signatures[i].isDefinition()) {
                        foundDefinition = true;
                        break;
                    }
                }
                var overloadString = TypeScript.getLocalizedText(TypeScript.DiagnosticCode._0_overload_s, [foundDefinition ? len - 2 : len - 1]);
                lastMemberName.add(TypeScript.MemberName.create(overloadString));
            }

            return result;
        };

        PullSignatureSymbol.prototype.toString = function (scopeSymbol, useConstraintInName) {
            var s = this.getSignatureTypeNameEx(this.getScopedNameEx().toString(), false, false, scopeSymbol, undefined, useConstraintInName).toString();
            return s;
        };

        PullSignatureSymbol.prototype.getSignatureTypeNameEx = function (prefix, shortform, brackets, scopeSymbol, getParamMarkerInfo, getTypeParamMarkerInfo) {
            var typeParamterBuilder = new TypeScript.MemberNameArray();

            typeParamterBuilder.add(PullSymbol.getTypeParameterStringEx(this.getTypeParameters(), scopeSymbol, getTypeParamMarkerInfo, true));

            if (brackets) {
                typeParamterBuilder.add(TypeScript.MemberName.create("["));
            } else {
                typeParamterBuilder.add(TypeScript.MemberName.create("("));
            }

            var builder = new TypeScript.MemberNameArray();
            builder.prefix = prefix;

            if (getTypeParamMarkerInfo) {
                builder.prefix = prefix;
                builder.addAll(typeParamterBuilder.entries);
            } else {
                builder.prefix = prefix + typeParamterBuilder.toString();
            }

            var params = this.parameters;
            var paramLen = params.length;
            for (var i = 0; i < paramLen; i++) {
                var paramType = params[i].type;
                var typeString = paramType ? ": " : "";
                var paramIsVarArg = params[i].isVarArg;
                var varArgPrefix = paramIsVarArg ? "..." : "";
                var optionalString = (!paramIsVarArg && params[i].isOptional) ? "?" : "";
                if (getParamMarkerInfo) {
                    builder.add(new TypeScript.MemberName());
                }
                builder.add(TypeScript.MemberName.create(varArgPrefix + params[i].getScopedNameEx(scopeSymbol).toString() + optionalString + typeString));
                if (paramType) {
                    builder.add(paramType.getScopedNameEx(scopeSymbol));
                }
                if (getParamMarkerInfo) {
                    builder.add(new TypeScript.MemberName());
                }
                if (i < paramLen - 1) {
                    builder.add(TypeScript.MemberName.create(", "));
                }
            }

            if (shortform) {
                if (brackets) {
                    builder.add(TypeScript.MemberName.create("] => "));
                } else {
                    builder.add(TypeScript.MemberName.create(") => "));
                }
            } else {
                if (brackets) {
                    builder.add(TypeScript.MemberName.create("]: "));
                } else {
                    builder.add(TypeScript.MemberName.create("): "));
                }
            }

            if (this.returnType) {
                builder.add(this.returnType.getScopedNameEx(scopeSymbol));
            } else {
                builder.add(TypeScript.MemberName.create("any"));
            }

            return builder;
        };
        return PullSignatureSymbol;
    })(PullSymbol);
    TypeScript.PullSignatureSymbol = PullSignatureSymbol;

    var PullTypeSymbol = (function (_super) {
        __extends(PullTypeSymbol, _super);
        function PullTypeSymbol(name, kind) {
            _super.call(this, name, kind);
            this._members = TypeScript.sentinelEmptyArray;
            this._enclosedMemberTypes = null;
            this._typeParameters = null;
            this._typeArguments = null;
            this._containedNonMembers = null;
            this._containedNonMemberTypes = null;
            this._specializedVersionsOfThisType = null;
            this._arrayVersionOfThisType = null;
            this._implementedTypes = null;
            this._extendedTypes = null;
            this._typesThatExplicitlyImplementThisType = null;
            this._typesThatExtendThisType = null;
            this._callSignatures = null;
            this._allCallSignatures = null;
            this._constructSignatures = null;
            this._allConstructSignatures = null;
            this._indexSignatures = null;
            this._allIndexSignatures = null;
            this._elementType = null;
            this._memberNameCache = null;
            this._enclosedTypeNameCache = null;
            this._typeParameterNameCache = null;
            this._containedNonMemberNameCache = null;
            this._containedNonMemberTypeNameCache = null;
            this._specializedTypeIDCache = null;
            this._hasGenericSignature = false;
            this._hasGenericMember = false;
            this._hasBaseTypeConflict = false;
            this._knownBaseTypeCount = 0;
            this._invalidatedSpecializations = false;
            this._associatedContainerTypeSymbol = null;
            this._constructorMethod = null;
            this._hasDefaultConstructor = false;
            this._functionSymbol = null;
            this.hasRecursiveSpecializationError = false;
            this.inMemberTypeNameEx = false;
            this.inSymbolPrivacyCheck = false;
            this.type = this;
        }
        PullTypeSymbol.prototype.isType = function () {
            return true;
        };
        PullTypeSymbol.prototype.isClass = function () {
            return this.kind == 8 /* Class */ || (this._constructorMethod != null);
        };
        PullTypeSymbol.prototype.isFunction = function () {
            return (this.kind & (33554432 /* ConstructorType */ | 16777216 /* FunctionType */)) != 0;
        };
        PullTypeSymbol.prototype.isConstructor = function () {
            return this.kind == 33554432 /* ConstructorType */;
        };
        PullTypeSymbol.prototype.isTypeParameter = function () {
            return false;
        };
        PullTypeSymbol.prototype.isTypeVariable = function () {
            return false;
        };
        PullTypeSymbol.prototype.isError = function () {
            return false;
        };
        PullTypeSymbol.prototype.isEnum = function () {
            return this.kind == 64 /* Enum */;
        };

        PullTypeSymbol.prototype.getKnownBaseTypeCount = function () {
            return this._knownBaseTypeCount;
        };
        PullTypeSymbol.prototype.resetKnownBaseTypeCount = function () {
            this._knownBaseTypeCount = 0;
        };
        PullTypeSymbol.prototype.incrementKnownBaseCount = function () {
            this._knownBaseTypeCount++;
        };

        PullTypeSymbol.prototype.setHasBaseTypeConflict = function () {
            this._hasBaseTypeConflict = true;
        };
        PullTypeSymbol.prototype.hasBaseTypeConflict = function () {
            return this._hasBaseTypeConflict;
        };

        PullTypeSymbol.prototype.setUnresolved = function () {
            _super.prototype.setUnresolved.call(this);

            this._invalidatedSpecializations = false;

            var specializations = this.getKnownSpecializations();

            for (var i = 0; i < specializations.length; i++) {
                specializations[i].setUnresolved();
            }
        };

        PullTypeSymbol.prototype.hasMembers = function () {
            if (this._members != TypeScript.sentinelEmptyArray) {
                return true;
            }

            var parents = this.getExtendedTypes();

            for (var i = 0; i < parents.length; i++) {
                if (parents[i].hasMembers()) {
                    return true;
                }
            }

            return false;
        };

        PullTypeSymbol.prototype.setHasGenericSignature = function () {
            this._hasGenericSignature = true;
        };
        PullTypeSymbol.prototype.getHasGenericSignature = function () {
            return this._hasGenericSignature;
        };

        PullTypeSymbol.prototype.setHasGenericMember = function () {
            this._hasGenericMember = true;
        };
        PullTypeSymbol.prototype.getHasGenericMember = function () {
            return this._hasGenericMember;
        };

        PullTypeSymbol.prototype.setAssociatedContainerType = function (type) {
            this._associatedContainerTypeSymbol = type;
        };

        PullTypeSymbol.prototype.getAssociatedContainerType = function () {
            return this._associatedContainerTypeSymbol;
        };

        PullTypeSymbol.prototype.getArrayType = function () {
            return this._arrayVersionOfThisType;
        };

        PullTypeSymbol.prototype.getElementType = function () {
            return this._elementType;
        };

        PullTypeSymbol.prototype.setElementType = function (type) {
            this._elementType = type;
        };

        PullTypeSymbol.prototype.setArrayType = function (arrayType) {
            this._arrayVersionOfThisType = arrayType;
        };

        PullTypeSymbol.prototype.getFunctionSymbol = function () {
            return this._functionSymbol;
        };

        PullTypeSymbol.prototype.setFunctionSymbol = function (symbol) {
            if (symbol) {
                this._functionSymbol = symbol;
            }
        };

        PullTypeSymbol.prototype.addContainedNonMember = function (nonMember) {
            if (!nonMember) {
                return;
            }

            if (!this._containedNonMembers) {
                this._containedNonMembers = [];
            }

            this._containedNonMembers[this._containedNonMembers.length] = nonMember;

            if (!this._containedNonMemberNameCache) {
                this._containedNonMemberNameCache = new TypeScript.BlockIntrinsics();
            }

            this._containedNonMemberNameCache[nonMember.name] = nonMember;
        };

        PullTypeSymbol.prototype.findContainedNonMember = function (name) {
            if (!this._containedNonMemberNameCache) {
                return null;
            }

            return this._containedNonMemberNameCache[name];
        };

        PullTypeSymbol.prototype.findContainedNonMemberType = function (typeName) {
            if (!this._containedNonMemberTypeNameCache) {
                return null;
            }

            return this._containedNonMemberTypeNameCache[typeName];
        };

        PullTypeSymbol.prototype.addMember = function (memberSymbol) {
            if (!memberSymbol) {
                return;
            }

            memberSymbol.setContainer(this);

            if (!this._memberNameCache) {
                this._memberNameCache = new TypeScript.BlockIntrinsics();
            }

            if (this._members == TypeScript.sentinelEmptyArray) {
                this._members = [];
            }

            this._members[this._members.length] = memberSymbol;
            this._memberNameCache[memberSymbol.name] = memberSymbol;
        };

        PullTypeSymbol.prototype.addEnclosedMemberType = function (enclosedType) {
            if (!enclosedType) {
                return;
            }

            enclosedType.setContainer(this);

            if (!this._enclosedTypeNameCache) {
                this._enclosedTypeNameCache = new TypeScript.BlockIntrinsics();
            }

            if (!this._enclosedMemberTypes) {
                this._enclosedMemberTypes = [];
            }

            this._enclosedMemberTypes[this._enclosedMemberTypes.length] = enclosedType;
            this._enclosedTypeNameCache[enclosedType.name] = enclosedType;
        };

        PullTypeSymbol.prototype.addEnclosedNonMember = function (enclosedNonMember) {
            if (!enclosedNonMember) {
                return;
            }

            enclosedNonMember.setContainer(this);

            if (!this._containedNonMemberNameCache) {
                this._containedNonMemberNameCache = new TypeScript.BlockIntrinsics();
            }

            if (!this._containedNonMembers) {
                this._containedNonMembers = [];
            }

            this._containedNonMembers[this._containedNonMembers.length] = enclosedNonMember;
            this._containedNonMemberNameCache[enclosedNonMember.name] = enclosedNonMember;
        };

        PullTypeSymbol.prototype.addEnclosedNonMemberType = function (enclosedNonMemberType) {
            if (!enclosedNonMemberType) {
                return;
            }

            enclosedNonMemberType.setContainer(this);

            if (!this._containedNonMemberTypeNameCache) {
                this._containedNonMemberTypeNameCache = new TypeScript.BlockIntrinsics();
            }

            if (!this._containedNonMemberTypes) {
                this._containedNonMemberTypes = [];
            }

            this._containedNonMemberTypes[this._containedNonMemberTypes.length] = enclosedNonMemberType;
            this._containedNonMemberTypeNameCache[enclosedNonMemberType.name] = enclosedNonMemberType;
        };

        PullTypeSymbol.prototype.addTypeParameter = function (typeParameter) {
            if (!typeParameter) {
                return;
            }

            if (!typeParameter.getContainer()) {
                typeParameter.setContainer(this);
            }

            if (!this._typeParameterNameCache) {
                this._typeParameterNameCache = new TypeScript.BlockIntrinsics();
            }

            if (!this._typeParameters) {
                this._typeParameters = [];
            }

            this._typeParameters[this._typeParameters.length] = typeParameter;
            this._typeParameterNameCache[typeParameter.getName()] = typeParameter;
        };

        PullTypeSymbol.prototype.addConstructorTypeParameter = function (typeParameter) {
            this.addTypeParameter(typeParameter);

            var constructSignatures = this.getConstructSignatures();

            for (var i = 0; i < constructSignatures.length; i++) {
                constructSignatures[i].addTypeParameter(typeParameter);
            }
        };

        PullTypeSymbol.prototype.getMembers = function () {
            return this._members;
        };

        PullTypeSymbol.prototype.setHasDefaultConstructor = function (hasOne) {
            if (typeof hasOne === "undefined") { hasOne = true; }
            this._hasDefaultConstructor = hasOne;
        };

        PullTypeSymbol.prototype.getHasDefaultConstructor = function () {
            return this._hasDefaultConstructor;
        };

        PullTypeSymbol.prototype.getConstructorMethod = function () {
            return this._constructorMethod;
        };

        PullTypeSymbol.prototype.setConstructorMethod = function (constructorMethod) {
            this._constructorMethod = constructorMethod;
        };

        PullTypeSymbol.prototype.getTypeParameters = function () {
            if (!this._typeParameters) {
                return TypeScript.sentinelEmptyArray;
            }

            return this._typeParameters;
        };

        PullTypeSymbol.prototype.isGeneric = function () {
            return (this._typeParameters && this._typeParameters.length != 0) || this._hasGenericSignature || this._hasGenericMember || (this._typeArguments && this._typeArguments.length) || this.isArray();
        };

        PullTypeSymbol.prototype.isFixed = function () {
            if (!this.isGeneric()) {
                return true;
            }

            if (this._typeParameters && this._typeArguments) {
                if (!this._typeArguments.length || this._typeArguments.length < this._typeParameters.length) {
                    return false;
                }

                for (var i = 0; i < this._typeArguments.length; i++) {
                    if (!this._typeArguments[i].isFixed()) {
                        return false;
                    }
                }

                return true;
            } else if (this._hasGenericMember) {
                var members = this.getMembers();
                var memberType = null;

                for (var i = 0; i < members.length; i++) {
                    memberType = members[i].type;

                    if (memberType && !memberType.isFixed()) {
                        return false;
                    }
                }

                return true;
            }

            return false;
        };

        PullTypeSymbol.prototype.addSpecialization = function (specializedVersionOfThisType, substitutingTypes) {
            if (!substitutingTypes || !substitutingTypes.length) {
                return;
            }

            if (!this._specializedTypeIDCache) {
                this._specializedTypeIDCache = new TypeScript.BlockIntrinsics();
            }

            if (!this._specializedVersionsOfThisType) {
                this._specializedVersionsOfThisType = [];
            }

            this._specializedVersionsOfThisType[this._specializedVersionsOfThisType.length] = specializedVersionOfThisType;

            this._specializedTypeIDCache[getIDForTypeSubstitutions(substitutingTypes)] = specializedVersionOfThisType;
        };

        PullTypeSymbol.prototype.getSpecialization = function (substitutingTypes) {
            if (!substitutingTypes || !substitutingTypes.length) {
                return null;
            }

            if (!this._specializedTypeIDCache) {
                this._specializedTypeIDCache = new TypeScript.BlockIntrinsics();

                return null;
            }

            var specialization = this._specializedTypeIDCache[getIDForTypeSubstitutions(substitutingTypes)];

            if (!specialization) {
                return null;
            }

            return specialization;
        };

        PullTypeSymbol.prototype.getKnownSpecializations = function () {
            if (!this._specializedVersionsOfThisType) {
                return TypeScript.sentinelEmptyArray;
            }

            return this._specializedVersionsOfThisType;
        };

        PullTypeSymbol.prototype.getTypeArguments = function () {
            return this._typeArguments;
        };
        PullTypeSymbol.prototype.setTypeArguments = function (typeArgs) {
            this._typeArguments = typeArgs;
        };

        PullTypeSymbol.prototype.addCallSignature = function (callSignature) {
            if (!this._callSignatures) {
                this._callSignatures = [];
            }

            this._callSignatures[this._callSignatures.length] = callSignature;

            if (callSignature.isGeneric()) {
                this._hasGenericSignature = true;
            }

            callSignature.functionType = this;
        };

        PullTypeSymbol.prototype.addConstructSignature = function (constructSignature) {
            if (!this._constructSignatures) {
                this._constructSignatures = [];
            }

            this._constructSignatures[this._constructSignatures.length] = constructSignature;

            if (constructSignature.isGeneric()) {
                this._hasGenericSignature = true;
            }

            constructSignature.functionType = this;
        };

        PullTypeSymbol.prototype.addIndexSignature = function (indexSignature) {
            if (!this._indexSignatures) {
                this._indexSignatures = [];
            }

            this._indexSignatures[this._indexSignatures.length] = indexSignature;

            if (indexSignature.isGeneric()) {
                this._hasGenericSignature = true;
            }

            indexSignature.functionType = this;
        };

        PullTypeSymbol.prototype.hasOwnCallSignatures = function () {
            return !!this._callSignatures;
        };

        PullTypeSymbol.prototype.getCallSignatures = function (collectBaseSignatures) {
            if (typeof collectBaseSignatures === "undefined") { collectBaseSignatures = true; }
            if (!collectBaseSignatures) {
                return this._callSignatures || [];
            }

            if (this._allCallSignatures) {
                return this._allCallSignatures;
            }

            var signatures = [];

            if (this._callSignatures) {
                signatures = signatures.concat(this._callSignatures);
            }

            if (collectBaseSignatures && this._extendedTypes) {
                for (var i = 0; i < this._extendedTypes.length; i++) {
                    if (this._extendedTypes[i].hasBase(this)) {
                        continue;
                    }

                    signatures = signatures.concat(this._extendedTypes[i].getCallSignatures());
                }
            }

            this._allCallSignatures = signatures;

            return signatures;
        };

        PullTypeSymbol.prototype.hasOwnConstructSignatures = function () {
            return !!this._constructSignatures;
        };

        PullTypeSymbol.prototype.getConstructSignatures = function (collectBaseSignatures) {
            if (typeof collectBaseSignatures === "undefined") { collectBaseSignatures = true; }
            if (!collectBaseSignatures) {
                return this._constructSignatures || [];
            }

            var signatures = [];

            if (this._constructSignatures) {
                signatures = signatures.concat(this._constructSignatures);
            }

            if (collectBaseSignatures && this._extendedTypes && !(this.kind == 33554432 /* ConstructorType */)) {
                for (var i = 0; i < this._extendedTypes.length; i++) {
                    if (this._extendedTypes[i].hasBase(this)) {
                        continue;
                    }

                    signatures = signatures.concat(this._extendedTypes[i].getConstructSignatures());
                }
            }

            return signatures;
        };

        PullTypeSymbol.prototype.hasOwnIndexSignatures = function () {
            return !!this._indexSignatures;
        };

        PullTypeSymbol.prototype.getIndexSignatures = function (collectBaseSignatures) {
            if (typeof collectBaseSignatures === "undefined") { collectBaseSignatures = true; }
            if (!collectBaseSignatures) {
                return this._indexSignatures || [];
            }

            if (this._allIndexSignatures) {
                return this._allIndexSignatures;
            }

            var signatures = [];

            if (this._indexSignatures) {
                signatures = signatures.concat(this._indexSignatures);
            }

            if (collectBaseSignatures && this._extendedTypes) {
                for (var i = 0; i < this._extendedTypes.length; i++) {
                    if (this._extendedTypes[i].hasBase(this)) {
                        continue;
                    }

                    signatures = signatures.concat(this._extendedTypes[i].getIndexSignatures());
                }
            }

            this._allIndexSignatures = signatures;

            return signatures;
        };

        PullTypeSymbol.prototype.addImplementedType = function (implementedType) {
            if (!implementedType) {
                return;
            }

            if (!this._implementedTypes) {
                this._implementedTypes = [];
            }

            this._implementedTypes[this._implementedTypes.length] = implementedType;

            implementedType.addTypeThatExplicitlyImplementsThisType(this);
        };

        PullTypeSymbol.prototype.getImplementedTypes = function () {
            if (!this._implementedTypes) {
                return TypeScript.sentinelEmptyArray;
            }

            return this._implementedTypes;
        };

        PullTypeSymbol.prototype.addExtendedType = function (extendedType) {
            if (!extendedType) {
                return;
            }

            if (!this._extendedTypes) {
                this._extendedTypes = [];
            }

            this._extendedTypes[this._extendedTypes.length] = extendedType;

            extendedType.addTypeThatExtendsThisType(this);
        };

        PullTypeSymbol.prototype.getExtendedTypes = function () {
            if (!this._extendedTypes) {
                return TypeScript.sentinelEmptyArray;
            }

            return this._extendedTypes;
        };

        PullTypeSymbol.prototype.addTypeThatExtendsThisType = function (type) {
            if (!type) {
                return;
            }

            if (!this._typesThatExtendThisType) {
                this._typesThatExtendThisType = [];
            }

            this._typesThatExtendThisType[this._typesThatExtendThisType.length] = type;
        };

        PullTypeSymbol.prototype.getTypesThatExtendThisType = function () {
            if (!this._typesThatExplicitlyImplementThisType) {
                this._typesThatExplicitlyImplementThisType = [];
            }

            return this._typesThatExtendThisType;
        };

        PullTypeSymbol.prototype.addTypeThatExplicitlyImplementsThisType = function (type) {
            if (!type) {
                return;
            }

            if (!this._typesThatExplicitlyImplementThisType) {
                this._typesThatExplicitlyImplementThisType = [];
            }

            this._typesThatExplicitlyImplementThisType[this._typesThatExplicitlyImplementThisType.length] = type;
        };

        PullTypeSymbol.prototype.getTypesThatExplicitlyImplementThisType = function () {
            if (!this._typesThatExplicitlyImplementThisType) {
                this._typesThatExplicitlyImplementThisType = [];
            }

            return this._typesThatExplicitlyImplementThisType;
        };

        PullTypeSymbol.prototype.hasBase = function (potentialBase, origin) {
            if (typeof origin === "undefined") { origin = null; }
            if (this === potentialBase) {
                return true;
            }

            if (origin && (this === origin || this.getRootSymbol() === origin)) {
                return true;
            }

            if (!origin) {
                origin = this;
            }

            var extendedTypes = this.getExtendedTypes();

            for (var i = 0; i < extendedTypes.length; i++) {
                if (extendedTypes[i].hasBase(potentialBase, origin)) {
                    return true;
                }
            }

            var implementedTypes = this.getImplementedTypes();

            for (var i = 0; i < implementedTypes.length; i++) {
                if (implementedTypes[i].hasBase(potentialBase, origin)) {
                    return true;
                }
            }

            return false;
        };

        PullTypeSymbol.prototype.isValidBaseKind = function (baseType, isExtendedType) {
            if (baseType.isError()) {
                return false;
            }

            var thisIsClass = this.isClass();
            if (isExtendedType) {
                if (thisIsClass) {
                    return baseType.kind === 8 /* Class */;
                }
            } else {
                if (!thisIsClass) {
                    return false;
                }
            }

            return !!(baseType.kind & (16 /* Interface */ | 8 /* Class */ | 128 /* Array */));
        };

        PullTypeSymbol.prototype.findMember = function (name, lookInParent) {
            if (typeof lookInParent === "undefined") { lookInParent = true; }
            var memberSymbol = null;

            if (this._memberNameCache) {
                memberSymbol = this._memberNameCache[name];
            }

            if (!lookInParent) {
                return memberSymbol;
            } else if (memberSymbol) {
                return memberSymbol;
            }

            if (!memberSymbol && this._extendedTypes) {
                for (var i = 0; i < this._extendedTypes.length; i++) {
                    memberSymbol = this._extendedTypes[i].findMember(name);

                    if (memberSymbol) {
                        return memberSymbol;
                    }
                }
            }

            return null;
        };

        PullTypeSymbol.prototype.findNestedType = function (name, kind) {
            if (typeof kind === "undefined") { kind = 0 /* None */; }
            var memberSymbol;

            if (!this._enclosedTypeNameCache) {
                return null;
            }

            memberSymbol = this._enclosedTypeNameCache[name];

            if (memberSymbol && kind != 0 /* None */) {
                memberSymbol = ((memberSymbol.kind & kind) != 0) ? memberSymbol : null;
            }

            return memberSymbol;
        };

        PullTypeSymbol.prototype.getAllMembers = function (searchDeclKind, includePrivate) {
            var allMembers = [];

            var i = 0;
            var j = 0;
            var m = 0;
            var n = 0;

            if (this._members != TypeScript.sentinelEmptyArray) {
                for (var i = 0, n = this._members.length; i < n; i++) {
                    var member = this._members[i];
                    if ((member.kind & searchDeclKind) && (includePrivate || !member.hasFlag(2 /* Private */))) {
                        allMembers[allMembers.length] = member;
                    }
                }
            }

            if (this._extendedTypes) {
                for (var i = 0, n = this._extendedTypes.length; i < n; i++) {
                    var extendedMembers = this._extendedTypes[i].getAllMembers(searchDeclKind, includePrivate);

                    for (var j = 0, m = extendedMembers.length; j < m; j++) {
                        var extendedMember = extendedMembers[j];
                        if (!(this._memberNameCache && this._memberNameCache[extendedMember.name])) {
                            allMembers[allMembers.length] = extendedMember;
                        }
                    }
                }
            }

            if (this.isContainer() && this._enclosedMemberTypes) {
                for (var i = 0; i < this._enclosedMemberTypes.length; i++) {
                    allMembers[allMembers.length] = this._enclosedMemberTypes[i];
                }
            }

            return allMembers;
        };

        PullTypeSymbol.prototype.findTypeParameter = function (name) {
            if (!this._typeParameterNameCache) {
                return null;
            }

            return this._typeParameterNameCache[name];
        };

        PullTypeSymbol.prototype.setResolved = function () {
            _super.prototype.setResolved.call(this);
        };

        PullTypeSymbol.prototype.invalidate = function () {
            if (this._constructorMethod) {
                this._constructorMethod.invalidate();
            }

            this._knownBaseTypeCount = 0;

            _super.prototype.invalidate.call(this);
        };

        PullTypeSymbol.prototype.getNamePartForFullName = function () {
            var name = _super.prototype.getNamePartForFullName.call(this);

            var typars = this.getTypeArguments();
            if (!typars || !typars.length) {
                typars = this.getTypeParameters();
            }

            var typarString = PullSymbol.getTypeParameterString(typars, this, true);
            return name + typarString;
        };

        PullTypeSymbol.prototype.getScopedName = function (scopeSymbol, useConstraintInName) {
            return this.getScopedNameEx(scopeSymbol, useConstraintInName).toString();
        };

        PullTypeSymbol.prototype.isNamedTypeSymbol = function () {
            if (this.isArray()) {
                return false;
            }

            var kind = this.kind;
            if (kind === 2 /* Primitive */ || kind === 8 /* Class */ || kind === 4 /* Container */ || kind === 32 /* DynamicModule */ || kind === 256 /* TypeAlias */ || kind === 64 /* Enum */ || kind === 8192 /* TypeParameter */ || ((kind === 16 /* Interface */ || kind === 8388608 /* ObjectType */) && this.name != "")) {
                return true;
            }

            return false;
        };

        PullTypeSymbol.prototype.toString = function (scopeSymbol, useConstraintInName) {
            var s = this.getScopedNameEx(scopeSymbol, useConstraintInName).toString();
            return s;
        };

        PullTypeSymbol.prototype.getScopedNameEx = function (scopeSymbol, useConstraintInName, getPrettyTypeName, getTypeParamMarkerInfo) {
            if (this.isArray()) {
                var elementMemberName = this._elementType ? (this._elementType.isArray() || this._elementType.isNamedTypeSymbol() ? this._elementType.getScopedNameEx(scopeSymbol, false, getPrettyTypeName, getTypeParamMarkerInfo) : this._elementType.getMemberTypeNameEx(false, scopeSymbol, getPrettyTypeName)) : TypeScript.MemberName.create("any");
                return TypeScript.MemberName.create(elementMemberName, "", "[]");
            }

            if (!this.isNamedTypeSymbol()) {
                return this.getMemberTypeNameEx(true, scopeSymbol, getPrettyTypeName);
            }

            var builder = new TypeScript.MemberNameArray();
            builder.prefix = _super.prototype.getScopedName.call(this, scopeSymbol, useConstraintInName);

            var typars = this.getTypeArguments();
            if (!typars || !typars.length) {
                typars = this.getTypeParameters();
            }

            builder.add(PullSymbol.getTypeParameterStringEx(typars, scopeSymbol, getTypeParamMarkerInfo, useConstraintInName));

            return builder;
        };

        PullTypeSymbol.prototype.hasOnlyOverloadCallSignatures = function () {
            var members = this.getMembers();
            var callSignatures = this.getCallSignatures();
            var constructSignatures = this.getConstructSignatures();
            return members.length === 0 && constructSignatures.length === 0 && callSignatures.length > 1;
        };

        PullTypeSymbol.prototype.getMemberTypeNameEx = function (topLevel, scopeSymbol, getPrettyTypeName) {
            var members = this.getMembers();
            var callSignatures = this.getCallSignatures();
            var constructSignatures = this.getConstructSignatures();
            var indexSignatures = this.getIndexSignatures();

            if (members.length > 0 || callSignatures.length > 0 || constructSignatures.length > 0 || indexSignatures.length > 0) {
                if (this.inMemberTypeNameEx) {
                    var associatedContainerType = this.getAssociatedContainerType();
                    if (associatedContainerType && associatedContainerType.isNamedTypeSymbol()) {
                        var nameForTypeOf = associatedContainerType.getScopedNameEx(scopeSymbol);
                        return TypeScript.MemberName.create(nameForTypeOf, "typeof ", "");
                    } else {
                        return TypeScript.MemberName.create("any");
                    }
                }

                this.inMemberTypeNameEx = true;

                var allMemberNames = new TypeScript.MemberNameArray();
                var curlies = !topLevel || indexSignatures.length != 0;
                var delim = "; ";
                for (var i = 0; i < members.length; i++) {
                    if (members[i].kind == 65536 /* Method */ && members[i].type.hasOnlyOverloadCallSignatures()) {
                        var methodCallSignatures = members[i].type.getCallSignatures();
                        var nameStr = members[i].getDisplayName(scopeSymbol) + (members[i].isOptional ? "?" : "");
                        ;
                        var methodMemberNames = PullSignatureSymbol.getSignaturesTypeNameEx(methodCallSignatures, nameStr, false, false, scopeSymbol);
                        allMemberNames.addAll(methodMemberNames);
                    } else {
                        var memberTypeName = members[i].getNameAndTypeNameEx(scopeSymbol);
                        if (memberTypeName.isArray() && (memberTypeName).delim === delim) {
                            allMemberNames.addAll((memberTypeName).entries);
                        } else {
                            allMemberNames.add(memberTypeName);
                        }
                    }
                    curlies = true;
                }

                var getPrettyFunctionOverload = getPrettyTypeName && !curlies && this.hasOnlyOverloadCallSignatures();

                var signatureCount = callSignatures.length + constructSignatures.length + indexSignatures.length;
                var useShortFormSignature = !curlies && (signatureCount === 1);
                var signatureMemberName;

                if (callSignatures.length > 0) {
                    signatureMemberName = PullSignatureSymbol.getSignaturesTypeNameEx(callSignatures, "", useShortFormSignature, false, scopeSymbol, getPrettyFunctionOverload);
                    allMemberNames.addAll(signatureMemberName);
                }

                if (constructSignatures.length > 0) {
                    signatureMemberName = PullSignatureSymbol.getSignaturesTypeNameEx(constructSignatures, "new", useShortFormSignature, false, scopeSymbol);
                    allMemberNames.addAll(signatureMemberName);
                }

                if (indexSignatures.length > 0) {
                    signatureMemberName = PullSignatureSymbol.getSignaturesTypeNameEx(indexSignatures, "", useShortFormSignature, true, scopeSymbol);
                    allMemberNames.addAll(signatureMemberName);
                }

                if ((curlies) || (!getPrettyFunctionOverload && (signatureCount > 1) && topLevel)) {
                    allMemberNames.prefix = "{ ";
                    allMemberNames.suffix = "}";
                    allMemberNames.delim = delim;
                } else if (allMemberNames.entries.length > 1) {
                    allMemberNames.delim = delim;
                }

                this.inMemberTypeNameEx = false;

                return allMemberNames;
            }

            return TypeScript.MemberName.create("{}");
        };

        PullTypeSymbol.prototype.isExternallyVisible = function (inIsExternallyVisibleSymbols) {
            var isVisible = _super.prototype.isExternallyVisible.call(this, inIsExternallyVisibleSymbols);
            if (isVisible) {
                var typars = this.getTypeArguments();
                if (!typars || !typars.length) {
                    typars = this.getTypeParameters();
                }

                if (typars) {
                    for (var i = 0; i < typars.length; i++) {
                        isVisible = PullSymbol.getIsExternallyVisible(typars[i], this, inIsExternallyVisibleSymbols);
                        if (!isVisible) {
                            break;
                        }
                    }
                }
            }

            return isVisible;
        };
        return PullTypeSymbol;
    })(PullSymbol);
    TypeScript.PullTypeSymbol = PullTypeSymbol;

    var PullPrimitiveTypeSymbol = (function (_super) {
        __extends(PullPrimitiveTypeSymbol, _super);
        function PullPrimitiveTypeSymbol(name) {
            _super.call(this, name, 2 /* Primitive */);

            this.isResolved = true;
        }
        PullPrimitiveTypeSymbol.prototype.isStringConstant = function () {
            return false;
        };

        PullPrimitiveTypeSymbol.prototype.isFixed = function () {
            return true;
        };

        PullPrimitiveTypeSymbol.prototype.invalidate = function () {
        };
        return PullPrimitiveTypeSymbol;
    })(PullTypeSymbol);
    TypeScript.PullPrimitiveTypeSymbol = PullPrimitiveTypeSymbol;

    var PullStringConstantTypeSymbol = (function (_super) {
        __extends(PullStringConstantTypeSymbol, _super);
        function PullStringConstantTypeSymbol(name) {
            _super.call(this, name);
        }
        PullStringConstantTypeSymbol.prototype.isStringConstant = function () {
            return true;
        };
        return PullStringConstantTypeSymbol;
    })(PullPrimitiveTypeSymbol);
    TypeScript.PullStringConstantTypeSymbol = PullStringConstantTypeSymbol;

    var PullErrorTypeSymbol = (function (_super) {
        __extends(PullErrorTypeSymbol, _super);
        function PullErrorTypeSymbol(diagnostic, delegateType, _data) {
            if (typeof _data === "undefined") { _data = null; }
            _super.call(this, "error");
            this.diagnostic = diagnostic;
            this.delegateType = delegateType;
            this._data = _data;

            this.isResolved = true;
        }
        PullErrorTypeSymbol.prototype.isError = function () {
            return true;
        };

        PullErrorTypeSymbol.prototype.getDiagnostic = function () {
            return this.diagnostic;
        };

        PullErrorTypeSymbol.prototype.getName = function (scopeSymbol, useConstraintInName) {
            return this.delegateType.getName(scopeSymbol, useConstraintInName);
        };

        PullErrorTypeSymbol.prototype.getDisplayName = function (scopeSymbol, useConstraintInName) {
            return this.delegateType.getDisplayName(scopeSymbol, useConstraintInName);
        };

        PullErrorTypeSymbol.prototype.toString = function (scopeSymbol, useConstraintInName) {
            return this.delegateType.toString(scopeSymbol, useConstraintInName);
        };

        PullErrorTypeSymbol.prototype.setData = function (data) {
            this._data = data;
        };

        PullErrorTypeSymbol.prototype.getData = function () {
            return this._data;
        };
        return PullErrorTypeSymbol;
    })(PullPrimitiveTypeSymbol);
    TypeScript.PullErrorTypeSymbol = PullErrorTypeSymbol;

    var PullContainerTypeSymbol = (function (_super) {
        __extends(PullContainerTypeSymbol, _super);
        function PullContainerTypeSymbol(name, kind) {
            if (typeof kind === "undefined") { kind = 4 /* Container */; }
            _super.call(this, name, kind);
            this.instanceSymbol = null;
            this.assignedValue = null;
            this.assignedType = null;
            this.assignedContainer = null;
        }
        PullContainerTypeSymbol.prototype.isContainer = function () {
            return true;
        };

        PullContainerTypeSymbol.prototype.setInstanceSymbol = function (symbol) {
            this.instanceSymbol = symbol;
        };

        PullContainerTypeSymbol.prototype.getInstanceSymbol = function () {
            return this.instanceSymbol;
        };

        PullContainerTypeSymbol.prototype.invalidate = function () {
            if (this.instanceSymbol) {
                this.instanceSymbol.invalidate();
            }

            _super.prototype.invalidate.call(this);
        };

        PullContainerTypeSymbol.prototype.setExportAssignedValueSymbol = function (symbol) {
            this.assignedValue = symbol;
        };
        PullContainerTypeSymbol.prototype.getExportAssignedValueSymbol = function () {
            return this.assignedValue;
        };

        PullContainerTypeSymbol.prototype.setExportAssignedTypeSymbol = function (type) {
            this.assignedType = type;
        };

        PullContainerTypeSymbol.prototype.getExportAssignedTypeSymbol = function () {
            return this.assignedType;
        };

        PullContainerTypeSymbol.prototype.setExportAssignedContainerSymbol = function (container) {
            this.assignedContainer = container;
        };

        PullContainerTypeSymbol.prototype.getExportAssignedContainerSymbol = function () {
            return this.assignedContainer;
        };

        PullContainerTypeSymbol.prototype.resetExportAssignedSymbols = function () {
            this.assignedValue = null;
            this.assignedType = null;
            this.assignedContainer = null;
        };

        PullContainerTypeSymbol.usedAsSymbol = function (containerSymbol, symbol) {
            if (!containerSymbol || !containerSymbol.isContainer()) {
                return false;
            }

            if (!containerSymbol.isAlias() && containerSymbol.type == symbol) {
                return true;
            }

            var containerTypeSymbol = containerSymbol;
            var valueExportSymbol = containerTypeSymbol.getExportAssignedValueSymbol();
            var typeExportSymbol = containerTypeSymbol.getExportAssignedTypeSymbol();
            var containerExportSymbol = containerTypeSymbol.getExportAssignedContainerSymbol();
            if (valueExportSymbol || typeExportSymbol || containerExportSymbol) {
                return valueExportSymbol == symbol || typeExportSymbol == symbol || containerExportSymbol == symbol || PullContainerTypeSymbol.usedAsSymbol(containerExportSymbol, symbol);
            }

            return false;
        };

        PullContainerTypeSymbol.prototype.getInstanceType = function () {
            return this.instanceSymbol ? this.instanceSymbol.type : null;
        };
        return PullContainerTypeSymbol;
    })(PullTypeSymbol);
    TypeScript.PullContainerTypeSymbol = PullContainerTypeSymbol;

    var PullTypeAliasSymbol = (function (_super) {
        __extends(PullTypeAliasSymbol, _super);
        function PullTypeAliasSymbol(name) {
            _super.call(this, name, 256 /* TypeAlias */);
            this.assignedValue = null;
            this.assignedType = null;
            this.assignedContainer = null;
            this.isUsedAsValue = false;
            this.typeUsedExternally = false;
            this.retrievingExportAssignment = false;
        }
        PullTypeAliasSymbol.prototype.isAlias = function () {
            return true;
        };
        PullTypeAliasSymbol.prototype.isContainer = function () {
            return true;
        };

        PullTypeAliasSymbol.prototype.setAssignedValueSymbol = function (symbol) {
            this.assignedValue = symbol;
        };

        PullTypeAliasSymbol.prototype.getExportAssignedValueSymbol = function () {
            if (this.assignedValue) {
                return this.assignedValue;
            }

            if (this.retrievingExportAssignment) {
                return null;
            }

            if (this.assignedContainer) {
                this.retrievingExportAssignment = true;
                var sym = this.assignedContainer.getExportAssignedValueSymbol();
                this.retrievingExportAssignment = false;
                return sym;
            }

            return null;
        };

        PullTypeAliasSymbol.prototype.setAssignedTypeSymbol = function (type) {
            this.assignedType = type;
        };

        PullTypeAliasSymbol.prototype.getExportAssignedTypeSymbol = function () {
            if (this.retrievingExportAssignment) {
                return null;
            }

            if (this.assignedType) {
                if (this.assignedType.isAlias()) {
                    this.retrievingExportAssignment = true;
                    var sym = (this.assignedType).getExportAssignedTypeSymbol();
                    this.retrievingExportAssignment = false;
                } else if (this.assignedType != this.assignedContainer) {
                    return this.assignedType;
                }
            }

            if (this.assignedContainer) {
                this.retrievingExportAssignment = true;
                var sym = this.assignedContainer.getExportAssignedTypeSymbol();
                this.retrievingExportAssignment = false;
                if (sym) {
                    return sym;
                }
            }

            return this.assignedContainer;
        };

        PullTypeAliasSymbol.prototype.setAssignedContainerSymbol = function (container) {
            this.assignedContainer = container;
        };

        PullTypeAliasSymbol.prototype.getExportAssignedContainerSymbol = function () {
            if (this.retrievingExportAssignment) {
                return null;
            }

            if (this.assignedContainer) {
                this.retrievingExportAssignment = true;
                var sym = this.assignedContainer.getExportAssignedContainerSymbol();
                this.retrievingExportAssignment = false;
                if (sym) {
                    return sym;
                }
            }

            return this.assignedContainer;
        };

        PullTypeAliasSymbol.prototype.getMembers = function () {
            if (this.assignedType) {
                return this.assignedType.getMembers();
            }

            return TypeScript.sentinelEmptyArray;
        };

        PullTypeAliasSymbol.prototype.getCallSignatures = function () {
            if (this.assignedType) {
                return this.assignedType.getCallSignatures();
            }

            return TypeScript.sentinelEmptyArray;
        };

        PullTypeAliasSymbol.prototype.getConstructSignatures = function () {
            if (this.assignedType) {
                return this.assignedType.getConstructSignatures();
            }

            return TypeScript.sentinelEmptyArray;
        };

        PullTypeAliasSymbol.prototype.getIndexSignatures = function () {
            if (this.assignedType) {
                return this.assignedType.getIndexSignatures();
            }

            return TypeScript.sentinelEmptyArray;
        };

        PullTypeAliasSymbol.prototype.findMember = function (name) {
            if (this.assignedType) {
                return this.assignedType.findMember(name);
            }

            return null;
        };

        PullTypeAliasSymbol.prototype.findNestedType = function (name) {
            if (this.assignedType) {
                return this.assignedType.findNestedType(name);
            }

            return null;
        };

        PullTypeAliasSymbol.prototype.getAllMembers = function (searchDeclKind, includePrivate) {
            if (this.assignedType) {
                return this.assignedType.getAllMembers(searchDeclKind, includePrivate);
            }

            return TypeScript.sentinelEmptyArray;
        };

        PullTypeAliasSymbol.prototype.invalidate = function () {
            this.isUsedAsValue = false;

            _super.prototype.invalidate.call(this);
        };
        return PullTypeAliasSymbol;
    })(PullTypeSymbol);
    TypeScript.PullTypeAliasSymbol = PullTypeAliasSymbol;

    var PullDefinitionSignatureSymbol = (function (_super) {
        __extends(PullDefinitionSignatureSymbol, _super);
        function PullDefinitionSignatureSymbol() {
            _super.apply(this, arguments);
        }
        PullDefinitionSignatureSymbol.prototype.isDefinition = function () {
            return true;
        };
        return PullDefinitionSignatureSymbol;
    })(PullSignatureSymbol);
    TypeScript.PullDefinitionSignatureSymbol = PullDefinitionSignatureSymbol;

    var PullTypeParameterSymbol = (function (_super) {
        __extends(PullTypeParameterSymbol, _super);
        function PullTypeParameterSymbol(name, _isFunctionTypeParameter) {
            _super.call(this, name, 8192 /* TypeParameter */);
            this._isFunctionTypeParameter = _isFunctionTypeParameter;
            this._constraint = null;
        }
        PullTypeParameterSymbol.prototype.isTypeParameter = function () {
            return true;
        };
        PullTypeParameterSymbol.prototype.isFunctionTypeParameter = function () {
            return this._isFunctionTypeParameter;
        };

        PullTypeParameterSymbol.prototype.isFixed = function () {
            return false;
        };

        PullTypeParameterSymbol.prototype.setConstraint = function (constraintType) {
            this._constraint = constraintType;
        };

        PullTypeParameterSymbol.prototype.getConstraint = function () {
            return this._constraint;
        };

        PullTypeParameterSymbol.prototype.isGeneric = function () {
            return true;
        };

        PullTypeParameterSymbol.prototype.fullName = function (scopeSymbol) {
            var name = this.getDisplayName(scopeSymbol);
            var container = this.getContainer();
            if (container) {
                var containerName = container.fullName(scopeSymbol);
                name = name + " in " + containerName;
            }

            return name;
        };

        PullTypeParameterSymbol.prototype.getName = function (scopeSymbol, useConstraintInName) {
            var name = _super.prototype.getName.call(this, scopeSymbol);

            if (this.isPrinting) {
                return name;
            }

            this.isPrinting = true;

            if (useConstraintInName && this._constraint) {
                name += " extends " + this._constraint.toString(scopeSymbol);
            }

            this.isPrinting = false;

            return name;
        };

        PullTypeParameterSymbol.prototype.getDisplayName = function (scopeSymbol, useConstraintInName) {
            var name = _super.prototype.getDisplayName.call(this, scopeSymbol, useConstraintInName);

            if (this.isPrinting) {
                return name;
            }

            this.isPrinting = true;

            if (useConstraintInName && this._constraint) {
                name += " extends " + this._constraint.toString(scopeSymbol);
            }

            this.isPrinting = false;

            return name;
        };

        PullTypeParameterSymbol.prototype.isExternallyVisible = function (inIsExternallyVisibleSymbols) {
            var constraint = this.getConstraint();
            if (constraint) {
                return PullSymbol.getIsExternallyVisible(constraint, this, inIsExternallyVisibleSymbols);
            }

            return true;
        };
        return PullTypeParameterSymbol;
    })(PullTypeSymbol);
    TypeScript.PullTypeParameterSymbol = PullTypeParameterSymbol;

    var PullTypeVariableSymbol = (function (_super) {
        __extends(PullTypeVariableSymbol, _super);
        function PullTypeVariableSymbol(name, isFunctionTypeParameter) {
            _super.call(this, name, isFunctionTypeParameter);
            this.tyvarID = TypeScript.globalTyvarID++;
        }
        PullTypeVariableSymbol.prototype.isTypeParameter = function () {
            return true;
        };
        PullTypeVariableSymbol.prototype.isTypeVariable = function () {
            return true;
        };
        return PullTypeVariableSymbol;
    })(PullTypeParameterSymbol);
    TypeScript.PullTypeVariableSymbol = PullTypeVariableSymbol;

    var PullAccessorSymbol = (function (_super) {
        __extends(PullAccessorSymbol, _super);
        function PullAccessorSymbol(name) {
            _super.call(this, name, 4096 /* Property */);
            this._getterSymbol = null;
            this._setterSymbol = null;
        }
        PullAccessorSymbol.prototype.isAccessor = function () {
            return true;
        };

        PullAccessorSymbol.prototype.setSetter = function (setter) {
            if (!setter) {
                return;
            }

            this._setterSymbol = setter;

            setter.setAccessorSymbol(this);
        };

        PullAccessorSymbol.prototype.getSetter = function () {
            return this._setterSymbol;
        };

        PullAccessorSymbol.prototype.setGetter = function (getter) {
            if (!getter) {
                return;
            }

            this._getterSymbol = getter;

            getter.setAccessorSymbol(this);
        };

        PullAccessorSymbol.prototype.getGetter = function () {
            return this._getterSymbol;
        };

        PullAccessorSymbol.prototype.invalidate = function () {
            if (this._getterSymbol) {
                this._getterSymbol.invalidate();
            }

            if (this._setterSymbol) {
                this._setterSymbol.invalidate();
            }

            _super.prototype.invalidate.call(this);
        };
        return PullAccessorSymbol;
    })(PullSymbol);
    TypeScript.PullAccessorSymbol = PullAccessorSymbol;

    function typeWrapsTypeParameter(type, typeParameter) {
        if (type.isTypeParameter()) {
            return type == typeParameter;
        }

        var typeArguments = type.getTypeArguments();

        if (typeArguments) {
            for (var i = 0; i < typeArguments.length; i++) {
                if (typeWrapsTypeParameter(typeArguments[i], typeParameter)) {
                    return true;
                }
            }
        }

        return false;
    }
    TypeScript.typeWrapsTypeParameter = typeWrapsTypeParameter;

    function getRootType(typeToSpecialize) {
        var decl = typeToSpecialize.getDeclarations()[0];

        if (!typeToSpecialize.isGeneric()) {
            return typeToSpecialize;
        }

        return (typeToSpecialize.kind & (8 /* Class */ | 16 /* Interface */)) ? decl.getSymbol().type : typeToSpecialize;
    }
    TypeScript.getRootType = getRootType;

    TypeScript.nSpecializationsCreated = 0;
    TypeScript.nSpecializedSignaturesCreated = 0;

    function shouldSpecializeTypeParameterForTypeParameter(specialization, typeToSpecialize) {
        if (specialization == typeToSpecialize) {
            return false;
        }

        if (!(specialization.isTypeParameter() && typeToSpecialize.isTypeParameter())) {
            return true;
        }

        var parent = specialization.getDeclarations()[0].getParentDecl();
        var targetParent = typeToSpecialize.getDeclarations()[0].getParentDecl();

        if (parent == targetParent) {
            return true;
        }

        while (parent) {
            if (parent.flags & 16 /* Static */) {
                return true;
            }

            if (parent == targetParent) {
                return false;
            }

            parent = parent.getParentDecl();
        }

        return true;
    }
    TypeScript.shouldSpecializeTypeParameterForTypeParameter = shouldSpecializeTypeParameterForTypeParameter;

    function specializeType(typeToSpecialize, typeArguments, resolver, enclosingDecl, context, ast) {
        if (typeToSpecialize.isPrimitive() || !typeToSpecialize.isGeneric()) {
            return typeToSpecialize;
        }

        var searchForExistingSpecialization = typeArguments != null;

        if (typeArguments === null || (context.specializingToAny && typeArguments.length)) {
            typeArguments = [];
        }

        if (typeToSpecialize.isTypeParameter()) {
            if (context.specializingToAny) {
                return resolver.semanticInfoChain.anyTypeSymbol;
            }

            var substitution = context.findSpecializationForType(typeToSpecialize);

            if (substitution != typeToSpecialize) {
                if (shouldSpecializeTypeParameterForTypeParameter(substitution, typeToSpecialize)) {
                    return substitution;
                }
            }

            if (typeArguments && typeArguments.length) {
                if (shouldSpecializeTypeParameterForTypeParameter(typeArguments[0], typeToSpecialize)) {
                    return typeArguments[0];
                }
            }

            return typeToSpecialize;
        }

        if (typeToSpecialize.isArray()) {
            if (typeToSpecialize.currentlyBeingSpecialized()) {
                return typeToSpecialize;
            }

            var newElementType = null;

            if (!context.specializingToAny) {
                var elementType = typeToSpecialize.getElementType();

                newElementType = specializeType(elementType, typeArguments, resolver, enclosingDecl, context, ast);
            } else {
                newElementType = resolver.semanticInfoChain.anyTypeSymbol;
            }

            var newArrayType = specializeType(resolver.getCachedArrayType(), [newElementType], resolver, enclosingDecl, context);

            return newArrayType;
        }

        var typeParameters = typeToSpecialize.getTypeParameters();

        if (!context.specializingToAny && searchForExistingSpecialization && (typeParameters.length > typeArguments.length)) {
            searchForExistingSpecialization = false;
        }

        var newType = null;

        var newTypeDecl = typeToSpecialize.getDeclarations()[0];

        var rootType = getRootType(typeToSpecialize);

        var isArray = typeToSpecialize === resolver.getCachedArrayType() || typeToSpecialize.isArray();

        if (searchForExistingSpecialization || context.specializingToAny || typeToSpecialize.hasRecursiveSpecializationError) {
            if (!typeArguments.length || context.specializingToAny || typeToSpecialize.hasRecursiveSpecializationError) {
                for (var i = 0; i < typeParameters.length; i++) {
                    typeArguments[i] = resolver.semanticInfoChain.anyTypeSymbol;
                }
            }

            if (isArray) {
                newType = typeArguments[0].getArrayType();
            } else if (typeArguments.length) {
                newType = rootType.getSpecialization(typeArguments);
            }

            if (!newType && !typeParameters.length && context.specializingToAny) {
                newType = rootType.getSpecialization([resolver.semanticInfoChain.anyTypeSymbol]);
            }

            for (var i = 0; i < typeArguments.length; i++) {
                if (!typeArguments[i].isTypeParameter() && (typeArguments[i] == rootType || typeWrapsTypeParameter(typeArguments[i], typeParameters[i]))) {
                    declAST = resolver.semanticInfoChain.getASTForDecl(newTypeDecl);
                    if (declAST && typeArguments[i] != resolver.getCachedArrayType()) {
                        diagnostic = context.postError(enclosingDecl.getScriptName(), declAST.minChar, declAST.getLength(), TypeScript.DiagnosticCode.A_generic_type_may_not_reference_itself_with_a_wrapped_form_of_its_own_type_parameters, null, enclosingDecl);
                        typeToSpecialize.hasRecursiveSpecializationError = true;
                        return resolver.getNewErrorTypeSymbol(diagnostic);
                    } else {
                        return resolver.semanticInfoChain.anyTypeSymbol;
                    }
                }
            }
        } else {
            var knownTypeArguments = typeToSpecialize.getTypeArguments();
            var typesToReplace = knownTypeArguments ? knownTypeArguments : typeParameters;
            var diagnostic;
            var declAST;

            for (var i = 0; i < typesToReplace.length; i++) {
                if (!typesToReplace[i].isTypeParameter() && (typeArguments[i] == rootType || typeWrapsTypeParameter(typesToReplace[i], typeParameters[i]))) {
                    declAST = resolver.semanticInfoChain.getASTForDecl(newTypeDecl);
                    if (declAST && typeArguments[i] != resolver.getCachedArrayType()) {
                        diagnostic = context.postError(enclosingDecl.getScriptName(), declAST.minChar, declAST.getLength(), TypeScript.DiagnosticCode.A_generic_type_may_not_reference_itself_with_a_wrapped_form_of_its_own_type_parameters, null, enclosingDecl);
                        typeToSpecialize.hasRecursiveSpecializationError = true;
                        return resolver.getNewErrorTypeSymbol(diagnostic);
                    } else {
                        return resolver.semanticInfoChain.anyTypeSymbol;
                    }
                }

                substitution = specializeType(typesToReplace[i], null, resolver, enclosingDecl, context, ast);

                typeArguments[i] = substitution != null ? substitution : typesToReplace[i];
            }

            newType = rootType.getSpecialization(typeArguments);
        }

        var rootTypeParameters = rootType.getTypeParameters();

        if (rootTypeParameters.length && (rootTypeParameters.length == typeArguments.length)) {
            for (var i = 0; i < typeArguments.length; i++) {
                if (typeArguments[i] != rootTypeParameters[i]) {
                    break;
                }
            }

            if (i == rootTypeParameters.length) {
                return rootType;
            }
        }

        if (newType) {
            if (!newType.isResolved && !newType.currentlyBeingSpecialized()) {
            } else {
                return newType;
            }
        }

        var prevInSpecialization = context.inSpecialization;
        context.inSpecialization = true;

        if (!newType) {
            TypeScript.nSpecializationsCreated++;

            newType = typeToSpecialize.isClass() ? new PullTypeSymbol(typeToSpecialize.name, 8 /* Class */) : isArray ? new PullTypeSymbol("Array", 128 /* Array */) : typeToSpecialize.isTypeParameter() ? new PullTypeVariableSymbol(typeToSpecialize.name, (typeToSpecialize).isFunctionTypeParameter()) : new PullTypeSymbol(typeToSpecialize.name, typeToSpecialize.kind);
            newType.setRootSymbol(rootType);
        }

        newType.setIsBeingSpecialized();

        newType.setTypeArguments(typeArguments);

        newType.hasRecursiveSpecializationError = typeToSpecialize.hasRecursiveSpecializationError;

        rootType.addSpecialization(newType, typeArguments);

        if (isArray) {
            newType.setElementType(typeArguments[0]);
            typeArguments[0].setArrayType(newType);
        }

        if (typeToSpecialize.currentlyBeingSpecialized()) {
            return newType;
        }

        var prevCurrentlyBeingSpecialized = typeToSpecialize.currentlyBeingSpecialized();
        if (typeToSpecialize.kind == 33554432 /* ConstructorType */) {
            typeToSpecialize.setIsBeingSpecialized();
        }

        var typeReplacementMap = {};

        for (var i = 0; i < typeParameters.length; i++) {
            if (typeParameters[i] != typeArguments[i]) {
                typeReplacementMap[typeParameters[i].pullSymbolIDString] = typeArguments[i];
            }
            newType.addTypeParameter(typeParameters[i]);
        }

        var extendedTypesToSpecialize = typeToSpecialize.getExtendedTypes();
        var typeDecl;
        var typeAST;
        var unitPath;
        var decls = typeToSpecialize.getDeclarations();
        var extendTypeSymbol = null;
        var implementedTypeSymbol = null;

        if (extendedTypesToSpecialize.length) {
            for (var i = 0; i < decls.length; i++) {
                typeDecl = decls[i];
                typeAST = resolver.semanticInfoChain.getASTForDecl(typeDecl);

                if (typeAST.extendsList) {
                    unitPath = resolver.getUnitPath();
                    resolver.setUnitPath(typeDecl.getScriptName());
                    for (var j = 0; j < typeAST.extendsList.members.length; j++) {
                        context.pushTypeSpecializationCache(typeReplacementMap);
                        extendTypeSymbol = resolver.resolveTypeReference(new TypeScript.TypeReference(typeAST.extendsList.members[j], 0), typeDecl, context);
                        resolver.setUnitPath(unitPath);
                        context.popTypeSpecializationCache();

                        newType.addExtendedType(extendTypeSymbol);
                    }
                }
            }
        }

        var implementedTypesToSpecialize = typeToSpecialize.getImplementedTypes();

        if (implementedTypesToSpecialize.length) {
            for (var i = 0; i < decls.length; i++) {
                typeDecl = decls[i];
                typeAST = resolver.semanticInfoChain.getASTForDecl(typeDecl);

                if (typeAST.implementsList) {
                    unitPath = resolver.getUnitPath();
                    resolver.setUnitPath(typeDecl.getScriptName());
                    for (var j = 0; j < typeAST.implementsList.members.length; j++) {
                        context.pushTypeSpecializationCache(typeReplacementMap);
                        implementedTypeSymbol = resolver.resolveTypeReference(new TypeScript.TypeReference(typeAST.implementsList.members[j], 0), typeDecl, context);
                        resolver.setUnitPath(unitPath);
                        context.popTypeSpecializationCache();

                        newType.addImplementedType(implementedTypeSymbol);
                    }
                }
            }
        }

        var callSignatures = typeToSpecialize.getCallSignatures(false);
        var constructSignatures = typeToSpecialize.getConstructSignatures(false);
        var indexSignatures = typeToSpecialize.getIndexSignatures(false);
        var members = typeToSpecialize.getMembers();

        var newSignature;
        var placeHolderSignature;
        var signature;

        var decl = null;
        var declAST = null;
        var parameters;
        var newParameters;
        var returnType = null;
        var prevSpecializationSignature = null;

        for (var i = 0; i < callSignatures.length; i++) {
            signature = callSignatures[i];

            if (!signature.currentlyBeingSpecialized()) {
                context.pushTypeSpecializationCache(typeReplacementMap);

                decl = signature.getDeclarations()[0];
                unitPath = resolver.getUnitPath();
                resolver.setUnitPath(decl.getScriptName());

                newSignature = new PullSignatureSymbol(signature.kind);
                TypeScript.nSpecializedSignaturesCreated++;
                newSignature.mimicSignature(signature, resolver);
                declAST = resolver.semanticInfoChain.getASTForDecl(decl);

                TypeScript.Debug.assert(declAST != null, "Call signature for type '" + typeToSpecialize.toString() + "' could not be specialized because of a stale declaration");

                prevSpecializationSignature = decl.getSpecializingSignatureSymbol();
                decl.setSpecializingSignatureSymbol(newSignature);

                if (!(signature.isResolved || signature.inResolution)) {
                    resolver.resolveDeclaredSymbol(signature, enclosingDecl, new TypeScript.PullTypeResolutionContext());
                }

                resolver.resolveAST(declAST, false, newTypeDecl, context, true);
                decl.setSpecializingSignatureSymbol(prevSpecializationSignature);

                parameters = signature.parameters;
                newParameters = newSignature.parameters;

                for (var p = 0; p < parameters.length; p++) {
                    newParameters[p].type = parameters[p].type;
                }
                newSignature.setResolved();

                resolver.setUnitPath(unitPath);

                returnType = newSignature.returnType;

                if (!returnType) {
                    newSignature.returnType = signature.returnType;
                }

                signature.setIsBeingSpecialized();
                newSignature.setRootSymbol(signature);
                placeHolderSignature = newSignature;
                newSignature = specializeSignature(newSignature, true, typeReplacementMap, null, resolver, newTypeDecl, context);
                signature.setIsSpecialized();

                if (newSignature != placeHolderSignature) {
                    newSignature.setRootSymbol(signature);
                }

                context.popTypeSpecializationCache();

                if (!newSignature) {
                    context.inSpecialization = prevInSpecialization;
                    typeToSpecialize.setValueIsBeingSpecialized(prevCurrentlyBeingSpecialized);
                    TypeScript.Debug.assert(false, "returning from call");
                    return resolver.semanticInfoChain.anyTypeSymbol;
                }
            } else {
                newSignature = signature;
            }

            newType.addCallSignature(newSignature);

            if (newSignature.hasAGenericParameter) {
                newType.setHasGenericSignature();
            }
        }

        for (var i = 0; i < constructSignatures.length; i++) {
            signature = constructSignatures[i];

            if (!signature.currentlyBeingSpecialized()) {
                context.pushTypeSpecializationCache(typeReplacementMap);

                decl = signature.getDeclarations()[0];
                unitPath = resolver.getUnitPath();
                resolver.setUnitPath(decl.getScriptName());

                newSignature = new PullSignatureSymbol(signature.kind);
                TypeScript.nSpecializedSignaturesCreated++;
                newSignature.mimicSignature(signature, resolver);
                declAST = resolver.semanticInfoChain.getASTForDecl(decl);

                TypeScript.Debug.assert(declAST != null, "Construct signature for type '" + typeToSpecialize.toString() + "' could not be specialized because of a stale declaration");

                prevSpecializationSignature = decl.getSpecializingSignatureSymbol();
                decl.setSpecializingSignatureSymbol(newSignature);

                if (!(signature.isResolved || signature.inResolution)) {
                    resolver.resolveDeclaredSymbol(signature, enclosingDecl, new TypeScript.PullTypeResolutionContext());
                }

                resolver.resolveAST(declAST, false, newTypeDecl, context, true);
                decl.setSpecializingSignatureSymbol(prevSpecializationSignature);

                parameters = signature.parameters;
                newParameters = newSignature.parameters;

                for (var p = 0; p < parameters.length; p++) {
                    newParameters[p].type = parameters[p].type;
                }
                newSignature.setResolved();

                resolver.setUnitPath(unitPath);

                returnType = newSignature.returnType;

                if (!returnType) {
                    newSignature.returnType = signature.returnType;
                }

                signature.setIsBeingSpecialized();
                newSignature.setRootSymbol(signature);
                placeHolderSignature = newSignature;
                newSignature = specializeSignature(newSignature, true, typeReplacementMap, null, resolver, newTypeDecl, context);
                signature.setIsSpecialized();

                if (newSignature != placeHolderSignature) {
                    newSignature.setRootSymbol(signature);
                }

                context.popTypeSpecializationCache();

                if (!newSignature) {
                    context.inSpecialization = prevInSpecialization;
                    typeToSpecialize.setValueIsBeingSpecialized(prevCurrentlyBeingSpecialized);
                    TypeScript.Debug.assert(false, "returning from construct");
                    return resolver.semanticInfoChain.anyTypeSymbol;
                }
            } else {
                newSignature = signature;
            }

            newType.addConstructSignature(newSignature);

            if (newSignature.hasAGenericParameter) {
                newType.setHasGenericSignature();
            }
        }

        for (var i = 0; i < indexSignatures.length; i++) {
            signature = indexSignatures[i];

            if (!signature.currentlyBeingSpecialized()) {
                context.pushTypeSpecializationCache(typeReplacementMap);

                decl = signature.getDeclarations()[0];
                unitPath = resolver.getUnitPath();
                resolver.setUnitPath(decl.getScriptName());

                newSignature = new PullSignatureSymbol(signature.kind);
                TypeScript.nSpecializedSignaturesCreated++;
                newSignature.mimicSignature(signature, resolver);
                declAST = resolver.semanticInfoChain.getASTForDecl(decl);

                TypeScript.Debug.assert(declAST != null, "Index signature for type '" + typeToSpecialize.toString() + "' could not be specialized because of a stale declaration");

                prevSpecializationSignature = decl.getSpecializingSignatureSymbol();
                decl.setSpecializingSignatureSymbol(newSignature);

                if (!(signature.isResolved || signature.inResolution)) {
                    resolver.resolveDeclaredSymbol(signature, enclosingDecl, new TypeScript.PullTypeResolutionContext());
                }

                resolver.resolveAST(declAST, false, newTypeDecl, context, true);
                decl.setSpecializingSignatureSymbol(prevSpecializationSignature);

                parameters = signature.parameters;
                newParameters = newSignature.parameters;

                for (var p = 0; p < parameters.length; p++) {
                    newParameters[p].type = parameters[p].type;
                }
                newSignature.setResolved();

                resolver.setUnitPath(unitPath);

                returnType = newSignature.returnType;

                if (!returnType) {
                    newSignature.returnType = signature.returnType;
                }

                signature.setIsBeingSpecialized();
                newSignature.setRootSymbol(signature);
                placeHolderSignature = newSignature;
                newSignature = specializeSignature(newSignature, true, typeReplacementMap, null, resolver, newTypeDecl, context);
                signature.setIsSpecialized();

                if (newSignature != placeHolderSignature) {
                    newSignature.setRootSymbol(signature);
                }

                context.popTypeSpecializationCache();

                if (!newSignature) {
                    context.inSpecialization = prevInSpecialization;
                    typeToSpecialize.setValueIsBeingSpecialized(prevCurrentlyBeingSpecialized);
                    TypeScript.Debug.assert(false, "returning from index");
                    return resolver.semanticInfoChain.anyTypeSymbol;
                }
            } else {
                newSignature = signature;
            }

            newType.addIndexSignature(newSignature);

            if (newSignature.hasAGenericParameter) {
                newType.setHasGenericSignature();
            }
        }

        var field = null;
        var newField = null;

        var fieldType = null;
        var newFieldType = null;
        var replacementType = null;

        var fieldSignatureSymbol = null;

        for (var i = 0; i < members.length; i++) {
            field = members[i];
            field.setIsBeingSpecialized();

            decls = field.getDeclarations();

            newField = new PullSymbol(field.name, field.kind);

            newField.setRootSymbol(field);

            if (field.isOptional) {
                newField.isOptional = true;
            }

            if (!field.isResolved) {
                resolver.resolveDeclaredSymbol(field, newTypeDecl, context);
            }

            fieldType = field.type;

            if (!fieldType) {
                fieldType = newType;
            }

            replacementType = typeReplacementMap[fieldType.pullSymbolIDString];

            if (replacementType) {
                newField.type = replacementType;
            } else {
                if (fieldType.isGeneric() && !fieldType.isFixed()) {
                    unitPath = resolver.getUnitPath();
                    resolver.setUnitPath(decls[0].getScriptName());

                    context.pushTypeSpecializationCache(typeReplacementMap);

                    newFieldType = specializeType(fieldType, !fieldType.getIsSpecialized() ? typeArguments : null, resolver, newTypeDecl, context, ast);

                    resolver.setUnitPath(unitPath);

                    context.popTypeSpecializationCache();

                    newField.type = newFieldType;
                } else {
                    newField.type = fieldType;
                }
            }
            field.setIsSpecialized();
            newType.addMember(newField);
        }

        if (typeToSpecialize.isClass()) {
            var constructorMethod = typeToSpecialize.getConstructorMethod();

            if (!constructorMethod.isResolved) {
                var prevIsSpecializingConstructorMethod = context.isSpecializingConstructorMethod;
                context.isSpecializingConstructorMethod = true;
                resolver.resolveDeclaredSymbol(constructorMethod, enclosingDecl, context);
                context.isSpecializingConstructorMethod = prevIsSpecializingConstructorMethod;
            }

            var newConstructorMethod = new PullSymbol(constructorMethod.name, 32768 /* ConstructorMethod */);
            var newConstructorType = specializeType(constructorMethod.type, typeArguments, resolver, newTypeDecl, context, ast);

            newConstructorMethod.type = newConstructorType;

            var constructorDecls = constructorMethod.getDeclarations();

            newConstructorMethod.setRootSymbol(constructorMethod);

            newType.setConstructorMethod(newConstructorMethod);
        }

        newType.setIsSpecialized();

        newType.setResolved();
        typeToSpecialize.setValueIsBeingSpecialized(prevCurrentlyBeingSpecialized);
        context.inSpecialization = prevInSpecialization;
        return newType;
    }
    TypeScript.specializeType = specializeType;

    function specializeSignature(signature, skipLocalTypeParameters, typeReplacementMap, typeArguments, resolver, enclosingDecl, context, ast) {
        if (signature.currentlyBeingSpecialized()) {
            return signature;
        }

        if (!signature.isResolved && !signature.inResolution) {
            resolver.resolveDeclaredSymbol(signature, enclosingDecl, context);
        }

        var newSignature = signature.getSpecialization(typeArguments);

        if (newSignature) {
            return newSignature;
        }

        signature.setIsBeingSpecialized();

        var prevInSpecialization = context.inSpecialization;
        context.inSpecialization = true;

        newSignature = new PullSignatureSymbol(signature.kind);
        TypeScript.nSpecializedSignaturesCreated++;
        newSignature.setRootSymbol(signature);

        if (signature.hasVarArgs) {
            newSignature.hasVarArgs = true;
        }

        if (signature.hasAGenericParameter) {
            newSignature.hasAGenericParameter = true;
        }

        signature.addSpecialization(newSignature, typeArguments);

        var parameters = signature.parameters;
        var typeParameters = signature.getTypeParameters();
        var returnType = signature.returnType;

        for (var i = 0; i < typeParameters.length; i++) {
            newSignature.addTypeParameter(typeParameters[i]);
        }

        if (signature.hasAGenericParameter) {
            newSignature.hasAGenericParameter = true;
        }

        var newParameter;
        var newParameterType;
        var newParameterElementType;
        var parameterType;
        var replacementParameterType;
        var localTypeParameters = new TypeScript.BlockIntrinsics();
        var localSkipMap = null;

        if (skipLocalTypeParameters) {
            for (var i = 0; i < typeParameters.length; i++) {
                localTypeParameters[typeParameters[i].getName()] = true;
                if (!localSkipMap) {
                    localSkipMap = {};
                }
                localSkipMap[typeParameters[i].pullSymbolIDString] = typeParameters[i];
            }
        }

        context.pushTypeSpecializationCache(typeReplacementMap);

        if (skipLocalTypeParameters && localSkipMap) {
            context.pushTypeSpecializationCache(localSkipMap);
        }
        var newReturnType = (!localTypeParameters[returnType.name]) ? specializeType(returnType, null, resolver, enclosingDecl, context, ast) : returnType;
        if (skipLocalTypeParameters && localSkipMap) {
            context.popTypeSpecializationCache();
        }
        context.popTypeSpecializationCache();

        newSignature.returnType = newReturnType;

        for (var k = 0; k < parameters.length; k++) {
            newParameter = new PullSymbol(parameters[k].name, parameters[k].kind);
            newParameter.setRootSymbol(parameters[k]);

            parameterType = parameters[k].type;

            context.pushTypeSpecializationCache(typeReplacementMap);
            if (skipLocalTypeParameters && localSkipMap) {
                context.pushTypeSpecializationCache(localSkipMap);
            }
            newParameterType = !localTypeParameters[parameterType.name] ? specializeType(parameterType, null, resolver, enclosingDecl, context, ast) : parameterType;
            if (skipLocalTypeParameters && localSkipMap) {
                context.popTypeSpecializationCache();
            }
            context.popTypeSpecializationCache();

            if (parameters[k].isOptional) {
                newParameter.isOptional = true;
            }

            if (parameters[k].isVarArg) {
                newParameter.isVarArg = true;
                newSignature.hasVarArgs = true;
            }

            if (resolver.isTypeArgumentOrWrapper(newParameterType)) {
                newSignature.hasAGenericParameter = true;
            }

            newParameter.type = newParameterType;
            newSignature.addParameter(newParameter, newParameter.isOptional);
        }

        signature.setIsSpecialized();

        context.inSpecialization = prevInSpecialization;

        return newSignature;
    }
    TypeScript.specializeSignature = specializeSignature;

    function getIDForTypeSubstitutions(types) {
        var substitution = "";

        for (var i = 0; i < types.length; i++) {
            substitution += types[i].pullSymbolIDString + "#";
        }

        return substitution;
    }
    TypeScript.getIDForTypeSubstitutions = getIDForTypeSubstitutions;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var PullSymbolBindingContext = (function () {
        function PullSymbolBindingContext(semanticInfoChain, scriptName) {
            this.semanticInfoChain = semanticInfoChain;
            this.scriptName = scriptName;
            this.parentChain = [];
            this.declPath = [];
            this.reBindingAfterChange = false;
            this.startingDeclForRebind = TypeScript.pullDeclID;
            this.semanticInfo = this.semanticInfoChain.getUnit(this.scriptName);
        }
        PullSymbolBindingContext.prototype.getParent = function (n) {
            if (typeof n === "undefined") { n = 0; }
            return this.parentChain ? this.parentChain[this.parentChain.length - 1 - n] : null;
        };
        PullSymbolBindingContext.prototype.getDeclPath = function () {
            return this.declPath;
        };

        PullSymbolBindingContext.prototype.pushParent = function (parentDecl) {
            if (parentDecl) {
                this.parentChain[this.parentChain.length] = parentDecl;
                this.declPath[this.declPath.length] = parentDecl.name;
            }
        };

        PullSymbolBindingContext.prototype.popParent = function () {
            if (this.parentChain.length) {
                this.parentChain.length--;
                this.declPath.length--;
            }
        };
        return PullSymbolBindingContext;
    })();
    TypeScript.PullSymbolBindingContext = PullSymbolBindingContext;

    TypeScript.time_in_findSymbol = 0;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var CandidateInferenceInfo = (function () {
        function CandidateInferenceInfo() {
            this.typeParameter = null;
            this.isFixed = false;
            this.inferenceCandidates = [];
        }
        CandidateInferenceInfo.prototype.addCandidate = function (candidate) {
            if (!this.isFixed) {
                this.inferenceCandidates[this.inferenceCandidates.length] = candidate;
            }
        };
        return CandidateInferenceInfo;
    })();
    TypeScript.CandidateInferenceInfo = CandidateInferenceInfo;

    var ArgumentInferenceContext = (function () {
        function ArgumentInferenceContext() {
            this.inferenceCache = {};
            this.candidateCache = {};
        }
        ArgumentInferenceContext.prototype.alreadyRelatingTypes = function (objectType, parameterType) {
            var comboID = objectType.pullSymbolIDString + "#" + parameterType.pullSymbolIDString;

            if (this.inferenceCache[comboID]) {
                return true;
            } else {
                this.inferenceCache[comboID] = true;
                return false;
            }
        };

        ArgumentInferenceContext.prototype.resetRelationshipCache = function () {
            this.inferenceCache = {};
        };

        ArgumentInferenceContext.prototype.addInferenceRoot = function (param) {
            var info = this.candidateCache[param.pullSymbolIDString];

            if (!info) {
                info = new CandidateInferenceInfo();
                info.typeParameter = param;
                this.candidateCache[param.pullSymbolIDString] = info;
            }
        };

        ArgumentInferenceContext.prototype.getInferenceInfo = function (param) {
            return this.candidateCache[param.pullSymbolIDString];
        };

        ArgumentInferenceContext.prototype.addCandidateForInference = function (param, candidate, fix) {
            var info = this.getInferenceInfo(param);

            if (info) {
                if (candidate) {
                    info.addCandidate(candidate);
                }

                if (!info.isFixed) {
                    info.isFixed = fix;
                }
            }
        };

        ArgumentInferenceContext.prototype.getInferenceCandidates = function () {
            var inferenceCandidates = [];
            var info;
            var val;

            for (var infoKey in this.candidateCache) {
                info = this.candidateCache[infoKey];

                for (var i = 0; i < info.inferenceCandidates.length; i++) {
                    val = {};
                    val[info.typeParameter.pullSymbolIDString] = info.inferenceCandidates[i];
                    inferenceCandidates[inferenceCandidates.length] = val;
                }
            }

            return inferenceCandidates;
        };

        ArgumentInferenceContext.prototype.inferArgumentTypes = function (resolver, context) {
            var info = null;

            var collection;

            var bestCommonType;

            var results = [];

            var unfit = false;

            for (var infoKey in this.candidateCache) {
                info = this.candidateCache[infoKey];

                if (!info.inferenceCandidates.length) {
                    results[results.length] = { param: info.typeParameter, type: resolver.semanticInfoChain.anyTypeSymbol };
                    continue;
                }

                collection = {
                    getLength: function () {
                        return info.inferenceCandidates.length;
                    },
                    setTypeAtIndex: function (index, type) {
                    },
                    getTypeAtIndex: function (index) {
                        return info.inferenceCandidates[index].type;
                    }
                };

                bestCommonType = resolver.widenType(resolver.findBestCommonType(info.inferenceCandidates[0], null, collection, context, new TypeScript.TypeComparisonInfo()));

                if (!bestCommonType) {
                    unfit = true;
                } else {
                    for (var i = 0; i < results.length; i++) {
                        if (results[i].type == info.typeParameter) {
                            results[i].type = bestCommonType;
                        }
                    }
                }

                results[results.length] = { param: info.typeParameter, type: bestCommonType };
            }

            return { results: results, unfit: unfit };
        };
        return ArgumentInferenceContext;
    })();
    TypeScript.ArgumentInferenceContext = ArgumentInferenceContext;

    var PullContextualTypeContext = (function () {
        function PullContextualTypeContext(contextualType, provisional, substitutions) {
            this.contextualType = contextualType;
            this.provisional = provisional;
            this.substitutions = substitutions;
            this.provisionallyTypedSymbols = [];
            this.provisionalDiagnostic = [];
        }
        PullContextualTypeContext.prototype.recordProvisionallyTypedSymbol = function (symbol) {
            this.provisionallyTypedSymbols[this.provisionallyTypedSymbols.length] = symbol;
        };

        PullContextualTypeContext.prototype.invalidateProvisionallyTypedSymbols = function () {
            for (var i = 0; i < this.provisionallyTypedSymbols.length; i++) {
                this.provisionallyTypedSymbols[i].invalidate();
            }
        };

        PullContextualTypeContext.prototype.postDiagnostic = function (error) {
            this.provisionalDiagnostic[this.provisionalDiagnostic.length] = error;
        };

        PullContextualTypeContext.prototype.hadProvisionalErrors = function () {
            return this.provisionalDiagnostic.length > 0;
        };
        return PullContextualTypeContext;
    })();
    TypeScript.PullContextualTypeContext = PullContextualTypeContext;

    var PullTypeResolutionContext = (function () {
        function PullTypeResolutionContext(inTypeCheck) {
            if (typeof inTypeCheck === "undefined") { inTypeCheck = false; }
            this.inTypeCheck = inTypeCheck;
            this.contextStack = [];
            this.typeSpecializationStack = [];
            this.genericASTResolutionStack = [];
            this.resolvingTypeReference = false;
            this.resolvingNamespaceMemberAccess = false;
            this.resolveAggressively = false;
            this.canUseTypeSymbol = false;
            this.specializingToAny = false;
            this.specializingToObject = false;
            this.isResolvingClassExtendedType = false;
            this.isSpecializingSignatureAtCallSite = false;
            this.isSpecializingConstructorMethod = false;
            this.isComparingSpecializedSignatures = false;
            this.isResolvingSuperConstructorTarget = false;
            this.inConstructorArguments = false;
            this.inImportDeclaration = false;
            this.isInStaticInitializer = false;
            this.isInInvocationExpression = false;
            this.resolvingTypeNameAsNameExpression = false;
            this.inSpecialization = false;
            this.suppressErrors = false;
            this.inBaseTypeResolution = false;
        }
        PullTypeResolutionContext.prototype.pushContextualType = function (type, provisional, substitutions) {
            this.contextStack.push(new PullContextualTypeContext(type, provisional, substitutions));
        };

        PullTypeResolutionContext.prototype.popContextualType = function () {
            var tc = this.contextStack.pop();

            tc.invalidateProvisionallyTypedSymbols();

            return tc;
        };

        PullTypeResolutionContext.prototype.findSubstitution = function (type) {
            var substitution = null;

            if (this.contextStack.length) {
                for (var i = this.contextStack.length - 1; i >= 0; i--) {
                    if (this.contextStack[i].substitutions) {
                        substitution = this.contextStack[i].substitutions[type.pullSymbolIDString];

                        if (substitution) {
                            break;
                        }
                    }
                }
            }

            return substitution;
        };

        PullTypeResolutionContext.prototype.getContextualType = function () {
            var context = !this.contextStack.length ? null : this.contextStack[this.contextStack.length - 1];

            if (context) {
                var type = context.contextualType;

                if (!type) {
                    return null;
                }

                if (type.isTypeParameter() && (type).getConstraint()) {
                    type = (type).getConstraint();
                }

                var substitution = this.findSubstitution(type);

                return substitution ? substitution : type;
            }

            return null;
        };

        PullTypeResolutionContext.prototype.inProvisionalResolution = function () {
            return (!this.contextStack.length ? false : this.contextStack[this.contextStack.length - 1].provisional);
        };

        PullTypeResolutionContext.prototype.isInBaseTypeResolution = function () {
            return this.inBaseTypeResolution;
        };

        PullTypeResolutionContext.prototype.startBaseTypeResolution = function () {
            var wasInBaseTypeResoltion = this.inBaseTypeResolution;
            this.inBaseTypeResolution = true;
            return wasInBaseTypeResoltion;
        };

        PullTypeResolutionContext.prototype.doneBaseTypeResolution = function (wasInBaseTypeResolution) {
            this.inBaseTypeResolution = wasInBaseTypeResolution;
        };

        PullTypeResolutionContext.prototype.setTypeInContext = function (symbol, type) {
            var substitution = this.findSubstitution(type);

            symbol.type = substitution ? substitution : type;

            if (this.contextStack.length && this.inProvisionalResolution()) {
                this.contextStack[this.contextStack.length - 1].recordProvisionallyTypedSymbol(symbol);
            }
        };

        PullTypeResolutionContext.prototype.pushTypeSpecializationCache = function (cache) {
            this.typeSpecializationStack[this.typeSpecializationStack.length] = cache;
        };

        PullTypeResolutionContext.prototype.popTypeSpecializationCache = function () {
            if (this.typeSpecializationStack.length) {
                this.typeSpecializationStack.length--;
            }
        };

        PullTypeResolutionContext.prototype.findSpecializationForType = function (type) {
            var specialization = null;

            for (var i = this.typeSpecializationStack.length - 1; i >= 0; i--) {
                specialization = (this.typeSpecializationStack[i])[type.pullSymbolIDString];

                if (specialization) {
                    return specialization;
                }
            }

            return type;
        };

        PullTypeResolutionContext.prototype.postError = function (fileName, offset, length, diagnosticKey, arguments, enclosingDecl, post) {
            if (typeof post === "undefined") { post = true; }
            var diagnostic = new TypeScript.Diagnostic(fileName, offset, length, diagnosticKey, arguments);

            if (post) {
                this.postDiagnostic(diagnostic, enclosingDecl);
            }

            return diagnostic;
        };

        PullTypeResolutionContext.prototype.postDiagnostic = function (diagnostic, enclosingDecl) {
            if (this.inProvisionalResolution()) {
                (this.contextStack[this.contextStack.length - 1]).postDiagnostic(diagnostic);
            } else if (this.inTypeCheck && !this.suppressErrors && enclosingDecl) {
                enclosingDecl.addDiagnostic(diagnostic);
            }
        };

        PullTypeResolutionContext.prototype.typeCheck = function () {
            return this.inTypeCheck && !this.inSpecialization;
        };

        PullTypeResolutionContext.prototype.startResolvingTypeArguments = function (ast) {
            this.genericASTResolutionStack[this.genericASTResolutionStack.length] = ast;
        };

        PullTypeResolutionContext.prototype.isResolvingTypeArguments = function (ast) {
            for (var i = 0; i < this.genericASTResolutionStack.length; i++) {
                if (this.genericASTResolutionStack[i].astID === ast.astID) {
                    return true;
                }
            }

            return false;
        };

        PullTypeResolutionContext.prototype.doneResolvingTypeArguments = function () {
            this.genericASTResolutionStack.length--;
        };
        return PullTypeResolutionContext;
    })();
    TypeScript.PullTypeResolutionContext = PullTypeResolutionContext;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var PullResolutionDataCache = (function () {
        function PullResolutionDataCache() {
            this.cacheSize = 16;
            this.rdCache = [];
            this.nextUp = 0;
            for (var i = 0; i < this.cacheSize; i++) {
                this.rdCache[i] = {
                    actuals: [],
                    exactCandidates: [],
                    conversionCandidates: [],
                    id: i
                };
            }
        }
        PullResolutionDataCache.prototype.getResolutionData = function () {
            var rd = null;

            if (this.nextUp < this.cacheSize) {
                rd = this.rdCache[this.nextUp];
            }

            if (rd === null) {
                this.cacheSize++;
                rd = {
                    actuals: [],
                    exactCandidates: [],
                    conversionCandidates: [],
                    id: this.cacheSize
                };
                this.rdCache[this.cacheSize] = rd;
            }

            this.nextUp++;

            return rd;
        };

        PullResolutionDataCache.prototype.returnResolutionData = function (rd) {
            rd.actuals.length = 0;
            rd.exactCandidates.length = 0;
            rd.conversionCandidates.length = 0;

            this.nextUp = rd.id;
        };
        return PullResolutionDataCache;
    })();
    TypeScript.PullResolutionDataCache = PullResolutionDataCache;

    var PullAdditionalCallResolutionData = (function () {
        function PullAdditionalCallResolutionData() {
            this.targetSymbol = null;
            this.targetTypeSymbol = null;
            this.resolvedSignatures = null;
            this.candidateSignature = null;
            this.actualParametersContextTypeSymbols = null;
        }
        return PullAdditionalCallResolutionData;
    })();
    TypeScript.PullAdditionalCallResolutionData = PullAdditionalCallResolutionData;

    var PullAdditionalObjectLiteralResolutionData = (function () {
        function PullAdditionalObjectLiteralResolutionData() {
            this.membersContextTypeSymbols = null;
        }
        return PullAdditionalObjectLiteralResolutionData;
    })();
    TypeScript.PullAdditionalObjectLiteralResolutionData = PullAdditionalObjectLiteralResolutionData;

    var PullTypeResolver = (function () {
        function PullTypeResolver(compilationSettings, semanticInfoChain, unitPath) {
            this.compilationSettings = compilationSettings;
            this.semanticInfoChain = semanticInfoChain;
            this.unitPath = unitPath;
            this._cachedArrayInterfaceType = null;
            this._cachedNumberInterfaceType = null;
            this._cachedStringInterfaceType = null;
            this._cachedBooleanInterfaceType = null;
            this._cachedObjectInterfaceType = null;
            this._cachedFunctionInterfaceType = null;
            this._cachedIArgumentsInterfaceType = null;
            this._cachedRegExpInterfaceType = null;
            this.cachedFunctionArgumentsSymbol = null;
            this.seenSuperConstructorCall = false;
            this.assignableCache = {};
            this.subtypeCache = {};
            this.identicalCache = {};
            this.resolutionDataCache = new PullResolutionDataCache();
            this.currentUnit = null;
            this.lastExternalModulePath = "";
            this.cachedFunctionArgumentsSymbol = new TypeScript.PullSymbol("arguments", 1024 /* Variable */);
            this.cachedFunctionArgumentsSymbol.type = this.cachedIArgumentsInterfaceType() ? this.cachedIArgumentsInterfaceType() : this.semanticInfoChain.anyTypeSymbol;
            this.cachedFunctionArgumentsSymbol.setResolved();

            var functionArgumentsDecl = new TypeScript.PullDecl("arguments", "arguments", 2048 /* Parameter */, 0 /* None */, new TypeScript.TextSpan(0, 0), unitPath);
            functionArgumentsDecl.setSymbol(this.cachedFunctionArgumentsSymbol);
            this.cachedFunctionArgumentsSymbol.addDeclaration(functionArgumentsDecl);

            this.currentUnit = this.semanticInfoChain.getUnit(unitPath);
        }
        PullTypeResolver.prototype.cleanCachedGlobals = function () {
            this._cachedArrayInterfaceType = null;
            this._cachedNumberInterfaceType = null;
            this._cachedStringInterfaceType = null;
            this._cachedBooleanInterfaceType = null;
            this._cachedObjectInterfaceType = null;
            this._cachedFunctionInterfaceType = null;
            this._cachedIArgumentsInterfaceType = null;
            this._cachedRegExpInterfaceType = null;
            this.cachedFunctionArgumentsSymbol = null;

            this.identicalCache = {};
            this.subtypeCache = {};
            this.assignableCache = {};
        };

        PullTypeResolver.prototype.cachedArrayInterfaceType = function () {
            if (!this._cachedArrayInterfaceType) {
                this._cachedArrayInterfaceType = this.getSymbolFromDeclPath("Array", [], 16 /* Interface */);
            }

            if (!this._cachedArrayInterfaceType) {
                this._cachedArrayInterfaceType = this.semanticInfoChain.anyTypeSymbol;
            }

            if (!this._cachedArrayInterfaceType.isResolved) {
                this.resolveDeclaredSymbol(this._cachedArrayInterfaceType, null, new TypeScript.PullTypeResolutionContext());
            }

            return this._cachedArrayInterfaceType;
        };

        PullTypeResolver.prototype.getCachedArrayType = function () {
            return this.cachedArrayInterfaceType();
        };

        PullTypeResolver.prototype.cachedNumberInterfaceType = function () {
            if (!this._cachedNumberInterfaceType) {
                this._cachedNumberInterfaceType = this.getSymbolFromDeclPath("Number", [], 16 /* Interface */);
            }

            if (this._cachedNumberInterfaceType && !this._cachedNumberInterfaceType.isResolved) {
                this.resolveDeclaredSymbol(this._cachedNumberInterfaceType, null, new TypeScript.PullTypeResolutionContext());
            }

            return this._cachedNumberInterfaceType;
        };

        PullTypeResolver.prototype.cachedStringInterfaceType = function () {
            if (!this._cachedStringInterfaceType) {
                this._cachedStringInterfaceType = this.getSymbolFromDeclPath("String", [], 16 /* Interface */);
            }

            if (this._cachedStringInterfaceType && !this._cachedStringInterfaceType.isResolved) {
                this.resolveDeclaredSymbol(this._cachedStringInterfaceType, null, new TypeScript.PullTypeResolutionContext());
            }

            return this._cachedStringInterfaceType;
        };

        PullTypeResolver.prototype.cachedBooleanInterfaceType = function () {
            if (!this._cachedBooleanInterfaceType) {
                this._cachedBooleanInterfaceType = this.getSymbolFromDeclPath("Boolean", [], 16 /* Interface */);
            }

            if (this._cachedBooleanInterfaceType && !this._cachedBooleanInterfaceType.isResolved) {
                this.resolveDeclaredSymbol(this._cachedBooleanInterfaceType, null, new TypeScript.PullTypeResolutionContext());
            }

            return this._cachedBooleanInterfaceType;
        };

        PullTypeResolver.prototype.cachedObjectInterfaceType = function () {
            if (!this._cachedObjectInterfaceType) {
                this._cachedObjectInterfaceType = this.getSymbolFromDeclPath("Object", [], 16 /* Interface */);
            }

            if (!this._cachedObjectInterfaceType) {
                this._cachedObjectInterfaceType = this.semanticInfoChain.anyTypeSymbol;
            }

            if (!this._cachedObjectInterfaceType.isResolved) {
                this.resolveDeclaredSymbol(this._cachedObjectInterfaceType, null, new TypeScript.PullTypeResolutionContext());
            }

            return this._cachedObjectInterfaceType;
        };

        PullTypeResolver.prototype.cachedFunctionInterfaceType = function () {
            if (!this._cachedFunctionInterfaceType) {
                this._cachedFunctionInterfaceType = this.getSymbolFromDeclPath("Function", [], 16 /* Interface */);
            }

            if (this._cachedFunctionInterfaceType && !this._cachedFunctionInterfaceType.isResolved) {
                this.resolveDeclaredSymbol(this._cachedFunctionInterfaceType, null, new TypeScript.PullTypeResolutionContext());
            }

            return this._cachedFunctionInterfaceType;
        };

        PullTypeResolver.prototype.cachedIArgumentsInterfaceType = function () {
            if (!this._cachedIArgumentsInterfaceType) {
                this._cachedIArgumentsInterfaceType = this.getSymbolFromDeclPath("IArguments", [], 16 /* Interface */);
            }

            if (this._cachedIArgumentsInterfaceType && !this._cachedIArgumentsInterfaceType.isResolved) {
                this.resolveDeclaredSymbol(this._cachedIArgumentsInterfaceType, null, new TypeScript.PullTypeResolutionContext());
            }

            return this._cachedIArgumentsInterfaceType;
        };

        PullTypeResolver.prototype.cachedRegExpInterfaceType = function () {
            if (!this._cachedRegExpInterfaceType) {
                this._cachedRegExpInterfaceType = this.getSymbolFromDeclPath("RegExp", [], 16 /* Interface */);
            }

            if (!this._cachedRegExpInterfaceType.isResolved) {
                this.resolveDeclaredSymbol(this._cachedRegExpInterfaceType, null, new TypeScript.PullTypeResolutionContext());
            }

            return this._cachedRegExpInterfaceType;
        };

        PullTypeResolver.prototype.getUnitPath = function () {
            return this.unitPath;
        };

        PullTypeResolver.prototype.setUnitPath = function (unitPath) {
            this.unitPath = unitPath;

            this.currentUnit = this.semanticInfoChain.getUnit(unitPath);
        };

        PullTypeResolver.prototype.getDeclForAST = function (ast) {
            return this.semanticInfoChain.getDeclForAST(ast, this.unitPath);
        };

        PullTypeResolver.prototype.getSymbolForAST = function (ast) {
            return this.semanticInfoChain.getSymbolForAST(ast, this.unitPath);
        };

        PullTypeResolver.prototype.setSymbolForAST = function (ast, symbol, context) {
            if (context && (context.inProvisionalResolution() || context.inSpecialization)) {
                return;
            }

            this.semanticInfoChain.setSymbolForAST(ast, symbol, this.unitPath);
        };

        PullTypeResolver.prototype.getASTForSymbol = function (symbol) {
            return this.semanticInfoChain.getASTForSymbol(symbol, this.unitPath);
        };

        PullTypeResolver.prototype.getASTForDecl = function (decl) {
            return this.semanticInfoChain.getASTForDecl(decl);
        };

        PullTypeResolver.prototype.getNewErrorTypeSymbol = function (diagnostic, data) {
            return new TypeScript.PullErrorTypeSymbol(diagnostic, this.semanticInfoChain.anyTypeSymbol, data);
        };

        PullTypeResolver.prototype.getEnclosingDecl = function (decl) {
            var declPath = TypeScript.getPathToDecl(decl);

            if (!declPath.length) {
                return null;
            } else if (declPath.length > 1 && declPath[declPath.length - 1] === decl) {
                return declPath[declPath.length - 2];
            } else {
                return declPath[declPath.length - 1];
            }
        };

        PullTypeResolver.prototype.getExportedMemberSymbol = function (symbol, parent) {
            if (!(symbol.kind & (65536 /* Method */ | 4096 /* Property */))) {
                var isContainer = (parent.kind & (4 /* Container */ | 32 /* DynamicModule */)) != 0;
                var containerType = !isContainer ? parent.getAssociatedContainerType() : parent;

                if (isContainer && containerType) {
                    if (symbol.hasFlag(1 /* Exported */)) {
                        return symbol;
                    }

                    return null;
                }
            }

            return symbol;
        };

        PullTypeResolver.prototype.getMemberSymbol = function (symbolName, declSearchKind, parent) {
            var member = null;

            if (declSearchKind & TypeScript.PullElementKind.SomeValue) {
                member = parent.findMember(symbolName);
            } else {
                member = parent.findNestedType(symbolName);
            }

            if (member) {
                return this.getExportedMemberSymbol(member, parent);
            }

            var containerType = parent.getAssociatedContainerType();

            if (containerType) {
                if (containerType.isClass()) {
                    return null;
                }

                parent = containerType;
            }

            if (declSearchKind & TypeScript.PullElementKind.SomeValue) {
                member = parent.findMember(symbolName);
            } else {
                member = parent.findNestedType(symbolName);
            }

            if (member) {
                return this.getExportedMemberSymbol(member, parent);
            }

            var typeDeclarations = parent.getDeclarations();
            var childDecls = null;

            for (var j = 0; j < typeDeclarations.length; j++) {
                childDecls = typeDeclarations[j].searchChildDecls(symbolName, declSearchKind);

                if (childDecls.length) {
                    member = childDecls[0].getSymbol();

                    if (!member) {
                        member = childDecls[0].getSignatureSymbol();
                    }
                    return this.getExportedMemberSymbol(member, parent);
                }

                if ((declSearchKind & TypeScript.PullElementKind.SomeType) != 0 || (declSearchKind & TypeScript.PullElementKind.SomeValue) != 0) {
                    childDecls = typeDeclarations[j].searchChildDecls(symbolName, 256 /* TypeAlias */);
                    if (childDecls.length && childDecls[0].kind == 256 /* TypeAlias */) {
                        var aliasSymbol = this.getExportedMemberSymbol(childDecls[0].getSymbol(), parent);
                        if (aliasSymbol) {
                            if ((declSearchKind & TypeScript.PullElementKind.SomeType) != 0) {
                                var typeSymbol = aliasSymbol.getExportAssignedTypeSymbol();
                                if (typeSymbol) {
                                    return typeSymbol;
                                }
                            } else {
                                var valueSymbol = aliasSymbol.getExportAssignedValueSymbol();
                                if (valueSymbol) {
                                    return valueSymbol;
                                }
                            }
                        }
                    }
                }
            }
        };

        PullTypeResolver.prototype.getSymbolFromDeclPath = function (symbolName, declPath, declSearchKind) {
            var symbol = null;

            var decl = null;
            var childDecls;
            var declSymbol = null;
            var declMembers;
            var pathDeclKind;
            var valDecl = null;
            var kind;
            var instanceSymbol = null;
            var instanceType = null;
            var childSymbol = null;

            for (var i = declPath.length - 1; i >= 0; i--) {
                decl = declPath[i];
                pathDeclKind = decl.kind;

                if (decl.flags & 2097152 /* DeclaredInAWithBlock */) {
                    return this.semanticInfoChain.anyTypeSymbol;
                }

                if (pathDeclKind & (4 /* Container */ | 32 /* DynamicModule */)) {
                    childDecls = decl.searchChildDecls(symbolName, declSearchKind);

                    if (childDecls.length) {
                        return childDecls[0].getSymbol();
                    }

                    if (declSearchKind & TypeScript.PullElementKind.SomeValue) {
                        instanceSymbol = (decl.getSymbol()).getInstanceSymbol();

                        childDecls = decl.searchChildDecls(symbolName, 256 /* TypeAlias */);

                        if (childDecls.length) {
                            var sym = childDecls[0].getSymbol();

                            if (sym.isAlias()) {
                                return sym;
                            }
                        }

                        if (instanceSymbol) {
                            instanceType = instanceSymbol.type;

                            childSymbol = this.getMemberSymbol(symbolName, declSearchKind, instanceType);

                            if (childSymbol && (childSymbol.kind & declSearchKind)) {
                                return childSymbol;
                            }
                        }

                        valDecl = decl.getValueDecl();

                        if (valDecl) {
                            decl = valDecl;
                        }
                    }

                    declSymbol = decl.getSymbol().type;

                    var childSymbol = this.getMemberSymbol(symbolName, declSearchKind, declSymbol);

                    if (childSymbol) {
                        return childSymbol;
                    }
                } else if ((declSearchKind & (TypeScript.PullElementKind.SomeType | TypeScript.PullElementKind.SomeContainer)) || !(pathDeclKind & 8 /* Class */)) {
                    var candidateSymbol = null;

                    if (pathDeclKind === 131072 /* FunctionExpression */ && symbolName === (decl).getFunctionExpressionName()) {
                        candidateSymbol = decl.getSymbol();
                    }

                    childDecls = decl.searchChildDecls(symbolName, declSearchKind);

                    if (childDecls.length) {
                        if (decl.kind & TypeScript.PullElementKind.SomeFunction) {
                            decl.ensureSymbolIsBound();
                        }
                        return childDecls[0].getSymbol();
                    }

                    if (candidateSymbol) {
                        return candidateSymbol;
                    }

                    if (declSearchKind & TypeScript.PullElementKind.SomeValue) {
                        childDecls = decl.searchChildDecls(symbolName, 256 /* TypeAlias */);

                        if (childDecls.length) {
                            var sym = childDecls[0].getSymbol();

                            if (sym.isAlias()) {
                                return sym;
                            }
                        }
                    }
                }
            }

            symbol = this.semanticInfoChain.findSymbol([symbolName], declSearchKind);

            return symbol;
        };

        PullTypeResolver.prototype.getVisibleDeclsFromDeclPath = function (declPath, declSearchKind) {
            var result = [];
            var decl = null;
            var childDecls;
            var pathDeclKind;

            for (var i = declPath.length - 1; i >= 0; i--) {
                decl = declPath[i];
                pathDeclKind = decl.kind;

                var declKind = decl.kind;

                if (declKind !== 8 /* Class */ && declKind !== 16 /* Interface */) {
                    this.addFilteredDecls(decl.getChildDecls(), declSearchKind, result);
                }

                switch (declKind) {
                    case 4 /* Container */:
                    case 32 /* DynamicModule */:
                        var otherDecls = this.semanticInfoChain.findDeclsFromPath(declPath.slice(0, i + 1), TypeScript.PullElementKind.SomeContainer);
                        for (var j = 0, m = otherDecls.length; j < m; j++) {
                            var otherDecl = otherDecls[j];
                            if (otherDecl === decl) {
                                continue;
                            }

                            var otherDeclChildren = otherDecl.getChildDecls();
                            for (var k = 0, s = otherDeclChildren.length; k < s; k++) {
                                var otherDeclChild = otherDeclChildren[k];
                                if ((otherDeclChild.flags & 1 /* Exported */) && (otherDeclChild.kind & declSearchKind)) {
                                    result.push(otherDeclChild);
                                }
                            }
                        }

                        break;

                    case 8 /* Class */:
                    case 16 /* Interface */:
                        var parameters = decl.getTypeParameters();
                        if (parameters && parameters.length) {
                            this.addFilteredDecls(parameters, declSearchKind, result);
                        }

                        break;

                    case 131072 /* FunctionExpression */:
                        var functionExpressionName = (decl).getFunctionExpressionName();
                        if (functionExpressionName) {
                            result.push(decl);
                        }

                    case 16384 /* Function */:
                    case 32768 /* ConstructorMethod */:
                    case 65536 /* Method */:
                        var parameters = decl.getTypeParameters();
                        if (parameters && parameters.length) {
                            this.addFilteredDecls(parameters, declSearchKind, result);
                        }

                        break;
                }
            }

            var units = this.semanticInfoChain.units;
            for (var i = 0, n = units.length; i < n; i++) {
                var unit = units[i];
                if (unit === this.currentUnit && declPath.length != 0) {
                    continue;
                }
                var topLevelDecls = unit.getTopLevelDecls();
                if (topLevelDecls.length) {
                    for (var j = 0, m = topLevelDecls.length; j < m; j++) {
                        var topLevelDecl = topLevelDecls[j];
                        if (topLevelDecl.kind === 1 /* Script */ || topLevelDecl.kind === 0 /* Global */) {
                            this.addFilteredDecls(topLevelDecl.getChildDecls(), declSearchKind, result);
                        }
                    }
                }
            }

            return result;
        };

        PullTypeResolver.prototype.addFilteredDecls = function (decls, declSearchKind, result) {
            if (decls.length) {
                for (var i = 0, n = decls.length; i < n; i++) {
                    var decl = decls[i];
                    if (decl.kind & declSearchKind) {
                        result.push(decl);
                    }
                }
            }
        };

        PullTypeResolver.prototype.getVisibleDecls = function (enclosingDecl, context) {
            var declPath = enclosingDecl !== null ? TypeScript.getPathToDecl(enclosingDecl) : [];

            if (enclosingDecl && !declPath.length) {
                declPath = [enclosingDecl];
            }

            var declSearchKind = TypeScript.PullElementKind.SomeType | TypeScript.PullElementKind.SomeContainer | TypeScript.PullElementKind.SomeValue;

            return this.getVisibleDeclsFromDeclPath(declPath, declSearchKind);
        };

        PullTypeResolver.prototype.getVisibleContextSymbols = function (enclosingDecl, context) {
            var contextualTypeSymbol = context.getContextualType();
            if (!contextualTypeSymbol || this.isAnyOrEquivalent(contextualTypeSymbol)) {
                return null;
            }

            var declSearchKind = TypeScript.PullElementKind.SomeType | TypeScript.PullElementKind.SomeContainer | TypeScript.PullElementKind.SomeValue;
            var members = contextualTypeSymbol.getAllMembers(declSearchKind, false);

            for (var i = 0; i < members.length; i++) {
                members[i].setUnresolved();
            }

            return members;
        };

        PullTypeResolver.prototype.getVisibleMembersFromExpression = function (expression, enclosingDecl, context) {
            var prevCanUseTypeSymbol = context.canUseTypeSymbol;
            var prevResolvingNamespaceMemberAccess = context.resolvingNamespaceMemberAccess;
            context.canUseTypeSymbol = true;
            context.resolvingNamespaceMemberAccess = true;
            var lhs = this.resolveAST(expression, false, enclosingDecl, context);
            context.canUseTypeSymbol = prevCanUseTypeSymbol;
            context.resolvingNamespaceMemberAccess = prevResolvingNamespaceMemberAccess;

            if (context.resolvingTypeReference && (lhs.kind === 8 /* Class */ || lhs.kind === 16 /* Interface */)) {
                return null;
            }

            var lhsType = lhs.type;
            if (!lhsType) {
                return null;
            }

            if (this.isAnyOrEquivalent(lhsType)) {
                return null;
            }

            if (!lhsType.isResolved) {
                this.resolveDeclaredSymbol(lhsType, enclosingDecl, context);
            }

            var includePrivate = false;
            var containerSymbol = lhsType;
            if (containerSymbol.kind === 33554432 /* ConstructorType */) {
                containerSymbol = containerSymbol.getConstructSignatures()[0].returnType;
            }

            if (containerSymbol && containerSymbol.isClass()) {
                var declPath = TypeScript.getPathToDecl(enclosingDecl);
                if (declPath && declPath.length) {
                    var declarations = containerSymbol.getDeclarations();
                    for (var i = 0, n = declarations.length; i < n; i++) {
                        var declaration = declarations[i];
                        if (declPath.indexOf(declaration) >= 0) {
                            includePrivate = true;
                            break;
                        }
                    }
                }
            }

            var declSearchKind = TypeScript.PullElementKind.SomeType | TypeScript.PullElementKind.SomeContainer | TypeScript.PullElementKind.SomeValue;

            var members = [];

            if (lhsType.isContainer()) {
                var exportedAssignedContainerSymbol = (lhsType).getExportAssignedContainerSymbol();
                if (exportedAssignedContainerSymbol) {
                    lhsType = exportedAssignedContainerSymbol;
                }
            }

            if (lhsType.isTypeParameter()) {
                var constraint = (lhsType).getConstraint();

                if (constraint) {
                    lhsType = constraint;
                    members = lhsType.getAllMembers(declSearchKind, false);
                }
            } else {
                if (lhs.kind == 67108864 /* EnumMember */) {
                    lhsType = this.semanticInfoChain.numberTypeSymbol;
                }

                if (lhsType === this.semanticInfoChain.numberTypeSymbol && this.cachedNumberInterfaceType()) {
                    lhsType = this.cachedNumberInterfaceType();
                } else if (lhsType === this.semanticInfoChain.stringTypeSymbol && this.cachedStringInterfaceType()) {
                    lhsType = this.cachedStringInterfaceType();
                } else if (lhsType === this.semanticInfoChain.booleanTypeSymbol && this.cachedBooleanInterfaceType()) {
                    lhsType = this.cachedBooleanInterfaceType();
                }

                if (!lhsType.isResolved) {
                    var potentiallySpecializedType = this.resolveDeclaredSymbol(lhsType, enclosingDecl, context);

                    if (potentiallySpecializedType != lhsType) {
                        if (!lhs.isType()) {
                            context.setTypeInContext(lhs, potentiallySpecializedType);
                        }

                        lhsType = potentiallySpecializedType;
                    }
                }

                members = lhsType.getAllMembers(declSearchKind, includePrivate);

                if (lhsType.isContainer()) {
                    if (lhsType.isAlias()) {
                        lhsType = (lhsType).getExportAssignedTypeSymbol();
                    }
                    var associatedInstance = (lhsType).getInstanceSymbol();
                    if (associatedInstance) {
                        var instanceType = associatedInstance.type;
                        if (!instanceType.isResolved) {
                            this.resolveDeclaredSymbol(instanceType, enclosingDecl, context);
                        }
                        var instanceMembers = instanceType.getAllMembers(declSearchKind, includePrivate);
                        members = members.concat(instanceMembers);
                    }

                    var exportedContainer = (lhsType).getExportAssignedContainerSymbol();
                    if (exportedContainer) {
                        var exportedContainerMembers = exportedContainer.getAllMembers(declSearchKind, includePrivate);
                        members = members.concat(exportedContainerMembers);
                    }
                } else if (lhsType.isConstructor()) {
                    var prototypeStr = "prototype";
                    var prototypeSymbol = new TypeScript.PullSymbol(prototypeStr, 4096 /* Property */);
                    var parentDecl = lhsType.getDeclarations()[0];
                    var prototypeDecl = new TypeScript.PullDecl(prototypeStr, prototypeStr, parentDecl.kind, parentDecl.flags, parentDecl.getSpan(), parentDecl.getScriptName());
                    this.currentUnit.addSynthesizedDecl(prototypeDecl);
                    prototypeDecl.setParentDecl(parentDecl);
                    prototypeSymbol.addDeclaration(prototypeDecl);
                    prototypeSymbol.type = lhsType.getAssociatedContainerType();
                    prototypeSymbol.isResolved = true;
                    members.push(prototypeSymbol);
                } else {
                    var associatedContainerSymbol = lhsType.getAssociatedContainerType();
                    if (associatedContainerSymbol) {
                        var containerType = associatedContainerSymbol.type;
                        if (!containerType.isResolved) {
                            this.resolveDeclaredSymbol(containerType, enclosingDecl, context);
                        }
                        var containerMembers = containerType.getAllMembers(declSearchKind, includePrivate);
                        members = members.concat(containerMembers);
                    }
                }
            }

            if (lhsType.getCallSignatures().length && this.cachedFunctionInterfaceType()) {
                members = members.concat(this.cachedFunctionInterfaceType().getAllMembers(declSearchKind, false));
            }

            return members;
        };

        PullTypeResolver.prototype.isAnyOrEquivalent = function (type) {
            return (type === this.semanticInfoChain.anyTypeSymbol) || type.isError();
        };

        PullTypeResolver.prototype.isNumberOrEquivalent = function (type) {
            return (type === this.semanticInfoChain.numberTypeSymbol) || (this.cachedNumberInterfaceType() && type === this.cachedNumberInterfaceType());
        };

        PullTypeResolver.prototype.isTypeArgumentOrWrapper = function (type) {
            if (!type) {
                return false;
            }

            if (!type.isGeneric()) {
                return false;
            }

            if (type.isTypeParameter()) {
                return true;
            }

            if (type.isArray()) {
                return this.isTypeArgumentOrWrapper(type.getElementType());
            }

            var typeArguments = type.getTypeArguments();

            if (typeArguments) {
                for (var i = 0; i < typeArguments.length; i++) {
                    if (this.isTypeArgumentOrWrapper(typeArguments[i])) {
                        return true;
                    }
                }
            } else {
                return true;
            }

            return false;
        };

        PullTypeResolver.prototype.isArrayOrEquivalent = function (type) {
            return (type.isArray() && type.getElementType()) || type == this.cachedArrayInterfaceType();
        };

        PullTypeResolver.prototype.findTypeSymbolForDynamicModule = function (idText, currentFileName, search) {
            var originalIdText = idText;
            var symbol = null;

            if (!TypeScript.isRelative(originalIdText)) {
                idText = originalIdText;

                var strippedIdText = TypeScript.stripQuotes(idText);

                if (this.lastExternalModulePath != "") {
                    idText = TypeScript.normalizePath(this.lastExternalModulePath + strippedIdText + ".ts");
                    symbol = search(idText);

                    if (symbol) {
                        return symbol;
                    }

                    if (symbol === null) {
                        idText = TypeScript.normalizePath(this.lastExternalModulePath + strippedIdText + ".d.ts");
                        symbol = search(idText);
                    }

                    if (symbol) {
                        return symbol;
                    }
                }

                var path = TypeScript.getRootFilePath(TypeScript.switchToForwardSlashes(currentFileName));

                while (symbol === null && path != "") {
                    idText = TypeScript.normalizePath(path + strippedIdText + ".d.ts");
                    symbol = search(idText);

                    if (symbol === null) {
                        idText = TypeScript.normalizePath(path + strippedIdText + ".ts");
                        symbol = search(idText);
                    }

                    if (symbol === null) {
                        if (path === '/') {
                            path = '';
                        } else {
                            path = TypeScript.normalizePath(path + "..");
                            path = path && path != '/' ? path + '/' : path;
                        }
                    }

                    if (symbol) {
                        this.lastExternalModulePath = path;
                    }
                }
            }

            symbol = search(originalIdText);

            if (symbol === null) {
                if (!symbol) {
                    idText = TypeScript.swapQuotes(originalIdText);
                    symbol = search(idText);
                }

                if (!symbol) {
                    idText = TypeScript.stripQuotes(originalIdText) + ".d.ts";
                    symbol = search(idText);
                }

                if (!symbol) {
                    idText = TypeScript.stripQuotes(originalIdText) + ".ts";
                    symbol = search(idText);
                }
            }

            return symbol;
        };

        PullTypeResolver.prototype.resolveDeclaredSymbol = function (symbol, enclosingDecl, context) {
            var savedResolvingTypeReference = context.resolvingTypeReference;
            context.resolvingTypeReference = false;

            var result = this.resolveDeclaredSymbolWorker(symbol, enclosingDecl, context);
            context.resolvingTypeReference = savedResolvingTypeReference;

            return result;
        };

        PullTypeResolver.prototype.resolveDeclaredSymbolWorker = function (symbol, enclosingDecl, context) {
            if (!symbol || symbol.isResolved) {
                return symbol;
            }

            if (symbol.inResolution) {
                if (!symbol.currentlyBeingSpecialized()) {
                    if (!symbol.isType()) {
                        symbol.type = this.semanticInfoChain.anyTypeSymbol;
                    }

                    return symbol;
                }
            }

            var thisUnit = this.unitPath;

            var decls = symbol.getDeclarations();

            var ast = null;

            for (var i = 0; i < decls.length; i++) {
                var decl = decls[i];

                ast = this.semanticInfoChain.getASTForDecl(decl);

                if (!ast || ast.nodeType() === 81 /* Member */) {
                    this.setUnitPath(thisUnit);
                    return symbol;
                }

                this.setUnitPath(decl.getScriptName());
                var resolvedSymbol = this.resolveAST(ast, false, enclosingDecl, context);

                if (decl.kind == 2048 /* Parameter */ && !symbol.isResolved && !symbol.type && resolvedSymbol && symbol.hasFlag(8388608 /* PropertyParameter */)) {
                    symbol.type = resolvedSymbol.type;
                    symbol.setResolved();
                }
            }

            var typeArgs = symbol.isType() ? (symbol).getTypeArguments() : null;

            if (typeArgs && typeArgs.length) {
                var typeParameters = (symbol).getTypeParameters();
                var typeCache = {};

                for (var i = 0; i < typeParameters.length; i++) {
                    typeCache[typeParameters[i].pullSymbolIDString] = typeArgs[i];
                }

                context.pushTypeSpecializationCache(typeCache);
                var rootType = TypeScript.getRootType(symbol.type);

                var specializedSymbol = TypeScript.specializeType(rootType, typeArgs, this, enclosingDecl, context, ast);

                context.popTypeSpecializationCache();

                symbol = specializedSymbol;
            }

            this.setUnitPath(thisUnit);

            return symbol;
        };

        PullTypeResolver.prototype.resolveModuleDeclaration = function (ast, context) {
            var containerDecl = this.getDeclForAST(ast);
            var containerSymbol = containerDecl.getSymbol();

            if (containerSymbol.isResolved || containerSymbol.inResolution) {
                return containerSymbol;
            }

            containerSymbol.inResolution = true;

            var containerDecls = containerSymbol.getDeclarations();

            for (var i = 0; i < containerDecls.length; i++) {
                var childDecls = containerDecls[i].getChildDecls();

                for (var j = 0; j < childDecls.length; j++) {
                    childDecls[j].ensureSymbolIsBound();
                }
            }

            var members = ast.members.members;

            if (containerDecl.kind != 64 /* Enum */) {
                var instanceSymbol = containerSymbol.getInstanceSymbol();

                if (instanceSymbol) {
                    this.resolveDeclaredSymbol(instanceSymbol, containerDecl.getParentDecl(), context);
                }

                for (var i = 0; i < members.length; i++) {
                    if (members[i].nodeType() == 88 /* ExportAssignment */) {
                        this.resolveExportAssignmentStatement(members[i], containerDecl, context);
                        break;
                    }
                }
            }

            if (context.typeCheck()) {
                var subModuleAST = null;
                var currentPath = this.unitPath;
                for (var i = 0; i < containerDecls.length; i++) {
                    subModuleAST = this.getASTForDecl(containerDecls[i]);

                    if (subModuleAST) {
                        this.setUnitPath(containerDecls[i].getScriptName());
                        this.resolveAST(subModuleAST.members, false, containerDecls[i], context);
                    }
                }

                this.setUnitPath(currentPath);

                this.validateVariableDeclarationGroups(containerDecl, context);
            }

            if (!context.isInBaseTypeResolution()) {
                containerSymbol.setResolved();
            } else {
                containerSymbol.inResolution = false;
            }

            return containerSymbol;
        };

        PullTypeResolver.prototype.isTypeRefWithoutTypeArgs = function (typeRef) {
            if (typeRef.nodeType() != 11 /* TypeRef */) {
                return false;
            }

            if (typeRef.term.nodeType() == 21 /* Name */) {
                return true;
            } else if (typeRef.term.nodeType() == 33 /* MemberAccessExpression */) {
                var binex = typeRef.term;

                if (binex.operand2.nodeType() == 21 /* Name */) {
                    return true;
                }
            }

            return false;
        };

        PullTypeResolver.prototype.resolveReferenceTypeDeclaration = function (typeDeclAST, context) {
            var typeDecl = this.getDeclForAST(typeDeclAST);
            var enclosingDecl = this.getEnclosingDecl(typeDecl);
            var typeDeclSymbol = typeDecl.getSymbol();
            var typeDeclIsClass = typeDeclAST.nodeType() === 14 /* ClassDeclaration */;
            var hasVisited = this.getSymbolForAST(typeDeclAST) != null;
            var extendedTypes = [];
            var implementedTypes = [];

            if ((typeDeclSymbol.isResolved && hasVisited) || (typeDeclSymbol.inResolution && !context.isInBaseTypeResolution())) {
                return typeDeclSymbol;
            }

            var wasResolving = typeDeclSymbol.inResolution;
            typeDeclSymbol.startResolving();

            if (!typeDeclSymbol.isResolved) {
                var typeDeclTypeParameters = typeDeclSymbol.getTypeParameters();
                for (var i = 0; i < typeDeclTypeParameters.length; i++) {
                    this.resolveDeclaredSymbol(typeDeclTypeParameters[i], typeDecl, context);
                }
            }

            var typeRefDecls = typeDeclSymbol.getDeclarations();

            for (var i = 0; i < typeRefDecls.length; i++) {
                var childDecls = typeRefDecls[i].getChildDecls();

                for (var j = 0; j < childDecls.length; j++) {
                    childDecls[j].ensureSymbolIsBound();
                }
            }

            var wasInBaseTypeResolution = context.startBaseTypeResolution();

            if (!typeDeclIsClass && !hasVisited) {
                typeDeclSymbol.resetKnownBaseTypeCount();
            }

            if (typeDeclAST.extendsList) {
                var savedIsResolvingClassExtendedType = context.isResolvingClassExtendedType;
                if (typeDeclIsClass) {
                    context.isResolvingClassExtendedType = true;
                }

                for (var i = typeDeclSymbol.getKnownBaseTypeCount(); i < typeDeclAST.extendsList.members.length; i = typeDeclSymbol.getKnownBaseTypeCount()) {
                    typeDeclSymbol.incrementKnownBaseCount();
                    var parentType = this.resolveTypeReference(new TypeScript.TypeReference(typeDeclAST.extendsList.members[i], 0), typeDecl, context);

                    if (typeDeclSymbol.isValidBaseKind(parentType, true)) {
                        var resolvedParentType = parentType;
                        extendedTypes[extendedTypes.length] = parentType;
                        if (parentType.isGeneric() && parentType.isResolved && !parentType.getIsSpecialized()) {
                            parentType = this.specializeTypeToAny(parentType, enclosingDecl, context);
                            typeDecl.addDiagnostic(new TypeScript.Diagnostic(typeDecl.getScriptName(), typeDeclAST.minChar, typeDeclAST.getLength(), TypeScript.DiagnosticCode.Generic_type_references_must_include_all_type_arguments));
                        }
                        if (!typeDeclSymbol.hasBase(parentType)) {
                            this.setSymbolForAST(typeDeclAST.extendsList.members[i], resolvedParentType, context);
                            typeDeclSymbol.addExtendedType(parentType);

                            var specializations = typeDeclSymbol.getKnownSpecializations();

                            for (var j = 0; j < specializations.length; j++) {
                                specializations[j].addExtendedType(parentType);
                            }
                        }
                    }
                }

                context.isResolvingClassExtendedType = savedIsResolvingClassExtendedType;
            }

            if (typeDeclAST.implementsList && typeDeclIsClass) {
                var extendsCount = typeDeclAST.extendsList ? typeDeclAST.extendsList.members.length : 0;
                for (var i = typeDeclSymbol.getKnownBaseTypeCount(); ((i - extendsCount) >= 0) && ((i - extendsCount) < typeDeclAST.implementsList.members.length); i = typeDeclSymbol.getKnownBaseTypeCount()) {
                    typeDeclSymbol.incrementKnownBaseCount();
                    var implementedType = this.resolveTypeReference(new TypeScript.TypeReference(typeDeclAST.implementsList.members[i - extendsCount], 0), typeDecl, context);

                    if (typeDeclSymbol.isValidBaseKind(implementedType, false)) {
                        var resolvedImplementedType = implementedType;
                        implementedTypes[implementedTypes.length] = implementedType;
                        if (implementedType.isGeneric() && implementedType.isResolved && !implementedType.getIsSpecialized()) {
                            implementedType = this.specializeTypeToAny(implementedType, enclosingDecl, context);
                            typeDecl.addDiagnostic(new TypeScript.Diagnostic(typeDecl.getScriptName(), typeDeclAST.minChar, typeDeclAST.getLength(), TypeScript.DiagnosticCode.Generic_type_references_must_include_all_type_arguments));
                            this.setSymbolForAST(typeDeclAST.implementsList.members[i - extendsCount], implementedType, context);
                            typeDeclSymbol.addImplementedType(implementedType);
                        } else if (!typeDeclSymbol.hasBase(implementedType)) {
                            this.setSymbolForAST(typeDeclAST.implementsList.members[i - extendsCount], resolvedImplementedType, context);
                            typeDeclSymbol.addImplementedType(implementedType);
                        }
                    }
                }
            }

            context.doneBaseTypeResolution(wasInBaseTypeResolution);

            if (wasInBaseTypeResolution) {
                typeDeclSymbol.inResolution = false;
                return typeDeclSymbol;
            }

            if (!typeDeclSymbol.isResolved) {
                var typeDeclMembers = typeDeclSymbol.getMembers();

                if (TypeScript.globalBinder) {
                    TypeScript.globalBinder.resetTypeParameterCache();
                }

                if (context.typeCheck()) {
                    for (var i = 0; i < typeDeclMembers.length; i++) {
                        this.resolveDeclaredSymbol(typeDeclMembers[i], typeDecl, context);
                    }
                }

                if (!typeDeclIsClass) {
                    var callSignatures = typeDeclSymbol.getCallSignatures();
                    for (var i = 0; i < callSignatures.length; i++) {
                        this.resolveDeclaredSymbol(callSignatures[i], typeDecl, context);
                    }

                    var constructSignatures = typeDeclSymbol.getConstructSignatures();
                    for (var i = 0; i < constructSignatures.length; i++) {
                        this.resolveDeclaredSymbol(constructSignatures[i], typeDecl, context);
                    }

                    var indexSignatures = typeDeclSymbol.getIndexSignatures();
                    for (var i = 0; i < indexSignatures.length; i++) {
                        this.resolveDeclaredSymbol(indexSignatures[i], typeDecl, context);
                    }

                    if (context.typeCheck()) {
                        this.typeCheckBases(typeDeclAST, typeDeclSymbol, enclosingDecl, context);
                    }
                }
            }

            this.setSymbolForAST(typeDeclAST.name, typeDeclSymbol, context);
            this.setSymbolForAST(typeDeclAST, typeDeclSymbol, context);

            typeDeclSymbol.setResolved();

            return typeDeclSymbol;
        };

        PullTypeResolver.prototype.resolveClassDeclaration = function (classDeclAST, context) {
            var classDecl = this.getDeclForAST(classDeclAST);
            var classDeclSymbol = classDecl.getSymbol();
            if (classDeclSymbol.isResolved) {
                return classDeclSymbol;
            }

            this.resolveReferenceTypeDeclaration(classDeclAST, context);

            var constructorMethod = classDeclSymbol.getConstructorMethod();
            var extendedTypes = classDeclSymbol.getExtendedTypes();
            var parentType = extendedTypes.length ? extendedTypes[0] : null;

            if (constructorMethod) {
                var constructorTypeSymbol = constructorMethod.type;

                var constructSignatures = constructorTypeSymbol.getConstructSignatures();

                if (!constructSignatures.length) {
                    var constructorSignature;

                    if (parentType) {
                        var parentClass = parentType;
                        var parentConstructor = parentClass.getConstructorMethod();
                        var parentConstructorType = parentConstructor.type;
                        var parentConstructSignatures = parentConstructorType.getConstructSignatures();

                        var parentConstructSignature;
                        var parentParameters;
                        for (var i = 0; i < parentConstructSignatures.length; i++) {
                            parentConstructSignature = parentConstructSignatures[i];
                            parentParameters = parentConstructSignature.parameters;

                            constructorSignature = parentConstructSignature.isDefinition() ? new TypeScript.PullDefinitionSignatureSymbol(2097152 /* ConstructSignature */) : new TypeScript.PullSignatureSymbol(2097152 /* ConstructSignature */);
                            constructorSignature.returnType = classDeclSymbol;

                            for (var j = 0; j < parentParameters.length; j++) {
                                constructorSignature.addParameter(parentParameters[j], parentParameters[j].isOptional);
                            }

                            var typeParameters = constructorTypeSymbol.getTypeParameters();

                            for (var j = 0; j < typeParameters.length; j++) {
                                constructorSignature.addTypeParameter(typeParameters[j]);
                            }

                            constructorTypeSymbol.addConstructSignature(constructorSignature);
                            constructorSignature.addDeclaration(classDecl);
                        }
                    } else {
                        constructorSignature = new TypeScript.PullSignatureSymbol(2097152 /* ConstructSignature */);
                        constructorSignature.returnType = classDeclSymbol;
                        constructorTypeSymbol.addConstructSignature(constructorSignature);
                        constructorSignature.addDeclaration(classDecl);

                        var typeParameters = constructorTypeSymbol.getTypeParameters();

                        for (var i = 0; i < typeParameters.length; i++) {
                            constructorSignature.addTypeParameter(typeParameters[i]);
                        }
                    }
                }

                if (!classDeclSymbol.isResolved) {
                    return classDeclSymbol;
                }

                if (context.typeCheck()) {
                    var constructorMembers = constructorTypeSymbol.getMembers();

                    this.resolveDeclaredSymbol(constructorMethod, classDecl, context);

                    for (var i = 0; i < constructorMembers.length; i++) {
                        this.resolveDeclaredSymbol(constructorMembers[i], classDecl, context);
                    }
                }
            }

            if (parentType) {
                var parentConstructorSymbol = parentType.getConstructorMethod();
                var parentConstructorTypeSymbol = parentConstructorSymbol.type;

                if (!constructorTypeSymbol.hasBase(parentConstructorTypeSymbol)) {
                    constructorTypeSymbol.addExtendedType(parentConstructorTypeSymbol);
                }
            }

            if (context.typeCheck()) {
                this.typeCheckBases(classDeclAST, classDeclSymbol, this.getEnclosingDecl(classDecl), context);
                if (classDeclSymbol.isResolved && !classDeclSymbol.hasBaseTypeConflict()) {
                    this.typeCheckMembersAgainstIndexer(classDeclSymbol, classDecl, context);
                }
            }

            return classDeclSymbol;
        };

        PullTypeResolver.prototype.resolveInterfaceDeclaration = function (interfaceDeclAST, context) {
            var interfaceDecl = this.getDeclForAST(interfaceDeclAST);
            var interfaceDeclSymbol = interfaceDecl.getSymbol();

            this.resolveReferenceTypeDeclaration(interfaceDeclAST, context);

            if (context.typeCheck()) {
                if (!interfaceDeclSymbol.hasBaseTypeConflict()) {
                    this.typeCheckMembersAgainstIndexer(interfaceDeclSymbol, interfaceDecl, context);
                }
            }

            return interfaceDeclSymbol;
        };

        PullTypeResolver.prototype.filterSymbol = function (symbol, kind) {
            if (symbol) {
                if (symbol.kind & kind) {
                    return symbol;
                }

                if (symbol.isAlias()) {
                    var alias = symbol;
                    if (kind & TypeScript.PullElementKind.SomeContainer) {
                        return alias.getExportAssignedContainerSymbol();
                    } else if (kind & TypeScript.PullElementKind.SomeType) {
                        return alias.getExportAssignedTypeSymbol();
                    } else if (kind & TypeScript.PullElementKind.SomeValue) {
                        return alias.getExportAssignedValueSymbol();
                    }
                }
            }
            return null;
        };

        PullTypeResolver.prototype.getMemberSymbolOfKind = function (symbolName, kind, pullTypeSymbol) {
            var symbol = this.getMemberSymbol(symbolName, kind, pullTypeSymbol);

            return this.filterSymbol(symbol, kind);
        };

        PullTypeResolver.prototype.resolveIdentifierOfInternalModuleReference = function (importDecl, identifier, moduleSymbol, enclosingDecl, context) {
            if (identifier.isMissing()) {
                return null;
            }

            var moduleTypeSymbol = moduleSymbol.type;
            var rhsName = identifier.text();
            var containerSymbol = this.getMemberSymbolOfKind(rhsName, TypeScript.PullElementKind.SomeContainer, moduleTypeSymbol);
            var valueSymbol = null;
            var typeSymbol = null;

            var acceptableAlias = true;

            if (containerSymbol) {
                acceptableAlias = (containerSymbol.kind & TypeScript.PullElementKind.AcceptableAlias) != 0;
            }

            if (!acceptableAlias && containerSymbol && containerSymbol.kind == 256 /* TypeAlias */) {
                if (!containerSymbol.isResolved) {
                    this.resolveDeclaredSymbol(containerSymbol, enclosingDecl, context);
                }
                var aliasedAssignedValue = (containerSymbol).getExportAssignedValueSymbol();
                var aliasedAssignedType = (containerSymbol).getExportAssignedTypeSymbol();
                var aliasedAssignedContainer = (containerSymbol).getExportAssignedContainerSymbol();

                if (aliasedAssignedValue || aliasedAssignedType || aliasedAssignedContainer) {
                    valueSymbol = aliasedAssignedValue;
                    typeSymbol = aliasedAssignedType;
                    containerSymbol = aliasedAssignedContainer;
                    acceptableAlias = true;
                }
            }

            if (!acceptableAlias) {
                importDecl.addDiagnostic(new TypeScript.Diagnostic(importDecl.getScriptName(), identifier.minChar, identifier.getLength(), TypeScript.DiagnosticCode.Import_declaration_referencing_identifier_from_internal_module_can_only_be_made_with_variables_functions_classes_interfaces_enums_and_internal_modules));
                return null;
            }

            if (!valueSymbol) {
                if (moduleTypeSymbol.getInstanceSymbol()) {
                    valueSymbol = this.getMemberSymbolOfKind(rhsName, TypeScript.PullElementKind.SomeValue, moduleTypeSymbol.getInstanceSymbol().type);
                }
            }
            if (!typeSymbol) {
                typeSymbol = this.getMemberSymbolOfKind(rhsName, TypeScript.PullElementKind.SomeType, moduleTypeSymbol);
            }

            if (!valueSymbol && !typeSymbol && !containerSymbol) {
                importDecl.addDiagnostic(new TypeScript.Diagnostic(importDecl.getScriptName(), identifier.minChar, identifier.getLength(), TypeScript.DiagnosticCode.Could_not_find_symbol_0_in_module_1, [rhsName, moduleSymbol.toString()]));
                return null;
            }

            if (valueSymbol) {
                if (!valueSymbol.isResolved) {
                    this.resolveDeclaredSymbol(valueSymbol, enclosingDecl, context);
                }
            }
            if (typeSymbol) {
                if (!typeSymbol.isResolved) {
                    this.resolveDeclaredSymbol(typeSymbol, enclosingDecl, context);
                }
            }
            if (containerSymbol) {
                if (!containerSymbol.isResolved) {
                    this.resolveDeclaredSymbol(containerSymbol, enclosingDecl, context);
                }
            }

            if (!typeSymbol && containerSymbol) {
                typeSymbol = containerSymbol;
            }

            return {
                valueSymbol: valueSymbol,
                typeSymbol: typeSymbol,
                containerSymbol: containerSymbol
            };
        };

        PullTypeResolver.prototype.resolveModuleReference = function (importDecl, moduleNameExpr, context, declPath) {
            TypeScript.CompilerDiagnostics.assert(moduleNameExpr.nodeType() == 33 /* MemberAccessExpression */ || moduleNameExpr.nodeType() == 21 /* Name */, "resolving module reference should always be either name or member reference");

            var moduleSymbol = null;
            var moduleName;

            if (moduleNameExpr.nodeType() == 33 /* MemberAccessExpression */) {
                var dottedNameAST = moduleNameExpr;
                var moduleContainer = this.resolveModuleReference(importDecl, dottedNameAST.operand1, context, declPath);
                if (moduleContainer) {
                    moduleName = (dottedNameAST.operand2).text();
                    moduleSymbol = this.getMemberSymbolOfKind(moduleName, 4 /* Container */, moduleContainer.type);
                    if (!moduleSymbol) {
                        importDecl.addDiagnostic(new TypeScript.Diagnostic(importDecl.getScriptName(), dottedNameAST.operand2.minChar, dottedNameAST.operand2.getLength(), TypeScript.DiagnosticCode.Could_not_find_module_0_in_module_1, [moduleName, moduleContainer.toString()]));
                    }
                }
            } else if (!(moduleNameExpr).isMissing()) {
                moduleName = (moduleNameExpr).text();
                moduleSymbol = this.filterSymbol(this.getSymbolFromDeclPath(moduleName, declPath, 4 /* Container */), 4 /* Container */);
                if (!moduleSymbol) {
                    importDecl.addDiagnostic(new TypeScript.Diagnostic(importDecl.getScriptName(), moduleNameExpr.minChar, moduleNameExpr.getLength(), TypeScript.DiagnosticCode.Unable_to_resolve_module_reference_0, [moduleName]));
                }
            }

            return moduleSymbol;
        };

        PullTypeResolver.prototype.resolveInternalModuleReference = function (importStatementAST, context) {
            var importDecl = this.getDeclForAST(importStatementAST);
            var enclosingDecl = this.getEnclosingDecl(importDecl);

            var aliasExpr = importStatementAST.alias.nodeType() == 11 /* TypeRef */ ? (importStatementAST.alias).term : importStatementAST.alias;
            var declPath = enclosingDecl !== null ? TypeScript.getPathToDecl(enclosingDecl) : [];
            var aliasedType = null;

            if (aliasExpr.nodeType() == 21 /* Name */) {
                var moduleSymbol = this.resolveModuleReference(importDecl, aliasExpr, context, declPath);
                if (moduleSymbol) {
                    aliasedType = moduleSymbol.type;
                    if (context.typeCheck() && aliasedType.hasFlag(32768 /* InitializedModule */)) {
                        var moduleName = (aliasExpr).text();
                        var valueSymbol = this.getSymbolFromDeclPath(moduleName, declPath, TypeScript.PullElementKind.SomeValue);
                        var instanceSymbol = (aliasedType).getInstanceSymbol();
                        if (valueSymbol && (instanceSymbol != valueSymbol || valueSymbol.type == aliasedType)) {
                            context.postError(this.unitPath, aliasExpr.minChar, aliasExpr.getLength(), TypeScript.DiagnosticCode.Internal_module_reference_0_in_import_declaration_doesn_t_reference_module_instance_for_1, [(aliasExpr).actualText, moduleSymbol.type.toString(enclosingDecl ? enclosingDecl.getSymbol() : null)], enclosingDecl);
                        }
                    }
                } else {
                    aliasedType = this.semanticInfoChain.anyTypeSymbol;
                }
            } else if (aliasExpr.nodeType() == 33 /* MemberAccessExpression */) {
                var importDeclSymbol = importDecl.getSymbol();
                var dottedNameAST = aliasExpr;
                var moduleSymbol = this.resolveModuleReference(importDecl, dottedNameAST.operand1, context, declPath);
                if (moduleSymbol) {
                    var identifierResolution = this.resolveIdentifierOfInternalModuleReference(importDecl, dottedNameAST.operand2, moduleSymbol, enclosingDecl, context);
                    if (identifierResolution) {
                        importDeclSymbol.setAssignedValueSymbol(identifierResolution.valueSymbol);
                        importDeclSymbol.setAssignedTypeSymbol(identifierResolution.typeSymbol);
                        importDeclSymbol.setAssignedContainerSymbol(identifierResolution.containerSymbol);
                        if (identifierResolution.valueSymbol) {
                            importDeclSymbol.isUsedAsValue = true;
                        }
                        this.semanticInfoChain.setSymbolForAST(importStatementAST.alias, importDeclSymbol, this.unitPath);
                        return null;
                    }
                }

                importDeclSymbol.setAssignedTypeSymbol(this.semanticInfoChain.anyTypeSymbol);
            }

            return aliasedType;
        };

        PullTypeResolver.prototype.resolveImportDeclaration = function (importStatementAST, context) {
            var _this = this;
            var importDecl = this.getDeclForAST(importStatementAST);
            var enclosingDecl = this.getEnclosingDecl(importDecl);
            var importDeclSymbol = importDecl.getSymbol();

            var aliasedType = null;

            if (importDeclSymbol.isResolved) {
                return importDeclSymbol;
            }

            importDeclSymbol.startResolving();

            var isExternalImportDeclaration = importStatementAST.isExternalImportDeclaration();

            if (isExternalImportDeclaration) {
                var modPath = (importStatementAST.alias).actualText;
                var declPath = TypeScript.getPathToDecl(enclosingDecl);

                aliasedType = this.findTypeSymbolForDynamicModule(modPath, importDecl.getScriptName(), function (s) {
                    return _this.semanticInfoChain.findSymbol([s], 32 /* DynamicModule */);
                });

                if (!aliasedType) {
                    aliasedType = this.findTypeSymbolForDynamicModule(modPath, importDecl.getScriptName(), function (s) {
                        return _this.getSymbolFromDeclPath(s, declPath, 32 /* DynamicModule */);
                    });
                }
                if (!aliasedType) {
                    importDecl.addDiagnostic(new TypeScript.Diagnostic(this.currentUnit.getPath(), importStatementAST.minChar, importStatementAST.getLength(), TypeScript.DiagnosticCode.Unable_to_resolve_external_module_0, [modPath]));
                    aliasedType = this.semanticInfoChain.anyTypeSymbol;
                }
            } else {
                aliasedType = this.resolveInternalModuleReference(importStatementAST, context);
            }

            if (aliasedType) {
                if (!aliasedType.isContainer()) {
                    importDecl.addDiagnostic(new TypeScript.Diagnostic(this.currentUnit.getPath(), importStatementAST.minChar, importStatementAST.getLength(), TypeScript.DiagnosticCode.Module_cannot_be_aliased_to_a_non_module_type));
                    aliasedType = this.semanticInfoChain.anyTypeSymbol;
                } else if ((aliasedType).getExportAssignedValueSymbol()) {
                    importDeclSymbol.isUsedAsValue = true;
                }

                if (aliasedType.isContainer()) {
                    importDeclSymbol.setAssignedContainerSymbol(aliasedType);
                }
                importDeclSymbol.setAssignedTypeSymbol(aliasedType);

                this.semanticInfoChain.setSymbolForAST(importStatementAST.alias, aliasedType, this.unitPath);
            }

            importDeclSymbol.setResolved();

            if (context.typeCheck()) {
                var checkPrivacy;
                if (isExternalImportDeclaration) {
                    var containerSymbol = importDeclSymbol.getExportAssignedContainerSymbol();
                    var container = containerSymbol ? containerSymbol.getContainer() : null;
                    if (container && container.kind == 32 /* DynamicModule */) {
                        checkPrivacy = true;
                    }
                } else {
                    checkPrivacy = true;
                }

                if (checkPrivacy) {
                    var typeSymbol = importDeclSymbol.getExportAssignedTypeSymbol();
                    var containerSymbol = importDeclSymbol.getExportAssignedContainerSymbol();
                    var valueSymbol = importDeclSymbol.getExportAssignedValueSymbol();

                    this.checkSymbolPrivacy(importDeclSymbol, containerSymbol, context, function (symbol) {
                        var messageCode = TypeScript.DiagnosticCode.Exported_import_declaration_0_is_assigned_container_that_is_or_is_using_inaccessible_module_1;
                        var messageArguments = [importDeclSymbol.getScopedName(enclosingDecl ? enclosingDecl.getSymbol() : null), symbol.getScopedName(enclosingDecl ? enclosingDecl.getSymbol() : null)];
                        context.postError(_this.unitPath, importStatementAST.minChar, importStatementAST.getLength(), messageCode, messageArguments, enclosingDecl);
                    });

                    if (typeSymbol != containerSymbol) {
                        this.checkSymbolPrivacy(importDeclSymbol, typeSymbol, context, function (symbol) {
                            var messageCode = symbol.isContainer() && !(symbol).isEnum() ? TypeScript.DiagnosticCode.Exported_import_declaration_0_is_assigned_type_that_is_using_inaccessible_module_1 : TypeScript.DiagnosticCode.Exported_import_declaration_0_is_assigned_type_that_has_or_is_using_private_type_1;

                            var messageArguments = [importDeclSymbol.getScopedName(enclosingDecl ? enclosingDecl.getSymbol() : null), symbol.getScopedName(enclosingDecl ? enclosingDecl.getSymbol() : null)];
                            context.postError(_this.unitPath, importStatementAST.minChar, importStatementAST.getLength(), messageCode, messageArguments, enclosingDecl);
                        });
                    }

                    if (valueSymbol) {
                        this.checkSymbolPrivacy(importDeclSymbol, valueSymbol.type, context, function (symbol) {
                            var messageCode = symbol.isContainer() && !(symbol).isEnum() ? TypeScript.DiagnosticCode.Exported_import_declaration_0_is_assigned_value_with_type_that_is_using_inaccessible_module_1 : TypeScript.DiagnosticCode.Exported_import_declaration_0_is_assigned_value_with_type_that_has_or_is_using_private_type_1;
                            var messageArguments = [importDeclSymbol.getScopedName(enclosingDecl ? enclosingDecl.getSymbol() : null), symbol.getScopedName(enclosingDecl ? enclosingDecl.getSymbol() : null)];
                            context.postError(_this.unitPath, importStatementAST.minChar, importStatementAST.getLength(), messageCode, messageArguments, enclosingDecl);
                        });
                    }
                }
            }

            return importDeclSymbol;
        };

        PullTypeResolver.prototype.resolveExportAssignmentStatement = function (exportAssignmentAST, enclosingDecl, context) {
            var id = exportAssignmentAST.id.text();
            var valueSymbol = null;
            var typeSymbol = null;
            var containerSymbol = null;

            var parentSymbol = enclosingDecl.getSymbol();

            if (!parentSymbol.isType() && (parentSymbol).isContainer()) {
                enclosingDecl.addDiagnostic(new TypeScript.Diagnostic(enclosingDecl.getScriptName(), exportAssignmentAST.minChar, exportAssignmentAST.getLength(), TypeScript.DiagnosticCode.Export_assignments_may_only_be_used_at_the_top_level_of_external_modules));
                return this.semanticInfoChain.anyTypeSymbol;
            }

            var declPath = enclosingDecl !== null ? [enclosingDecl] : [];

            containerSymbol = this.getSymbolFromDeclPath(id, declPath, TypeScript.PullElementKind.SomeContainer);

            var acceptableAlias = true;

            if (containerSymbol) {
                acceptableAlias = (containerSymbol.kind & TypeScript.PullElementKind.AcceptableAlias) != 0;
            }

            if (!acceptableAlias && containerSymbol && containerSymbol.kind == 256 /* TypeAlias */) {
                if (!containerSymbol.isResolved) {
                    this.resolveDeclaredSymbol(containerSymbol, enclosingDecl, context);
                }

                var aliasedAssignedValue = (containerSymbol).getExportAssignedValueSymbol();
                var aliasedAssignedType = (containerSymbol).getExportAssignedTypeSymbol();
                var aliasedAssignedContainer = (containerSymbol).getExportAssignedContainerSymbol();

                if (aliasedAssignedValue || aliasedAssignedType || aliasedAssignedContainer) {
                    valueSymbol = aliasedAssignedValue;
                    typeSymbol = aliasedAssignedType;
                    containerSymbol = aliasedAssignedContainer;
                    acceptableAlias = true;
                }
            }

            if (!acceptableAlias) {
                enclosingDecl.addDiagnostic(new TypeScript.Diagnostic(enclosingDecl.getScriptName(), exportAssignmentAST.minChar, exportAssignmentAST.getLength(), TypeScript.DiagnosticCode.Export_assignments_may_only_be_made_with_variables_functions_classes_interfaces_enums_and_internal_modules));
                return this.semanticInfoChain.voidTypeSymbol;
            }

            if (!valueSymbol) {
                valueSymbol = this.getSymbolFromDeclPath(id, declPath, TypeScript.PullElementKind.SomeValue);
            }
            if (!typeSymbol) {
                typeSymbol = this.getSymbolFromDeclPath(id, declPath, TypeScript.PullElementKind.SomeType);
            }

            if (!valueSymbol && !typeSymbol && !containerSymbol) {
                context.postError(enclosingDecl.getScriptName(), exportAssignmentAST.minChar, exportAssignmentAST.getLength(), TypeScript.DiagnosticCode.Could_not_find_symbol_0, [id], enclosingDecl);
                return this.semanticInfoChain.voidTypeSymbol;
            }

            if (valueSymbol) {
                (parentSymbol).setExportAssignedValueSymbol(valueSymbol);
            }
            if (typeSymbol) {
                (parentSymbol).setExportAssignedTypeSymbol(typeSymbol);
            }
            if (containerSymbol) {
                (parentSymbol).setExportAssignedContainerSymbol(containerSymbol);
            }

            if (valueSymbol && !valueSymbol.isResolved) {
                this.resolveDeclaredSymbol(valueSymbol, enclosingDecl, context);
            }
            if (typeSymbol && !typeSymbol.isResolved) {
                this.resolveDeclaredSymbol(typeSymbol, enclosingDecl, context);
            }
            if (containerSymbol && !containerSymbol.isResolved) {
                this.resolveDeclaredSymbol(containerSymbol, enclosingDecl, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.resolveFunctionTypeSignature = function (funcDeclAST, enclosingDecl, context) {
            var funcDeclSymbol = null;

            var functionDecl = this.getDeclForAST(funcDeclAST);

            if (!functionDecl) {
                var semanticInfo = this.semanticInfoChain.getUnit(this.unitPath);
                var declCollectionContext = new TypeScript.DeclCollectionContext(semanticInfo, this.unitPath);

                if (enclosingDecl) {
                    declCollectionContext.pushParent(enclosingDecl);
                }

                TypeScript.getAstWalkerFactory().walk(funcDeclAST, TypeScript.preCollectDecls, TypeScript.postCollectDecls, null, declCollectionContext);

                functionDecl = this.getDeclForAST(funcDeclAST);
                this.currentUnit.addSynthesizedDecl(functionDecl);
            }

            if (!functionDecl.hasSymbol()) {
                var binder = new TypeScript.PullSymbolBinder(this.semanticInfoChain);
                binder.setUnit(this.unitPath);
                if (functionDecl.kind === 33554432 /* ConstructorType */) {
                    binder.bindConstructorTypeDeclarationToPullSymbol(functionDecl);
                } else {
                    binder.bindFunctionTypeDeclarationToPullSymbol(functionDecl);
                }
            }

            funcDeclSymbol = functionDecl.getSymbol();

            var signature = funcDeclSymbol.kind === 33554432 /* ConstructorType */ ? funcDeclSymbol.getConstructSignatures()[0] : funcDeclSymbol.getCallSignatures()[0];

            if (funcDeclAST.returnTypeAnnotation) {
                var returnTypeSymbol = this.resolveTypeReference(funcDeclAST.returnTypeAnnotation, functionDecl, context);

                signature.returnType = returnTypeSymbol;

                if (this.isTypeArgumentOrWrapper(returnTypeSymbol)) {
                    signature.hasAGenericParameter = true;

                    if (funcDeclSymbol) {
                        funcDeclSymbol.type.setHasGenericSignature();
                    }
                }
            }

            if (funcDeclAST.arguments) {
                for (var i = 0; i < funcDeclAST.arguments.members.length; i++) {
                    this.resolveFunctionTypeSignatureParameter(funcDeclAST.arguments.members[i], signature, functionDecl, context);
                }
            }

            if (funcDeclSymbol && signature.hasAGenericParameter) {
                funcDeclSymbol.type.setHasGenericSignature();
            }

            if (signature.hasAGenericParameter) {
                if (funcDeclSymbol) {
                    funcDeclSymbol.type.setHasGenericSignature();
                }
            }

            funcDeclSymbol.setResolved();

            if (context.typeCheck()) {
                this.typeCheckFunctionOverloads(funcDeclAST, context);
            }

            return funcDeclSymbol;
        };

        PullTypeResolver.prototype.resolveFunctionTypeSignatureParameter = function (argDeclAST, signature, enclosingDecl, context) {
            var paramDecl = this.getDeclForAST(argDeclAST);
            var paramSymbol = paramDecl.getSymbol();

            if (argDeclAST.typeExpr) {
                var typeRef = this.resolveTypeReference(argDeclAST.typeExpr, enclosingDecl, context);

                if (paramSymbol.isVarArg && !(typeRef.isArray() || typeRef == this.cachedArrayInterfaceType())) {
                    var diagnostic = context.postError(this.unitPath, argDeclAST.minChar, argDeclAST.getLength(), TypeScript.DiagnosticCode.Rest_parameters_must_be_array_types, null, enclosingDecl);
                    typeRef = this.getNewErrorTypeSymbol(diagnostic);
                }

                context.setTypeInContext(paramSymbol, typeRef);

                if (this.isTypeArgumentOrWrapper(typeRef)) {
                    signature.hasAGenericParameter = true;
                }
            } else {
                if (paramSymbol.isVarArg && paramSymbol.type) {
                    if (this.cachedArrayInterfaceType()) {
                        context.setTypeInContext(paramSymbol, TypeScript.specializeType(this.cachedArrayInterfaceType(), [paramSymbol.type], this, this.cachedArrayInterfaceType().getDeclarations()[0], context));
                    } else {
                        context.setTypeInContext(paramSymbol, paramSymbol.type);
                    }
                } else {
                    context.setTypeInContext(paramSymbol, this.semanticInfoChain.anyTypeSymbol);

                    if (this.compilationSettings.noImplicitAny && !context.isInInvocationExpression) {
                        context.postError(this.unitPath, argDeclAST.minChar, argDeclAST.getLength(), TypeScript.DiagnosticCode.Parameter_0_of_function_type_implicitly_has_an_any_type, [argDeclAST.id.actualText], enclosingDecl);
                    }
                }
            }

            paramSymbol.setResolved();
        };

        PullTypeResolver.prototype.resolveFunctionExpressionParameter = function (argDeclAST, contextParam, enclosingDecl, context) {
            var paramDecl = this.getDeclForAST(argDeclAST);
            var paramSymbol = paramDecl.getSymbol();

            if (argDeclAST.typeExpr) {
                var typeRef = this.resolveTypeReference(argDeclAST.typeExpr, enclosingDecl, context);

                if (paramSymbol.isVarArg && !(typeRef.isArray() || typeRef == this.cachedArrayInterfaceType())) {
                    var diagnostic = context.postError(this.unitPath, argDeclAST.minChar, argDeclAST.getLength(), TypeScript.DiagnosticCode.Rest_parameters_must_be_array_types, null, enclosingDecl);
                    typeRef = this.getNewErrorTypeSymbol(diagnostic);
                }

                context.setTypeInContext(paramSymbol, typeRef);
            } else {
                if (contextParam) {
                    context.setTypeInContext(paramSymbol, contextParam.type);
                } else {
                    if (paramSymbol.isVarArg && this.cachedArrayInterfaceType()) {
                        context.setTypeInContext(paramSymbol, TypeScript.specializeType(this.cachedArrayInterfaceType(), [this.semanticInfoChain.anyTypeSymbol], this, this.cachedArrayInterfaceType().getDeclarations()[0], context));
                    } else {
                        context.setTypeInContext(paramSymbol, this.semanticInfoChain.anyTypeSymbol);
                    }

                    if (this.compilationSettings.noImplicitAny && !context.isInInvocationExpression) {
                        var functionExpressionName = (paramDecl.getParentDecl()).getFunctionExpressionName();
                        if (functionExpressionName != "") {
                            context.postError(this.unitPath, argDeclAST.minChar, argDeclAST.getLength(), TypeScript.DiagnosticCode.Parameter_0_of_1_implicitly_has_an_any_type, [argDeclAST.id.actualText, functionExpressionName], enclosingDecl, true);
                        } else {
                            context.postError(this.unitPath, argDeclAST.minChar, argDeclAST.getLength(), TypeScript.DiagnosticCode.Parameter_0_of_lambda_function_implicitly_has_an_any_type, [argDeclAST.id.actualText], enclosingDecl, true);
                        }
                    }
                }
            }

            paramSymbol.setResolved();
        };

        PullTypeResolver.prototype.resolveInterfaceTypeReference = function (interfaceDeclAST, enclosingDecl, context) {
            var interfaceSymbol = null;

            var interfaceDecl = this.getDeclForAST(interfaceDeclAST);

            if (!interfaceDecl) {
                var semanticInfo = this.semanticInfoChain.getUnit(this.unitPath);
                var declCollectionContext = new TypeScript.DeclCollectionContext(semanticInfo, this.unitPath);

                if (enclosingDecl) {
                    declCollectionContext.pushParent(enclosingDecl);
                }

                TypeScript.getAstWalkerFactory().walk(interfaceDeclAST, TypeScript.preCollectDecls, TypeScript.postCollectDecls, null, declCollectionContext);

                var interfaceDecl = this.getDeclForAST(interfaceDeclAST);
                this.currentUnit.addSynthesizedDecl(interfaceDecl);

                var binder = new TypeScript.PullSymbolBinder(this.semanticInfoChain);

                binder.setUnit(this.unitPath);
                binder.bindObjectTypeDeclarationToPullSymbol(interfaceDecl);
            }

            interfaceSymbol = interfaceDecl.getSymbol();

            if (interfaceDeclAST.members) {
                var memberDecl = null;
                var memberSymbol = null;
                var memberType = null;
                var typeMembers = interfaceDeclAST.members;

                for (var i = 0; i < typeMembers.members.length; i++) {
                    memberDecl = this.getDeclForAST(typeMembers.members[i]);
                    memberSymbol = (memberDecl.kind & TypeScript.PullElementKind.SomeSignature) ? memberDecl.getSignatureSymbol() : memberDecl.getSymbol();

                    this.resolveDeclaredSymbol(memberSymbol, enclosingDecl, context);

                    memberType = memberSymbol.type;

                    if ((memberType && memberType.isGeneric()) || (memberSymbol.isSignature() && (memberSymbol).isGeneric())) {
                        interfaceSymbol.setHasGenericMember();
                    }
                }
            }

            interfaceSymbol.setResolved();

            if (context.typeCheck()) {
                if (!interfaceSymbol.hasBaseTypeConflict()) {
                    this.typeCheckMembersAgainstIndexer(interfaceSymbol, interfaceDecl, context);
                }
            }

            return interfaceSymbol;
        };

        PullTypeResolver.prototype.resolveTypeReference = function (typeRef, enclosingDecl, context) {
            if (typeRef === null) {
                return null;
            }

            var type = this.getSymbolForAST(typeRef);
            var aliasType = null;
            if (!type) {
                type = this.computeTypeReferenceSymbol(typeRef, enclosingDecl, context);

                if (type.kind == 4 /* Container */) {
                    var containerType = type;
                    var instanceSymbol = containerType.getInstanceSymbol();

                    if (instanceSymbol && (instanceSymbol.hasFlag(16384 /* ClassConstructorVariable */) || instanceSymbol.kind == 32768 /* ConstructorMethod */)) {
                        type = instanceSymbol.type.getAssociatedContainerType();
                    }
                }

                if (type && type.isAlias()) {
                    aliasType = type;
                    type = aliasType.getExportAssignedTypeSymbol();
                }

                if (type && !type.isGeneric()) {
                    this.setSymbolForAST(typeRef, type, context);
                    if (aliasType) {
                        this.currentUnit.setAliasSymbolForAST(typeRef, aliasType);
                    }
                }
            }

            if (type && !type.isError()) {
                if ((type.kind & TypeScript.PullElementKind.SomeType) === 0) {
                    if (type.kind & TypeScript.PullElementKind.SomeContainer) {
                        context.postError(this.unitPath, typeRef.minChar, typeRef.getLength(), TypeScript.DiagnosticCode.Type_reference_cannot_refer_to_container_0, [aliasType ? aliasType.toString() : type.toString()], enclosingDecl);
                    } else {
                        context.postError(this.unitPath, typeRef.minChar, typeRef.getLength(), TypeScript.DiagnosticCode.Type_reference_must_refer_to_type, null, enclosingDecl);
                    }
                }
            }

            return type;
        };

        PullTypeResolver.prototype.computeTypeReferenceSymbol = function (typeRef, enclosingDecl, context) {
            var typeDeclSymbol = null;
            var diagnostic = null;
            var typeSymbol = null;

            if (typeRef.term.nodeType() === 21 /* Name */) {
                var prevResolvingTypeReference = context.resolvingTypeReference;
                context.resolvingTypeReference = true;
                typeSymbol = this.resolveTypeNameExpression(typeRef.term, enclosingDecl, context);
                typeDeclSymbol = typeSymbol;

                context.resolvingTypeReference = prevResolvingTypeReference;
            } else if (typeRef.term.nodeType() === 13 /* FunctionDeclaration */) {
                typeDeclSymbol = this.resolveFunctionTypeSignature(typeRef.term, enclosingDecl, context);
            } else if (typeRef.term.nodeType() === 15 /* InterfaceDeclaration */) {
                typeDeclSymbol = this.resolveInterfaceTypeReference(typeRef.term, enclosingDecl, context);
            } else if (typeRef.term.nodeType() === 10 /* GenericType */) {
                typeSymbol = this.resolveGenericTypeReference(typeRef.term, enclosingDecl, context);
                typeDeclSymbol = typeSymbol;
            } else if (typeRef.term.nodeType() === 33 /* MemberAccessExpression */) {
                var dottedName = typeRef.term;

                prevResolvingTypeReference = context.resolvingTypeReference;
                typeSymbol = this.resolveDottedTypeNameExpression(dottedName, enclosingDecl, context);
                typeDeclSymbol = typeSymbol;
                context.resolvingTypeReference = prevResolvingTypeReference;
            } else if (typeRef.term.nodeType() === 5 /* StringLiteral */) {
                var stringConstantAST = typeRef.term;
                typeDeclSymbol = new TypeScript.PullStringConstantTypeSymbol(stringConstantAST.actualText);
                var decl = new TypeScript.PullDecl(stringConstantAST.actualText, stringConstantAST.actualText, typeDeclSymbol.kind, null, new TypeScript.TextSpan(stringConstantAST.minChar, stringConstantAST.getLength()), enclosingDecl.getScriptName());
                this.currentUnit.addSynthesizedDecl(decl);
                typeDeclSymbol.addDeclaration(decl);
            } else if (typeRef.term.nodeType() === 12 /* TypeQuery */) {
                var typeQuery = typeRef.term;

                var typeQueryTerm = typeQuery.name;
                if (typeQueryTerm.nodeType() === 11 /* TypeRef */) {
                    typeQueryTerm = (typeQueryTerm).term;
                }

                var savedResolvingTypeReference = context.resolvingTypeReference;
                context.resolvingTypeReference = false;
                var valueSymbol = this.resolveAST(typeQueryTerm, false, enclosingDecl, context);
                context.resolvingTypeReference = savedResolvingTypeReference;

                if (valueSymbol && valueSymbol.isAlias()) {
                    if ((valueSymbol).assignedValue) {
                        valueSymbol = (valueSymbol).assignedValue;
                    } else {
                        var containerSymbol = (valueSymbol).getExportAssignedContainerSymbol();
                        valueSymbol = (containerSymbol && containerSymbol.isContainer() && !containerSymbol.isEnum()) ? containerSymbol.getInstanceSymbol() : null;
                    }
                }

                if (valueSymbol) {
                    typeDeclSymbol = valueSymbol.type;
                } else {
                    typeDeclSymbol = this.getNewErrorTypeSymbol(null);
                }
            }

            if (!typeDeclSymbol) {
                context.postError(this.unitPath, typeRef.term.minChar, typeRef.term.getLength(), TypeScript.DiagnosticCode.Unable_to_resolve_type, null, enclosingDecl);
                return this.getNewErrorTypeSymbol(null);
            }

            if (typeDeclSymbol.isError()) {
                return typeDeclSymbol;
            }

            if (typeRef.arrayCount) {
                var arraySymbol = typeDeclSymbol.getArrayType();

                if (!arraySymbol) {
                    if (!this.cachedArrayInterfaceType().isResolved) {
                        this.resolveDeclaredSymbol(this.cachedArrayInterfaceType(), enclosingDecl, context);
                    }

                    if (this.genericTypeIsUsedWithoutRequiredTypeArguments(typeDeclSymbol, typeRef, context)) {
                        context.postError(this.unitPath, typeRef.minChar, typeRef.getLength(), TypeScript.DiagnosticCode.Generic_type_references_must_include_all_type_arguments, null, enclosingDecl);
                        typeDeclSymbol = this.specializeTypeToAny(typeDeclSymbol, enclosingDecl, context);
                    }

                    arraySymbol = TypeScript.specializeType(this.cachedArrayInterfaceType(), [typeDeclSymbol], this, this.cachedArrayInterfaceType().getDeclarations()[0], context, typeRef);

                    if (!arraySymbol) {
                        arraySymbol = this.semanticInfoChain.anyTypeSymbol;
                    }
                }

                if (typeRef.arrayCount > 1) {
                    for (var arity = typeRef.arrayCount - 1; arity > 0; arity--) {
                        var existingArraySymbol = arraySymbol.getArrayType();

                        if (!existingArraySymbol) {
                            arraySymbol = TypeScript.specializeType(this.cachedArrayInterfaceType(), [arraySymbol], this, this.cachedArrayInterfaceType().getDeclarations()[0], context, typeRef);
                        } else {
                            arraySymbol = existingArraySymbol;
                        }
                    }
                }

                typeDeclSymbol = arraySymbol;
            }

            return typeDeclSymbol;
        };

        PullTypeResolver.prototype.genericTypeIsUsedWithoutRequiredTypeArguments = function (typeSymbol, typeReference, context) {
            return typeSymbol.isNamedTypeSymbol() && typeSymbol.isGeneric() && !typeSymbol.isTypeParameter() && (typeSymbol.isResolved || (typeSymbol.inResolution && !context.inSpecialization)) && !typeSymbol.getIsSpecialized() && typeSymbol.getTypeParameters().length && (typeSymbol.getTypeArguments() == null && !this.isArrayOrEquivalent(typeSymbol)) && this.isTypeRefWithoutTypeArgs(typeReference);
        };

        PullTypeResolver.prototype.resolveVariableDeclaration = function (varDecl, context, enclosingDecl) {
            var _this = this;
            var decl = this.getDeclForAST(varDecl);

            if (enclosingDecl && decl.kind == 2048 /* Parameter */) {
                enclosingDecl.ensureSymbolIsBound();
            }

            var declSymbol = decl.getSymbol();
            var declParameterSymbol = decl.getValueDecl() ? decl.getValueDecl().getSymbol() : null;

            if (declSymbol.isResolved) {
                var declType = declSymbol.type;
                var valDecl = decl.getValueDecl();

                if (valDecl) {
                    var valSymbol = valDecl.getSymbol();

                    if (valSymbol && !valSymbol.isResolved) {
                        valSymbol.type = declType;
                        valSymbol.setResolved();
                    }
                }
                return declSymbol;
            }

            if (declSymbol.inResolution) {
                if (!context.inSpecialization) {
                    declSymbol.type = this.semanticInfoChain.anyTypeSymbol;
                    declSymbol.setResolved();
                    return declSymbol;
                }
            }

            declSymbol.startResolving();

            var wrapperDecl = this.getEnclosingDecl(decl);
            wrapperDecl = wrapperDecl ? wrapperDecl : enclosingDecl;

            var typeExprSymbol = null;
            var initExprSymbol = null;
            var initTypeSymbol = null;
            var inConstructorArgumentList = context.inConstructorArguments;
            context.inConstructorArguments = false;

            if (varDecl.typeExpr) {
                typeExprSymbol = this.resolveTypeReference(varDecl.typeExpr, wrapperDecl, context);

                if (!typeExprSymbol) {
                    diagnostic = context.postError(this.unitPath, varDecl.minChar, varDecl.getLength(), TypeScript.DiagnosticCode.Unable_to_resolve_type_of_0, [varDecl.id.actualText], decl);
                    declSymbol.type = this.getNewErrorTypeSymbol(diagnostic);

                    if (declParameterSymbol) {
                        context.setTypeInContext(declParameterSymbol, this.semanticInfoChain.anyTypeSymbol);
                    }
                } else if (typeExprSymbol.isError()) {
                    context.setTypeInContext(declSymbol, typeExprSymbol);
                    if (declParameterSymbol) {
                        context.setTypeInContext(declParameterSymbol, typeExprSymbol);
                    }
                } else {
                    if (typeExprSymbol == this.semanticInfoChain.anyTypeSymbol) {
                        decl.setFlag(16777216 /* IsAnnotatedWithAny */);
                    }

                    if (this.genericTypeIsUsedWithoutRequiredTypeArguments(typeExprSymbol, varDecl.typeExpr, context)) {
                        context.postError(this.unitPath, varDecl.typeExpr.minChar, varDecl.typeExpr.getLength(), TypeScript.DiagnosticCode.Generic_type_references_must_include_all_type_arguments, null, enclosingDecl);

                        typeExprSymbol = this.specializeTypeToAny(typeExprSymbol, enclosingDecl, context);
                    }

                    if (typeExprSymbol.isContainer()) {
                        var exportedTypeSymbol = (typeExprSymbol).getExportAssignedTypeSymbol();

                        if (exportedTypeSymbol) {
                            typeExprSymbol = exportedTypeSymbol;
                        } else {
                            typeExprSymbol = typeExprSymbol.type;

                            if (typeExprSymbol.isAlias()) {
                                typeExprSymbol = (typeExprSymbol).getExportAssignedTypeSymbol();
                            }

                            if (typeExprSymbol && typeExprSymbol.isContainer() && !typeExprSymbol.isEnum()) {
                                var instanceSymbol = (typeExprSymbol).getInstanceSymbol();

                                if (!instanceSymbol || !TypeScript.PullHelpers.symbolIsEnum(instanceSymbol)) {
                                    typeExprSymbol = this.getNewErrorTypeSymbol(diagnostic);
                                } else {
                                    typeExprSymbol = instanceSymbol.type;
                                }
                            }
                        }
                    } else if (declSymbol.isVarArg && !(typeExprSymbol.isArray() || typeExprSymbol == this.cachedArrayInterfaceType())) {
                        var diagnostic = context.postError(this.unitPath, varDecl.minChar, varDecl.getLength(), TypeScript.DiagnosticCode.Rest_parameters_must_be_array_types, null, enclosingDecl);
                        typeExprSymbol = this.getNewErrorTypeSymbol(diagnostic);
                    }

                    context.setTypeInContext(declSymbol, typeExprSymbol);

                    if (declParameterSymbol) {
                        declParameterSymbol.type = typeExprSymbol;
                    }

                    if (typeExprSymbol.kind == 16777216 /* FunctionType */) {
                        typeExprSymbol.setFunctionSymbol(declSymbol);
                    }

                    if ((varDecl.nodeType() === 20 /* Parameter */) && enclosingDecl && ((typeExprSymbol.isGeneric() && !typeExprSymbol.isArray()) || this.isTypeArgumentOrWrapper(typeExprSymbol))) {
                        var signature = enclosingDecl.getSpecializingSignatureSymbol();

                        if (signature) {
                            signature.hasAGenericParameter = true;
                        }
                    }
                }
            }

            if (varDecl.init && (context.typeCheck() || !varDecl.typeExpr)) {
                if (typeExprSymbol) {
                    context.pushContextualType(typeExprSymbol, context.inProvisionalResolution(), null);
                }

                if (inConstructorArgumentList) {
                    context.inConstructorArguments = inConstructorArgumentList;
                }

                context.isInStaticInitializer = (decl.flags & 16 /* Static */) != 0;
                initExprSymbol = this.resolveAST(varDecl.init, typeExprSymbol != null, wrapperDecl, context);
                context.isInStaticInitializer = false;

                context.inConstructorArguments = false;

                if (typeExprSymbol) {
                    context.popContextualType();
                }

                if (!initExprSymbol) {
                    diagnostic = context.postError(this.unitPath, varDecl.minChar, varDecl.getLength(), TypeScript.DiagnosticCode.Unable_to_resolve_type_of_0, [varDecl.id.actualText], decl);

                    if (!varDecl.typeExpr) {
                        context.setTypeInContext(declSymbol, this.getNewErrorTypeSymbol(diagnostic));

                        if (declParameterSymbol) {
                            context.setTypeInContext(declParameterSymbol, this.semanticInfoChain.anyTypeSymbol);
                        }
                    }
                } else {
                    initTypeSymbol = initExprSymbol.type;

                    if (!varDecl.typeExpr) {
                        context.setTypeInContext(declSymbol, this.widenType(initTypeSymbol));

                        if (declParameterSymbol) {
                            context.setTypeInContext(declParameterSymbol, initTypeSymbol);
                        }

                        if (this.compilationSettings.noImplicitAny) {
                            if ((declSymbol.type != initTypeSymbol) && (declSymbol.type == this.semanticInfoChain.anyTypeSymbol)) {
                                context.postError(this.unitPath, varDecl.minChar, varDecl.getLength(), TypeScript.DiagnosticCode.Variable_0_implicitly_has_an_any_type, [varDecl.id.actualText], enclosingDecl);
                            }
                        }
                    }
                }
            }

            if (!(varDecl.typeExpr || varDecl.init)) {
                var defaultType = this.semanticInfoChain.anyTypeSymbol;

                if (this.compilationSettings.noImplicitAny && ((varDecl.getVarFlags() & 16384 /* ForInVariable */) === 0)) {
                    if (wrapperDecl.kind == 16384 /* Function */ || wrapperDecl.kind == 65536 /* Method */ || wrapperDecl.kind == 32768 /* ConstructorMethod */ || wrapperDecl.kind == 2097152 /* ConstructSignature */) {
                        context.postError(this.unitPath, varDecl.minChar, varDecl.getLength(), TypeScript.DiagnosticCode.Parameter_0_of_1_implicitly_has_an_any_type, [varDecl.id.actualText, enclosingDecl.name], enclosingDecl);
                    } else if (wrapperDecl.kind == 8388608 /* ObjectType */) {
                        context.postError(this.unitPath, varDecl.minChar, varDecl.getLength(), TypeScript.DiagnosticCode.Member_0_of_object_type_implicitly_has_an_any_type, [varDecl.id.actualText], enclosingDecl);
                    } else if (wrapperDecl.kind != 1073741824 /* CatchBlock */) {
                        context.postError(this.unitPath, varDecl.minChar, varDecl.getLength(), TypeScript.DiagnosticCode.Variable_0_implicitly_has_an_any_type, [varDecl.id.actualText], enclosingDecl);
                    }
                }

                if (declSymbol.isVarArg) {
                    defaultType = TypeScript.specializeType(this.cachedArrayInterfaceType(), [defaultType], this, this.cachedArrayInterfaceType().getDeclarations()[0], context);
                }

                context.setTypeInContext(declSymbol, defaultType);

                if (declParameterSymbol) {
                    declParameterSymbol.type = defaultType;
                }
            } else if (context.typeCheck()) {
                if (typeExprSymbol && typeExprSymbol.isAlias()) {
                    typeExprSymbol = (typeExprSymbol).getExportAssignedTypeSymbol();
                }

                if (typeExprSymbol && typeExprSymbol.isContainer()) {
                    var exportedTypeSymbol = (typeExprSymbol).getExportAssignedTypeSymbol();

                    if (exportedTypeSymbol) {
                        typeExprSymbol = exportedTypeSymbol;
                    } else {
                        var instanceTypeSymbol = (typeExprSymbol).getInstanceType();

                        if (!instanceTypeSymbol || !TypeScript.PullHelpers.symbolIsEnum(instanceTypeSymbol)) {
                            context.postError(this.unitPath, varDecl.minChar, varDecl.getLength(), TypeScript.DiagnosticCode.Tried_to_set_variable_type_to_uninitialized_module_type_0, [typeExprSymbol.toString()], enclosingDecl);
                            typeExprSymbol = null;
                        } else {
                            typeExprSymbol = instanceTypeSymbol;
                        }
                    }
                }

                initTypeSymbol = this.getInstanceTypeForAssignment(varDecl, initTypeSymbol, enclosingDecl, context);

                if (initTypeSymbol && typeExprSymbol) {
                    var comparisonInfo = new TypeComparisonInfo();

                    var isAssignable = this.sourceIsAssignableToTarget(initTypeSymbol, typeExprSymbol, context, comparisonInfo);

                    if (!isAssignable) {
                        if (comparisonInfo.message) {
                            context.postError(this.unitPath, varDecl.minChar, varDecl.getLength(), TypeScript.DiagnosticCode.Cannot_convert_0_to_1_NL_2, [initTypeSymbol.toString(), typeExprSymbol.toString(), comparisonInfo.message], enclosingDecl);
                        } else {
                            context.postError(this.unitPath, varDecl.minChar, varDecl.getLength(), TypeScript.DiagnosticCode.Cannot_convert_0_to_1, [initTypeSymbol.toString(), typeExprSymbol.toString()], enclosingDecl);
                        }
                    }
                }
            }

            declSymbol.setResolved();

            if (declParameterSymbol) {
                declParameterSymbol.setResolved();
            }

            if (context.typeCheck()) {
                if (varDecl.init && varDecl.nodeType() === 20 /* Parameter */) {
                    var containerSignature = enclosingDecl.getSignatureSymbol();
                    if (containerSignature && !containerSignature.isDefinition()) {
                        context.postError(this.unitPath, varDecl.minChar, varDecl.getLength(), TypeScript.DiagnosticCode.Default_arguments_are_not_allowed_in_an_overload_parameter, [], enclosingDecl);
                    }
                }
                if (declSymbol.kind != 2048 /* Parameter */ && (declSymbol.kind != 4096 /* Property */ || declSymbol.getContainer().isNamedTypeSymbol())) {
                    this.checkSymbolPrivacy(declSymbol, declSymbol.type, context, function (symbol) {
                        return _this.variablePrivacyErrorReporter(declSymbol, symbol, context);
                    });
                }
            }

            context.inConstructorArguments = inConstructorArgumentList;

            return declSymbol;
        };

        PullTypeResolver.prototype.resolveTypeParameterDeclaration = function (typeParameterAST, context) {
            var typeParameterDecl = this.getDeclForAST(typeParameterAST);
            var typeParameterSymbol = typeParameterDecl.getSymbol();

            if (typeParameterSymbol.isResolved || typeParameterSymbol.inResolution) {
                return typeParameterSymbol;
            }

            typeParameterSymbol.startResolving();

            if (typeParameterAST.constraint) {
                var enclosingDecl = this.getEnclosingDecl(typeParameterDecl);
                var constraintTypeSymbol = this.resolveTypeReference(typeParameterAST.constraint, enclosingDecl, context);

                if (constraintTypeSymbol && constraintTypeSymbol.isPrimitive() && !constraintTypeSymbol.isError()) {
                    context.postError(this.unitPath, typeParameterAST.minChar, typeParameterAST.getLength(), TypeScript.DiagnosticCode.Type_parameter_constraint_cannot_be_a_primitive_type, null, enclosingDecl);
                    constraintTypeSymbol = this.specializeTypeToAny(constraintTypeSymbol, enclosingDecl, context);
                } else if (this.genericTypeIsUsedWithoutRequiredTypeArguments(constraintTypeSymbol, typeParameterAST.constraint, context)) {
                    context.postError(this.unitPath, typeParameterAST.constraint.minChar, typeParameterAST.constraint.getLength(), TypeScript.DiagnosticCode.Generic_type_references_must_include_all_type_arguments, null, enclosingDecl);
                    constraintTypeSymbol = this.specializeTypeToAny(constraintTypeSymbol, enclosingDecl, context);
                }

                if (constraintTypeSymbol) {
                    typeParameterSymbol.setConstraint(constraintTypeSymbol);
                }
            }

            typeParameterSymbol.setResolved();

            return typeParameterSymbol;
        };

        PullTypeResolver.prototype.resolveFunctionBodyReturnTypes = function (funcDeclAST, signature, useContextualType, enclosingDecl, context) {
            var _this = this;
            var returnStatements = [];

            var enclosingDeclStack = [enclosingDecl];

            var preFindReturnExpressionTypes = function (ast, parent, walker) {
                var go = true;

                switch (ast.nodeType()) {
                    case 13 /* FunctionDeclaration */:
                        go = false;
                        break;

                    case 94 /* ReturnStatement */:
                        var returnStatement = ast;
                        enclosingDecl.setFlag(4194304 /* HasReturnStatement */);
                        returnStatements[returnStatements.length] = { returnStatement: returnStatement, enclosingDecl: enclosingDeclStack[enclosingDeclStack.length - 1] };
                        go = false;
                        break;

                    case 102 /* CatchClause */:
                    case 100 /* WithStatement */:
                        enclosingDeclStack[enclosingDeclStack.length] = _this.getDeclForAST(ast);
                        break;

                    default:
                        break;
                }

                walker.options.goChildren = go;

                return ast;
            };

            var postFindReturnExpressionEnclosingDecls = function (ast, parent, walker) {
                switch (ast.nodeType()) {
                    case 102 /* CatchClause */:
                    case 100 /* WithStatement */:
                        enclosingDeclStack.length--;
                        break;
                    default:
                        break;
                }

                walker.options.goChildren = true;

                return ast;
            };

            TypeScript.getAstWalkerFactory().walk(funcDeclAST.block, preFindReturnExpressionTypes, postFindReturnExpressionEnclosingDecls);

            if (!returnStatements.length) {
                signature.returnType = this.semanticInfoChain.voidTypeSymbol;
            } else {
                var returnExpressionSymbols = [];
                var returnType;

                for (var i = 0; i < returnStatements.length; i++) {
                    if (returnStatements[i].returnStatement.returnExpression) {
                        returnType = this.resolveAST(returnStatements[i].returnStatement.returnExpression, useContextualType, returnStatements[i].enclosingDecl, context).type;

                        if (returnType.isError()) {
                            signature.returnType = returnType;
                            return;
                        } else {
                            this.setSymbolForAST(returnStatements[i].returnStatement, returnType, context);
                        }

                        returnExpressionSymbols[returnExpressionSymbols.length] = returnType;
                    }
                }

                if (!returnExpressionSymbols.length) {
                    signature.returnType = this.semanticInfoChain.voidTypeSymbol;
                } else {
                    var collection = {
                        getLength: function () {
                            return returnExpressionSymbols.length;
                        },
                        setTypeAtIndex: function (index, type) {
                        },
                        getTypeAtIndex: function (index) {
                            return returnExpressionSymbols[index].type;
                        }
                    };

                    returnType = this.findBestCommonType(returnExpressionSymbols[0], null, collection, context, new TypeComparisonInfo());

                    if (useContextualType && returnType == this.semanticInfoChain.anyTypeSymbol) {
                        var contextualType = context.getContextualType();

                        if (contextualType) {
                            returnType = contextualType;
                        }
                    }

                    var functionDecl = this.getDeclForAST(funcDeclAST);
                    var functionSymbol = functionDecl.getSymbol();

                    if (returnType) {
                        var previousReturnType = returnType;
                        var newReturnType = this.widenType(returnType);
                        signature.returnType = newReturnType;

                        if (this.compilationSettings.noImplicitAny) {
                            if (previousReturnType !== newReturnType && newReturnType === this.semanticInfoChain.anyTypeSymbol) {
                                var functionName = enclosingDecl.name;
                                if (functionName == "") {
                                    functionName = (enclosingDecl).getFunctionExpressionName();
                                }

                                if (functionName != "") {
                                    context.postError(this.unitPath, funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode._0_which_lacks_return_type_annotation_implicitly_has_an_any_return_type, [functionName], enclosingDecl);
                                } else {
                                    context.postError(this.unitPath, funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_any_return_type, [], enclosingDecl);
                                }
                            }
                        }
                    }

                    if (this.isTypeArgumentOrWrapper(returnType) && functionSymbol) {
                        functionSymbol.type.setHasGenericSignature();
                    }
                }
            }
        };

        PullTypeResolver.prototype.resolveFunctionDeclaration = function (funcDeclAST, context) {
            var _this = this;
            var funcDecl = this.getDeclForAST(funcDeclAST);

            var funcSymbol = funcDecl.getSymbol();

            var signature = funcDecl.getSpecializingSignatureSymbol();

            var hadError = false;

            var isConstructor = funcDeclAST.isConstructor || TypeScript.hasFlag(funcDeclAST.getFunctionFlags(), 1024 /* ConstructMember */);

            if (signature) {
                if (signature.isResolved) {
                    return funcSymbol;
                }

                if (isConstructor && !signature.inResolution) {
                    var classAST = funcDeclAST.classDecl;

                    if (classAST) {
                        var classDecl = this.getDeclForAST(classAST);
                        var classSymbol = classDecl.getSymbol();

                        if (!classSymbol.isResolved && !classSymbol.inResolution) {
                            this.resolveDeclaredSymbol(classSymbol, this.getEnclosingDecl(classDecl), context);
                        }
                    }
                }

                var diagnostic;

                var functionTypeSymbol = funcSymbol && funcSymbol.type;

                if (signature.inResolution) {
                    if (funcDeclAST.returnTypeAnnotation) {
                        var returnTypeSymbol = this.resolveTypeReference(funcDeclAST.returnTypeAnnotation, funcDecl, context);
                        if (!returnTypeSymbol) {
                            diagnostic = context.postError(this.unitPath, funcDeclAST.returnTypeAnnotation.minChar, funcDeclAST.returnTypeAnnotation.getLength(), TypeScript.DiagnosticCode.Cannot_resolve_return_type_reference, null, funcDecl);
                            signature.returnType = this.getNewErrorTypeSymbol(diagnostic);
                            hadError = true;
                        } else {
                            if (this.isTypeArgumentOrWrapper(returnTypeSymbol)) {
                                signature.hasAGenericParameter = true;
                                if (funcSymbol) {
                                    funcSymbol.type.setHasGenericSignature();
                                }
                            }
                            signature.returnType = returnTypeSymbol;

                            if (isConstructor && returnTypeSymbol === this.semanticInfoChain.voidTypeSymbol) {
                                context.postError(this.unitPath, funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode.Constructors_cannot_have_a_return_type_of_void, null, funcDecl);
                            }
                        }
                    } else {
                        signature.returnType = this.semanticInfoChain.anyTypeSymbol;
                    }

                    if (funcSymbol) {
                        funcSymbol.setUnresolved();
                        if (funcSymbol.type === this.semanticInfoChain.anyTypeSymbol) {
                            funcSymbol.type = functionTypeSymbol;
                        }
                    }
                    signature.setResolved();
                    return funcSymbol;
                }

                if (funcSymbol) {
                    funcSymbol.startResolving();
                }
                signature.startResolving();

                if (funcDeclAST.typeArguments) {
                    for (var i = 0; i < funcDeclAST.typeArguments.members.length; i++) {
                        this.resolveTypeParameterDeclaration(funcDeclAST.typeArguments.members[i], context);
                    }
                }

                if (funcDeclAST.arguments) {
                    var prevInConstructorArguments = context.inConstructorArguments;
                    context.inConstructorArguments = isConstructor;
                    for (var i = 0; i < funcDeclAST.arguments.members.length; i++) {
                        this.resolveVariableDeclaration(funcDeclAST.arguments.members[i], context, funcDecl);
                    }
                    context.inConstructorArguments = prevInConstructorArguments;
                }

                if (signature.isGeneric()) {
                    if (funcSymbol) {
                        funcSymbol.type.setHasGenericSignature();
                    }
                }

                if (funcDeclAST.returnTypeAnnotation) {
                    var prevReturnTypeSymbol = signature.returnType;

                    returnTypeSymbol = this.resolveTypeReference(funcDeclAST.returnTypeAnnotation, funcDecl, context);

                    if (!returnTypeSymbol) {
                        diagnostic = context.postError(this.unitPath, funcDeclAST.returnTypeAnnotation.minChar, funcDeclAST.returnTypeAnnotation.getLength(), TypeScript.DiagnosticCode.Cannot_resolve_return_type_reference, null, funcDecl);
                        signature.returnType = this.getNewErrorTypeSymbol(diagnostic);

                        hadError = true;
                    } else if (!(this.isTypeArgumentOrWrapper(returnTypeSymbol) && prevReturnTypeSymbol && !this.isTypeArgumentOrWrapper(prevReturnTypeSymbol))) {
                        if (this.isTypeArgumentOrWrapper(returnTypeSymbol)) {
                            signature.hasAGenericParameter = true;

                            if (funcSymbol) {
                                funcSymbol.type.setHasGenericSignature();
                            }
                        }

                        signature.returnType = returnTypeSymbol;

                        if (isConstructor && returnTypeSymbol === this.semanticInfoChain.voidTypeSymbol) {
                            context.postError(this.unitPath, funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode.Constructors_cannot_have_a_return_type_of_void, null, funcDecl);
                        }
                    }
                } else if (!funcDeclAST.isConstructor && !funcDeclAST.isConstructMember()) {
                    if (funcDeclAST.isSignature()) {
                        signature.returnType = this.semanticInfoChain.anyTypeSymbol;

                        if (this.compilationSettings.noImplicitAny) {
                            var funcDeclASTName = funcDeclAST.name;
                            if (funcDeclASTName) {
                                context.postError(this.unitPath, funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode._0_which_lacks_return_type_annotation_implicitly_has_an_any_return_type, [funcDeclASTName.actualText], funcDecl);
                            } else {
                                context.postError(this.unitPath, funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode.Lambda_Function_which_lacks_return_type_annotation_implicitly_has_an_any_return_type, [], funcDecl);
                            }
                        }
                    } else {
                        this.resolveFunctionBodyReturnTypes(funcDeclAST, signature, false, funcDecl, context);
                    }
                } else if (funcDeclAST.isConstructMember()) {
                    if (funcDeclAST.isSignature()) {
                        signature.returnType = this.semanticInfoChain.anyTypeSymbol;

                        if (this.compilationSettings.noImplicitAny) {
                            context.postError(this.unitPath, funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode.Constructor_signature_which_lacks_return_type_annotation_implicitly_has_an_any_return_type, [], funcDecl);
                        }
                    }
                }

                if (!hadError) {
                    if (funcSymbol) {
                        funcSymbol.setUnresolved();
                        if (funcSymbol.type === this.semanticInfoChain.anyTypeSymbol) {
                            funcSymbol.type = functionTypeSymbol;
                        }
                    }
                    signature.setResolved();
                }
            }

            if (context.inTypeCheck && (!context.inSpecialization || !signature.isGeneric())) {
                var prevSeenSuperConstructorCall = this.seenSuperConstructorCall;

                PullTypeResolver.typeCheckCallBacks.push(function () {
                    if (signature.hasBeenChecked) {
                        return;
                    }

                    _this.setUnitPath(funcDecl.getScriptName());
                    _this.seenSuperConstructorCall = false;

                    _this.resolveAST(funcDeclAST.block, false, funcDecl, context);

                    _this.validateVariableDeclarationGroups(funcDecl, context);

                    var enclosingDecl = _this.getEnclosingDecl(funcDecl);

                    var hasReturn = (funcDecl.flags & (2048 /* Signature */ | 4194304 /* HasReturnStatement */)) != 0;

                    var parameters = signature.parameters;

                    if (funcDeclAST.isConstructor || TypeScript.hasFlag(funcDeclAST.getFunctionFlags(), 1024 /* ConstructMember */)) {
                        if (funcDecl.getSignatureSymbol() && funcDecl.getSignatureSymbol().isDefinition() && _this.enclosingClassIsDerived(funcDecl)) {
                            if (!_this.seenSuperConstructorCall) {
                                context.postError(_this.unitPath, funcDeclAST.minChar, 11, TypeScript.DiagnosticCode.Constructors_for_derived_classes_must_contain_a_super_call, null, enclosingDecl);
                            } else if (_this.superCallMustBeFirstStatementInConstructor(funcDecl, enclosingDecl)) {
                                var firstStatement = _this.getFirstStatementFromFunctionDeclAST(funcDeclAST);
                                if (!firstStatement || !_this.isSuperCallNode(firstStatement)) {
                                    context.postError(_this.unitPath, funcDeclAST.minChar, 11, TypeScript.DiagnosticCode.A_super_call_must_be_the_first_statement_in_the_constructor_when_a_class_contains_initialized_properties_or_has_parameter_properties, null, enclosingDecl);
                                }
                            }
                        }
                        _this.typeCheckFunctionOverloads(funcDeclAST, context);
                    } else if (TypeScript.hasFlag(funcDeclAST.getFunctionFlags(), 4096 /* IndexerMember */)) {
                        var allIndexSignatures = enclosingDecl.getSymbol().type.getIndexSignatures();

                        for (var i = 0; i < allIndexSignatures.length; i++) {
                            if (!allIndexSignatures[i].isResolved) {
                                _this.resolveDeclaredSymbol(allIndexSignatures[i], allIndexSignatures[i].getDeclarations()[0].getParentDecl(), context);
                            }

                            if (allIndexSignatures[i].parameters[0].type !== parameters[0].type) {
                                var stringIndexSignature = null;
                                var numberIndexSignature = null;

                                var indexSignature = signature;

                                var isNumericIndexer = parameters[0].type === _this.semanticInfoChain.numberTypeSymbol;

                                if (isNumericIndexer) {
                                    numberIndexSignature = indexSignature;
                                    stringIndexSignature = allIndexSignatures[i];
                                } else {
                                    numberIndexSignature = allIndexSignatures[i];
                                    stringIndexSignature = indexSignature;

                                    if (enclosingDecl.getSymbol() === numberIndexSignature.getDeclarations()[0].getParentDecl().getSymbol()) {
                                        break;
                                    }
                                }
                                var comparisonInfo = new TypeComparisonInfo();
                                var resolutionContext = new TypeScript.PullTypeResolutionContext();
                                if (!_this.sourceIsSubtypeOfTarget(numberIndexSignature.returnType, stringIndexSignature.returnType, resolutionContext, comparisonInfo)) {
                                    if (comparisonInfo.message) {
                                        context.postError(_this.unitPath, funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode.Numeric_indexer_type_0_must_be_a_subtype_of_string_indexer_type_1_NL_2, [numberIndexSignature.returnType.toString(), stringIndexSignature.returnType.toString(), comparisonInfo.message], enclosingDecl);
                                    } else {
                                        context.postError(_this.unitPath, funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode.Numeric_indexer_type_0_must_be_a_subtype_of_string_indexer_type_1, [numberIndexSignature.returnType.toString(), stringIndexSignature.returnType.toString()], enclosingDecl);
                                    }
                                }
                                break;
                            }
                        }

                        var allMembers = enclosingDecl.getSymbol().type.getAllMembers(TypeScript.PullElementKind.All, true);
                        for (var i = 0; i < allMembers.length; i++) {
                            var name = allMembers[i].name;
                            if (name) {
                                if (!allMembers[i].isResolved) {
                                    _this.resolveDeclaredSymbol(allMembers[i], allMembers[i].getDeclarations()[0].getParentDecl(), context);
                                }

                                if (enclosingDecl.getSymbol() !== allMembers[i].getContainer()) {
                                    var isMemberNumeric = isFinite(+name);
                                    if (isNumericIndexer === isMemberNumeric) {
                                        _this.checkThatMemberIsSubtypeOfIndexer(allMembers[i], indexSignature, funcDeclAST, context, enclosingDecl, isNumericIndexer);
                                    }
                                }
                            }
                        }
                    } else {
                        if (funcDeclAST.block && funcDeclAST.returnTypeAnnotation != null && !hasReturn) {
                            var isVoidOrAny = _this.isAnyOrEquivalent(returnTypeSymbol) || returnTypeSymbol === _this.semanticInfoChain.voidTypeSymbol;

                            if (!isVoidOrAny && !(funcDeclAST.block.statements.members.length > 0 && funcDeclAST.block.statements.members[0].nodeType() === 96 /* ThrowStatement */)) {
                                var funcName = funcDecl.getDisplayName();
                                funcName = funcName ? funcName : "expression";

                                context.postError(_this.unitPath, funcDeclAST.returnTypeAnnotation.minChar, funcDeclAST.returnTypeAnnotation.getLength(), TypeScript.DiagnosticCode.Function_0_declared_a_non_void_return_type_but_has_no_return_expression, [funcName], enclosingDecl);
                            }
                        }
                        _this.typeCheckFunctionOverloads(funcDeclAST, context);
                    }

                    _this.checkFunctionTypePrivacy(funcDeclAST, false, context);
                    _this.seenSuperConstructorCall = prevSeenSuperConstructorCall;

                    signature.hasBeenChecked = true;
                });
            }

            return funcSymbol;
        };

        PullTypeResolver.prototype.resolveGetAccessorDeclaration = function (funcDeclAST, context) {
            var funcDecl = this.getDeclForAST(funcDeclAST);
            var accessorSymbol = funcDecl.getSymbol();

            var getterSymbol = accessorSymbol.getGetter();
            var getterTypeSymbol = getterSymbol.type;

            var signature = getterTypeSymbol.getCallSignatures()[0];

            var hadError = false;
            var diagnostic;

            if (signature) {
                if (signature.isResolved) {
                    return accessorSymbol;
                }

                if (signature.inResolution) {
                    signature.returnType = this.semanticInfoChain.anyTypeSymbol;
                    signature.setResolved();

                    return accessorSymbol;
                }

                signature.startResolving();

                if (funcDeclAST.arguments) {
                    for (var i = 0; i < funcDeclAST.arguments.members.length; i++) {
                        this.resolveVariableDeclaration(funcDeclAST.arguments.members[i], context, funcDecl);
                    }
                }

                if (signature.hasAGenericParameter) {
                    if (getterSymbol) {
                        getterTypeSymbol.setHasGenericSignature();
                    }
                }

                if (funcDeclAST.returnTypeAnnotation) {
                    var returnTypeSymbol = this.resolveTypeReference(funcDeclAST.returnTypeAnnotation, funcDecl, context);

                    if (!returnTypeSymbol) {
                        diagnostic = context.postError(this.unitPath, funcDeclAST.returnTypeAnnotation.minChar, funcDeclAST.returnTypeAnnotation.getLength(), TypeScript.DiagnosticCode.Cannot_resolve_return_type_reference, null, funcDecl);
                        signature.returnType = this.getNewErrorTypeSymbol(diagnostic);

                        hadError = true;
                    } else {
                        if (this.isTypeArgumentOrWrapper(returnTypeSymbol)) {
                            signature.hasAGenericParameter = true;

                            if (getterSymbol) {
                                getterTypeSymbol.setHasGenericSignature();
                            }
                        }

                        signature.returnType = returnTypeSymbol;
                    }
                } else {
                    if (funcDeclAST.isSignature()) {
                        signature.returnType = this.semanticInfoChain.anyTypeSymbol;
                    } else {
                        this.resolveFunctionBodyReturnTypes(funcDeclAST, signature, false, funcDecl, context);
                    }
                }

                if (!hadError) {
                    signature.setResolved();
                }
            }

            var accessorType = signature.returnType;

            var setter = accessorSymbol.getSetter();

            if (setter) {
                var setterType = setter.type;
                var setterSig = setterType.getCallSignatures()[0];

                if (setterSig.isResolved) {
                    var setterParameters = setterSig.parameters;

                    if (setterParameters.length) {
                        var setterParameter = setterParameters[0];
                        var setterParameterType = setterParameter.type;

                        if (!this.typesAreIdentical(accessorType, setterParameterType)) {
                            diagnostic = context.postError(this.unitPath, funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode.get_and_set_accessor_must_have_the_same_type, null, this.getEnclosingDecl(funcDecl));
                            accessorSymbol.type = this.getNewErrorTypeSymbol(diagnostic);
                        }
                    }
                } else {
                    accessorSymbol.type = accessorType;
                }
            } else {
                accessorSymbol.type = accessorType;
            }

            if (context.typeCheck()) {
                var prevSeenSuperConstructorCall = this.seenSuperConstructorCall;
                this.seenSuperConstructorCall = false;

                this.resolveAST(funcDeclAST.block, false, funcDecl, context);

                this.validateVariableDeclarationGroups(funcDecl, context);

                var enclosingDecl = this.getEnclosingDecl(funcDecl);

                var hasReturn = (funcDecl.flags & (2048 /* Signature */ | 4194304 /* HasReturnStatement */)) != 0;

                var isGetter = TypeScript.hasFlag(funcDeclAST.getFunctionFlags(), 32 /* GetAccessor */);
                var isSetter = !isGetter;

                var getter = accessorSymbol.getGetter();
                var setter = accessorSymbol.getSetter();

                var funcNameAST = funcDeclAST.name;

                if (!hasReturn) {
                    if (!(funcDeclAST.block.statements.members.length > 0 && funcDeclAST.block.statements.members[0].nodeType() === 96 /* ThrowStatement */)) {
                        context.postError(this.unitPath, funcNameAST.minChar, funcNameAST.getLength(), TypeScript.DiagnosticCode.Getters_must_return_a_value, null, enclosingDecl);
                    }
                }

                if (getter && setter) {
                    var getterDecl = getter.getDeclarations()[0];
                    var setterDecl = setter.getDeclarations()[0];

                    var getterIsPrivate = getterDecl.flags & 2 /* Private */;
                    var setterIsPrivate = setterDecl.flags & 2 /* Private */;

                    if (getterIsPrivate != setterIsPrivate) {
                        context.postError(this.unitPath, funcNameAST.minChar, funcNameAST.getLength(), TypeScript.DiagnosticCode.Getter_and_setter_accessors_do_not_agree_in_visibility, null, enclosingDecl);
                    }
                }

                this.checkFunctionTypePrivacy(funcDeclAST, false, context);
            }

            return accessorSymbol;
        };

        PullTypeResolver.prototype.resolveSetAccessorDeclaration = function (funcDeclAST, context) {
            var funcDecl = this.getDeclForAST(funcDeclAST);
            var accessorSymbol = funcDecl.getSymbol();

            var setterSymbol = accessorSymbol.getSetter();
            var setterTypeSymbol = setterSymbol.type;

            var signature = setterTypeSymbol.getCallSignatures()[0];

            var hadError = false;

            if (signature) {
                if (signature.isResolved) {
                    return accessorSymbol;
                }

                if (signature.inResolution) {
                    signature.returnType = this.semanticInfoChain.anyTypeSymbol;
                    signature.setResolved();

                    return accessorSymbol;
                }

                signature.startResolving();

                if (funcDeclAST.arguments) {
                    for (var i = 0; i < funcDeclAST.arguments.members.length; i++) {
                        this.resolveVariableDeclaration(funcDeclAST.arguments.members[i], context, funcDecl);
                    }
                }

                if (signature.hasAGenericParameter) {
                    if (setterSymbol) {
                        setterTypeSymbol.setHasGenericSignature();
                    }
                }

                if (!hadError) {
                    signature.setResolved();
                }
            }

            var parameters = signature.parameters;

            var getter = accessorSymbol.getGetter();

            var accessorType = parameters.length ? parameters[0].type : getter ? getter.type : this.semanticInfoChain.undefinedTypeSymbol;

            if (getter) {
                var getterType = getter.type;
                var getterSig = getterType.getCallSignatures()[0];

                if (accessorType == this.semanticInfoChain.undefinedTypeSymbol) {
                    accessorType = getterType;
                }

                if (getterSig.isResolved) {
                    var getterReturnType = getterSig.returnType;

                    if (!this.typesAreIdentical(accessorType, getterReturnType)) {
                        if (this.isAnyOrEquivalent(accessorType)) {
                            accessorSymbol.type = getterReturnType;
                            if (!accessorType.isError()) {
                                parameters[0].type = getterReturnType;
                            }
                        } else {
                            var diagnostic = context.postError(this.unitPath, funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode.get_and_set_accessor_must_have_the_same_type, null, this.getEnclosingDecl(funcDecl));
                            accessorSymbol.type = this.getNewErrorTypeSymbol(diagnostic);
                        }
                    }
                } else {
                    accessorSymbol.type = accessorType;
                }
            } else {
                accessorSymbol.type = accessorType;

                if (this.compilationSettings.noImplicitAny) {
                    if (accessorSymbol.type == this.semanticInfoChain.anyTypeSymbol) {
                        context.postError(this.unitPath, funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode._0_which_lacks_return_type_annotation_implicitly_has_an_any_return_type, [funcDeclAST.name.actualText], this.getEnclosingDecl(funcDecl));
                    }
                }
            }

            if (context.typeCheck()) {
                var prevSeenSuperConstructorCall = this.seenSuperConstructorCall;
                this.seenSuperConstructorCall = false;

                this.resolveAST(funcDeclAST.block, false, funcDecl, context);

                this.validateVariableDeclarationGroups(funcDecl, context);

                var enclosingDecl = this.getEnclosingDecl(funcDecl);

                var hasReturn = (funcDecl.flags & (2048 /* Signature */ | 4194304 /* HasReturnStatement */)) != 0;

                var isGetter = TypeScript.hasFlag(funcDeclAST.getFunctionFlags(), 32 /* GetAccessor */);
                var isSetter = !isGetter;

                var getter = accessorSymbol.getGetter();
                var setter = accessorSymbol.getSetter();

                var funcNameAST = funcDeclAST.name;

                if (getter && setter) {
                    var getterDecl = getter.getDeclarations()[0];
                    var setterDecl = setter.getDeclarations()[0];

                    var getterIsPrivate = getterDecl.flags & 2 /* Private */;
                    var setterIsPrivate = setterDecl.flags & 2 /* Private */;

                    if (getterIsPrivate != setterIsPrivate) {
                        context.postError(this.unitPath, funcNameAST.minChar, funcNameAST.getLength(), TypeScript.DiagnosticCode.Getter_and_setter_accessors_do_not_agree_in_visibility, null, enclosingDecl);
                    }
                }

                this.checkFunctionTypePrivacy(funcDeclAST, false, context);
            }

            return accessorSymbol;
        };

        PullTypeResolver.prototype.resolveList = function (list, enclosingDecl, context) {
            if (context.typeCheck()) {
                for (var i = 0; i < list.members.length; i++) {
                    this.resolveAST(list.members[i], false, enclosingDecl, context);
                }
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.resolveVoidExpression = function (ast, enclosingDecl, context) {
            if (context.typeCheck()) {
                this.resolveAST((ast).operand, false, enclosingDecl, context);
            }

            this.setSymbolForAST(ast, this.semanticInfoChain.voidTypeSymbol, context);
            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.resolveLogicalOperation = function (ast, enclosingDecl, context) {
            if (context.typeCheck()) {
                var binex = ast;

                var leftType = this.resolveAST(binex.operand1, false, enclosingDecl, context).type;
                var rightType = this.resolveAST(binex.operand2, false, enclosingDecl, context).type;

                var comparisonInfo = new TypeComparisonInfo();
                if (!this.sourceIsAssignableToTarget(leftType, rightType, context, comparisonInfo) && !this.sourceIsAssignableToTarget(rightType, leftType, context, comparisonInfo)) {
                    context.postError(this.unitPath, binex.minChar, binex.getLength(), TypeScript.DiagnosticCode.Operator_0_cannot_be_applied_to_types_1_and_2, [TypeScript.BinaryExpression.getTextForBinaryToken(binex.nodeType()), leftType.toString(), rightType.toString()], enclosingDecl);
                }
            }

            this.setSymbolForAST(ast, this.semanticInfoChain.booleanTypeSymbol, context);
            return this.semanticInfoChain.booleanTypeSymbol;
        };

        PullTypeResolver.prototype.resolveUnaryLogicalOperation = function (ast, enclosingDecl, context) {
            if (context.typeCheck()) {
                this.resolveAST((ast).operand, false, enclosingDecl, context);
            }

            this.setSymbolForAST(ast, this.semanticInfoChain.booleanTypeSymbol, context);
            return this.semanticInfoChain.booleanTypeSymbol;
        };

        PullTypeResolver.prototype.resolveUnaryArithmeticOperation = function (ast, enclosingDecl, context) {
            var nodeType = ast.nodeType();
            if (context.typeCheck()) {
                var unaryExpression = ast;
                var expression = this.resolveAST(unaryExpression.operand, false, enclosingDecl, context);

                if (nodeType == 27 /* PlusExpression */ || nodeType == 28 /* NegateExpression */ || nodeType == 73 /* BitwiseNotExpression */) {
                    return this.semanticInfoChain.numberTypeSymbol;
                }
                var operandType = expression.type;

                var operandIsFit = this.isAnyOrEquivalent(operandType) || operandType === this.semanticInfoChain.numberTypeSymbol || TypeScript.PullHelpers.symbolIsEnum(operandType);

                if (!operandIsFit) {
                    context.postError(this.unitPath, unaryExpression.operand.minChar, unaryExpression.operand.getLength(), TypeScript.DiagnosticCode.The_type_of_a_unary_arithmetic_operation_operand_must_be_of_type_any_number_or_an_enum_type, null, enclosingDecl);
                }

                switch (unaryExpression.nodeType()) {
                    case 77 /* PostIncrementExpression */:
                    case 75 /* PreIncrementExpression */:
                    case 78 /* PostDecrementExpression */:
                    case 76 /* PreDecrementExpression */:
                        if (!this.isValidLHS(unaryExpression.operand, expression)) {
                            context.postError(this.unitPath, unaryExpression.operand.minChar, unaryExpression.operand.getLength(), TypeScript.DiagnosticCode.The_operand_of_an_increment_or_decrement_operator_must_be_a_variable_property_or_indexer, null, enclosingDecl);
                        }

                        break;
                }
            }

            this.setSymbolForAST(ast, this.semanticInfoChain.numberTypeSymbol, context);
            return this.semanticInfoChain.numberTypeSymbol;
        };

        PullTypeResolver.prototype.resolveBinaryArithmeticExpression = function (ast, enclosingDecl, context) {
            if (context.typeCheck()) {
                var binaryExpression = ast;

                var lhsSymbol = this.resolveAST(binaryExpression.operand1, false, enclosingDecl, context);

                var lhsType = lhsSymbol.type;
                var rhsType = this.resolveAST(binaryExpression.operand2, false, enclosingDecl, context).type;

                var lhsIsFit = this.isAnyOrEquivalent(lhsType) || lhsType === this.semanticInfoChain.numberTypeSymbol || TypeScript.PullHelpers.symbolIsEnum(lhsType);
                var rhsIsFit = this.isAnyOrEquivalent(rhsType) || rhsType === this.semanticInfoChain.numberTypeSymbol || TypeScript.PullHelpers.symbolIsEnum(rhsType);

                if (!rhsIsFit) {
                    context.postError(this.unitPath, binaryExpression.operand1.minChar, binaryExpression.operand1.getLength(), TypeScript.DiagnosticCode.The_right_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type, null, enclosingDecl);
                }

                if (!lhsIsFit) {
                    context.postError(this.unitPath, binaryExpression.operand2.minChar, binaryExpression.operand2.getLength(), TypeScript.DiagnosticCode.The_left_hand_side_of_an_arithmetic_operation_must_be_of_type_any_number_or_an_enum_type, null, enclosingDecl);
                }

                if (rhsIsFit && lhsIsFit) {
                    switch (binaryExpression.nodeType()) {
                        case 48 /* LeftShiftAssignmentExpression */:
                        case 49 /* SignedRightShiftAssignmentExpression */:
                        case 50 /* UnsignedRightShiftAssignmentExpression */:
                        case 41 /* SubtractAssignmentExpression */:
                        case 43 /* MultiplyAssignmentExpression */:
                        case 42 /* DivideAssignmentExpression */:
                        case 44 /* ModuloAssignmentExpression */:
                        case 47 /* OrAssignmentExpression */:
                        case 45 /* AndAssignmentExpression */:
                        case 46 /* ExclusiveOrAssignmentExpression */:
                            if (!this.isValidLHS(binaryExpression.operand1, lhsSymbol)) {
                                context.postError(this.unitPath, binaryExpression.operand1.minChar, binaryExpression.operand1.getLength(), TypeScript.DiagnosticCode.Invalid_left_hand_side_of_assignment_expression, null, enclosingDecl);
                            }

                            this.checkAssignability(binaryExpression.operand1, rhsType, lhsType, enclosingDecl, context);
                            break;
                    }
                }
            }

            this.setSymbolForAST(ast, this.semanticInfoChain.numberTypeSymbol, context);
            return this.semanticInfoChain.numberTypeSymbol;
        };

        PullTypeResolver.prototype.resolveTypeOfExpression = function (ast, enclosingDecl, context) {
            if (context.typeCheck()) {
                this.resolveAST((ast).operand, false, enclosingDecl, context);
            }

            this.setSymbolForAST(ast, this.semanticInfoChain.stringTypeSymbol, context);
            return this.semanticInfoChain.stringTypeSymbol;
        };

        PullTypeResolver.prototype.resolveThrowStatement = function (ast, enclosingDecl, context) {
            if (context.typeCheck()) {
                this.resolveAST((ast).expression, false, enclosingDecl, context);
            }

            this.setSymbolForAST(ast, this.semanticInfoChain.voidTypeSymbol, context);
            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.resolveDeleteStatement = function (ast, enclosingDecl, context) {
            if (context.typeCheck()) {
                this.resolveAST((ast).operand, false, enclosingDecl, context);
            }

            this.setSymbolForAST(ast, this.semanticInfoChain.booleanTypeSymbol, context);
            return this.semanticInfoChain.booleanTypeSymbol;
        };

        PullTypeResolver.prototype.resolveInstanceOfExpression = function (ast, enclosingDecl, context) {
            if (context.typeCheck()) {
                var binaryExpression = ast;

                var lhsType = this.widenType(this.resolveAST(binaryExpression.operand1, false, enclosingDecl, context).type);
                var rhsType = this.widenType(this.resolveAST(binaryExpression.operand2, false, enclosingDecl, context).type);

                var isValidLHS = lhsType && (this.isAnyOrEquivalent(lhsType) || !lhsType.isPrimitive());
                var isValidRHS = rhsType && (this.isAnyOrEquivalent(rhsType) || rhsType.isClass() || this.typeIsSubtypeOfFunction(rhsType, context));

                if (!isValidLHS) {
                    context.postError(this.unitPath, binaryExpression.operand1.minChar, binaryExpression.operand1.getLength(), TypeScript.DiagnosticCode.The_left_hand_side_of_an_instanceof_expression_must_be_of_type_any_an_object_type_or_a_type_parameter, null, enclosingDecl);
                }

                if (!isValidRHS) {
                    context.postError(this.unitPath, binaryExpression.operand1.minChar, binaryExpression.operand1.getLength(), TypeScript.DiagnosticCode.The_right_hand_side_of_an_instanceof_expression_must_be_of_type_any_or_a_subtype_of_the_Function_interface_type, null, enclosingDecl);
                }
            }

            this.setSymbolForAST(ast, this.semanticInfoChain.booleanTypeSymbol, context);
            return this.semanticInfoChain.booleanTypeSymbol;
        };

        PullTypeResolver.prototype.resolveCommaExpression = function (ast, enclosingDecl, context) {
            if (context.typeCheck()) {
                this.resolveAST((ast).operand1, false, enclosingDecl, context);
                return this.resolveAST((ast).operand2, false, enclosingDecl, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.resolveInExpression = function (ast, enclosingDecl, context) {
            if (context.typeCheck()) {
                var binaryExpression = ast;
                var lhsType = this.widenType(this.resolveAST(binaryExpression.operand1, false, enclosingDecl, context).type);
                var rhsType = this.widenType(this.resolveAST(binaryExpression.operand2, false, enclosingDecl, context).type);

                var isStringAnyOrNumber = lhsType.type === this.semanticInfoChain.stringTypeSymbol || this.isAnyOrEquivalent(lhsType.type) || this.isNumberOrEquivalent(lhsType.type);
                var isValidRHS = rhsType && (this.isAnyOrEquivalent(rhsType) || !rhsType.isPrimitive());

                if (!isStringAnyOrNumber) {
                    context.postError(this.unitPath, binaryExpression.operand1.minChar, binaryExpression.operand1.getLength(), TypeScript.DiagnosticCode.The_left_hand_side_of_an_in_expression_must_be_of_types_string_or_any, null, enclosingDecl);
                }

                if (!isValidRHS) {
                    context.postError(this.unitPath, binaryExpression.operand1.minChar, binaryExpression.operand1.getLength(), TypeScript.DiagnosticCode.The_right_hand_side_of_an_in_expression_must_be_of_type_any_an_object_type_or_a_type_parameter, null, enclosingDecl);
                }
            }

            this.setSymbolForAST(ast, this.semanticInfoChain.booleanTypeSymbol, context);
            return this.semanticInfoChain.booleanTypeSymbol;
        };

        PullTypeResolver.prototype.resolveForStatement = function (ast, enclosingDecl, context) {
            if (context.typeCheck()) {
                this.resolveAST((ast).init, false, enclosingDecl, context);
                this.resolveAST((ast).cond, false, enclosingDecl, context);
                this.resolveAST((ast).incr, false, enclosingDecl, context);
                this.resolveAST((ast).body, false, enclosingDecl, context);
            }

            this.setSymbolForAST(ast, this.semanticInfoChain.voidTypeSymbol, context);
            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.resolveForInStatement = function (ast, enclosingDecl, context) {
            if (context.typeCheck()) {
                var forInStatement = ast;

                var rhsType = this.widenType(this.resolveAST(forInStatement.obj, false, enclosingDecl, context).type);
                var lval = forInStatement.lval;

                if (lval.nodeType() === 19 /* VariableDeclaration */) {
                    var declaration = forInStatement.lval;
                    var varDecl = declaration.declarators.members[0];

                    if (varDecl.typeExpr) {
                        context.postError(this.unitPath, lval.minChar, lval.getLength(), TypeScript.DiagnosticCode.Variable_declarations_of_a_for_statement_cannot_use_a_type_annotation, null, enclosingDecl);
                    }
                }

                var varSym = this.resolveAST(forInStatement.lval, false, enclosingDecl, context);

                if (lval.nodeType() === 19 /* VariableDeclaration */) {
                    varSym = this.getSymbolForAST((forInStatement.lval).declarators.members[0]);
                }

                var isStringOrNumber = varSym.type === this.semanticInfoChain.stringTypeSymbol || this.isAnyOrEquivalent(varSym.type);

                var isValidRHS = rhsType && (this.isAnyOrEquivalent(rhsType) || !rhsType.isPrimitive());

                if (!isStringOrNumber) {
                    context.postError(this.unitPath, lval.minChar, lval.getLength(), TypeScript.DiagnosticCode.Variable_declarations_of_a_for_statement_must_be_of_types_string_or_any, null, enclosingDecl);
                }

                if (!isValidRHS) {
                    context.postError(this.unitPath, forInStatement.obj.minChar, forInStatement.obj.getLength(), TypeScript.DiagnosticCode.The_right_hand_side_of_a_for_in_statement_must_be_of_type_any_an_object_type_or_a_type_parameter, null, enclosingDecl);
                }

                this.resolveAST(forInStatement.body, false, enclosingDecl, context);
            }

            this.setSymbolForAST(ast, this.semanticInfoChain.voidTypeSymbol, context);
            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.resolveWhileStatement = function (ast, enclosingDecl, context) {
            if (context.typeCheck()) {
                this.resolveAST((ast).cond, false, enclosingDecl, context);
                this.resolveAST((ast).body, false, enclosingDecl, context);
            }

            this.setSymbolForAST(ast, this.semanticInfoChain.voidTypeSymbol, context);
            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.resolveDoStatement = function (ast, enclosingDecl, context) {
            if (context.typeCheck()) {
                this.resolveAST((ast).cond, false, enclosingDecl, context);
                this.resolveAST((ast).body, false, enclosingDecl, context);
            }

            this.setSymbolForAST(ast, this.semanticInfoChain.voidTypeSymbol, context);
            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.resolveIfStatement = function (ast, enclosingDecl, context) {
            if (context.typeCheck()) {
                this.resolveAST((ast).cond, false, enclosingDecl, context);
                this.resolveAST((ast).thenBod, false, enclosingDecl, context);
                this.resolveAST((ast).elseBod, false, enclosingDecl, context);
            }

            this.setSymbolForAST(ast, this.semanticInfoChain.voidTypeSymbol, context);
            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.resolveBlock = function (ast, enclosingDecl, context) {
            if (context.typeCheck()) {
                this.resolveAST((ast).statements, false, enclosingDecl, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.resolveVariableStatement = function (ast, enclosingDecl, context) {
            if (context.typeCheck()) {
                this.resolveAST((ast).declaration, false, enclosingDecl, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.resolveVariableDeclarationList = function (ast, enclosingDecl, context) {
            if (context.typeCheck()) {
                this.resolveAST((ast).declarators, false, enclosingDecl, context);
            }

            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.resolveWithStatement = function (ast, enclosingDecl, context) {
            if (context.typeCheck()) {
                var withStatement = ast;
                context.postError(this.unitPath, withStatement.expr.minChar, withStatement.expr.getLength(), TypeScript.DiagnosticCode.All_symbols_within_a_with_block_will_be_resolved_to_any, null, enclosingDecl);
            }

            this.setSymbolForAST(ast, this.semanticInfoChain.voidTypeSymbol, context);
            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.resolveTryStatement = function (ast, enclosingDecl, context) {
            if (context.typeCheck()) {
                var tryStatement = ast;

                this.resolveAST(tryStatement.tryBody, false, enclosingDecl, context);
                this.resolveAST(tryStatement.catchClause, false, enclosingDecl, context);
                this.resolveAST(tryStatement.finallyBody, false, enclosingDecl, context);
            }

            this.setSymbolForAST(ast, this.semanticInfoChain.voidTypeSymbol, context);
            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.resolveCatchClause = function (ast, enclosingDecl, context) {
            if (context.typeCheck()) {
                this.resolveAST((ast).body, false, this.getDeclForAST(ast), context);
            }

            this.setSymbolForAST(ast, this.semanticInfoChain.voidTypeSymbol, context);
            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.resolveReturnStatement = function (ast, inContextuallyTypedAssignment, enclosingDecl, context) {
            var parentDecl = enclosingDecl;
            var returnAST = ast;
            var returnExpr = returnAST.returnExpression;

            while (parentDecl) {
                if (parentDecl.kind & TypeScript.PullElementKind.SomeFunction) {
                    parentDecl.setFlag(4194304 /* HasReturnStatement */);
                    break;
                }

                parentDecl = parentDecl.getParentDecl();
            }

            var inContextuallyTypedAssignment = false;
            var enclosingDeclAST;

            if (enclosingDecl.kind & TypeScript.PullElementKind.SomeFunction) {
                enclosingDeclAST = this.getASTForDecl(enclosingDecl);
                if (enclosingDeclAST.returnTypeAnnotation) {
                    var returnTypeAnnotationSymbol = this.resolveTypeReference(enclosingDeclAST.returnTypeAnnotation, enclosingDecl, context);
                    if (returnTypeAnnotationSymbol) {
                        inContextuallyTypedAssignment = true;
                        context.pushContextualType(returnTypeAnnotationSymbol, context.inProvisionalResolution(), null);
                    }
                } else {
                    var currentContextualType = context.getContextualType();
                    if (currentContextualType && currentContextualType.isFunction()) {
                        var currentContextualTypeSignatureSymbol = currentContextualType.getDeclarations()[0].getSignatureSymbol();
                        var currentContextualTypeReturnTypeSymbol = currentContextualTypeSignatureSymbol.returnType;
                        if (currentContextualTypeReturnTypeSymbol) {
                            inContextuallyTypedAssignment = true;
                            context.pushContextualType(currentContextualTypeReturnTypeSymbol, context.inProvisionalResolution(), null);
                        }
                    }
                }
            }

            var returnType = returnExpr ? this.resolveAST(returnExpr, inContextuallyTypedAssignment, enclosingDecl, context).type : this.semanticInfoChain.voidTypeSymbol;

            if (inContextuallyTypedAssignment) {
                context.popContextualType();
            }

            if (context.typeCheck() && returnExpr) {
                if (enclosingDecl.kind === 524288 /* SetAccessor */ && returnExpr) {
                    context.postError(this.unitPath, returnExpr.minChar, returnExpr.getLength(), TypeScript.DiagnosticCode.Setters_cannot_return_a_value, null, enclosingDecl);
                }

                if (enclosingDecl.kind & TypeScript.PullElementKind.SomeFunction) {
                    enclosingDeclAST = this.getASTForDecl(enclosingDecl);

                    if (enclosingDeclAST.returnTypeAnnotation) {
                        var signatureSymbol = enclosingDecl.getSignatureSymbol();
                        var sigReturnType = signatureSymbol.returnType;

                        if (returnType && sigReturnType) {
                            var comparisonInfo = new TypeComparisonInfo();
                            var upperBound = null;

                            if (returnType.isTypeParameter()) {
                                upperBound = (returnType).getConstraint();

                                if (upperBound) {
                                    returnType = upperBound;
                                }
                            }

                            if (sigReturnType.isTypeParameter()) {
                                upperBound = (sigReturnType).getConstraint();

                                if (upperBound) {
                                    sigReturnType = upperBound;
                                }
                            }

                            if (!returnType.isResolved) {
                                this.resolveDeclaredSymbol(returnType, enclosingDecl, context);
                            }

                            if (!sigReturnType.isResolved) {
                                this.resolveDeclaredSymbol(sigReturnType, enclosingDecl, context);
                            }

                            var isAssignable = this.sourceIsAssignableToTarget(returnType, sigReturnType, context, comparisonInfo);

                            if (!isAssignable) {
                                if (comparisonInfo.message) {
                                    context.postError(this.unitPath, returnExpr.minChar, returnExpr.getLength(), TypeScript.DiagnosticCode.Cannot_convert_0_to_1_NL_2, [returnType.toString(), sigReturnType.toString(), comparisonInfo.message], enclosingDecl);
                                } else {
                                    context.postError(this.unitPath, returnExpr.minChar, returnExpr.getLength(), TypeScript.DiagnosticCode.Cannot_convert_0_to_1, [returnType.toString(), sigReturnType.toString()], enclosingDecl);
                                }
                            }
                        }
                    }
                }
            }

            this.setSymbolForAST(ast, returnType, context);

            return returnType;
        };

        PullTypeResolver.prototype.resolveSwitchStatement = function (ast, enclosingDecl, context) {
            if (context.typeCheck()) {
                var switchStatement = ast;

                var expressionType = this.resolveAST(switchStatement.val, false, enclosingDecl, context).type;

                this.resolveAST(switchStatement.caseList, false, enclosingDecl, context);
                this.resolveAST(switchStatement.defaultCase, false, enclosingDecl, context);

                if (switchStatement.caseList && switchStatement.caseList.members) {
                    for (var i = 0, n = switchStatement.caseList.members.length; i < n; i++) {
                        var caseClause = switchStatement.caseList.members[i];
                        if (caseClause !== switchStatement.defaultCase) {
                            var caseClauseExpressionType = this.resolveAST(caseClause.expr, false, enclosingDecl, context).type;

                            var comparisonInfo = new TypeComparisonInfo();
                            if (!this.sourceIsAssignableToTarget(expressionType, caseClauseExpressionType, context, comparisonInfo) && !this.sourceIsAssignableToTarget(caseClauseExpressionType, expressionType, context, comparisonInfo)) {
                                if (comparisonInfo.message) {
                                    context.postError(this.unitPath, caseClause.expr.minChar, caseClause.expr.getLength(), TypeScript.DiagnosticCode.Cannot_convert_0_to_1_NL_2, [caseClauseExpressionType.toString(), expressionType.toString(), comparisonInfo.message], enclosingDecl);
                                } else {
                                    context.postError(this.unitPath, caseClause.expr.minChar, caseClause.expr.getLength(), TypeScript.DiagnosticCode.Cannot_convert_0_to_1, [caseClauseExpressionType.toString(), expressionType.toString()], enclosingDecl);
                                }
                            }
                        }
                    }
                }
            }

            this.setSymbolForAST(ast, this.semanticInfoChain.voidTypeSymbol, context);
            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.resolveCaseClause = function (ast, enclosingDecl, context) {
            if (context.typeCheck()) {
                this.resolveAST((ast).expr, false, enclosingDecl, context);
                this.resolveAST((ast).body, false, enclosingDecl, context);
            }

            this.setSymbolForAST(ast, this.semanticInfoChain.voidTypeSymbol, context);
            return this.semanticInfoChain.voidTypeSymbol;
        };

        PullTypeResolver.prototype.resolveLabeledStatement = function (ast, enclosingDecl, context) {
            return this.resolveAST((ast).statement, false, enclosingDecl, context);
        };

        PullTypeResolver.prototype.resolveAST = function (ast, inContextuallyTypedAssignment, enclosingDecl, context, specializingSignature) {
            if (typeof specializingSignature === "undefined") { specializingSignature = false; }
            TypeScript.globalSemanticInfoChain = this.semanticInfoChain;

            if (TypeScript.globalBinder) {
                TypeScript.globalBinder.semanticInfoChain = this.semanticInfoChain;
            }

            if (!ast) {
                return;
            }

            var symbol = specializingSignature ? null : this.semanticInfoChain.getSymbolForAST(ast, this.unitPath);

            if (symbol && symbol.type && (symbol.isResolved)) {
                return symbol;
            }

            var nodeType = ast.nodeType();

            switch (nodeType) {
                case 1 /* List */:
                    return this.resolveList(ast, enclosingDecl, context);

                case 2 /* Script */:
                    return null;

                case 16 /* ModuleDeclaration */:
                    return this.resolveModuleDeclaration(ast, context);

                case 15 /* InterfaceDeclaration */:
                    return this.resolveInterfaceDeclaration(ast, context);

                case 14 /* ClassDeclaration */:
                    return this.resolveClassDeclaration(ast, context);

                case 19 /* VariableDeclaration */:
                    return this.resolveVariableDeclarationList(ast, enclosingDecl, context);

                case 18 /* VariableDeclarator */:
                case 20 /* Parameter */:
                    return this.resolveVariableDeclaration(ast, context, enclosingDecl);

                case 9 /* TypeParameter */:
                    return this.resolveTypeParameterDeclaration(ast, context);

                case 17 /* ImportDeclaration */:
                    return this.resolveImportDeclaration(ast, context);

                case 23 /* ObjectLiteralExpression */:
                    return this.resolveObjectLiteralExpression(ast, inContextuallyTypedAssignment, enclosingDecl, context);

                case 10 /* GenericType */:
                    return this.resolveGenericTypeReference(ast, enclosingDecl, context);

                case 21 /* Name */:
                    if (context.resolvingTypeReference) {
                        return this.resolveTypeNameExpression(ast, enclosingDecl, context);
                    } else {
                        return this.resolveNameExpression(ast, enclosingDecl, context);
                    }

                case 33 /* MemberAccessExpression */:
                    if (context.resolvingTypeReference) {
                        return this.resolveDottedTypeNameExpression(ast, enclosingDecl, context);
                    } else {
                        return this.resolveDottedNameExpression(ast, enclosingDecl, context);
                    }

                case 10 /* GenericType */:
                    return this.resolveGenericTypeReference(ast, enclosingDecl, context);

                case 13 /* FunctionDeclaration */: {
                    var funcDecl = ast;

                    if (funcDecl.isGetAccessor()) {
                        return this.resolveGetAccessorDeclaration(funcDecl, context);
                    } else if (funcDecl.isSetAccessor()) {
                        return this.resolveSetAccessorDeclaration(funcDecl, context);
                    } else if (inContextuallyTypedAssignment || (funcDecl.getFunctionFlags() & 8192 /* IsFunctionExpression */) || (funcDecl.getFunctionFlags() & 2048 /* IsFatArrowFunction */) || (funcDecl.getFunctionFlags() & 16384 /* IsFunctionProperty */)) {
                        return this.resolveFunctionExpression(funcDecl, inContextuallyTypedAssignment, enclosingDecl, context);
                    } else {
                        return this.resolveFunctionDeclaration(funcDecl, context);
                    }
                }

                case 18 /* VariableDeclarator */:
                case 20 /* Parameter */:
                    return this.resolveVariableDeclaration(ast, context, enclosingDecl);

                case 9 /* TypeParameter */:
                    return this.resolveTypeParameterDeclaration(ast, context);

                case 17 /* ImportDeclaration */:
                    return this.resolveImportDeclaration(ast, context);

                case 23 /* ObjectLiteralExpression */:
                    return this.resolveObjectLiteralExpression(ast, inContextuallyTypedAssignment, enclosingDecl, context);

                case 10 /* GenericType */:
                    return this.resolveGenericTypeReference(ast, enclosingDecl, context);

                case 21 /* Name */:
                    if (context.resolvingTypeReference) {
                        return this.resolveTypeNameExpression(ast, enclosingDecl, context);
                    } else {
                        return this.resolveNameExpression(ast, enclosingDecl, context);
                    }

                case 33 /* MemberAccessExpression */:
                    if (context.resolvingTypeReference) {
                        return this.resolveDottedTypeNameExpression(ast, enclosingDecl, context);
                    } else {
                        return this.resolveDottedNameExpression(ast, enclosingDecl, context);
                    }

                case 10 /* GenericType */:
                    return this.resolveGenericTypeReference(ast, enclosingDecl, context);

                case 13 /* FunctionDeclaration */: {
                    var funcDecl = ast;

                    if (funcDecl.isGetAccessor()) {
                        return this.resolveGetAccessorDeclaration(funcDecl, context);
                    } else if (funcDecl.isSetAccessor()) {
                        return this.resolveSetAccessorDeclaration(funcDecl, context);
                    } else if (inContextuallyTypedAssignment || (funcDecl.getFunctionFlags() & 8192 /* IsFunctionExpression */) || (funcDecl.getFunctionFlags() & 2048 /* IsFatArrowFunction */) || (funcDecl.getFunctionFlags() & 16384 /* IsFunctionProperty */)) {
                        return this.resolveFunctionExpression(funcDecl, inContextuallyTypedAssignment, enclosingDecl, context);
                    } else {
                        return this.resolveFunctionDeclaration(funcDecl, context);
                    }
                }

                case 22 /* ArrayLiteralExpression */:
                    return this.resolveArrayLiteralExpression(ast, inContextuallyTypedAssignment, enclosingDecl, context);

                case 30 /* ThisExpression */:
                    return this.resolveThisExpression(ast, enclosingDecl, context);

                case 31 /* SuperExpression */:
                    return this.resolveSuperExpression(ast, enclosingDecl, context);

                case 37 /* InvocationExpression */:
                    return this.resolveInvocationExpression(ast, inContextuallyTypedAssignment, enclosingDecl, context);

                case 38 /* ObjectCreationExpression */:
                    return this.resolveObjectCreationExpression(ast, inContextuallyTypedAssignment, enclosingDecl, context);

                case 79 /* CastExpression */:
                    return this.resolveTypeAssertionExpression(ast, inContextuallyTypedAssignment, enclosingDecl, context);

                case 11 /* TypeRef */:
                    return this.resolveTypeReference(ast, enclosingDecl, context);

                case 88 /* ExportAssignment */:
                    return this.resolveExportAssignmentStatement(ast, enclosingDecl, context);

                case 7 /* NumericLiteral */:
                    return this.semanticInfoChain.numberTypeSymbol;
                case 5 /* StringLiteral */:
                    return this.semanticInfoChain.stringTypeSymbol;
                case 8 /* NullLiteral */:
                    return this.semanticInfoChain.nullTypeSymbol;
                case 3 /* TrueLiteral */:
                case 4 /* FalseLiteral */:
                    return this.semanticInfoChain.booleanTypeSymbol;
                case 25 /* VoidExpression */:
                    return this.resolveVoidExpression(ast, enclosingDecl, context);

                case 39 /* AssignmentExpression */:
                    return this.resolveAssignmentStatement(ast, inContextuallyTypedAssignment, enclosingDecl, context);

                case 74 /* LogicalNotExpression */:
                    return this.resolveUnaryLogicalOperation(ast, enclosingDecl, context);

                case 58 /* NotEqualsWithTypeConversionExpression */:
                case 57 /* EqualsWithTypeConversionExpression */:
                case 59 /* EqualsExpression */:
                case 60 /* NotEqualsExpression */:
                case 61 /* LessThanExpression */:
                case 62 /* LessThanOrEqualExpression */:
                case 64 /* GreaterThanOrEqualExpression */:
                case 63 /* GreaterThanExpression */:
                    return this.resolveLogicalOperation(ast, enclosingDecl, context);

                case 65 /* AddExpression */:
                case 40 /* AddAssignmentExpression */:
                    return this.resolveBinaryAdditionOperation(ast, inContextuallyTypedAssignment, enclosingDecl, context);

                case 27 /* PlusExpression */:
                case 28 /* NegateExpression */:
                case 73 /* BitwiseNotExpression */:
                case 77 /* PostIncrementExpression */:
                case 75 /* PreIncrementExpression */:
                case 78 /* PostDecrementExpression */:
                case 76 /* PreDecrementExpression */:
                    return this.resolveUnaryArithmeticOperation(ast, enclosingDecl, context);

                case 66 /* SubtractExpression */:
                case 67 /* MultiplyExpression */:
                case 68 /* DivideExpression */:
                case 69 /* ModuloExpression */:
                case 54 /* BitwiseOrExpression */:
                case 56 /* BitwiseAndExpression */:
                case 70 /* LeftShiftExpression */:
                case 71 /* SignedRightShiftExpression */:
                case 72 /* UnsignedRightShiftExpression */:
                case 55 /* BitwiseExclusiveOrExpression */:
                case 46 /* ExclusiveOrAssignmentExpression */:
                case 48 /* LeftShiftAssignmentExpression */:
                case 49 /* SignedRightShiftAssignmentExpression */:
                case 50 /* UnsignedRightShiftAssignmentExpression */:
                case 41 /* SubtractAssignmentExpression */:
                case 43 /* MultiplyAssignmentExpression */:
                case 42 /* DivideAssignmentExpression */:
                case 44 /* ModuloAssignmentExpression */:
                case 47 /* OrAssignmentExpression */:
                case 45 /* AndAssignmentExpression */:
                    return this.resolveBinaryArithmeticExpression(ast, enclosingDecl, context);

                case 36 /* ElementAccessExpression */:
                    return this.resolveIndexExpression(ast, inContextuallyTypedAssignment, enclosingDecl, context);

                case 52 /* LogicalOrExpression */:
                    return this.resolveLogicalOrExpression(ast, inContextuallyTypedAssignment, enclosingDecl, context);

                case 53 /* LogicalAndExpression */:
                    return this.resolveLogicalAndExpression(ast, inContextuallyTypedAssignment, enclosingDecl, context);

                case 35 /* TypeOfExpression */:
                    return this.resolveTypeOfExpression(ast, enclosingDecl, context);

                case 96 /* ThrowStatement */:
                    return this.resolveThrowStatement(ast, enclosingDecl, context);

                case 29 /* DeleteExpression */:
                    return this.resolveDeleteStatement(ast, enclosingDecl, context);

                case 51 /* ConditionalExpression */:
                    return this.resolveConditionalExpression(ast, enclosingDecl, context);

                case 6 /* RegularExpressionLiteral */:
                    return this.resolveRegularExpressionLiteral();

                case 80 /* ParenthesizedExpression */:
                    return this.resolveParenthesizedExpression(ast, enclosingDecl, context);

                case 89 /* ExpressionStatement */:
                    return this.resolveExpressionStatement(ast, inContextuallyTypedAssignment, enclosingDecl, context);

                case 34 /* InstanceOfExpression */:
                    return this.resolveInstanceOfExpression(ast, enclosingDecl, context);

                case 26 /* CommaExpression */:
                    return this.resolveCommaExpression(ast, enclosingDecl, context);

                case 32 /* InExpression */:
                    return this.resolveInExpression(ast, enclosingDecl, context);

                case 91 /* ForStatement */:
                    return this.resolveForStatement(ast, enclosingDecl, context);

                case 90 /* ForInStatement */:
                    return this.resolveForInStatement(ast, enclosingDecl, context);

                case 99 /* WhileStatement */:
                    return this.resolveWhileStatement(ast, enclosingDecl, context);

                case 86 /* DoStatement */:
                    return this.resolveDoStatement(ast, enclosingDecl, context);

                case 92 /* IfStatement */:
                    return this.resolveIfStatement(ast, enclosingDecl, context);

                case 82 /* Block */:
                    return this.resolveBlock(ast, enclosingDecl, context);

                case 98 /* VariableStatement */:
                    return this.resolveVariableStatement(ast, enclosingDecl, context);

                case 100 /* WithStatement */:
                    return this.resolveWithStatement(ast, enclosingDecl, context);

                case 97 /* TryStatement */:
                    return this.resolveTryStatement(ast, enclosingDecl, context);

                case 102 /* CatchClause */:
                    return this.resolveCatchClause(ast, enclosingDecl, context);

                case 94 /* ReturnStatement */:
                    return this.resolveReturnStatement(ast, inContextuallyTypedAssignment, enclosingDecl, context);

                case 95 /* SwitchStatement */:
                    return this.resolveSwitchStatement(ast, enclosingDecl, context);

                case 101 /* CaseClause */:
                    return this.resolveCaseClause(ast, enclosingDecl, context);

                case 93 /* LabeledStatement */:
                    return this.resolveLabeledStatement(ast, enclosingDecl, context);
            }

            return this.semanticInfoChain.anyTypeSymbol;
        };

        PullTypeResolver.prototype.resolveRegularExpressionLiteral = function () {
            if (this.cachedRegExpInterfaceType()) {
                return this.cachedRegExpInterfaceType();
            } else {
                return this.semanticInfoChain.anyTypeSymbol;
            }
        };

        PullTypeResolver.prototype.isNameOrMemberAccessExpression = function (ast) {
            var checkAST = ast;

            while (checkAST) {
                if (checkAST.nodeType() === 89 /* ExpressionStatement */) {
                    checkAST = (checkAST).expression;
                } else if (checkAST.nodeType() === 80 /* ParenthesizedExpression */) {
                    checkAST = (checkAST).expression;
                } else if (checkAST.nodeType() === 21 /* Name */) {
                    return true;
                } else if (checkAST.nodeType() === 33 /* MemberAccessExpression */) {
                    return true;
                } else {
                    return false;
                }
            }
        };

        PullTypeResolver.prototype.resolveNameSymbol = function (nameSymbol, context) {
            if (nameSymbol && !context.canUseTypeSymbol && nameSymbol != this.semanticInfoChain.undefinedTypeSymbol && nameSymbol != this.semanticInfoChain.nullTypeSymbol && (nameSymbol.isPrimitive() || !(nameSymbol.kind & TypeScript.PullElementKind.SomeValue))) {
                var valueSymbol = nameSymbol.isAlias() ? (nameSymbol).getExportAssignedValueSymbol() : null;
                if (valueSymbol) {
                    nameSymbol = valueSymbol;
                } else {
                    nameSymbol = null;
                }
            }

            return nameSymbol;
        };

        PullTypeResolver.prototype.resolveNameExpression = function (nameAST, enclosingDecl, context) {
            var nameSymbol = this.getSymbolForAST(nameAST);
            var foundCached = nameSymbol != null;

            if (!foundCached) {
                nameSymbol = this.computeNameExpression(nameAST, enclosingDecl, context);
            }

            if (!nameSymbol.isResolved) {
                this.resolveDeclaredSymbol(nameSymbol, enclosingDecl, context);
            }

            if (nameSymbol && (nameSymbol.type != this.semanticInfoChain.anyTypeSymbol || nameSymbol.hasFlag(16777216 /* IsAnnotatedWithAny */))) {
                this.setSymbolForAST(nameAST, nameSymbol, context);
            }

            return nameSymbol;
        };

        PullTypeResolver.prototype.computeNameExpression = function (nameAST, enclosingDecl, context) {
            if (nameAST.isMissing()) {
                return this.semanticInfoChain.anyTypeSymbol;
            }

            var id = nameAST.text();

            var declPath = enclosingDecl !== null ? TypeScript.getPathToDecl(enclosingDecl) : [];

            if (enclosingDecl && !declPath.length) {
                declPath = [enclosingDecl];
            }

            var aliasSymbol = null;
            var nameSymbol = this.getSymbolFromDeclPath(id, declPath, TypeScript.PullElementKind.SomeValue);

            if (!nameSymbol && id === "arguments" && enclosingDecl && (enclosingDecl.kind & TypeScript.PullElementKind.SomeFunction)) {
                nameSymbol = this.cachedFunctionArgumentsSymbol;

                if (this.cachedIArgumentsInterfaceType() && !this.cachedIArgumentsInterfaceType().isResolved) {
                    this.resolveDeclaredSymbol(this.cachedIArgumentsInterfaceType(), enclosingDecl, context);
                }
            }

            if (!nameSymbol) {
                nameSymbol = this.getSymbolFromDeclPath(id, declPath, 256 /* TypeAlias */);

                if (nameSymbol && !nameSymbol.isAlias()) {
                    nameSymbol = null;
                }
            }

            if (!nameSymbol) {
                if (context.resolvingTypeNameAsNameExpression) {
                    return null;
                } else {
                    context.postError(this.unitPath, nameAST.minChar, nameAST.getLength(), TypeScript.DiagnosticCode.Could_not_find_symbol_0, [nameAST.actualText], enclosingDecl);
                    return this.getNewErrorTypeSymbol(null, id);
                }
            }

            if (nameSymbol.isType() && nameSymbol.isAlias()) {
                aliasSymbol = nameSymbol;
                aliasSymbol.isUsedAsValue = true;

                if (!nameSymbol.isResolved) {
                    this.resolveDeclaredSymbol(nameSymbol, enclosingDecl, context);
                }

                if (aliasSymbol.assignedValue) {
                    if (!aliasSymbol.assignedValue.isResolved) {
                        this.resolveDeclaredSymbol(aliasSymbol.assignedValue, enclosingDecl, context);
                    }
                } else if (aliasSymbol.assignedContainer && !aliasSymbol.assignedContainer.isResolved) {
                    this.resolveDeclaredSymbol(aliasSymbol.assignedContainer, enclosingDecl, context);
                }

                var exportAssignmentSymbol = (nameSymbol).getExportAssignedValueSymbol();

                if (exportAssignmentSymbol) {
                    nameSymbol = exportAssignmentSymbol;
                } else {
                    aliasSymbol = null;
                }
            }

            if (aliasSymbol) {
                this.currentUnit.setAliasSymbolForAST(nameAST, aliasSymbol);
            }

            return nameSymbol;
        };

        PullTypeResolver.prototype.resolveDottedNameExpression = function (dottedNameAST, enclosingDecl, context) {
            var symbol = this.getSymbolForAST(dottedNameAST);
            var foundCached = symbol != null;

            if (!foundCached) {
                symbol = this.computeDottedNameExpressionSymbol(dottedNameAST, enclosingDecl, context);
            }

            if (symbol && !symbol.isResolved) {
                this.resolveDeclaredSymbol(symbol, enclosingDecl, context);
            }

            if (symbol && (symbol.type != this.semanticInfoChain.anyTypeSymbol || symbol.hasFlag(16777216 /* IsAnnotatedWithAny */))) {
                this.setSymbolForAST(dottedNameAST, symbol, context);
                this.setSymbolForAST(dottedNameAST.operand2, symbol, context);
            }

            return symbol;
        };

        PullTypeResolver.prototype.isPrototypeMember = function (dottedNameAST, enclosingDecl, context) {
            var rhsName = (dottedNameAST.operand2).text();
            if (rhsName === "prototype") {
                var prevCanUseTypeSymbol = context.canUseTypeSymbol;
                context.canUseTypeSymbol = true;
                var lhsType = this.resolveAST(dottedNameAST.operand1, false, enclosingDecl, context).type;
                context.canUseTypeSymbol = prevCanUseTypeSymbol;

                if (lhsType) {
                    if (lhsType.isClass() || lhsType.isConstructor()) {
                        return true;
                    } else {
                        var classInstanceType = lhsType.getAssociatedContainerType();

                        if (classInstanceType && classInstanceType.isClass()) {
                            return true;
                        }
                    }
                }
            }

            return false;
        };

        PullTypeResolver.prototype.computeDottedNameExpressionSymbol = function (dottedNameAST, enclosingDecl, context) {
            if ((dottedNameAST.operand2).isMissing()) {
                return this.semanticInfoChain.anyTypeSymbol;
            }

            var rhsName = (dottedNameAST.operand2).text();
            var prevCanUseTypeSymbol = context.canUseTypeSymbol;
            context.canUseTypeSymbol = true;
            var lhs = this.resolveAST(dottedNameAST.operand1, false, enclosingDecl, context);
            context.canUseTypeSymbol = prevCanUseTypeSymbol;
            var lhsType = lhs.type;

            if (lhs.isAlias()) {
                (lhs).isUsedAsValue = true;
                lhsType = (lhs).getExportAssignedTypeSymbol();
            }

            if (this.isAnyOrEquivalent(lhsType)) {
                return lhsType;
            }

            if (lhsType.isAlias()) {
                lhsType = (lhsType).getExportAssignedTypeSymbol();
            }

            if (!lhsType) {
                context.postError(this.unitPath, dottedNameAST.operand2.minChar, dottedNameAST.operand2.getLength(), TypeScript.DiagnosticCode.Could_not_find_enclosing_symbol_for_dotted_name_0, [(dottedNameAST.operand2).actualText], enclosingDecl);
                return this.getNewErrorTypeSymbol(null);
            }

            if ((lhsType === this.semanticInfoChain.numberTypeSymbol || (lhs.kind == 67108864 /* EnumMember */)) && this.cachedNumberInterfaceType()) {
                lhsType = this.cachedNumberInterfaceType();
            } else if (lhsType === this.semanticInfoChain.stringTypeSymbol && this.cachedStringInterfaceType()) {
                lhsType = this.cachedStringInterfaceType();
            } else if (lhsType === this.semanticInfoChain.booleanTypeSymbol && this.cachedBooleanInterfaceType()) {
                lhsType = this.cachedBooleanInterfaceType();
            }

            if (!lhsType.isResolved) {
                var potentiallySpecializedType = this.resolveDeclaredSymbol(lhsType, enclosingDecl, context);

                if (potentiallySpecializedType != lhsType) {
                    if (!lhs.isType()) {
                        context.setTypeInContext(lhs, potentiallySpecializedType);
                    }

                    lhsType = potentiallySpecializedType;
                }
            }

            if (lhsType.isContainer() && !lhsType.isAlias()) {
                var instanceSymbol = (lhsType).getInstanceSymbol();

                if (instanceSymbol) {
                    lhsType = instanceSymbol.type;
                }
            }

            if (this.isPrototypeMember(dottedNameAST, enclosingDecl, context)) {
                if (lhsType.isClass()) {
                    this.checkForStaticMemberAccess(dottedNameAST, lhsType, lhsType, enclosingDecl, context);
                    return lhsType;
                } else {
                    var classInstanceType = lhsType.getAssociatedContainerType();

                    if (classInstanceType && classInstanceType.isClass()) {
                        this.checkForStaticMemberAccess(dottedNameAST, lhsType, classInstanceType, enclosingDecl, context);
                        return classInstanceType;
                    }
                }
            }

            if (lhsType.isTypeParameter()) {
                lhsType = this.substituteUpperBoundForType(lhsType);
            }

            var nameSymbol = null;
            if (!(lhs.isType() && (lhs).isClass() && this.isNameOrMemberAccessExpression(dottedNameAST.operand1)) && !nameSymbol) {
                nameSymbol = this.getMemberSymbol(rhsName, TypeScript.PullElementKind.SomeValue, lhsType);
                nameSymbol = this.resolveNameSymbol(nameSymbol, context);
            }

            if (!nameSymbol) {
                if (lhsType.isClass()) {
                    var staticType = lhsType.getConstructorMethod().type;

                    nameSymbol = this.getMemberSymbol(rhsName, TypeScript.PullElementKind.SomeValue, staticType);

                    if (!nameSymbol) {
                        nameSymbol = this.getMemberSymbol(rhsName, TypeScript.PullElementKind.SomeValue, lhsType);
                    }
                } else if ((lhsType.getCallSignatures().length || lhsType.getConstructSignatures().length) && this.cachedFunctionInterfaceType()) {
                    nameSymbol = this.getMemberSymbol(rhsName, TypeScript.PullElementKind.SomeValue, this.cachedFunctionInterfaceType());
                } else if (lhsType.isContainer()) {
                    var containerType = lhsType;
                    var associatedInstance = containerType.getInstanceSymbol();

                    if (associatedInstance) {
                        var instanceType = associatedInstance.type;

                        nameSymbol = this.getMemberSymbol(rhsName, TypeScript.PullElementKind.SomeValue, instanceType);
                    }
                } else {
                    var associatedType = lhsType.getAssociatedContainerType();

                    if (associatedType && !associatedType.isClass()) {
                        nameSymbol = this.getMemberSymbol(rhsName, TypeScript.PullElementKind.SomeValue, associatedType);
                    }
                }

                nameSymbol = this.resolveNameSymbol(nameSymbol, context);

                if (!nameSymbol && !lhsType.isPrimitive() && this.cachedObjectInterfaceType()) {
                    nameSymbol = this.getMemberSymbol(rhsName, TypeScript.PullElementKind.SomeValue, this.cachedObjectInterfaceType());
                }

                if (!nameSymbol) {
                    context.postError(this.unitPath, dottedNameAST.operand2.minChar, dottedNameAST.operand2.getLength(), TypeScript.DiagnosticCode.The_property_0_does_not_exist_on_value_of_type_1, [(dottedNameAST.operand2).actualText, lhsType.toString(enclosingDecl ? enclosingDecl.getSymbol() : null)], enclosingDecl);
                    return this.getNewErrorTypeSymbol(null, rhsName);
                }
            }

            if (context.typeCheck()) {
                this.checkForSuperMemberAccess(dottedNameAST, nameSymbol, enclosingDecl, context) || this.checkForPrivateMemberAccess(dottedNameAST, lhsType, nameSymbol, enclosingDecl, context) || this.checkForStaticMemberAccess(dottedNameAST, lhsType, nameSymbol, enclosingDecl, context);
            }

            return nameSymbol;
        };

        PullTypeResolver.prototype.resolveTypeNameExpression = function (nameAST, enclosingDecl, context) {
            var typeNameSymbol = this.getSymbolForAST(nameAST);

            if (!typeNameSymbol || !typeNameSymbol.isType()) {
                typeNameSymbol = this.computeTypeNameExpression(nameAST, enclosingDecl, context);
                this.setSymbolForAST(nameAST, typeNameSymbol, context);
            }

            if (!typeNameSymbol.isResolved) {
                var savedResolvingNamespaceMemberAccess = context.resolvingNamespaceMemberAccess;
                context.resolvingNamespaceMemberAccess = false;
                this.resolveDeclaredSymbol(typeNameSymbol, enclosingDecl, context);
                context.resolvingNamespaceMemberAccess = savedResolvingNamespaceMemberAccess;
            }

            if (typeNameSymbol && !(typeNameSymbol.isTypeParameter() && (typeNameSymbol).isFunctionTypeParameter() && context.isSpecializingSignatureAtCallSite && !context.isSpecializingConstructorMethod)) {
                var substitution = context.findSpecializationForType(typeNameSymbol);

                if (typeNameSymbol.isTypeParameter() && (substitution != typeNameSymbol)) {
                    if (TypeScript.shouldSpecializeTypeParameterForTypeParameter(substitution, typeNameSymbol)) {
                        typeNameSymbol = substitution;
                    }
                }
            }

            return typeNameSymbol;
        };

        PullTypeResolver.prototype.computeTypeNameExpression = function (nameAST, enclosingDecl, context) {
            if (nameAST.isMissing()) {
                return this.semanticInfoChain.anyTypeSymbol;
            }

            var id = nameAST.text();

            if (id === "any") {
                return this.semanticInfoChain.anyTypeSymbol;
            } else if (id === "string") {
                return this.semanticInfoChain.stringTypeSymbol;
            } else if (id === "number") {
                return this.semanticInfoChain.numberTypeSymbol;
            } else if (id === "boolean") {
                return this.semanticInfoChain.booleanTypeSymbol;
            } else if (id === "void") {
                return this.semanticInfoChain.voidTypeSymbol;
            } else {
                var declPath = enclosingDecl !== null ? TypeScript.getPathToDecl(enclosingDecl) : [];

                if (enclosingDecl && !declPath.length) {
                    declPath = [enclosingDecl];
                }

                var kindToCheckFirst = context.resolvingNamespaceMemberAccess ? TypeScript.PullElementKind.SomeContainer : TypeScript.PullElementKind.SomeType;
                var kindToCheckSecond = context.resolvingNamespaceMemberAccess ? TypeScript.PullElementKind.SomeType : TypeScript.PullElementKind.SomeContainer;

                var typeNameSymbol = this.getSymbolFromDeclPath(id, declPath, kindToCheckFirst);

                if (!typeNameSymbol) {
                    typeNameSymbol = this.getSymbolFromDeclPath(id, declPath, kindToCheckSecond);
                }

                if (!typeNameSymbol) {
                    context.postError(this.unitPath, nameAST.minChar, nameAST.getLength(), TypeScript.DiagnosticCode.Could_not_find_symbol_0, [nameAST.actualText], enclosingDecl);
                    return this.getNewErrorTypeSymbol(null, id);
                }

                var typeNameSymbolAlias = null;
                if (typeNameSymbol.isAlias()) {
                    typeNameSymbolAlias = typeNameSymbol;
                    if (!typeNameSymbol.isResolved) {
                        var savedResolvingNamespaceMemberAccess = context.resolvingNamespaceMemberAccess;
                        context.resolvingNamespaceMemberAccess = false;
                        this.resolveDeclaredSymbol(typeNameSymbol, enclosingDecl, context);
                        context.resolvingNamespaceMemberAccess = savedResolvingNamespaceMemberAccess;
                    }

                    var aliasedType = typeNameSymbolAlias.getExportAssignedTypeSymbol();

                    if (aliasedType && !aliasedType.isResolved) {
                        this.resolveDeclaredSymbol(aliasedType, enclosingDecl, context);
                    }
                }

                if (typeNameSymbol.isTypeParameter()) {
                    if (enclosingDecl && (enclosingDecl.kind & TypeScript.PullElementKind.SomeFunction) && (enclosingDecl.flags & 16 /* Static */)) {
                        var parentDecl = typeNameSymbol.getDeclarations()[0].getParentDecl();

                        if (parentDecl.kind == 8 /* Class */) {
                            context.postError(this.unitPath, nameAST.minChar, nameAST.getLength(), TypeScript.DiagnosticCode.Static_methods_cannot_reference_class_type_parameters, null, enclosingDecl);
                            return this.getNewErrorTypeSymbol(null);
                        }
                    }
                }
            }

            return typeNameSymbol;
        };

        PullTypeResolver.prototype.resolveGenericTypeReference = function (genericTypeAST, enclosingDecl, context) {
            var savedResolvingTypeReference = context.resolvingTypeReference;
            context.resolvingTypeReference = true;
            var genericTypeSymbol = this.resolveAST(genericTypeAST.name, false, enclosingDecl, context).type;
            context.resolvingTypeReference = savedResolvingTypeReference;

            if (genericTypeSymbol.isError()) {
                return genericTypeSymbol;
            }

            if (!genericTypeSymbol.inResolution && !genericTypeSymbol.isResolved) {
                this.resolveDeclaredSymbol(genericTypeSymbol, enclosingDecl, context);
            }

            if (genericTypeSymbol.isAlias()) {
                genericTypeSymbol = (genericTypeSymbol).getExportAssignedTypeSymbol();
            }

            var typeArgs = [];

            if (!context.isResolvingTypeArguments(genericTypeAST)) {
                context.startResolvingTypeArguments(genericTypeAST);
                var savedIsResolvingClassExtendedType = context.isResolvingClassExtendedType;
                context.isResolvingClassExtendedType = false;

                if (genericTypeAST.typeArguments && genericTypeAST.typeArguments.members.length) {
                    for (var i = 0; i < genericTypeAST.typeArguments.members.length; i++) {
                        var typeArg = this.resolveTypeReference(genericTypeAST.typeArguments.members[i], enclosingDecl, context);

                        if (this.genericTypeIsUsedWithoutRequiredTypeArguments(typeArg, genericTypeAST.typeArguments.members[i], context)) {
                            context.postError(this.unitPath, genericTypeAST.typeArguments.members[i].minChar, genericTypeAST.typeArguments.members[i].getLength(), TypeScript.DiagnosticCode.Generic_type_references_must_include_all_type_arguments, null, enclosingDecl);
                            typeArg = this.specializeTypeToAny(typeArg, enclosingDecl, context);
                        }

                        if (!(typeArg.isTypeParameter() && (typeArg).isFunctionTypeParameter() && context.isSpecializingSignatureAtCallSite && !context.isSpecializingConstructorMethod)) {
                            typeArgs[i] = context.findSpecializationForType(typeArg);
                        } else {
                            typeArgs[i] = typeArg;
                        }
                    }
                }
                context.isResolvingClassExtendedType = savedIsResolvingClassExtendedType;
                context.doneResolvingTypeArguments();
            }

            var typeParameters = genericTypeSymbol.getTypeParameters();

            if (typeArgs.length && typeArgs.length != typeParameters.length) {
                context.postError(this.unitPath, genericTypeAST.minChar, genericTypeAST.getLength(), TypeScript.DiagnosticCode.Generic_type_0_requires_1_type_argument_s, [genericTypeSymbol.toString(), genericTypeSymbol.getTypeParameters().length], enclosingDecl);
                return this.getNewErrorTypeSymbol(null);
            }

            var specializedSymbol = TypeScript.specializeType(genericTypeSymbol, typeArgs, this, enclosingDecl, context, genericTypeAST);

            var typeConstraint = null;
            var upperBound = null;

            for (var iArg = 0; (iArg < typeArgs.length) && (iArg < typeParameters.length); iArg++) {
                typeArg = typeArgs[iArg];
                typeConstraint = typeParameters[iArg].getConstraint();

                if (typeConstraint) {
                    if (typeConstraint.isTypeParameter()) {
                        for (var j = 0; j < typeParameters.length && j < typeArgs.length; j++) {
                            if (typeParameters[j] == typeConstraint) {
                                typeConstraint = typeArgs[j];
                            }
                        }
                    }

                    if (typeArg.isTypeParameter()) {
                        upperBound = (typeArg).getConstraint();

                        if (upperBound) {
                            typeArg = upperBound;
                        }
                    }

                    if (typeArg.inResolution) {
                        return specializedSymbol;
                    }
                    if (!this.sourceIsAssignableToTarget(typeArg, typeConstraint, context)) {
                        context.postError(this.unitPath, genericTypeAST.minChar, genericTypeAST.getLength(), TypeScript.DiagnosticCode.Type_0_does_not_satisfy_the_constraint_1_for_type_parameter_2, [typeArg.toString(null, true), typeConstraint.toString(null, true), typeParameters[iArg].toString(null, true)], enclosingDecl);
                    }
                }
            }

            return specializedSymbol;
        };

        PullTypeResolver.prototype.resolveDottedTypeNameExpression = function (dottedNameAST, enclosingDecl, context) {
            var symbol = this.getSymbolForAST(dottedNameAST);
            if (!symbol) {
                symbol = this.computeDottedTypeNameExpression(dottedNameAST, enclosingDecl, context);
                this.setSymbolForAST(dottedNameAST, symbol, context);
            }

            if (!symbol.isResolved) {
                this.resolveDeclaredSymbol(symbol, enclosingDecl, context);
            }

            return symbol;
        };

        PullTypeResolver.prototype.computeDottedTypeNameExpression = function (dottedNameAST, enclosingDecl, context) {
            if ((dottedNameAST.operand2).isMissing()) {
                return this.semanticInfoChain.anyTypeSymbol;
            }

            var rhsName = (dottedNameAST.operand2).text();

            var savedResolvingTypeReference = context.resolvingTypeReference;
            var savedResolvingNamespaceMemberAccess = context.resolvingNamespaceMemberAccess;
            context.resolvingNamespaceMemberAccess = true;
            context.resolvingTypeReference = true;
            var lhs = this.resolveAST(dottedNameAST.operand1, false, enclosingDecl, context);
            context.resolvingTypeReference = savedResolvingTypeReference;
            context.resolvingNamespaceMemberAccess = savedResolvingNamespaceMemberAccess;

            var lhsType = lhs.isAlias() ? (lhs).getExportAssignedTypeSymbol() : lhs.type;

            if (context.isResolvingClassExtendedType) {
                if (lhs.isAlias()) {
                    (lhs).isUsedAsValue = true;
                }
            }

            if (this.isAnyOrEquivalent(lhsType)) {
                return lhsType;
            }

            if (!lhsType) {
                context.postError(this.unitPath, dottedNameAST.operand2.minChar, dottedNameAST.operand2.getLength(), TypeScript.DiagnosticCode.Could_not_find_enclosing_symbol_for_dotted_name_0, [(dottedNameAST.operand2).actualText], enclosingDecl);
                return this.getNewErrorTypeSymbol(null);
            }

            var memberKind = context.resolvingNamespaceMemberAccess ? TypeScript.PullElementKind.SomeContainer : TypeScript.PullElementKind.SomeType;
            var childTypeSymbol = this.getMemberSymbol(rhsName, memberKind, lhsType);

            if (!childTypeSymbol && lhsType.isContainer()) {
                var exportedContainer = (lhsType).getExportAssignedContainerSymbol();

                if (exportedContainer) {
                    childTypeSymbol = this.getMemberSymbol(rhsName, memberKind, exportedContainer);
                }
            }

            if (!childTypeSymbol && enclosingDecl) {
                var parentDecl = enclosingDecl;

                while (parentDecl) {
                    if (parentDecl.kind & TypeScript.PullElementKind.SomeContainer) {
                        break;
                    }

                    parentDecl = parentDecl.getParentDecl();
                }

                if (parentDecl) {
                    var enclosingSymbolType = parentDecl.getSymbol().type;

                    if (enclosingSymbolType === lhsType) {
                        childTypeSymbol = this.getMemberSymbol(rhsName, memberKind, lhsType);
                    }
                }
            }

            if (!childTypeSymbol) {
                context.postError(this.unitPath, dottedNameAST.operand2.minChar, dottedNameAST.operand2.getLength(), TypeScript.DiagnosticCode.The_property_0_does_not_exist_on_value_of_type_1, [(dottedNameAST.operand2).actualText, lhsType.toString(enclosingDecl ? enclosingDecl.getSymbol() : null)], enclosingDecl);
                return this.getNewErrorTypeSymbol(null, rhsName);
            }

            return childTypeSymbol;
        };

        PullTypeResolver.prototype.resolveFunctionExpression = function (funcDeclAST, inContextuallyTypedAssignment, enclosingDecl, context) {
            var _this = this;
            var funcDeclSymbol = null;
            var functionDecl = this.getDeclForAST(funcDeclAST);

            if (functionDecl && functionDecl.hasSymbol()) {
                funcDeclSymbol = functionDecl.getSymbol();
                if (funcDeclSymbol.isResolved) {
                    return funcDeclSymbol;
                }
            }

            var shouldContextuallyType = inContextuallyTypedAssignment;

            var assigningFunctionTypeSymbol = null;
            var assigningFunctionSignature = null;

            if (funcDeclAST.returnTypeAnnotation) {
                shouldContextuallyType = false;
            }

            if (shouldContextuallyType && funcDeclAST.arguments) {
                for (var i = 0; i < funcDeclAST.arguments.members.length; i++) {
                    var parameter = funcDeclAST.arguments.members[i];
                    if (parameter.typeExpr) {
                        shouldContextuallyType = false;
                        break;
                    }
                }
            }

            if (shouldContextuallyType) {
                assigningFunctionTypeSymbol = context.getContextualType();

                if (assigningFunctionTypeSymbol) {
                    this.resolveDeclaredSymbol(assigningFunctionTypeSymbol, enclosingDecl, context);

                    if (assigningFunctionTypeSymbol) {
                        assigningFunctionSignature = assigningFunctionTypeSymbol.getCallSignatures()[0];
                    }
                }
            }

            if (!functionDecl) {
                var semanticInfo = this.semanticInfoChain.getUnit(this.unitPath);
                var declCollectionContext = new TypeScript.DeclCollectionContext(semanticInfo, this.unitPath);

                if (enclosingDecl) {
                    declCollectionContext.pushParent(enclosingDecl);
                }

                TypeScript.getAstWalkerFactory().walk(funcDeclAST, TypeScript.preCollectDecls, TypeScript.postCollectDecls, null, declCollectionContext);

                functionDecl = this.getDeclForAST(funcDeclAST);
                this.currentUnit.addSynthesizedDecl(functionDecl);

                var binder = new TypeScript.PullSymbolBinder(this.semanticInfoChain);
                binder.setUnit(this.unitPath);
                binder.bindFunctionExpressionToPullSymbol(functionDecl);
            }

            funcDeclSymbol = functionDecl.getSymbol();
            var funcDeclType = funcDeclSymbol.type;
            var signature = funcDeclType.getCallSignatures()[0];
            funcDeclSymbol.startResolving();

            if (funcDeclAST.arguments) {
                var contextParams = [];

                if (assigningFunctionSignature) {
                    contextParams = assigningFunctionSignature.parameters;
                }

                var contextualParametersCount = contextParams.length;
                for (var i = 0, n = funcDeclAST.arguments.members.length; i < n; i++) {
                    var actualParameter = funcDeclAST.arguments.members[i];

                    var actualParameterIsVarArgParameter = funcDeclAST.variableArgList && i === n - 1;
                    var correspondingContextualParameter = null;
                    var contextualParameterType = null;

                    if (i < contextualParametersCount) {
                        correspondingContextualParameter = contextParams[i];
                    } else if (contextualParametersCount && contextParams[contextualParametersCount - 1].isVarArg) {
                        correspondingContextualParameter = contextParams[contextualParametersCount - 1];
                    }

                    if (correspondingContextualParameter) {
                        if (correspondingContextualParameter.isVarArg === actualParameterIsVarArgParameter) {
                            contextualParameterType = correspondingContextualParameter.type;
                        } else if (correspondingContextualParameter.isVarArg) {
                            contextualParameterType = correspondingContextualParameter.type.getElementType();
                        }
                    }

                    this.resolveFunctionExpressionParameter(actualParameter, contextualParameterType, functionDecl, context);
                }
            }

            if (funcDeclAST.returnTypeAnnotation) {
                var returnTypeSymbol = this.resolveTypeReference(funcDeclAST.returnTypeAnnotation, functionDecl, context);

                signature.returnType = returnTypeSymbol;
            } else {
                if (assigningFunctionSignature) {
                    var returnType = assigningFunctionSignature.returnType;

                    if (returnType) {
                        context.pushContextualType(returnType, context.inProvisionalResolution(), null);

                        this.resolveFunctionBodyReturnTypes(funcDeclAST, signature, true, functionDecl, context);
                        context.popContextualType();
                    } else {
                        signature.returnType = this.semanticInfoChain.anyTypeSymbol;

                        if (this.compilationSettings.noImplicitAny && !context.isInInvocationExpression) {
                            var functionExpressionName = (functionDecl).getFunctionExpressionName();

                            if (functionExpressionName != "") {
                                context.postError(this.unitPath, funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode._0_which_lacks_return_type_annotation_implicitly_has_an_any_return_type, [functionExpressionName], functionDecl);
                            } else {
                                context.postError(this.unitPath, funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode.Function_expression_which_lacks_return_type_annotation_implicitly_has_an_any_return_type, [], functionDecl);
                            }
                        }
                    }
                } else {
                    this.resolveFunctionBodyReturnTypes(funcDeclAST, signature, false, functionDecl, context);
                }
            }

            funcDeclSymbol.type = funcDeclType;
            funcDeclSymbol.setResolved();

            if (context.typeCheck()) {
                PullTypeResolver.typeCheckCallBacks.push(function () {
                    _this.setUnitPath(functionDecl.getScriptName());
                    _this.seenSuperConstructorCall = false;

                    _this.resolveAST(funcDeclAST.block, false, functionDecl, context);

                    _this.validateVariableDeclarationGroups(functionDecl, context);

                    var hasReturn = (functionDecl.flags & (2048 /* Signature */ | 4194304 /* HasReturnStatement */)) != 0;

                    if (funcDeclAST.block && funcDeclAST.returnTypeAnnotation != null && !hasReturn) {
                        var isVoidOrAny = _this.isAnyOrEquivalent(returnTypeSymbol) || returnTypeSymbol === _this.semanticInfoChain.voidTypeSymbol;

                        if (!isVoidOrAny && !(funcDeclAST.block.statements.members.length > 0 && funcDeclAST.block.statements.members[0].nodeType() === 96 /* ThrowStatement */)) {
                            var funcName = functionDecl.getDisplayName();
                            funcName = funcName ? "'" + funcName + "'" : "expression";

                            context.postError(_this.unitPath, funcDeclAST.returnTypeAnnotation.minChar, funcDeclAST.returnTypeAnnotation.getLength(), TypeScript.DiagnosticCode.Function_0_declared_a_non_void_return_type_but_has_no_return_expression, [funcName], enclosingDecl);
                        }
                    }

                    _this.typeCheckFunctionOverloads(funcDeclAST, context);
                });
            }

            return funcDeclSymbol;
        };

        PullTypeResolver.prototype.resolveThisExpression = function (ast, enclosingDecl, context) {
            var symbol = this.getSymbolForAST(ast);

            if (!symbol) {
                symbol = this.computeThisExpressionSymbol(ast, enclosingDecl, context);
                this.setSymbolForAST(ast, symbol, context);
            }

            this.checkForThisOrSuperCaptureInArrowFunction(ast, enclosingDecl);

            return symbol;
        };

        PullTypeResolver.prototype.computeThisExpressionSymbol = function (ast, enclosingDecl, context) {
            if (enclosingDecl) {
                var enclosingDeclKind = enclosingDecl.kind;
                var diagnostics;
                var thisTypeSymbol = this.semanticInfoChain.anyTypeSymbol;
                var classDecl = null;

                if (!(enclosingDeclKind & (TypeScript.PullElementKind.SomeFunction | 1 /* Script */ | TypeScript.PullElementKind.SomeBlock | 8 /* Class */))) {
                    thisTypeSymbol = this.getNewErrorTypeSymbol(null);
                } else {
                    var declPath = TypeScript.getPathToDecl(enclosingDecl);

                    if (declPath.length) {
                        var isStaticContext = false;
                        for (var i = declPath.length - 1; i >= 0; i--) {
                            var decl = declPath[i];
                            var declKind = decl.kind;
                            var declFlags = decl.flags;

                            if (declFlags & 16 /* Static */) {
                                isStaticContext = true;
                            } else if (declKind === 131072 /* FunctionExpression */ && !TypeScript.hasFlag(declFlags, 8192 /* FatArrow */)) {
                                break;
                            } else if (declKind === 16384 /* Function */) {
                                break;
                            } else if (declKind === 8 /* Class */) {
                                if (context.isInStaticInitializer) {
                                    thisTypeSymbol = this.getNewErrorTypeSymbol(null);
                                } else {
                                    var classSymbol = decl.getSymbol();
                                    classDecl = decl;
                                    if (isStaticContext) {
                                        var constructorSymbol = classSymbol.getConstructorMethod();
                                        thisTypeSymbol = constructorSymbol.type;
                                    } else {
                                        thisTypeSymbol = classSymbol;
                                    }
                                }
                                break;
                            }
                        }
                    }
                }
            }

            if (context.typeCheck()) {
                var thisExpressionAST = ast;
                var enclosingNonLambdaDecl = this.getEnclosingNonLambdaDecl(enclosingDecl);

                if (context.isResolvingSuperConstructorTarget && this.superCallMustBeFirstStatementInConstructor(enclosingDecl, classDecl)) {
                    context.postError(this.unitPath, thisExpressionAST.minChar, thisExpressionAST.getLength(), TypeScript.DiagnosticCode.this_cannot_be_referenced_in_current_location, null, enclosingDecl);
                } else if (enclosingNonLambdaDecl) {
                    if (enclosingNonLambdaDecl.kind === 8 /* Class */ && context.isInStaticInitializer) {
                        context.postError(this.unitPath, thisExpressionAST.minChar, thisExpressionAST.getLength(), TypeScript.DiagnosticCode.this_cannot_be_referenced_in_static_initializers_in_a_class_body, null, enclosingDecl);
                    } else if (enclosingNonLambdaDecl.kind === 4 /* Container */ || enclosingNonLambdaDecl.kind === 32 /* DynamicModule */) {
                        context.postError(this.unitPath, thisExpressionAST.minChar, thisExpressionAST.getLength(), TypeScript.DiagnosticCode.this_cannot_be_referenced_within_module_bodies, null, enclosingDecl);
                    } else if (context.inConstructorArguments) {
                        context.postError(this.unitPath, thisExpressionAST.minChar, thisExpressionAST.getLength(), TypeScript.DiagnosticCode.this_cannot_be_referenced_in_constructor_arguments, null, enclosingDecl);
                    }
                }
            }

            return thisTypeSymbol;
        };

        PullTypeResolver.prototype.getEnclosingNonLambdaDecl = function (enclosingDecl) {
            var declPath = enclosingDecl !== null ? TypeScript.getPathToDecl(enclosingDecl) : [];

            if (declPath.length) {
                for (var i = declPath.length - 1; i >= 0; i--) {
                    var decl = declPath[i];
                    if (!(decl.kind === 131072 /* FunctionExpression */ && (decl.flags & 8192 /* FatArrow */))) {
                        return decl;
                    }
                }
            }

            return null;
        };

        PullTypeResolver.prototype.resolveSuperExpression = function (ast, enclosingDecl, context) {
            if (!enclosingDecl) {
                return this.semanticInfoChain.anyTypeSymbol;
            }

            var declPath = enclosingDecl !== null ? TypeScript.getPathToDecl(enclosingDecl) : [];
            var classSymbol = null;
            var superType = this.semanticInfoChain.anyTypeSymbol;

            if (declPath.length) {
                for (var i = declPath.length - 1; i >= 0; i--) {
                    var decl = declPath[i];
                    var declFlags = decl.flags;

                    if (decl.kind === 131072 /* FunctionExpression */ && !(declFlags & 8192 /* FatArrow */)) {
                        break;
                    } else if (declFlags & 16 /* Static */) {
                        break;
                    } else if (decl.kind === 8 /* Class */) {
                        classSymbol = decl.getSymbol();

                        break;
                    }
                }
            }

            if (classSymbol) {
                if (!classSymbol.isResolved) {
                    this.resolveDeclaredSymbol(classSymbol, enclosingDecl, context);
                }

                var parents = classSymbol.getExtendedTypes();

                if (parents.length) {
                    superType = parents[0];
                }
            }

            if (context.typeCheck()) {
                var nonLambdaEnclosingDecl = this.getEnclosingNonLambdaDecl(enclosingDecl);

                if (nonLambdaEnclosingDecl) {
                    var nonLambdaEnclosingDeclKind = nonLambdaEnclosingDecl.kind;
                    var inSuperConstructorTarget = context.isResolvingSuperConstructorTarget;

                    if (inSuperConstructorTarget && enclosingDecl.kind !== 32768 /* ConstructorMethod */) {
                        context.postError(this.unitPath, ast.minChar, ast.getLength(), TypeScript.DiagnosticCode.Super_calls_are_not_permitted_outside_constructors_or_in_local_functions_inside_constructors, null, enclosingDecl);
                    } else if ((nonLambdaEnclosingDeclKind !== 65536 /* Method */ && nonLambdaEnclosingDeclKind !== 262144 /* GetAccessor */ && nonLambdaEnclosingDeclKind !== 524288 /* SetAccessor */ && nonLambdaEnclosingDeclKind !== 32768 /* ConstructorMethod */) || ((nonLambdaEnclosingDecl.flags & 16 /* Static */) !== 0)) {
                        context.postError(this.unitPath, ast.minChar, ast.getLength(), TypeScript.DiagnosticCode.super_property_access_is_permitted_only_in_a_constructor_instance_member_function_or_instance_member_accessor_of_a_derived_class, null, enclosingDecl);
                    } else if (!this.enclosingClassIsDerived(enclosingDecl)) {
                        context.postError(this.unitPath, ast.minChar, ast.getLength(), TypeScript.DiagnosticCode.super_cannot_be_referenced_in_non_derived_classes, null, enclosingDecl);
                    }
                }
            }

            this.checkForThisOrSuperCaptureInArrowFunction(ast, enclosingDecl);

            return superType;
        };

        PullTypeResolver.prototype.resolveObjectLiteralExpression = function (expressionAST, inContextuallyTypedAssignment, enclosingDecl, context, additionalResults) {
            var symbol = this.getSymbolForAST(expressionAST);

            if (!symbol || additionalResults) {
                symbol = this.computeObjectLiteralExpression(expressionAST, inContextuallyTypedAssignment, enclosingDecl, context, additionalResults);
                this.setSymbolForAST(expressionAST, symbol, context);
            }

            return symbol;
        };

        PullTypeResolver.prototype.computeObjectLiteralExpression = function (expressionAST, inContextuallyTypedAssignment, enclosingDecl, context, additionalResults) {
            var objectLitAST = expressionAST;
            var span = TypeScript.TextSpan.fromBounds(objectLitAST.minChar, objectLitAST.limChar);

            var objectLitDecl = new TypeScript.PullDecl("", "", 512 /* ObjectLiteral */, 0 /* None */, span, this.unitPath);
            this.currentUnit.addSynthesizedDecl(objectLitDecl);

            if (enclosingDecl) {
                objectLitDecl.setParentDecl(enclosingDecl);
            }

            this.currentUnit.setDeclForAST(objectLitAST, objectLitDecl);
            this.currentUnit.setASTForDecl(objectLitDecl, objectLitAST);

            var typeSymbol = new TypeScript.PullTypeSymbol("", 16 /* Interface */);
            typeSymbol.addDeclaration(objectLitDecl);
            objectLitDecl.setSymbol(typeSymbol);

            var memberDecls = objectLitAST.operand;

            var contextualType = null;

            if (inContextuallyTypedAssignment) {
                contextualType = context.getContextualType();

                this.resolveDeclaredSymbol(contextualType, enclosingDecl, context);
            }

            if (memberDecls) {
                var binex;
                var memberSymbol;
                var assigningSymbol = null;
                var acceptedContextualType = false;

                if (additionalResults) {
                    additionalResults.membersContextTypeSymbols = [];
                }

                for (var i = 0, len = memberDecls.members.length; i < len; i++) {
                    binex = memberDecls.members[i];

                    var id = binex.operand1;
                    var text;
                    var actualText;

                    if (id.nodeType() === 21 /* Name */) {
                        actualText = (id).actualText;
                        text = (id).text();
                    } else if (id.nodeType() === 5 /* StringLiteral */) {
                        actualText = (id).actualText;
                        text = (id).text();
                    } else if (id.nodeType() === 7 /* NumericLiteral */) {
                        actualText = text = (id).text();
                    } else {
                        return this.semanticInfoChain.anyTypeSymbol;
                    }

                    span = TypeScript.TextSpan.fromBounds(binex.minChar, binex.limChar);

                    var isAccessor = binex.operand2.nodeType() === 13 /* FunctionDeclaration */ && (binex.operand2).isAccessor();

                    if (!isAccessor) {
                        var decl = new TypeScript.PullDecl(text, actualText, 4096 /* Property */, 4 /* Public */, span, this.unitPath);
                        this.currentUnit.addSynthesizedDecl(decl);

                        objectLitDecl.addChildDecl(decl);
                        decl.setParentDecl(objectLitDecl);

                        this.semanticInfoChain.getUnit(this.unitPath).setDeclForAST(binex, decl);
                        this.semanticInfoChain.getUnit(this.unitPath).setASTForDecl(decl, binex);

                        memberSymbol = new TypeScript.PullSymbol(text, 4096 /* Property */);

                        memberSymbol.addDeclaration(decl);
                        decl.setSymbol(memberSymbol);
                    }

                    if (contextualType) {
                        assigningSymbol = this.getMemberSymbol(text, TypeScript.PullElementKind.SomeValue, contextualType);

                        if (assigningSymbol) {
                            this.resolveDeclaredSymbol(assigningSymbol, enclosingDecl, context);

                            context.pushContextualType(assigningSymbol.type, context.inProvisionalResolution(), null);

                            acceptedContextualType = true;

                            if (additionalResults) {
                                additionalResults.membersContextTypeSymbols[i] = assigningSymbol.type;
                            }
                        }
                    }

                    if (isAccessor) {
                        var funcDeclAST = binex.operand2;
                        var semanticInfo = this.semanticInfoChain.getUnit(this.unitPath);
                        var declCollectionContext = new TypeScript.DeclCollectionContext(semanticInfo, this.unitPath);

                        declCollectionContext.pushParent(objectLitDecl);

                        TypeScript.getAstWalkerFactory().walk(funcDeclAST, TypeScript.preCollectDecls, TypeScript.postCollectDecls, null, declCollectionContext);

                        var functionDecl = this.getDeclForAST(funcDeclAST);
                        this.currentUnit.addSynthesizedDecl(functionDecl);

                        var binder = new TypeScript.PullSymbolBinder(this.semanticInfoChain);
                        binder.setUnit(this.unitPath);

                        if (funcDeclAST.isGetAccessor()) {
                            binder.bindGetAccessorDeclarationToPullSymbol(functionDecl);
                        } else {
                            binder.bindSetAccessorDeclarationToPullSymbol(functionDecl);
                        }
                    }

                    var memberExprType = this.resolveAST(binex.operand2, assigningSymbol != null, enclosingDecl, context);

                    if (acceptedContextualType) {
                        context.popContextualType();
                        acceptedContextualType = false;
                    }

                    if (isAccessor) {
                        this.setSymbolForAST(binex.operand1, memberExprType, context);
                    } else {
                        context.setTypeInContext(memberSymbol, memberExprType.type);
                        memberSymbol.setResolved();

                        this.setSymbolForAST(binex.operand1, memberSymbol, context);
                        typeSymbol.addMember(memberSymbol);
                    }
                }
            }

            typeSymbol.setResolved();
            return typeSymbol;
        };

        PullTypeResolver.prototype.resolveArrayLiteralExpression = function (arrayLit, inContextuallyTypedAssignment, enclosingDecl, context) {
            var symbol = this.getSymbolForAST(arrayLit);
            if (!symbol) {
                symbol = this.computeArrayLiteralExpressionSymbol(arrayLit, inContextuallyTypedAssignment, enclosingDecl, context);
                this.setSymbolForAST(arrayLit, symbol, context);
            }

            return symbol;
        };

        PullTypeResolver.prototype.computeArrayLiteralExpressionSymbol = function (arrayLit, inContextuallyTypedAssignment, enclosingDecl, context) {
            var elements = arrayLit.operand;
            var elementType = this.semanticInfoChain.anyTypeSymbol;
            var elementTypes = [];
            var comparisonInfo = new TypeComparisonInfo();
            var contextualElementType = null;
            comparisonInfo.onlyCaptureFirstError = true;

            if (inContextuallyTypedAssignment) {
                var contextualType = context.getContextualType();

                this.resolveDeclaredSymbol(contextualType, enclosingDecl, context);

                if (contextualType) {
                    if (contextualType.isArray()) {
                        contextualElementType = contextualType.getElementType();
                    } else {
                        var indexSignatures = contextualType.getIndexSignatures();
                        for (var i = 0; i < indexSignatures.length; i++) {
                            var signature = indexSignatures[i];
                            if (signature.parameters[0].type === this.semanticInfoChain.numberTypeSymbol) {
                                contextualElementType = signature.returnType;
                                break;
                            }
                        }
                    }
                }
            }

            if (elements) {
                if (inContextuallyTypedAssignment) {
                    context.pushContextualType(contextualElementType, context.inProvisionalResolution(), null);
                }

                for (var i = 0; i < elements.members.length; i++) {
                    elementTypes[elementTypes.length] = this.resolveAST(elements.members[i], inContextuallyTypedAssignment, enclosingDecl, context).type;
                }

                if (inContextuallyTypedAssignment) {
                    context.popContextualType();
                }
            }

            if (this.compilationSettings.noImplicitAny && !context.isInInvocationExpression) {
                if (!inContextuallyTypedAssignment && elements.members.length == 0) {
                    context.postError(this.unitPath, arrayLit.minChar, arrayLit.getLength(), TypeScript.DiagnosticCode.Array_Literal_implicitly_has_an_any_type_from_widening, [], enclosingDecl);
                }
            }

            if (contextualElementType && !contextualElementType.isTypeParameter()) {
                elementType = contextualElementType;

                for (var i = 0; i < elementTypes.length; i++) {
                    var comparisonInfo = new TypeComparisonInfo();
                    var currentElementType = elementTypes[i];
                    var currentElementAST = elements.members[i];
                    if (!this.sourceIsAssignableToTarget(currentElementType, contextualElementType, context, comparisonInfo)) {
                        var message;
                        if (comparisonInfo.message) {
                            message = context.postError(this.getUnitPath(), currentElementAST.minChar, currentElementAST.getLength(), TypeScript.DiagnosticCode.Cannot_convert_0_to_1_NL_2, [currentElementType.toString(), contextualElementType.toString(), comparisonInfo.message], enclosingDecl);
                        } else {
                            message = context.postError(this.getUnitPath(), currentElementAST.minChar, currentElementAST.getLength(), TypeScript.DiagnosticCode.Cannot_convert_0_to_1, [currentElementType.toString(), contextualElementType.toString()], enclosingDecl);
                        }

                        return this.getNewErrorTypeSymbol(null);
                    }
                }
            } else {
                if (elementTypes.length) {
                    elementType = elementTypes[0];
                } else if (contextualElementType) {
                    elementType = contextualElementType;
                }

                var collection = {
                    getLength: function () {
                        return elements.members.length;
                    },
                    setTypeAtIndex: function (index, type) {
                        elementTypes[index] = type;
                    },
                    getTypeAtIndex: function (index) {
                        return elementTypes[index];
                    }
                };

                elementType = this.findBestCommonType(elementType, null, collection, context, comparisonInfo);

                if (elementType === this.semanticInfoChain.undefinedTypeSymbol || elementType === this.semanticInfoChain.nullTypeSymbol) {
                    elementType = this.semanticInfoChain.anyTypeSymbol;

                    if (this.compilationSettings.noImplicitAny && !inContextuallyTypedAssignment && !context.isInInvocationExpression) {
                        context.postError(this.unitPath, arrayLit.minChar, arrayLit.getLength(), TypeScript.DiagnosticCode.Array_Literal_implicitly_has_an_any_type_from_widening, [], enclosingDecl);
                    }
                }

                if (!elementType) {
                    elementType = this.semanticInfoChain.anyTypeSymbol;

                    if (this.compilationSettings.noImplicitAny && !inContextuallyTypedAssignment && !context.isInInvocationExpression) {
                        context.postError(this.unitPath, arrayLit.minChar, arrayLit.getLength(), TypeScript.DiagnosticCode.Array_Literal_implicitly_has_an_any_type_from_widening, [], enclosingDecl);
                    }
                } else if (contextualElementType && !contextualElementType.isTypeParameter()) {
                    if (this.sourceIsAssignableToTarget(elementType, contextualElementType, context)) {
                        elementType = contextualType;
                    }
                }
            }

            var arraySymbol = elementType.getArrayType();

            if (!arraySymbol) {
                if (!this.cachedArrayInterfaceType().isResolved) {
                    this.resolveDeclaredSymbol(this.cachedArrayInterfaceType(), enclosingDecl, context);
                }

                arraySymbol = TypeScript.specializeType(this.cachedArrayInterfaceType(), [elementType], this, this.cachedArrayInterfaceType().getDeclarations()[0], context, arrayLit);

                if (!arraySymbol) {
                    arraySymbol = this.semanticInfoChain.anyTypeSymbol;
                }
            }

            return arraySymbol;
        };

        PullTypeResolver.prototype.resolveIndexExpression = function (callEx, inContextuallyTypedAssignment, enclosingDecl, context) {
            var symbol = this.getSymbolForAST(callEx);
            if (!symbol) {
                symbol = this.computeIndexExpressionSymbol(callEx, inContextuallyTypedAssignment, enclosingDecl, context);
                this.setSymbolForAST(callEx, symbol, context);
            }

            return symbol;
        };

        PullTypeResolver.prototype.computeIndexExpressionSymbol = function (callEx, inContextuallyTypedAssignment, enclosingDecl, context) {
            var targetSymbol = this.resolveAST(callEx.operand1, inContextuallyTypedAssignment, enclosingDecl, context);

            var targetTypeSymbol = targetSymbol.type;

            if (this.isAnyOrEquivalent(targetTypeSymbol)) {
                return targetTypeSymbol;
            }

            var elementType = targetTypeSymbol.getElementType();

            var indexType = this.resolveAST(callEx.operand2, inContextuallyTypedAssignment, enclosingDecl, context).type;

            var isNumberIndex = indexType === this.semanticInfoChain.numberTypeSymbol || TypeScript.PullHelpers.symbolIsEnum(indexType);

            if (elementType && isNumberIndex) {
                return elementType;
            }

            if (callEx.operand2.nodeType() === 5 /* StringLiteral */ || callEx.operand2.nodeType() === 7 /* NumericLiteral */) {
                var memberName = callEx.operand2.nodeType() === 5 /* StringLiteral */ ? TypeScript.stripQuotes((callEx.operand2).actualText) : (callEx.operand2).value.toString();

                var member = this.getMemberSymbol(memberName, TypeScript.PullElementKind.SomeValue, targetTypeSymbol);

                if (member) {
                    return member.type;
                }
            }

            var signatures = targetTypeSymbol.getIndexSignatures();

            var stringSignature = null;
            var numberSignature = null;
            var signature = null;
            var paramSymbols;
            var paramType;

            for (var i = 0; i < signatures.length; i++) {
                if (stringSignature && numberSignature) {
                    break;
                }

                signature = signatures[i];

                paramSymbols = signature.parameters;

                if (paramSymbols.length) {
                    paramType = paramSymbols[0].type;

                    if (paramType === this.semanticInfoChain.stringTypeSymbol) {
                        stringSignature = signatures[i];
                        continue;
                    } else if (paramType === this.semanticInfoChain.numberTypeSymbol || paramType.kind === 64 /* Enum */) {
                        numberSignature = signatures[i];
                        continue;
                    }
                }
            }

            if (numberSignature && (isNumberIndex || indexType === this.semanticInfoChain.anyTypeSymbol)) {
                var returnType = numberSignature.returnType;

                if (!returnType) {
                    returnType = this.semanticInfoChain.anyTypeSymbol;
                }

                return returnType;
            } else if (stringSignature && (isNumberIndex || indexType === this.semanticInfoChain.anyTypeSymbol || indexType === this.semanticInfoChain.stringTypeSymbol)) {
                var returnType = stringSignature.returnType;

                if (!returnType) {
                    returnType = this.semanticInfoChain.anyTypeSymbol;
                }

                return returnType;
            } else if (isNumberIndex || indexType === this.semanticInfoChain.anyTypeSymbol || indexType === this.semanticInfoChain.stringTypeSymbol) {
                var returnType = this.semanticInfoChain.anyTypeSymbol;
                return returnType;
            } else {
                context.postError(this.getUnitPath(), callEx.minChar, callEx.getLength(), TypeScript.DiagnosticCode.Value_of_type_0_is_not_indexable_by_type_1, [targetTypeSymbol.toString(), indexType.toString()], enclosingDecl);
                return this.getNewErrorTypeSymbol(null);
            }
        };

        PullTypeResolver.prototype.resolveBitwiseOperator = function (expressionAST, inContextuallyTypedAssignment, enclosingDecl, context) {
            var binex = expressionAST;

            var leftType = this.resolveAST(binex.operand1, inContextuallyTypedAssignment, enclosingDecl, context).type;
            var rightType = this.resolveAST(binex.operand2, inContextuallyTypedAssignment, enclosingDecl, context).type;

            if (this.sourceIsSubtypeOfTarget(leftType, this.semanticInfoChain.numberTypeSymbol, context) && this.sourceIsSubtypeOfTarget(rightType, this.semanticInfoChain.numberTypeSymbol, context)) {
                return this.semanticInfoChain.numberTypeSymbol;
            } else if ((leftType === this.semanticInfoChain.booleanTypeSymbol) && (rightType === this.semanticInfoChain.booleanTypeSymbol)) {
                return this.semanticInfoChain.booleanTypeSymbol;
            } else if (this.isAnyOrEquivalent(leftType)) {
                if ((this.isAnyOrEquivalent(rightType) || (rightType === this.semanticInfoChain.numberTypeSymbol) || (rightType === this.semanticInfoChain.booleanTypeSymbol))) {
                    return this.semanticInfoChain.anyTypeSymbol;
                }
            } else if (this.isAnyOrEquivalent(rightType)) {
                if ((leftType === this.semanticInfoChain.numberTypeSymbol) || (leftType === this.semanticInfoChain.booleanTypeSymbol)) {
                    return this.semanticInfoChain.anyTypeSymbol;
                }
            }

            return this.semanticInfoChain.anyTypeSymbol;
        };

        PullTypeResolver.prototype.resolveBinaryAdditionOperation = function (binaryExpression, inContextuallyTypedAssignment, enclosingDecl, context) {
            var lhsType = this.resolveAST(binaryExpression.operand1, false, enclosingDecl, context).type;
            var rhsType = this.resolveAST(binaryExpression.operand2, false, enclosingDecl, context).type;

            if (TypeScript.PullHelpers.symbolIsEnum(lhsType)) {
                lhsType = this.semanticInfoChain.numberTypeSymbol;
            } else if (lhsType === this.semanticInfoChain.nullTypeSymbol || lhsType === this.semanticInfoChain.undefinedTypeSymbol) {
                if (rhsType != this.semanticInfoChain.nullTypeSymbol && rhsType != this.semanticInfoChain.undefinedTypeSymbol) {
                    lhsType = rhsType;
                } else {
                    lhsType = this.semanticInfoChain.anyTypeSymbol;
                }
            }

            if (TypeScript.PullHelpers.symbolIsEnum(rhsType)) {
                rhsType = this.semanticInfoChain.numberTypeSymbol;
            } else if (rhsType === this.semanticInfoChain.nullTypeSymbol || rhsType === this.semanticInfoChain.undefinedTypeSymbol) {
                if (lhsType != this.semanticInfoChain.nullTypeSymbol && lhsType != this.semanticInfoChain.undefinedTypeSymbol) {
                    rhsType = lhsType;
                } else {
                    rhsType = this.semanticInfoChain.anyTypeSymbol;
                }
            }

            var exprType = null;

            if (lhsType === this.semanticInfoChain.stringTypeSymbol || rhsType === this.semanticInfoChain.stringTypeSymbol) {
                exprType = this.semanticInfoChain.stringTypeSymbol;
            } else if (this.isAnyOrEquivalent(lhsType) || this.isAnyOrEquivalent(rhsType)) {
                exprType = this.semanticInfoChain.anyTypeSymbol;
            } else if (rhsType === this.semanticInfoChain.numberTypeSymbol && lhsType === this.semanticInfoChain.numberTypeSymbol) {
                exprType = this.semanticInfoChain.numberTypeSymbol;
            }

            if (exprType) {
                if (binaryExpression.nodeType() === 40 /* AddAssignmentExpression */) {
                    var lhsExpression = this.resolveAST(binaryExpression.operand1, false, enclosingDecl, context);
                    if (!this.isValidLHS(binaryExpression.operand1, lhsExpression)) {
                        context.postError(this.unitPath, binaryExpression.operand1.minChar, binaryExpression.operand1.getLength(), TypeScript.DiagnosticCode.Invalid_left_hand_side_of_assignment_expression, null, enclosingDecl);
                    }

                    this.checkAssignability(binaryExpression.operand1, exprType, lhsType, enclosingDecl, context);
                }
            } else {
                context.postError(this.unitPath, binaryExpression.operand1.minChar, binaryExpression.operand1.getLength(), TypeScript.DiagnosticCode.Invalid_expression_types_not_known_to_support_the_addition_operator, null, enclosingDecl);
                exprType = this.semanticInfoChain.anyTypeSymbol;
            }

            return exprType;
        };

        PullTypeResolver.prototype.resolveLogicalOrExpression = function (binex, inContextuallyTypedAssignment, enclosingDecl, context) {
            var symbol = this.getSymbolForAST(binex);
            if (!symbol) {
                symbol = this.computeLogicalOrExpressionSymbol(binex, inContextuallyTypedAssignment, enclosingDecl, context);
                this.setSymbolForAST(binex, symbol, context);
            }

            return symbol;
        };

        PullTypeResolver.prototype.computeLogicalOrExpressionSymbol = function (binex, inContextuallyTypedAssignment, enclosingDecl, context) {
            var leftType = this.resolveAST(binex.operand1, inContextuallyTypedAssignment, enclosingDecl, context).type;
            var rightType = this.resolveAST(binex.operand2, inContextuallyTypedAssignment, enclosingDecl, context).type;

            if (this.isAnyOrEquivalent(leftType) || this.isAnyOrEquivalent(rightType)) {
                return this.semanticInfoChain.anyTypeSymbol;
            } else if (leftType === this.semanticInfoChain.booleanTypeSymbol) {
                if (rightType === this.semanticInfoChain.booleanTypeSymbol) {
                    return this.semanticInfoChain.booleanTypeSymbol;
                } else {
                    return this.semanticInfoChain.anyTypeSymbol;
                }
            } else if (leftType === this.semanticInfoChain.numberTypeSymbol) {
                if (rightType === this.semanticInfoChain.numberTypeSymbol) {
                    return this.semanticInfoChain.numberTypeSymbol;
                } else {
                    return this.semanticInfoChain.anyTypeSymbol;
                }
            } else if (leftType === this.semanticInfoChain.stringTypeSymbol) {
                if (rightType === this.semanticInfoChain.stringTypeSymbol) {
                    return this.semanticInfoChain.stringTypeSymbol;
                } else {
                    return this.semanticInfoChain.anyTypeSymbol;
                }
            } else if (this.sourceIsSubtypeOfTarget(leftType, rightType, context)) {
                return rightType;
            } else if (this.sourceIsSubtypeOfTarget(rightType, leftType, context)) {
                return leftType;
            }

            return this.semanticInfoChain.anyTypeSymbol;
        };

        PullTypeResolver.prototype.resolveLogicalAndExpression = function (binex, inContextuallyTypedAssignment, enclosingDecl, context) {
            if (context.typeCheck()) {
                this.resolveAST(binex.operand1, inContextuallyTypedAssignment, enclosingDecl, context);
            }

            return this.resolveAST(binex.operand2, inContextuallyTypedAssignment, enclosingDecl, context).type;
        };

        PullTypeResolver.prototype.resolveConditionalExpression = function (trinex, enclosingDecl, context) {
            var symbol = this.getSymbolForAST(trinex);
            if (!symbol) {
                symbol = this.computeConditionalExpressionSymbol(trinex, enclosingDecl, context);
                this.setSymbolForAST(trinex, symbol, context);
            }

            return symbol;
        };

        PullTypeResolver.prototype.computeConditionalExpressionSymbol = function (trinex, enclosingDecl, context) {
            if (context.typeCheck()) {
                this.resolveAST(trinex.operand1, false, enclosingDecl, context);
            }

            var leftType = this.resolveAST(trinex.operand2, false, enclosingDecl, context).type;
            var rightType = this.resolveAST(trinex.operand3, false, enclosingDecl, context).type;

            var symbol = null;
            if (this.typesAreIdentical(leftType, rightType)) {
                symbol = leftType;
            } else if (this.sourceIsSubtypeOfTarget(leftType, rightType, context) || this.sourceIsSubtypeOfTarget(rightType, leftType, context)) {
                var collection = {
                    getLength: function () {
                        return 2;
                    },
                    setTypeAtIndex: function (index, type) {
                    },
                    getTypeAtIndex: function (index) {
                        return rightType;
                    }
                };

                var bestCommonType = this.findBestCommonType(leftType, null, collection, context);

                if (bestCommonType) {
                    symbol = bestCommonType;
                }
            }

            if (!symbol) {
                context.postError(this.getUnitPath(), trinex.minChar, trinex.getLength(), TypeScript.DiagnosticCode.Type_of_conditional_expression_cannot_be_determined_Best_common_type_could_not_be_found_between_0_and_1, [leftType.toString(), rightType.toString()], enclosingDecl);
                return this.getNewErrorTypeSymbol(null);
            }

            return symbol;
        };

        PullTypeResolver.prototype.resolveParenthesizedExpression = function (ast, enclosingDecl, context) {
            return this.resolveAST(ast.expression, false, enclosingDecl, context);
        };

        PullTypeResolver.prototype.resolveExpressionStatement = function (ast, inContextuallyTypedAssignment, enclosingDecl, context) {
            return this.resolveAST(ast.expression, inContextuallyTypedAssignment, enclosingDecl, context);
        };

        PullTypeResolver.prototype.resolveInvocationExpression = function (callEx, inContextuallyTypedAssignment, enclosingDecl, context, additionalResults) {
            var symbol = this.getSymbolForAST(callEx);
            var callResolutionData = this.currentUnit.getCallResolutionDataForAST(callEx);

            if (!symbol || !symbol.isResolved || (additionalResults && !callResolutionData)) {
                symbol = this.computeInvocationExpressionSymbol(callEx, inContextuallyTypedAssignment, enclosingDecl, context, additionalResults);
                if (symbol != this.semanticInfoChain.anyTypeSymbol) {
                    this.setSymbolForAST(callEx, symbol, context);
                }
                this.currentUnit.setCallResolutionDataForAST(callEx, additionalResults);
            } else {
                if (additionalResults && callResolutionData && (callResolutionData != additionalResults)) {
                    additionalResults.actualParametersContextTypeSymbols = callResolutionData.actualParametersContextTypeSymbols;
                    additionalResults.candidateSignature = callResolutionData.candidateSignature;
                    additionalResults.resolvedSignatures = callResolutionData.resolvedSignatures;
                    additionalResults.targetSymbol = callResolutionData.targetSymbol;
                    additionalResults.targetTypeSymbol = callResolutionData.targetTypeSymbol;
                }
            }

            return symbol;
        };

        PullTypeResolver.prototype.computeInvocationExpressionSymbol = function (callEx, inContextuallyTypedAssignment, enclosingDecl, context, additionalResults) {
            var targetSymbol = this.resolveAST(callEx.target, inContextuallyTypedAssignment, enclosingDecl, context);

            var targetAST = this.getLastIdentifierInTarget(callEx);

            var targetTypeSymbol = targetSymbol.type;
            if (this.isAnyOrEquivalent(targetTypeSymbol)) {
                this.resolveAST(callEx.arguments, inContextuallyTypedAssignment, enclosingDecl, context);

                if (targetSymbol != this.semanticInfoChain.anyTypeSymbol && callEx.typeArguments) {
                    context.postError(this.unitPath, targetAST.minChar, targetAST.getLength(), TypeScript.DiagnosticCode.Untyped_function_calls_may_not_accept_type_arguments, null, enclosingDecl);
                    return this.getNewErrorTypeSymbol(null);
                }

                return this.semanticInfoChain.anyTypeSymbol;
            }

            var isSuperCall = false;

            if (callEx.target.nodeType() === 31 /* SuperExpression */) {
                isSuperCall = true;

                if (targetTypeSymbol.isClass()) {
                    this.seenSuperConstructorCall = true;
                    targetSymbol = targetTypeSymbol.getConstructorMethod();
                    targetTypeSymbol = targetSymbol.type;
                } else {
                    context.postError(this.unitPath, targetAST.minChar, targetAST.getLength(), TypeScript.DiagnosticCode.Calls_to_super_are_only_valid_inside_a_class, null, enclosingDecl);

                    return this.getNewErrorTypeSymbol(null);
                }
            }

            var signatures = isSuperCall ? targetTypeSymbol.getConstructSignatures() : targetTypeSymbol.getCallSignatures();

            if (!signatures.length && (targetTypeSymbol.kind == 33554432 /* ConstructorType */)) {
                context.postError(this.unitPath, targetAST.minChar, targetAST.getLength(), TypeScript.DiagnosticCode.Value_of_type_0_is_not_callable_Did_you_mean_to_include_new, [targetTypeSymbol.toString()], enclosingDecl);
            }

            var typeArgs = null;
            var typeReplacementMap = null;
            var couldNotFindGenericOverload = false;
            var couldNotAssignToConstraint;
            var constraintDiagnostic = null;
            var diagnostics = [];

            if (callEx.typeArguments) {
                typeArgs = [];

                if (callEx.typeArguments && callEx.typeArguments.members.length) {
                    for (var i = 0; i < callEx.typeArguments.members.length; i++) {
                        var typeArg = this.resolveTypeReference(callEx.typeArguments.members[i], enclosingDecl, context);
                        typeArgs[i] = context.findSpecializationForType(typeArg);
                    }
                }
            } else if (isSuperCall && targetTypeSymbol.isGeneric()) {
                typeArgs = targetTypeSymbol.getTypeArguments();
            }

            if (targetTypeSymbol.isGeneric()) {
                var resolvedSignatures = [];
                var inferredTypeArgs;
                var specializedSignature;
                var typeParameters;
                var typeConstraint = null;
                var prevSpecializingToAny = context.specializingToAny;
                var prevSpecializing = context.isSpecializingSignatureAtCallSite;
                var beforeResolutionSignatures = signatures;
                var triedToInferTypeArgs;

                for (var i = 0; i < signatures.length; i++) {
                    typeParameters = signatures[i].getTypeParameters();
                    couldNotAssignToConstraint = false;
                    triedToInferTypeArgs = false;

                    if (signatures[i].isGeneric() && typeParameters.length && !signatures[i].isFixed()) {
                        if (typeArgs) {
                            inferredTypeArgs = typeArgs;
                        } else if (callEx.arguments) {
                            inferredTypeArgs = this.inferArgumentTypesForSignature(signatures[i], callEx.arguments, new TypeComparisonInfo(), enclosingDecl, context);
                            triedToInferTypeArgs = true;
                        }

                        if (inferredTypeArgs) {
                            typeReplacementMap = {};

                            if (inferredTypeArgs.length) {
                                if (inferredTypeArgs.length != typeParameters.length) {
                                    continue;
                                }

                                for (var j = 0; j < typeParameters.length; j++) {
                                    typeReplacementMap[typeParameters[j].pullSymbolIDString] = inferredTypeArgs[j];
                                }
                                for (var j = 0; j < typeParameters.length; j++) {
                                    typeConstraint = typeParameters[j].getConstraint();

                                    if (typeConstraint) {
                                        if (typeConstraint.isTypeParameter()) {
                                            for (var k = 0; k < typeParameters.length && k < inferredTypeArgs.length; k++) {
                                                if (typeParameters[k] == typeConstraint) {
                                                    typeConstraint = inferredTypeArgs[k];
                                                }
                                            }
                                        }
                                        if (typeConstraint.isTypeParameter()) {
                                            context.pushTypeSpecializationCache(typeReplacementMap);
                                            typeConstraint = TypeScript.specializeType(typeConstraint, null, this, enclosingDecl, context);
                                            context.popTypeSpecializationCache();
                                        }
                                        context.isComparingSpecializedSignatures = true;
                                        if (!this.sourceIsAssignableToTarget(inferredTypeArgs[j], typeConstraint, context)) {
                                            constraintDiagnostic = context.postError(this.unitPath, targetAST.minChar, targetAST.getLength(), TypeScript.DiagnosticCode.Type_0_does_not_satisfy_the_constraint_1_for_type_parameter_2, [inferredTypeArgs[j].toString(null, true), typeConstraint.toString(null, true), typeParameters[j].toString(null, true)], enclosingDecl, false);
                                            couldNotAssignToConstraint = true;
                                        }
                                        context.isComparingSpecializedSignatures = false;

                                        if (couldNotAssignToConstraint) {
                                            break;
                                        }
                                    }
                                }
                            } else {
                                if (triedToInferTypeArgs) {
                                    if (signatures[i].isFixed()) {
                                        if (signatures[i].hasAGenericParameter) {
                                            context.specializingToAny = true;
                                        } else {
                                            resolvedSignatures[resolvedSignatures.length] = signatures[i];
                                        }
                                    } else {
                                        continue;
                                    }
                                }

                                context.specializingToAny = true;
                            }

                            if (couldNotAssignToConstraint) {
                                continue;
                            }

                            context.isSpecializingSignatureAtCallSite = true;
                            specializedSignature = TypeScript.specializeSignature(signatures[i], false, typeReplacementMap, inferredTypeArgs, this, enclosingDecl, context);

                            context.isSpecializingSignatureAtCallSite = prevSpecializing;
                            context.specializingToAny = prevSpecializingToAny;

                            if (specializedSignature) {
                                resolvedSignatures[resolvedSignatures.length] = specializedSignature;
                            }
                        }
                    } else {
                        if (!(callEx.typeArguments && callEx.typeArguments.members.length)) {
                            resolvedSignatures[resolvedSignatures.length] = signatures[i];
                        }
                    }
                }

                if (signatures.length && !resolvedSignatures.length) {
                    couldNotFindGenericOverload = true;
                }

                signatures = resolvedSignatures;
            }

            var errorCondition = null;

            if (!signatures.length) {
                if (additionalResults) {
                    additionalResults.targetSymbol = targetSymbol;
                    additionalResults.targetTypeSymbol = targetTypeSymbol;
                    additionalResults.resolvedSignatures = beforeResolutionSignatures;
                    additionalResults.candidateSignature = beforeResolutionSignatures && beforeResolutionSignatures.length ? beforeResolutionSignatures[0] : null;

                    additionalResults.actualParametersContextTypeSymbols = actualParametersContextTypeSymbols;
                }

                if (!couldNotFindGenericOverload) {
                    if (this.cachedFunctionInterfaceType() && this.sourceIsSubtypeOfTarget(targetTypeSymbol, this.cachedFunctionInterfaceType(), context)) {
                        return this.semanticInfoChain.anyTypeSymbol;
                    }

                    context.postError(this.unitPath, callEx.minChar, callEx.getLength(), TypeScript.DiagnosticCode.Cannot_invoke_an_expression_whose_type_lacks_a_call_signature, null, enclosingDecl);
                    errorCondition = this.getNewErrorTypeSymbol(null);
                } else {
                    context.postError(this.unitPath, callEx.minChar, callEx.getLength(), TypeScript.DiagnosticCode.Could_not_select_overload_for_call_expression, null, enclosingDecl);
                    errorCondition = this.getNewErrorTypeSymbol(null);
                }

                if (constraintDiagnostic) {
                    context.postDiagnostic(constraintDiagnostic, enclosingDecl);
                }

                return errorCondition;
            }

            var prevIsResolvingSuperConstructorTarget = context.isResolvingSuperConstructorTarget;

            if (isSuperCall) {
                context.isResolvingSuperConstructorTarget = true;
            }

            var signature = this.resolveOverloads(callEx, signatures, enclosingDecl, callEx.typeArguments != null, context, diagnostics);
            var useBeforeResolutionSignatures = signature == null;

            if (isSuperCall) {
                context.isResolvingSuperConstructorTarget = prevIsResolvingSuperConstructorTarget;
            }

            if (!signature) {
                for (var i = 0; i < diagnostics.length; i++) {
                    context.postDiagnostic(diagnostics[i], enclosingDecl);
                }

                context.postError(this.unitPath, targetAST.minChar, targetAST.getLength(), TypeScript.DiagnosticCode.Could_not_select_overload_for_call_expression, null, enclosingDecl);

                errorCondition = this.getNewErrorTypeSymbol(null);

                if (!signatures.length) {
                    return errorCondition;
                }

                signature = signatures[0];

                if (callEx.arguments) {
                    for (var k = 0, n = callEx.arguments.members.length; k < n; k++) {
                        var arg = callEx.arguments.members[k];
                        var argSymbol = this.getSymbolForAST(arg);

                        if (argSymbol) {
                            var argType = argSymbol.type;
                            if (arg.nodeType() === 13 /* FunctionDeclaration */) {
                                if (!this.canApplyContextualTypeToFunction(argType, arg, true)) {
                                    continue;
                                }
                            }

                            argSymbol.invalidate();
                        }
                    }
                }
            }

            if (!signature.isGeneric() && callEx.typeArguments) {
                context.postError(this.unitPath, targetAST.minChar, targetAST.getLength(), TypeScript.DiagnosticCode.Non_generic_functions_may_not_accept_type_arguments, null, enclosingDecl);
            }

            var returnType = isSuperCall ? this.semanticInfoChain.voidTypeSymbol : signature.returnType;

            var actualParametersContextTypeSymbols = [];
            if (callEx.arguments) {
                var len = callEx.arguments.members.length;
                var params = signature.parameters;
                var contextualType = null;
                var signatureDecl = signature.getDeclarations()[0];

                for (var i = 0; i < len; i++) {
                    if (params.length) {
                        if (i < params.length - 1 || (i < params.length && !signature.hasVarArgs)) {
                            if (typeReplacementMap) {
                                context.pushTypeSpecializationCache(typeReplacementMap);
                            }
                            this.resolveDeclaredSymbol(params[i], signatureDecl, context);
                            if (typeReplacementMap) {
                                context.popTypeSpecializationCache();
                            }
                            contextualType = params[i].type;
                        } else if (signature.hasVarArgs) {
                            contextualType = params[params.length - 1].type;
                            if (contextualType.isArray()) {
                                contextualType = contextualType.getElementType();
                            }
                        }
                    }

                    if (contextualType) {
                        context.pushContextualType(contextualType, context.inProvisionalResolution(), null);
                        actualParametersContextTypeSymbols[i] = contextualType;
                    }

                    this.resolveAST(callEx.arguments.members[i], contextualType != null, enclosingDecl, context);

                    if (contextualType) {
                        context.popContextualType();
                        contextualType = null;
                    }
                }
            }

            if (additionalResults) {
                additionalResults.targetSymbol = targetSymbol;
                additionalResults.targetTypeSymbol = targetTypeSymbol;
                if (useBeforeResolutionSignatures && beforeResolutionSignatures) {
                    additionalResults.resolvedSignatures = beforeResolutionSignatures;
                    additionalResults.candidateSignature = beforeResolutionSignatures[0];
                } else {
                    additionalResults.resolvedSignatures = signatures;
                    additionalResults.candidateSignature = signature;
                }
                additionalResults.actualParametersContextTypeSymbols = actualParametersContextTypeSymbols;
            }

            if (errorCondition) {
                return errorCondition;
            }

            if (!returnType) {
                returnType = this.semanticInfoChain.anyTypeSymbol;
            }

            return returnType;
        };

        PullTypeResolver.prototype.resolveObjectCreationExpression = function (callEx, inContextuallyTypedAssignment, enclosingDecl, context, additionalResults) {
            var symbol = this.getSymbolForAST(callEx);
            var callResolutionData = this.currentUnit.getCallResolutionDataForAST(callEx);

            if (!symbol || !symbol.isResolved || (additionalResults && !callResolutionData)) {
                symbol = this.computeObjectCreationExpressionSymbol(callEx, inContextuallyTypedAssignment, enclosingDecl, context, additionalResults);
                this.setSymbolForAST(callEx, symbol, context);
                this.currentUnit.setCallResolutionDataForAST(callEx, additionalResults);
            } else {
                if (additionalResults && callResolutionData && (callResolutionData != additionalResults)) {
                    additionalResults.actualParametersContextTypeSymbols = callResolutionData.actualParametersContextTypeSymbols;
                    additionalResults.candidateSignature = callResolutionData.candidateSignature;
                    additionalResults.resolvedSignatures = callResolutionData.resolvedSignatures;
                    additionalResults.targetSymbol = callResolutionData.targetSymbol;
                    additionalResults.targetTypeSymbol = callResolutionData.targetTypeSymbol;
                }
            }

            return symbol;
        };

        PullTypeResolver.prototype.computeObjectCreationExpressionSymbol = function (callEx, inContextuallyTypedAssignment, enclosingDecl, context, additionalResults) {
            var returnType = null;

            var targetSymbol = this.resolveAST(callEx.target, inContextuallyTypedAssignment, enclosingDecl, context);
            var targetTypeSymbol = targetSymbol.isType() ? targetSymbol : targetSymbol.type;

            var targetAST = this.getLastIdentifierInTarget(callEx);

            if (targetTypeSymbol.isClass()) {
                targetTypeSymbol = targetTypeSymbol.getConstructorMethod().type;
            }

            var constructSignatures = targetTypeSymbol.getConstructSignatures();

            var typeArgs = null;
            var typeReplacementMap = null;
            var usedCallSignaturesInstead = false;
            var couldNotAssignToConstraint;
            var constraintDiagnostic = null;
            var diagnostics = [];

            if (this.isAnyOrEquivalent(targetTypeSymbol)) {
                this.resolveAST(callEx.arguments, inContextuallyTypedAssignment, enclosingDecl, context);
                return targetTypeSymbol;
            }

            if (!constructSignatures.length) {
                constructSignatures = targetTypeSymbol.getCallSignatures();
                usedCallSignaturesInstead = true;

                if (this.compilationSettings.noImplicitAny) {
                    context.postError(this.unitPath, callEx.minChar, callEx.getLength(), TypeScript.DiagnosticCode.New_expression_which_lacks_a_constructor_signature_implicitly_has_an_any_type, [], enclosingDecl);
                }
            }

            if (constructSignatures.length) {
                if (callEx.typeArguments) {
                    typeArgs = [];

                    if (callEx.typeArguments && callEx.typeArguments.members.length) {
                        for (var i = 0; i < callEx.typeArguments.members.length; i++) {
                            var typeArg = this.resolveTypeReference(callEx.typeArguments.members[i], enclosingDecl, context);
                            typeArgs[i] = context.findSpecializationForType(typeArg);
                        }
                    }
                }

                if (targetTypeSymbol.isGeneric()) {
                    var resolvedSignatures = [];
                    var inferredTypeArgs;
                    var specializedSignature;
                    var typeParameters;
                    var typeConstraint = null;
                    var prevSpecializingToAny = context.specializingToAny;
                    var prevIsSpecializing = context.isSpecializingSignatureAtCallSite = true;
                    var triedToInferTypeArgs;

                    for (var i = 0; i < constructSignatures.length; i++) {
                        couldNotAssignToConstraint = false;

                        if (constructSignatures[i].isGeneric() && !constructSignatures[i].isFixed()) {
                            if (typeArgs) {
                                inferredTypeArgs = typeArgs;
                            } else if (callEx.arguments) {
                                inferredTypeArgs = this.inferArgumentTypesForSignature(constructSignatures[i], callEx.arguments, new TypeComparisonInfo(), enclosingDecl, context);
                                triedToInferTypeArgs = true;
                            }

                            if (inferredTypeArgs) {
                                typeParameters = constructSignatures[i].getTypeParameters();

                                typeReplacementMap = {};

                                if (inferredTypeArgs.length) {
                                    if (inferredTypeArgs.length < typeParameters.length) {
                                        continue;
                                    }

                                    for (var j = 0; j < typeParameters.length; j++) {
                                        typeReplacementMap[typeParameters[j].pullSymbolIDString] = inferredTypeArgs[j];
                                    }
                                    for (var j = 0; j < typeParameters.length; j++) {
                                        typeConstraint = typeParameters[j].getConstraint();

                                        if (typeConstraint) {
                                            if (typeConstraint.isTypeParameter()) {
                                                for (var k = 0; k < typeParameters.length && k < inferredTypeArgs.length; k++) {
                                                    if (typeParameters[k] == typeConstraint) {
                                                        typeConstraint = inferredTypeArgs[k];
                                                    }
                                                }
                                            }
                                            if (typeConstraint.isTypeParameter()) {
                                                context.pushTypeSpecializationCache(typeReplacementMap);
                                                typeConstraint = TypeScript.specializeType(typeConstraint, null, this, enclosingDecl, context);
                                                context.popTypeSpecializationCache();
                                            }

                                            context.isComparingSpecializedSignatures = true;
                                            if (!this.sourceIsAssignableToTarget(inferredTypeArgs[j], typeConstraint, context)) {
                                                constraintDiagnostic = context.postError(this.unitPath, targetAST.minChar, targetAST.getLength(), TypeScript.DiagnosticCode.Type_0_does_not_satisfy_the_constraint_1_for_type_parameter_2, [inferredTypeArgs[j].toString(null, true), typeConstraint.toString(null, true), typeParameters[j].toString(null, true)], enclosingDecl, false);
                                                couldNotAssignToConstraint = true;
                                            }
                                            context.isComparingSpecializedSignatures = false;

                                            if (couldNotAssignToConstraint) {
                                                break;
                                            }
                                        }
                                    }
                                } else {
                                    if (triedToInferTypeArgs) {
                                        if (constructSignatures[i].isFixed()) {
                                            if (!constructSignatures[i].hasAGenericParameter) {
                                                resolvedSignatures[resolvedSignatures.length] = constructSignatures[i];
                                            }
                                        } else {
                                            continue;
                                        }
                                    } else {
                                        context.specializingToAny = true;
                                    }
                                }

                                if (couldNotAssignToConstraint) {
                                    continue;
                                }

                                context.isSpecializingSignatureAtCallSite = true;
                                specializedSignature = TypeScript.specializeSignature(constructSignatures[i], false, typeReplacementMap, inferredTypeArgs, this, enclosingDecl, context);

                                context.specializingToAny = prevSpecializingToAny;
                                context.isSpecializingSignatureAtCallSite = prevIsSpecializing;

                                if (specializedSignature) {
                                    resolvedSignatures[resolvedSignatures.length] = specializedSignature;
                                }
                            }
                        } else {
                            if (!(callEx.typeArguments && callEx.typeArguments.members.length)) {
                                resolvedSignatures[resolvedSignatures.length] = constructSignatures[i];
                            }
                        }
                    }

                    constructSignatures = resolvedSignatures;
                }

                var signature = this.resolveOverloads(callEx, constructSignatures, enclosingDecl, callEx.typeArguments != null, context, diagnostics);

                if (additionalResults) {
                    additionalResults.targetSymbol = targetSymbol;
                    additionalResults.targetTypeSymbol = targetTypeSymbol;
                    additionalResults.resolvedSignatures = constructSignatures;
                    additionalResults.candidateSignature = signature;
                    additionalResults.actualParametersContextTypeSymbols = [];
                }

                if (!constructSignatures.length) {
                    if (constraintDiagnostic) {
                        context.postDiagnostic(constraintDiagnostic, enclosingDecl);
                    }

                    return this.getNewErrorTypeSymbol(null);
                }

                var errorCondition = null;

                if (!signature) {
                    for (var i = 0; i < diagnostics.length; i++) {
                        context.postDiagnostic(diagnostics[i], enclosingDecl);
                    }

                    context.postError(this.unitPath, targetAST.minChar, targetAST.getLength(), TypeScript.DiagnosticCode.Could_not_select_overload_for_new_expression, null, enclosingDecl);

                    errorCondition = this.getNewErrorTypeSymbol(null);

                    if (!constructSignatures.length) {
                        return errorCondition;
                    }

                    signature = constructSignatures[0];

                    if (callEx.arguments) {
                        for (var k = 0, n = callEx.arguments.members.length; k < n; k++) {
                            var arg = callEx.arguments.members[k];
                            var argSymbol = this.getSymbolForAST(arg);

                            if (argSymbol) {
                                var argType = argSymbol.type;
                                if (arg.nodeType() === 13 /* FunctionDeclaration */) {
                                    if (!this.canApplyContextualTypeToFunction(argType, arg, true)) {
                                        continue;
                                    }
                                }

                                argSymbol.invalidate();
                            }
                        }
                    }
                }

                returnType = signature.returnType;

                if (returnType && !signature.isGeneric() && returnType.isGeneric() && !returnType.getIsSpecialized()) {
                    if (typeArgs && typeArgs.length) {
                        returnType = TypeScript.specializeType(returnType, typeArgs, this, enclosingDecl, context, callEx);
                    } else {
                        returnType = this.specializeTypeToAny(returnType, enclosingDecl, context);
                    }
                }

                if (usedCallSignaturesInstead) {
                    if (returnType != this.semanticInfoChain.voidTypeSymbol) {
                        context.postError(this.unitPath, targetAST.minChar, targetAST.getLength(), TypeScript.DiagnosticCode.Call_signatures_used_in_a_new_expression_must_have_a_void_return_type, null, enclosingDecl);

                        return this.getNewErrorTypeSymbol(null);
                    } else {
                        returnType = this.semanticInfoChain.anyTypeSymbol;
                    }
                }

                if (!returnType) {
                    returnType = signature.returnType;

                    if (!returnType) {
                        returnType = targetTypeSymbol;
                    }
                }

                var actualParametersContextTypeSymbols = [];
                if (callEx.arguments) {
                    var len = callEx.arguments.members.length;
                    var params = signature.parameters;
                    var contextualType = null;
                    var signatureDecl = signature.getDeclarations()[0];

                    for (var i = 0; i < len; i++) {
                        if (params.length) {
                            if (i < params.length - 1 || (i < params.length && !signature.hasVarArgs)) {
                                if (typeReplacementMap) {
                                    context.pushTypeSpecializationCache(typeReplacementMap);
                                }
                                this.resolveDeclaredSymbol(params[i], signatureDecl, context);
                                if (typeReplacementMap) {
                                    context.popTypeSpecializationCache();
                                }
                                contextualType = params[i].type;
                            } else if (signature.hasVarArgs) {
                                contextualType = params[params.length - 1].type;
                                if (contextualType.isArray()) {
                                    contextualType = contextualType.getElementType();
                                }
                            }
                        }

                        if (contextualType) {
                            context.pushContextualType(contextualType, context.inProvisionalResolution(), null);
                            actualParametersContextTypeSymbols[i] = contextualType;
                        }

                        this.resolveAST(callEx.arguments.members[i], contextualType != null, enclosingDecl, context);

                        if (contextualType) {
                            context.popContextualType();
                            contextualType = null;
                        }
                    }
                }

                if (additionalResults) {
                    additionalResults.targetSymbol = targetSymbol;
                    additionalResults.targetTypeSymbol = targetTypeSymbol;
                    additionalResults.resolvedSignatures = constructSignatures;
                    additionalResults.candidateSignature = signature;
                    additionalResults.actualParametersContextTypeSymbols = actualParametersContextTypeSymbols;
                }

                if (errorCondition) {
                    return errorCondition;
                }

                if (!returnType) {
                    returnType = this.semanticInfoChain.anyTypeSymbol;
                }

                return returnType;
            } else if (targetTypeSymbol.isClass()) {
                return returnType;
            }

            context.postError(this.unitPath, targetAST.minChar, targetAST.getLength(), TypeScript.DiagnosticCode.Invalid_new_expression, null, enclosingDecl);

            return this.getNewErrorTypeSymbol(null);
        };

        PullTypeResolver.prototype.resolveTypeAssertionExpression = function (assertionExpression, inContextuallyTypedAssignment, enclosingDecl, context) {
            var returnType = this.resolveAST(assertionExpression.castTerm, false, enclosingDecl, context).type;
            this.setSymbolForAST(assertionExpression, returnType, context);

            if (context.typeCheck()) {
                if (returnType.isError()) {
                    var symbolName = (returnType).getData();
                    context.postError(this.unitPath, assertionExpression.minChar, assertionExpression.getLength(), TypeScript.DiagnosticCode.Could_not_find_symbol_0, [symbolName], enclosingDecl);
                }

                context.pushContextualType(returnType, context.inProvisionalResolution(), null);
                var exprType = this.resolveAST(assertionExpression.operand, true, enclosingDecl, context).type;
                context.popContextualType();

                if (!exprType.isResolved) {
                    this.resolveDeclaredSymbol(exprType, enclosingDecl, context);
                }

                var comparisonInfo = new TypeComparisonInfo();

                var isAssignable = this.sourceIsAssignableToTarget(returnType, exprType, context, comparisonInfo) || this.sourceIsAssignableToTarget(exprType, returnType, context, comparisonInfo);

                if (!isAssignable) {
                    var message;
                    if (comparisonInfo.message) {
                        context.postError(this.unitPath, assertionExpression.minChar, assertionExpression.getLength(), TypeScript.DiagnosticCode.Cannot_convert_0_to_1_NL_2, [exprType.toString(), returnType.toString(), comparisonInfo.message], enclosingDecl);
                    } else {
                        context.postError(this.unitPath, assertionExpression.minChar, assertionExpression.getLength(), TypeScript.DiagnosticCode.Cannot_convert_0_to_1, [exprType.toString(), returnType.toString()], enclosingDecl);
                    }
                }
            }

            return returnType;
        };

        PullTypeResolver.prototype.resolveAssignmentStatement = function (binaryExpression, inContextuallyTypedAssignment, enclosingDecl, context) {
            var leftExpr = this.resolveAST(binaryExpression.operand1, false, enclosingDecl, context);
            var leftType = leftExpr.type;

            leftType = this.widenType(leftExpr.type);

            context.pushContextualType(leftType, context.inProvisionalResolution(), null);
            var rightType = this.widenType(this.resolveAST(binaryExpression.operand2, true, enclosingDecl, context).type);
            context.popContextualType();

            rightType = this.getInstanceTypeForAssignment(binaryExpression.operand1, rightType, enclosingDecl, context);

            if (context.typeCheck()) {
                if (!this.isValidLHS(binaryExpression.operand1, leftExpr)) {
                    context.postError(this.unitPath, binaryExpression.operand1.minChar, binaryExpression.operand1.getLength(), TypeScript.DiagnosticCode.Invalid_left_hand_side_of_assignment_expression, null, enclosingDecl);
                }

                this.checkAssignability(binaryExpression.operand1, rightType, leftType, enclosingDecl, context);
            }
            return rightType;
        };

        PullTypeResolver.prototype.computeAssignmentStatementSymbol = function (binex, inContextuallyTypedAssignment, enclosingDecl, context) {
            var leftType = this.resolveAST(binex.operand1, inContextuallyTypedAssignment, enclosingDecl, context).type;

            context.pushContextualType(leftType, context.inProvisionalResolution(), null);
            this.resolveAST(binex.operand2, true, enclosingDecl, context);
            context.popContextualType();

            return leftType;
        };

        PullTypeResolver.prototype.getInstanceTypeForAssignment = function (lhs, type, enclosingDecl, context) {
            var typeToReturn = type;
            if (typeToReturn && typeToReturn.isAlias()) {
                typeToReturn = (typeToReturn).getExportAssignedTypeSymbol();
            }

            if (typeToReturn && typeToReturn.isContainer()) {
                var instanceTypeSymbol = (typeToReturn).getInstanceType();

                if (!instanceTypeSymbol) {
                    context.postError(this.unitPath, lhs.minChar, lhs.getLength(), TypeScript.DiagnosticCode.Tried_to_set_variable_type_to_uninitialized_module_type_0, [type.toString()], enclosingDecl);
                    typeToReturn = null;
                } else {
                    typeToReturn = instanceTypeSymbol;
                }
            }

            return typeToReturn;
        };

        PullTypeResolver.prototype.resolveBoundDecls = function (decl, context) {
            if (!decl) {
                return;
            }

            switch (decl.kind) {
                case 1 /* Script */:
                    var childDecls = decl.getChildDecls();
                    for (var i = 0; i < childDecls.length; i++) {
                        this.resolveBoundDecls(childDecls[i], context);
                    }
                    break;
                case 32 /* DynamicModule */:
                case 4 /* Container */:
                case 64 /* Enum */:
                    var moduleDecl = this.semanticInfoChain.getASTForDecl(decl);
                    this.resolveModuleDeclaration(moduleDecl, context);
                    break;
                case 16 /* Interface */:
                    var interfaceDecl = this.semanticInfoChain.getASTForDecl(decl);
                    this.resolveInterfaceDeclaration(interfaceDecl, context);
                    break;
                case 8 /* Class */:
                    var classDecl = this.semanticInfoChain.getASTForDecl(decl);
                    this.resolveClassDeclaration(classDecl, context);
                    break;
                case 65536 /* Method */:
                case 16384 /* Function */:
                    var funcDecl = this.semanticInfoChain.getASTForDecl(decl);
                    this.resolveFunctionDeclaration(funcDecl, context);
                    break;
                case 262144 /* GetAccessor */:
                    funcDecl = this.semanticInfoChain.getASTForDecl(decl);
                    this.resolveGetAccessorDeclaration(funcDecl, context);
                    break;
                case 524288 /* SetAccessor */:
                    funcDecl = this.semanticInfoChain.getASTForDecl(decl);
                    this.resolveSetAccessorDeclaration(funcDecl, context);
                    break;
                case 4096 /* Property */:
                case 1024 /* Variable */:
                case 2048 /* Parameter */:
                    var varDecl = this.semanticInfoChain.getASTForDecl(decl);

                    if (varDecl) {
                        this.resolveVariableDeclaration(varDecl, context);
                    }
                    break;
            }
        };

        PullTypeResolver.prototype.mergeOrdered = function (a, b, context, comparisonInfo) {
            if (this.isAnyOrEquivalent(a) || this.isAnyOrEquivalent(b)) {
                return this.semanticInfoChain.anyTypeSymbol;
            } else if (a === b) {
                return a;
            } else if ((b === this.semanticInfoChain.nullTypeSymbol) && a != this.semanticInfoChain.nullTypeSymbol) {
                return a;
            } else if ((a === this.semanticInfoChain.nullTypeSymbol) && (b != this.semanticInfoChain.nullTypeSymbol)) {
                return b;
            } else if ((a === this.semanticInfoChain.voidTypeSymbol) && (b === this.semanticInfoChain.voidTypeSymbol || b === this.semanticInfoChain.undefinedTypeSymbol || b === this.semanticInfoChain.nullTypeSymbol)) {
                return a;
            } else if ((a === this.semanticInfoChain.voidTypeSymbol) && (b === this.semanticInfoChain.anyTypeSymbol)) {
                return b;
            } else if ((b === this.semanticInfoChain.undefinedTypeSymbol) && a != this.semanticInfoChain.voidTypeSymbol) {
                return a;
            } else if ((a === this.semanticInfoChain.undefinedTypeSymbol) && (b != this.semanticInfoChain.undefinedTypeSymbol)) {
                return b;
            } else if (a.isTypeParameter() && !b.isTypeParameter()) {
                return b;
            } else if (!a.isTypeParameter() && b.isTypeParameter()) {
                return a;
            } else if (a.isArray() && b.isArray()) {
                if (a.getElementType() === b.getElementType()) {
                    return a;
                } else {
                    var mergedET = this.mergeOrdered(a.getElementType(), b.getElementType(), context, comparisonInfo);
                    if (mergedET) {
                        var mergedArrayType = mergedET.getArrayType();

                        if (!mergedArrayType) {
                            mergedArrayType = TypeScript.specializeType(this.cachedArrayInterfaceType(), [mergedET], this, this.cachedArrayInterfaceType().getDeclarations()[0], context);
                        }

                        return mergedArrayType;
                    }
                }
            } else if (this.sourceIsSubtypeOfTarget(a, b, context, comparisonInfo)) {
                return b;
            } else if (this.sourceIsSubtypeOfTarget(b, a, context, comparisonInfo)) {
                return a;
            }

            return null;
        };

        PullTypeResolver.prototype.widenType = function (type) {
            if (type === this.semanticInfoChain.undefinedTypeSymbol || type === this.semanticInfoChain.nullTypeSymbol || type.isError()) {
                return this.semanticInfoChain.anyTypeSymbol;
            }

            return type;
        };

        PullTypeResolver.prototype.isNullOrUndefinedType = function (type) {
            return type === this.semanticInfoChain.nullTypeSymbol || type === this.semanticInfoChain.undefinedTypeSymbol;
        };

        PullTypeResolver.prototype.canApplyContextualType = function (type) {
            if (!type) {
                return true;
            }

            var kind = type.kind;

            if ((kind & 8388608 /* ObjectType */) != 0) {
                return true;
            }
            if ((kind & 16 /* Interface */) != 0) {
                return true;
            } else if ((kind & TypeScript.PullElementKind.SomeFunction) != 0) {
                return this.canApplyContextualTypeToFunction(type, this.semanticInfoChain.getASTForDecl(type.getDeclarations[0]), true);
            } else if ((kind & 128 /* Array */) != 0) {
                return true;
            } else if (type == this.semanticInfoChain.anyTypeSymbol || kind != 2 /* Primitive */) {
                return true;
            }

            return false;
        };

        PullTypeResolver.prototype.findBestCommonType = function (initialType, targetType, collection, context, comparisonInfo) {
            var len = collection.getLength();
            var nlastChecked = 0;
            var bestCommonType = initialType;

            if (targetType && this.canApplyContextualType(bestCommonType)) {
                if (bestCommonType) {
                    bestCommonType = this.mergeOrdered(bestCommonType, targetType, context);
                } else {
                    bestCommonType = targetType;
                }
            }

            var convergenceType = bestCommonType;

            while (nlastChecked < len) {
                for (var i = 0; i < len; i++) {
                    if (i === nlastChecked) {
                        continue;
                    }

                    if (convergenceType && (bestCommonType = this.mergeOrdered(convergenceType, collection.getTypeAtIndex(i), context, comparisonInfo))) {
                        convergenceType = bestCommonType;
                    }

                    if (bestCommonType === null || this.isAnyOrEquivalent(bestCommonType)) {
                        break;
                    } else if (targetType && !(bestCommonType.isTypeParameter() || targetType.isTypeParameter())) {
                        collection.setTypeAtIndex(i, targetType);
                    }
                }

                if (convergenceType && bestCommonType) {
                    break;
                }

                nlastChecked++;
                if (nlastChecked < len) {
                    convergenceType = collection.getTypeAtIndex(nlastChecked);
                }
            }

            if (!bestCommonType) {
                var emptyTypeDecl = new TypeScript.PullDecl("{}", "{}", 8388608 /* ObjectType */, 0 /* None */, new TypeScript.TextSpan(0, 0), this.currentUnit.getPath());
                var emptyType = new TypeScript.PullTypeSymbol("{}", 8388608 /* ObjectType */);

                emptyTypeDecl.setSymbol(emptyType);
                emptyType.addDeclaration(emptyTypeDecl);

                bestCommonType = emptyType;
            }

            return bestCommonType;
        };

        PullTypeResolver.prototype.typesAreIdentical = function (t1, t2, val) {
            if (t1 === t2) {
                return true;
            }

            if (!t1 || !t2) {
                return false;
            }

            if (val && t1.isPrimitive() && (t1).isStringConstant() && t2 === this.semanticInfoChain.stringTypeSymbol) {
                return (val.nodeType() === 5 /* StringLiteral */) && (TypeScript.stripQuotes((val).actualText) === TypeScript.stripQuotes(t1.name));
            }

            if (val && t2.isPrimitive() && (t2).isStringConstant() && t2 === this.semanticInfoChain.stringTypeSymbol) {
                return (val.nodeType() === 5 /* StringLiteral */) && (TypeScript.stripQuotes((val).actualText) === TypeScript.stripQuotes(t2.name));
            }

            if (t1.isPrimitive() && (t1).isStringConstant() && t2.isPrimitive() && (t2).isStringConstant()) {
                return TypeScript.stripQuotes(t1.name) === TypeScript.stripQuotes(t2.name);
            }

            if (t1.isPrimitive() || t2.isPrimitive()) {
                return false;
            }

            if (t1.isClass()) {
                return false;
            }

            if (t1.isError() && t2.isError()) {
                return true;
            }

            if (t1.isTypeParameter()) {
                if (!t2.isTypeParameter()) {
                    return false;
                }

                var t1ParentDeclaration = t1.getDeclarations()[0].getParentDecl();
                var t2ParentDeclaration = t2.getDeclarations()[0].getParentDecl();

                if (t1ParentDeclaration === t2ParentDeclaration) {
                    return this.symbolsShareDeclaration(t1, t2);
                } else {
                    return true;
                }
            }

            var comboId = t2.pullSymbolIDString + "#" + t1.pullSymbolIDString;

            if (this.identicalCache[comboId] != undefined) {
                return true;
            }

            if ((t1.kind & 64 /* Enum */) || (t2.kind & 64 /* Enum */)) {
                return t1.getAssociatedContainerType() === t2 || t2.getAssociatedContainerType() === t1;
            }

            if (t1.isArray() || t2.isArray()) {
                if (!(t1.isArray() && t2.isArray())) {
                    return false;
                }
                this.identicalCache[comboId] = false;
                var ret = this.typesAreIdentical(t1.getElementType(), t2.getElementType());
                if (ret) {
                    this.identicalCache[comboId] = true;
                } else {
                    this.identicalCache[comboId] = undefined;
                }

                return ret;
            }

            if (t1.isPrimitive() != t2.isPrimitive()) {
                return false;
            }

            this.identicalCache[comboId] = false;

            if (t1.hasMembers() && t2.hasMembers()) {
                var t1Members = t1.getMembers();
                var t2Members = t2.getMembers();

                if (t1Members.length != t2Members.length) {
                    this.identicalCache[comboId] = undefined;
                    return false;
                }

                var t1MemberSymbol = null;
                var t2MemberSymbol = null;

                var t1MemberType = null;
                var t2MemberType = null;

                for (var iMember = 0; iMember < t1Members.length; iMember++) {
                    t1MemberSymbol = t1Members[iMember];
                    t2MemberSymbol = this.getMemberSymbol(t1MemberSymbol.name, TypeScript.PullElementKind.SomeValue, t2);

                    if (!t2MemberSymbol || (t1MemberSymbol.isOptional != t2MemberSymbol.isOptional)) {
                        this.identicalCache[comboId] = undefined;
                        return false;
                    }

                    t1MemberType = t1MemberSymbol.type;
                    t2MemberType = t2MemberSymbol.type;

                    if (t1MemberType && t2MemberType && (this.identicalCache[t2MemberType.pullSymbolIDString + "#" + t1MemberType.pullSymbolIDString] != undefined)) {
                        continue;
                    }

                    if (!this.typesAreIdentical(t1MemberType, t2MemberType)) {
                        this.identicalCache[comboId] = undefined;
                        return false;
                    }
                }
            } else if (t1.hasMembers() || t2.hasMembers()) {
                this.identicalCache[comboId] = undefined;
                return false;
            }

            var t1CallSigs = t1.getCallSignatures();
            var t2CallSigs = t2.getCallSignatures();

            var t1ConstructSigs = t1.getConstructSignatures();
            var t2ConstructSigs = t2.getConstructSignatures();

            var t1IndexSigs = t1.getIndexSignatures();
            var t2IndexSigs = t2.getIndexSignatures();

            if (!this.signatureGroupsAreIdentical(t1CallSigs, t2CallSigs)) {
                this.identicalCache[comboId] = undefined;
                return false;
            }

            if (!this.signatureGroupsAreIdentical(t1ConstructSigs, t2ConstructSigs)) {
                this.identicalCache[comboId] = undefined;
                return false;
            }

            if (!this.signatureGroupsAreIdentical(t1IndexSigs, t2IndexSigs)) {
                this.identicalCache[comboId] = undefined;
                return false;
            }

            this.identicalCache[comboId] = true;
            return true;
        };

        PullTypeResolver.prototype.signatureGroupsAreIdentical = function (sg1, sg2) {
            if (sg1 === sg2) {
                return true;
            }

            if (!sg1 || !sg2) {
                return false;
            }

            if (sg1.length != sg2.length) {
                return false;
            }

            var sig1 = null;
            var sig2 = null;
            var sigsMatch = false;

            for (var iSig1 = 0; iSig1 < sg1.length; iSig1++) {
                sig1 = sg1[iSig1];

                for (var iSig2 = 0; iSig2 < sg2.length; iSig2++) {
                    sig2 = sg2[iSig2];

                    if (this.signaturesAreIdentical(sig1, sig2)) {
                        sigsMatch = true;
                        break;
                    }
                }

                if (sigsMatch) {
                    sigsMatch = false;
                    continue;
                }

                return false;
            }

            return true;
        };

        PullTypeResolver.prototype.signaturesAreIdentical = function (s1, s2, includingReturnType) {
            if (typeof includingReturnType === "undefined") { includingReturnType = true; }
            if (s1.hasVarArgs != s2.hasVarArgs) {
                return false;
            }

            if (s1.nonOptionalParamCount != s2.nonOptionalParamCount) {
                return false;
            }

            if (s1.typeParameters && s2.typeParameters && (s1.typeParameters.length != s2.typeParameters.length)) {
                return false;
            }

            var s1Params = s1.parameters;
            var s2Params = s2.parameters;

            if (s1Params.length != s2Params.length) {
                return false;
            }

            if (includingReturnType && !this.typesAreIdentical(s1.returnType, s2.returnType)) {
                return false;
            }

            for (var iParam = 0; iParam < s1Params.length; iParam++) {
                if (!this.typesAreIdentical(s1Params[iParam].type, s2Params[iParam].type)) {
                    return false;
                }
            }

            return true;
        };

        PullTypeResolver.prototype.substituteUpperBoundForType = function (type) {
            if (!type || !type.isTypeParameter()) {
                return type;
            }

            var constraint = (type).getConstraint();

            if (constraint) {
                return this.substituteUpperBoundForType(constraint);
            }

            if (this.cachedObjectInterfaceType()) {
                return this.cachedObjectInterfaceType();
            }

            return type;
        };

        PullTypeResolver.prototype.symbolsShareDeclaration = function (symbol1, symbol2) {
            var decls1 = symbol1.getDeclarations();
            var decls2 = symbol2.getDeclarations();

            if (decls1.length && decls2.length) {
                return decls1[0].isEqual(decls2[0]);
            }

            return false;
        };

        PullTypeResolver.prototype.sourceExtendsTarget = function (source, target, context) {
            if (source.isGeneric() != target.isGeneric()) {
                return false;
            }

            if (source.hasBase(target)) {
                return true;
            }

            if (context.isInBaseTypeResolution() && (source.kind & (16 /* Interface */ | 8 /* Class */)) && (target.kind & (16 /* Interface */ | 8 /* Class */))) {
                var sourceDecls = source.getDeclarations();
                var sourceAST = null;
                var extendsSymbol = null;
                var extendsList = null;

                for (var i = 0; i < sourceDecls.length; i++) {
                    sourceAST = this.semanticInfoChain.getASTForDecl(sourceDecls[i]);
                    extendsList = sourceAST.extendsList;

                    if (extendsList && extendsList.members && extendsList.members.length) {
                        for (var j = 0; j < extendsList.members.length; j++) {
                            extendsSymbol = this.semanticInfoChain.getSymbolForAST(extendsList.members[j], sourceDecls[i].getScriptName());

                            if (extendsSymbol == target || this.sourceExtendsTarget(extendsSymbol, target, context)) {
                                return true;
                            }
                        }
                    }
                }

                return false;
            }
        };

        PullTypeResolver.prototype.sourceIsSubtypeOfTarget = function (source, target, context, comparisonInfo) {
            return this.sourceIsRelatableToTarget(source, target, false, this.subtypeCache, context, comparisonInfo);
        };

        PullTypeResolver.prototype.sourceMembersAreSubtypeOfTargetMembers = function (source, target, context, comparisonInfo) {
            return this.sourceMembersAreRelatableToTargetMembers(source, target, false, this.subtypeCache, context, comparisonInfo);
        };

        PullTypeResolver.prototype.sourcePropertyIsSubtypeOfTargetProperty = function (source, target, sourceProp, targetProp, context, comparisonInfo) {
            return this.sourcePropertyIsRelatableToTargetProperty(source, target, sourceProp, targetProp, false, this.subtypeCache, context, comparisonInfo);
        };

        PullTypeResolver.prototype.sourceCallSignaturesAreSubtypeOfTargetCallSignatures = function (source, target, context, comparisonInfo) {
            return this.sourceCallSignaturesAreRelatableToTargetCallSignatures(source, target, false, this.subtypeCache, context, comparisonInfo);
        };

        PullTypeResolver.prototype.sourceConstructSignaturesAreSubtypeOfTargetConstructSignatures = function (source, target, context, comparisonInfo) {
            return this.sourceConstructSignaturesAreRelatableToTargetConstructSignatures(source, target, false, this.subtypeCache, context, comparisonInfo);
        };

        PullTypeResolver.prototype.sourceIndexSignaturesAreSubtypeOfTargetIndexSignatures = function (source, target, context, comparisonInfo) {
            return this.sourceIndexSignaturesAreRelatableToTargetIndexSignatures(source, target, false, this.subtypeCache, context, comparisonInfo);
        };

        PullTypeResolver.prototype.typeIsSubtypeOfFunction = function (source, context) {
            var callSignatures = source.getCallSignatures();

            if (callSignatures.length) {
                return true;
            }

            var constructSignatures = source.getConstructSignatures();

            if (constructSignatures.length) {
                return true;
            }

            if (this.cachedFunctionInterfaceType()) {
                return this.sourceIsSubtypeOfTarget(source, this.cachedFunctionInterfaceType(), context);
            }

            return false;
        };

        PullTypeResolver.prototype.signatureGroupIsSubtypeOfTarget = function (sg1, sg2, context, comparisonInfo) {
            return this.signatureGroupIsRelatableToTarget(sg1, sg2, false, this.subtypeCache, context, comparisonInfo);
        };

        PullTypeResolver.prototype.signatureIsSubtypeOfTarget = function (s1, s2, context, comparisonInfo) {
            return this.signatureIsRelatableToTarget(s1, s2, false, this.subtypeCache, context, comparisonInfo);
        };

        PullTypeResolver.prototype.sourceIsAssignableToTarget = function (source, target, context, comparisonInfo, isInProvisionalResolution) {
            if (typeof isInProvisionalResolution === "undefined") { isInProvisionalResolution = false; }
            var cache = isInProvisionalResolution ? {} : this.assignableCache;
            return this.sourceIsRelatableToTarget(source, target, true, cache, context, comparisonInfo);
        };

        PullTypeResolver.prototype.signatureGroupIsAssignableToTarget = function (sg1, sg2, context, comparisonInfo) {
            return this.signatureGroupIsRelatableToTarget(sg1, sg2, true, this.assignableCache, context, comparisonInfo);
        };

        PullTypeResolver.prototype.signatureIsAssignableToTarget = function (s1, s2, context, comparisonInfo) {
            return this.signatureIsRelatableToTarget(s1, s2, true, this.assignableCache, context, comparisonInfo);
        };

        PullTypeResolver.prototype.sourceIsRelatableToTarget = function (source, target, assignableTo, comparisonCache, context, comparisonInfo) {
            if (source === target) {
                return true;
            }

            if (!(source && target)) {
                return true;
            }

            if (context.specializingToAny && (target.isTypeParameter() || source.isTypeParameter())) {
                return true;
            }

            if (context.specializingToObject) {
                if (target.isTypeParameter()) {
                    target = this.cachedObjectInterfaceType();
                }
                if (source.isTypeParameter()) {
                    target = this.cachedObjectInterfaceType();
                }
            }

            var sourceSubstitution = source;

            if (source == this.semanticInfoChain.stringTypeSymbol && this.cachedStringInterfaceType()) {
                if (!this.cachedStringInterfaceType().isResolved) {
                    this.resolveDeclaredSymbol(this.cachedStringInterfaceType(), null, context);
                }
                sourceSubstitution = this.cachedStringInterfaceType();
            } else if (source == this.semanticInfoChain.numberTypeSymbol && this.cachedNumberInterfaceType()) {
                if (!this.cachedNumberInterfaceType().isResolved) {
                    this.resolveDeclaredSymbol(this.cachedNumberInterfaceType(), null, context);
                }
                sourceSubstitution = this.cachedNumberInterfaceType();
            } else if (source == this.semanticInfoChain.booleanTypeSymbol && this.cachedBooleanInterfaceType()) {
                if (!this.cachedBooleanInterfaceType().isResolved) {
                    this.resolveDeclaredSymbol(this.cachedBooleanInterfaceType(), null, context);
                }
                sourceSubstitution = this.cachedBooleanInterfaceType();
            } else if (TypeScript.PullHelpers.symbolIsEnum(source) && this.cachedNumberInterfaceType()) {
                sourceSubstitution = this.cachedNumberInterfaceType();
            } else if (source.isTypeParameter()) {
                sourceSubstitution = this.substituteUpperBoundForType(source);
            }

            var comboId = source.pullSymbolIDString + "#" + target.pullSymbolIDString;

            if (comparisonCache[comboId] != undefined) {
                return true;
            }

            if (assignableTo) {
                if (this.isAnyOrEquivalent(source) || this.isAnyOrEquivalent(target)) {
                    return true;
                }

                if (source === this.semanticInfoChain.stringTypeSymbol && target.isPrimitive() && (target).isStringConstant()) {
                    return comparisonInfo && comparisonInfo.stringConstantVal && (comparisonInfo.stringConstantVal.nodeType() === 5 /* StringLiteral */) && (TypeScript.stripQuotes((comparisonInfo.stringConstantVal).actualText) === TypeScript.stripQuotes(target.name));
                }
            } else {
                if (this.isAnyOrEquivalent(target)) {
                    return true;
                }

                if (target === this.semanticInfoChain.stringTypeSymbol && source.isPrimitive() && (source).isStringConstant()) {
                    return true;
                }
            }

            if (source.isPrimitive() && (source).isStringConstant() && target.isPrimitive() && (target).isStringConstant()) {
                return TypeScript.stripQuotes(source.name) === TypeScript.stripQuotes(target.name);
            }

            if (source === this.semanticInfoChain.undefinedTypeSymbol) {
                return true;
            }

            if ((source === this.semanticInfoChain.nullTypeSymbol) && (target != this.semanticInfoChain.undefinedTypeSymbol && target != this.semanticInfoChain.voidTypeSymbol)) {
                return true;
            }

            if (target == this.semanticInfoChain.voidTypeSymbol) {
                if (source == this.semanticInfoChain.anyTypeSymbol || source == this.semanticInfoChain.undefinedTypeSymbol || source == this.semanticInfoChain.nullTypeSymbol) {
                    return true;
                }

                return false;
            } else if (source == this.semanticInfoChain.voidTypeSymbol) {
                if (target == this.semanticInfoChain.anyTypeSymbol) {
                    return true;
                }

                return false;
            }

            if (target === this.semanticInfoChain.numberTypeSymbol && TypeScript.PullHelpers.symbolIsEnum(source)) {
                return true;
            }

            if (source === this.semanticInfoChain.numberTypeSymbol && TypeScript.PullHelpers.symbolIsEnum(target)) {
                return true;
            }

            if (TypeScript.PullHelpers.symbolIsEnum(target) && TypeScript.PullHelpers.symbolIsEnum(source)) {
                return this.symbolsShareDeclaration(target, source);
            }

            if ((source.kind & 64 /* Enum */) || (target.kind & 64 /* Enum */)) {
                return false;
            }

            if (source.isArray() && target.isArray()) {
                comparisonCache[comboId] = false;
                var ret = this.sourceIsRelatableToTarget(source.getElementType(), target.getElementType(), assignableTo, comparisonCache, context, comparisonInfo);
                if (ret) {
                    comparisonCache[comboId] = true;
                } else {
                    comparisonCache[comboId] = undefined;
                }

                return ret;
            } else if (source.isArray() && target == this.cachedArrayInterfaceType()) {
                return true;
            } else if (target.isArray() && source == this.cachedArrayInterfaceType()) {
                return true;
            }

            if (source.isPrimitive() && target.isPrimitive()) {
                return false;
            } else if (source.isPrimitive() != target.isPrimitive()) {
                if (target.isPrimitive()) {
                    return false;
                }
            }

            if (target.isTypeParameter()) {
                if (source.isTypeParameter() && (source == sourceSubstitution)) {
                    var targetParentDeclaration = target.getDeclarations()[0].getParentDecl();
                    var sourceParentDeclaration = source.getDeclarations()[0].getParentDecl();

                    if (targetParentDeclaration !== sourceParentDeclaration) {
                        return this.symbolsShareDeclaration(target, source);
                    } else {
                        return true;
                    }
                } else {
                    if (context.isComparingSpecializedSignatures) {
                        target = this.substituteUpperBoundForType(target);
                    } else {
                        return false;
                    }
                }
            }

            comparisonCache[comboId] = false;

            if (this.sourceExtendsTarget(source, target, context)) {
                return true;
            }

            if (this.cachedObjectInterfaceType() && target === this.cachedObjectInterfaceType()) {
                return true;
            }

            if (this.cachedFunctionInterfaceType() && (sourceSubstitution.getCallSignatures().length || sourceSubstitution.getConstructSignatures().length) && target === this.cachedFunctionInterfaceType()) {
                return true;
            }

            if (target.hasMembers() && !this.sourceMembersAreRelatableToTargetMembers(sourceSubstitution, target, assignableTo, comparisonCache, context, comparisonInfo)) {
                comparisonCache[comboId] = undefined;
                return false;
            }

            if (!this.sourceCallSignaturesAreRelatableToTargetCallSignatures(sourceSubstitution, target, assignableTo, comparisonCache, context, comparisonInfo)) {
                comparisonCache[comboId] = undefined;
                return false;
            }

            if (!this.sourceConstructSignaturesAreRelatableToTargetConstructSignatures(sourceSubstitution, target, assignableTo, comparisonCache, context, comparisonInfo)) {
                comparisonCache[comboId] = undefined;
                return false;
            }

            if (!this.sourceIndexSignaturesAreRelatableToTargetIndexSignatures(sourceSubstitution, target, assignableTo, comparisonCache, context, comparisonInfo)) {
                comparisonCache[comboId] = undefined;
                return false;
            }

            comparisonCache[comboId] = true;
            return true;
        };

        PullTypeResolver.prototype.sourceMembersAreRelatableToTargetMembers = function (source, target, assignableTo, comparisonCache, context, comparisonInfo) {
            var targetProps = target.getAllMembers(TypeScript.PullElementKind.SomeValue, true);

            for (var itargetProp = 0; itargetProp < targetProps.length; itargetProp++) {
                var targetProp = targetProps[itargetProp];
                var sourceProp = this.getMemberSymbol(targetProp.name, TypeScript.PullElementKind.SomeValue, source);

                if (!targetProp.isResolved) {
                    this.resolveDeclaredSymbol(targetProp, null, context);
                }

                var targetPropType = targetProp.type;

                if (!sourceProp) {
                    if (this.cachedObjectInterfaceType()) {
                        sourceProp = this.getMemberSymbol(targetProp.name, TypeScript.PullElementKind.SomeValue, this.cachedObjectInterfaceType());
                    }

                    if (!sourceProp) {
                        if (this.cachedFunctionInterfaceType() && (targetPropType.getCallSignatures().length || targetPropType.getConstructSignatures().length)) {
                            sourceProp = this.getMemberSymbol(targetProp.name, TypeScript.PullElementKind.SomeValue, this.cachedFunctionInterfaceType());
                        }

                        if (!sourceProp) {
                            if (!(targetProp.isOptional)) {
                                if (comparisonInfo) {
                                    comparisonInfo.flags |= 2 /* RequiredPropertyIsMissing */;
                                    comparisonInfo.addMessage(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Type_0_is_missing_property_1_from_type_2, [source.toString(), targetProp.getScopedNameEx().toString(), target.toString()]));
                                }
                                return false;
                            }
                            continue;
                        }
                    }
                }

                if (!this.sourcePropertyIsRelatableToTargetProperty(source, target, sourceProp, targetProp, assignableTo, comparisonCache, context, comparisonInfo)) {
                    return false;
                }
            }

            return true;
        };

        PullTypeResolver.prototype.sourcePropertyIsRelatableToTargetProperty = function (source, target, sourceProp, targetProp, assignableTo, comparisonCache, context, comparisonInfo) {
            var targetPropIsPrivate = targetProp.hasFlag(2 /* Private */);
            var sourcePropIsPrivate = sourceProp.hasFlag(2 /* Private */);

            if (targetPropIsPrivate != sourcePropIsPrivate) {
                if (comparisonInfo) {
                    if (targetPropIsPrivate) {
                        comparisonInfo.addMessage(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Property_0_defined_as_public_in_type_1_is_defined_as_private_in_type_2, [targetProp.getScopedNameEx().toString(), sourceProp.getContainer().toString(), targetProp.getContainer().toString()]));
                    } else {
                        comparisonInfo.addMessage(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Property_0_defined_as_private_in_type_1_is_defined_as_public_in_type_2, [targetProp.getScopedNameEx().toString(), sourceProp.getContainer().toString(), targetProp.getContainer().toString()]));
                    }
                    comparisonInfo.flags |= 128 /* InconsistantPropertyAccesibility */;
                }
                return false;
            } else if (sourcePropIsPrivate && targetPropIsPrivate) {
                var targetDecl = targetProp.getDeclarations()[0];
                var sourceDecl = sourceProp.getDeclarations()[0];

                if (!targetDecl.isEqual(sourceDecl)) {
                    if (comparisonInfo) {
                        comparisonInfo.flags |= 128 /* InconsistantPropertyAccesibility */;
                        comparisonInfo.addMessage(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Types_0_and_1_define_property_2_as_private, [sourceProp.getContainer().toString(), targetProp.getContainer().toString(), targetProp.getScopedNameEx().toString()]));
                    }

                    return false;
                }
            }

            if (!sourceProp.isResolved) {
                this.resolveDeclaredSymbol(sourceProp, null, context);
            }

            var sourcePropType = sourceProp.type;
            var targetPropType = targetProp.type;

            if (targetPropType && sourcePropType && (comparisonCache[sourcePropType.pullSymbolIDString + "#" + targetPropType.pullSymbolIDString] != undefined)) {
                return true;
            }

            var comparisonInfoPropertyTypeCheck = null;
            if (comparisonInfo && !comparisonInfo.onlyCaptureFirstError) {
                comparisonInfoPropertyTypeCheck = new TypeComparisonInfo(comparisonInfo);
            }
            if (!this.sourceIsRelatableToTarget(sourcePropType, targetPropType, assignableTo, comparisonCache, context, comparisonInfoPropertyTypeCheck)) {
                if (comparisonInfo) {
                    comparisonInfo.flags |= 32 /* IncompatiblePropertyTypes */;
                    var message;
                    if (comparisonInfoPropertyTypeCheck && comparisonInfoPropertyTypeCheck.message) {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Types_of_property_0_of_types_1_and_2_are_incompatible_NL_3, [targetProp.getScopedNameEx().toString(), source.toString(), target.toString(), comparisonInfoPropertyTypeCheck.message]);
                    } else {
                        message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Types_of_property_0_of_types_1_and_2_are_incompatible, [targetProp.getScopedNameEx().toString(), source.toString(), target.toString()]);
                    }
                    comparisonInfo.addMessage(message);
                }

                return false;
            }

            return true;
        };

        PullTypeResolver.prototype.sourceCallSignaturesAreRelatableToTargetCallSignatures = function (source, target, assignableTo, comparisonCache, context, comparisonInfo) {
            var targetCallSigs = target.getCallSignatures();

            if (targetCallSigs.length) {
                var comparisonInfoSignatuesTypeCheck = null;
                if (comparisonInfo && !comparisonInfo.onlyCaptureFirstError) {
                    comparisonInfoSignatuesTypeCheck = new TypeComparisonInfo(comparisonInfo);
                }

                var sourceCallSigs = source.getCallSignatures();
                if (!this.signatureGroupIsRelatableToTarget(sourceCallSigs, targetCallSigs, assignableTo, comparisonCache, context, comparisonInfoSignatuesTypeCheck)) {
                    if (comparisonInfo) {
                        var message;
                        if (sourceCallSigs.length && targetCallSigs.length) {
                            if (comparisonInfoSignatuesTypeCheck && comparisonInfoSignatuesTypeCheck.message) {
                                message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Call_signatures_of_types_0_and_1_are_incompatible_NL_2, [source.toString(), target.toString(), comparisonInfoSignatuesTypeCheck.message]);
                            } else {
                                message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Call_signatures_of_types_0_and_1_are_incompatible, [source.toString(), target.toString()]);
                            }
                        } else {
                            var hasSig = targetCallSigs.length ? target.toString() : source.toString();
                            var lacksSig = !targetCallSigs.length ? target.toString() : source.toString();
                            message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Type_0_requires_a_call_signature_but_type_1_lacks_one, [hasSig, lacksSig]);
                        }
                        comparisonInfo.flags |= 4 /* IncompatibleSignatures */;
                        comparisonInfo.addMessage(message);
                    }
                    return false;
                }
            }

            return true;
        };

        PullTypeResolver.prototype.sourceConstructSignaturesAreRelatableToTargetConstructSignatures = function (source, target, assignableTo, comparisonCache, context, comparisonInfo) {
            var targetConstructSigs = target.getConstructSignatures();
            if (targetConstructSigs.length) {
                var comparisonInfoSignatuesTypeCheck = null;
                if (comparisonInfo && !comparisonInfo.onlyCaptureFirstError) {
                    comparisonInfoSignatuesTypeCheck = new TypeComparisonInfo(comparisonInfo);
                }

                var sourceConstructSigs = source.getConstructSignatures();
                if (!this.signatureGroupIsRelatableToTarget(sourceConstructSigs, targetConstructSigs, assignableTo, comparisonCache, context, comparisonInfoSignatuesTypeCheck)) {
                    if (comparisonInfo) {
                        var message;
                        if (sourceConstructSigs.length && targetConstructSigs.length) {
                            if (comparisonInfoSignatuesTypeCheck && comparisonInfoSignatuesTypeCheck.message) {
                                message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Construct_signatures_of_types_0_and_1_are_incompatible_NL_2, [source.toString(), target.toString(), comparisonInfoSignatuesTypeCheck.message]);
                            } else {
                                message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Construct_signatures_of_types_0_and_1_are_incompatible, [source.toString(), target.toString()]);
                            }
                        } else {
                            var hasSig = targetConstructSigs.length ? target.toString() : source.toString();
                            var lacksSig = !targetConstructSigs.length ? target.toString() : source.toString();
                            message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Type_0_requires_a_construct_signature_but_type_1_lacks_one, [hasSig, lacksSig]);
                        }
                        comparisonInfo.flags |= 4 /* IncompatibleSignatures */;
                        comparisonInfo.addMessage(message);
                    }
                    return false;
                }
            }

            return true;
        };

        PullTypeResolver.prototype.sourceIndexSignaturesAreRelatableToTargetIndexSignatures = function (source, target, assignableTo, comparisonCache, context, comparisonInfo) {
            var targetIndexSigs = target.getIndexSignatures();

            if (targetIndexSigs.length) {
                var sourceIndexSigs = source.getIndexSignatures();

                var targetIndex = !targetIndexSigs.length && this.cachedObjectInterfaceType() ? this.cachedObjectInterfaceType().getIndexSignatures() : targetIndexSigs;
                var sourceIndex = !sourceIndexSigs.length && this.cachedObjectInterfaceType() ? this.cachedObjectInterfaceType().getIndexSignatures() : sourceIndexSigs;

                var sourceStringSig = null;
                var sourceNumberSig = null;

                var targetStringSig = null;
                var targetNumberSig = null;

                var params;

                for (var i = 0; i < targetIndex.length; i++) {
                    if (targetStringSig && targetNumberSig) {
                        break;
                    }

                    params = targetIndex[i].parameters;

                    if (params.length) {
                        if (!targetStringSig && params[0].type === this.semanticInfoChain.stringTypeSymbol) {
                            targetStringSig = targetIndex[i];
                            continue;
                        } else if (!targetNumberSig && params[0].type === this.semanticInfoChain.numberTypeSymbol) {
                            targetNumberSig = targetIndex[i];
                            continue;
                        }
                    }
                }

                for (var i = 0; i < sourceIndex.length; i++) {
                    if (sourceStringSig && sourceNumberSig) {
                        break;
                    }

                    params = sourceIndex[i].parameters;

                    if (params.length) {
                        if (!sourceStringSig && params[0].type === this.semanticInfoChain.stringTypeSymbol) {
                            sourceStringSig = sourceIndex[i];
                            continue;
                        } else if (!sourceNumberSig && params[0].type === this.semanticInfoChain.numberTypeSymbol) {
                            sourceNumberSig = sourceIndex[i];
                            continue;
                        }
                    }
                }

                var comparable = true;
                var comparisonInfoSignatuesTypeCheck = null;
                if (comparisonInfo && !comparisonInfo.onlyCaptureFirstError) {
                    comparisonInfoSignatuesTypeCheck = new TypeComparisonInfo(comparisonInfo);
                }

                if (targetStringSig) {
                    if (sourceStringSig) {
                        comparable = this.signatureIsAssignableToTarget(sourceStringSig, targetStringSig, context, comparisonInfoSignatuesTypeCheck);
                    } else {
                        comparable = false;
                    }
                }

                if (comparable && targetNumberSig) {
                    if (sourceNumberSig) {
                        comparable = this.signatureIsAssignableToTarget(sourceNumberSig, targetNumberSig, context, comparisonInfoSignatuesTypeCheck);
                    } else if (sourceStringSig) {
                        comparable = this.sourceIsAssignableToTarget(sourceStringSig.returnType, targetNumberSig.returnType, context, comparisonInfoSignatuesTypeCheck);
                    } else {
                        comparable = false;
                    }
                }

                if (!comparable) {
                    if (comparisonInfo) {
                        var message;
                        if (comparisonInfoSignatuesTypeCheck && comparisonInfoSignatuesTypeCheck.message) {
                            message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Index_signatures_of_types_0_and_1_are_incompatible_NL_2, [source.toString(), target.toString(), comparisonInfoSignatuesTypeCheck.message]);
                        } else {
                            message = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Index_signatures_of_types_0_and_1_are_incompatible, [source.toString(), target.toString()]);
                        }
                        comparisonInfo.flags |= 4 /* IncompatibleSignatures */;
                        comparisonInfo.addMessage(message);
                    }
                    return false;
                }
            }

            if (targetStringSig && !source.isNamedTypeSymbol() && source.hasMembers()) {
                var targetReturnType = targetStringSig.returnType;
                var sourceMembers = source.getMembers();

                for (var i = 0; i < sourceMembers.length; i++) {
                    if (!this.sourceIsRelatableToTarget(sourceMembers[i].type, targetReturnType, assignableTo, comparisonCache, context, comparisonInfo)) {
                        return false;
                    }
                }
            }

            return true;
        };

        PullTypeResolver.prototype.signatureGroupIsRelatableToTarget = function (sourceSG, targetSG, assignableTo, comparisonCache, context, comparisonInfo) {
            if (sourceSG === targetSG) {
                return true;
            }

            if (!(sourceSG.length && targetSG.length)) {
                return false;
            }

            var mSig = null;
            var nSig = null;
            var foundMatch = false;

            var targetExcludeDefinition = targetSG.length > 1;
            var sourceExcludeDefinition = sourceSG.length > 1;
            for (var iMSig = 0; iMSig < targetSG.length; iMSig++) {
                mSig = targetSG[iMSig];

                if (mSig.isStringConstantOverloadSignature() || (targetExcludeDefinition && mSig.isDefinition())) {
                    continue;
                }

                for (var iNSig = 0; iNSig < sourceSG.length; iNSig++) {
                    nSig = sourceSG[iNSig];

                    if (nSig.isStringConstantOverloadSignature() || (sourceExcludeDefinition && nSig.isDefinition())) {
                        continue;
                    }

                    if (this.signatureIsRelatableToTarget(nSig, mSig, assignableTo, comparisonCache, context, comparisonInfo)) {
                        foundMatch = true;
                        break;
                    }
                }

                if (foundMatch) {
                    foundMatch = false;
                    continue;
                }
                return false;
            }

            return true;
        };

        PullTypeResolver.prototype.signatureIsRelatableToTarget = function (sourceSig, targetSig, assignableTo, comparisonCache, context, comparisonInfo) {
            var sourceParameters = sourceSig.parameters;
            var targetParameters = targetSig.parameters;

            if (!sourceParameters || !targetParameters) {
                return false;
            }

            var targetVarArgCount = targetSig.nonOptionalParamCount;
            var sourceVarArgCount = sourceSig.nonOptionalParamCount;

            if (sourceVarArgCount > targetVarArgCount && !targetSig.hasVarArgs) {
                if (comparisonInfo) {
                    comparisonInfo.flags |= 3 /* SourceSignatureHasTooManyParameters */;
                    comparisonInfo.addMessage(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Call_signature_expects_0_or_fewer_parameters, [targetVarArgCount]));
                }
                return false;
            }

            var sourceReturnType = sourceSig.returnType;
            var targetReturnType = targetSig.returnType;

            var prevSpecializingToObject = context.specializingToObject;
            context.specializingToObject = true;

            if (targetReturnType != this.semanticInfoChain.voidTypeSymbol) {
                if (!this.sourceIsRelatableToTarget(sourceReturnType, targetReturnType, assignableTo, comparisonCache, context, comparisonInfo)) {
                    if (comparisonInfo) {
                        comparisonInfo.flags |= 16 /* IncompatibleReturnTypes */;
                    }
                    context.specializingToObject = prevSpecializingToObject;
                    return false;
                }
            }

            var len = (sourceVarArgCount < targetVarArgCount && (sourceSig.hasVarArgs || (sourceParameters.length > sourceVarArgCount))) ? targetVarArgCount : sourceVarArgCount;
            var sourceParamType = null;
            var targetParamType = null;
            var sourceParamName = "";
            var targetParamName = "";

            for (var iSource = 0, iTarget = 0; iSource < len; iSource++, iTarget++) {
                if (iSource < sourceParameters.length && (!sourceSig.hasVarArgs || iSource < sourceVarArgCount)) {
                    sourceParamType = sourceParameters[iSource].type;
                    sourceParamName = sourceParameters[iSource].name;
                } else if (iSource === sourceVarArgCount) {
                    sourceParamType = sourceParameters[iSource].type;
                    if (sourceParamType.isArray()) {
                        sourceParamType = sourceParamType.getElementType();
                    }
                    sourceParamName = sourceParameters[iSource].name;
                }

                if (iTarget < targetParameters.length && iTarget < targetVarArgCount) {
                    targetParamType = targetParameters[iTarget].type;
                    targetParamName = targetParameters[iTarget].name;
                } else if (targetSig.hasVarArgs && iTarget === targetVarArgCount) {
                    targetParamType = targetParameters[iTarget].type;

                    if (targetParamType.isArray()) {
                        targetParamType = targetParamType.getElementType();
                    }
                    targetParamName = targetParameters[iTarget].name;
                }

                if (sourceParamType && sourceParamType.isTypeParameter() && this.cachedObjectInterfaceType()) {
                    sourceParamType = this.cachedObjectInterfaceType();
                }
                if (targetParamType && targetParamType.isTypeParameter() && this.cachedObjectInterfaceType()) {
                    targetParamType = this.cachedObjectInterfaceType();
                }

                if (!(this.sourceIsRelatableToTarget(sourceParamType, targetParamType, assignableTo, comparisonCache, context, comparisonInfo) || this.sourceIsRelatableToTarget(targetParamType, sourceParamType, assignableTo, comparisonCache, context, comparisonInfo))) {
                    if (comparisonInfo) {
                        comparisonInfo.flags |= 64 /* IncompatibleParameterTypes */;
                    }
                    context.specializingToObject = prevSpecializingToObject;
                    return false;
                }
            }
            context.specializingToObject = prevSpecializingToObject;
            return true;
        };

        PullTypeResolver.prototype.resolveOverloads = function (application, group, enclosingDecl, haveTypeArgumentsAtCallSite, context, diagnostics) {
            var rd = this.resolutionDataCache.getResolutionData();
            var actuals = rd.actuals;
            var exactCandidates = rd.exactCandidates;
            var conversionCandidates = rd.conversionCandidates;
            var candidate = null;
            var hasOverloads = group.length > 1;
            var comparisonInfo = new TypeComparisonInfo();
            var args = null;
            var target = null;

            if (application.nodeType() === 37 /* InvocationExpression */ || application.nodeType() === 38 /* ObjectCreationExpression */) {
                var callEx = application;

                args = callEx.arguments;
                target = this.getLastIdentifierInTarget(callEx);

                if (callEx.arguments) {
                    var len = callEx.arguments.members.length;
                    var originalIsInInvocationExpression = context.isInInvocationExpression;
                    context.isInInvocationExpression = true;

                    for (var i = 0; i < len; i++) {
                        var argSym = this.resolveAST(callEx.arguments.members[i], false, enclosingDecl, context);
                        actuals[i] = argSym.type;
                    }

                    context.isInInvocationExpression = originalIsInInvocationExpression;
                }
            } else if (application.nodeType() === 36 /* ElementAccessExpression */) {
                var binExp = application;
                target = binExp.operand1;
                args = new TypeScript.ASTList([binExp.operand2]);

                var argSym = this.resolveAST(args.members[0], false, enclosingDecl, context);
                actuals[0] = argSym.type;
            }

            var signature;
            var returnType;
            var candidateInfo;

            for (var j = 0, groupLen = group.length; j < groupLen; j++) {
                signature = group[j];
                if ((hasOverloads && signature.isDefinition()) || (haveTypeArgumentsAtCallSite && !signature.isGeneric())) {
                    continue;
                }

                returnType = signature.returnType;

                this.getCandidateSignatures(signature, actuals, args, exactCandidates, conversionCandidates, enclosingDecl, context, comparisonInfo);
            }
            if (exactCandidates.length === 0) {
                var applicableCandidates = this.getApplicableSignaturesFromCandidates(conversionCandidates, args, comparisonInfo, enclosingDecl, context);
                if (applicableCandidates.length > 0) {
                    candidateInfo = this.findMostApplicableSignature(applicableCandidates, args, enclosingDecl, context);

                    candidate = candidateInfo.sig;
                } else {
                    if (comparisonInfo.message) {
                        diagnostics.push(context.postError(this.unitPath, target.minChar, target.getLength(), TypeScript.DiagnosticCode.Supplied_parameters_do_not_match_any_signature_of_call_target_NL_0, [comparisonInfo.message], enclosingDecl, false));
                    } else {
                        diagnostics.push(context.postError(this.unitPath, target.minChar, target.getLength(), TypeScript.DiagnosticCode.Supplied_parameters_do_not_match_any_signature_of_call_target, null, enclosingDecl, false));
                    }
                }
            } else {
                if (exactCandidates.length > 1) {
                    var applicableSigs = [];
                    for (var i = 0; i < exactCandidates.length; i++) {
                        applicableSigs[i] = { signature: exactCandidates[i], hadProvisionalErrors: false };
                    }
                    candidateInfo = this.findMostApplicableSignature(applicableSigs, args, enclosingDecl, context);

                    candidate = candidateInfo.sig;
                } else {
                    candidate = exactCandidates[0];
                }
            }

            this.resolutionDataCache.returnResolutionData(rd);
            return candidate;
        };

        PullTypeResolver.prototype.getLastIdentifierInTarget = function (callEx) {
            return (callEx.target.nodeType() === 33 /* MemberAccessExpression */) ? (callEx.target).operand2 : callEx.target;
        };

        PullTypeResolver.prototype.getCandidateSignatures = function (signature, actuals, args, exactCandidates, conversionCandidates, enclosingDecl, context, comparisonInfo) {
            var parameters = signature.parameters;
            var lowerBound = signature.nonOptionalParamCount;
            var upperBound = parameters.length;
            var formalLen = lowerBound;
            var acceptable = false;

            var actualsLength = args && actuals.length == args.separatorCount && actuals.length ? args.separatorCount + 1 : actuals.length;
            if ((actualsLength >= lowerBound) && (signature.hasVarArgs || actualsLength <= upperBound)) {
                formalLen = (signature.hasVarArgs ? parameters.length : actuals.length);
                acceptable = true;
            }

            var repeatType = null;

            if (acceptable) {
                if (signature.hasVarArgs) {
                    formalLen -= 1;
                    repeatType = parameters[formalLen].type;
                    repeatType = repeatType.getElementType();
                    acceptable = actualsLength >= (formalLen < lowerBound ? formalLen : lowerBound);
                }
                var len = actuals.length;

                var exact = acceptable;
                var convert = acceptable;

                var typeA;
                var typeB;

                for (var i = 0; i < len; i++) {
                    if (i < formalLen) {
                        typeA = parameters[i].type;
                    } else {
                        typeA = repeatType;
                    }

                    typeB = actuals[i];

                    if (typeA && !typeA.isResolved) {
                        this.resolveDeclaredSymbol(typeA, enclosingDecl, context);
                    }

                    if (typeB && !typeB.isResolved) {
                        this.resolveDeclaredSymbol(typeB, enclosingDecl, context);
                    }

                    if (!typeA || !typeB || !(this.typesAreIdentical(typeA, typeB, args.members[i]))) {
                        exact = false;
                    }

                    comparisonInfo.stringConstantVal = args.members[i];

                    if (!this.sourceIsAssignableToTarget(typeB, typeA, context, comparisonInfo)) {
                        convert = false;
                    }

                    comparisonInfo.stringConstantVal = null;

                    if (!(exact || convert)) {
                        break;
                    }
                }
                if (exact) {
                    exactCandidates[exactCandidates.length] = signature;
                } else if (convert && (exactCandidates.length === 0)) {
                    conversionCandidates[conversionCandidates.length] = signature;
                }
            }
        };

        PullTypeResolver.prototype.getApplicableSignaturesFromCandidates = function (candidateSignatures, args, comparisonInfo, enclosingDecl, context) {
            var applicableSigs = [];
            var memberType = null;
            var miss = false;
            var cxt = null;
            var hadProvisionalErrors = false;

            var parameters;
            var signature;
            var argSym;

            for (var i = 0; i < candidateSignatures.length; i++) {
                miss = false;

                signature = candidateSignatures[i];
                parameters = signature.parameters;

                for (var j = 0; j < args.members.length; j++) {
                    if (j >= parameters.length) {
                        continue;
                    }

                    if (!parameters[j].isResolved) {
                        this.resolveDeclaredSymbol(parameters[j], enclosingDecl, context);
                    }

                    memberType = parameters[j].type;

                    if (signature.hasVarArgs && (j >= signature.nonOptionalParamCount) && memberType.isArray()) {
                        memberType = memberType.getElementType();
                    }

                    if (this.isAnyOrEquivalent(memberType)) {
                        continue;
                    } else if (args.members[j].nodeType() === 13 /* FunctionDeclaration */) {
                        if (this.cachedFunctionInterfaceType() && memberType === this.cachedFunctionInterfaceType()) {
                            continue;
                        }

                        argSym = this.resolveFunctionExpression(args.members[j], false, enclosingDecl, context);

                        if (!this.canApplyContextualTypeToFunction(memberType, args.members[j], true)) {
                            if (this.canApplyContextualTypeToFunction(memberType, args.members[j], false)) {
                                if (!this.sourceIsAssignableToTarget(argSym.type, memberType, context, comparisonInfo, true)) {
                                    break;
                                }
                            } else {
                                break;
                            }
                        } else {
                            argSym.invalidate();
                            context.pushContextualType(memberType, true, null);

                            argSym = this.resolveFunctionExpression(args.members[j], true, enclosingDecl, context);

                            if (!this.sourceIsAssignableToTarget(argSym.type, memberType, context, comparisonInfo, true)) {
                                if (comparisonInfo) {
                                    comparisonInfo.setMessage(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Could_not_apply_type_0_to_argument_1_which_is_of_type_2, [memberType.toString(), (j + 1), argSym.getTypeName()]));
                                }
                                miss = true;
                            }
                            argSym.invalidate();
                            cxt = context.popContextualType();
                            hadProvisionalErrors = cxt.hadProvisionalErrors();

                            if (miss) {
                                break;
                            }
                        }
                    } else if (args.members[j].nodeType() === 23 /* ObjectLiteralExpression */) {
                        if (this.cachedObjectInterfaceType() && memberType === this.cachedObjectInterfaceType()) {
                            continue;
                        }

                        context.pushContextualType(memberType, true, null);
                        argSym = this.resolveObjectLiteralExpression(args.members[j], true, enclosingDecl, context);

                        if (!this.sourceIsAssignableToTarget(argSym.type, memberType, context, comparisonInfo, true)) {
                            if (comparisonInfo) {
                                comparisonInfo.setMessage(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Could_not_apply_type_0_to_argument_1_which_is_of_type_2, [memberType.toString(), (j + 1), argSym.getTypeName()]));
                            }

                            miss = true;
                        }

                        argSym.invalidate();
                        cxt = context.popContextualType();
                        hadProvisionalErrors = cxt.hadProvisionalErrors();

                        if (miss) {
                            break;
                        }
                    } else if (args.members[j].nodeType() === 22 /* ArrayLiteralExpression */) {
                        if (memberType === this.cachedArrayInterfaceType()) {
                            continue;
                        }

                        context.pushContextualType(memberType, true, null);
                        var argSym = this.resolveArrayLiteralExpression(args.members[j], true, enclosingDecl, context);

                        if (!this.sourceIsAssignableToTarget(argSym.type, memberType, context, comparisonInfo, true)) {
                            if (comparisonInfo) {
                                comparisonInfo.setMessage(TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Could_not_apply_type_0_to_argument_1_which_is_of_type_2, [memberType.toString(), (j + 1), argSym.getTypeName()]));
                            }
                            break;
                        }

                        argSym.invalidate();
                        cxt = context.popContextualType();

                        hadProvisionalErrors = cxt.hadProvisionalErrors();

                        if (miss) {
                            break;
                        }
                    }
                }

                if (j === args.members.length) {
                    applicableSigs[applicableSigs.length] = { signature: candidateSignatures[i], hadProvisionalErrors: hadProvisionalErrors };
                }

                hadProvisionalErrors = false;
            }

            return applicableSigs;
        };

        PullTypeResolver.prototype.findMostApplicableSignature = function (signatures, args, enclosingDecl, context) {
            if (signatures.length === 1) {
                return { sig: signatures[0].signature, ambiguous: false };
            }

            var best = signatures[0];
            var Q = null;

            var AType = null;
            var PType = null;
            var QType = null;

            var ambiguous = false;

            var bestParams;
            var qParams;

            for (var qSig = 1; qSig < signatures.length; qSig++) {
                Q = signatures[qSig];

                for (var i = 0; args && i < args.members.length; i++) {
                    var argSym = this.resolveAST(args.members[i], false, enclosingDecl, context);

                    AType = argSym.type;

                    argSym.invalidate();

                    bestParams = best.signature.parameters;
                    qParams = Q.signature.parameters;

                    PType = i < bestParams.length ? bestParams[i].type : bestParams[bestParams.length - 1].type.getElementType();
                    QType = i < qParams.length ? qParams[i].type : qParams[qParams.length - 1].type.getElementType();

                    if (this.typesAreIdentical(PType, QType) && !(QType.isPrimitive() && (QType).isStringConstant())) {
                        continue;
                    } else if (PType.isPrimitive() && (PType).isStringConstant() && args.members[i].nodeType() === 5 /* StringLiteral */ && TypeScript.stripQuotes((args.members[i]).actualText) === TypeScript.stripQuotes((PType).name)) {
                        break;
                    } else if (QType.isPrimitive() && (QType).isStringConstant() && args.members[i].nodeType() === 5 /* StringLiteral */ && TypeScript.stripQuotes((args.members[i]).actualText) === TypeScript.stripQuotes((QType).name)) {
                        best = Q;
                    } else if (this.typesAreIdentical(AType, PType)) {
                        break;
                    } else if (this.typesAreIdentical(AType, QType)) {
                        best = Q;
                        break;
                    } else if (this.sourceIsSubtypeOfTarget(PType, QType, context)) {
                        break;
                    } else if (this.sourceIsSubtypeOfTarget(QType, PType, context)) {
                        best = Q;
                        break;
                    } else if (Q.hadProvisionalErrors) {
                        break;
                    } else if (best.hadProvisionalErrors) {
                        best = Q;
                        break;
                    }
                }

                if (!args || i === args.members.length) {
                    var collection = {
                        getLength: function () {
                            return 2;
                        },
                        setTypeAtIndex: function (index, type) {
                        },
                        getTypeAtIndex: function (index) {
                            return index ? Q.signature.returnType : best.signature.returnType;
                        }
                    };
                    var bct = this.findBestCommonType(best.signature.returnType, null, collection, context);
                    ambiguous = !bct;
                } else {
                    ambiguous = false;
                }
            }

            return { sig: best.signature, ambiguous: ambiguous };
        };

        PullTypeResolver.prototype.canApplyContextualTypeToFunction = function (candidateType, funcDecl, beStringent) {
            if (funcDecl.isMethod() || beStringent && funcDecl.returnTypeAnnotation) {
                return false;
            }

            beStringent = beStringent || (this.cachedFunctionInterfaceType() === candidateType);

            if (!beStringent) {
                return true;
            }
            var functionSymbol = this.getDeclForAST(funcDecl).getSymbol();
            var signature = functionSymbol.type.getCallSignatures()[0];
            var parameters = signature.parameters;
            var paramLen = parameters.length;

            for (var i = 0; i < paramLen; i++) {
                var param = parameters[i];
                var argDecl = this.getASTForDecl(param.getDeclarations()[0]);

                if (beStringent && argDecl.typeExpr) {
                    return false;
                }
            }

            if (candidateType.getConstructSignatures().length && candidateType.getCallSignatures().length) {
                return false;
            }

            var candidateSigs = candidateType.getConstructSignatures().length ? candidateType.getConstructSignatures() : candidateType.getCallSignatures();

            if (!candidateSigs || candidateSigs.length > 1) {
                return false;
            }

            return true;
        };

        PullTypeResolver.prototype.inferArgumentTypesForSignature = function (signature, args, comparisonInfo, enclosingDecl, context) {
            var cxt = null;
            var hadProvisionalErrors = false;

            var parameters = signature.parameters;
            var typeParameters = signature.getTypeParameters();
            var argContext = new TypeScript.ArgumentInferenceContext();

            var parameterType = null;

            for (var i = 0; i < typeParameters.length; i++) {
                argContext.addInferenceRoot(typeParameters[i]);
            }

            var substitutions;
            var inferenceCandidates;
            var inferenceCandidate;

            for (var i = 0; i < args.members.length; i++) {
                if (i >= parameters.length) {
                    break;
                }

                parameterType = parameters[i].type;

                if (signature.hasVarArgs && (i >= signature.nonOptionalParamCount - 1) && parameterType.isArray()) {
                    parameterType = parameterType.getElementType();
                }

                inferenceCandidates = argContext.getInferenceCandidates();
                substitutions = {};

                if (inferenceCandidates.length) {
                    for (var j = 0; j < inferenceCandidates.length; j++) {
                        argContext.resetRelationshipCache();

                        inferenceCandidate = inferenceCandidates[j];

                        substitutions = inferenceCandidates[j];

                        context.pushContextualType(parameterType, true, substitutions);

                        var argSym = this.resolveAST(args.members[i], true, enclosingDecl, context);

                        this.relateTypeToTypeParameters(argSym.type, parameterType, false, argContext, enclosingDecl, context);

                        cxt = context.popContextualType();

                        argSym.invalidate();

                        hadProvisionalErrors = cxt.hadProvisionalErrors();
                    }
                } else {
                    context.pushContextualType(parameterType, true, {});
                    var argSym = this.resolveAST(args.members[i], true, enclosingDecl, context);

                    this.relateTypeToTypeParameters(argSym.type, parameterType, false, argContext, enclosingDecl, context);

                    cxt = context.popContextualType();

                    argSym.invalidate();

                    hadProvisionalErrors = cxt.hadProvisionalErrors();
                }
            }

            hadProvisionalErrors = false;

            var inferenceResults = argContext.inferArgumentTypes(this, context);

            if (inferenceResults.unfit) {
                return null;
            }

            var resultTypes = [];

            for (var i = 0; i < typeParameters.length; i++) {
                for (var j = 0; j < inferenceResults.results.length; j++) {
                    if (inferenceResults.results[j].param == typeParameters[i]) {
                        resultTypes[resultTypes.length] = inferenceResults.results[j].type;
                        break;
                    }
                }
            }

            if (!args.members.length && !resultTypes.length && typeParameters.length) {
                for (var i = 0; i < typeParameters.length; i++) {
                    resultTypes[resultTypes.length] = this.semanticInfoChain.anyTypeSymbol;
                }
            } else if (resultTypes.length && resultTypes.length < typeParameters.length) {
                for (var i = resultTypes.length; i < typeParameters.length; i++) {
                    resultTypes[i] = this.semanticInfoChain.anyTypeSymbol;
                }
            }

            return resultTypes;
        };

        PullTypeResolver.prototype.relateTypeToTypeParameters = function (expressionType, parameterType, shouldFix, argContext, enclosingDecl, context) {
            if (!expressionType || !parameterType) {
                return;
            }

            if (expressionType.isError()) {
                expressionType = this.semanticInfoChain.anyTypeSymbol;
            }

            if (parameterType === expressionType) {
                return;
            }

            if (parameterType.isTypeParameter()) {
                if (expressionType.isGeneric() && !expressionType.isFixed()) {
                    expressionType = this.specializeTypeToAny(expressionType, enclosingDecl, context);
                }
                argContext.addCandidateForInference(parameterType, expressionType, shouldFix);
                return;
            }
            var parameterDeclarations = parameterType.getDeclarations();
            var expressionDeclarations = expressionType.getDeclarations();
            if (!parameterType.isArray() && parameterDeclarations.length && expressionDeclarations.length && (parameterDeclarations[0].isEqual(expressionDeclarations[0]) || (expressionType.isGeneric() && parameterType.isGeneric() && this.sourceIsSubtypeOfTarget(expressionType, parameterType, context, null))) && expressionType.isGeneric()) {
                var typeParameters = parameterType.getIsSpecialized() ? parameterType.getTypeArguments() : parameterType.getTypeParameters();
                var typeArguments = expressionType.getTypeArguments();

                if (!typeArguments) {
                    typeParameters = parameterType.getTypeArguments();
                    typeArguments = expressionType.getIsSpecialized() ? expressionType.getTypeArguments() : expressionType.getTypeParameters();
                }

                if (typeParameters && typeArguments && typeParameters.length === typeArguments.length) {
                    for (var i = 0; i < typeParameters.length; i++) {
                        if (typeArguments[i] != typeParameters[i]) {
                            this.relateTypeToTypeParameters(typeArguments[i], typeParameters[i], true, argContext, enclosingDecl, context);
                        }
                    }
                }
            }

            var prevSpecializingToAny = context.specializingToAny;
            context.specializingToAny = true;

            if (!this.sourceIsAssignableToTarget(expressionType, parameterType, context)) {
                context.specializingToAny = prevSpecializingToAny;
                return;
            }
            context.specializingToAny = prevSpecializingToAny;

            if (expressionType.isArray() && parameterType.isArray()) {
                this.relateArrayTypeToTypeParameters(expressionType, parameterType, shouldFix, argContext, enclosingDecl, context);

                return;
            }

            this.relateObjectTypeToTypeParameters(expressionType, parameterType, shouldFix, argContext, enclosingDecl, context);
        };

        PullTypeResolver.prototype.relateFunctionSignatureToTypeParameters = function (expressionSignature, parameterSignature, argContext, enclosingDecl, context) {
            var expressionParams = expressionSignature.parameters;
            var expressionReturnType = expressionSignature.returnType;

            var parameterParams = parameterSignature.parameters;
            var parameterReturnType = parameterSignature.returnType;

            var len = parameterParams.length < expressionParams.length ? parameterParams.length : expressionParams.length;

            for (var i = 0; i < len; i++) {
                this.relateTypeToTypeParameters(expressionParams[i].type, parameterParams[i].type, true, argContext, enclosingDecl, context);
            }

            this.relateTypeToTypeParameters(expressionReturnType, parameterReturnType, false, argContext, enclosingDecl, context);
        };

        PullTypeResolver.prototype.relateObjectTypeToTypeParameters = function (objectType, parameterType, shouldFix, argContext, enclosingDecl, context) {
            var parameterTypeMembers = parameterType.getMembers();
            var parameterSignatures;
            var parameterSignature;

            var objectMember;
            var objectSignatures;

            if (argContext.alreadyRelatingTypes(objectType, parameterType)) {
                return;
            }

            var objectTypeArguments = objectType.getTypeArguments();
            var parameterTypeParameters = parameterType.getTypeParameters();

            if (objectTypeArguments && (objectTypeArguments.length === parameterTypeParameters.length)) {
                for (var i = 0; i < objectTypeArguments.length; i++) {
                    argContext.addCandidateForInference(parameterTypeParameters[i], objectTypeArguments[i], shouldFix);
                }
            }

            for (var i = 0; i < parameterTypeMembers.length; i++) {
                objectMember = this.getMemberSymbol(parameterTypeMembers[i].name, TypeScript.PullElementKind.SomeValue, objectType);

                if (objectMember) {
                    this.relateTypeToTypeParameters(objectMember.type, parameterTypeMembers[i].type, shouldFix, argContext, enclosingDecl, context);
                }
            }

            parameterSignatures = parameterType.getCallSignatures();
            objectSignatures = objectType.getCallSignatures();

            for (var i = 0; i < parameterSignatures.length; i++) {
                parameterSignature = parameterSignatures[i];

                for (var j = 0; j < objectSignatures.length; j++) {
                    this.relateFunctionSignatureToTypeParameters(objectSignatures[j], parameterSignature, argContext, enclosingDecl, context);
                }
            }

            parameterSignatures = parameterType.getConstructSignatures();
            objectSignatures = objectType.getConstructSignatures();

            for (var i = 0; i < parameterSignatures.length; i++) {
                parameterSignature = parameterSignatures[i];

                for (var j = 0; j < objectSignatures.length; j++) {
                    this.relateFunctionSignatureToTypeParameters(objectSignatures[j], parameterSignature, argContext, enclosingDecl, context);
                }
            }

            parameterSignatures = parameterType.getIndexSignatures();
            objectSignatures = objectType.getIndexSignatures();

            for (var i = 0; i < parameterSignatures.length; i++) {
                parameterSignature = parameterSignatures[i];

                for (var j = 0; j < objectSignatures.length; j++) {
                    this.relateFunctionSignatureToTypeParameters(objectSignatures[j], parameterSignature, argContext, enclosingDecl, context);
                }
            }
        };

        PullTypeResolver.prototype.relateArrayTypeToTypeParameters = function (argArrayType, parameterArrayType, shouldFix, argContext, enclosingDecl, context) {
            var argElement = argArrayType.getElementType();
            var paramElement = parameterArrayType.getElementType();

            this.relateTypeToTypeParameters(argElement, paramElement, shouldFix, argContext, enclosingDecl, context);
        };

        PullTypeResolver.prototype.specializeTypeToAny = function (typeToSpecialize, enclosingDecl, context) {
            var prevSpecialize = context.specializingToAny;

            context.specializingToAny = true;

            var rootType = TypeScript.getRootType(typeToSpecialize);

            var type = TypeScript.specializeType(rootType, [], this, enclosingDecl, context);

            context.specializingToAny = prevSpecialize;

            return type;
        };

        PullTypeResolver.prototype.specializeSignatureToAny = function (signatureToSpecialize, enclosingDecl, context) {
            var typeParameters = signatureToSpecialize.getTypeParameters();
            var typeReplacementMap = {};
            var typeArguments = [];

            for (var i = 0; i < typeParameters.length; i++) {
                typeArguments[i] = this.semanticInfoChain.anyTypeSymbol;
                typeReplacementMap[typeParameters[i].pullSymbolIDString] = typeArguments[i];
            }
            if (!typeArguments.length) {
                typeArguments[0] = this.semanticInfoChain.anyTypeSymbol;
            }

            var prevSpecialize = context.specializingToAny;

            context.specializingToAny = true;

            var sig = TypeScript.specializeSignature(signatureToSpecialize, false, typeReplacementMap, typeArguments, this, enclosingDecl, context);
            context.specializingToAny = prevSpecialize;

            return sig;
        };

        PullTypeResolver.typeCheck = function (compilationSettings, semanticInfoChain, scriptName, script) {
            var unit = semanticInfoChain.getUnit(scriptName);

            if (unit.getTypeChecked()) {
                return;
            }

            var scriptDecl = unit.getTopLevelDecls()[0];

            var resolver = new PullTypeResolver(compilationSettings, semanticInfoChain, scriptName);
            var context = new TypeScript.PullTypeResolutionContext(true);

            resolver.resolveAST(script.moduleElements, false, scriptDecl, context);

            resolver.validateVariableDeclarationGroups(scriptDecl, context);

            PullTypeResolver.globalTypeCheckPhase++;
            var callBack = null;

            while (PullTypeResolver.typeCheckCallBacks.length) {
                callBack = PullTypeResolver.typeCheckCallBacks[PullTypeResolver.typeCheckCallBacks.length - 1];
                PullTypeResolver.typeCheckCallBacks.pop();
                callBack();
            }

            unit.setTypeChecked();
        };

        PullTypeResolver.prototype.validateVariableDeclarationGroups = function (enclosingDecl, context) {
            var declGroups = enclosingDecl.getVariableDeclGroups();
            var decl;
            var firstSymbol;
            var firstSymbolType;
            var symbol;
            var symbolType;
            var boundDeclAST;

            for (var i = 0; i < declGroups.length; i++) {
                for (var j = 0; j < declGroups[i].length; j++) {
                    decl = declGroups[i][j];
                    symbol = decl.getSymbol();
                    boundDeclAST = this.semanticInfoChain.getASTForDecl(decl);
                    symbolType = this.resolveAST(boundDeclAST, false, enclosingDecl, context).type;
                    if (!j) {
                        firstSymbol = symbol;
                        firstSymbolType = symbolType;
                        continue;
                    }

                    if (symbolType && firstSymbolType && !this.typesAreIdentical(symbolType, firstSymbolType)) {
                        context.postError(this.currentUnit.getPath(), boundDeclAST.minChar, boundDeclAST.getLength(), TypeScript.DiagnosticCode.Subsequent_variable_declarations_must_have_the_same_type_Variable_0_must_be_of_type_1_but_here_has_type_2, [symbol.getScopedName(), firstSymbolType.toString(), symbolType.toString()], enclosingDecl);
                    }
                }
            }
        };

        PullTypeResolver.prototype.typeCheckFunctionOverloads = function (funcDecl, context, signature, allSignatures) {
            if (!signature) {
                var functionSignatureInfo = TypeScript.PullHelpers.getSignatureForFuncDecl(funcDecl, this.currentUnit);
                signature = functionSignatureInfo.signature;
                allSignatures = functionSignatureInfo.allSignatures;
            }
            var functionDeclaration = this.currentUnit.getDeclForAST(funcDecl);
            var funcSymbol = functionDeclaration.getSymbol();

            var definitionSignature = null;
            for (var i = allSignatures.length - 1; i >= 0; i--) {
                if (allSignatures[i].isDefinition()) {
                    definitionSignature = allSignatures[i];
                    break;
                }
            }

            if (!signature.isDefinition()) {
                for (var i = 0; i < allSignatures.length; i++) {
                    if (allSignatures[i] === signature) {
                        break;
                    }

                    if (this.signaturesAreIdentical(allSignatures[i], signature, false)) {
                        if (!this.typesAreIdentical(allSignatures[i].returnType, signature.returnType)) {
                            context.postError(this.unitPath, funcDecl.minChar, funcDecl.getLength(), TypeScript.DiagnosticCode.Overloads_cannot_differ_only_by_return_type, null, functionDeclaration);
                        } else if (funcDecl.isConstructor) {
                            context.postError(this.unitPath, funcDecl.minChar, funcDecl.getLength(), TypeScript.DiagnosticCode.Duplicate_constructor_overload_signature, null, functionDeclaration);
                        } else if (funcDecl.isConstructMember()) {
                            context.postError(this.unitPath, funcDecl.minChar, funcDecl.getLength(), TypeScript.DiagnosticCode.Duplicate_overload_construct_signature, null, functionDeclaration);
                        } else if (funcDecl.isCallMember()) {
                            context.postError(this.unitPath, funcDecl.minChar, funcDecl.getLength(), TypeScript.DiagnosticCode.Duplicate_overload_call_signature, null, functionDeclaration);
                        } else {
                            context.postError(this.unitPath, funcDecl.minChar, funcDecl.getLength(), TypeScript.DiagnosticCode.Duplicate_overload_signature_for_0, [funcSymbol.getScopedNameEx().toString()], functionDeclaration);
                        }

                        break;
                    }
                }
            }

            var isConstantOverloadSignature = signature.isStringConstantOverloadSignature();
            if (isConstantOverloadSignature) {
                if (signature.isDefinition()) {
                    context.postError(this.unitPath, funcDecl.minChar, funcDecl.getLength(), TypeScript.DiagnosticCode.Overload_signature_implementation_cannot_use_specialized_type, null, functionDeclaration);
                } else {
                    var foundSubtypeSignature = false;
                    for (var i = 0; i < allSignatures.length; i++) {
                        if (allSignatures[i].isDefinition() || allSignatures[i] === signature) {
                            continue;
                        }

                        if (!allSignatures[i].isResolved) {
                            this.resolveDeclaredSymbol(allSignatures[i], this.getEnclosingDecl(functionDeclaration), context);
                        }

                        if (allSignatures[i].isStringConstantOverloadSignature()) {
                            continue;
                        }

                        if (this.signatureIsSubtypeOfTarget(signature, allSignatures[i], context)) {
                            foundSubtypeSignature = true;
                            break;
                        }
                    }

                    if (!foundSubtypeSignature) {
                        context.postError(this.unitPath, funcDecl.minChar, funcDecl.getLength(), TypeScript.DiagnosticCode.Specialized_overload_signature_is_not_subtype_of_any_non_specialized_signature, null, functionDeclaration);
                    }
                }
            } else if (definitionSignature && definitionSignature != signature) {
                var comparisonInfo = new TypeComparisonInfo();

                if (!definitionSignature.isResolved) {
                    this.resolveDeclaredSymbol(definitionSignature, this.getEnclosingDecl(functionDeclaration), context);
                }

                if (!this.signatureIsAssignableToTarget(definitionSignature, signature, context, comparisonInfo)) {
                    if (comparisonInfo.message) {
                        context.postError(this.unitPath, funcDecl.minChar, funcDecl.getLength(), TypeScript.DiagnosticCode.Overload_signature_is_not_compatible_with_function_definition_NL_0, [comparisonInfo.message], functionDeclaration);
                    } else {
                        context.postError(this.unitPath, funcDecl.minChar, funcDecl.getLength(), TypeScript.DiagnosticCode.Overload_signature_is_not_compatible_with_function_definition, null, functionDeclaration);
                    }
                }
            }

            var signatureForVisibilityCheck = definitionSignature;
            if (!definitionSignature) {
                if (allSignatures[0] === signature) {
                    return;
                }
                signatureForVisibilityCheck = allSignatures[0];
            }

            if (!funcDecl.isConstructor && !funcDecl.isConstructMember() && signatureForVisibilityCheck && signature != signatureForVisibilityCheck) {
                var errorCode;

                if (signatureForVisibilityCheck.hasFlag(2 /* Private */) != signature.hasFlag(2 /* Private */)) {
                    errorCode = TypeScript.DiagnosticCode.Overload_signatures_must_all_be_public_or_private;
                } else if (signatureForVisibilityCheck.hasFlag(1 /* Exported */) != signature.hasFlag(1 /* Exported */)) {
                    errorCode = TypeScript.DiagnosticCode.Overload_signatures_must_all_be_exported_or_local;
                } else if (signatureForVisibilityCheck.hasFlag(8 /* Ambient */) != signature.hasFlag(8 /* Ambient */)) {
                    errorCode = TypeScript.DiagnosticCode.Overload_signatures_must_all_be_ambient_or_non_ambient;
                } else if (signatureForVisibilityCheck.hasFlag(128 /* Optional */) != signature.hasFlag(128 /* Optional */)) {
                    errorCode = TypeScript.DiagnosticCode.Overload_signatures_must_all_be_optional_or_required;
                }

                if (errorCode) {
                    context.postError(this.unitPath, funcDecl.minChar, funcDecl.getLength(), errorCode, null, functionDeclaration);
                }
            }
        };

        PullTypeResolver.prototype.checkSymbolPrivacy = function (declSymbol, symbol, context, privacyErrorReporter) {
            if (!symbol || symbol.kind === 2 /* Primitive */) {
                return;
            }

            if (symbol.isType()) {
                var typeSymbol = symbol;
                if (typeSymbol.isArray()) {
                    this.checkSymbolPrivacy(declSymbol, typeSymbol.getElementType(), context, privacyErrorReporter);
                    return;
                }

                if (!typeSymbol.isNamedTypeSymbol()) {
                    if (typeSymbol.inSymbolPrivacyCheck) {
                        return;
                    }

                    typeSymbol.inSymbolPrivacyCheck = true;

                    var members = typeSymbol.getMembers();
                    for (var i = 0; i < members.length; i++) {
                        this.checkSymbolPrivacy(declSymbol, members[i].type, context, privacyErrorReporter);
                    }

                    this.checkTypePrivacyOfSignatures(declSymbol, typeSymbol.getCallSignatures(), context, privacyErrorReporter);
                    this.checkTypePrivacyOfSignatures(declSymbol, typeSymbol.getConstructSignatures(), context, privacyErrorReporter);
                    this.checkTypePrivacyOfSignatures(declSymbol, typeSymbol.getIndexSignatures(), context, privacyErrorReporter);

                    typeSymbol.inSymbolPrivacyCheck = false;

                    return;
                }
            }

            if (declSymbol.isExternallyVisible()) {
                var symbolIsVisible = symbol.isExternallyVisible();

                if (symbolIsVisible) {
                    var symbolPath = symbol.pathToRoot();
                    if (symbolPath.length && symbolPath[symbolPath.length - 1].kind === 32 /* DynamicModule */) {
                        var declSymbolPath = declSymbol.pathToRoot();
                        var verifyAlias = false;
                        if (declSymbolPath.length) {
                            if (declSymbolPath[declSymbolPath.length - 1] != symbolPath[symbolPath.length - 1]) {
                                verifyAlias = true;
                            } else if (symbolPath.length > 1 && symbolPath[symbolPath.length - 2].kind == 32 /* DynamicModule */) {
                                if (declSymbolPath.length < 2 || declSymbolPath[declSymbolPath.length - 2] != symbolPath[symbolPath.length - 2]) {
                                    verifyAlias = true;
                                }
                            }
                        }

                        if (verifyAlias) {
                            symbolIsVisible = false;
                            for (var i = symbolPath.length - 1; i >= 0; i--) {
                                var aliasSymbol = symbolPath[i].getAliasedSymbol(declSymbol);
                                if (aliasSymbol) {
                                    symbolIsVisible = true;
                                    aliasSymbol.typeUsedExternally = true;
                                    break;
                                }
                            }
                            symbol = symbolPath[symbolPath.length - 1];
                        }
                    }
                }

                if (!symbolIsVisible) {
                    privacyErrorReporter(symbol);
                }
            }
        };

        PullTypeResolver.prototype.checkTypePrivacyOfSignatures = function (declSymbol, signatures, context, privacyErrorReporter) {
            for (var i = 0; i < signatures.length; i++) {
                var signature = signatures[i];
                if (signatures.length > 1 && signature.isDefinition()) {
                    continue;
                }

                var typeParams = signature.getTypeParameters();
                for (var j = 0; j < typeParams.length; j++) {
                    this.checkSymbolPrivacy(declSymbol, typeParams[j], context, privacyErrorReporter);
                }

                var params = signature.parameters;
                for (var j = 0; j < params.length; j++) {
                    var paramType = params[j].type;
                    this.checkSymbolPrivacy(declSymbol, paramType, context, privacyErrorReporter);
                }

                var returnType = signature.returnType;
                this.checkSymbolPrivacy(declSymbol, returnType, context, privacyErrorReporter);
            }
        };

        PullTypeResolver.prototype.baseListPrivacyErrorReporter = function (declAST, declSymbol, baseAst, isExtendedType, symbol, context) {
            var decl = this.getDeclForAST(declAST);
            var enclosingDecl = this.getEnclosingDecl(decl);
            var enclosingSymbol = enclosingDecl ? enclosingDecl.getSymbol() : null;
            var messageCode;

            var typeSymbol = symbol;
            var typeSymbolName = typeSymbol.getScopedName(enclosingSymbol);
            if (typeSymbol.isContainer() && !typeSymbol.isEnum()) {
                if (!TypeScript.isQuoted(typeSymbolName)) {
                    typeSymbolName = "'" + typeSymbolName + "'";
                }
                if (declAST.nodeType() === 14 /* ClassDeclaration */) {
                    if (isExtendedType) {
                        messageCode = TypeScript.DiagnosticCode.Exported_class_0_extends_class_from_inaccessible_module_1;
                    } else {
                        messageCode = TypeScript.DiagnosticCode.Exported_class_0_implements_interface_from_inaccessible_module_1;
                    }
                } else {
                    messageCode = TypeScript.DiagnosticCode.Exported_interface_0_extends_interface_from_inaccessible_module_1;
                }
            } else {
                if (declAST.nodeType() === 14 /* ClassDeclaration */) {
                    if (isExtendedType) {
                        messageCode = TypeScript.DiagnosticCode.Exported_class_0_extends_private_class_1;
                    } else {
                        messageCode = TypeScript.DiagnosticCode.Exported_class_0_implements_private_interface_1;
                    }
                } else {
                    messageCode = TypeScript.DiagnosticCode.Exported_interface_0_extends_private_interface_1;
                }
            }

            var messageArguments = [declSymbol.getScopedName(enclosingSymbol), typeSymbolName];
            context.postError(this.unitPath, baseAst.minChar, baseAst.getLength(), messageCode, messageArguments, enclosingDecl);
        };

        PullTypeResolver.prototype.variablePrivacyErrorReporter = function (declSymbol, symbol, context) {
            var typeSymbol = symbol;
            var declAST = this.getASTForSymbol(declSymbol);
            var enclosingDecl = this.getEnclosingDecl(declSymbol.getDeclarations()[0]);
            var enclosingSymbol = enclosingDecl ? enclosingDecl.getSymbol() : null;

            var isProperty = declSymbol.kind === 4096 /* Property */;
            var isPropertyOfClass = false;
            var declParent = declSymbol.getContainer();
            if (declParent && (declParent.kind === 8 /* Class */ || declParent.kind === 32768 /* ConstructorMethod */)) {
                isPropertyOfClass = true;
            }

            var messageCode;
            var typeSymbolName = typeSymbol.getScopedName(enclosingSymbol);
            if (typeSymbol.isContainer() && !typeSymbol.isEnum()) {
                if (!TypeScript.isQuoted(typeSymbolName)) {
                    typeSymbolName = "'" + typeSymbolName + "'";
                }

                if (declSymbol.hasFlag(16 /* Static */)) {
                    messageCode = TypeScript.DiagnosticCode.Public_static_property_0_of_exported_class_is_using_inaccessible_module_1;
                } else if (isProperty) {
                    if (isPropertyOfClass) {
                        messageCode = TypeScript.DiagnosticCode.Public_property_0_of_exported_class_is_using_inaccessible_module_1;
                    } else {
                        messageCode = TypeScript.DiagnosticCode.Property_0_of_exported_interface_is_using_inaccessible_module_1;
                    }
                } else {
                    messageCode = TypeScript.DiagnosticCode.Exported_variable_0_is_using_inaccessible_module_1;
                }
            } else {
                if (declSymbol.hasFlag(16 /* Static */)) {
                    messageCode = TypeScript.DiagnosticCode.Public_static_property_0_of_exported_class_has_or_is_using_private_type_1;
                } else if (isProperty) {
                    if (isPropertyOfClass) {
                        messageCode = TypeScript.DiagnosticCode.Public_property_0_of_exported_class_has_or_is_using_private_type_1;
                    } else {
                        messageCode = TypeScript.DiagnosticCode.Property_0_of_exported_interface_has_or_is_using_private_type_1;
                    }
                } else {
                    messageCode = TypeScript.DiagnosticCode.Exported_variable_0_has_or_is_using_private_type_1;
                }
            }

            var messageArguments = [declSymbol.getScopedName(enclosingSymbol), typeSymbolName];
            context.postError(this.unitPath, declAST.minChar, declAST.getLength(), messageCode, messageArguments, enclosingDecl);
        };

        PullTypeResolver.prototype.checkFunctionTypePrivacy = function (funcDeclAST, inContextuallyTypedAssignment, context) {
            var _this = this;
            if (inContextuallyTypedAssignment || (funcDeclAST.getFunctionFlags() & 8192 /* IsFunctionExpression */) || (funcDeclAST.getFunctionFlags() & 16384 /* IsFunctionProperty */)) {
                return;
            }

            var functionDecl = this.currentUnit.getDeclForAST(funcDeclAST);
            var functionSymbol = functionDecl.getSymbol();
            ;
            var functionSignature;

            var isGetter = funcDeclAST.isGetAccessor();
            var isSetter = funcDeclAST.isSetAccessor();

            if (isGetter || isSetter) {
                var accessorSymbol = functionSymbol;
                functionSignature = (isGetter ? accessorSymbol.getGetter() : accessorSymbol.getSetter()).type.getCallSignatures()[0];
            } else {
                if (!functionSymbol) {
                    var parentDecl = functionDecl.getParentDecl();
                    functionSymbol = parentDecl.getSymbol();
                    if (functionSymbol && functionSymbol.isType() && !(functionSymbol).isNamedTypeSymbol()) {
                        return;
                    }
                } else if (functionSymbol.kind == 65536 /* Method */ && !functionSymbol.getContainer().isNamedTypeSymbol()) {
                    return;
                }
                functionSignature = functionDecl.getSignatureSymbol();
            }

            if (!isGetter) {
                var funcParams = functionSignature.parameters;
                for (var i = 0; i < funcParams.length; i++) {
                    this.checkSymbolPrivacy(functionSymbol, funcParams[i].type, context, function (symbol) {
                        return _this.functionArgumentTypePrivacyErrorReporter(funcDeclAST, i, funcParams[i], symbol, context);
                    });
                }
            }

            if (!isSetter) {
                this.checkSymbolPrivacy(functionSymbol, functionSignature.returnType, context, function (symbol) {
                    return _this.functionReturnTypePrivacyErrorReporter(funcDeclAST, functionSignature.returnType, symbol, context);
                });
            }
        };

        PullTypeResolver.prototype.functionArgumentTypePrivacyErrorReporter = function (declAST, argIndex, paramSymbol, symbol, context) {
            var decl = this.getDeclForAST(declAST);
            var enclosingDecl = this.getEnclosingDecl(decl);
            var enclosingSymbol = enclosingDecl ? enclosingDecl.getSymbol() : null;

            var isGetter = declAST.isAccessor() && TypeScript.hasFlag(declAST.getFunctionFlags(), 32 /* GetAccessor */);
            var isSetter = declAST.isAccessor() && TypeScript.hasFlag(declAST.getFunctionFlags(), 64 /* SetAccessor */);
            var isStatic = (decl.flags & 16 /* Static */) === 16 /* Static */;
            var isMethod = decl.kind === 65536 /* Method */;
            var isMethodOfClass = false;
            var declParent = decl.getParentDecl();
            if (declParent && (declParent.kind === 8 /* Class */ || declParent.kind === 32768 /* ConstructorMethod */)) {
                isMethodOfClass = true;
            }

            var start = declAST.arguments.members[argIndex].minChar;
            var length = declAST.arguments.members[argIndex].getLength();

            var typeSymbol = symbol;
            var typeSymbolName = typeSymbol.getScopedName(enclosingSymbol);
            var messageCode;
            if (typeSymbol.isContainer() && !typeSymbol.isEnum()) {
                if (!TypeScript.isQuoted(typeSymbolName)) {
                    typeSymbolName = "'" + typeSymbolName + "'";
                }

                if (declAST.isConstructor) {
                    messageCode = TypeScript.DiagnosticCode.Parameter_0_of_constructor_from_exported_class_is_using_inaccessible_module_1;
                } else if (isSetter) {
                    if (isStatic) {
                        messageCode = TypeScript.DiagnosticCode.Parameter_0_of_public_static_property_setter_from_exported_class_is_using_inaccessible_module_1;
                    } else {
                        messageCode = TypeScript.DiagnosticCode.Parameter_0_of_public_property_setter_from_exported_class_is_using_inaccessible_module_1;
                    }
                } else if (declAST.isConstructMember()) {
                    messageCode = TypeScript.DiagnosticCode.Parameter_0_of_constructor_signature_from_exported_interface_is_using_inaccessible_module_1;
                } else if (declAST.isCallMember()) {
                    messageCode = TypeScript.DiagnosticCode.Parameter_0_of_call_signature_from_exported_interface_is_using_inaccessible_module_1;
                } else if (isMethod) {
                    if (isStatic) {
                        messageCode = TypeScript.DiagnosticCode.Parameter_0_of_public_static_method_from_exported_class_is_using_inaccessible_module_1;
                    } else if (isMethodOfClass) {
                        messageCode = TypeScript.DiagnosticCode.Parameter_0_of_public_method_from_exported_class_is_using_inaccessible_module_1;
                    } else {
                        messageCode = TypeScript.DiagnosticCode.Parameter_0_of_method_from_exported_interface_is_using_inaccessible_module_1;
                    }
                } else if (!isGetter) {
                    messageCode = TypeScript.DiagnosticCode.Parameter_0_of_exported_function_is_using_inaccessible_module_1;
                }
            } else {
                if (declAST.isConstructor) {
                    messageCode = TypeScript.DiagnosticCode.Parameter_0_of_constructor_from_exported_class_has_or_is_using_private_type_1;
                } else if (isSetter) {
                    if (isStatic) {
                        messageCode = TypeScript.DiagnosticCode.Parameter_0_of_public_static_property_setter_from_exported_class_has_or_is_using_private_type_1;
                    } else {
                        messageCode = TypeScript.DiagnosticCode.Parameter_0_of_public_property_setter_from_exported_class_has_or_is_using_private_type_1;
                    }
                } else if (declAST.isConstructMember()) {
                    messageCode = TypeScript.DiagnosticCode.Parameter_0_of_constructor_signature_from_exported_interface_has_or_is_using_private_type_1;
                } else if (declAST.isCallMember()) {
                    messageCode = TypeScript.DiagnosticCode.Parameter_0_of_call_signature_from_exported_interface_has_or_is_using_private_type_1;
                } else if (isMethod) {
                    if (isStatic) {
                        messageCode = TypeScript.DiagnosticCode.Parameter_0_of_public_static_method_from_exported_class_has_or_is_using_private_type_1;
                    } else if (isMethodOfClass) {
                        messageCode = TypeScript.DiagnosticCode.Parameter_0_of_public_method_from_exported_class_has_or_is_using_private_type_1;
                    } else {
                        messageCode = TypeScript.DiagnosticCode.Parameter_0_of_method_from_exported_interface_has_or_is_using_private_type_1;
                    }
                } else if (!isGetter && !declAST.isIndexerMember()) {
                    messageCode = TypeScript.DiagnosticCode.Parameter_0_of_exported_function_has_or_is_using_private_type_1;
                }
            }

            if (messageCode) {
                var messageArgs = [paramSymbol.getScopedName(enclosingSymbol), typeSymbolName];
                context.postError(this.unitPath, start, length, messageCode, messageArgs, enclosingDecl);
            }
        };

        PullTypeResolver.prototype.functionReturnTypePrivacyErrorReporter = function (declAST, funcReturnType, symbol, context) {
            var _this = this;
            var decl = this.getDeclForAST(declAST);
            var enclosingDecl = this.getEnclosingDecl(decl);

            var isGetter = declAST.isAccessor() && TypeScript.hasFlag(declAST.getFunctionFlags(), 32 /* GetAccessor */);
            var isSetter = declAST.isAccessor() && TypeScript.hasFlag(declAST.getFunctionFlags(), 64 /* SetAccessor */);
            var isStatic = (decl.flags & 16 /* Static */) === 16 /* Static */;
            var isMethod = decl.kind === 65536 /* Method */;
            var isMethodOfClass = false;
            var declParent = decl.getParentDecl();
            if (declParent && (declParent.kind === 8 /* Class */ || declParent.kind === 32768 /* ConstructorMethod */)) {
                isMethodOfClass = true;
            }

            var messageCode = null;
            var typeSymbol = symbol;
            var typeSymbolName = typeSymbol.getScopedName(enclosingDecl ? enclosingDecl.getSymbol() : null);
            if (typeSymbol.isContainer() && !typeSymbol.isEnum()) {
                if (!TypeScript.isQuoted(typeSymbolName)) {
                    typeSymbolName = "'" + typeSymbolName + "'";
                }

                if (isGetter) {
                    if (isStatic) {
                        messageCode = TypeScript.DiagnosticCode.Return_type_of_public_static_property_getter_from_exported_class_is_using_inaccessible_module_0;
                    } else {
                        messageCode = TypeScript.DiagnosticCode.Return_type_of_public_property_getter_from_exported_class_is_using_inaccessible_module_0;
                    }
                } else if (declAST.isConstructMember()) {
                    messageCode = TypeScript.DiagnosticCode.Return_type_of_constructor_signature_from_exported_interface_is_using_inaccessible_module_0;
                } else if (declAST.isCallMember()) {
                    messageCode = TypeScript.DiagnosticCode.Return_type_of_call_signature_from_exported_interface_is_using_inaccessible_module_0;
                } else if (declAST.isIndexerMember()) {
                    messageCode = TypeScript.DiagnosticCode.Return_type_of_index_signature_from_exported_interface_is_using_inaccessible_module_0;
                } else if (isMethod) {
                    if (isStatic) {
                        messageCode = TypeScript.DiagnosticCode.Return_type_of_public_static_method_from_exported_class_is_using_inaccessible_module_0;
                    } else if (isMethodOfClass) {
                        messageCode = TypeScript.DiagnosticCode.Return_type_of_public_method_from_exported_class_is_using_inaccessible_module_0;
                    } else {
                        messageCode = TypeScript.DiagnosticCode.Return_type_of_method_from_exported_interface_is_using_inaccessible_module_0;
                    }
                } else if (!isSetter && !declAST.isConstructor) {
                    messageCode = TypeScript.DiagnosticCode.Return_type_of_exported_function_is_using_inaccessible_module_0;
                }
            } else {
                if (isGetter) {
                    if (isStatic) {
                        messageCode = TypeScript.DiagnosticCode.Return_type_of_public_static_property_getter_from_exported_class_has_or_is_using_private_type_0;
                    } else {
                        messageCode = TypeScript.DiagnosticCode.Return_type_of_public_property_getter_from_exported_class_has_or_is_using_private_type_0;
                    }
                } else if (declAST.isConstructMember()) {
                    messageCode = TypeScript.DiagnosticCode.Return_type_of_constructor_signature_from_exported_interface_has_or_is_using_private_type_0;
                } else if (declAST.isCallMember()) {
                    messageCode = TypeScript.DiagnosticCode.Return_type_of_call_signature_from_exported_interface_has_or_is_using_private_type_0;
                } else if (declAST.isIndexerMember()) {
                    messageCode = TypeScript.DiagnosticCode.Return_type_of_index_signature_from_exported_interface_has_or_is_using_private_type_0;
                } else if (isMethod) {
                    if (isStatic) {
                        messageCode = TypeScript.DiagnosticCode.Return_type_of_public_static_method_from_exported_class_has_or_is_using_private_type_0;
                    } else if (isMethodOfClass) {
                        messageCode = TypeScript.DiagnosticCode.Return_type_of_public_method_from_exported_class_has_or_is_using_private_type_0;
                    } else {
                        messageCode = TypeScript.DiagnosticCode.Return_type_of_method_from_exported_interface_has_or_is_using_private_type_0;
                    }
                } else if (!isSetter && !declAST.isConstructor) {
                    messageCode = TypeScript.DiagnosticCode.Return_type_of_exported_function_has_or_is_using_private_type_0;
                }
            }

            if (messageCode) {
                var messageArguments = [typeSymbolName];
                var reportOnFuncDecl = false;

                if (declAST.returnTypeAnnotation) {
                    var returnExpressionSymbol = this.resolveTypeReference(declAST.returnTypeAnnotation, decl, context);
                    if (returnExpressionSymbol === funcReturnType) {
                        context.postError(this.unitPath, declAST.returnTypeAnnotation.minChar, declAST.returnTypeAnnotation.getLength(), messageCode, messageArguments, enclosingDecl);
                    }
                }

                if (declAST.block) {
                    var reportErrorOnReturnExpressions = function (ast, parent, walker) {
                        var go = true;
                        switch (ast.nodeType()) {
                            case 13 /* FunctionDeclaration */:
                                go = false;
                                break;

                            case 94 /* ReturnStatement */:
                                var returnStatement = ast;
                                var returnExpressionSymbol = _this.resolveAST(returnStatement.returnExpression, false, decl, context).type;

                                if (returnExpressionSymbol === funcReturnType) {
                                    context.postError(_this.unitPath, returnStatement.minChar, returnStatement.getLength(), messageCode, messageArguments, enclosingDecl);
                                } else {
                                    reportOnFuncDecl = true;
                                }
                                go = false;
                                break;

                            default:
                                break;
                        }

                        walker.options.goChildren = go;
                        return ast;
                    };

                    TypeScript.getAstWalkerFactory().walk(declAST.block, reportErrorOnReturnExpressions);
                }

                if (reportOnFuncDecl) {
                    context.postError(this.unitPath, declAST.minChar, declAST.getLength(), messageCode, messageArguments, enclosingDecl);
                }
            }
        };

        PullTypeResolver.prototype.enclosingClassIsDerived = function (decl) {
            if (decl) {
                var parentDecl = decl.getParentDecl();
                var classSymbol = null;

                while (parentDecl) {
                    if (parentDecl.kind == 8 /* Class */) {
                        classSymbol = parentDecl.getSymbol();
                        if (classSymbol.getExtendedTypes().length > 0) {
                            return true;
                        }

                        break;
                    }
                    parentDecl = parentDecl.getParentDecl();
                }
            }

            return false;
        };

        PullTypeResolver.prototype.isSuperCallNode = function (node) {
            if (node && node.nodeType() === 89 /* ExpressionStatement */) {
                var expressionStatement = node;
                if (expressionStatement.expression && expressionStatement.expression.nodeType() === 37 /* InvocationExpression */) {
                    var callExpression = expressionStatement.expression;
                    if (callExpression.target && callExpression.target.nodeType() === 31 /* SuperExpression */) {
                        return true;
                    }
                }
            }
            return false;
        };

        PullTypeResolver.prototype.getFirstStatementFromFunctionDeclAST = function (funcDeclAST) {
            if (funcDeclAST.block && funcDeclAST.block.statements && funcDeclAST.block.statements.members) {
                return funcDeclAST.block.statements.members[0];
            }

            return null;
        };

        PullTypeResolver.prototype.superCallMustBeFirstStatementInConstructor = function (enclosingConstructor, enclosingClass) {
            if (enclosingConstructor && enclosingClass) {
                var classSymbol = enclosingClass.getSymbol();
                if (classSymbol.getExtendedTypes().length === 0) {
                    return false;
                }

                var classMembers = classSymbol.getMembers();
                for (var i = 0, n1 = classMembers.length; i < n1; i++) {
                    var member = classMembers[i];

                    if (member.kind === 4096 /* Property */) {
                        var declarations = member.getDeclarations();
                        for (var j = 0, n2 = declarations.length; j < n2; j++) {
                            var declaration = declarations[j];
                            var ast = this.semanticInfoChain.getASTForDecl(declaration);
                            if (ast.nodeType() === 20 /* Parameter */) {
                                return true;
                            }

                            if (ast.nodeType() === 18 /* VariableDeclarator */) {
                                var variableDeclarator = ast;
                                if (variableDeclarator.init) {
                                    return true;
                                }
                            }
                        }
                    }
                }
            }

            return false;
        };

        PullTypeResolver.prototype.checkForThisOrSuperCaptureInArrowFunction = function (expression, enclosingDecl) {
            var declPath = TypeScript.getPathToDecl(enclosingDecl);

            if (declPath.length) {
                var inFatArrow = false;
                for (var i = declPath.length - 1; i >= 0; i--) {
                    var decl = declPath[i];
                    var declKind = decl.kind;
                    var declFlags = decl.flags;

                    if (declKind === 131072 /* FunctionExpression */ && TypeScript.hasFlag(declFlags, 8192 /* FatArrow */)) {
                        inFatArrow = true;
                        continue;
                    }

                    if (inFatArrow) {
                        if (declKind === 16384 /* Function */ || declKind === 65536 /* Method */ || declKind === 32768 /* ConstructorMethod */ || declKind === 262144 /* GetAccessor */ || declKind === 524288 /* SetAccessor */ || declKind === 131072 /* FunctionExpression */ || declKind === 8 /* Class */ || declKind === 4 /* Container */ || declKind === 32 /* DynamicModule */ || declKind === 1 /* Script */) {
                            decl.setFlags(decl.flags | 262144 /* MustCaptureThis */);

                            if (declKind === 8 /* Class */) {
                                var constructorSymbol = (decl.getSymbol()).getConstructorMethod();
                                var constructorDecls = constructorSymbol.getDeclarations();
                                for (var i = 0; i < constructorDecls.length; i++) {
                                    constructorDecls[i].flags = constructorDecls[i].flags | 262144 /* MustCaptureThis */;
                                }
                            }
                            break;
                        }
                    } else if (declKind === 16384 /* Function */ || declKind === 131072 /* FunctionExpression */) {
                        break;
                    }
                }
            }
        };

        PullTypeResolver.prototype.typeCheckMembersAgainstIndexer = function (containerType, containerTypeDecl, context) {
            var indexSignatures = containerType.getIndexSignatures();

            if (indexSignatures.length > 0) {
                var members = containerTypeDecl.getChildDecls();
                for (var i = 0; i < members.length; i++) {
                    var member = members[i];
                    if (!member.name || member.kind & TypeScript.PullElementKind.SomeSignature) {
                        continue;
                    }

                    var isMemberNumeric = isFinite(+member.name);
                    for (var j = 0; j < indexSignatures.length; j++) {
                        if (!indexSignatures[j].isResolved) {
                            this.resolveDeclaredSymbol(indexSignatures[j], indexSignatures[j].getDeclarations()[0].getParentDecl(), context);
                        }
                        if ((indexSignatures[j].parameters[0].type === this.semanticInfoChain.numberTypeSymbol) === isMemberNumeric) {
                            this.checkThatMemberIsSubtypeOfIndexer(member.getSymbol(), indexSignatures[j], this.semanticInfoChain.getASTForDecl(member), context, containerTypeDecl, isMemberNumeric);
                            break;
                        }
                    }
                }
            }
        };

        PullTypeResolver.prototype.checkThatMemberIsSubtypeOfIndexer = function (member, indexSignature, astForError, context, enclosingDecl, isNumeric) {
            var comparisonInfo = new TypeComparisonInfo();
            var resolutionContext = new TypeScript.PullTypeResolutionContext();

            if (!this.sourceIsSubtypeOfTarget(member.type, indexSignature.returnType, resolutionContext, comparisonInfo)) {
                if (isNumeric) {
                    if (comparisonInfo.message) {
                        context.postError(this.unitPath, astForError.minChar, astForError.getLength(), TypeScript.DiagnosticCode.All_numerically_named_properties_must_be_subtypes_of_numeric_indexer_type_0_NL_1, [indexSignature.returnType.toString(), comparisonInfo.message], enclosingDecl);
                    } else {
                        context.postError(this.unitPath, astForError.minChar, astForError.getLength(), TypeScript.DiagnosticCode.All_numerically_named_properties_must_be_subtypes_of_numeric_indexer_type_0, [indexSignature.returnType.toString()], enclosingDecl);
                    }
                } else {
                    if (comparisonInfo.message) {
                        context.postError(this.unitPath, astForError.minChar, astForError.getLength(), TypeScript.DiagnosticCode.All_named_properties_must_be_subtypes_of_string_indexer_type_0_NL_1, [indexSignature.returnType.toString(), comparisonInfo.message], enclosingDecl);
                    } else {
                        context.postError(this.unitPath, astForError.minChar, astForError.getLength(), TypeScript.DiagnosticCode.All_named_properties_must_be_subtypes_of_string_indexer_type_0, [indexSignature.returnType.toString()], enclosingDecl);
                    }
                }
            }
        };

        PullTypeResolver.prototype.typeCheckIfTypeMemberPropertyOkToOverride = function (typeSymbol, extendedType, typeMember, extendedTypeMember, enclosingDecl, comparisonInfo) {
            if (!typeSymbol.isClass()) {
                return true;
            }

            var typeMemberKind = typeMember.kind;
            var extendedMemberKind = extendedTypeMember.kind;

            if (typeMemberKind === extendedMemberKind) {
                return true;
            }

            var errorCode;
            if (typeMemberKind === 4096 /* Property */) {
                if (typeMember.isAccessor()) {
                    errorCode = TypeScript.DiagnosticCode.Class_0_defines_instance_member_accessor_1_but_extended_class_2_defines_it_as_instance_member_function;
                } else {
                    errorCode = TypeScript.DiagnosticCode.Class_0_defines_instance_member_property_1_but_extended_class_2_defines_it_as_instance_member_function;
                }
            } else if (typeMemberKind === 65536 /* Method */) {
                if (extendedTypeMember.isAccessor()) {
                    errorCode = TypeScript.DiagnosticCode.Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_accessor;
                } else {
                    errorCode = TypeScript.DiagnosticCode.Class_0_defines_instance_member_function_1_but_extended_class_2_defines_it_as_instance_member_property;
                }
            }

            var message = TypeScript.getDiagnosticMessage(errorCode, [typeSymbol.toString(), typeMember.getScopedNameEx().toString(), extendedType.toString()]);
            comparisonInfo.addMessage(message);
            return false;
        };

        PullTypeResolver.prototype.typeCheckIfTypeExtendsType = function (typeDecl, typeSymbol, extendedType, enclosingDecl, context) {
            var typeMembers = typeSymbol.getMembers();

            var resolutionContext = new TypeScript.PullTypeResolutionContext();
            var comparisonInfo = new TypeComparisonInfo();
            var foundError = false;

            for (var i = 0; i < typeMembers.length; i++) {
                var propName = typeMembers[i].name;
                var extendedTypeProp = extendedType.findMember(propName);
                if (extendedTypeProp) {
                    foundError = !this.typeCheckIfTypeMemberPropertyOkToOverride(typeSymbol, extendedType, typeMembers[i], extendedTypeProp, enclosingDecl, comparisonInfo);

                    if (!foundError) {
                        foundError = !this.sourcePropertyIsSubtypeOfTargetProperty(typeSymbol, extendedType, typeMembers[i], extendedTypeProp, resolutionContext, comparisonInfo);
                    }

                    if (foundError) {
                        break;
                    }
                }
            }

            if (!foundError && typeSymbol.hasOwnCallSignatures()) {
                foundError = !this.sourceCallSignaturesAreSubtypeOfTargetCallSignatures(typeSymbol, extendedType, resolutionContext, comparisonInfo);
            }

            if (!foundError && typeSymbol.hasOwnConstructSignatures()) {
                foundError = !this.sourceConstructSignaturesAreSubtypeOfTargetConstructSignatures(typeSymbol, extendedType, resolutionContext, comparisonInfo);
            }

            if (!foundError && typeSymbol.hasOwnIndexSignatures()) {
                foundError = !this.sourceIndexSignaturesAreSubtypeOfTargetIndexSignatures(typeSymbol, extendedType, resolutionContext, comparisonInfo);
            }

            if (!foundError && typeSymbol.isClass()) {
                var typeConstructorType = typeSymbol.getConstructorMethod().type;
                var typeConstructorTypeMembers = typeConstructorType.getMembers();
                if (typeConstructorTypeMembers.length) {
                    var extendedConstructorType = extendedType.getConstructorMethod().type;
                    var comparisonInfoForPropTypeCheck = new TypeComparisonInfo(comparisonInfo);

                    for (var i = 0; i < typeConstructorTypeMembers.length; i++) {
                        var propName = typeConstructorTypeMembers[i].name;
                        var extendedConstructorTypeProp = extendedConstructorType.findMember(propName);
                        if (extendedConstructorTypeProp) {
                            if (!extendedConstructorTypeProp.isResolved) {
                                var extendedClassAst = this.currentUnit.getASTForSymbol(extendedType);
                                var extendedClassDecl = this.currentUnit.getDeclForAST(extendedClassAst);
                                this.resolveDeclaredSymbol(extendedConstructorTypeProp, extendedClassDecl, resolutionContext);
                            }

                            var typeConstructorTypePropType = typeConstructorTypeMembers[i].type;
                            var extendedConstructorTypePropType = extendedConstructorTypeProp.type;
                            if (!this.sourceIsSubtypeOfTarget(typeConstructorTypePropType, extendedConstructorTypePropType, resolutionContext, comparisonInfoForPropTypeCheck)) {
                                var propMessage;
                                if (comparisonInfoForPropTypeCheck.message) {
                                    propMessage = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Types_of_static_property_0_of_class_1_and_class_2_are_incompatible_NL_3, [extendedConstructorTypeProp.getScopedNameEx().toString(), typeSymbol.toString(), extendedType.toString(), comparisonInfoForPropTypeCheck.message]);
                                } else {
                                    propMessage = TypeScript.getDiagnosticMessage(TypeScript.DiagnosticCode.Types_of_static_property_0_of_class_1_and_class_2_are_incompatible, [extendedConstructorTypeProp.getScopedNameEx().toString(), typeSymbol.toString(), extendedType.toString()]);
                                }
                                comparisonInfo.addMessage(propMessage);
                                foundError = true;
                                break;
                            }
                        }
                    }
                }
            }

            if (foundError) {
                var errorCode;
                if (typeSymbol.isClass()) {
                    errorCode = TypeScript.DiagnosticCode.Class_0_cannot_extend_class_1_NL_2;
                } else {
                    if (extendedType.isClass()) {
                        errorCode = TypeScript.DiagnosticCode.Interface_0_cannot_extend_class_1_NL_2;
                    } else {
                        errorCode = TypeScript.DiagnosticCode.Interface_0_cannot_extend_interface_1_NL_2;
                    }
                }

                context.postError(this.unitPath, typeDecl.name.minChar, typeDecl.name.getLength(), errorCode, [typeSymbol.getScopedName(), extendedType.getScopedName(), comparisonInfo.message], enclosingDecl);
            }
        };

        PullTypeResolver.prototype.typeCheckIfClassImplementsType = function (classDecl, classSymbol, implementedType, enclosingDecl, context) {
            var resolutionContext = new TypeScript.PullTypeResolutionContext();
            var comparisonInfo = new TypeComparisonInfo();
            var foundError = !this.sourceMembersAreSubtypeOfTargetMembers(classSymbol, implementedType, resolutionContext, comparisonInfo);
            if (!foundError) {
                foundError = !this.sourceCallSignaturesAreSubtypeOfTargetCallSignatures(classSymbol, implementedType, resolutionContext, comparisonInfo);
                if (!foundError) {
                    foundError = !this.sourceConstructSignaturesAreSubtypeOfTargetConstructSignatures(classSymbol, implementedType, resolutionContext, comparisonInfo);
                    if (!foundError) {
                        foundError = !this.sourceIndexSignaturesAreSubtypeOfTargetIndexSignatures(classSymbol, implementedType, resolutionContext, comparisonInfo);
                    }
                }
            }

            if (foundError) {
                context.postError(this.unitPath, classDecl.name.minChar, classDecl.name.getLength(), TypeScript.DiagnosticCode.Class_0_declares_interface_1_but_does_not_implement_it_NL_2, [classSymbol.getScopedName(), implementedType.getScopedName(), comparisonInfo.message], enclosingDecl);
            }
        };

        PullTypeResolver.prototype.hasClassTypeSymbolConflictAsValue = function (valueDeclAST, typeSymbol, enclosingDecl, context) {
            var typeSymbolAlias = this.currentUnit.getAliasSymbolForAST(valueDeclAST);
            var tempResolvingTypeNameAsNameExpression = context.resolvingTypeNameAsNameExpression;
            context.resolvingTypeNameAsNameExpression = true;
            var valueSymbol = this.computeNameExpression(valueDeclAST, enclosingDecl, context);
            context.resolvingTypeNameAsNameExpression = tempResolvingTypeNameAsNameExpression;
            var valueSymbolAlias = this.currentUnit.getAliasSymbolForAST(valueDeclAST);

            this.currentUnit.setAliasSymbolForAST(valueDeclAST, typeSymbolAlias);

            if (typeSymbolAlias && valueSymbolAlias) {
                return typeSymbolAlias != valueSymbolAlias;
            }

            if (!valueSymbol.hasFlag(16384 /* ClassConstructorVariable */)) {
                return true;
            }

            var associatedContainerType = valueSymbol.type ? valueSymbol.type.getAssociatedContainerType() : null;
            if (associatedContainerType) {
                return associatedContainerType != typeSymbol;
            }

            return true;
        };

        PullTypeResolver.prototype.typeCheckBase = function (typeDeclAst, typeSymbol, baseDeclAST, isExtendedType, enclosingDecl, context) {
            var _this = this;
            var typeDecl = this.getDeclForAST(typeDeclAst);
            var contextForBaseTypeResolution = new TypeScript.PullTypeResolutionContext();
            contextForBaseTypeResolution.isResolvingClassExtendedType = true;

            var baseType = this.resolveAST(baseDeclAST, false, enclosingDecl, context);
            contextForBaseTypeResolution.isResolvingClassExtendedType = false;

            var typeDeclIsClass = typeSymbol.isClass();

            if (!typeSymbol.isValidBaseKind(baseType, isExtendedType)) {
                if (baseType.isError()) {
                    var error = (baseType).getDiagnostic();
                    if (error) {
                        context.postError(this.unitPath, baseDeclAST.minChar, baseDeclAST.getLength(), error.diagnosticKey(), error.arguments(), enclosingDecl);
                    }
                } else if (isExtendedType) {
                    if (typeDeclIsClass) {
                        context.postError(this.unitPath, baseDeclAST.minChar, baseDeclAST.getLength(), TypeScript.DiagnosticCode.A_class_may_only_extend_another_class, null, enclosingDecl);
                    } else {
                        context.postError(this.unitPath, baseDeclAST.minChar, baseDeclAST.getLength(), TypeScript.DiagnosticCode.An_interface_may_only_extend_another_class_or_interface, null, enclosingDecl);
                    }
                } else {
                    context.postError(this.unitPath, baseDeclAST.minChar, baseDeclAST.getLength(), TypeScript.DiagnosticCode.A_class_may_only_implement_another_class_or_interface, null, enclosingDecl);
                }
                return;
            } else if (typeDeclIsClass && isExtendedType && baseDeclAST.nodeType() == 21 /* Name */) {
                if (this.hasClassTypeSymbolConflictAsValue(baseDeclAST, baseType, enclosingDecl, context)) {
                    context.postError(this.unitPath, baseDeclAST.minChar, baseDeclAST.getLength(), TypeScript.DiagnosticCode.Type_reference_0_in_extends_clause_doesn_t_reference_constructor_function_for_1, [(baseDeclAST).actualText, baseType.toString(enclosingDecl ? enclosingDecl.getSymbol() : null)], enclosingDecl);
                }
            }

            if ((baseType.getRootSymbol()).hasBase(typeSymbol.getRootSymbol())) {
                typeSymbol.setHasBaseTypeConflict();
                baseType.setHasBaseTypeConflict();

                context.postError(this.unitPath, typeDeclAst.name.minChar, typeDeclAst.name.getLength(), typeDeclIsClass ? TypeScript.DiagnosticCode.Class_0_is_recursively_referenced_as_a_base_type_of_itself : TypeScript.DiagnosticCode.Interface_0_is_recursively_referenced_as_a_base_type_of_itself, [typeSymbol.getScopedName()], enclosingDecl);
                return;
            }

            if (isExtendedType) {
                this.typeCheckIfTypeExtendsType(typeDeclAst, typeSymbol, baseType, enclosingDecl, context);
            } else {
                this.typeCheckIfClassImplementsType(typeDeclAst, typeSymbol, baseType, enclosingDecl, context);
            }

            this.checkSymbolPrivacy(typeSymbol, baseType, context, function (errorSymbol) {
                return _this.baseListPrivacyErrorReporter(typeDeclAst, typeSymbol, baseDeclAST, isExtendedType, errorSymbol, context);
            });
        };

        PullTypeResolver.prototype.typeCheckBases = function (typeDeclAst, typeSymbol, enclosingDecl, context) {
            if (!context.typeCheck()) {
                return;
            }

            if (!typeDeclAst.extendsList && !typeDeclAst.implementsList) {
                return;
            }

            if (typeDeclAst.extendsList) {
                for (var i = 0; i < typeDeclAst.extendsList.members.length; i++) {
                    this.typeCheckBase(typeDeclAst, typeSymbol, typeDeclAst.extendsList.members[i], true, enclosingDecl, context);
                }
            }

            if (typeSymbol.isClass()) {
                if (typeDeclAst.implementsList) {
                    for (var i = 0; i < typeDeclAst.implementsList.members.length; i++) {
                        this.typeCheckBase(typeDeclAst, typeSymbol, typeDeclAst.implementsList.members[i], false, enclosingDecl, context);
                    }
                }
            } else if (typeDeclAst.implementsList) {
                context.postError(this.unitPath, typeDeclAst.implementsList.minChar, typeDeclAst.implementsList.getLength(), TypeScript.DiagnosticCode.An_interface_cannot_implement_another_type, null, enclosingDecl);
            }
        };

        PullTypeResolver.prototype.checkAssignability = function (ast, source, target, enclosingDecl, context) {
            var comparisonInfo = new TypeComparisonInfo();

            var isAssignable = this.sourceIsAssignableToTarget(source, target, context, comparisonInfo);

            if (!isAssignable) {
                if (comparisonInfo.message) {
                    context.postError(this.unitPath, ast.minChar, ast.getLength(), TypeScript.DiagnosticCode.Cannot_convert_0_to_1_NL_2, [source.toString(), target.toString(), comparisonInfo.message], enclosingDecl);
                } else {
                    context.postError(this.unitPath, ast.minChar, ast.getLength(), TypeScript.DiagnosticCode.Cannot_convert_0_to_1, [source.toString(), target.toString()], enclosingDecl);
                }
            }
        };

        PullTypeResolver.prototype.isValidLHS = function (ast, expressionSymbol) {
            var expressionTypeSymbol = expressionSymbol.type;

            if (ast.nodeType() === 36 /* ElementAccessExpression */ || this.isAnyOrEquivalent(expressionTypeSymbol)) {
                return true;
            } else if (!expressionSymbol.isType() || expressionTypeSymbol.isArray()) {
                return ((expressionSymbol.kind & TypeScript.PullElementKind.SomeLHS) != 0) && !expressionSymbol.hasFlag(4096 /* Enum */);
            }

            return false;
        };

        PullTypeResolver.prototype.checkForSuperMemberAccess = function (memberAccessExpression, resolvedName, enclosingDecl, context) {
            if (resolvedName) {
                if (memberAccessExpression.operand1.nodeType() === 31 /* SuperExpression */ && !resolvedName.isError() && resolvedName.kind !== 65536 /* Method */) {
                    context.postError(this.unitPath, memberAccessExpression.operand2.minChar, memberAccessExpression.operand2.getLength(), TypeScript.DiagnosticCode.Only_public_instance_methods_of_the_base_class_are_accessible_via_the_super_keyword, [], enclosingDecl);
                    return true;
                }
            }

            return false;
        };

        PullTypeResolver.prototype.checkForPrivateMemberAccess = function (memberAccessExpression, expressionType, resolvedName, enclosingDecl, context) {
            if (resolvedName) {
                if (resolvedName.hasFlag(2 /* Private */)) {
                    var memberContainer = resolvedName.getContainer();
                    if (memberContainer && memberContainer.kind === 33554432 /* ConstructorType */) {
                        memberContainer = memberContainer.getAssociatedContainerType();
                    }

                    if (memberContainer && memberContainer.isClass()) {
                        var containingClass = enclosingDecl;

                        while (containingClass && containingClass.kind != 8 /* Class */) {
                            containingClass = containingClass.getParentDecl();
                        }

                        if (!containingClass || containingClass.getSymbol() !== memberContainer) {
                            var name = memberAccessExpression.operand2;
                            context.postError(this.unitPath, name.minChar, name.getLength(), TypeScript.DiagnosticCode._0_1_is_inaccessible, [memberContainer.toString(null, false), name.actualText], enclosingDecl);
                            return true;
                        }
                    }
                }
            }

            return false;
        };

        PullTypeResolver.prototype.checkForStaticMemberAccess = function (memberAccessExpression, expressionType, resolvedName, enclosingDecl, context) {
            if (expressionType && resolvedName && !resolvedName.isError()) {
                if (expressionType.isClass() || expressionType.kind === 33554432 /* ConstructorType */) {
                    var name = memberAccessExpression.operand2;

                    if (resolvedName.hasFlag(16 /* Static */) || this.isPrototypeMember(memberAccessExpression, enclosingDecl, context)) {
                        if (expressionType.kind !== 33554432 /* ConstructorType */) {
                            context.postError(this.unitPath, name.minChar, name.getLength(), TypeScript.DiagnosticCode.Static_member_cannot_be_accessed_off_an_instance_variable, null, enclosingDecl);
                            return true;
                        }
                    }
                }
            }

            return false;
        };
        PullTypeResolver.typeCheckCallBacks = [];

        PullTypeResolver.globalTypeCheckPhase = 0;
        return PullTypeResolver;
    })();
    TypeScript.PullTypeResolver = PullTypeResolver;

    var TypeComparisonInfo = (function () {
        function TypeComparisonInfo(sourceComparisonInfo) {
            this.onlyCaptureFirstError = false;
            this.flags = 0 /* SuccessfulComparison */;
            this.message = "";
            this.stringConstantVal = null;
            this.indent = 1;
            if (sourceComparisonInfo) {
                this.flags = sourceComparisonInfo.flags;
                this.onlyCaptureFirstError = sourceComparisonInfo.onlyCaptureFirstError;
                this.stringConstantVal = sourceComparisonInfo.stringConstantVal;
                this.indent = sourceComparisonInfo.indent + 1;
            }
        }
        TypeComparisonInfo.prototype.indentString = function () {
            var result = "";

            for (var i = 0; i < this.indent; i++) {
                result += "\t";
            }

            return result;
        };

        TypeComparisonInfo.prototype.addMessage = function (message) {
            if (!this.onlyCaptureFirstError && this.message) {
                this.message = this.message + TypeScript.newLine() + this.indentString() + message;
            } else {
                this.message = this.indentString() + message;
            }
        };

        TypeComparisonInfo.prototype.setMessage = function (message) {
            this.message = this.indentString() + message;
        };
        return TypeComparisonInfo;
    })();
    TypeScript.TypeComparisonInfo = TypeComparisonInfo;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.declCacheHit = 0;
    TypeScript.declCacheMiss = 0;
    TypeScript.symbolCacheHit = 0;
    TypeScript.symbolCacheMiss = 0;

    var sentinalEmptyArray = [];

    var SemanticInfo = (function () {
        function SemanticInfo(compilationUnitPath) {
            this.topLevelDecls = [];
            this.topLevelSynthesizedDecls = [];
            this.declASTMap = new TypeScript.DataMap();
            this.astDeclMap = new TypeScript.DataMap();
            this.astSymbolMap = new TypeScript.DataMap();
            this.astAliasSymbolMap = new TypeScript.DataMap();
            this.symbolASTMap = new TypeScript.DataMap();
            this.astCallResolutionDataMap = TypeScript.Collections.createHashTable(TypeScript.Collections.DefaultHashTableCapacity, function (k) {
                return k;
            });
            this.syntaxElementSymbolMap = new TypeScript.DataMap();
            this.symbolSyntaxElementMap = new TypeScript.DataMap();
            this.hasBeenTypeChecked = false;
            this.compilationUnitPath = compilationUnitPath;
        }
        SemanticInfo.prototype.addTopLevelDecl = function (decl) {
            this.topLevelDecls[this.topLevelDecls.length] = decl;
        };

        SemanticInfo.prototype.setTypeChecked = function (shouldTC) {
            if (typeof shouldTC === "undefined") { shouldTC = true; }
            this.hasBeenTypeChecked = shouldTC;
        };
        SemanticInfo.prototype.getTypeChecked = function () {
            return this.hasBeenTypeChecked;
        };
        SemanticInfo.prototype.invalidate = function () {
            this.astSymbolMap = new TypeScript.DataMap();
            this.symbolASTMap = new TypeScript.DataMap();
        };

        SemanticInfo.prototype.getTopLevelDecls = function () {
            return this.topLevelDecls;
        };

        SemanticInfo.prototype.getPath = function () {
            return this.compilationUnitPath;
        };

        SemanticInfo.prototype.addSynthesizedDecl = function (decl) {
            this.topLevelSynthesizedDecls[this.topLevelSynthesizedDecls.length] = decl;
        };

        SemanticInfo.prototype.getSynthesizedDecls = function () {
            return this.topLevelSynthesizedDecls;
        };

        SemanticInfo.prototype.cleanSynthesizedDecls = function () {
            this.topLevelSynthesizedDecls = [];
        };

        SemanticInfo.prototype.getDeclForAST = function (ast) {
            if (TypeScript.useDirectTypeStorage) {
                return ast.decl;
            }

            return this.astDeclMap.read(ast.astIDString);
        };

        SemanticInfo.prototype.setDeclForAST = function (ast, decl) {
            if (TypeScript.useDirectTypeStorage) {
                ast.decl = decl;
                return;
            }

            this.astDeclMap.link(ast.astIDString, decl);
        };

        SemanticInfo.prototype.getASTForDecl = function (decl) {
            if (TypeScript.useDirectTypeStorage) {
                return decl.ast;
            }

            return this.declASTMap.read(decl.declIDString);
        };

        SemanticInfo.prototype.setASTForDecl = function (decl, ast) {
            if (TypeScript.useDirectTypeStorage) {
                decl.ast = ast;
                return;
            }

            this.declASTMap.link(decl.declIDString, ast);
        };

        SemanticInfo.prototype.setSymbolForAST = function (ast, symbol) {
            if (TypeScript.useDirectTypeStorage) {
                ast.symbol = symbol;
                symbol.ast = ast;
                return;
            }

            this.astSymbolMap.link(ast.astIDString, symbol);
            this.symbolASTMap.link(symbol.pullSymbolIDString, ast);
        };

        SemanticInfo.prototype.getSymbolForAST = function (ast) {
            if (TypeScript.useDirectTypeStorage) {
                return (ast).symbol;
            }
            return this.astSymbolMap.read(ast.astIDString);
        };

        SemanticInfo.prototype.getASTForSymbol = function (symbol) {
            if (TypeScript.useDirectTypeStorage) {
                return symbol.ast;
            }
            return this.symbolASTMap.read(symbol.pullSymbolIDString);
        };

        SemanticInfo.prototype.setAliasSymbolForAST = function (ast, symbol) {
            if (TypeScript.useDirectTypeStorage) {
                ast.aliasSymbol = symbol;
                return;
            }
            this.astAliasSymbolMap.link(ast.astIDString, symbol);
        };

        SemanticInfo.prototype.getAliasSymbolForAST = function (ast) {
            if (TypeScript.useDirectTypeStorage) {
                return (ast).aliasSymbol;
            }
            return this.astAliasSymbolMap.read(ast.astIDString);
        };

        SemanticInfo.prototype.getCallResolutionDataForAST = function (ast) {
            if (TypeScript.useDirectTypeStorage) {
                return (ast).callResolutionData;
            }
            return this.astCallResolutionDataMap.get(ast.astID);
        };

        SemanticInfo.prototype.setCallResolutionDataForAST = function (ast, callResolutionData) {
            if (callResolutionData) {
                if (TypeScript.useDirectTypeStorage) {
                    (ast).callResolutionData = callResolutionData;
                    return;
                }
                this.astCallResolutionDataMap.set(ast.astID, callResolutionData);
            }
        };

        SemanticInfo.prototype.getDiagnostics = function (semanticErrors) {
            for (var i = 0; i < this.topLevelDecls.length; i++) {
                TypeScript.getDiagnosticsFromEnclosingDecl(this.topLevelDecls[i], semanticErrors);
            }
        };
        return SemanticInfo;
    })();
    TypeScript.SemanticInfo = SemanticInfo;

    var SemanticInfoChain = (function () {
        function SemanticInfoChain() {
            this.units = [new SemanticInfo("")];
            this.declCache = new TypeScript.BlockIntrinsics();
            this.symbolCache = new TypeScript.BlockIntrinsics();
            this.unitCache = new TypeScript.BlockIntrinsics();
            this.topLevelDecls = [];
            this.anyTypeSymbol = null;
            this.booleanTypeSymbol = null;
            this.numberTypeSymbol = null;
            this.stringTypeSymbol = null;
            this.nullTypeSymbol = null;
            this.undefinedTypeSymbol = null;
            this.voidTypeSymbol = null;
            if (TypeScript.globalBinder) {
                TypeScript.globalBinder.semanticInfoChain = this;
            }

            var globalDecl = this.getGlobalDecl();
            var globalInfo = this.units[0];
            globalInfo.addTopLevelDecl(globalDecl);
        }
        SemanticInfoChain.prototype.addPrimitiveType = function (name, globalDecl) {
            var span = new TypeScript.TextSpan(0, 0);
            var decl = new TypeScript.PullDecl(name, name, 2 /* Primitive */, 0 /* None */, span, "");
            var symbol = new TypeScript.PullPrimitiveTypeSymbol(name);

            symbol.addDeclaration(decl);
            decl.setSymbol(symbol);

            symbol.setResolved();

            if (globalDecl) {
                globalDecl.addChildDecl(decl);
            }

            return symbol;
        };

        SemanticInfoChain.prototype.addPrimitiveValue = function (name, type, globalDecl) {
            var span = new TypeScript.TextSpan(0, 0);
            var decl = new TypeScript.PullDecl(name, name, 1024 /* Variable */, 8 /* Ambient */, span, "");
            var symbol = new TypeScript.PullSymbol(name, 1024 /* Variable */);

            symbol.addDeclaration(decl);
            decl.setSymbol(symbol);
            symbol.type = type;
            symbol.setResolved();

            globalDecl.addChildDecl(decl);
        };

        SemanticInfoChain.prototype.getGlobalDecl = function () {
            var span = new TypeScript.TextSpan(0, 0);
            var globalDecl = new TypeScript.PullDecl("", "", 0 /* Global */, 0 /* None */, span, "");

            this.anyTypeSymbol = this.addPrimitiveType("any", globalDecl);
            this.booleanTypeSymbol = this.addPrimitiveType("boolean", globalDecl);
            this.numberTypeSymbol = this.addPrimitiveType("number", globalDecl);
            this.stringTypeSymbol = this.addPrimitiveType("string", globalDecl);
            this.voidTypeSymbol = this.addPrimitiveType("void", globalDecl);

            this.nullTypeSymbol = this.addPrimitiveType("null", null);
            this.undefinedTypeSymbol = this.addPrimitiveType("undefined", null);
            this.addPrimitiveValue("undefined", this.undefinedTypeSymbol, globalDecl);
            this.addPrimitiveValue("null", this.nullTypeSymbol, globalDecl);

            return globalDecl;
        };

        SemanticInfoChain.prototype.addUnit = function (unit) {
            this.units[this.units.length] = unit;
            this.unitCache[unit.getPath()] = unit;
        };

        SemanticInfoChain.prototype.getUnit = function (compilationUnitPath) {
            return this.unitCache[compilationUnitPath];
        };

        SemanticInfoChain.prototype.updateUnit = function (oldUnit, newUnit) {
            for (var i = 0; i < this.units.length; i++) {
                if (this.units[i].getPath() === oldUnit.getPath()) {
                    this.units[i] = newUnit;
                    this.unitCache[oldUnit.getPath()] = newUnit;
                    return;
                }
            }
        };

        SemanticInfoChain.prototype.collectAllTopLevelDecls = function () {
            if (this.topLevelDecls.length) {
                return this.topLevelDecls;
            }

            var unitDecls;

            for (var i = 0; i < this.units.length; i++) {
                unitDecls = this.units[i].getTopLevelDecls();
                for (var j = 0; j < unitDecls.length; j++) {
                    this.topLevelDecls[this.topLevelDecls.length] = unitDecls[j];
                }
            }

            return this.topLevelDecls;
        };

        SemanticInfoChain.prototype.collectAllSynthesizedDecls = function () {
            var decls = [];
            var synthDecls;

            for (var i = 0; i < this.units.length; i++) {
                synthDecls = this.units[i].getSynthesizedDecls();
                for (var j = 0; j < synthDecls.length; j++) {
                    decls[decls.length] = synthDecls[j];
                }
            }

            return decls;
        };

        SemanticInfoChain.prototype.getDeclPathCacheID = function (declPath, declKind) {
            var cacheID = "";

            for (var i = 0; i < declPath.length; i++) {
                cacheID += "#" + declPath[i];
            }

            return cacheID + "#" + declKind.toString();
        };

        SemanticInfoChain.prototype.findTopLevelSymbol = function (name, kind, stopAtFile) {
            var cacheID = this.getDeclPathCacheID([name], kind);

            var symbol = this.symbolCache[name];

            if (!symbol) {
                var topLevelDecls = this.collectAllTopLevelDecls();
                var foundDecls = null;

                for (var i = 0; i < topLevelDecls.length; i++) {
                    foundDecls = topLevelDecls[i].searchChildDecls(name, kind);

                    if (foundDecls.length) {
                        symbol = foundDecls[0].getSymbol();
                        break;
                    }

                    if (topLevelDecls[i].name == stopAtFile) {
                        break;
                    }
                }

                if (symbol) {
                    this.symbolCache[cacheID] = symbol;

                    symbol.addCacheID(cacheID);
                }
            }

            return symbol;
        };

        SemanticInfoChain.prototype.findDecls = function (declPath, declKind) {
            var cacheID = this.getDeclPathCacheID(declPath, declKind);

            if (declPath.length) {
                var cachedDecls = this.declCache[cacheID];

                if (cachedDecls && cachedDecls.length) {
                    TypeScript.declCacheHit++;
                    return cachedDecls;
                }
            }

            TypeScript.declCacheMiss++;

            if (declKind == 32 /* DynamicModule */ && declPath.length == 1) {
                var path = declPath[0];

                if (TypeScript.isRooted(path)) {
                    var unit = this.unitCache[path];

                    if (unit) {
                        var decl = unit.getTopLevelDecls()[0].getChildDecls()[0];

                        if (decl.kind == 32 /* DynamicModule */) {
                            return [decl];
                        }
                    }

                    return TypeScript.sentinelEmptyArray;
                }
            }

            var declsToSearch = this.collectAllTopLevelDecls();

            var decls = TypeScript.sentinelEmptyArray;
            var path;
            var foundDecls = TypeScript.sentinelEmptyArray;
            var keepSearching = (declKind & TypeScript.PullElementKind.SomeContainer) || (declKind & 16 /* Interface */);

            for (var i = 0; i < declPath.length; i++) {
                path = declPath[i];
                decls = TypeScript.sentinelEmptyArray;

                for (var j = 0; j < declsToSearch.length; j++) {
                    foundDecls = declsToSearch[j].searchChildDecls(path, declKind);

                    for (var k = 0; k < foundDecls.length; k++) {
                        if (decls == TypeScript.sentinelEmptyArray) {
                            decls = [];
                        }
                        decls[decls.length] = foundDecls[k];
                    }

                    if (foundDecls.length && !keepSearching) {
                        break;
                    }
                }

                declsToSearch = decls;

                if (!declsToSearch) {
                    break;
                }
            }

            if (decls.length) {
                this.declCache[cacheID] = decls;
            }

            return decls;
        };

        SemanticInfoChain.prototype.findDeclsFromPath = function (declPath, declKind) {
            var declString = [];

            for (var i = 0, n = declPath.length; i < n; i++) {
                if (declPath[i].kind & 1 /* Script */) {
                    continue;
                }

                declString.push(declPath[i].name);
            }

            return this.findDecls(declString, declKind);
        };

        SemanticInfoChain.prototype.findSymbol = function (declPath, declType) {
            var cacheID = this.getDeclPathCacheID(declPath, declType);

            if (declPath.length) {
                var cachedSymbol = this.symbolCache[cacheID];

                if (cachedSymbol) {
                    TypeScript.symbolCacheHit++;
                    return cachedSymbol;
                }
            }

            TypeScript.symbolCacheMiss++;

            var decls = this.findDecls(declPath, declType);
            var symbol = null;

            if (decls.length) {
                symbol = decls[0].getSymbol();

                if (symbol) {
                    this.symbolCache[cacheID] = symbol;

                    symbol.addCacheID(cacheID);
                }
            }

            return symbol;
        };

        SemanticInfoChain.prototype.cacheGlobalSymbol = function (symbol, kind) {
            var cacheID1 = this.getDeclPathCacheID([symbol.name], kind);
            var cacheID2 = this.getDeclPathCacheID([symbol.name], symbol.kind);

            if (!this.symbolCache[cacheID1]) {
                this.symbolCache[cacheID1] = symbol;
                symbol.addCacheID(cacheID1);
            }

            if (!this.symbolCache[cacheID2]) {
                this.symbolCache[cacheID2] = symbol;
                symbol.addCacheID(cacheID2);
            }
        };

        SemanticInfoChain.prototype.cleanDecl = function (decl) {
            decl.setSymbol(null);
            decl.setSignatureSymbol(null);
            decl.setSpecializingSignatureSymbol(null);
            decl.setIsBound(false);

            var children = decl.getChildDecls();

            for (var i = 0; i < children.length; i++) {
                this.cleanDecl(children[i]);
            }

            var typeParameters = decl.getTypeParameters();

            for (var i = 0; i < typeParameters.length; i++) {
                this.cleanDecl(typeParameters[i]);
            }

            var valueDecl = decl.getValueDecl();

            if (valueDecl) {
                this.cleanDecl(valueDecl);
            }
        };

        SemanticInfoChain.prototype.cleanAllDecls = function () {
            var topLevelDecls = this.collectAllTopLevelDecls();

            for (var i = 1; i < topLevelDecls.length; i++) {
                this.cleanDecl(topLevelDecls[i]);
            }

            var synthesizedDecls = this.collectAllSynthesizedDecls();

            for (var i = 0; i < synthesizedDecls.length; i++) {
                this.cleanDecl(synthesizedDecls[i]);
            }

            this.cleanAllSynthesizedDecls();
            this.topLevelDecls = [];
        };

        SemanticInfoChain.prototype.cleanAllSynthesizedDecls = function () {
            for (var i = 0; i < this.units.length; i++) {
                this.units[i].cleanSynthesizedDecls();
            }
        };

        SemanticInfoChain.prototype.update = function () {
            this.declCache = new TypeScript.BlockIntrinsics();
            this.symbolCache = new TypeScript.BlockIntrinsics();
            this.units[0] = new SemanticInfo("");
            this.units[0].addTopLevelDecl(this.getGlobalDecl());
            this.cleanAllDecls();

            for (var unit in this.unitCache) {
                if (this.unitCache[unit]) {
                    this.unitCache[unit].invalidate();
                }
            }
        };

        SemanticInfoChain.prototype.invalidateUnit = function (compilationUnitPath) {
            var unit = this.unitCache[compilationUnitPath];
            if (unit) {
                unit.invalidate();
            }
        };

        SemanticInfoChain.prototype.forceTypeCheck = function (compilationUnitPath) {
            var unit = this.unitCache[compilationUnitPath];
            if (unit) {
                unit.setTypeChecked(false);
            }
        };

        SemanticInfoChain.prototype.getDeclForAST = function (ast, unitPath) {
            var unit = this.unitCache[unitPath];

            if (unit) {
                return unit.getDeclForAST(ast);
            }

            return null;
        };

        SemanticInfoChain.prototype.getASTForDecl = function (decl) {
            var unit = this.unitCache[decl.getScriptName()];

            if (unit) {
                return unit.getASTForDecl(decl);
            }

            return null;
        };

        SemanticInfoChain.prototype.getSymbolForAST = function (ast, unitPath) {
            if (TypeScript.useDirectTypeStorage) {
                return (ast).symbol;
            }

            var unit = this.unitCache[unitPath];

            if (unit) {
                return unit.getSymbolForAST(ast);
            }

            return null;
        };

        SemanticInfoChain.prototype.getASTForSymbol = function (symbol, unitPath) {
            if (TypeScript.useDirectTypeStorage) {
                return symbol.ast;
            }

            var unit = this.unitCache[unitPath];

            if (unit) {
                return unit.getASTForSymbol(symbol);
            }

            return null;
        };

        SemanticInfoChain.prototype.setSymbolForAST = function (ast, symbol, unitPath) {
            if (TypeScript.useDirectTypeStorage) {
                ast.symbol = symbol;
                return;
            }

            var unit = this.unitCache[unitPath];

            if (unit) {
                unit.setSymbolForAST(ast, symbol);
            }
        };

        SemanticInfoChain.prototype.getAliasSymbolForAST = function (ast, unitPath) {
            if (TypeScript.useDirectTypeStorage) {
                return (ast).aliasSymbol;
            }

            var unit = this.unitCache[unitPath];

            if (unit) {
                return unit.getAliasSymbolForAST(ast);
            }

            return null;
        };

        SemanticInfoChain.prototype.removeSymbolFromCache = function (symbol) {
            var path = [symbol.name];
            var kind = (symbol.kind & TypeScript.PullElementKind.SomeType) !== 0 ? TypeScript.PullElementKind.SomeType : TypeScript.PullElementKind.SomeValue;

            var kindID = this.getDeclPathCacheID(path, kind);
            var symID = this.getDeclPathCacheID(path, symbol.kind);

            symbol.addCacheID(kindID);
            symbol.addCacheID(symID);

            symbol.invalidateCachedIDs(this.symbolCache);
        };

        SemanticInfoChain.prototype.postDiagnostics = function () {
            var errors = [];

            for (var i = 1; i < this.units.length; i++) {
                this.units[i].getDiagnostics(errors);
            }

            return errors;
        };
        return SemanticInfoChain;
    })();
    TypeScript.SemanticInfoChain = SemanticInfoChain;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var DeclCollectionContext = (function () {
        function DeclCollectionContext(semanticInfo, scriptName) {
            this.semanticInfo = semanticInfo;
            this.scriptName = scriptName;
            this.isDeclareFile = false;
            this.parentChain = new Array();
            this.containingModuleHasExportAssignmentArray = [false];
            this.isParsingAmbientModuleArray = [false];
            this.foundValueDecl = false;
        }
        DeclCollectionContext.prototype.getParent = function () {
            return this.parentChain ? this.parentChain[this.parentChain.length - 1] : null;
        };

        DeclCollectionContext.prototype.pushParent = function (parentDecl) {
            if (parentDecl) {
                this.parentChain[this.parentChain.length] = parentDecl;
            }
        };

        DeclCollectionContext.prototype.popParent = function () {
            this.parentChain.length--;
        };

        DeclCollectionContext.prototype.containingModuleHasExportAssignment = function () {
            TypeScript.Debug.assert(this.containingModuleHasExportAssignmentArray.length > 0);
            return TypeScript.ArrayUtilities.last(this.containingModuleHasExportAssignmentArray);
        };

        DeclCollectionContext.prototype.isParsingAmbientModule = function () {
            TypeScript.Debug.assert(this.isParsingAmbientModuleArray.length > 0);
            return TypeScript.ArrayUtilities.last(this.isParsingAmbientModuleArray);
        };
        return DeclCollectionContext;
    })();
    TypeScript.DeclCollectionContext = DeclCollectionContext;

    function preCollectImportDecls(ast, parentAST, context) {
        var importDecl = ast;
        var declFlags = 0 /* None */;
        var span = TypeScript.TextSpan.fromBounds(importDecl.minChar, importDecl.limChar);

        var parent = context.getParent();

        if (!context.containingModuleHasExportAssignment() && TypeScript.hasFlag(importDecl.getVarFlags(), 1 /* Exported */)) {
            declFlags |= 1 /* Exported */;
        }

        if (parent && (parent.kind === 536870912 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.PullDecl(importDecl.id.text(), importDecl.id.actualText, 256 /* TypeAlias */, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(ast, decl);
        context.semanticInfo.setASTForDecl(decl, ast);

        parent.addChildDecl(decl);
        decl.setParentDecl(parent);

        return false;
    }

    function preCollectModuleDecls(ast, parentAST, context) {
        var moduleDecl = ast;
        var declFlags = 0 /* None */;
        var modName = (moduleDecl.name).text();
        var isDynamic = TypeScript.isQuoted(modName) || TypeScript.hasFlag(moduleDecl.getModuleFlags(), 512 /* IsDynamic */);
        var kind = 4 /* Container */;

        if (!context.containingModuleHasExportAssignment() && (TypeScript.hasFlag(moduleDecl.getModuleFlags(), 1 /* Exported */) || context.isParsingAmbientModule())) {
            declFlags |= 1 /* Exported */;
        }

        if (TypeScript.hasFlag(moduleDecl.getModuleFlags(), 8 /* Ambient */) || context.isParsingAmbientModule() || context.isDeclareFile) {
            declFlags |= 8 /* Ambient */;
        }

        if (TypeScript.hasFlag(moduleDecl.getModuleFlags(), 128 /* IsEnum */)) {
            declFlags |= (4096 /* Enum */ | 131072 /* InitializedEnum */);
            kind = 64 /* Enum */;
        } else {
            kind = isDynamic ? 32 /* DynamicModule */ : 4 /* Container */;
        }

        var span = TypeScript.TextSpan.fromBounds(moduleDecl.minChar, moduleDecl.limChar);

        var decl = new TypeScript.PullDecl(modName, (moduleDecl.name).actualText, kind, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(ast, decl);
        context.semanticInfo.setASTForDecl(decl, ast);

        var parent = context.getParent();
        parent.addChildDecl(decl);
        decl.setParentDecl(parent);

        context.pushParent(decl);

        context.containingModuleHasExportAssignmentArray.push(TypeScript.ArrayUtilities.any(moduleDecl.members.members, function (m) {
            return m.nodeType() === 88 /* ExportAssignment */;
        }));
        context.isParsingAmbientModuleArray.push(context.isDeclareFile || TypeScript.ArrayUtilities.last(context.isParsingAmbientModuleArray) || TypeScript.hasFlag(moduleDecl.getModuleFlags(), 8 /* Ambient */));

        return true;
    }

    function preCollectClassDecls(classDecl, parentAST, context) {
        var declFlags = 0 /* None */;
        var constructorDeclKind = 1024 /* Variable */;

        if (!context.containingModuleHasExportAssignment() && (TypeScript.hasFlag(classDecl.getVarFlags(), 1 /* Exported */) || context.isParsingAmbientModule())) {
            declFlags |= 1 /* Exported */;
        }

        if (TypeScript.hasFlag(classDecl.getVarFlags(), 8 /* Ambient */) || context.isParsingAmbientModule() || context.isDeclareFile) {
            declFlags |= 8 /* Ambient */;
        }

        var span = TypeScript.TextSpan.fromBounds(classDecl.minChar, classDecl.limChar);

        var decl = new TypeScript.PullDecl(classDecl.name.text(), classDecl.name.actualText, 8 /* Class */, declFlags, span, context.scriptName);

        var constructorDecl = new TypeScript.PullDecl(classDecl.name.text(), classDecl.name.actualText, constructorDeclKind, declFlags | 16384 /* ClassConstructorVariable */, span, context.scriptName);

        decl.setValueDecl(constructorDecl);

        var parent = context.getParent();
        parent.addChildDecl(decl);
        parent.addChildDecl(constructorDecl);
        decl.setParentDecl(parent);
        constructorDecl.setParentDecl(parent);

        context.pushParent(decl);

        context.semanticInfo.setDeclForAST(classDecl, decl);
        context.semanticInfo.setASTForDecl(decl, classDecl);
        context.semanticInfo.setASTForDecl(constructorDecl, classDecl);

        return true;
    }

    function createObjectTypeDeclaration(interfaceDecl, context) {
        var declFlags = 0 /* None */;

        var span = TypeScript.TextSpan.fromBounds(interfaceDecl.minChar, interfaceDecl.limChar);

        var parent = context.getParent();

        if (parent && (parent.kind === 536870912 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.PullDecl("", "", 8388608 /* ObjectType */, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(interfaceDecl, decl);
        context.semanticInfo.setASTForDecl(decl, interfaceDecl);

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        return true;
    }

    function preCollectInterfaceDecls(interfaceDecl, parentAST, context) {
        var declFlags = 0 /* None */;

        if (interfaceDecl.getFlags() & 8 /* TypeReference */) {
            return createObjectTypeDeclaration(interfaceDecl, context);
        }

        if (!context.containingModuleHasExportAssignment() && (TypeScript.hasFlag(interfaceDecl.getVarFlags(), 1 /* Exported */) || context.isParsingAmbientModule())) {
            declFlags |= 1 /* Exported */;
        }

        var span = TypeScript.TextSpan.fromBounds(interfaceDecl.minChar, interfaceDecl.limChar);

        var decl = new TypeScript.PullDecl(interfaceDecl.name.text(), interfaceDecl.name.actualText, 16 /* Interface */, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(interfaceDecl, decl);
        context.semanticInfo.setASTForDecl(decl, interfaceDecl);

        var parent = context.getParent();

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        return true;
    }

    function preCollectParameterDecl(argDecl, parentAST, context) {
        var declFlags = 0 /* None */;

        if (TypeScript.hasFlag(argDecl.getVarFlags(), 2 /* Private */)) {
            declFlags |= 2 /* Private */;
        } else {
            declFlags |= 4 /* Public */;
        }

        if (TypeScript.hasFlag(argDecl.getFlags(), 4 /* OptionalName */) || TypeScript.hasFlag(argDecl.id.getFlags(), 4 /* OptionalName */)) {
            declFlags |= 128 /* Optional */;
        }

        var parent = context.getParent();

        if (parent && (parent.kind === 536870912 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var span = TypeScript.TextSpan.fromBounds(argDecl.minChar, argDecl.limChar);

        var decl = new TypeScript.PullDecl(argDecl.id.text(), argDecl.id.actualText, 2048 /* Parameter */, declFlags, span, context.scriptName);

        parent.addChildDecl(decl);
        decl.setParentDecl(parent);

        if (TypeScript.hasFlag(argDecl.getVarFlags(), 256 /* Property */)) {
            var propDecl = new TypeScript.PullDecl(argDecl.id.text(), argDecl.id.actualText, 4096 /* Property */, declFlags, span, context.scriptName);
            propDecl.setValueDecl(decl);
            decl.setFlag(8388608 /* PropertyParameter */);
            context.parentChain[context.parentChain.length - 2].addChildDecl(propDecl);
            propDecl.setParentDecl(context.parentChain[context.parentChain.length - 2]);
            context.semanticInfo.setASTForDecl(decl, argDecl);
            context.semanticInfo.setASTForDecl(propDecl, argDecl);
            context.semanticInfo.setDeclForAST(argDecl, propDecl);
        } else {
            context.semanticInfo.setASTForDecl(decl, argDecl);
            context.semanticInfo.setDeclForAST(argDecl, decl);
        }

        if (argDecl.typeExpr && ((argDecl.typeExpr).term.nodeType() === 15 /* InterfaceDeclaration */ || (argDecl.typeExpr).term.nodeType() === 13 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo, context.scriptName);

            if (parent) {
                declCollectionContext.pushParent(parent);
            }

            TypeScript.getAstWalkerFactory().walk((argDecl.typeExpr).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return false;
    }

    function preCollectTypeParameterDecl(typeParameterDecl, parentAST, context) {
        var declFlags = 0 /* None */;

        var span = TypeScript.TextSpan.fromBounds(typeParameterDecl.minChar, typeParameterDecl.limChar);

        var parent = context.getParent();

        if (parent && (parent.kind === 536870912 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.PullDecl(typeParameterDecl.name.text(), typeParameterDecl.name.actualText, 8192 /* TypeParameter */, declFlags, span, context.scriptName);
        context.semanticInfo.setASTForDecl(decl, typeParameterDecl);
        context.semanticInfo.setDeclForAST(typeParameterDecl, decl);

        parent.addChildDecl(decl);
        decl.setParentDecl(parent);

        if (typeParameterDecl.constraint && ((typeParameterDecl.constraint).term.nodeType() === 15 /* InterfaceDeclaration */ || (typeParameterDecl.constraint).term.nodeType() === 13 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo, context.scriptName);

            if (parent) {
                declCollectionContext.pushParent(parent);
            }

            TypeScript.getAstWalkerFactory().walk((typeParameterDecl.constraint).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }

    function createPropertySignature(propertyDecl, context) {
        var declFlags = 4 /* Public */;
        var parent = context.getParent();
        var declType = parent.kind === 64 /* Enum */ ? 67108864 /* EnumMember */ : 4096 /* Property */;

        if (TypeScript.hasFlag(propertyDecl.id.getFlags(), 4 /* OptionalName */)) {
            declFlags |= 128 /* Optional */;
        }

        if (propertyDecl.constantValue !== null) {
            declFlags |= 524288 /* Constant */;
        }

        var span = TypeScript.TextSpan.fromBounds(propertyDecl.minChar, propertyDecl.limChar);

        var decl = new TypeScript.PullDecl(propertyDecl.id.text(), propertyDecl.id.actualText, declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(propertyDecl, decl);
        context.semanticInfo.setASTForDecl(decl, propertyDecl);

        parent.addChildDecl(decl);
        decl.setParentDecl(parent);

        if (propertyDecl.typeExpr && ((propertyDecl.typeExpr).term.nodeType() === 15 /* InterfaceDeclaration */ || (propertyDecl.typeExpr).term.nodeType() === 13 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo, context.scriptName);

            if (parent) {
                declCollectionContext.pushParent(parent);
            }

            TypeScript.getAstWalkerFactory().walk((propertyDecl.typeExpr).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return false;
    }

    function createMemberVariableDeclaration(memberDecl, context) {
        var declFlags = 0 /* None */;
        var declType = 4096 /* Property */;

        if (TypeScript.hasFlag(memberDecl.getVarFlags(), 2 /* Private */)) {
            declFlags |= 2 /* Private */;
        } else {
            declFlags |= 4 /* Public */;
        }

        if (TypeScript.hasFlag(memberDecl.getVarFlags(), 16 /* Static */)) {
            declFlags |= 16 /* Static */;
        }

        var span = TypeScript.TextSpan.fromBounds(memberDecl.minChar, memberDecl.limChar);

        var decl = new TypeScript.PullDecl(memberDecl.id.text(), memberDecl.id.actualText, declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(memberDecl, decl);
        context.semanticInfo.setASTForDecl(decl, memberDecl);

        var parent = context.getParent();
        parent.addChildDecl(decl);
        decl.setParentDecl(parent);

        if (memberDecl.typeExpr && ((memberDecl.typeExpr).term.nodeType() === 15 /* InterfaceDeclaration */ || (memberDecl.typeExpr).term.nodeType() === 13 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo, context.scriptName);

            if (parent) {
                declCollectionContext.pushParent(parent);
            }

            TypeScript.getAstWalkerFactory().walk((memberDecl.typeExpr).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return false;
    }

    function createVariableDeclaration(varDecl, context) {
        var declFlags = 0 /* None */;
        var declType = 1024 /* Variable */;

        if (!context.containingModuleHasExportAssignment() && (TypeScript.hasFlag(varDecl.getVarFlags(), 1 /* Exported */) || context.isParsingAmbientModule())) {
            declFlags |= 1 /* Exported */;
        }

        if (TypeScript.hasFlag(varDecl.getVarFlags(), 8 /* Ambient */) || context.isParsingAmbientModule() || context.isDeclareFile) {
            declFlags |= 8 /* Ambient */;
        }

        var span = TypeScript.TextSpan.fromBounds(varDecl.minChar, varDecl.limChar);

        var parent = context.getParent();

        if (parent && (parent.kind === 536870912 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.PullDecl(varDecl.id.text(), varDecl.id.actualText, declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(varDecl, decl);
        context.semanticInfo.setASTForDecl(decl, varDecl);

        parent.addChildDecl(decl);
        decl.setParentDecl(parent);

        if (varDecl.typeExpr && ((varDecl.typeExpr).term.nodeType() === 15 /* InterfaceDeclaration */ || (varDecl.typeExpr).term.nodeType() === 13 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo, context.scriptName);

            if (parent) {
                declCollectionContext.pushParent(parent);
            }

            TypeScript.getAstWalkerFactory().walk((varDecl.typeExpr).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return false;
    }

    function preCollectVarDecls(ast, parentAST, context) {
        var varDecl = ast;
        var declFlags = 0 /* None */;
        var declType = 1024 /* Variable */;
        var isProperty = false;
        var isStatic = false;

        if (TypeScript.hasFlag(varDecl.getVarFlags(), 2048 /* ClassProperty */)) {
            return createMemberVariableDeclaration(varDecl, context);
        } else if (TypeScript.hasFlag(varDecl.getVarFlags(), 256 /* Property */)) {
            return createPropertySignature(varDecl, context);
        }

        return createVariableDeclaration(varDecl, context);
    }

    function createFunctionTypeDeclaration(functionTypeDeclAST, context) {
        var declFlags = 2048 /* Signature */;
        var declType = 16777216 /* FunctionType */;

        var span = TypeScript.TextSpan.fromBounds(functionTypeDeclAST.minChar, functionTypeDeclAST.limChar);

        var parent = context.getParent();

        if (parent && (parent.kind === 536870912 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.PullDecl("", "", declType, declFlags, span, context.semanticInfo.getPath());
        context.semanticInfo.setDeclForAST(functionTypeDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, functionTypeDeclAST);

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        if (functionTypeDeclAST.returnTypeAnnotation && ((functionTypeDeclAST.returnTypeAnnotation).term.nodeType() === 15 /* InterfaceDeclaration */ || (functionTypeDeclAST.returnTypeAnnotation).term.nodeType() === 13 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo, context.scriptName);

            declCollectionContext.pushParent(decl);

            TypeScript.getAstWalkerFactory().walk((functionTypeDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }

    function createConstructorTypeDeclaration(constructorTypeDeclAST, context) {
        var declFlags = 0 /* None */;
        var declType = 33554432 /* ConstructorType */;

        var span = TypeScript.TextSpan.fromBounds(constructorTypeDeclAST.minChar, constructorTypeDeclAST.limChar);

        var parent = context.getParent();

        if (parent && (parent.kind === 536870912 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.PullDecl("", "", declType, declFlags, span, context.semanticInfo.getPath());
        context.semanticInfo.setDeclForAST(constructorTypeDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, constructorTypeDeclAST);

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        if (constructorTypeDeclAST.returnTypeAnnotation && ((constructorTypeDeclAST.returnTypeAnnotation).term.nodeType() === 15 /* InterfaceDeclaration */ || (constructorTypeDeclAST.returnTypeAnnotation).term.nodeType() === 13 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo, context.scriptName);

            declCollectionContext.pushParent(decl);

            TypeScript.getAstWalkerFactory().walk((constructorTypeDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }

    function createFunctionDeclaration(funcDeclAST, context) {
        var declFlags = 0 /* None */;
        var declType = 16384 /* Function */;

        if (!context.containingModuleHasExportAssignment() && (TypeScript.hasFlag(funcDeclAST.getFunctionFlags(), 1 /* Exported */) || context.isParsingAmbientModule())) {
            declFlags |= 1 /* Exported */;
        }

        if (TypeScript.hasFlag(funcDeclAST.getFunctionFlags(), 8 /* Ambient */) || context.isParsingAmbientModule() || context.isDeclareFile) {
            declFlags |= 8 /* Ambient */;
        }

        if (!funcDeclAST.block) {
            declFlags |= 2048 /* Signature */;
        }

        var span = TypeScript.TextSpan.fromBounds(funcDeclAST.minChar, funcDeclAST.limChar);

        var parent = context.getParent();

        if (parent && (parent.kind === 536870912 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.PullDecl(funcDeclAST.name.text(), funcDeclAST.name.actualText, declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(funcDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, funcDeclAST);

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        if (funcDeclAST.returnTypeAnnotation && ((funcDeclAST.returnTypeAnnotation).term.nodeType() === 15 /* InterfaceDeclaration */ || (funcDeclAST.returnTypeAnnotation).term.nodeType() === 13 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo, context.scriptName);

            declCollectionContext.pushParent(decl);

            TypeScript.getAstWalkerFactory().walk((funcDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }

    function createFunctionExpressionDeclaration(functionExpressionDeclAST, context) {
        var declFlags = 0 /* None */;

        if (TypeScript.hasFlag(functionExpressionDeclAST.getFunctionFlags(), 2048 /* IsFatArrowFunction */)) {
            declFlags |= 8192 /* FatArrow */;
        }

        var span = TypeScript.TextSpan.fromBounds(functionExpressionDeclAST.minChar, functionExpressionDeclAST.limChar);

        var parent = context.getParent();

        if (parent && (parent.kind === 536870912 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var name = functionExpressionDeclAST.name ? functionExpressionDeclAST.name.actualText : "";
        var decl = new TypeScript.PullFunctionExpressionDecl(name, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(functionExpressionDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, functionExpressionDeclAST);

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        if (functionExpressionDeclAST.returnTypeAnnotation && ((functionExpressionDeclAST.returnTypeAnnotation).term.nodeType() === 15 /* InterfaceDeclaration */ || (functionExpressionDeclAST.returnTypeAnnotation).term.nodeType() === 13 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo, context.scriptName);

            declCollectionContext.pushParent(decl);

            TypeScript.getAstWalkerFactory().walk((functionExpressionDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }

    function createMemberFunctionDeclaration(memberFunctionDeclAST, context) {
        var declFlags = 0 /* None */;
        var declType = 65536 /* Method */;

        if (TypeScript.hasFlag(memberFunctionDeclAST.getFunctionFlags(), 16 /* Static */)) {
            declFlags |= 16 /* Static */;
        }

        if (TypeScript.hasFlag(memberFunctionDeclAST.getFunctionFlags(), 2 /* Private */)) {
            declFlags |= 2 /* Private */;
        } else {
            declFlags |= 4 /* Public */;
        }

        if (!memberFunctionDeclAST.block) {
            declFlags |= 2048 /* Signature */;
        }

        if (TypeScript.hasFlag(memberFunctionDeclAST.name.getFlags(), 4 /* OptionalName */)) {
            declFlags |= 128 /* Optional */;
        }

        var span = TypeScript.TextSpan.fromBounds(memberFunctionDeclAST.minChar, memberFunctionDeclAST.limChar);

        var decl = new TypeScript.PullDecl(memberFunctionDeclAST.name.text(), memberFunctionDeclAST.name.actualText, declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(memberFunctionDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, memberFunctionDeclAST);

        var parent = context.getParent();

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        if (memberFunctionDeclAST.returnTypeAnnotation && ((memberFunctionDeclAST.returnTypeAnnotation).term.nodeType() === 15 /* InterfaceDeclaration */ || (memberFunctionDeclAST.returnTypeAnnotation).term.nodeType() === 13 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo, context.scriptName);

            declCollectionContext.pushParent(decl);

            TypeScript.getAstWalkerFactory().walk((memberFunctionDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }

    function createIndexSignatureDeclaration(indexSignatureDeclAST, context) {
        var declFlags = 2048 /* Signature */ | 1024 /* Index */;
        var declType = 4194304 /* IndexSignature */;

        var span = TypeScript.TextSpan.fromBounds(indexSignatureDeclAST.minChar, indexSignatureDeclAST.limChar);

        var parent = context.getParent();

        if (parent && (parent.kind === 536870912 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.PullDecl("", "", declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(indexSignatureDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, indexSignatureDeclAST);

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        if (indexSignatureDeclAST.returnTypeAnnotation && ((indexSignatureDeclAST.returnTypeAnnotation).term.nodeType() === 15 /* InterfaceDeclaration */ || (indexSignatureDeclAST.returnTypeAnnotation).term.nodeType() === 13 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo, context.scriptName);

            if (parent) {
                declCollectionContext.pushParent(parent);
            }

            TypeScript.getAstWalkerFactory().walk((indexSignatureDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }

    function createCallSignatureDeclaration(callSignatureDeclAST, context) {
        var declFlags = 2048 /* Signature */ | 256 /* Call */;
        var declType = 1048576 /* CallSignature */;

        var span = TypeScript.TextSpan.fromBounds(callSignatureDeclAST.minChar, callSignatureDeclAST.limChar);

        var parent = context.getParent();

        if (parent && (parent.kind === 536870912 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.PullDecl("", "", declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(callSignatureDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, callSignatureDeclAST);

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        if (callSignatureDeclAST.returnTypeAnnotation && ((callSignatureDeclAST.returnTypeAnnotation).term.nodeType() === 15 /* InterfaceDeclaration */ || (callSignatureDeclAST.returnTypeAnnotation).term.nodeType() === 13 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo, context.scriptName);

            declCollectionContext.pushParent(decl);

            TypeScript.getAstWalkerFactory().walk((callSignatureDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }

    function createConstructSignatureDeclaration(constructSignatureDeclAST, context) {
        var declFlags = 2048 /* Signature */ | 256 /* Call */;
        var declType = 2097152 /* ConstructSignature */;

        var span = TypeScript.TextSpan.fromBounds(constructSignatureDeclAST.minChar, constructSignatureDeclAST.limChar);

        var parent = context.getParent();

        if (parent && (parent.kind === 536870912 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.PullDecl("", "", declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(constructSignatureDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, constructSignatureDeclAST);

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        if (constructSignatureDeclAST.returnTypeAnnotation && ((constructSignatureDeclAST.returnTypeAnnotation).term.nodeType() === 15 /* InterfaceDeclaration */ || (constructSignatureDeclAST.returnTypeAnnotation).term.nodeType() === 13 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo, context.scriptName);

            declCollectionContext.pushParent(decl);

            TypeScript.getAstWalkerFactory().walk((constructSignatureDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }

    function createClassConstructorDeclaration(constructorDeclAST, context) {
        var declFlags = 512 /* Constructor */;
        var declType = 32768 /* ConstructorMethod */;

        if (!constructorDeclAST.block) {
            declFlags |= 2048 /* Signature */;
        }

        var span = TypeScript.TextSpan.fromBounds(constructorDeclAST.minChar, constructorDeclAST.limChar);

        var parent = context.getParent();

        if (parent) {
            var parentFlags = parent.flags;

            if (parentFlags & 1 /* Exported */) {
                declFlags |= 1 /* Exported */;
            }
        }

        var decl = new TypeScript.PullDecl(parent.name, parent.getDisplayName(), declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(constructorDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, constructorDeclAST);

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        if (constructorDeclAST.returnTypeAnnotation && ((constructorDeclAST.returnTypeAnnotation).term.nodeType() === 15 /* InterfaceDeclaration */ || (constructorDeclAST.returnTypeAnnotation).term.nodeType() === 13 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo, context.scriptName);

            declCollectionContext.pushParent(decl);

            TypeScript.getAstWalkerFactory().walk((constructorDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }

    function createGetAccessorDeclaration(getAccessorDeclAST, context) {
        var declFlags = 4 /* Public */;
        var declType = 262144 /* GetAccessor */;

        if (TypeScript.hasFlag(getAccessorDeclAST.getFunctionFlags(), 16 /* Static */)) {
            declFlags |= 16 /* Static */;
        }

        if (TypeScript.hasFlag(getAccessorDeclAST.name.getFlags(), 4 /* OptionalName */)) {
            declFlags |= 128 /* Optional */;
        }

        if (TypeScript.hasFlag(getAccessorDeclAST.getFunctionFlags(), 2 /* Private */)) {
            declFlags |= 2 /* Private */;
        } else {
            declFlags |= 4 /* Public */;
        }

        var span = TypeScript.TextSpan.fromBounds(getAccessorDeclAST.minChar, getAccessorDeclAST.limChar);

        var parent = context.getParent();

        if (parent && (parent.kind === 536870912 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.PullDecl(getAccessorDeclAST.name.text(), getAccessorDeclAST.name.actualText, declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(getAccessorDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, getAccessorDeclAST);

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        if (getAccessorDeclAST.returnTypeAnnotation && ((getAccessorDeclAST.returnTypeAnnotation).term.nodeType() === 15 /* InterfaceDeclaration */ || (getAccessorDeclAST.returnTypeAnnotation).term.nodeType() === 13 /* FunctionDeclaration */)) {
            var declCollectionContext = new DeclCollectionContext(context.semanticInfo, context.scriptName);

            declCollectionContext.pushParent(decl);

            TypeScript.getAstWalkerFactory().walk((getAccessorDeclAST.returnTypeAnnotation).term, preCollectDecls, postCollectDecls, null, declCollectionContext);
        }

        return true;
    }

    function createSetAccessorDeclaration(setAccessorDeclAST, context) {
        var declFlags = 4 /* Public */;
        var declType = 524288 /* SetAccessor */;

        if (TypeScript.hasFlag(setAccessorDeclAST.getFunctionFlags(), 16 /* Static */)) {
            declFlags |= 16 /* Static */;
        }

        if (TypeScript.hasFlag(setAccessorDeclAST.name.getFlags(), 4 /* OptionalName */)) {
            declFlags |= 128 /* Optional */;
        }

        if (TypeScript.hasFlag(setAccessorDeclAST.getFunctionFlags(), 2 /* Private */)) {
            declFlags |= 2 /* Private */;
        } else {
            declFlags |= 4 /* Public */;
        }

        var span = TypeScript.TextSpan.fromBounds(setAccessorDeclAST.minChar, setAccessorDeclAST.limChar);

        var parent = context.getParent();

        if (parent && (parent.kind === 536870912 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.PullDecl(setAccessorDeclAST.name.actualText, setAccessorDeclAST.name.actualText, declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(setAccessorDeclAST, decl);
        context.semanticInfo.setASTForDecl(decl, setAccessorDeclAST);

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        return true;
    }

    function preCollectCatchDecls(ast, parentAST, context) {
        var declFlags = 0 /* None */;
        var declType = 1073741824 /* CatchBlock */;

        var span = TypeScript.TextSpan.fromBounds(ast.minChar, ast.limChar);

        var parent = context.getParent();

        if (parent && (parent.kind === 536870912 /* WithBlock */ || (parent.flags & 2097152 /* DeclaredInAWithBlock */))) {
            declFlags |= 2097152 /* DeclaredInAWithBlock */;
        }

        var decl = new TypeScript.PullDecl("", "", declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(ast, decl);
        context.semanticInfo.setASTForDecl(decl, ast);

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        return true;
    }

    function preCollectWithDecls(ast, parentAST, context) {
        var declFlags = 0 /* None */;
        var declType = 536870912 /* WithBlock */;

        var span = TypeScript.TextSpan.fromBounds(ast.minChar, ast.limChar);

        var parent = context.getParent();

        var decl = new TypeScript.PullDecl("", "", declType, declFlags, span, context.scriptName);
        context.semanticInfo.setDeclForAST(ast, decl);
        context.semanticInfo.setASTForDecl(decl, ast);

        if (parent) {
            parent.addChildDecl(decl);
            decl.setParentDecl(parent);
        }

        context.pushParent(decl);

        return true;
    }

    function preCollectFuncDecls(ast, parentAST, context) {
        var funcDecl = ast;

        if (funcDecl.isConstructor) {
            return createClassConstructorDeclaration(funcDecl, context);
        } else if (funcDecl.isGetAccessor()) {
            return createGetAccessorDeclaration(funcDecl, context);
        } else if (funcDecl.isSetAccessor()) {
            return createSetAccessorDeclaration(funcDecl, context);
        } else if (TypeScript.hasFlag(funcDecl.getFunctionFlags(), 1024 /* ConstructMember */)) {
            return TypeScript.hasFlag(funcDecl.getFlags(), 8 /* TypeReference */) ? createConstructorTypeDeclaration(funcDecl, context) : createConstructSignatureDeclaration(funcDecl, context);
        } else if (TypeScript.hasFlag(funcDecl.getFunctionFlags(), 512 /* CallMember */)) {
            return createCallSignatureDeclaration(funcDecl, context);
        } else if (TypeScript.hasFlag(funcDecl.getFunctionFlags(), 4096 /* IndexerMember */)) {
            return createIndexSignatureDeclaration(funcDecl, context);
        } else if (TypeScript.hasFlag(funcDecl.getFlags(), 8 /* TypeReference */)) {
            return createFunctionTypeDeclaration(funcDecl, context);
        } else if (TypeScript.hasFlag(funcDecl.getFunctionFlags(), 256 /* Method */)) {
            return createMemberFunctionDeclaration(funcDecl, context);
        } else if (TypeScript.hasFlag(funcDecl.getFunctionFlags(), (8192 /* IsFunctionExpression */ | 2048 /* IsFatArrowFunction */ | 16384 /* IsFunctionProperty */))) {
            return createFunctionExpressionDeclaration(funcDecl, context);
        }

        return createFunctionDeclaration(funcDecl, context);
    }

    function preCollectDecls(ast, parentAST, walker) {
        var context = walker.state;
        var go = false;

        if (ast.nodeType() === 2 /* Script */) {
            var script = ast;
            var span = TypeScript.TextSpan.fromBounds(script.minChar, script.limChar);

            var decl = new TypeScript.PullDecl(context.scriptName, context.scriptName, 1 /* Script */, 0 /* None */, span, context.scriptName);
            context.semanticInfo.setDeclForAST(ast, decl);
            context.semanticInfo.setASTForDecl(decl, ast);

            context.pushParent(decl);
            context.isDeclareFile = script.isDeclareFile;

            go = true;
        } else if (ast.nodeType() === 1 /* List */) {
            go = true;
        } else if (ast.nodeType() === 82 /* Block */) {
            go = true;
        } else if (ast.nodeType() === 19 /* VariableDeclaration */) {
            go = true;
        } else if (ast.nodeType() === 98 /* VariableStatement */) {
            go = true;
        } else if (ast.nodeType() === 16 /* ModuleDeclaration */) {
            go = preCollectModuleDecls(ast, parentAST, context);
        } else if (ast.nodeType() === 14 /* ClassDeclaration */) {
            go = preCollectClassDecls(ast, parentAST, context);
        } else if (ast.nodeType() === 15 /* InterfaceDeclaration */) {
            go = preCollectInterfaceDecls(ast, parentAST, context);
        } else if (ast.nodeType() === 20 /* Parameter */) {
            go = preCollectParameterDecl(ast, parentAST, context);
        } else if (ast.nodeType() === 18 /* VariableDeclarator */) {
            go = preCollectVarDecls(ast, parentAST, context);
        } else if (ast.nodeType() === 13 /* FunctionDeclaration */) {
            go = preCollectFuncDecls(ast, parentAST, context);
        } else if (ast.nodeType() === 17 /* ImportDeclaration */) {
            go = preCollectImportDecls(ast, parentAST, context);
        } else if (ast.nodeType() === 9 /* TypeParameter */) {
            go = preCollectTypeParameterDecl(ast, parentAST, context);
        } else if (ast.nodeType() === 92 /* IfStatement */) {
            go = true;
        } else if (ast.nodeType() === 91 /* ForStatement */) {
            go = true;
        } else if (ast.nodeType() === 90 /* ForInStatement */) {
            go = true;
        } else if (ast.nodeType() === 99 /* WhileStatement */) {
            go = true;
        } else if (ast.nodeType() === 86 /* DoStatement */) {
            go = true;
        } else if (ast.nodeType() === 26 /* CommaExpression */) {
            go = true;
        } else if (ast.nodeType() === 94 /* ReturnStatement */) {
            go = true;
        } else if (ast.nodeType() === 95 /* SwitchStatement */ || ast.nodeType() === 101 /* CaseClause */) {
            go = true;
        } else if (ast.nodeType() === 37 /* InvocationExpression */) {
            go = true;
        } else if (ast.nodeType() === 38 /* ObjectCreationExpression */) {
            go = true;
        } else if (ast.nodeType() === 97 /* TryStatement */) {
            go = true;
        } else if (ast.nodeType() === 93 /* LabeledStatement */) {
            go = true;
        } else if (ast.nodeType() === 102 /* CatchClause */) {
            go = preCollectCatchDecls(ast, parentAST, context);
        } else if (ast.nodeType() === 100 /* WithStatement */) {
            go = preCollectWithDecls(ast, parentAST, context);
        }

        walker.options.goChildren = go;

        return ast;
    }
    TypeScript.preCollectDecls = preCollectDecls;

    function isContainer(decl) {
        return decl.kind === 4 /* Container */ || decl.kind === 32 /* DynamicModule */ || decl.kind === 64 /* Enum */;
    }

    function getInitializationFlag(decl) {
        if (decl.kind & 4 /* Container */) {
            return 32768 /* InitializedModule */;
        } else if (decl.kind & 64 /* Enum */) {
            return 131072 /* InitializedEnum */;
        } else if (decl.kind & 32 /* DynamicModule */) {
            return 65536 /* InitializedDynamicModule */;
        }

        return 0 /* None */;
    }

    function hasInitializationFlag(decl) {
        var kind = decl.kind;

        if (kind & 4 /* Container */) {
            return (decl.flags & 32768 /* InitializedModule */) !== 0;
        } else if (kind & 64 /* Enum */) {
            return (decl.flags & 131072 /* InitializedEnum */) != 0;
        } else if (kind & 32 /* DynamicModule */) {
            return (decl.flags & 65536 /* InitializedDynamicModule */) !== 0;
        }

        return false;
    }

    function postCollectDecls(ast, parentAST, walker) {
        var context = walker.state;
        var parentDecl;
        var initFlag = 0 /* None */;

        if (ast.nodeType() === 16 /* ModuleDeclaration */) {
            var thisModule = context.getParent();
            context.popParent();
            context.containingModuleHasExportAssignmentArray.pop();
            context.isParsingAmbientModuleArray.pop();

            parentDecl = context.getParent();

            if (hasInitializationFlag(thisModule)) {
                if (parentDecl && isContainer(parentDecl)) {
                    initFlag = getInitializationFlag(parentDecl);
                    parentDecl.setFlags(parentDecl.flags | initFlag);
                }

                var valueDecl = new TypeScript.PullDecl(thisModule.name, thisModule.getDisplayName(), 1024 /* Variable */, thisModule.flags, thisModule.getSpan(), context.scriptName);

                thisModule.setValueDecl(valueDecl);

                context.semanticInfo.setASTForDecl(valueDecl, ast);

                if (parentDecl) {
                    parentDecl.addChildDecl(valueDecl);
                    valueDecl.setParentDecl(parentDecl);
                }
            }
        } else if (ast.nodeType() === 14 /* ClassDeclaration */) {
            context.popParent();

            parentDecl = context.getParent();

            if (parentDecl && isContainer(parentDecl)) {
                initFlag = getInitializationFlag(parentDecl);
                parentDecl.setFlags(parentDecl.flags | initFlag);
            }
        } else if (ast.nodeType() === 15 /* InterfaceDeclaration */) {
            context.popParent();
        } else if (ast.nodeType() === 13 /* FunctionDeclaration */) {
            context.popParent();

            parentDecl = context.getParent();

            if (parentDecl && isContainer(parentDecl)) {
                initFlag = getInitializationFlag(parentDecl);
                parentDecl.setFlags(parentDecl.flags | initFlag);
            }
        } else if (ast.nodeType() === 18 /* VariableDeclarator */) {
            parentDecl = context.getParent();

            if (parentDecl && isContainer(parentDecl)) {
                initFlag = getInitializationFlag(parentDecl);
                parentDecl.setFlags(parentDecl.flags | initFlag);
            }
        } else if (ast.nodeType() === 102 /* CatchClause */) {
            parentDecl = context.getParent();

            if (parentDecl && isContainer(parentDecl)) {
                initFlag = getInitializationFlag(parentDecl);
                parentDecl.setFlags(parentDecl.flags | initFlag);
            }

            context.popParent();
        } else if (ast.nodeType() === 100 /* WithStatement */) {
            parentDecl = context.getParent();

            if (parentDecl && isContainer(parentDecl)) {
                initFlag = getInitializationFlag(parentDecl);
                parentDecl.setFlags(parentDecl.flags | initFlag);
            }

            context.popParent();
        }

        return ast;
    }
    TypeScript.postCollectDecls = postCollectDecls;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    function getPathToDecl(decl) {
        if (!decl) {
            return [];
        }

        var decls = decl.getParentPath();

        if (decls) {
            return decls;
        } else {
            decls = [decl];
        }

        var parentDecl = decl.getParentDecl();

        while (parentDecl) {
            if (parentDecl && decls[decls.length - 1] != parentDecl && !(parentDecl.kind & 512 /* ObjectLiteral */)) {
                decls[decls.length] = parentDecl;
            }
            parentDecl = parentDecl.getParentDecl();
        }

        decls = decls.reverse();

        decl.setParentPath(decls);

        return decls;
    }
    TypeScript.getPathToDecl = getPathToDecl;

    var PullSymbolBinder = (function () {
        function PullSymbolBinder(semanticInfoChain) {
            this.semanticInfoChain = semanticInfoChain;
            this.functionTypeParameterCache = new TypeScript.BlockIntrinsics();
            this.semanticInfo = null;
        }
        PullSymbolBinder.prototype.findTypeParameterInCache = function (name) {
            return this.functionTypeParameterCache[name];
        };

        PullSymbolBinder.prototype.addTypeParameterToCache = function (typeParameter) {
            this.functionTypeParameterCache[typeParameter.getName()] = typeParameter;
        };

        PullSymbolBinder.prototype.resetTypeParameterCache = function () {
            this.functionTypeParameterCache = new TypeScript.BlockIntrinsics();
        };

        PullSymbolBinder.prototype.setUnit = function (fileName) {
            this.semanticInfo = this.semanticInfoChain.getUnit(fileName);
        };

        PullSymbolBinder.prototype.getParent = function (decl, returnInstanceType) {
            if (typeof returnInstanceType === "undefined") { returnInstanceType = false; }
            var parentDecl = decl.getParentDecl();

            if (parentDecl.kind == 1 /* Script */) {
                return null;
            }

            var parent = parentDecl.getSymbol();

            if (!parent && parentDecl && !parentDecl.isBound()) {
                this.bindDeclToPullSymbol(parentDecl);
            }

            parent = parentDecl.getSymbol();
            if (parent) {
                var parentDeclKind = parentDecl.kind;
                if (parentDeclKind == 262144 /* GetAccessor */) {
                    parent = (parent).getGetter();
                } else if (parentDeclKind == 524288 /* SetAccessor */) {
                    parent = (parent).getSetter();
                }
            }

            if (parent) {
                if (returnInstanceType && parent.isType() && parent.isContainer()) {
                    var instanceSymbol = (parent).getInstanceSymbol();

                    if (instanceSymbol) {
                        return instanceSymbol.type;
                    }
                }

                return parent.type;
            }

            return null;
        };

        PullSymbolBinder.prototype.findDeclsInContext = function (startingDecl, declKind, searchGlobally) {
            if (!searchGlobally) {
                var parentDecl = startingDecl.getParentDecl();
                return parentDecl.searchChildDecls(startingDecl.name, declKind);
            }

            var contextSymbolPath = getPathToDecl(startingDecl);

            if (contextSymbolPath.length) {
                var copyOfContextSymbolPath = [];

                for (var i = 0; i < contextSymbolPath.length; i++) {
                    if (contextSymbolPath[i].kind & 1 /* Script */) {
                        continue;
                    }
                    copyOfContextSymbolPath[copyOfContextSymbolPath.length] = contextSymbolPath[i].name;
                }

                return this.semanticInfoChain.findDecls(copyOfContextSymbolPath, declKind);
            }

            return this.semanticInfoChain.findDecls([name], declKind);
        };

        PullSymbolBinder.prototype.bindModuleDeclarationToPullSymbol = function (moduleContainerDecl) {
            var modName = moduleContainerDecl.name;

            var moduleContainerTypeSymbol = null;
            var moduleInstanceSymbol = null;
            var moduleInstanceTypeSymbol = null;

            var moduleInstanceDecl = moduleContainerDecl.getValueDecl();

            var moduleKind = moduleContainerDecl.kind;

            var parent = this.getParent(moduleContainerDecl);
            var parentInstanceSymbol = this.getParent(moduleContainerDecl, true);
            var parentDecl = moduleContainerDecl.getParentDecl();
            var moduleAST = this.semanticInfo.getASTForDecl(moduleContainerDecl);

            var isExported = moduleContainerDecl.flags & 1 /* Exported */;
            var isEnum = (moduleKind & 64 /* Enum */) != 0;
            var searchKind = isEnum ? 64 /* Enum */ : TypeScript.PullElementKind.SomeContainer;
            var isInitializedModule = (moduleContainerDecl.flags & TypeScript.PullElementFlags.SomeInitializedModule) != 0;

            var createdNewSymbol = false;

            if (parent) {
                if (isExported) {
                    moduleContainerTypeSymbol = parent.findNestedType(modName, searchKind);
                } else {
                    moduleContainerTypeSymbol = parent.findContainedNonMemberType(modName);

                    if (moduleContainerTypeSymbol && !(moduleContainerTypeSymbol.kind & searchKind)) {
                        moduleContainerTypeSymbol = null;
                    }
                }
            } else if (!isExported || moduleContainerDecl.kind === 32 /* DynamicModule */) {
                moduleContainerTypeSymbol = this.semanticInfoChain.findTopLevelSymbol(modName, searchKind, this.semanticInfo.getPath());
            }

            if (moduleContainerTypeSymbol && moduleContainerTypeSymbol.kind !== moduleKind) {
                if (isInitializedModule) {
                    moduleContainerDecl.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), moduleAST.minChar, moduleAST.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [moduleContainerDecl.getDisplayName()]));
                }

                moduleContainerTypeSymbol = null;
            }

            if (moduleContainerTypeSymbol) {
                moduleInstanceSymbol = moduleContainerTypeSymbol.getInstanceSymbol();
            } else {
                moduleContainerTypeSymbol = new TypeScript.PullContainerTypeSymbol(modName, moduleKind);
                createdNewSymbol = true;

                if (!parent) {
                    this.semanticInfoChain.cacheGlobalSymbol(moduleContainerTypeSymbol, searchKind);
                }
            }

            if (!moduleInstanceSymbol && isInitializedModule) {
                var variableSymbol = null;
                if (!isEnum) {
                    if (parentInstanceSymbol) {
                        if (isExported) {
                            variableSymbol = parentInstanceSymbol.findMember(modName, false);

                            if (!variableSymbol) {
                                variableSymbol = parentInstanceSymbol.findContainedNonMember(modName);
                            }
                        } else {
                            variableSymbol = parentInstanceSymbol.findContainedNonMember(modName);

                            if (!variableSymbol) {
                                variableSymbol = parentInstanceSymbol.findMember(modName, false);
                            }
                        }

                        if (variableSymbol) {
                            var declarations = variableSymbol.getDeclarations();

                            if (declarations.length) {
                                var variableSymbolParentDecl = declarations[0].getParentDecl();

                                if (parentDecl !== variableSymbolParentDecl) {
                                    variableSymbol = null;
                                }
                            }
                        }
                    } else if (!(moduleContainerDecl.flags & 1 /* Exported */)) {
                        var siblingDecls = parentDecl.getChildDecls();
                        var augmentedDecl = null;

                        for (var i = 0; i < siblingDecls.length; i++) {
                            if (siblingDecls[i] == moduleContainerDecl) {
                                break;
                            }

                            if ((siblingDecls[i].name == modName) && (siblingDecls[i].kind & (8 /* Class */ | TypeScript.PullElementKind.SomeFunction))) {
                                augmentedDecl = siblingDecls[i];
                                break;
                            }
                        }

                        if (augmentedDecl) {
                            variableSymbol = augmentedDecl.getSymbol();

                            if (variableSymbol && variableSymbol.isType()) {
                                variableSymbol = (variableSymbol).getConstructorMethod();
                            }
                        }
                    }
                }

                if (variableSymbol) {
                    var prevKind = variableSymbol.kind;
                    var acceptableRedeclaration = (prevKind == 16384 /* Function */) || (prevKind == 32768 /* ConstructorMethod */) || variableSymbol.hasFlag(TypeScript.PullElementFlags.ImplicitVariable);

                    if (acceptableRedeclaration) {
                        moduleInstanceTypeSymbol = variableSymbol.type;
                    } else {
                        variableSymbol = null;
                    }
                }

                if (!moduleInstanceTypeSymbol) {
                    moduleInstanceTypeSymbol = new TypeScript.PullTypeSymbol("", 8388608 /* ObjectType */);
                }

                moduleInstanceTypeSymbol.addDeclaration(moduleContainerDecl);

                if (!moduleInstanceTypeSymbol.getAssociatedContainerType()) {
                    moduleInstanceTypeSymbol.setAssociatedContainerType(moduleContainerTypeSymbol);
                }

                if (variableSymbol) {
                    moduleInstanceSymbol = variableSymbol;
                } else {
                    moduleInstanceSymbol = new TypeScript.PullSymbol(modName, 1024 /* Variable */);
                    moduleInstanceSymbol.type = moduleInstanceTypeSymbol;
                }

                moduleContainerTypeSymbol.setInstanceSymbol(moduleInstanceSymbol);
            }

            moduleContainerTypeSymbol.addDeclaration(moduleContainerDecl);
            moduleContainerDecl.setSymbol(moduleContainerTypeSymbol);

            this.semanticInfo.setSymbolForAST(moduleAST.name, moduleContainerTypeSymbol);
            this.semanticInfo.setSymbolForAST(moduleAST, moduleContainerTypeSymbol);

            var moduleDeclarations = moduleContainerTypeSymbol.getDeclarations();

            if (isEnum && moduleDeclarations.length > 1 && moduleAST.members.members.length > 0) {
                var multipleEnums = TypeScript.ArrayUtilities.where(moduleDeclarations, function (d) {
                    return d.kind === 64 /* Enum */;
                }).length > 1;
                if (multipleEnums) {
                    var firstVariable = moduleAST.members.members[0];
                    var firstVariableDeclarator = firstVariable.declaration.declarators.members[0];
                    if (!firstVariableDeclarator.init) {
                        moduleContainerDecl.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), firstVariableDeclarator.minChar, firstVariableDeclarator.getLength(), TypeScript.DiagnosticCode.Enums_with_multiple_declarations_must_provide_an_initializer_for_the_first_enum_element, null));
                    }
                }
            }

            if (createdNewSymbol) {
                if (parent) {
                    if (moduleContainerDecl.flags & 1 /* Exported */) {
                        parent.addEnclosedMemberType(moduleContainerTypeSymbol);
                    } else {
                        parent.addEnclosedNonMemberType(moduleContainerTypeSymbol);
                    }
                }
            }

            if (isEnum) {
                moduleInstanceTypeSymbol = moduleContainerTypeSymbol.getInstanceSymbol().type;

                var enumIndexSignature = new TypeScript.PullSignatureSymbol(4194304 /* IndexSignature */);
                var enumIndexParameterSymbol = new TypeScript.PullSymbol("x", 2048 /* Parameter */);
                enumIndexParameterSymbol.type = this.semanticInfoChain.numberTypeSymbol;
                enumIndexSignature.addParameter(enumIndexParameterSymbol);
                enumIndexSignature.returnType = this.semanticInfoChain.stringTypeSymbol;

                moduleInstanceTypeSymbol.addIndexSignature(enumIndexSignature);
            }

            var valueDecl = moduleContainerDecl.getValueDecl();

            if (valueDecl) {
                valueDecl.ensureSymbolIsBound();
            }

            var otherDecls = this.findDeclsInContext(moduleContainerDecl, moduleContainerDecl.kind, true);

            if (otherDecls && otherDecls.length) {
                for (var i = 0; i < otherDecls.length; i++) {
                    otherDecls[i].ensureSymbolIsBound();
                }
            }
        };

        PullSymbolBinder.prototype.bindImportDeclaration = function (importDeclaration) {
            var declFlags = importDeclaration.flags;
            var declKind = importDeclaration.kind;
            var importDeclAST = this.semanticInfo.getASTForDecl(importDeclaration);

            var isExported = false;
            var importSymbol = null;
            var declName = importDeclaration.name;
            var parentHadSymbol = false;
            var parent = this.getParent(importDeclaration);

            if (parent) {
                importSymbol = parent.findMember(declName, false);

                if (!importSymbol) {
                    importSymbol = parent.findContainedNonMemberType(declName);

                    if (importSymbol) {
                        var declarations = importSymbol.getDeclarations();

                        if (declarations.length) {
                            var importSymbolParent = declarations[0].getParentDecl();

                            if (importSymbolParent !== importDeclaration.getParentDecl()) {
                                importSymbol = null;
                            }
                        }
                    }
                }
            } else if (!(importDeclaration.flags & 1 /* Exported */)) {
                importSymbol = this.semanticInfoChain.findTopLevelSymbol(declName, TypeScript.PullElementKind.SomeContainer, this.semanticInfo.getPath());
            }

            if (importSymbol) {
                parentHadSymbol = true;
            }

            if (importSymbol) {
                importDeclaration.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), importDeclAST.minChar, importDeclAST.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [importDeclaration.getDisplayName()]));
                importSymbol = null;
            }

            if (!importSymbol) {
                importSymbol = new TypeScript.PullTypeAliasSymbol(declName);

                if (!parent) {
                    this.semanticInfoChain.cacheGlobalSymbol(importSymbol, TypeScript.PullElementKind.SomeContainer);
                }
            }

            importSymbol.addDeclaration(importDeclaration);
            importDeclaration.setSymbol(importSymbol);

            this.semanticInfo.setSymbolForAST(importDeclAST, importSymbol);

            if (parent && !parentHadSymbol) {
                if (declFlags & 1 /* Exported */) {
                    parent.addEnclosedMemberType(importSymbol);
                } else {
                    parent.addEnclosedNonMemberType(importSymbol);
                }
            }
        };

        PullSymbolBinder.prototype.bindClassDeclarationToPullSymbol = function (classDecl) {
            var className = classDecl.name;
            var classSymbol = null;

            var constructorSymbol = null;
            var constructorTypeSymbol = null;

            var classAST = this.semanticInfo.getASTForDecl(classDecl);

            var parent = this.getParent(classDecl);
            var parentDecl = classDecl.getParentDecl();
            var isExported = classDecl.flags & 1 /* Exported */;
            var isGeneric = false;

            if (parent) {
                if (isExported) {
                    classSymbol = parent.findNestedType(className);

                    if (!classSymbol) {
                        classSymbol = parent.findMember(className, false);
                    }
                } else {
                    classSymbol = parent.findContainedNonMemberType(className);

                    if (classSymbol && (classSymbol.kind & 8 /* Class */)) {
                        var declarations = classSymbol.getDeclarations();

                        if (declarations.length) {
                            var classSymbolParentDecl = declarations[0].getParentDecl();

                            if (classSymbolParentDecl !== parentDecl) {
                                classSymbol = null;
                            }
                        }
                    } else {
                        classSymbol = null;
                    }
                }
            } else {
                classSymbol = this.semanticInfoChain.findTopLevelSymbol(className, 8 /* Class */, this.semanticInfo.getPath());
            }

            if (classSymbol) {
                classDecl.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), classAST.minChar, classAST.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [classDecl.getDisplayName()]));
                classSymbol = null;
            }

            var decls;

            classSymbol = new TypeScript.PullTypeSymbol(className, 8 /* Class */);

            if (!parent) {
                this.semanticInfoChain.cacheGlobalSymbol(classSymbol, 8 /* Class */);
            }

            classSymbol.addDeclaration(classDecl);

            classDecl.setSymbol(classSymbol);

            this.semanticInfo.setSymbolForAST(classAST.name, classSymbol);
            this.semanticInfo.setSymbolForAST(classAST, classSymbol);

            if (parent) {
                if (classDecl.flags & 1 /* Exported */) {
                    parent.addEnclosedMemberType(classSymbol);
                } else {
                    parent.addEnclosedNonMemberType(classSymbol);
                }
            }

            this.resetTypeParameterCache();

            constructorSymbol = classSymbol.getConstructorMethod();
            constructorTypeSymbol = constructorSymbol ? constructorSymbol.type : null;

            if (!constructorSymbol) {
                constructorSymbol = new TypeScript.PullSymbol(className, 32768 /* ConstructorMethod */);
                constructorTypeSymbol = new TypeScript.PullTypeSymbol("", 33554432 /* ConstructorType */);

                constructorSymbol.setIsSynthesized();

                constructorSymbol.type = constructorTypeSymbol;
                classSymbol.setConstructorMethod(constructorSymbol);

                classSymbol.setHasDefaultConstructor();
            }

            if (constructorSymbol.getIsSynthesized()) {
                constructorSymbol.addDeclaration(classDecl.getValueDecl());
                constructorTypeSymbol.addDeclaration(classDecl);
            } else {
                classSymbol.setHasDefaultConstructor(false);
            }

            constructorTypeSymbol.setAssociatedContainerType(classSymbol);

            var typeParameters = classDecl.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = classSymbol.findTypeParameter(typeParameters[i].name);

                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].name, false);

                    classSymbol.addTypeParameter(typeParameter);
                    constructorTypeSymbol.addConstructorTypeParameter(typeParameter);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();

                    var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameterDecls[0]);
                    classDecl.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), typeParameterAST.minChar, typeParameterAST.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [typeParameter.getName()]));
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }

            var valueDecl = classDecl.getValueDecl();

            if (valueDecl) {
                valueDecl.ensureSymbolIsBound();
            }
        };

        PullSymbolBinder.prototype.bindInterfaceDeclarationToPullSymbol = function (interfaceDecl) {
            var interfaceName = interfaceDecl.name;
            var interfaceSymbol = null;

            var interfaceAST = this.semanticInfo.getASTForDecl(interfaceDecl);
            var createdNewSymbol = false;
            var parent = this.getParent(interfaceDecl);

            var acceptableSharedKind = 16 /* Interface */;

            if (parent) {
                interfaceSymbol = parent.findNestedType(interfaceName, TypeScript.PullElementKind.SomeType);
            } else if (!(interfaceDecl.flags & 1 /* Exported */)) {
                interfaceSymbol = this.semanticInfoChain.findTopLevelSymbol(interfaceName, 16 /* Interface */, this.semanticInfo.getPath());
            }

            if (interfaceSymbol && !(interfaceSymbol.kind & acceptableSharedKind)) {
                interfaceDecl.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), interfaceAST.minChar, interfaceAST.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [interfaceDecl.getDisplayName()]));
                interfaceSymbol = null;
            }

            if (!interfaceSymbol) {
                interfaceSymbol = new TypeScript.PullTypeSymbol(interfaceName, 16 /* Interface */);
                createdNewSymbol = true;

                if (!parent) {
                    this.semanticInfoChain.cacheGlobalSymbol(interfaceSymbol, acceptableSharedKind);
                }
            }

            interfaceSymbol.addDeclaration(interfaceDecl);
            interfaceDecl.setSymbol(interfaceSymbol);

            if (createdNewSymbol) {
                if (parent) {
                    if (interfaceDecl.flags & 1 /* Exported */) {
                        parent.addEnclosedMemberType(interfaceSymbol);
                    } else {
                        parent.addEnclosedNonMemberType(interfaceSymbol);
                    }
                }
            }

            this.resetTypeParameterCache();

            var typeParameters = interfaceDecl.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = interfaceSymbol.findTypeParameter(typeParameters[i].name);

                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].name, false);

                    interfaceSymbol.addTypeParameter(typeParameter);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();

                    for (var j = 0; j < typeParameterDecls.length; j++) {
                        var typeParameterDeclParent = typeParameterDecls[j].getParentDecl();

                        if (typeParameterDeclParent && typeParameterDeclParent === interfaceDecl) {
                            var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameterDecls[0]);
                            interfaceDecl.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), typeParameterAST.minChar, typeParameterAST.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [typeParameter.getName()]));

                            break;
                        }
                    }
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }

            var otherDecls = this.findDeclsInContext(interfaceDecl, interfaceDecl.kind, true);

            if (otherDecls && otherDecls.length) {
                for (var i = 0; i < otherDecls.length; i++) {
                    otherDecls[i].ensureSymbolIsBound();
                }
            }
        };

        PullSymbolBinder.prototype.bindObjectTypeDeclarationToPullSymbol = function (objectDecl) {
            var objectSymbolAST = this.semanticInfo.getASTForDecl(objectDecl);

            var objectSymbol = new TypeScript.PullTypeSymbol("", 8388608 /* ObjectType */);

            objectSymbol.addDeclaration(objectDecl);
            objectDecl.setSymbol(objectSymbol);

            this.semanticInfo.setSymbolForAST(objectSymbolAST, objectSymbol);

            var childDecls = objectDecl.getChildDecls();

            for (var i = 0; i < childDecls.length; i++) {
                this.bindDeclToPullSymbol(childDecls[i]);
            }

            var typeParameters = objectDecl.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = objectSymbol.findTypeParameter(typeParameters[i].name);

                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].name, false);

                    objectSymbol.addTypeParameter(typeParameter);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();

                    var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameterDecls[0]);
                    objectDecl.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), typeParameterAST.minChar, typeParameterAST.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [typeParameter.name]));
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }
        };

        PullSymbolBinder.prototype.bindConstructorTypeDeclarationToPullSymbol = function (constructorTypeDeclaration) {
            var declKind = constructorTypeDeclaration.kind;
            var declFlags = constructorTypeDeclaration.flags;
            var constructorTypeAST = this.semanticInfo.getASTForDecl(constructorTypeDeclaration);

            var constructorTypeSymbol = new TypeScript.PullTypeSymbol("", 33554432 /* ConstructorType */);

            constructorTypeDeclaration.setSymbol(constructorTypeSymbol);
            constructorTypeSymbol.addDeclaration(constructorTypeDeclaration);
            this.semanticInfo.setSymbolForAST(constructorTypeAST, constructorTypeSymbol);

            var signature = new TypeScript.PullDefinitionSignatureSymbol(2097152 /* ConstructSignature */);

            if ((constructorTypeAST).variableArgList) {
                signature.hasVarArgs = true;
            }

            signature.addDeclaration(constructorTypeDeclaration);
            constructorTypeDeclaration.setSignatureSymbol(signature);

            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(constructorTypeDeclaration), constructorTypeSymbol, signature);

            constructorTypeSymbol.addConstructSignature(signature);

            var typeParameters = constructorTypeDeclaration.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = constructorTypeSymbol.findTypeParameter(typeParameters[i].name);

                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].name, false);

                    constructorTypeSymbol.addConstructorTypeParameter(typeParameter);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();

                    var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameterDecls[0]);
                    constructorTypeDeclaration.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), typeParameterAST.minChar, typeParameterAST.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [typeParameter.name]));
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }
        };

        PullSymbolBinder.prototype.bindVariableDeclarationToPullSymbol = function (variableDeclaration) {
            var declFlags = variableDeclaration.flags;
            var declKind = variableDeclaration.kind;
            var varDeclAST = this.semanticInfo.getASTForDecl(variableDeclaration);

            var isExported = (declFlags & 1 /* Exported */) !== 0;

            var variableSymbol = null;

            var declName = variableDeclaration.name;

            var parentHadSymbol = false;

            var parent = this.getParent(variableDeclaration, true);

            var parentDecl = variableDeclaration.getParentDecl();

            var isImplicit = (declFlags & TypeScript.PullElementFlags.ImplicitVariable) !== 0;
            var isModuleValue = (declFlags & (TypeScript.PullElementFlags.SomeInitializedModule)) != 0;
            var isEnumValue = (declFlags & 131072 /* InitializedEnum */) != 0;
            var isClassConstructorVariable = (declFlags & 16384 /* ClassConstructorVariable */) != 0;

            if (parentDecl && !isImplicit) {
                parentDecl.addVariableDeclToGroup(variableDeclaration);
            }

            if (parent) {
                if (isExported) {
                    variableSymbol = parent.findMember(declName, false);
                } else {
                    variableSymbol = parent.findContainedNonMember(declName);
                }

                if (variableSymbol) {
                    var declarations = variableSymbol.getDeclarations();

                    if (declarations.length) {
                        var variableSymbolParentDecl = declarations[0].getParentDecl();

                        if (parentDecl !== variableSymbolParentDecl) {
                            variableSymbol = null;
                        }
                    }
                }
            } else if (!(variableDeclaration.flags & 1 /* Exported */)) {
                variableSymbol = this.semanticInfoChain.findTopLevelSymbol(declName, TypeScript.PullElementKind.SomeValue, this.semanticInfo.getPath());
            }

            if (variableSymbol && !variableSymbol.isType()) {
                parentHadSymbol = true;
            }

            var span;
            var decl;
            var decls;
            var ast;
            var members;

            if (variableSymbol) {
                var prevKind = variableSymbol.kind;
                var prevIsAmbient = variableSymbol.hasFlag(8 /* Ambient */);
                var prevIsEnum = variableSymbol.hasFlag(131072 /* InitializedEnum */);
                var prevIsClassConstructorVariable = variableSymbol.hasFlag(16384 /* ClassConstructorVariable */);
                var prevIsModuleValue = variableSymbol.hasFlag(TypeScript.PullElementFlags.SomeInitializedModule);
                var prevIsImplicit = variableSymbol.hasFlag(TypeScript.PullElementFlags.ImplicitVariable);
                var onlyOneIsEnum = (isEnumValue || prevIsEnum) && !(isEnumValue && prevIsEnum);
                var isAmbient = (variableDeclaration.flags & 8 /* Ambient */) != 0;
                var prevDecl = variableSymbol.getDeclarations()[0];
                var bothAreGlobal = parentDecl && (parentDecl.kind == 1 /* Script */) && (declKind == prevKind);
                var shareParent = bothAreGlobal || prevDecl.getParentDecl() == variableDeclaration.getParentDecl();
                var prevIsParam = shareParent && prevKind == 2048 /* Parameter */ && declKind == 1024 /* Variable */;

                var acceptableRedeclaration = (!shareParent || prevIsParam) || (isImplicit && ((!isEnumValue && !isClassConstructorVariable && prevKind == 16384 /* Function */) || (isModuleValue && prevIsModuleValue) || (isClassConstructorVariable && prevIsModuleValue && isAmbient) || (isModuleValue && prevIsClassConstructorVariable)));

                if (acceptableRedeclaration && prevIsClassConstructorVariable && !prevIsAmbient) {
                    if (prevDecl.getScriptName() != variableDeclaration.getScriptName()) {
                        acceptableRedeclaration = false;
                    }
                }

                if (shareParent && !prevIsParam && (!acceptableRedeclaration || onlyOneIsEnum)) {
                    if (isImplicit || prevIsImplicit || (prevKind & TypeScript.PullElementKind.SomeFunction) !== 0) {
                        span = variableDeclaration.getSpan();
                        var errorDecl = isImplicit ? variableSymbol.getDeclarations()[0] : variableDeclaration;
                        errorDecl.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), span.start(), span.length(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [variableDeclaration.getDisplayName()]));
                    }

                    variableSymbol = null;
                    parentHadSymbol = false;
                }
            } else if (variableSymbol && (variableSymbol.kind !== 1024 /* Variable */) && !isImplicit) {
                span = variableDeclaration.getSpan();

                variableDeclaration.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), span.start(), span.length(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [variableDeclaration.getDisplayName()]));
                variableSymbol = null;
                parentHadSymbol = false;
            }

            if ((declFlags & TypeScript.PullElementFlags.ImplicitVariable) === 0) {
                if (!variableSymbol) {
                    variableSymbol = new TypeScript.PullSymbol(declName, declKind);
                    this.semanticInfoChain.cacheGlobalSymbol(variableSymbol, declKind);
                }

                variableSymbol.addDeclaration(variableDeclaration);
                variableDeclaration.setSymbol(variableSymbol);

                this.semanticInfo.setSymbolForAST(varDeclAST.id, variableSymbol);
                this.semanticInfo.setSymbolForAST(varDeclAST, variableSymbol);
            } else if (!parentHadSymbol) {
                if (isClassConstructorVariable) {
                    var classTypeSymbol = variableSymbol;

                    if (parent) {
                        members = parent.getMembers();

                        for (var i = 0; i < members.length; i++) {
                            if ((members[i].name === declName) && (members[i].kind === 8 /* Class */)) {
                                classTypeSymbol = members[i];
                                break;
                            }
                        }
                    }

                    if (!classTypeSymbol) {
                        var parentDecl = variableDeclaration.getParentDecl();

                        if (parentDecl) {
                            var childDecls = parentDecl.searchChildDecls(declName, TypeScript.PullElementKind.SomeType);

                            if (childDecls.length) {
                                for (var i = 0; i < childDecls.length; i++) {
                                    if (childDecls[i].getValueDecl() === variableDeclaration) {
                                        classTypeSymbol = childDecls[i].getSymbol();
                                    }
                                }
                            }
                        }

                        if (!classTypeSymbol) {
                            classTypeSymbol = this.semanticInfoChain.findTopLevelSymbol(declName, TypeScript.PullElementKind.SomeType, this.semanticInfo.getPath());
                        }
                    }

                    if (classTypeSymbol && (classTypeSymbol.kind !== 8 /* Class */)) {
                        classTypeSymbol = null;
                    }

                    if (classTypeSymbol && classTypeSymbol.isClass()) {
                        variableSymbol = classTypeSymbol.getConstructorMethod();
                        variableDeclaration.setSymbol(variableSymbol);

                        decls = classTypeSymbol.getDeclarations();

                        if (decls.length) {
                            decl = decls[decls.length - 1];
                            ast = this.semanticInfo.getASTForDecl(decl);

                            if (ast) {
                                this.semanticInfo.setASTForDecl(variableDeclaration, ast);
                            }
                        }
                    } else {
                        if (!variableSymbol) {
                            variableSymbol = new TypeScript.PullSymbol(declName, declKind);
                        }

                        variableSymbol.addDeclaration(variableDeclaration);
                        variableDeclaration.setSymbol(variableSymbol);

                        variableSymbol.type = this.semanticInfoChain.anyTypeSymbol;
                    }
                } else if (declFlags & TypeScript.PullElementFlags.SomeInitializedModule) {
                    var moduleContainerTypeSymbol = null;
                    var moduleParent = this.getParent(variableDeclaration);

                    if (moduleParent) {
                        members = moduleParent.getMembers();

                        for (var i = 0; i < members.length; i++) {
                            if ((members[i].name === declName) && (members[i].isContainer())) {
                                moduleContainerTypeSymbol = members[i];
                                break;
                            }
                        }
                    }

                    if (!moduleContainerTypeSymbol) {
                        var parentDecl = variableDeclaration.getParentDecl();

                        if (parentDecl) {
                            var searchKind = (declFlags & (32768 /* InitializedModule */ | 65536 /* InitializedDynamicModule */)) ? TypeScript.PullElementKind.SomeContainer : 64 /* Enum */;
                            var childDecls = parentDecl.searchChildDecls(declName, searchKind);

                            if (childDecls.length) {
                                for (var i = 0; i < childDecls.length; i++) {
                                    if (childDecls[i].getValueDecl() === variableDeclaration) {
                                        moduleContainerTypeSymbol = childDecls[i].getSymbol();
                                    }
                                }
                            }
                        }
                        if (!moduleContainerTypeSymbol) {
                            moduleContainerTypeSymbol = this.semanticInfoChain.findTopLevelSymbol(declName, TypeScript.PullElementKind.SomeContainer, this.semanticInfo.getPath());

                            if (!moduleContainerTypeSymbol) {
                                moduleContainerTypeSymbol = this.semanticInfoChain.findTopLevelSymbol(declName, 64 /* Enum */, this.semanticInfo.getPath());
                            }
                        }
                    }

                    if (moduleContainerTypeSymbol && (!moduleContainerTypeSymbol.isContainer())) {
                        moduleContainerTypeSymbol = null;
                    }

                    if (moduleContainerTypeSymbol) {
                        variableSymbol = moduleContainerTypeSymbol.getInstanceSymbol();

                        variableSymbol.addDeclaration(variableDeclaration);
                        variableDeclaration.setSymbol(variableSymbol);

                        decls = moduleContainerTypeSymbol.getDeclarations();

                        if (decls.length) {
                            decl = decls[decls.length - 1];
                            ast = this.semanticInfo.getASTForDecl(decl);

                            if (ast) {
                                this.semanticInfo.setASTForDecl(variableDeclaration, ast);
                            }
                        }
                    } else {
                        TypeScript.Debug.assert(false, "Attempted to bind invalid implicit variable symbol");
                    }
                }
            } else {
                variableSymbol.addDeclaration(variableDeclaration);
                variableDeclaration.setSymbol(variableSymbol);
            }

            if (parent && !parentHadSymbol) {
                if (declFlags & 1 /* Exported */) {
                    parent.addMember(variableSymbol);
                } else {
                    parent.addEnclosedNonMember(variableSymbol);
                }
            }
        };

        PullSymbolBinder.prototype.bindPropertyDeclarationToPullSymbol = function (propertyDeclaration) {
            var declFlags = propertyDeclaration.flags;
            var declKind = propertyDeclaration.kind;
            var propDeclAST = this.semanticInfo.getASTForDecl(propertyDeclaration);

            var isStatic = false;
            var isOptional = false;

            var propertySymbol = null;

            if (TypeScript.hasFlag(declFlags, 16 /* Static */)) {
                isStatic = true;
            }

            if (TypeScript.hasFlag(declFlags, 128 /* Optional */)) {
                isOptional = true;
            }

            var declName = propertyDeclaration.name;

            var parentHadSymbol = false;

            var parent = this.getParent(propertyDeclaration, true);

            if (parent.isClass() && isStatic) {
                parent = parent.getConstructorMethod().type;
            }

            propertySymbol = parent.findMember(declName, false);

            if (propertySymbol) {
                var span = propertyDeclaration.getSpan();

                propertyDeclaration.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), span.start(), span.length(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [propertyDeclaration.getDisplayName()]));

                propertySymbol = null;
            }

            if (propertySymbol) {
                parentHadSymbol = true;
            }

            var classTypeSymbol;

            if (!parentHadSymbol) {
                propertySymbol = new TypeScript.PullSymbol(declName, declKind);
            }

            propertySymbol.addDeclaration(propertyDeclaration);
            propertyDeclaration.setSymbol(propertySymbol);

            this.semanticInfo.setSymbolForAST(propDeclAST.id, propertySymbol);
            this.semanticInfo.setSymbolForAST(propDeclAST, propertySymbol);

            if (isOptional) {
                propertySymbol.isOptional = true;
            }

            if (parent && !parentHadSymbol) {
                parent.addMember(propertySymbol);
            }
        };

        PullSymbolBinder.prototype.bindParameterSymbols = function (funcDecl, funcType, signatureSymbol) {
            var parameters = [];
            var decl = null;
            var argDecl = null;
            var parameterSymbol = null;
            var isProperty = false;
            var params = new TypeScript.BlockIntrinsics();

            if (funcDecl.arguments) {
                for (var i = 0; i < funcDecl.arguments.members.length; i++) {
                    argDecl = funcDecl.arguments.members[i];
                    decl = this.semanticInfo.getDeclForAST(argDecl);
                    isProperty = TypeScript.hasFlag(argDecl.getVarFlags(), 256 /* Property */);
                    parameterSymbol = new TypeScript.PullSymbol(argDecl.id.text(), 2048 /* Parameter */);

                    if (funcDecl.variableArgList && i === funcDecl.arguments.members.length - 1) {
                        parameterSymbol.isVarArg = true;
                    }

                    if (decl.flags & 128 /* Optional */) {
                        parameterSymbol.isOptional = true;
                    }

                    if (params[argDecl.id.text()]) {
                        decl.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), argDecl.minChar, argDecl.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [argDecl.id.actualText]));
                    } else {
                        params[argDecl.id.text()] = true;
                    }
                    if (decl) {
                        if (isProperty) {
                            decl.ensureSymbolIsBound();
                            var valDecl = decl.getValueDecl();

                            if (valDecl) {
                                valDecl.setSymbol(parameterSymbol);
                                parameterSymbol.addDeclaration(valDecl);
                            }
                        } else {
                            parameterSymbol.addDeclaration(decl);
                            decl.setSymbol(parameterSymbol);
                        }
                    }

                    signatureSymbol.addParameter(parameterSymbol, parameterSymbol.isOptional);

                    if (signatureSymbol.isDefinition()) {
                        funcType.addEnclosedNonMember(parameterSymbol);
                    }
                }
            }
        };

        PullSymbolBinder.prototype.bindFunctionDeclarationToPullSymbol = function (functionDeclaration) {
            var declKind = functionDeclaration.kind;
            var declFlags = functionDeclaration.flags;
            var funcDeclAST = this.semanticInfo.getASTForDecl(functionDeclaration);

            var isExported = (declFlags & 1 /* Exported */) !== 0;

            var funcName = functionDeclaration.name;

            var isSignature = (declFlags & 2048 /* Signature */) !== 0;

            var parent = this.getParent(functionDeclaration, true);
            var parentDecl = functionDeclaration.getParentDecl();
            var parentHadSymbol = false;

            var functionSymbol = null;
            var functionTypeSymbol = null;

            if (parent) {
                functionSymbol = parent.findMember(funcName, false);

                if (!functionSymbol) {
                    functionSymbol = parent.findContainedNonMember(funcName);

                    if (functionSymbol) {
                        var declarations = functionSymbol.getDeclarations();

                        if (declarations.length) {
                            var funcSymbolParentDecl = declarations[0].getParentDecl();

                            if (parentDecl !== funcSymbolParentDecl) {
                                functionSymbol = null;
                            }
                        }
                    }
                }
            } else if (!(functionDeclaration.flags & 1 /* Exported */)) {
                functionSymbol = this.semanticInfoChain.findTopLevelSymbol(funcName, TypeScript.PullElementKind.SomeValue, this.semanticInfo.getPath());
            }

            if (functionSymbol && (functionSymbol.kind !== 16384 /* Function */ || (!isSignature && !functionSymbol.allDeclsHaveFlag(2048 /* Signature */)))) {
                functionDeclaration.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [functionDeclaration.getDisplayName()]));
                functionSymbol = null;
            }

            if (functionSymbol) {
                functionTypeSymbol = functionSymbol.type;
                parentHadSymbol = true;
            }

            if (!functionSymbol) {
                functionSymbol = new TypeScript.PullSymbol(funcName, 16384 /* Function */);
            }

            if (!functionTypeSymbol) {
                functionTypeSymbol = new TypeScript.PullTypeSymbol("", 16777216 /* FunctionType */);
                functionSymbol.type = functionTypeSymbol;
                functionTypeSymbol.setFunctionSymbol(functionSymbol);
            }

            functionDeclaration.setSymbol(functionSymbol);
            functionSymbol.addDeclaration(functionDeclaration);
            functionTypeSymbol.addDeclaration(functionDeclaration);

            this.semanticInfo.setSymbolForAST(funcDeclAST.name, functionSymbol);
            this.semanticInfo.setSymbolForAST(funcDeclAST, functionSymbol);

            if (parent && !parentHadSymbol) {
                if (isExported) {
                    parent.addMember(functionSymbol);
                } else {
                    parent.addEnclosedNonMember(functionSymbol);
                }
            }

            var signature = isSignature ? new TypeScript.PullSignatureSymbol(1048576 /* CallSignature */) : new TypeScript.PullDefinitionSignatureSymbol(1048576 /* CallSignature */);

            signature.addDeclaration(functionDeclaration);
            functionDeclaration.setSignatureSymbol(signature);

            if (funcDeclAST.variableArgList) {
                signature.hasVarArgs = true;
            }

            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(functionDeclaration), functionTypeSymbol, signature);

            var typeParameters = functionDeclaration.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = signature.findTypeParameter(typeParameters[i].name);

                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].name, true);

                    signature.addTypeParameter(typeParameter);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();

                    var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameterDecls[0]);
                    functionDeclaration.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), typeParameterAST.minChar, typeParameterAST.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [typeParameter.name]));
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }

            functionTypeSymbol.addCallSignature(signature);

            var otherDecls = this.findDeclsInContext(functionDeclaration, functionDeclaration.kind, false);

            if (otherDecls && otherDecls.length) {
                for (var i = 0; i < otherDecls.length; i++) {
                    otherDecls[i].ensureSymbolIsBound();
                }
            }
        };

        PullSymbolBinder.prototype.bindFunctionExpressionToPullSymbol = function (functionExpressionDeclaration) {
            var declKind = functionExpressionDeclaration.kind;
            var declFlags = functionExpressionDeclaration.flags;
            var funcExpAST = this.semanticInfo.getASTForDecl(functionExpressionDeclaration);

            var functionName = declKind == 131072 /* FunctionExpression */ ? (functionExpressionDeclaration).getFunctionExpressionName() : functionExpressionDeclaration.name;
            var functionSymbol = new TypeScript.PullSymbol(functionName, 16384 /* Function */);
            var functionTypeSymbol = new TypeScript.PullTypeSymbol("", 16777216 /* FunctionType */);
            functionTypeSymbol.setFunctionSymbol(functionSymbol);

            functionSymbol.type = functionTypeSymbol;

            functionExpressionDeclaration.setSymbol(functionSymbol);
            functionSymbol.addDeclaration(functionExpressionDeclaration);
            functionTypeSymbol.addDeclaration(functionExpressionDeclaration);

            if (funcExpAST.name) {
                this.semanticInfo.setSymbolForAST(funcExpAST.name, functionSymbol);
            }
            this.semanticInfo.setSymbolForAST(funcExpAST, functionSymbol);

            var signature = new TypeScript.PullDefinitionSignatureSymbol(1048576 /* CallSignature */);

            if (funcExpAST.variableArgList) {
                signature.hasVarArgs = true;
            }

            var typeParameters = functionExpressionDeclaration.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = signature.findTypeParameter(typeParameters[i].name);

                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].name, true);

                    signature.addTypeParameter(typeParameter);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();

                    var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameterDecls[0]);
                    functionExpressionDeclaration.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), typeParameterAST.minChar, typeParameterAST.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [typeParameter.getName()]));
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }

            signature.addDeclaration(functionExpressionDeclaration);
            functionExpressionDeclaration.setSignatureSymbol(signature);

            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(functionExpressionDeclaration), functionTypeSymbol, signature);

            functionTypeSymbol.addCallSignature(signature);
        };

        PullSymbolBinder.prototype.bindFunctionTypeDeclarationToPullSymbol = function (functionTypeDeclaration) {
            var declKind = functionTypeDeclaration.kind;
            var declFlags = functionTypeDeclaration.flags;
            var funcTypeAST = this.semanticInfo.getASTForDecl(functionTypeDeclaration);

            var functionTypeSymbol = new TypeScript.PullTypeSymbol("", 16777216 /* FunctionType */);

            functionTypeDeclaration.setSymbol(functionTypeSymbol);
            functionTypeSymbol.addDeclaration(functionTypeDeclaration);
            this.semanticInfo.setSymbolForAST(funcTypeAST, functionTypeSymbol);

            var isSignature = (declFlags & 2048 /* Signature */) !== 0;
            var signature = isSignature ? new TypeScript.PullSignatureSymbol(1048576 /* CallSignature */) : new TypeScript.PullDefinitionSignatureSymbol(1048576 /* CallSignature */);

            if (funcTypeAST.variableArgList) {
                signature.hasVarArgs = true;
            }

            var typeParameters = functionTypeDeclaration.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = signature.findTypeParameter(typeParameters[i].name);

                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].name, true);

                    signature.addTypeParameter(typeParameter);
                } else {
                    var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameterDecls[0]);
                    functionTypeDeclaration.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), typeParameterAST.minChar, typeParameterAST.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [typeParameter.name]));
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }

            signature.addDeclaration(functionTypeDeclaration);
            functionTypeDeclaration.setSignatureSymbol(signature);

            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(functionTypeDeclaration), functionTypeSymbol, signature);

            functionTypeSymbol.addCallSignature(signature);
        };

        PullSymbolBinder.prototype.bindMethodDeclarationToPullSymbol = function (methodDeclaration) {
            var declKind = methodDeclaration.kind;
            var declFlags = methodDeclaration.flags;
            var methodAST = this.semanticInfo.getASTForDecl(methodDeclaration);

            var isPrivate = (declFlags & 2 /* Private */) !== 0;
            var isStatic = (declFlags & 16 /* Static */) !== 0;
            var isOptional = (declFlags & 128 /* Optional */) !== 0;

            var methodName = methodDeclaration.name;

            var isSignature = (declFlags & 2048 /* Signature */) !== 0;

            var parent = this.getParent(methodDeclaration, true);
            var parentHadSymbol = false;

            var methodSymbol = null;
            var methodTypeSymbol = null;

            if (parent.isClass() && isStatic) {
                parent = parent.getConstructorMethod().type;
            }

            methodSymbol = parent.findMember(methodName, false);

            if (methodSymbol && (methodSymbol.kind !== 65536 /* Method */ || (!isSignature && !methodSymbol.allDeclsHaveFlag(2048 /* Signature */)))) {
                methodDeclaration.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), methodAST.minChar, methodAST.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [methodDeclaration.getDisplayName()]));
                methodSymbol = null;
            }

            if (methodSymbol) {
                methodTypeSymbol = methodSymbol.type;
                parentHadSymbol = true;
            }

            if (!methodSymbol) {
                methodSymbol = new TypeScript.PullSymbol(methodName, 65536 /* Method */);
            }

            if (!methodTypeSymbol) {
                methodTypeSymbol = new TypeScript.PullTypeSymbol("", 16777216 /* FunctionType */);
                methodSymbol.type = methodTypeSymbol;
                methodTypeSymbol.setFunctionSymbol(methodSymbol);
            }

            methodDeclaration.setSymbol(methodSymbol);
            methodSymbol.addDeclaration(methodDeclaration);
            methodTypeSymbol.addDeclaration(methodDeclaration);
            this.semanticInfo.setSymbolForAST(methodAST.name, methodSymbol);
            this.semanticInfo.setSymbolForAST(methodAST, methodSymbol);

            if (isOptional) {
                methodSymbol.isOptional = true;
            }

            if (!parentHadSymbol) {
                parent.addMember(methodSymbol);
            }

            var sigKind = 1048576 /* CallSignature */;

            var signature = isSignature ? new TypeScript.PullSignatureSymbol(sigKind) : new TypeScript.PullDefinitionSignatureSymbol(sigKind);

            if (methodAST.variableArgList) {
                signature.hasVarArgs = true;
            }

            var typeParameters = methodDeclaration.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;
            var typeParameterName;
            var typeParameterAST;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameterName = typeParameters[i].name;
                typeParameterAST = this.semanticInfo.getASTForDecl(typeParameters[i]);

                typeParameter = signature.findTypeParameter(typeParameterName);

                if (!typeParameter) {
                    if (!typeParameterAST.constraint) {
                        typeParameter = this.findTypeParameterInCache(typeParameterName);
                    }

                    if (!typeParameter) {
                        typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameterName, true);

                        if (!typeParameterAST.constraint) {
                            this.addTypeParameterToCache(typeParameter);
                        }
                    }

                    signature.addTypeParameter(typeParameter);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();

                    typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameterDecls[0]);
                    methodDeclaration.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), typeParameterAST.minChar, typeParameterAST.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [typeParameter.getName()]));
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }

            signature.addDeclaration(methodDeclaration);
            methodDeclaration.setSignatureSymbol(signature);

            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(methodDeclaration), methodTypeSymbol, signature);

            methodTypeSymbol.addCallSignature(signature);

            var otherDecls = this.findDeclsInContext(methodDeclaration, methodDeclaration.kind, false);

            if (otherDecls && otherDecls.length) {
                for (var i = 0; i < otherDecls.length; i++) {
                    otherDecls[i].ensureSymbolIsBound();
                }
            }
        };

        PullSymbolBinder.prototype.bindConstructorDeclarationToPullSymbol = function (constructorDeclaration) {
            var declKind = constructorDeclaration.kind;
            var declFlags = constructorDeclaration.flags;
            var constructorAST = this.semanticInfo.getASTForDecl(constructorDeclaration);

            var constructorName = constructorDeclaration.name;

            var isSignature = (declFlags & 2048 /* Signature */) !== 0;

            var parent = this.getParent(constructorDeclaration, true);

            var parentHadSymbol = false;

            var constructorSymbol = parent.getConstructorMethod();
            var constructorTypeSymbol = null;

            if (constructorSymbol && (constructorSymbol.kind !== 32768 /* ConstructorMethod */ || (!isSignature && constructorSymbol.type && constructorSymbol.type.hasOwnConstructSignatures()))) {
                var hasDefinitionSignature = false;
                var constructorSigs = constructorSymbol.type.getConstructSignatures();

                for (var i = 0; i < constructorSigs.length; i++) {
                    if (!constructorSigs[i].hasFlag(2048 /* Signature */)) {
                        hasDefinitionSignature = true;
                        break;
                    }
                }

                if (hasDefinitionSignature) {
                    constructorDeclaration.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), constructorAST.minChar, constructorAST.getLength(), TypeScript.DiagnosticCode.Multiple_constructor_implementations_are_not_allowed, null));

                    constructorSymbol = null;
                }
            }

            if (constructorSymbol) {
                constructorTypeSymbol = constructorSymbol.type;
            } else {
                constructorSymbol = new TypeScript.PullSymbol(constructorName, 32768 /* ConstructorMethod */);
                constructorTypeSymbol = new TypeScript.PullTypeSymbol("", 33554432 /* ConstructorType */);
            }

            parent.setConstructorMethod(constructorSymbol);
            constructorSymbol.type = constructorTypeSymbol;

            constructorDeclaration.setSymbol(constructorSymbol);
            constructorSymbol.addDeclaration(constructorDeclaration);
            constructorTypeSymbol.addDeclaration(constructorDeclaration);
            constructorSymbol.setIsSynthesized(false);
            this.semanticInfo.setSymbolForAST(constructorAST, constructorSymbol);

            var constructSignature = isSignature ? new TypeScript.PullSignatureSymbol(2097152 /* ConstructSignature */) : new TypeScript.PullDefinitionSignatureSymbol(2097152 /* ConstructSignature */);

            constructSignature.returnType = parent;

            constructSignature.addDeclaration(constructorDeclaration);
            constructorDeclaration.setSignatureSymbol(constructSignature);

            this.bindParameterSymbols(constructorAST, constructorTypeSymbol, constructSignature);

            var typeParameters = constructorTypeSymbol.getTypeParameters();

            for (var i = 0; i < typeParameters.length; i++) {
                constructSignature.addTypeParameter(typeParameters[i]);
            }

            if (constructorAST.variableArgList) {
                constructSignature.hasVarArgs = true;
            }

            constructorTypeSymbol.addConstructSignature(constructSignature);

            var otherDecls = this.findDeclsInContext(constructorDeclaration, constructorDeclaration.kind, false);

            if (otherDecls && otherDecls.length) {
                for (var i = 0; i < otherDecls.length; i++) {
                    otherDecls[i].ensureSymbolIsBound();
                }
            }
        };

        PullSymbolBinder.prototype.bindConstructSignatureDeclarationToPullSymbol = function (constructSignatureDeclaration) {
            var parent = this.getParent(constructSignatureDeclaration, true);
            var constructorAST = this.semanticInfo.getASTForDecl(constructSignatureDeclaration);

            var constructSignature = new TypeScript.PullSignatureSymbol(2097152 /* ConstructSignature */);

            if (constructorAST.variableArgList) {
                constructSignature.hasVarArgs = true;
            }

            var typeParameters = constructSignatureDeclaration.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = constructSignature.findTypeParameter(typeParameters[i].name);

                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].name, true);

                    constructSignature.addTypeParameter(typeParameter);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();

                    var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameterDecls[0]);
                    constructSignatureDeclaration.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), typeParameterAST.minChar, typeParameterAST.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [typeParameter.getName()]));
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }

            constructSignature.addDeclaration(constructSignatureDeclaration);
            constructSignatureDeclaration.setSignatureSymbol(constructSignature);

            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(constructSignatureDeclaration), null, constructSignature);

            this.semanticInfo.setSymbolForAST(this.semanticInfo.getASTForDecl(constructSignatureDeclaration), constructSignature);

            parent.addConstructSignature(constructSignature);
        };

        PullSymbolBinder.prototype.bindCallSignatureDeclarationToPullSymbol = function (callSignatureDeclaration) {
            var parent = this.getParent(callSignatureDeclaration, true);
            var callSignatureAST = this.semanticInfo.getASTForDecl(callSignatureDeclaration);

            var callSignature = new TypeScript.PullSignatureSymbol(1048576 /* CallSignature */);

            if (callSignatureAST.variableArgList) {
                callSignature.hasVarArgs = true;
            }

            var typeParameters = callSignatureDeclaration.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = callSignature.findTypeParameter(typeParameters[i].name);

                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].name, true);

                    callSignature.addTypeParameter(typeParameter);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();

                    var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameterDecls[0]);
                    callSignatureDeclaration.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), typeParameterAST.minChar, typeParameterAST.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [typeParameter.getName()]));
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }

            callSignature.addDeclaration(callSignatureDeclaration);
            callSignatureDeclaration.setSignatureSymbol(callSignature);

            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(callSignatureDeclaration), null, callSignature);

            this.semanticInfo.setSymbolForAST(this.semanticInfo.getASTForDecl(callSignatureDeclaration), callSignature);

            parent.addCallSignature(callSignature);
        };

        PullSymbolBinder.prototype.bindIndexSignatureDeclarationToPullSymbol = function (indexSignatureDeclaration) {
            var parent = this.getParent(indexSignatureDeclaration, true);

            var indexSignature = new TypeScript.PullSignatureSymbol(4194304 /* IndexSignature */);

            var typeParameters = indexSignatureDeclaration.getTypeParameters();
            var typeParameter;
            var typeParameterDecls = null;

            for (var i = 0; i < typeParameters.length; i++) {
                typeParameter = indexSignature.findTypeParameter(typeParameters[i].name);

                if (!typeParameter) {
                    typeParameter = new TypeScript.PullTypeParameterSymbol(typeParameters[i].name, true);

                    indexSignature.addTypeParameter(typeParameter);
                } else {
                    typeParameterDecls = typeParameter.getDeclarations();

                    var typeParameterAST = this.semanticInfoChain.getASTForDecl(typeParameterDecls[0]);
                    indexSignatureDeclaration.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), typeParameterAST.minChar, typeParameterAST.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [typeParameter.name]));
                }

                typeParameter.addDeclaration(typeParameters[i]);
                typeParameters[i].setSymbol(typeParameter);
            }

            indexSignature.addDeclaration(indexSignatureDeclaration);
            indexSignatureDeclaration.setSignatureSymbol(indexSignature);

            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(indexSignatureDeclaration), null, indexSignature);

            this.semanticInfo.setSymbolForAST(this.semanticInfo.getASTForDecl(indexSignatureDeclaration), indexSignature);

            parent.addIndexSignature(indexSignature);
        };

        PullSymbolBinder.prototype.bindGetAccessorDeclarationToPullSymbol = function (getAccessorDeclaration) {
            var declKind = getAccessorDeclaration.kind;
            var declFlags = getAccessorDeclaration.flags;
            var funcDeclAST = this.semanticInfo.getASTForDecl(getAccessorDeclaration);

            var isExported = (declFlags & 1 /* Exported */) !== 0;

            var funcName = getAccessorDeclaration.name;

            var isSignature = (declFlags & 2048 /* Signature */) !== 0;
            var isStatic = false;

            if (TypeScript.hasFlag(declFlags, 16 /* Static */)) {
                isStatic = true;
            }

            var parent = this.getParent(getAccessorDeclaration, true);
            var parentHadSymbol = false;

            var accessorSymbol = null;
            var getterSymbol = null;
            var getterTypeSymbol = null;

            if (isStatic) {
                parent = parent.getConstructorMethod().type;
            }

            accessorSymbol = parent.findMember(funcName, false);

            if (accessorSymbol) {
                if (!accessorSymbol.isAccessor()) {
                    getAccessorDeclaration.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [getAccessorDeclaration.getDisplayName()]));
                    accessorSymbol = null;
                } else {
                    getterSymbol = accessorSymbol.getGetter();

                    if (getterSymbol) {
                        getAccessorDeclaration.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode.Getter_0_already_declared, [getAccessorDeclaration.getDisplayName()]));
                        accessorSymbol = null;
                        getterSymbol = null;
                    }
                }
            }

            if (accessorSymbol) {
                parentHadSymbol = true;
            }

            if (accessorSymbol && getterSymbol) {
                getterTypeSymbol = getterSymbol.type;
            }

            if (!accessorSymbol) {
                accessorSymbol = new TypeScript.PullAccessorSymbol(funcName);
            }

            if (!getterSymbol) {
                getterSymbol = new TypeScript.PullSymbol(funcName, 16384 /* Function */);
                getterTypeSymbol = new TypeScript.PullTypeSymbol("", 16777216 /* FunctionType */);
                getterTypeSymbol.setFunctionSymbol(getterSymbol);

                getterSymbol.type = getterTypeSymbol;

                accessorSymbol.setGetter(getterSymbol);
            }

            getAccessorDeclaration.setSymbol(accessorSymbol);
            accessorSymbol.addDeclaration(getAccessorDeclaration);
            getterSymbol.addDeclaration(getAccessorDeclaration);

            this.semanticInfo.setSymbolForAST(funcDeclAST.name, getterSymbol);
            this.semanticInfo.setSymbolForAST(funcDeclAST, getterSymbol);

            if (!parentHadSymbol) {
                parent.addMember(accessorSymbol);
            }

            var signature = isSignature ? new TypeScript.PullSignatureSymbol(1048576 /* CallSignature */) : new TypeScript.PullDefinitionSignatureSymbol(1048576 /* CallSignature */);

            signature.addDeclaration(getAccessorDeclaration);
            getAccessorDeclaration.setSignatureSymbol(signature);

            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(getAccessorDeclaration), getterTypeSymbol, signature);

            var typeParameters = getAccessorDeclaration.getTypeParameters();

            if (typeParameters.length) {
                getAccessorDeclaration.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode.Accessors_cannot_have_type_parameters, null));
            }

            getterTypeSymbol.addCallSignature(signature);
        };

        PullSymbolBinder.prototype.bindSetAccessorDeclarationToPullSymbol = function (setAccessorDeclaration) {
            var declKind = setAccessorDeclaration.kind;
            var declFlags = setAccessorDeclaration.flags;
            var funcDeclAST = this.semanticInfo.getASTForDecl(setAccessorDeclaration);

            var isExported = (declFlags & 1 /* Exported */) !== 0;

            var funcName = setAccessorDeclaration.name;

            var isSignature = (declFlags & 2048 /* Signature */) !== 0;
            var isStatic = false;

            if (TypeScript.hasFlag(declFlags, 16 /* Static */)) {
                isStatic = true;
            }

            var parent = this.getParent(setAccessorDeclaration, true);
            var parentHadSymbol = false;

            var accessorSymbol = null;
            var setterSymbol = null;
            var setterTypeSymbol = null;

            if (isStatic) {
                parent = parent.getConstructorMethod().type;
            }

            accessorSymbol = parent.findMember(funcName, false);

            if (accessorSymbol) {
                if (!accessorSymbol.isAccessor()) {
                    setAccessorDeclaration.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode.Duplicate_identifier_0, [setAccessorDeclaration.getDisplayName()]));
                    accessorSymbol = null;
                } else {
                    setterSymbol = accessorSymbol.getSetter();

                    if (setterSymbol) {
                        setAccessorDeclaration.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode.Setter_0_already_declared, [setAccessorDeclaration.getDisplayName()]));
                        accessorSymbol = null;
                        setterSymbol = null;
                    }
                }
            }

            if (accessorSymbol) {
                parentHadSymbol = true;

                if (setterSymbol) {
                    setterTypeSymbol = setterSymbol.type;
                }
            }

            if (!accessorSymbol) {
                accessorSymbol = new TypeScript.PullAccessorSymbol(funcName);
            }

            if (!setterSymbol) {
                setterSymbol = new TypeScript.PullSymbol(funcName, 16384 /* Function */);
                setterTypeSymbol = new TypeScript.PullTypeSymbol("", 16777216 /* FunctionType */);
                setterTypeSymbol.setFunctionSymbol(setterSymbol);

                setterSymbol.type = setterTypeSymbol;

                accessorSymbol.setSetter(setterSymbol);
            }

            setAccessorDeclaration.setSymbol(accessorSymbol);
            accessorSymbol.addDeclaration(setAccessorDeclaration);
            setterSymbol.addDeclaration(setAccessorDeclaration);

            this.semanticInfo.setSymbolForAST(funcDeclAST.name, setterSymbol);
            this.semanticInfo.setSymbolForAST(funcDeclAST, setterSymbol);

            if (!parentHadSymbol) {
                parent.addMember(accessorSymbol);
            }

            var signature = isSignature ? new TypeScript.PullSignatureSymbol(1048576 /* CallSignature */) : new TypeScript.PullDefinitionSignatureSymbol(1048576 /* CallSignature */);

            signature.addDeclaration(setAccessorDeclaration);
            setAccessorDeclaration.setSignatureSymbol(signature);

            this.bindParameterSymbols(this.semanticInfo.getASTForDecl(setAccessorDeclaration), setterTypeSymbol, signature);

            var typeParameters = setAccessorDeclaration.getTypeParameters();

            if (typeParameters.length) {
                setAccessorDeclaration.addDiagnostic(new TypeScript.Diagnostic(this.semanticInfo.getPath(), funcDeclAST.minChar, funcDeclAST.getLength(), TypeScript.DiagnosticCode.Accessors_cannot_have_type_parameters, null));
            }

            setterTypeSymbol.addCallSignature(signature);
        };

        PullSymbolBinder.prototype.bindDeclToPullSymbol = function (decl) {
            if (decl.isBound()) {
                return;
            }

            decl.setIsBound(true);

            switch (decl.kind) {
                case 1 /* Script */:
                    var childDecls = decl.getChildDecls();
                    for (var i = 0; i < childDecls.length; i++) {
                        this.bindDeclToPullSymbol(childDecls[i]);
                    }
                    break;

                case 64 /* Enum */:
                case 32 /* DynamicModule */:
                case 4 /* Container */:
                    this.bindModuleDeclarationToPullSymbol(decl);
                    break;

                case 16 /* Interface */:
                    this.bindInterfaceDeclarationToPullSymbol(decl);
                    break;

                case 8 /* Class */:
                    this.bindClassDeclarationToPullSymbol(decl);
                    break;

                case 16384 /* Function */:
                    this.bindFunctionDeclarationToPullSymbol(decl);
                    break;

                case 1024 /* Variable */:
                    this.bindVariableDeclarationToPullSymbol(decl);
                    break;

                case 67108864 /* EnumMember */:
                case 4096 /* Property */:
                    this.bindPropertyDeclarationToPullSymbol(decl);
                    break;

                case 65536 /* Method */:
                    this.bindMethodDeclarationToPullSymbol(decl);
                    break;

                case 32768 /* ConstructorMethod */:
                    this.bindConstructorDeclarationToPullSymbol(decl);
                    break;

                case 1048576 /* CallSignature */:
                    this.bindCallSignatureDeclarationToPullSymbol(decl);
                    break;

                case 2097152 /* ConstructSignature */:
                    this.bindConstructSignatureDeclarationToPullSymbol(decl);
                    break;

                case 4194304 /* IndexSignature */:
                    this.bindIndexSignatureDeclarationToPullSymbol(decl);
                    break;

                case 262144 /* GetAccessor */:
                    this.bindGetAccessorDeclarationToPullSymbol(decl);
                    break;

                case 524288 /* SetAccessor */:
                    this.bindSetAccessorDeclarationToPullSymbol(decl);
                    break;

                case 8388608 /* ObjectType */:
                    this.bindObjectTypeDeclarationToPullSymbol(decl);
                    break;

                case 16777216 /* FunctionType */:
                    this.bindFunctionTypeDeclarationToPullSymbol(decl);
                    break;

                case 33554432 /* ConstructorType */:
                    this.bindConstructorTypeDeclarationToPullSymbol(decl);
                    break;

                case 131072 /* FunctionExpression */:
                    this.bindFunctionExpressionToPullSymbol(decl);
                    break;

                case 256 /* TypeAlias */:
                    this.bindImportDeclaration(decl);
                    break;

                case 2048 /* Parameter */:
                case 8192 /* TypeParameter */:
                    break;

                case 1073741824 /* CatchBlock */:
                case 536870912 /* WithBlock */:
                    break;

                default:
                    TypeScript.CompilerDiagnostics.assert(false, "Unrecognized type declaration");
            }
        };

        PullSymbolBinder.prototype.bindDeclsForUnit = function (filePath) {
            this.setUnit(filePath);

            var topLevelDecls = this.semanticInfo.getTopLevelDecls();

            for (var i = 0; i < topLevelDecls.length; i++) {
                this.bindDeclToPullSymbol(topLevelDecls[i]);
            }
        };
        return PullSymbolBinder;
    })();
    TypeScript.PullSymbolBinder = PullSymbolBinder;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    function getDiagnosticsFromEnclosingDecl(enclosingDecl, errors) {
        var declErrors = enclosingDecl.getDiagnostics();

        if (declErrors) {
            for (var i = 0; i < declErrors.length; i++) {
                errors[errors.length] = declErrors[i];
            }
        }

        var childDecls = enclosingDecl.getChildDecls();

        for (var i = 0; i < childDecls.length; i++) {
            getDiagnosticsFromEnclosingDecl(childDecls[i], errors);
        }
    }
    TypeScript.getDiagnosticsFromEnclosingDecl = getDiagnosticsFromEnclosingDecl;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    (function (PullHelpers) {
        function getSignatureForFuncDecl(funcDecl, semanticInfo) {
            var functionDecl = semanticInfo.getDeclForAST(funcDecl);
            var funcSymbol = functionDecl.getSymbol();

            if (!funcSymbol) {
                funcSymbol = functionDecl.getSignatureSymbol();
            }

            var functionSignature = null;
            var typeSymbolWithAllSignatures = null;
            if (funcSymbol.isSignature()) {
                functionSignature = funcSymbol;
                var parent = functionDecl.getParentDecl();
                typeSymbolWithAllSignatures = parent.getSymbol().type;
            } else {
                functionSignature = functionDecl.getSignatureSymbol();
                typeSymbolWithAllSignatures = funcSymbol.type;
            }
            var signatures;
            if (funcDecl.isConstructor || funcDecl.isConstructMember()) {
                signatures = typeSymbolWithAllSignatures.getConstructSignatures();
            } else if (funcDecl.isIndexerMember()) {
                signatures = typeSymbolWithAllSignatures.getIndexSignatures();
            } else {
                signatures = typeSymbolWithAllSignatures.getCallSignatures();
            }
            return {
                signature: functionSignature,
                allSignatures: signatures
            };
        }
        PullHelpers.getSignatureForFuncDecl = getSignatureForFuncDecl;

        function getAccessorSymbol(getterOrSetter, semanticInfoChain, unitPath) {
            var functionDecl = semanticInfoChain.getDeclForAST(getterOrSetter, unitPath);
            var getterOrSetterSymbol = functionDecl.getSymbol();

            return getterOrSetterSymbol;
        }
        PullHelpers.getAccessorSymbol = getAccessorSymbol;

        function getGetterAndSetterFunction(funcDecl, semanticInfoChain, unitPath) {
            var accessorSymbol = PullHelpers.getAccessorSymbol(funcDecl, semanticInfoChain, unitPath);
            var result = {
                getter: null,
                setter: null
            };
            var getter = accessorSymbol.getGetter();
            if (getter) {
                var getterDecl = getter.getDeclarations()[0];
                result.getter = semanticInfoChain.getASTForDecl(getterDecl);
            }
            var setter = accessorSymbol.getSetter();
            if (setter) {
                var setterDecl = setter.getDeclarations()[0];
                result.setter = semanticInfoChain.getASTForDecl(setterDecl);
            }

            return result;
        }
        PullHelpers.getGetterAndSetterFunction = getGetterAndSetterFunction;

        function symbolIsEnum(source) {
            return source && ((source.kind & (64 /* Enum */ | 67108864 /* EnumMember */)) || source.hasFlag(131072 /* InitializedEnum */));
        }
        PullHelpers.symbolIsEnum = symbolIsEnum;

        function symbolIsModule(symbol) {
            return symbol && (symbol.kind == 4 /* Container */ || isOneDeclarationOfKind(symbol, 4 /* Container */));
        }
        PullHelpers.symbolIsModule = symbolIsModule;

        function isOneDeclarationOfKind(symbol, kind) {
            var decls = symbol.getDeclarations();
            for (var i = 0; i < decls.length; i++) {
                if (decls[i].kind === kind) {
                    return true;
                }
            }

            return false;
        }
    })(TypeScript.PullHelpers || (TypeScript.PullHelpers = {}));
    var PullHelpers = TypeScript.PullHelpers;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var SyntaxTreeToAstVisitor = (function () {
        function SyntaxTreeToAstVisitor(fileName, lineMap, compilationSettings) {
            this.fileName = fileName;
            this.lineMap = lineMap;
            this.compilationSettings = compilationSettings;
            this.position = 0;
            this.previousTokenTrailingComments = null;
        }
        SyntaxTreeToAstVisitor.visit = function (syntaxTree, fileName, compilationSettings, incrementalAST) {
            var visitor = incrementalAST ? new SyntaxTreeToIncrementalAstVisitor(fileName, syntaxTree.lineMap(), compilationSettings) : new SyntaxTreeToAstVisitor(fileName, syntaxTree.lineMap(), compilationSettings);
            return syntaxTree.sourceUnit().accept(visitor);
        };

        SyntaxTreeToAstVisitor.prototype.movePast = function (element) {
            if (element !== null) {
                this.position += element.fullWidth();
            }
        };

        SyntaxTreeToAstVisitor.prototype.moveTo = function (element1, element2) {
            if (element2 !== null) {
                this.position += TypeScript.Syntax.childOffset(element1, element2);
            }
        };

        SyntaxTreeToAstVisitor.prototype.setCommentsAndSpan = function (ast, fullStart, node) {
            var firstToken = node.firstToken();
            var lastToken = node.lastToken();

            this.setSpan2(ast, fullStart, node, firstToken, lastToken);
            ast.setPreComments(this.convertTokenLeadingComments(firstToken, fullStart));
            ast.setPostComments(this.convertNodeTrailingComments(node, lastToken, fullStart));
        };

        SyntaxTreeToAstVisitor.prototype.copySpan = function (from, to) {
            to.minChar = from.minChar;
            to.limChar = from.limChar;
            to.trailingTriviaWidth = from.trailingTriviaWidth;
        };

        SyntaxTreeToAstVisitor.prototype.setSpan = function (span, fullStart, element) {
            this.setSpan2(span, fullStart, element, element.firstToken(), element.lastToken());
        };

        SyntaxTreeToAstVisitor.prototype.setSpan2 = function (span, fullStart, element, firstToken, lastToken) {
            var leadingTriviaWidth = firstToken ? firstToken.leadingTriviaWidth() : 0;
            var trailingTriviaWidth = lastToken ? lastToken.trailingTriviaWidth() : 0;

            var desiredMinChar = fullStart + leadingTriviaWidth;
            var desiredLimChar = fullStart + element.fullWidth() - trailingTriviaWidth;

            this.setSpanExplicit(span, desiredMinChar, desiredLimChar);

            span.trailingTriviaWidth = trailingTriviaWidth;
        };

        SyntaxTreeToAstVisitor.prototype.setSpanExplicit = function (span, start, end) {
            span.minChar = start;
            span.limChar = end;
        };

        SyntaxTreeToAstVisitor.prototype.identifierFromToken = function (token, isOptional) {
            var result = null;
            if (token.fullWidth() === 0) {
                result = new TypeScript.MissingIdentifier();
            } else if (token.kind() === 11 /* IdentifierName */) {
                var tokenText = token.text();
                var text = tokenText === SyntaxTreeToAstVisitor.protoString ? SyntaxTreeToAstVisitor.protoSubstitutionString : null;

                result = new TypeScript.Identifier(tokenText, text);
            } else {
                var tokenText = token.text();
                result = new TypeScript.Identifier(tokenText, tokenText);
            }

            if (isOptional) {
                result.setFlags(result.getFlags() | 4 /* OptionalName */);
            }

            var start = this.position + token.leadingTriviaWidth();
            this.setSpanExplicit(result, start, start + token.width());

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitSyntaxList = function (node) {
            var start = this.position;
            var array = new Array(node.childCount());

            for (var i = 0, n = node.childCount(); i < n; i++) {
                array[i] = node.childAt(i).accept(this);
            }

            var result = new TypeScript.ASTList(array);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitSeparatedSyntaxList = function (list) {
            var start = this.position;
            var array = new Array(list.nonSeparatorCount());

            for (var i = 0, n = list.childCount(); i < n; i++) {
                if (i % 2 === 0) {
                    array[i / 2] = list.childAt(i).accept(this);
                    this.previousTokenTrailingComments = null;
                } else {
                    var separatorToken = list.childAt(i);
                    this.previousTokenTrailingComments = this.convertTokenTrailingComments(separatorToken, this.position + separatorToken.leadingTriviaWidth() + separatorToken.width());
                    this.movePast(separatorToken);
                }
            }

            var result = new TypeScript.ASTList(array, list.separatorCount());
            this.setSpan(result, start, list);

            result.setPostComments(this.previousTokenTrailingComments);
            this.previousTokenTrailingComments = null;

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.createRef = function (text, minChar) {
            var id = new TypeScript.Identifier(text, null);
            id.minChar = minChar;
            return id;
        };

        SyntaxTreeToAstVisitor.prototype.convertComment = function (trivia, commentStartPosition, hasTrailingNewLine) {
            var comment = new TypeScript.Comment(trivia.fullText(), trivia.kind() === 6 /* MultiLineCommentTrivia */, hasTrailingNewLine);

            comment.minChar = commentStartPosition;
            comment.limChar = commentStartPosition + trivia.fullWidth();

            return comment;
        };

        SyntaxTreeToAstVisitor.prototype.convertComments = function (triviaList, commentStartPosition) {
            var result = [];

            for (var i = 0, n = triviaList.count(); i < n; i++) {
                var trivia = triviaList.syntaxTriviaAt(i);

                if (trivia.isComment()) {
                    var hasTrailingNewLine = ((i + 1) < n) && triviaList.syntaxTriviaAt(i + 1).isNewLine();
                    result.push(this.convertComment(trivia, commentStartPosition, hasTrailingNewLine));
                }

                commentStartPosition += trivia.fullWidth();
            }

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.mergeComments = function (comments1, comments2) {
            if (comments1 === null) {
                return comments2;
            }

            if (comments2 === null) {
                return comments1;
            }

            return comments1.concat(comments2);
        };

        SyntaxTreeToAstVisitor.prototype.convertTokenLeadingComments = function (token, commentStartPosition) {
            if (token === null) {
                return null;
            }

            var preComments = token.hasLeadingComment() ? this.convertComments(token.leadingTrivia(), commentStartPosition) : null;

            var previousTokenTrailingComments = this.previousTokenTrailingComments;
            this.previousTokenTrailingComments = null;

            return this.mergeComments(previousTokenTrailingComments, preComments);
        };

        SyntaxTreeToAstVisitor.prototype.convertTokenTrailingComments = function (token, commentStartPosition) {
            if (token === null || !token.hasTrailingComment() || token.hasTrailingNewLine()) {
                return null;
            }

            return this.convertComments(token.trailingTrivia(), commentStartPosition);
        };

        SyntaxTreeToAstVisitor.prototype.convertNodeTrailingComments = function (node, lastToken, nodeStart) {
            if (lastToken === null || !lastToken.hasTrailingComment() || lastToken.hasTrailingNewLine()) {
                return null;
            }

            return this.convertComments(lastToken.trailingTrivia(), nodeStart + node.fullWidth() - lastToken.trailingTriviaWidth());
        };

        SyntaxTreeToAstVisitor.prototype.visitToken = function (token) {
            var fullStart = this.position;

            var result;
            if (token.kind() === 35 /* ThisKeyword */) {
                result = new TypeScript.ThisExpression();
            } else if (token.kind() === 50 /* SuperKeyword */) {
                result = new TypeScript.SuperExpression();
            } else if (token.kind() === 37 /* TrueKeyword */) {
                result = new TypeScript.LiteralExpression(3 /* TrueLiteral */);
            } else if (token.kind() === 24 /* FalseKeyword */) {
                result = new TypeScript.LiteralExpression(4 /* FalseLiteral */);
            } else if (token.kind() === 32 /* NullKeyword */) {
                result = new TypeScript.LiteralExpression(8 /* NullLiteral */);
            } else if (token.kind() === 14 /* StringLiteral */) {
                result = new TypeScript.StringLiteral(token.text(), token.valueText());
            } else if (token.kind() === 12 /* RegularExpressionLiteral */) {
                result = new TypeScript.RegexLiteral(token.text());
            } else if (token.kind() === 13 /* NumericLiteral */) {
                var preComments = this.convertTokenLeadingComments(token, fullStart);

                var value = token.text().indexOf(".") > 0 ? parseFloat(token.text()) : parseInt(token.text());
                result = new TypeScript.NumberLiteral(value, token.text());

                result.setPreComments(preComments);
            } else {
                result = this.identifierFromToken(token, false);
            }

            this.movePast(token);

            var start = fullStart + token.leadingTriviaWidth();
            this.setSpanExplicit(result, start, start + token.width());
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.getLeadingComments = function (node) {
            var firstToken = node.firstToken();
            var result = [];

            if (firstToken.hasLeadingComment()) {
                var leadingTrivia = firstToken.leadingTrivia();

                for (var i = 0, n = leadingTrivia.count(); i < n; i++) {
                    var trivia = leadingTrivia.syntaxTriviaAt(i);

                    if (trivia.isComment()) {
                        result.push(trivia);
                    }
                }
            }

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.hasTopLevelImportOrExport = function (node) {
            var firstToken;

            for (var i = 0, n = node.moduleElements.childCount(); i < n; i++) {
                var moduleElement = node.moduleElements.childAt(i);

                firstToken = moduleElement.firstToken();
                if (firstToken !== null && firstToken.kind() === 47 /* ExportKeyword */) {
                    return true;
                }

                if (moduleElement.kind() === 133 /* ImportDeclaration */) {
                    var importDecl = moduleElement;
                    if (importDecl.moduleReference.kind() === 245 /* ExternalModuleReference */) {
                        return true;
                    }
                }
            }

            var leadingComments = this.getLeadingComments(node);
            for (var i = 0, n = leadingComments.length; i < n; i++) {
                var trivia = leadingComments[i];

                if (TypeScript.getImplicitImport(trivia.fullText())) {
                    return true;
                }
            }

            return false;
        };

        SyntaxTreeToAstVisitor.prototype.getAmdDependency = function (comment) {
            var amdDependencyRegEx = /^\/\/\/\s*<amd-dependency\s+path=('|")(.+?)\1/gim;
            var match = amdDependencyRegEx.exec(comment);
            return match ? match[2] : null;
        };

        SyntaxTreeToAstVisitor.prototype.visitSourceUnit = function (node) {
            var start = this.position;

            var bod = this.visitSyntaxList(node.moduleElements);

            var topLevelMod = null;
            if (this.hasTopLevelImportOrExport(node)) {
                var correctedFileName = TypeScript.switchToForwardSlashes(this.fileName);
                var id = new TypeScript.Identifier(correctedFileName, correctedFileName);
                topLevelMod = new TypeScript.ModuleDeclaration(id, bod, null);
                this.setSpanExplicit(topLevelMod, start, this.position);

                var moduleFlags = topLevelMod.getModuleFlags() | 512 /* IsDynamic */ | 256 /* IsWholeFile */ | 1 /* Exported */;
                if (TypeScript.isDTSFile(this.fileName)) {
                    moduleFlags |= 8 /* Ambient */;
                }

                topLevelMod.setModuleFlags(moduleFlags);

                topLevelMod.prettyName = TypeScript.getPrettyName(correctedFileName);

                var leadingComments = this.getLeadingComments(node);
                for (var i = 0, n = leadingComments.length; i < n; i++) {
                    var trivia = leadingComments[i];
                    var amdDependency = this.getAmdDependency(trivia.fullText());
                    if (amdDependency) {
                        topLevelMod.amdDependencies.push(amdDependency);
                    }
                }

                bod = new TypeScript.ASTList([topLevelMod]);
                this.setSpanExplicit(bod, start, this.position);
            }

            var result = new TypeScript.Script();
            this.setSpanExplicit(result, start, start + node.fullWidth());

            result.moduleElements = bod;
            result.topLevelMod = topLevelMod;
            result.isDeclareFile = TypeScript.isDTSFile(this.fileName);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitExternalModuleReference = function (node) {
            this.moveTo(node, node.stringLiteral);
            var result = this.identifierFromToken(node.stringLiteral, false);
            this.movePast(node.stringLiteral);
            this.movePast(node.closeParenToken);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitModuleNameModuleReference = function (node) {
            return node.moduleName.accept(this);
        };

        SyntaxTreeToAstVisitor.prototype.visitClassDeclaration = function (node) {
            var start = this.position;

            this.moveTo(node, node.identifier);
            var name = this.identifierFromToken(node.identifier, false);
            this.movePast(node.identifier);

            var typeParameters = node.typeParameterList === null ? null : node.typeParameterList.accept(this);
            var extendsList = null;
            var implementsList = null;

            for (var i = 0, n = node.heritageClauses.childCount(); i < n; i++) {
                var heritageClause = node.heritageClauses.childAt(i);
                if (heritageClause.extendsOrImplementsKeyword.tokenKind === 48 /* ExtendsKeyword */) {
                    extendsList = heritageClause.accept(this);
                } else {
                    implementsList = heritageClause.accept(this);
                }
            }

            this.movePast(node.openBraceToken);
            var members = this.visitSyntaxList(node.classElements);
            var closeBracePosition = this.position;
            this.movePast(node.closeBraceToken);
            var closeBraceSpan = new TypeScript.ASTSpan();
            this.setSpan(closeBraceSpan, closeBracePosition, node.closeBraceToken);

            var result = new TypeScript.ClassDeclaration(name, typeParameters, members, extendsList, implementsList, closeBraceSpan);
            this.setCommentsAndSpan(result, start, node);

            for (var i = 0; i < members.members.length; i++) {
                var member = members.members[i];
                if (member.nodeType() === 13 /* FunctionDeclaration */) {
                    var funcDecl = member;

                    if (funcDecl.isConstructor) {
                        funcDecl.classDecl = result;

                        result.constructorDecl = funcDecl;
                    }
                }
            }

            this.completeClassDeclaration(node, result);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.completeClassDeclaration = function (node, result) {
            var flags = result.getVarFlags();
            if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 47 /* ExportKeyword */)) {
                flags = flags | 1 /* Exported */;
            }

            if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 63 /* DeclareKeyword */)) {
                flags = flags | 8 /* Ambient */;
            }

            result.setVarFlags(flags);
        };

        SyntaxTreeToAstVisitor.prototype.visitInterfaceDeclaration = function (node) {
            var start = this.position;

            this.moveTo(node, node.identifier);
            var name = this.identifierFromToken(node.identifier, false);
            this.movePast(node.identifier);
            var typeParameters = node.typeParameterList === null ? null : node.typeParameterList.accept(this);

            var extendsList = null;

            for (var i = 0, n = node.heritageClauses.childCount(); i < n; i++) {
                var heritageClause = node.heritageClauses.childAt(i);
                if (i === 0) {
                    extendsList = heritageClause.accept(this);
                } else {
                    this.movePast(heritageClause);
                }
            }

            this.movePast(node.body.openBraceToken);
            var members = this.visitSeparatedSyntaxList(node.body.typeMembers);

            this.movePast(node.body.closeBraceToken);

            var result = new TypeScript.InterfaceDeclaration(name, typeParameters, members, extendsList, null, false);
            this.setCommentsAndSpan(result, start, node);

            this.completeInterfaceDeclaration(node, result);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.completeInterfaceDeclaration = function (node, result) {
            if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 47 /* ExportKeyword */)) {
                result.setVarFlags(result.getVarFlags() | 1 /* Exported */);
            }
        };

        SyntaxTreeToAstVisitor.prototype.visitHeritageClause = function (node) {
            var start = this.position;
            var array = new Array(node.typeNames.nonSeparatorCount());

            this.movePast(node.extendsOrImplementsKeyword);
            for (var i = 0, n = node.typeNames.childCount(); i < n; i++) {
                if (i % 2 === 1) {
                    this.movePast(node.typeNames.childAt(i));
                } else {
                    var type = this.visitType(node.typeNames.childAt(i)).term;
                    array[i / 2] = type;
                }
            }

            var result = new TypeScript.ASTList(array);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.getModuleNames = function (node) {
            var result = [];

            if (node.stringLiteral !== null) {
                result.push(this.identifierFromToken(node.stringLiteral, false));
                this.movePast(node.stringLiteral);
            } else {
                this.getModuleNamesHelper(node.moduleName, result);
            }

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.getModuleNamesHelper = function (name, result) {
            if (name.kind() === 121 /* QualifiedName */) {
                var qualifiedName = name;
                this.getModuleNamesHelper(qualifiedName.left, result);
                this.movePast(qualifiedName.dotToken);
                result.push(this.identifierFromToken(qualifiedName.right, false));
                this.movePast(qualifiedName.right);
            } else {
                result.push(this.identifierFromToken(name, false));
                this.movePast(name);
            }
        };

        SyntaxTreeToAstVisitor.prototype.visitModuleDeclaration = function (node) {
            var start = this.position;

            var firstToken = node.firstToken();
            var preComments = this.convertTokenLeadingComments(firstToken, start);
            var postComments = this.convertNodeTrailingComments(node, node.closeBraceToken, start);

            this.moveTo(node, node.moduleKeyword);
            this.movePast(node.moduleKeyword);
            var names = this.getModuleNames(node);
            this.movePast(node.openBraceToken);

            var members = this.visitSyntaxList(node.moduleElements);

            var closeBracePosition = this.position;
            this.movePast(node.closeBraceToken);
            var closeBraceSpan = new TypeScript.ASTSpan();
            this.setSpan(closeBraceSpan, closeBracePosition, node.closeBraceToken);

            for (var i = names.length - 1; i >= 0; i--) {
                var innerName = names[i];

                var result = new TypeScript.ModuleDeclaration(innerName, members, closeBraceSpan);
                this.setSpan(result, start, node);

                result.setPreComments(preComments);
                result.setPostComments(postComments);

                preComments = null;
                postComments = null;

                if (i || TypeScript.SyntaxUtilities.containsToken(node.modifiers, 47 /* ExportKeyword */)) {
                    result.setModuleFlags(result.getModuleFlags() | 1 /* Exported */);
                }

                members = new TypeScript.ASTList([result]);
            }

            this.completeModuleDeclaration(node, result);

            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.completeModuleDeclaration = function (node, result) {
            if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 63 /* DeclareKeyword */)) {
                result.setModuleFlags(result.getModuleFlags() | 8 /* Ambient */);
            }
        };

        SyntaxTreeToAstVisitor.prototype.hasDotDotDotParameter = function (parameters) {
            for (var i = 0, n = parameters.nonSeparatorCount(); i < n; i++) {
                if ((parameters.nonSeparatorAt(i)).dotDotDotToken) {
                    return true;
                }
            }

            return false;
        };

        SyntaxTreeToAstVisitor.prototype.visitFunctionDeclaration = function (node) {
            var start = this.position;

            this.moveTo(node, node.identifier);
            var name = this.identifierFromToken(node.identifier, false);

            this.movePast(node.identifier);

            var typeParameters = node.callSignature.typeParameterList === null ? null : node.callSignature.typeParameterList.accept(this);
            var parameters = node.callSignature.parameterList.accept(this);

            var returnType = node.callSignature.typeAnnotation ? node.callSignature.typeAnnotation.accept(this) : null;

            var block = node.block ? node.block.accept(this) : null;

            this.movePast(node.semicolonToken);

            var result = new TypeScript.FunctionDeclaration(name, block, false, typeParameters, parameters, returnType, this.hasDotDotDotParameter(node.callSignature.parameterList.parameters));
            this.setCommentsAndSpan(result, start, node);

            if (node.semicolonToken) {
                result.setFunctionFlags(result.getFunctionFlags() | 128 /* Signature */);
            }

            this.completeFunctionDeclaration(node, result);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.completeFunctionDeclaration = function (node, result) {
            var flags = result.getFunctionFlags();
            if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 47 /* ExportKeyword */)) {
                flags = flags | 1 /* Exported */;
            }

            if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 63 /* DeclareKeyword */)) {
                flags = flags | 8 /* Ambient */;
            }

            result.setFunctionFlags(flags);
        };

        SyntaxTreeToAstVisitor.prototype.visitEnumDeclaration = function (node) {
            var start = this.position;

            this.moveTo(node, node.identifier);
            var name = this.identifierFromToken(node.identifier, false);
            this.movePast(node.identifier);

            this.movePast(node.openBraceToken);
            var array = new Array(node.enumElements.nonSeparatorCount());

            var declarators = [];

            for (var i = 0, n = node.enumElements.childCount(); i < n; i++) {
                if (i % 2 === 1) {
                    this.movePast(node.enumElements.childAt(i));
                } else {
                    var enumElement = node.enumElements.childAt(i);
                    var enumElementFullStart = this.position;
                    var memberStart = this.position + enumElement.leadingTriviaWidth();

                    var memberName = this.identifierFromToken(enumElement.propertyName, false);
                    this.movePast(enumElement.propertyName);

                    var init = enumElement.equalsValueClause !== null ? enumElement.equalsValueClause.accept(this) : null;

                    var declarator = new TypeScript.VariableDeclarator(memberName, new TypeScript.TypeReference(this.createRef(name.actualText, -1), 0), init);
                    declarator.constantValue = this.determineConstantValue(enumElement.equalsValueClause, declarators);

                    declarator.setVarFlags(declarator.getVarFlags() | 256 /* Property */);
                    this.setSpanExplicit(declarator, memberStart, this.position);
                    declarator.setPreComments(this.convertTokenLeadingComments(enumElement.firstToken(), enumElementFullStart));
                    declarator.setPostComments(this.convertNodeTrailingComments(enumElement, enumElement.lastToken(), enumElementFullStart));

                    declarators.push(declarator);

                    var declaration = new TypeScript.VariableDeclaration(new TypeScript.ASTList([declarator]));
                    this.setSpanExplicit(declaration, memberStart, this.position);

                    var statement = new TypeScript.VariableStatement(declaration);
                    statement.setFlags(16 /* EnumElement */);
                    this.setSpanExplicit(statement, memberStart, this.position);

                    array[i / 2] = statement;

                    declarator.setVarFlags(declarator.getVarFlags() | 1 /* Exported */);
                }
            }

            var members = new TypeScript.ASTList(array);

            var closeBracePosition = this.position;
            this.movePast(node.closeBraceToken);
            var closeBraceSpan = new TypeScript.ASTSpan();
            this.setSpan(closeBraceSpan, closeBracePosition, node.closeBraceToken);

            var result = new TypeScript.ModuleDeclaration(name, members, closeBraceSpan);
            this.setCommentsAndSpan(result, start, node);

            var flags = result.getModuleFlags() | 128 /* IsEnum */;

            if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 47 /* ExportKeyword */)) {
                flags = flags | 1 /* Exported */;
            }

            result.setModuleFlags(flags);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.determineConstantValue = function (equalsValue, declarators) {
            var value = equalsValue === null ? null : equalsValue.value;
            if (value === null) {
                if (declarators.length === 0) {
                    return 0;
                } else {
                    var lastConstantValue = TypeScript.ArrayUtilities.last(declarators).constantValue;
                    return lastConstantValue !== null ? lastConstantValue + 1 : null;
                }
            } else {
                return this.computeConstantValue(value, declarators);
            }
        };

        SyntaxTreeToAstVisitor.prototype.computeConstantValue = function (expression, declarators) {
            if (TypeScript.Syntax.isIntegerLiteral(expression)) {
                var token;
                switch (expression.kind()) {
                    case 163 /* PlusExpression */:
                    case 164 /* NegateExpression */:
                        token = (expression).operand;
                        break;
                    default:
                        token = expression;
                }

                var value = token.value();
                return value && expression.kind() === 164 /* NegateExpression */ ? -value : value;
            } else if (this.compilationSettings.propagateEnumConstants) {
                switch (expression.kind()) {
                    case 11 /* IdentifierName */:
                        var variableDeclarator = TypeScript.ArrayUtilities.firstOrDefault(declarators, function (d) {
                            return d.id.text() === (expression).valueText();
                        });
                        return variableDeclarator ? variableDeclarator.constantValue : null;

                    case 201 /* LeftShiftExpression */:
                        var binaryExpression = expression;
                        return this.computeConstantValue(binaryExpression.left, declarators) << this.computeConstantValue(binaryExpression.right, declarators);
                }

                return null;
            } else {
                return null;
            }
        };

        SyntaxTreeToAstVisitor.prototype.visitEnumElement = function (node) {
            throw TypeScript.Errors.invalidOperation();
        };

        SyntaxTreeToAstVisitor.prototype.visitImportDeclaration = function (node) {
            var start = this.position;

            this.moveTo(node, node.identifier);
            var name = this.identifierFromToken(node.identifier, false);
            this.movePast(node.identifier);
            this.movePast(node.equalsToken);
            var alias = node.moduleReference.accept(this);
            this.movePast(node.semicolonToken);

            var result = new TypeScript.ImportDeclaration(name, alias);
            this.setCommentsAndSpan(result, start, node);

            var flags = result.getVarFlags();
            if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 47 /* ExportKeyword */)) {
                flags = flags | 1 /* Exported */;
            }
            result.setVarFlags(flags);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitExportAssignment = function (node) {
            var start = this.position;

            this.moveTo(node, node.identifier);
            var name = this.identifierFromToken(node.identifier, false);
            this.movePast(node.identifier);
            this.movePast(node.semicolonToken);

            var result = new TypeScript.ExportAssignment(name);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitVariableStatement = function (node) {
            var start = this.position;

            var preComments = null;
            if (node.modifiers.childCount() > 0) {
                preComments = this.convertTokenLeadingComments(node.modifiers.firstToken(), start);
            }

            this.moveTo(node, node.variableDeclaration);

            var declaration = node.variableDeclaration.accept(this);
            this.movePast(node.semicolonToken);

            for (var i = 0, n = declaration.declarators.members.length; i < n; i++) {
                var varDecl = declaration.declarators.members[i];

                if (i === 0) {
                    varDecl.setPreComments(this.mergeComments(preComments, varDecl.preComments()));
                }

                var flags = varDecl.getVarFlags();
                if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 47 /* ExportKeyword */)) {
                    flags = flags | 1 /* Exported */;
                }

                if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 63 /* DeclareKeyword */)) {
                    flags = flags | 8 /* Ambient */;
                }

                varDecl.setVarFlags(flags);
            }

            var result = new TypeScript.VariableStatement(declaration);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitVariableDeclaration = function (node) {
            var start = this.position;

            var firstToken = node.firstToken();
            var preComments = this.convertTokenLeadingComments(firstToken, start);
            var postComments = this.convertNodeTrailingComments(node, node.lastToken(), start);

            this.moveTo(node, node.variableDeclarators);
            var variableDecls = this.visitSeparatedSyntaxList(node.variableDeclarators);

            for (var i = 0; i < variableDecls.members.length; i++) {
                if (i === 0) {
                    variableDecls.members[i].setPreComments(preComments);
                    variableDecls.members[i].setPostComments(postComments);
                }
            }

            var result = new TypeScript.VariableDeclaration(variableDecls);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitVariableDeclarator = function (node) {
            var start = this.position;
            var name = this.identifierFromToken(node.identifier, false);
            this.movePast(node.identifier);
            var typeExpr = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;
            var init = node.equalsValueClause ? node.equalsValueClause.accept(this) : null;

            var result = new TypeScript.VariableDeclarator(name, typeExpr, init);
            this.setSpan(result, start, node);

            if (init && init.nodeType() === 13 /* FunctionDeclaration */) {
                var funcDecl = init;
                funcDecl.hint = name.actualText;
            }

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitEqualsValueClause = function (node) {
            var afterEqualsComments = this.convertTokenTrailingComments(node.equalsToken, this.position + node.equalsToken.leadingTriviaWidth() + node.equalsToken.width());

            this.movePast(node.equalsToken);
            var result = node.value.accept(this);
            result.setPreComments(this.mergeComments(afterEqualsComments, result.preComments()));

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.getUnaryExpressionNodeType = function (kind) {
            switch (kind) {
                case 163 /* PlusExpression */:
                    return 27 /* PlusExpression */;
                case 164 /* NegateExpression */:
                    return 28 /* NegateExpression */;
                case 165 /* BitwiseNotExpression */:
                    return 73 /* BitwiseNotExpression */;
                case 166 /* LogicalNotExpression */:
                    return 74 /* LogicalNotExpression */;
                case 167 /* PreIncrementExpression */:
                    return 75 /* PreIncrementExpression */;
                case 168 /* PreDecrementExpression */:
                    return 76 /* PreDecrementExpression */;
                default:
                    throw TypeScript.Errors.invalidOperation();
            }
        };

        SyntaxTreeToAstVisitor.prototype.visitPrefixUnaryExpression = function (node) {
            var start = this.position;

            this.movePast(node.operatorToken);
            var operand = node.operand.accept(this);

            var result = new TypeScript.UnaryExpression(this.getUnaryExpressionNodeType(node.kind()), operand, null);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.isOnSingleLine = function (start, end) {
            return this.lineMap.getLineNumberFromPosition(start) === this.lineMap.getLineNumberFromPosition(end);
        };

        SyntaxTreeToAstVisitor.prototype.visitArrayLiteralExpression = function (node) {
            var start = this.position;
            var openStart = this.position + node.openBracketToken.leadingTriviaWidth();
            this.movePast(node.openBracketToken);

            var expressions = this.visitSeparatedSyntaxList(node.expressions);

            var closeStart = this.position + node.closeBracketToken.leadingTriviaWidth();
            this.movePast(node.closeBracketToken);

            var result = new TypeScript.UnaryExpression(22 /* ArrayLiteralExpression */, expressions, null);
            this.setSpan(result, start, node);

            if (this.isOnSingleLine(openStart, closeStart)) {
                result.setFlags(result.getFlags() | 2 /* SingleLine */);
            }

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitOmittedExpression = function (node) {
            var start = this.position;

            var result = new TypeScript.OmittedExpression();
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitParenthesizedExpression = function (node) {
            var start = this.position;

            this.movePast(node.openParenToken);
            var expr = node.expression.accept(this);
            this.movePast(node.closeParenToken);

            var result = new TypeScript.ParenthesizedExpression(expr);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.getArrowFunctionStatements = function (body) {
            if (body.kind() === 145 /* Block */) {
                return body.accept(this);
            } else {
                var expression = body.accept(this);
                var returnStatement = new TypeScript.ReturnStatement(expression);

                var preComments = expression.preComments();
                if (preComments) {
                    (body)._ast = undefined;
                    returnStatement.setPreComments(preComments);
                    expression.setPreComments(null);
                }

                var statements = new TypeScript.ASTList([returnStatement]);

                var block = new TypeScript.Block(statements, statements.members[0]);
                return block;
            }
        };

        SyntaxTreeToAstVisitor.prototype.visitSimpleArrowFunctionExpression = function (node) {
            var start = this.position;

            var identifier = this.identifierFromToken(node.identifier, false);
            this.movePast(node.identifier);
            this.movePast(node.equalsGreaterThanToken);

            var parameter = new TypeScript.Parameter(identifier, null, null, false);
            this.setSpanExplicit(parameter, identifier.minChar, identifier.limChar);

            var parameters = new TypeScript.ASTList([parameter]);

            var statements = this.getArrowFunctionStatements(node.body);

            var result = new TypeScript.FunctionDeclaration(null, statements, false, null, parameters, null, false);
            this.setSpan(result, start, node);

            result.setFunctionFlags(result.getFunctionFlags() | 8192 /* IsFunctionExpression */ | 2048 /* IsFatArrowFunction */);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitParenthesizedArrowFunctionExpression = function (node) {
            var start = this.position;

            var typeParameters = node.callSignature.typeParameterList === null ? null : node.callSignature.typeParameterList.accept(this);
            var parameters = node.callSignature.parameterList.accept(this);
            var returnType = node.callSignature.typeAnnotation ? node.callSignature.typeAnnotation.accept(this) : null;
            this.movePast(node.equalsGreaterThanToken);

            var block = this.getArrowFunctionStatements(node.body);

            var result = new TypeScript.FunctionDeclaration(null, block, false, typeParameters, parameters, returnType, this.hasDotDotDotParameter(node.callSignature.parameterList.parameters));
            this.setCommentsAndSpan(result, start, node);

            result.setFunctionFlags(result.getFunctionFlags() | 8192 /* IsFunctionExpression */ | 2048 /* IsFatArrowFunction */);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitType = function (type) {
            var result;
            if (type.isToken()) {
                var start = this.position;
                result = new TypeScript.TypeReference(type.accept(this), 0);
                this.setSpan(result, start, type);
            } else {
                result = type.accept(this);
            }

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitTypeQuery = function (node) {
            var start = this.position;
            this.movePast(node.typeOfKeyword);
            var name = node.name.accept(this);

            var typeQuery = new TypeScript.TypeQuery(name);
            this.setSpan(typeQuery, start, node);

            var result = new TypeScript.TypeReference(typeQuery, 0);
            this.copySpan(typeQuery, result);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitQualifiedName = function (node) {
            var start = this.position;
            var left = this.visitType(node.left).term;
            this.movePast(node.dotToken);
            var right = this.identifierFromToken(node.right, false);
            this.movePast(node.right);

            var term = new TypeScript.BinaryExpression(33 /* MemberAccessExpression */, left, right);
            this.setSpan(term, start, node);

            var result = new TypeScript.TypeReference(term, 0);
            this.copySpan(term, result);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitTypeArgumentList = function (node) {
            var array = new Array(node.typeArguments.nonSeparatorCount());

            this.movePast(node.lessThanToken);

            var start = this.position;

            for (var i = 0, n = node.typeArguments.childCount(); i < n; i++) {
                if (i % 2 === 1) {
                    this.movePast(node.typeArguments.childAt(i));
                } else {
                    array[i / 2] = this.visitType(node.typeArguments.childAt(i));
                }
            }
            this.movePast(node.greaterThanToken);

            var result = new TypeScript.ASTList(array);
            this.setSpan(result, start, node.typeArguments);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitConstructorType = function (node) {
            var start = this.position;

            this.movePast(node.newKeyword);
            var typeParameters = node.typeParameterList === null ? null : node.typeParameterList.accept(this);
            var parameters = node.parameterList.accept(this);
            this.movePast(node.equalsGreaterThanToken);
            var returnType = node.type ? this.visitType(node.type) : null;

            var funcDecl = new TypeScript.FunctionDeclaration(null, null, false, typeParameters, parameters, returnType, this.hasDotDotDotParameter(node.parameterList.parameters));
            this.setSpan(funcDecl, start, node);

            funcDecl.setFunctionFlags(funcDecl.getFunctionFlags() | 128 /* Signature */ | 1024 /* ConstructMember */);

            funcDecl.setFlags(funcDecl.getFlags() | 8 /* TypeReference */);
            funcDecl.hint = "_construct";
            funcDecl.classDecl = null;

            var result = new TypeScript.TypeReference(funcDecl, 0);
            this.copySpan(funcDecl, result);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitFunctionType = function (node) {
            var start = this.position;
            var typeParameters = node.typeParameterList === null ? null : node.typeParameterList.accept(this);
            var parameters = node.parameterList.accept(this);
            this.movePast(node.equalsGreaterThanToken);
            var returnType = node.type ? this.visitType(node.type) : null;

            var funcDecl = new TypeScript.FunctionDeclaration(null, null, false, typeParameters, parameters, returnType, this.hasDotDotDotParameter(node.parameterList.parameters));
            this.setSpan(funcDecl, start, node);

            funcDecl.setFlags(funcDecl.getFunctionFlags() | 128 /* Signature */);
            funcDecl.setFlags(funcDecl.getFlags() | 8 /* TypeReference */);

            var result = new TypeScript.TypeReference(funcDecl, 0);
            this.copySpan(funcDecl, result);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitObjectType = function (node) {
            var start = this.position;

            this.movePast(node.openBraceToken);
            var typeMembers = this.visitSeparatedSyntaxList(node.typeMembers);
            this.movePast(node.closeBraceToken);

            var interfaceDecl = new TypeScript.InterfaceDeclaration(new TypeScript.Identifier("__anonymous", "__anonymous"), null, typeMembers, null, null, true);
            this.setSpan(interfaceDecl, start, node);

            interfaceDecl.setFlags(interfaceDecl.getFlags() | 8 /* TypeReference */);

            var result = new TypeScript.TypeReference(interfaceDecl, 0);
            this.copySpan(interfaceDecl, result);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitArrayType = function (node) {
            var start = this.position;

            var result;
            var underlying = this.visitType(node.type);
            this.movePast(node.openBracketToken);
            this.movePast(node.closeBracketToken);

            if (underlying.nodeType() === 11 /* TypeRef */) {
                result = underlying;
                result.arrayCount++;
            } else {
                result = new TypeScript.TypeReference(underlying, 1);
            }

            result.setFlags(result.getFlags() | 8 /* TypeReference */);

            this.setSpan(result, start, node);
            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitGenericType = function (node) {
            var start = this.position;

            var underlying = this.visitType(node.name).term;
            var typeArguments = node.typeArgumentList.accept(this);

            var genericType = new TypeScript.GenericType(underlying, typeArguments);
            this.setSpan(genericType, start, node);

            genericType.setFlags(genericType.getFlags() | 8 /* TypeReference */);

            var result = new TypeScript.TypeReference(genericType, 0);
            this.copySpan(genericType, result);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitTypeAnnotation = function (node) {
            this.movePast(node.colonToken);
            return this.visitType(node.type);
        };

        SyntaxTreeToAstVisitor.prototype.visitBlock = function (node) {
            var start = this.position;

            this.movePast(node.openBraceToken);
            var statements = this.visitSyntaxList(node.statements);
            var closeBracePosition = this.position;

            var closeBraceLeadingComments = this.convertTokenLeadingComments(node.closeBraceToken, this.position);
            this.movePast(node.closeBraceToken);
            var closeBraceSpan = new TypeScript.ASTSpan();
            this.setSpan(closeBraceSpan, closeBracePosition, node.closeBraceToken);

            var result = new TypeScript.Block(statements, closeBraceSpan);
            this.setSpan(result, start, node);

            result.closeBraceLeadingComments = closeBraceLeadingComments;

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitParameter = function (node) {
            var start = this.position;

            this.moveTo(node, node.identifier);
            var identifier = this.identifierFromToken(node.identifier, !!node.questionToken);
            this.movePast(node.identifier);
            this.movePast(node.questionToken);
            var typeExpr = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;
            var init = node.equalsValueClause ? node.equalsValueClause.accept(this) : null;

            var result = new TypeScript.Parameter(identifier, typeExpr, init, !!node.questionToken);
            this.setCommentsAndSpan(result, start, node);

            if (node.publicOrPrivateKeyword) {
                if (node.publicOrPrivateKeyword.kind() === 57 /* PublicKeyword */) {
                    result.setVarFlags(result.getVarFlags() | 256 /* Property */ | 4 /* Public */);
                } else {
                    result.setVarFlags(result.getVarFlags() | 256 /* Property */ | 2 /* Private */);
                }
            }

            if (node.equalsValueClause || node.dotDotDotToken) {
                result.setFlags(result.getFlags() | 4 /* OptionalName */);
            }

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitMemberAccessExpression = function (node) {
            var start = this.position;

            var expression = node.expression.accept(this);
            this.movePast(node.dotToken);
            var name = this.identifierFromToken(node.name, false);
            this.movePast(node.name);

            var result = new TypeScript.BinaryExpression(33 /* MemberAccessExpression */, expression, name);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitPostfixUnaryExpression = function (node) {
            var start = this.position;

            var operand = node.operand.accept(this);
            this.movePast(node.operatorToken);

            var result = new TypeScript.UnaryExpression(node.kind() === 209 /* PostIncrementExpression */ ? 77 /* PostIncrementExpression */ : 78 /* PostDecrementExpression */, operand, null);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitElementAccessExpression = function (node) {
            var start = this.position;

            var expression = node.expression.accept(this);
            this.movePast(node.openBracketToken);
            var argumentExpression = node.argumentExpression.accept(this);
            this.movePast(node.closeBracketToken);

            var result = new TypeScript.BinaryExpression(36 /* ElementAccessExpression */, expression, argumentExpression);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.convertArgumentListArguments = function (node) {
            if (node === null) {
                return null;
            }

            var start = this.position;

            this.movePast(node.openParenToken);

            var result = this.visitSeparatedSyntaxList(node.arguments);

            if (node.arguments.fullWidth() === 0 && node.closeParenToken.fullWidth() === 0) {
                var openParenTokenEnd = start + node.openParenToken.leadingTriviaWidth() + node.openParenToken.width();
                this.setSpanExplicit(result, openParenTokenEnd, openParenTokenEnd + node.openParenToken.trailingTriviaWidth());
            }

            var closeParenPos = this.position;
            this.movePast(node.closeParenToken);
            var closeParenSpan = new TypeScript.ASTSpan();
            this.setSpan(closeParenSpan, closeParenPos, node.closeParenToken);

            return {
                argumentList: result,
                closeParenSpan: closeParenSpan
            };
        };

        SyntaxTreeToAstVisitor.prototype.visitInvocationExpression = function (node) {
            var start = this.position;

            var expression = node.expression.accept(this);
            var typeArguments = node.argumentList.typeArgumentList !== null ? node.argumentList.typeArgumentList.accept(this) : null;
            var argumentList = this.convertArgumentListArguments(node.argumentList);

            var result = new TypeScript.InvocationExpression(expression, typeArguments, argumentList ? argumentList.argumentList : null, argumentList ? argumentList.closeParenSpan : null);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitArgumentList = function (node) {
            throw TypeScript.Errors.invalidOperation();
        };

        SyntaxTreeToAstVisitor.prototype.getBinaryExpressionNodeType = function (node) {
            switch (node.kind()) {
                case 172 /* CommaExpression */:
                    return 26 /* CommaExpression */;
                case 173 /* AssignmentExpression */:
                    return 39 /* AssignmentExpression */;
                case 174 /* AddAssignmentExpression */:
                    return 40 /* AddAssignmentExpression */;
                case 175 /* SubtractAssignmentExpression */:
                    return 41 /* SubtractAssignmentExpression */;
                case 176 /* MultiplyAssignmentExpression */:
                    return 43 /* MultiplyAssignmentExpression */;
                case 177 /* DivideAssignmentExpression */:
                    return 42 /* DivideAssignmentExpression */;
                case 178 /* ModuloAssignmentExpression */:
                    return 44 /* ModuloAssignmentExpression */;
                case 179 /* AndAssignmentExpression */:
                    return 45 /* AndAssignmentExpression */;
                case 180 /* ExclusiveOrAssignmentExpression */:
                    return 46 /* ExclusiveOrAssignmentExpression */;
                case 181 /* OrAssignmentExpression */:
                    return 47 /* OrAssignmentExpression */;
                case 182 /* LeftShiftAssignmentExpression */:
                    return 48 /* LeftShiftAssignmentExpression */;
                case 183 /* SignedRightShiftAssignmentExpression */:
                    return 49 /* SignedRightShiftAssignmentExpression */;
                case 184 /* UnsignedRightShiftAssignmentExpression */:
                    return 50 /* UnsignedRightShiftAssignmentExpression */;
                case 186 /* LogicalOrExpression */:
                    return 52 /* LogicalOrExpression */;
                case 187 /* LogicalAndExpression */:
                    return 53 /* LogicalAndExpression */;
                case 188 /* BitwiseOrExpression */:
                    return 54 /* BitwiseOrExpression */;
                case 189 /* BitwiseExclusiveOrExpression */:
                    return 55 /* BitwiseExclusiveOrExpression */;
                case 190 /* BitwiseAndExpression */:
                    return 56 /* BitwiseAndExpression */;
                case 191 /* EqualsWithTypeConversionExpression */:
                    return 57 /* EqualsWithTypeConversionExpression */;
                case 192 /* NotEqualsWithTypeConversionExpression */:
                    return 58 /* NotEqualsWithTypeConversionExpression */;
                case 193 /* EqualsExpression */:
                    return 59 /* EqualsExpression */;
                case 194 /* NotEqualsExpression */:
                    return 60 /* NotEqualsExpression */;
                case 195 /* LessThanExpression */:
                    return 61 /* LessThanExpression */;
                case 196 /* GreaterThanExpression */:
                    return 63 /* GreaterThanExpression */;
                case 197 /* LessThanOrEqualExpression */:
                    return 62 /* LessThanOrEqualExpression */;
                case 198 /* GreaterThanOrEqualExpression */:
                    return 64 /* GreaterThanOrEqualExpression */;
                case 199 /* InstanceOfExpression */:
                    return 34 /* InstanceOfExpression */;
                case 200 /* InExpression */:
                    return 32 /* InExpression */;
                case 201 /* LeftShiftExpression */:
                    return 70 /* LeftShiftExpression */;
                case 202 /* SignedRightShiftExpression */:
                    return 71 /* SignedRightShiftExpression */;
                case 203 /* UnsignedRightShiftExpression */:
                    return 72 /* UnsignedRightShiftExpression */;
                case 204 /* MultiplyExpression */:
                    return 67 /* MultiplyExpression */;
                case 205 /* DivideExpression */:
                    return 68 /* DivideExpression */;
                case 206 /* ModuloExpression */:
                    return 69 /* ModuloExpression */;
                case 207 /* AddExpression */:
                    return 65 /* AddExpression */;
                case 208 /* SubtractExpression */:
                    return 66 /* SubtractExpression */;
            }

            throw TypeScript.Errors.invalidOperation();
        };

        SyntaxTreeToAstVisitor.prototype.visitBinaryExpression = function (node) {
            var start = this.position;

            var nodeType = this.getBinaryExpressionNodeType(node);
            var left = node.left.accept(this);
            this.movePast(node.operatorToken);
            var right = node.right.accept(this);

            var result = new TypeScript.BinaryExpression(nodeType, left, right);
            this.setSpan(result, start, node);

            if (right.nodeType() === 13 /* FunctionDeclaration */) {
                var id = left.nodeType() === 33 /* MemberAccessExpression */ ? (left).operand2 : left;
                var idHint = id.nodeType() === 21 /* Name */ ? id.actualText : null;

                var funcDecl = right;
                funcDecl.hint = idHint;
            }

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitConditionalExpression = function (node) {
            var start = this.position;

            var condition = node.condition.accept(this);
            this.movePast(node.questionToken);
            var whenTrue = node.whenTrue.accept(this);
            this.movePast(node.colonToken);
            var whenFalse = node.whenFalse.accept(this);

            var result = new TypeScript.ConditionalExpression(condition, whenTrue, whenFalse);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitConstructSignature = function (node) {
            var start = this.position;

            this.movePast(node.newKeyword);
            var typeParameters = node.callSignature.typeParameterList === null ? null : node.callSignature.typeParameterList.accept(this);
            var parameters = node.callSignature.parameterList.accept(this);
            var returnType = node.callSignature.typeAnnotation ? node.callSignature.typeAnnotation.accept(this) : null;

            var result = new TypeScript.FunctionDeclaration(null, null, false, typeParameters, parameters, returnType, this.hasDotDotDotParameter(node.callSignature.parameterList.parameters));
            this.setCommentsAndSpan(result, start, node);

            result.hint = "_construct";
            result.setFunctionFlags(result.getFunctionFlags() | 1024 /* ConstructMember */ | 256 /* Method */ | 128 /* Signature */);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitMethodSignature = function (node) {
            var start = this.position;

            var name = this.identifierFromToken(node.propertyName, !!node.questionToken);
            this.movePast(node.propertyName);
            this.movePast(node.questionToken);

            var typeParameters = node.callSignature.typeParameterList ? node.callSignature.typeParameterList.accept(this) : null;
            var parameters = node.callSignature.parameterList.accept(this);
            var returnType = node.callSignature.typeAnnotation ? node.callSignature.typeAnnotation.accept(this) : null;

            var result = new TypeScript.FunctionDeclaration(name, null, false, typeParameters, parameters, returnType, this.hasDotDotDotParameter(node.callSignature.parameterList.parameters));
            this.setCommentsAndSpan(result, start, node);

            result.setFunctionFlags(result.getFunctionFlags() | 256 /* Method */ | 128 /* Signature */);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitIndexSignature = function (node) {
            var start = this.position;

            this.movePast(node.openBracketToken);

            var parameter = node.parameter.accept(this);

            this.movePast(node.closeBracketToken);
            var returnType = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;

            var name = new TypeScript.Identifier("__item", "__item");
            this.setSpanExplicit(name, start, start);

            var parameters = new TypeScript.ASTList([parameter]);

            var result = new TypeScript.FunctionDeclaration(name, null, false, null, parameters, returnType, false);
            this.setCommentsAndSpan(result, start, node);

            result.setFunctionFlags(result.getFunctionFlags() | 4096 /* IndexerMember */ | 256 /* Method */ | 128 /* Signature */);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitPropertySignature = function (node) {
            var start = this.position;

            var name = this.identifierFromToken(node.propertyName, !!node.questionToken);
            this.movePast(node.propertyName);
            this.movePast(node.questionToken);
            var typeExpr = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;

            var result = new TypeScript.VariableDeclarator(name, typeExpr, null);
            this.setCommentsAndSpan(result, start, node);

            result.setVarFlags(result.getVarFlags() | 256 /* Property */);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitParameterList = function (node) {
            var start = this.position;

            var openParenToken = node.openParenToken;
            this.previousTokenTrailingComments = this.convertTokenTrailingComments(openParenToken, start + openParenToken.leadingTriviaWidth() + openParenToken.width());

            this.movePast(node.openParenToken);
            var result = this.visitSeparatedSyntaxList(node.parameters);
            this.movePast(node.closeParenToken);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitCallSignature = function (node) {
            var start = this.position;

            var typeParameters = node.typeParameterList === null ? null : node.typeParameterList.accept(this);
            var parameters = node.parameterList.accept(this);
            var returnType = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;

            var result = new TypeScript.FunctionDeclaration(null, null, false, typeParameters, parameters, returnType, this.hasDotDotDotParameter(node.parameterList.parameters));
            this.setCommentsAndSpan(result, start, node);

            result.hint = "_call";
            result.setFunctionFlags(result.getFunctionFlags() | 512 /* CallMember */ | 256 /* Method */ | 128 /* Signature */);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitTypeParameterList = function (node) {
            this.movePast(node.lessThanToken);
            var result = this.visitSeparatedSyntaxList(node.typeParameters);
            this.movePast(node.greaterThanToken);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitTypeParameter = function (node) {
            var start = this.position;

            var identifier = this.identifierFromToken(node.identifier, false);
            this.movePast(node.identifier);
            var constraint = node.constraint ? node.constraint.accept(this) : null;

            var result = new TypeScript.TypeParameter(identifier, constraint);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitConstraint = function (node) {
            this.movePast(node.extendsKeyword);
            return this.visitType(node.type);
        };

        SyntaxTreeToAstVisitor.prototype.visitIfStatement = function (node) {
            var start = this.position;

            this.moveTo(node, node.condition);
            var condition = node.condition.accept(this);
            this.movePast(node.closeParenToken);
            var thenBod = node.statement.accept(this);
            var elseBod = node.elseClause ? node.elseClause.accept(this) : null;

            var result = new TypeScript.IfStatement(condition, thenBod, elseBod);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitElseClause = function (node) {
            this.movePast(node.elseKeyword);
            return node.statement.accept(this);
        };

        SyntaxTreeToAstVisitor.prototype.visitExpressionStatement = function (node) {
            var start = this.position;

            var expression = node.expression.accept(this);
            this.movePast(node.semicolonToken);

            var result = new TypeScript.ExpressionStatement(expression);
            this.setCommentsAndSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitConstructorDeclaration = function (node) {
            var start = this.position;

            this.moveTo(node, node.parameterList);
            var parameters = node.parameterList.accept(this);

            var block = node.block ? node.block.accept(this) : null;

            this.movePast(node.semicolonToken);

            var result = new TypeScript.FunctionDeclaration(null, block, true, null, parameters, null, this.hasDotDotDotParameter(node.parameterList.parameters));
            this.setCommentsAndSpan(result, start, node);

            if (node.semicolonToken) {
                result.setFunctionFlags(result.getFunctionFlags() | 128 /* Signature */);
            }

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitMemberFunctionDeclaration = function (node) {
            var start = this.position;

            this.moveTo(node, node.propertyName);
            var name = this.identifierFromToken(node.propertyName, false);

            this.movePast(node.propertyName);

            var typeParameters = node.callSignature.typeParameterList === null ? null : node.callSignature.typeParameterList.accept(this);
            var parameters = node.callSignature.parameterList.accept(this);
            var returnType = node.callSignature.typeAnnotation ? node.callSignature.typeAnnotation.accept(this) : null;

            var block = node.block ? node.block.accept(this) : null;
            this.movePast(node.semicolonToken);

            var result = new TypeScript.FunctionDeclaration(name, block, false, typeParameters, parameters, returnType, this.hasDotDotDotParameter(node.callSignature.parameterList.parameters));
            this.setCommentsAndSpan(result, start, node);

            var flags = result.getFunctionFlags();
            if (node.semicolonToken) {
                flags = flags | 128 /* Signature */;
            }

            if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 55 /* PrivateKeyword */)) {
                flags = flags | 2 /* Private */;
            } else {
                flags = flags | 4 /* Public */;
            }

            if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 58 /* StaticKeyword */)) {
                flags = flags | 16 /* Static */;
            }

            flags = flags | 256 /* Method */;
            result.setFunctionFlags(flags);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitMemberAccessorDeclaration = function (node, typeAnnotation) {
            var start = this.position;

            this.moveTo(node, node.propertyName);
            var name = this.identifierFromToken(node.propertyName, false);
            this.movePast(node.propertyName);
            var parameters = node.parameterList.accept(this);
            var returnType = typeAnnotation ? typeAnnotation.accept(this) : null;

            var block = node.block ? node.block.accept(this) : null;
            var result = new TypeScript.FunctionDeclaration(name, block, false, null, parameters, returnType, this.hasDotDotDotParameter(node.parameterList.parameters));
            this.setCommentsAndSpan(result, start, node);

            if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 55 /* PrivateKeyword */)) {
                result.setFunctionFlags(result.getFunctionFlags() | 2 /* Private */);
            } else {
                result.setFunctionFlags(result.getFunctionFlags() | 4 /* Public */);
            }

            if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 58 /* StaticKeyword */)) {
                result.setFunctionFlags(result.getFunctionFlags() | 16 /* Static */);
            }

            result.setFunctionFlags(result.getFunctionFlags() | 256 /* Method */);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitGetMemberAccessorDeclaration = function (node) {
            var result = this.visitMemberAccessorDeclaration(node, node.typeAnnotation);

            result.setFunctionFlags(result.getFunctionFlags() | 32 /* GetAccessor */);
            result.hint = "get" + result.name.actualText;

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitSetMemberAccessorDeclaration = function (node) {
            var result = this.visitMemberAccessorDeclaration(node, null);

            result.setFunctionFlags(result.getFunctionFlags() | 64 /* SetAccessor */);
            result.hint = "set" + result.name.actualText;

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitMemberVariableDeclaration = function (node) {
            var start = this.position;

            this.moveTo(node, node.variableDeclarator);
            this.moveTo(node.variableDeclarator, node.variableDeclarator.identifier);

            var name = this.identifierFromToken(node.variableDeclarator.identifier, false);
            this.movePast(node.variableDeclarator.identifier);
            var typeExpr = node.variableDeclarator.typeAnnotation ? node.variableDeclarator.typeAnnotation.accept(this) : null;
            var init = node.variableDeclarator.equalsValueClause ? node.variableDeclarator.equalsValueClause.accept(this) : null;
            this.movePast(node.semicolonToken);

            var result = new TypeScript.VariableDeclarator(name, typeExpr, init);
            this.setCommentsAndSpan(result, start, node);

            if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 58 /* StaticKeyword */)) {
                result.setVarFlags(result.getVarFlags() | 16 /* Static */);
            }

            if (TypeScript.SyntaxUtilities.containsToken(node.modifiers, 55 /* PrivateKeyword */)) {
                result.setVarFlags(result.getVarFlags() | 2 /* Private */);
            } else {
                result.setVarFlags(result.getVarFlags() | 4 /* Public */);
            }

            result.setVarFlags(result.getVarFlags() | 2048 /* ClassProperty */);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitThrowStatement = function (node) {
            var start = this.position;

            this.movePast(node.throwKeyword);
            var expression = node.expression.accept(this);
            this.movePast(node.semicolonToken);

            var result = new TypeScript.ThrowStatement(expression);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitReturnStatement = function (node) {
            var start = this.position;

            this.movePast(node.returnKeyword);
            var expression = node.expression ? node.expression.accept(this) : null;
            this.movePast(node.semicolonToken);

            var result = new TypeScript.ReturnStatement(expression);
            this.setCommentsAndSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitObjectCreationExpression = function (node) {
            var start = this.position;

            this.movePast(node.newKeyword);
            var expression = node.expression.accept(this);
            var typeArgumentList = node.argumentList === null || node.argumentList.typeArgumentList === null ? null : node.argumentList.typeArgumentList.accept(this);
            var argumentList = this.convertArgumentListArguments(node.argumentList);

            var result = new TypeScript.ObjectCreationExpression(expression, typeArgumentList, argumentList ? argumentList.argumentList : null, argumentList ? argumentList.closeParenSpan : null);
            this.setSpan(result, start, node);

            if (expression.nodeType() === 11 /* TypeRef */) {
                var typeRef = expression;

                if (typeRef.arrayCount === 0) {
                    var term = typeRef.term;
                    if (term.nodeType() === 33 /* MemberAccessExpression */ || term.nodeType() === 21 /* Name */) {
                        expression = term;
                    }
                }
            }

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitSwitchStatement = function (node) {
            var start = this.position;

            this.movePast(node.switchKeyword);
            this.movePast(node.openParenToken);
            var expression = node.expression.accept(this);
            this.movePast(node.closeParenToken);
            var closeParenPosition = this.position;
            this.movePast(node.openBraceToken);

            var array = new Array(node.switchClauses.childCount());
            var defaultCase = null;

            for (var i = 0, n = node.switchClauses.childCount(); i < n; i++) {
                var switchClause = node.switchClauses.childAt(i);
                var translated = switchClause.accept(this);

                if (switchClause.kind() === 232 /* DefaultSwitchClause */) {
                    defaultCase = translated;
                }

                array[i] = translated;
            }

            var span = new TypeScript.ASTSpan();
            span.minChar = start;
            span.limChar = closeParenPosition;

            this.movePast(node.closeBraceToken);

            var result = new TypeScript.SwitchStatement(expression, new TypeScript.ASTList(array), defaultCase, span);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitCaseSwitchClause = function (node) {
            var start = this.position;

            this.movePast(node.caseKeyword);
            var expression = node.expression.accept(this);
            this.movePast(node.colonToken);
            var statements = this.visitSyntaxList(node.statements);

            var result = new TypeScript.CaseClause(expression, statements);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitDefaultSwitchClause = function (node) {
            var start = this.position;

            this.movePast(node.defaultKeyword);
            this.movePast(node.colonToken);
            var statements = this.visitSyntaxList(node.statements);

            var result = new TypeScript.CaseClause(null, statements);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitBreakStatement = function (node) {
            var start = this.position;

            this.movePast(node.breakKeyword);
            this.movePast(node.identifier);
            this.movePast(node.semicolonToken);
            var identifier = node.identifier ? node.identifier.valueText() : null;

            var result = new TypeScript.Jump(83 /* BreakStatement */, identifier);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitContinueStatement = function (node) {
            var start = this.position;

            this.movePast(node.continueKeyword);
            this.movePast(node.identifier);
            this.movePast(node.semicolonToken);

            var result = new TypeScript.Jump(84 /* ContinueStatement */, node.identifier ? node.identifier.valueText() : null);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitForStatement = function (node) {
            var start = this.position;

            this.movePast(node.forKeyword);
            this.movePast(node.openParenToken);
            var init = node.variableDeclaration ? node.variableDeclaration.accept(this) : node.initializer ? node.initializer.accept(this) : null;
            this.movePast(node.firstSemicolonToken);
            var cond = node.condition ? node.condition.accept(this) : null;
            this.movePast(node.secondSemicolonToken);
            var incr = node.incrementor ? node.incrementor.accept(this) : null;
            this.movePast(node.closeParenToken);
            var body = node.statement.accept(this);

            var result = new TypeScript.ForStatement(init, cond, incr, body);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitForInStatement = function (node) {
            var start = this.position;

            this.movePast(node.forKeyword);
            this.movePast(node.openParenToken);
            var init = node.variableDeclaration ? node.variableDeclaration.accept(this) : node.left.accept(this);
            if (node.variableDeclaration) {
                var variableDeclaration = init;
                for (var i = 0, n = variableDeclaration.declarators.members.length; i < n; i++) {
                    var boundDecl = variableDeclaration.declarators.members[i];
                    boundDecl.setVarFlags(boundDecl.getVarFlags() | 16384 /* ForInVariable */);
                }
            }

            this.movePast(node.inKeyword);
            var expression = node.expression.accept(this);
            this.movePast(node.closeParenToken);
            var body = node.statement.accept(this);

            var result = new TypeScript.ForInStatement(init, expression, body);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitWhileStatement = function (node) {
            var start = this.position;

            this.moveTo(node, node.condition);
            var condition = node.condition.accept(this);
            this.movePast(node.closeParenToken);
            var statement = node.statement.accept(this);

            var result = new TypeScript.WhileStatement(condition, statement);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitWithStatement = function (node) {
            var start = this.position;

            this.moveTo(node, node.condition);
            var condition = node.condition.accept(this);
            this.movePast(node.closeParenToken);
            var statement = node.statement.accept(this);

            var result = new TypeScript.WithStatement(condition, statement);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitCastExpression = function (node) {
            var start = this.position;

            this.movePast(node.lessThanToken);
            var castTerm = this.visitType(node.type);
            this.movePast(node.greaterThanToken);
            var expression = node.expression.accept(this);

            var result = new TypeScript.UnaryExpression(79 /* CastExpression */, expression, castTerm);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitObjectLiteralExpression = function (node) {
            var start = this.position;

            var openStart = this.position + node.openBraceToken.leadingTriviaWidth();
            this.movePast(node.openBraceToken);

            var propertyAssignments = this.visitSeparatedSyntaxList(node.propertyAssignments);

            var closeStart = this.position + node.closeBraceToken.leadingTriviaWidth();
            this.movePast(node.closeBraceToken);

            var result = new TypeScript.UnaryExpression(23 /* ObjectLiteralExpression */, propertyAssignments, null);
            this.setCommentsAndSpan(result, start, node);

            if (this.isOnSingleLine(openStart, closeStart)) {
                result.setFlags(result.getFlags() | 2 /* SingleLine */);
            }

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitSimplePropertyAssignment = function (node) {
            var start = this.position;

            var left = node.propertyName.accept(this);

            var afterColonComments = this.convertTokenTrailingComments(node.colonToken, this.position + node.colonToken.leadingTriviaWidth() + node.colonToken.width());

            this.movePast(node.colonToken);
            var right = node.expression.accept(this);
            right.setPreComments(this.mergeComments(afterColonComments, right.preComments()));

            var result = new TypeScript.BinaryExpression(81 /* Member */, left, right);
            this.setCommentsAndSpan(result, start, node);

            if (right.nodeType() === 13 /* FunctionDeclaration */) {
                var funcDecl = right;
                funcDecl.hint = left.text();
            }

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitFunctionPropertyAssignment = function (node) {
            var start = this.position;

            var left = node.propertyName.accept(this);
            var functionDeclaration = node.callSignature.accept(this);
            var block = node.block.accept(this);

            functionDeclaration.hint = left.text();
            functionDeclaration.block = block;
            functionDeclaration.setFunctionFlags(16384 /* IsFunctionProperty */);

            var result = new TypeScript.BinaryExpression(81 /* Member */, left, functionDeclaration);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitGetAccessorPropertyAssignment = function (node) {
            var start = this.position;

            this.moveTo(node, node.propertyName);
            var name = this.identifierFromToken(node.propertyName, false);
            var functionName = this.identifierFromToken(node.propertyName, false);
            this.movePast(node.propertyName);
            this.movePast(node.openParenToken);
            this.movePast(node.closeParenToken);
            var returnType = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;

            var block = node.block ? node.block.accept(this) : null;

            var funcDecl = new TypeScript.FunctionDeclaration(functionName, block, false, null, new TypeScript.ASTList([]), returnType, false);
            this.setSpan(funcDecl, start, node);

            funcDecl.setFunctionFlags(funcDecl.getFunctionFlags() | 32 /* GetAccessor */ | 8192 /* IsFunctionExpression */);
            funcDecl.hint = "get" + node.propertyName.valueText();

            var result = new TypeScript.BinaryExpression(81 /* Member */, name, funcDecl);
            this.copySpan(funcDecl, result);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitSetAccessorPropertyAssignment = function (node) {
            var start = this.position;

            this.moveTo(node, node.propertyName);
            var name = this.identifierFromToken(node.propertyName, false);
            var functionName = this.identifierFromToken(node.propertyName, false);
            this.movePast(node.propertyName);
            this.movePast(node.openParenToken);
            var parameter = node.parameter.accept(this);
            this.movePast(node.closeParenToken);

            var parameters = new TypeScript.ASTList([parameter]);

            var block = node.block ? node.block.accept(this) : null;

            var funcDecl = new TypeScript.FunctionDeclaration(functionName, block, false, null, parameters, null, false);
            this.setSpan(funcDecl, start, node);

            funcDecl.setFunctionFlags(funcDecl.getFunctionFlags() | 64 /* SetAccessor */ | 8192 /* IsFunctionExpression */);
            funcDecl.hint = "set" + node.propertyName.valueText();

            var result = new TypeScript.BinaryExpression(81 /* Member */, name, funcDecl);
            this.copySpan(funcDecl, result);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitFunctionExpression = function (node) {
            var start = this.position;

            this.movePast(node.functionKeyword);
            var name = node.identifier === null ? null : this.identifierFromToken(node.identifier, false);
            this.movePast(node.identifier);
            var typeParameters = node.callSignature.typeParameterList === null ? null : node.callSignature.typeParameterList.accept(this);
            var parameters = node.callSignature.parameterList.accept(this);
            var returnType = node.callSignature.typeAnnotation ? node.callSignature.typeAnnotation.accept(this) : null;

            var block = node.block ? node.block.accept(this) : null;

            var result = new TypeScript.FunctionDeclaration(name, block, false, typeParameters, parameters, returnType, this.hasDotDotDotParameter(node.callSignature.parameterList.parameters));
            this.setCommentsAndSpan(result, start, node);

            result.setFunctionFlags(result.getFunctionFlags() | 8192 /* IsFunctionExpression */);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitEmptyStatement = function (node) {
            var start = this.position;

            this.movePast(node.semicolonToken);

            var result = new TypeScript.EmptyStatement();
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitTryStatement = function (node) {
            var start = this.position;

            this.movePast(node.tryKeyword);
            var tryBody = node.block.accept(this);

            var catchClause = null;
            if (node.catchClause !== null) {
                catchClause = node.catchClause.accept(this);
            }

            var finallyBody = null;
            if (node.finallyClause !== null) {
                finallyBody = node.finallyClause.accept(this);
            }

            var result = new TypeScript.TryStatement(tryBody, catchClause, finallyBody);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitCatchClause = function (node) {
            var start = this.position;

            this.movePast(node.catchKeyword);
            this.movePast(node.openParenToken);
            var identifier = this.identifierFromToken(node.identifier, false);
            this.movePast(node.identifier);
            var typeExpr = node.typeAnnotation ? node.typeAnnotation.accept(this) : null;
            this.movePast(node.closeParenToken);
            var block = node.block.accept(this);

            var varDecl = new TypeScript.VariableDeclarator(identifier, typeExpr, null);
            this.setSpanExplicit(varDecl, identifier.minChar, identifier.limChar);

            var result = new TypeScript.CatchClause(varDecl, block);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitFinallyClause = function (node) {
            this.movePast(node.finallyKeyword);
            return node.block.accept(this);
        };

        SyntaxTreeToAstVisitor.prototype.visitLabeledStatement = function (node) {
            var start = this.position;

            var identifier = this.identifierFromToken(node.identifier, false);
            this.movePast(node.identifier);
            this.movePast(node.colonToken);
            var statement = node.statement.accept(this);

            var result = new TypeScript.LabeledStatement(identifier, statement);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitDoStatement = function (node) {
            var start = this.position;

            this.movePast(node.doKeyword);
            var statement = node.statement.accept(this);
            var whileSpan = new TypeScript.ASTSpan();
            this.setSpan(whileSpan, this.position, node.whileKeyword);

            this.movePast(node.whileKeyword);
            this.movePast(node.openParenToken);
            var condition = node.condition.accept(this);
            this.movePast(node.closeParenToken);
            this.movePast(node.semicolonToken);

            var result = new TypeScript.DoStatement(statement, condition, whileSpan);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitTypeOfExpression = function (node) {
            var start = this.position;

            this.movePast(node.typeOfKeyword);
            var expression = node.expression.accept(this);

            var result = new TypeScript.UnaryExpression(35 /* TypeOfExpression */, expression, null);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitDeleteExpression = function (node) {
            var start = this.position;

            this.movePast(node.deleteKeyword);
            var expression = node.expression.accept(this);

            var result = new TypeScript.UnaryExpression(29 /* DeleteExpression */, expression, null);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitVoidExpression = function (node) {
            var start = this.position;

            this.movePast(node.voidKeyword);
            var expression = node.expression.accept(this);

            var result = new TypeScript.UnaryExpression(25 /* VoidExpression */, expression, null);
            this.setSpan(result, start, node);

            return result;
        };

        SyntaxTreeToAstVisitor.prototype.visitDebuggerStatement = function (node) {
            var start = this.position;

            this.movePast(node.debuggerKeyword);
            this.movePast(node.semicolonToken);

            var result = new TypeScript.DebuggerStatement();
            this.setSpan(result, start, node);

            return result;
        };
        SyntaxTreeToAstVisitor.protoString = "__proto__";
        SyntaxTreeToAstVisitor.protoSubstitutionString = "#__proto__";
        return SyntaxTreeToAstVisitor;
    })();
    TypeScript.SyntaxTreeToAstVisitor = SyntaxTreeToAstVisitor;

    var SyntaxTreeToIncrementalAstVisitor = (function (_super) {
        __extends(SyntaxTreeToIncrementalAstVisitor, _super);
        function SyntaxTreeToIncrementalAstVisitor() {
            _super.apply(this, arguments);
        }
        SyntaxTreeToIncrementalAstVisitor.prototype.applyDelta = function (ast, delta) {
            if (delta === 0) {
                return;
            }

            var applyDelta = function (ast) {
                if (ast.minChar !== -1) {
                    ast.minChar += delta;
                }
                if (ast.limChar !== -1) {
                    ast.limChar += delta;
                }
            };

            var applyDeltaToComments = function (comments) {
                if (comments && comments.length > 0) {
                    for (var i = 0; i < comments.length; i++) {
                        var comment = comments[i];
                        applyDelta(comment);
                    }
                }
            };

            var pre = function (cur, parent, walker) {
                applyDelta(cur);
                applyDeltaToComments(cur.preComments());
                applyDeltaToComments(cur.postComments());

                return cur;
            };

            TypeScript.getAstWalkerFactory().walk(ast, pre);
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.setSpanExplicit = function (span, start, end) {
            if (span.minChar !== -1) {
                var delta = start - span.minChar;
                this.applyDelta(span, delta);

                span.limChar = end;
            } else {
                _super.prototype.setSpanExplicit.call(this, span, start, end);
            }
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.getAndMovePastAST = function (element) {
            if (this.previousTokenTrailingComments !== null) {
                return null;
            }

            var result = (element)._ast;
            if (!result) {
                return null;
            }

            var start = this.position;
            this.movePast(element);
            this.setSpan(result, start, element);
            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.setAST = function (element, ast) {
            (element)._ast = ast;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitSyntaxList = function (list) {
            var result = this.getAndMovePastAST(list);
            if (!result) {
                result = _super.prototype.visitSyntaxList.call(this, list);

                if (list.childCount() > 0) {
                    this.setAST(list, result);
                }
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitSeparatedSyntaxList = function (list) {
            var result = this.getAndMovePastAST(list);
            if (!result) {
                result = _super.prototype.visitSeparatedSyntaxList.call(this, list);

                if (list.childCount() > 0) {
                    this.setAST(list, result);
                }
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitToken = function (token) {
            var result = this.getAndMovePastAST(token);

            if (!result) {
                result = _super.prototype.visitToken.call(this, token);
                this.setAST(token, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitClassDeclaration = function (node) {
            var result = this.getAndMovePastAST(node);
            if (result) {
                this.completeClassDeclaration(node, result);
            } else {
                result = _super.prototype.visitClassDeclaration.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitInterfaceDeclaration = function (node) {
            var result = this.getAndMovePastAST(node);
            if (result) {
                this.completeInterfaceDeclaration(node, result);
            } else {
                result = _super.prototype.visitInterfaceDeclaration.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitHeritageClause = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitHeritageClause.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitModuleDeclaration = function (node) {
            var result = this.getAndMovePastAST(node);
            if (result) {
                this.completeModuleDeclaration(node, result);
            } else {
                result = _super.prototype.visitModuleDeclaration.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitFunctionDeclaration = function (node) {
            var result = this.getAndMovePastAST(node);
            if (result) {
                this.completeFunctionDeclaration(node, result);
            } else {
                result = _super.prototype.visitFunctionDeclaration.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitImportDeclaration = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitImportDeclaration.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitExportAssignment = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitExportAssignment.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitPrefixUnaryExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitPrefixUnaryExpression.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitArrayLiteralExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitArrayLiteralExpression.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitOmittedExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitOmittedExpression.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitParenthesizedExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitParenthesizedExpression.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitSimpleArrowFunctionExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitSimpleArrowFunctionExpression.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitParenthesizedArrowFunctionExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitParenthesizedArrowFunctionExpression.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitQualifiedName = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                var result = _super.prototype.visitQualifiedName.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitConstructorType = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitConstructorType.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitFunctionType = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitFunctionType.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitObjectType = function (node) {
            var start = this.position;
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitObjectType.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitArrayType = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitArrayType.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitGenericType = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitGenericType.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitBlock = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitBlock.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitParameter = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitParameter.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitMemberAccessExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitMemberAccessExpression.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitPostfixUnaryExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitPostfixUnaryExpression.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitElementAccessExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitElementAccessExpression.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitInvocationExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitInvocationExpression.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitBinaryExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitBinaryExpression.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitConditionalExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitConditionalExpression.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitConstructSignature = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitConstructSignature.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitMethodSignature = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitMethodSignature.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitIndexSignature = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitIndexSignature.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitPropertySignature = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitPropertySignature.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitCallSignature = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitCallSignature.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitTypeParameter = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitTypeParameter.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitIfStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitIfStatement.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitExpressionStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitExpressionStatement.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitConstructorDeclaration = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitConstructorDeclaration.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitMemberFunctionDeclaration = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitMemberFunctionDeclaration.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitMemberAccessorDeclaration = function (node, typeAnnotation) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitMemberAccessorDeclaration.call(this, node, typeAnnotation);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitMemberVariableDeclaration = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitMemberVariableDeclaration.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitThrowStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitThrowStatement.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitReturnStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitReturnStatement.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitObjectCreationExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitObjectCreationExpression.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitSwitchStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitSwitchStatement.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitCaseSwitchClause = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitCaseSwitchClause.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitDefaultSwitchClause = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitDefaultSwitchClause.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitBreakStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitBreakStatement.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitContinueStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitContinueStatement.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitForStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitForStatement.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitForInStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitForInStatement.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitWhileStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitWhileStatement.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitWithStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitWithStatement.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitCastExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitCastExpression.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitObjectLiteralExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitObjectLiteralExpression.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitSimplePropertyAssignment = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitSimplePropertyAssignment.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitFunctionPropertyAssignment = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitFunctionPropertyAssignment.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitGetAccessorPropertyAssignment = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitGetAccessorPropertyAssignment.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitSetAccessorPropertyAssignment = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitSetAccessorPropertyAssignment.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitFunctionExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitFunctionExpression.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitEmptyStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitEmptyStatement.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitTryStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitTryStatement.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitCatchClause = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitCatchClause.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitLabeledStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitLabeledStatement.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitDoStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitDoStatement.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitTypeOfExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitTypeOfExpression.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitDeleteExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitDeleteExpression.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitVoidExpression = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitVoidExpression.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };

        SyntaxTreeToIncrementalAstVisitor.prototype.visitDebuggerStatement = function (node) {
            var result = this.getAndMovePastAST(node);
            if (!result) {
                result = _super.prototype.visitDebuggerStatement.call(this, node);
                this.setAST(node, result);
            }

            return result;
        };
        return SyntaxTreeToIncrementalAstVisitor;
    })(SyntaxTreeToAstVisitor);
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    TypeScript.fileResolutionTime = 0;
    TypeScript.sourceCharactersCompiled = 0;
    TypeScript.syntaxTreeParseTime = 0;
    TypeScript.syntaxDiagnosticsTime = 0;
    TypeScript.astTranslationTime = 0;
    TypeScript.typeCheckTime = 0;

    TypeScript.emitTime = 0;
    TypeScript.emitWriteFileTime = 0;
    TypeScript.emitDirectoryExistsTime = 0;
    TypeScript.emitFileExistsTime = 0;
    TypeScript.emitResolvePathTime = 0;

    TypeScript.declarationEmitTime = 0;
    TypeScript.declarationEmitIsExternallyVisibleTime = 0;
    TypeScript.declarationEmitTypeSignatureTime = 0;
    TypeScript.declarationEmitGetBoundDeclTypeTime = 0;
    TypeScript.declarationEmitIsOverloadedCallSignatureTime = 0;
    TypeScript.declarationEmitFunctionDeclarationGetSymbolTime = 0;
    TypeScript.declarationEmitGetBaseTypeTime = 0;
    TypeScript.declarationEmitGetAccessorFunctionTime = 0;
    TypeScript.declarationEmitGetTypeParameterSymbolTime = 0;
    TypeScript.declarationEmitGetImportDeclarationSymbolTime = 0;

    TypeScript.ioHostResolvePathTime = 0;
    TypeScript.ioHostDirectoryNameTime = 0;
    TypeScript.ioHostCreateDirectoryStructureTime = 0;
    TypeScript.ioHostWriteFileTime = 0;

    var Document = (function () {
        function Document(fileName, compilationSettings, scriptSnapshot, byteOrderMark, version, isOpen, syntaxTree) {
            this.fileName = fileName;
            this.compilationSettings = compilationSettings;
            this.scriptSnapshot = scriptSnapshot;
            this.byteOrderMark = byteOrderMark;
            this.version = version;
            this.isOpen = isOpen;
            this._diagnostics = null;
            this._syntaxTree = null;
            this._bloomFilter = null;
            if (isOpen) {
                this._syntaxTree = syntaxTree;
            } else {
                var start = new Date().getTime();
                this._diagnostics = syntaxTree.diagnostics();
                TypeScript.syntaxDiagnosticsTime += new Date().getTime() - start;
            }

            this.lineMap = syntaxTree.lineMap();

            var start = new Date().getTime();
            this.script = TypeScript.SyntaxTreeToAstVisitor.visit(syntaxTree, fileName, compilationSettings, isOpen);
            TypeScript.astTranslationTime += new Date().getTime() - start;
        }
        Document.prototype.diagnostics = function () {
            if (this._diagnostics === null) {
                this._diagnostics = this._syntaxTree.diagnostics();
            }

            return this._diagnostics;
        };

        Document.prototype.syntaxTree = function () {
            if (this._syntaxTree) {
                return this._syntaxTree;
            }

            return TypeScript.Parser.parse(this.fileName, TypeScript.SimpleText.fromScriptSnapshot(this.scriptSnapshot), TypeScript.isDTSFile(this.fileName), TypeScript.getParseOptions(this.compilationSettings));
        };

        Document.prototype.bloomFilter = function () {
            if (!this._bloomFilter) {
                var identifiers = new TypeScript.BlockIntrinsics();
                var pre = function (cur, parent, walker) {
                    if (TypeScript.isValidAstNode(cur)) {
                        if (cur.nodeType() === 21 /* Name */) {
                            var nodeText = (cur).text();

                            identifiers[nodeText] = true;
                        }
                    }

                    return cur;
                };

                TypeScript.getAstWalkerFactory().walk(this.script, pre, null, null, identifiers);

                var identifierCount = 0;
                for (var name in identifiers) {
                    if (identifiers[name]) {
                        identifierCount++;
                    }
                }

                this._bloomFilter = new TypeScript.BloomFilter(identifierCount);
                this._bloomFilter.addKeys(identifiers);
            }
            return this._bloomFilter;
        };

        Document.prototype.update = function (scriptSnapshot, version, isOpen, textChangeRange, settings) {
            var oldScript = this.script;
            var oldSyntaxTree = this._syntaxTree;

            var text = TypeScript.SimpleText.fromScriptSnapshot(scriptSnapshot);

            var newSyntaxTree = textChangeRange === null || oldSyntaxTree === null ? TypeScript.Parser.parse(this.fileName, text, TypeScript.isDTSFile(this.fileName), TypeScript.getParseOptions(this.compilationSettings)) : TypeScript.Parser.incrementalParse(oldSyntaxTree, textChangeRange, text);

            return new Document(this.fileName, this.compilationSettings, scriptSnapshot, this.byteOrderMark, version, isOpen, newSyntaxTree);
        };

        Document.create = function (fileName, scriptSnapshot, byteOrderMark, version, isOpen, referencedFiles, compilationSettings) {
            var start = new Date().getTime();
            var syntaxTree = TypeScript.Parser.parse(fileName, TypeScript.SimpleText.fromScriptSnapshot(scriptSnapshot), TypeScript.isDTSFile(fileName), TypeScript.getParseOptions(compilationSettings));
            TypeScript.syntaxTreeParseTime += new Date().getTime() - start;

            var document = new Document(fileName, compilationSettings, scriptSnapshot, byteOrderMark, version, isOpen, syntaxTree);
            document.script.referencedFiles = referencedFiles;

            return document;
        };
        return Document;
    })();
    TypeScript.Document = Document;

    TypeScript.globalSemanticInfoChain = null;
    TypeScript.globalBinder = null;
    TypeScript.globalLogger = null;

    TypeScript.useDirectTypeStorage = false;

    var TypeScriptCompiler = (function () {
        function TypeScriptCompiler(logger, settings) {
            if (typeof logger === "undefined") { logger = new TypeScript.NullLogger(); }
            if (typeof settings === "undefined") { settings = new TypeScript.CompilationSettings(); }
            this.logger = logger;
            this.settings = settings;
            this.resolver = null;
            this.semanticInfoChain = null;
            this.fileNameToDocument = new TypeScript.StringHashTable();
            this.emitOptions = new TypeScript.EmitOptions(this.settings);
            TypeScript.globalLogger = logger;
        }
        TypeScriptCompiler.prototype.getDocument = function (fileName) {
            return this.fileNameToDocument.lookup(TypeScript.switchToForwardSlashes(fileName));
        };

        TypeScriptCompiler.prototype.timeFunction = function (funcDescription, func) {
            return TypeScript.timeFunction(this.logger, funcDescription, func);
        };

        TypeScriptCompiler.prototype.addSourceUnit = function (fileName, scriptSnapshot, byteOrderMark, version, isOpen, referencedFiles) {
            if (typeof referencedFiles === "undefined") { referencedFiles = []; }
            fileName = TypeScript.switchToForwardSlashes(fileName);

            TypeScript.sourceCharactersCompiled += scriptSnapshot.getLength();

            var document = Document.create(fileName, scriptSnapshot, byteOrderMark, version, isOpen, referencedFiles, this.emitOptions.compilationSettings);
            this.fileNameToDocument.addOrUpdate(fileName, document);

            return document;
        };

        TypeScriptCompiler.prototype.updateSourceUnit = function (fileName, scriptSnapshot, version, isOpen, textChangeRange) {
            var _this = this;
            fileName = TypeScript.switchToForwardSlashes(fileName);
            return this.timeFunction("pullUpdateUnit(" + fileName + ")", function () {
                var document = _this.getDocument(fileName);
                var updatedDocument = document.update(scriptSnapshot, version, isOpen, textChangeRange, _this.settings);

                _this.fileNameToDocument.addOrUpdate(fileName, updatedDocument);

                _this.pullUpdateScript(document, updatedDocument);

                return updatedDocument;
            });
        };

        TypeScriptCompiler.prototype.isDynamicModuleCompilation = function () {
            var fileNames = this.fileNameToDocument.getAllKeys();
            for (var i = 0, n = fileNames.length; i < n; i++) {
                var document = this.getDocument(fileNames[i]);
                var script = document.script;
                if (!script.isDeclareFile && script.topLevelMod !== null) {
                    return true;
                }
            }
            return false;
        };

        TypeScriptCompiler.prototype.updateCommonDirectoryPath = function () {
            var commonComponents = [];
            var commonComponentsLength = -1;

            var fileNames = this.fileNameToDocument.getAllKeys();
            for (var i = 0, len = fileNames.length; i < len; i++) {
                var fileName = fileNames[i];
                var document = this.getDocument(fileNames[i]);
                var script = document.script;

                if (!script.isDeclareFile) {
                    var fileComponents = TypeScript.filePathComponents(fileName);
                    if (commonComponentsLength === -1) {
                        commonComponents = fileComponents;
                        commonComponentsLength = commonComponents.length;
                    } else {
                        var updatedPath = false;
                        for (var j = 0; j < commonComponentsLength && j < fileComponents.length; j++) {
                            if (commonComponents[j] !== fileComponents[j]) {
                                commonComponentsLength = j;
                                updatedPath = true;

                                if (j === 0) {
                                    if (this.emitOptions.compilationSettings.outDirOption || this.emitOptions.compilationSettings.sourceRoot) {
                                        return new TypeScript.Diagnostic(null, 0, 0, TypeScript.DiagnosticCode.Cannot_find_the_common_subdirectory_path_for_the_input_files, null);
                                    } else {
                                        this.emitOptions.commonDirectoryPath = "";
                                        return null;
                                    }
                                }

                                break;
                            }
                        }

                        if (!updatedPath && fileComponents.length < commonComponentsLength) {
                            commonComponentsLength = fileComponents.length;
                        }
                    }
                }
            }

            this.emitOptions.commonDirectoryPath = commonComponents.slice(0, commonComponentsLength).join("/") + "/";
            return null;
        };

        TypeScriptCompiler.prototype.convertToDirectoryPath = function (dirPath) {
            if (dirPath && dirPath.charAt(dirPath.length - 1) !== "/") {
                dirPath += "/";
            }

            return dirPath;
        };

        TypeScriptCompiler.prototype.setEmitOptions = function (ioHost) {
            this.emitOptions.ioHost = ioHost;

            if (this.emitOptions.compilationSettings.moduleGenTarget === 0 /* Unspecified */ && this.isDynamicModuleCompilation()) {
                return new TypeScript.Diagnostic(null, 0, 0, TypeScript.DiagnosticCode.Cannot_compile_external_modules_unless_the_module_flag_is_provided, null);
            }

            if (!this.emitOptions.compilationSettings.mapSourceFiles) {
                if (this.emitOptions.compilationSettings.mapRoot) {
                    if (this.emitOptions.compilationSettings.sourceRoot) {
                        return new TypeScript.Diagnostic(null, 0, 0, TypeScript.DiagnosticCode.Options_mapRoot_and_sourceRoot_cannot_be_specified_without_specifying_sourcemap_option, null);
                    } else {
                        return new TypeScript.Diagnostic(null, 0, 0, TypeScript.DiagnosticCode.Option_mapRoot_cannot_be_specified_without_specifying_sourcemap_option, null);
                    }
                } else if (this.emitOptions.compilationSettings.sourceRoot) {
                    return new TypeScript.Diagnostic(null, 0, 0, TypeScript.DiagnosticCode.Option_sourceRoot_cannot_be_specified_without_specifying_sourcemap_option, null);
                }
            }

            this.emitOptions.compilationSettings.mapRoot = this.convertToDirectoryPath(TypeScript.switchToForwardSlashes(this.emitOptions.compilationSettings.mapRoot));
            this.emitOptions.compilationSettings.sourceRoot = this.convertToDirectoryPath(TypeScript.switchToForwardSlashes(this.emitOptions.compilationSettings.sourceRoot));

            if (!this.emitOptions.compilationSettings.outFileOption && !this.emitOptions.compilationSettings.outDirOption && !this.emitOptions.compilationSettings.mapRoot && !this.emitOptions.compilationSettings.sourceRoot) {
                this.emitOptions.outputMany = true;
                this.emitOptions.commonDirectoryPath = "";
                return null;
            }

            if (this.emitOptions.compilationSettings.outFileOption) {
                this.emitOptions.compilationSettings.outFileOption = TypeScript.switchToForwardSlashes(this.emitOptions.ioHost.resolvePath(this.emitOptions.compilationSettings.outFileOption));
                this.emitOptions.outputMany = false;
            } else {
                this.emitOptions.outputMany = true;
            }

            if (this.emitOptions.compilationSettings.outDirOption) {
                this.emitOptions.compilationSettings.outDirOption = TypeScript.switchToForwardSlashes(this.emitOptions.ioHost.resolvePath(this.emitOptions.compilationSettings.outDirOption));
                this.emitOptions.compilationSettings.outDirOption = this.convertToDirectoryPath(this.emitOptions.compilationSettings.outDirOption);
            }

            if (this.emitOptions.compilationSettings.outDirOption || this.emitOptions.compilationSettings.mapRoot || this.emitOptions.compilationSettings.sourceRoot) {
                return this.updateCommonDirectoryPath();
            }

            return null;
        };

        TypeScriptCompiler.prototype.getScripts = function () {
            var result = [];
            var fileNames = this.fileNameToDocument.getAllKeys();

            for (var i = 0, n = fileNames.length; i < n; i++) {
                var document = this.getDocument(fileNames[i]);
                result.push(document.script);
            }

            return result;
        };

        TypeScriptCompiler.prototype.getDocuments = function () {
            var result = [];
            var fileNames = this.fileNameToDocument.getAllKeys();

            for (var i = 0, n = fileNames.length; i < n; i++) {
                var document = this.getDocument(fileNames[i]);
                result.push(document);
            }

            return result;
        };

        TypeScriptCompiler.prototype.writeByteOrderMarkForDocument = function (document) {
            if (this.emitOptions.outputMany || document.script.topLevelMod) {
                return document.byteOrderMark !== 0 /* None */;
            } else {
                var fileNames = this.fileNameToDocument.getAllKeys();

                for (var i = 0, n = fileNames.length; i < n; i++) {
                    if (document.script.topLevelMod) {
                        continue;
                    }
                    var document = this.getDocument(fileNames[i]);
                    if (document.byteOrderMark !== 0 /* None */) {
                        return true;
                    }
                }

                return false;
            }
        };

        TypeScriptCompiler.mapToDTSFileName = function (fileName, wholeFileNameReplaced) {
            return TypeScript.getDeclareFilePath(fileName);
        };

        TypeScriptCompiler.prototype.canEmitDeclarations = function (script) {
            if (!this.settings.generateDeclarationFiles) {
                return false;
            }

            if (!!script && (script.isDeclareFile || script.moduleElements === null)) {
                return false;
            }

            return true;
        };

        TypeScriptCompiler.prototype.emitDeclarations = function (document, declarationEmitter) {
            var script = document.script;
            if (this.canEmitDeclarations(script)) {
                if (declarationEmitter) {
                    declarationEmitter.document = document;
                } else {
                    var declareFileName = this.emitOptions.mapOutputFileName(document, TypeScriptCompiler.mapToDTSFileName);
                    declarationEmitter = new TypeScript.DeclarationEmitter(declareFileName, document, this);
                }

                declarationEmitter.emitDeclarations(script);
            }

            return declarationEmitter;
        };

        TypeScriptCompiler.prototype.emitAllDeclarations = function () {
            var start = new Date().getTime();

            if (this.canEmitDeclarations()) {
                var sharedEmitter = null;
                var fileNames = this.fileNameToDocument.getAllKeys();

                for (var i = 0, n = fileNames.length; i < n; i++) {
                    var fileName = fileNames[i];

                    try  {
                        var document = this.getDocument(fileNames[i]);

                        if (this.emitOptions.outputMany || document.script.topLevelMod) {
                            var singleEmitter = this.emitDeclarations(document);
                            if (singleEmitter) {
                                singleEmitter.close();
                            }
                        } else {
                            sharedEmitter = this.emitDeclarations(document, sharedEmitter);
                        }
                    } catch (ex1) {
                        return TypeScript.Emitter.handleEmitterError(fileName, ex1);
                    }
                }

                if (sharedEmitter) {
                    try  {
                        sharedEmitter.close();
                    } catch (ex2) {
                        return TypeScript.Emitter.handleEmitterError(sharedEmitter.document.fileName, ex2);
                    }
                }
            }

            TypeScript.declarationEmitTime += new Date().getTime() - start;

            return [];
        };

        TypeScriptCompiler.prototype.emitUnitDeclarations = function (fileName) {
            if (this.canEmitDeclarations()) {
                var document = this.getDocument(fileName);

                if (this.emitOptions.outputMany || document.script.topLevelMod) {
                    try  {
                        var emitter = this.emitDeclarations(document);
                        if (emitter) {
                            emitter.close();
                        }
                    } catch (ex1) {
                        return TypeScript.Emitter.handleEmitterError(fileName, ex1);
                    }
                } else {
                    return this.emitAllDeclarations();
                }
            }

            return [];
        };

        TypeScriptCompiler.mapToFileNameExtension = function (extension, fileName, wholeFileNameReplaced) {
            if (wholeFileNameReplaced) {
                return fileName;
            } else {
                var splitFname = fileName.split(".");
                splitFname.pop();
                return splitFname.join(".") + extension;
            }
        };

        TypeScriptCompiler.mapToJSFileName = function (fileName, wholeFileNameReplaced) {
            return TypeScriptCompiler.mapToFileNameExtension(".js", fileName, wholeFileNameReplaced);
        };

        TypeScriptCompiler.prototype.emit = function (document, inputOutputMapper, emitter) {
            var script = document.script;
            if (!script.isDeclareFile) {
                var typeScriptFileName = document.fileName;
                if (!emitter) {
                    var javaScriptFileName = this.emitOptions.mapOutputFileName(document, TypeScriptCompiler.mapToJSFileName);
                    var outFile = this.createFile(javaScriptFileName, this.writeByteOrderMarkForDocument(document));

                    emitter = new TypeScript.Emitter(javaScriptFileName, outFile, this.emitOptions, this.semanticInfoChain);

                    if (this.settings.mapSourceFiles) {
                        var sourceMapFile = this.createFile(javaScriptFileName + TypeScript.SourceMapper.MapFileExtension, false);
                        var sourceMapSourceInfo = this.emitOptions.decodeSourceMapOptions(document, javaScriptFileName);
                        emitter.setSourceMappings(new TypeScript.SourceMapper(outFile, sourceMapFile, sourceMapSourceInfo));
                    }

                    if (inputOutputMapper) {
                        inputOutputMapper(typeScriptFileName, javaScriptFileName);
                    }
                } else if (this.settings.mapSourceFiles) {
                    var sourceMapSourceInfo = this.emitOptions.decodeSourceMapOptions(document, emitter.emittingFileName, emitter.sourceMapper.sourceMapSourceInfo);
                    emitter.setSourceMappings(new TypeScript.SourceMapper(emitter.outfile, emitter.sourceMapper.sourceMapOut, sourceMapSourceInfo));
                }

                emitter.setDocument(document);
                emitter.emitJavascript(script, false);
            }

            return emitter;
        };

        TypeScriptCompiler.prototype.emitAll = function (ioHost, inputOutputMapper) {
            var start = new Date().getTime();

            var optionsDiagnostic = this.setEmitOptions(ioHost);
            if (optionsDiagnostic) {
                return [optionsDiagnostic];
            }

            var fileNames = this.fileNameToDocument.getAllKeys();
            var sharedEmitter = null;

            for (var i = 0, n = fileNames.length; i < n; i++) {
                var fileName = fileNames[i];

                var document = this.getDocument(fileName);

                try  {
                    if (this.emitOptions.outputMany || document.script.topLevelMod) {
                        var singleEmitter = this.emit(document, inputOutputMapper);

                        if (singleEmitter) {
                            singleEmitter.emitSourceMapsAndClose();
                        }
                    } else {
                        sharedEmitter = this.emit(document, inputOutputMapper, sharedEmitter);
                    }
                } catch (ex1) {
                    return TypeScript.Emitter.handleEmitterError(fileName, ex1);
                }
            }

            if (sharedEmitter) {
                try  {
                    sharedEmitter.emitSourceMapsAndClose();
                } catch (ex2) {
                    return TypeScript.Emitter.handleEmitterError(sharedEmitter.document.fileName, ex2);
                }
            }

            TypeScript.emitTime += new Date().getTime() - start;
            return [];
        };

        TypeScriptCompiler.prototype.emitUnit = function (fileName, ioHost, inputOutputMapper) {
            var optionsDiagnostic = this.setEmitOptions(ioHost);
            if (optionsDiagnostic) {
                return [optionsDiagnostic];
            }

            var document = this.getDocument(fileName);

            if (this.emitOptions.outputMany || document.script.topLevelMod) {
                try  {
                    var emitter = this.emit(document, inputOutputMapper);

                    if (emitter) {
                        emitter.emitSourceMapsAndClose();
                    }
                } catch (ex1) {
                    return TypeScript.Emitter.handleEmitterError(fileName, ex1);
                }

                return [];
            } else {
                return this.emitAll(ioHost, inputOutputMapper);
            }
        };

        TypeScriptCompiler.prototype.createFile = function (fileName, writeByteOrderMark) {
            return new TypeScript.TextWriter(this.emitOptions.ioHost, fileName, writeByteOrderMark);
        };

        TypeScriptCompiler.prototype.pullResolveFile = function (fileName) {
            var unit = this.semanticInfoChain.getUnit(fileName);

            if (!unit) {
                return false;
            }

            this.setUnit(fileName);

            this.resolver.resolveBoundDecls(unit.getTopLevelDecls()[0], new TypeScript.PullTypeResolutionContext());

            return true;
        };

        TypeScriptCompiler.prototype.getSyntacticDiagnostics = function (fileName) {
            return this.getDocument(fileName).diagnostics();
        };

        TypeScriptCompiler.prototype.getSyntaxTree = function (fileName) {
            return this.getDocument(fileName).syntaxTree();
        };
        TypeScriptCompiler.prototype.getScript = function (fileName) {
            return this.getDocument(fileName).script;
        };

        TypeScriptCompiler.prototype.getSemanticDiagnostics = function (fileName) {
            var errors = [];
            var unit = this.semanticInfoChain.getUnit(fileName);

            TypeScript.globalSemanticInfoChain = this.semanticInfoChain;
            if (TypeScript.globalBinder) {
                TypeScript.globalBinder.semanticInfoChain = this.semanticInfoChain;
            }

            if (unit) {
                var document = this.getDocument(fileName);
                var script = document.script;

                if (script) {
                    var startTime = (new Date()).getTime();
                    TypeScript.PullTypeResolver.typeCheck(this.settings, this.semanticInfoChain, fileName, script);
                    var endTime = (new Date()).getTime();

                    TypeScript.typeCheckTime += endTime - startTime;

                    unit.getDiagnostics(errors);
                }
            }

            return errors;
        };

        TypeScriptCompiler.prototype.resolveAllFiles = function () {
            var fileNames = this.fileNameToDocument.getAllKeys();
            for (var i = 0, n = fileNames.length; i < n; i++) {
                this.getSemanticDiagnostics(fileNames[i]);
            }
        };

        TypeScriptCompiler.prototype.setUnit = function (unitPath) {
            if (!this.resolver) {
                this.resolver = new TypeScript.PullTypeResolver(this.settings, this.semanticInfoChain, unitPath);
            }

            this.resolver.setUnitPath(unitPath);
        };

        TypeScriptCompiler.prototype.pullTypeCheck = function () {
            var start = new Date().getTime();

            this.semanticInfoChain = new TypeScript.SemanticInfoChain();
            TypeScript.globalSemanticInfoChain = this.semanticInfoChain;

            if (this.resolver) {
                this.resolver.semanticInfoChain = this.semanticInfoChain;
            }

            var declCollectionContext = null;
            var i, n;

            var createDeclsStartTime = new Date().getTime();

            var fileNames = this.fileNameToDocument.getAllKeys();
            var n = fileNames.length;
            for (var i = 0; i < n; i++) {
                var fileName = fileNames[i];
                var document = this.getDocument(fileName);
                var semanticInfo = new TypeScript.SemanticInfo(fileName);

                declCollectionContext = new TypeScript.DeclCollectionContext(semanticInfo, fileName);

                TypeScript.getAstWalkerFactory().walk(document.script, TypeScript.preCollectDecls, TypeScript.postCollectDecls, null, declCollectionContext);

                semanticInfo.addTopLevelDecl(declCollectionContext.getParent());

                this.semanticInfoChain.addUnit(semanticInfo);
            }

            var createDeclsEndTime = new Date().getTime();

            var bindStartTime = new Date().getTime();

            var binder = new TypeScript.PullSymbolBinder(this.semanticInfoChain);
            TypeScript.globalBinder = binder;

            for (var i = 1; i < this.semanticInfoChain.units.length; i++) {
                binder.bindDeclsForUnit(this.semanticInfoChain.units[i].getPath());
            }

            var bindEndTime = new Date().getTime();

            this.logger.log("Decl creation: " + (createDeclsEndTime - createDeclsStartTime));
            this.logger.log("Binding: " + (bindEndTime - bindStartTime));
            this.logger.log("    Time in findSymbol: " + TypeScript.time_in_findSymbol);
            this.logger.log("Number of symbols created: " + TypeScript.pullSymbolID);
            this.logger.log("Number of specialized types created: " + TypeScript.nSpecializationsCreated);
            this.logger.log("Number of specialized signatures created: " + TypeScript.nSpecializedSignaturesCreated);
        };

        TypeScriptCompiler.prototype.pullUpdateScript = function (oldDocument, newDocument) {
            var _this = this;
            this.timeFunction("pullUpdateScript: ", function () {
                var oldScript = oldDocument.script;
                var newScript = newDocument.script;

                var newScriptSemanticInfo = new TypeScript.SemanticInfo(oldDocument.fileName);
                var oldScriptSemanticInfo = _this.semanticInfoChain.getUnit(oldDocument.fileName);

                TypeScript.lastBoundPullDeclId = TypeScript.pullDeclID;

                var declCollectionContext = new TypeScript.DeclCollectionContext(newScriptSemanticInfo, oldDocument.fileName);

                TypeScript.getAstWalkerFactory().walk(newScript, TypeScript.preCollectDecls, TypeScript.postCollectDecls, null, declCollectionContext);

                var oldTopLevelDecl = oldScriptSemanticInfo.getTopLevelDecls()[0];
                var newTopLevelDecl = declCollectionContext.getParent();

                newScriptSemanticInfo.addTopLevelDecl(newTopLevelDecl);

                if (_this.resolver) {
                    _this.resolver.cleanCachedGlobals();
                }

                _this.semanticInfoChain.updateUnit(oldScriptSemanticInfo, newScriptSemanticInfo);

                _this.logger.log("Cleaning symbols...");
                var cleanStart = new Date().getTime();
                _this.semanticInfoChain.update();
                var cleanEnd = new Date().getTime();
                _this.logger.log("   time to clean: " + (cleanEnd - cleanStart));

                if (_this.resolver) {
                    _this.resolver.setUnitPath(oldDocument.fileName);
                }
            });
        };

        TypeScriptCompiler.prototype.getSymbolOfDeclaration = function (decl) {
            if (!decl) {
                return null;
            }
            var ast = this.resolver.getASTForDecl(decl);
            if (!ast) {
                return null;
            }
            var enlosingDecl = this.resolver.getEnclosingDecl(decl);
            if (ast.nodeType() === 81 /* Member */) {
                return this.getSymbolOfDeclaration(enlosingDecl);
            }
            var resolutionContext = new TypeScript.PullTypeResolutionContext();
            return this.resolver.resolveAST(ast, false, enlosingDecl, resolutionContext);
        };

        TypeScriptCompiler.prototype.resolvePosition = function (pos, document) {
            var declStack = [];
            var resultASTs = [];
            var script = document.script;
            var scriptName = document.fileName;

            var semanticInfo = this.semanticInfoChain.getUnit(scriptName);
            var lastDeclAST = null;
            var foundAST = null;
            var symbol = null;
            var candidateSignature = null;
            var callSignatures = null;

            var lambdaAST = null;
            var declarationInitASTs = [];
            var objectLitAST = null;
            var asgAST = null;
            var typeAssertionASTs = [];
            var resolutionContext = new TypeScript.PullTypeResolutionContext();
            var inTypeReference = false;
            var enclosingDecl = null;
            var isConstructorCall = false;

            TypeScript.globalSemanticInfoChain = this.semanticInfoChain;
            if (TypeScript.globalBinder) {
                TypeScript.globalBinder.semanticInfoChain = this.semanticInfoChain;
            }

            var pre = function (cur, parent) {
                if (TypeScript.isValidAstNode(cur)) {
                    if (pos >= cur.minChar && pos <= cur.limChar) {
                        var previous = resultASTs[resultASTs.length - 1];

                        if (previous === undefined || (cur.minChar >= previous.minChar && cur.limChar <= previous.limChar)) {
                            var decl = semanticInfo.getDeclForAST(cur);

                            if (decl) {
                                declStack[declStack.length] = decl;
                                lastDeclAST = cur;
                            }

                            if (cur.nodeType() === 13 /* FunctionDeclaration */ && TypeScript.hasFlag((cur).getFunctionFlags(), 8192 /* IsFunctionExpression */)) {
                                lambdaAST = cur;
                            } else if (cur.nodeType() === 18 /* VariableDeclarator */) {
                                declarationInitASTs[declarationInitASTs.length] = cur;
                            } else if (cur.nodeType() === 23 /* ObjectLiteralExpression */) {
                                objectLitAST = cur;
                            } else if (cur.nodeType() === 79 /* CastExpression */) {
                                typeAssertionASTs[typeAssertionASTs.length] = cur;
                            } else if (cur.nodeType() === 39 /* AssignmentExpression */) {
                                asgAST = cur;
                            } else if (cur.nodeType() === 11 /* TypeRef */) {
                                inTypeReference = true;
                            }

                            resultASTs[resultASTs.length] = cur;
                        }
                    }
                }
                return cur;
            };

            TypeScript.getAstWalkerFactory().walk(script, pre);

            if (resultASTs.length) {
                this.setUnit(scriptName);

                foundAST = resultASTs[resultASTs.length - 1];

                if (foundAST.nodeType() === 21 /* Name */ && resultASTs.length > 1) {
                    var previousAST = resultASTs[resultASTs.length - 2];
                    switch (previousAST.nodeType()) {
                        case 15 /* InterfaceDeclaration */:
                            if (foundAST === (previousAST).name) {
                                foundAST = previousAST;
                            }
                            break;
                        case 14 /* ClassDeclaration */:
                            if (foundAST === (previousAST).name) {
                                foundAST = previousAST;
                            }
                            break;
                        case 16 /* ModuleDeclaration */:
                            if (foundAST === (previousAST).name) {
                                foundAST = previousAST;
                            }
                            break;

                        case 18 /* VariableDeclarator */:
                            if (foundAST === (previousAST).id) {
                                foundAST = previousAST;
                            }
                            break;

                        case 13 /* FunctionDeclaration */:
                            if (foundAST === (previousAST).name) {
                                foundAST = previousAST;
                            }
                            break;
                    }
                }

                var funcDecl = null;
                if (lastDeclAST === foundAST) {
                    symbol = declStack[declStack.length - 1].getSymbol();
                    this.resolver.resolveDeclaredSymbol(symbol, null, resolutionContext);
                    symbol.setUnresolved();
                    enclosingDecl = declStack[declStack.length - 1].getParentDecl();
                    if (foundAST.nodeType() === 13 /* FunctionDeclaration */) {
                        funcDecl = foundAST;
                    }
                } else {
                    for (var i = declStack.length - 1; i >= 0; i--) {
                        if (!(declStack[i].kind & (1024 /* Variable */ | 2048 /* Parameter */))) {
                            enclosingDecl = declStack[i];
                            break;
                        }
                    }

                    var callExpression = null;
                    if ((foundAST.nodeType() === 31 /* SuperExpression */ || foundAST.nodeType() === 30 /* ThisExpression */ || foundAST.nodeType() === 21 /* Name */) && resultASTs.length > 1) {
                        for (var i = resultASTs.length - 2; i >= 0; i--) {
                            if (resultASTs[i].nodeType() === 33 /* MemberAccessExpression */ && (resultASTs[i]).operand2 === resultASTs[i + 1]) {
                                foundAST = resultASTs[i];
                            } else if ((resultASTs[i].nodeType() === 37 /* InvocationExpression */ || resultASTs[i].nodeType() === 38 /* ObjectCreationExpression */) && (resultASTs[i]).target === resultASTs[i + 1]) {
                                callExpression = resultASTs[i];
                                break;
                            } else if (resultASTs[i].nodeType() === 13 /* FunctionDeclaration */ && (resultASTs[i]).name === resultASTs[i + 1]) {
                                funcDecl = resultASTs[i];
                                break;
                            } else {
                                break;
                            }
                        }
                    }

                    if (foundAST.nodeType() === 1 /* List */) {
                        for (var i = 0; i < (foundAST).members.length; i++) {
                            if ((foundAST).members[i].minChar > pos) {
                                foundAST = (foundAST).members[i];
                                break;
                            }
                        }
                    }

                    resolutionContext.resolvingTypeReference = inTypeReference;

                    var inContextuallyTypedAssignment = false;

                    if (declarationInitASTs.length) {
                        var assigningAST;

                        for (var i = 0; i < declarationInitASTs.length; i++) {
                            assigningAST = declarationInitASTs[i];
                            inContextuallyTypedAssignment = (assigningAST !== null) && (assigningAST.typeExpr !== null);

                            this.resolver.resolveAST(assigningAST, false, null, resolutionContext);
                            var varSymbol = this.semanticInfoChain.getSymbolForAST(assigningAST, scriptName);

                            if (varSymbol && inContextuallyTypedAssignment) {
                                var contextualType = varSymbol.type;
                                resolutionContext.pushContextualType(contextualType, false, null);
                            }

                            if (assigningAST.init) {
                                this.resolver.resolveAST(assigningAST.init, inContextuallyTypedAssignment, enclosingDecl, resolutionContext);
                            }
                        }
                    }

                    if (typeAssertionASTs.length) {
                        for (var i = 0; i < typeAssertionASTs.length; i++) {
                            this.resolver.resolveAST(typeAssertionASTs[i], inContextuallyTypedAssignment, enclosingDecl, resolutionContext);
                        }
                    }

                    if (asgAST) {
                        this.resolver.resolveAST(asgAST, inContextuallyTypedAssignment, enclosingDecl, resolutionContext);
                    }

                    if (objectLitAST) {
                        this.resolver.resolveAST(objectLitAST, inContextuallyTypedAssignment, enclosingDecl, resolutionContext);
                    }

                    if (lambdaAST) {
                        this.resolver.resolveAST(lambdaAST, true, enclosingDecl, resolutionContext);
                        enclosingDecl = semanticInfo.getDeclForAST(lambdaAST);
                    }

                    symbol = this.resolver.resolveAST(foundAST, inContextuallyTypedAssignment, enclosingDecl, resolutionContext);
                    if (callExpression) {
                        var isPropertyOrVar = symbol.kind === 4096 /* Property */ || symbol.kind === 1024 /* Variable */;
                        var typeSymbol = symbol.type;
                        if (isPropertyOrVar) {
                            isPropertyOrVar = (typeSymbol.kind !== 16 /* Interface */ && typeSymbol.kind !== 8388608 /* ObjectType */) || typeSymbol.name === "";
                        }

                        if (!isPropertyOrVar) {
                            isConstructorCall = foundAST.nodeType() === 31 /* SuperExpression */ || callExpression.nodeType() === 38 /* ObjectCreationExpression */;

                            if (foundAST.nodeType() === 31 /* SuperExpression */) {
                                if (symbol.kind === 8 /* Class */) {
                                    callSignatures = (symbol).getConstructorMethod().type.getConstructSignatures();
                                }
                            } else {
                                callSignatures = callExpression.nodeType() === 37 /* InvocationExpression */ ? typeSymbol.getCallSignatures() : typeSymbol.getConstructSignatures();
                            }

                            var callResolutionResults = new TypeScript.PullAdditionalCallResolutionData();
                            if (callExpression.nodeType() === 37 /* InvocationExpression */) {
                                this.resolver.resolveInvocationExpression(callExpression, inContextuallyTypedAssignment, enclosingDecl, resolutionContext, callResolutionResults);
                            } else {
                                this.resolver.resolveObjectCreationExpression(callExpression, inContextuallyTypedAssignment, enclosingDecl, resolutionContext, callResolutionResults);
                            }

                            if (callResolutionResults.candidateSignature) {
                                candidateSignature = callResolutionResults.candidateSignature;
                            }
                            if (callResolutionResults.targetSymbol && callResolutionResults.targetSymbol.name !== "") {
                                symbol = callResolutionResults.targetSymbol;
                            }
                            foundAST = callExpression;
                        }
                    }
                }

                if (funcDecl) {
                    if (symbol && symbol.kind !== 4096 /* Property */) {
                        var signatureInfo = TypeScript.PullHelpers.getSignatureForFuncDecl(funcDecl, this.semanticInfoChain.getUnit(scriptName));
                        candidateSignature = signatureInfo.signature;
                        callSignatures = signatureInfo.allSignatures;
                    }
                } else if (!callSignatures && symbol && (symbol.kind === 65536 /* Method */ || symbol.kind === 16384 /* Function */)) {
                    var typeSym = symbol.type;
                    if (typeSym) {
                        callSignatures = typeSym.getCallSignatures();
                    }
                }
            }

            var enclosingScopeSymbol = this.getSymbolOfDeclaration(enclosingDecl);

            return {
                symbol: symbol,
                ast: foundAST,
                enclosingScopeSymbol: enclosingScopeSymbol,
                candidateSignature: candidateSignature,
                callSignatures: callSignatures,
                isConstructorCall: isConstructorCall
            };
        };

        TypeScriptCompiler.prototype.extractResolutionContextFromPath = function (path, document, propagateContextualTypes) {
            var script = document.script;
            var scriptName = document.fileName;

            var semanticInfo = this.semanticInfoChain.getUnit(scriptName);
            var enclosingDecl = null;
            var enclosingDeclAST = null;
            var inContextuallyTypedAssignment = false;

            TypeScript.globalSemanticInfoChain = this.semanticInfoChain;
            if (TypeScript.globalBinder) {
                TypeScript.globalBinder.semanticInfoChain = this.semanticInfoChain;
            }

            var resolutionContext = new TypeScript.PullTypeResolutionContext();
            resolutionContext.resolveAggressively = true;

            if (path.count() === 0) {
                return null;
            }

            this.setUnit(semanticInfo.getPath());

            for (var i = 0, n = path.count(); i < n; i++) {
                var current = path.asts[i];

                switch (current.nodeType()) {
                    case 13 /* FunctionDeclaration */:
                        if (TypeScript.hasFlag((current).getFunctionFlags(), 8192 /* IsFunctionExpression */)) {
                            this.resolver.resolveAST((current), true, enclosingDecl, resolutionContext);
                        }

                        break;

                    case 18 /* VariableDeclarator */:
                        var assigningAST = current;
                        inContextuallyTypedAssignment = (assigningAST.typeExpr !== null);

                        if (inContextuallyTypedAssignment) {
                            if (propagateContextualTypes) {
                                this.resolver.resolveAST(assigningAST, false, null, resolutionContext);
                                var varSymbol = this.semanticInfoChain.getSymbolForAST(assigningAST, scriptName);

                                var contextualType = null;
                                if (varSymbol && inContextuallyTypedAssignment) {
                                    contextualType = varSymbol.type;
                                }

                                resolutionContext.pushContextualType(contextualType, false, null);

                                if (assigningAST.init) {
                                    this.resolver.resolveAST(assigningAST.init, inContextuallyTypedAssignment, enclosingDecl, resolutionContext);
                                }
                            }
                        }

                        break;

                    case 37 /* InvocationExpression */:
                    case 38 /* ObjectCreationExpression */:
                        if (propagateContextualTypes) {
                            var isNew = current.nodeType() === 38 /* ObjectCreationExpression */;
                            var callExpression = current;
                            var contextualType = null;

                            if ((i + 1 < n) && callExpression.arguments === path.asts[i + 1]) {
                                var callResolutionResults = new TypeScript.PullAdditionalCallResolutionData();
                                if (isNew) {
                                    this.resolver.resolveObjectCreationExpression(callExpression, inContextuallyTypedAssignment, enclosingDecl, resolutionContext, callResolutionResults);
                                } else {
                                    this.resolver.resolveInvocationExpression(callExpression, inContextuallyTypedAssignment, enclosingDecl, resolutionContext, callResolutionResults);
                                }

                                if (callResolutionResults.actualParametersContextTypeSymbols) {
                                    var argExpression = (path.asts[i + 1] && path.asts[i + 1].nodeType() === 1 /* List */) ? path.asts[i + 2] : path.asts[i + 1];
                                    if (argExpression) {
                                        for (var j = 0, m = callExpression.arguments.members.length; j < m; j++) {
                                            if (callExpression.arguments.members[j] === argExpression) {
                                                var callContextualType = callResolutionResults.actualParametersContextTypeSymbols[j];
                                                if (callContextualType) {
                                                    contextualType = callContextualType;
                                                    break;
                                                }
                                            }
                                        }
                                    }
                                }
                            } else {
                                if (isNew) {
                                    this.resolver.resolveObjectCreationExpression(callExpression, inContextuallyTypedAssignment, enclosingDecl, resolutionContext);
                                } else {
                                    this.resolver.resolveInvocationExpression(callExpression, inContextuallyTypedAssignment, enclosingDecl, resolutionContext);
                                }
                            }

                            resolutionContext.pushContextualType(contextualType, false, null);
                        }

                        break;

                    case 22 /* ArrayLiteralExpression */:
                        if (propagateContextualTypes) {
                            var contextualType = null;
                            var currentContextualType = resolutionContext.getContextualType();
                            if (currentContextualType && currentContextualType.isArray()) {
                                contextualType = currentContextualType.getElementType();
                            }

                            resolutionContext.pushContextualType(contextualType, false, null);
                        }

                        break;

                    case 23 /* ObjectLiteralExpression */:
                        if (propagateContextualTypes) {
                            var objectLiteralExpression = current;
                            var objectLiteralResolutionContext = new TypeScript.PullAdditionalObjectLiteralResolutionData();
                            this.resolver.resolveObjectLiteralExpression(objectLiteralExpression, inContextuallyTypedAssignment, enclosingDecl, resolutionContext, objectLiteralResolutionContext);

                            var memeberAST = (path.asts[i + 1] && path.asts[i + 1].nodeType() === 1 /* List */) ? path.asts[i + 2] : path.asts[i + 1];
                            if (memeberAST) {
                                var contextualType = null;
                                var memberDecls = objectLiteralExpression.operand;
                                if (memberDecls && objectLiteralResolutionContext.membersContextTypeSymbols) {
                                    for (var j = 0, m = memberDecls.members.length; j < m; j++) {
                                        if (memberDecls.members[j] === memeberAST) {
                                            var memberContextualType = objectLiteralResolutionContext.membersContextTypeSymbols[j];
                                            if (memberContextualType) {
                                                contextualType = memberContextualType;
                                                break;
                                            }
                                        }
                                    }
                                }

                                resolutionContext.pushContextualType(contextualType, false, null);
                            }
                        }

                        break;

                    case 39 /* AssignmentExpression */:
                        if (propagateContextualTypes) {
                            var assignmentExpression = current;
                            var contextualType = null;

                            if (path.asts[i + 1] && path.asts[i + 1] === assignmentExpression.operand2) {
                                var leftType = this.resolver.resolveAST(assignmentExpression.operand1, inContextuallyTypedAssignment, enclosingDecl, resolutionContext).type;
                                if (leftType) {
                                    inContextuallyTypedAssignment = true;
                                    contextualType = leftType;
                                }
                            }

                            resolutionContext.pushContextualType(contextualType, false, null);
                        }

                        break;

                    case 79 /* CastExpression */:
                        var castExpression = current;

                        if (i + 1 < n && path.asts[i + 1] === castExpression.castTerm) {
                            resolutionContext.resolvingTypeReference = true;
                        } else {
                            if (propagateContextualTypes) {
                                var contextualType = null;
                                var typeSymbol = this.resolver.resolveTypeAssertionExpression(castExpression, inContextuallyTypedAssignment, enclosingDecl, resolutionContext);

                                if (typeSymbol) {
                                    inContextuallyTypedAssignment = true;
                                    contextualType = typeSymbol;
                                }

                                resolutionContext.pushContextualType(contextualType, false, null);
                            }
                        }

                        break;

                    case 94 /* ReturnStatement */:
                        if (propagateContextualTypes) {
                            var returnStatement = current;
                            var contextualType = null;

                            if (enclosingDecl && (enclosingDecl.kind & TypeScript.PullElementKind.SomeFunction)) {
                                var functionDeclaration = enclosingDeclAST;
                                if (functionDeclaration.returnTypeAnnotation) {
                                    var currentResolvingTypeReference = resolutionContext.resolvingTypeReference;
                                    resolutionContext.resolvingTypeReference = true;
                                    var returnTypeSymbol = this.resolver.resolveTypeReference(functionDeclaration.returnTypeAnnotation, enclosingDecl, resolutionContext);
                                    resolutionContext.resolvingTypeReference = currentResolvingTypeReference;
                                    if (returnTypeSymbol) {
                                        inContextuallyTypedAssignment = true;
                                        contextualType = returnTypeSymbol;
                                    }
                                } else {
                                    var currentContextualType = resolutionContext.getContextualType();
                                    if (currentContextualType && currentContextualType.isFunction()) {
                                        var currentContextualTypeSignatureSymbol = currentContextualType.getDeclarations()[0].getSignatureSymbol();
                                        var currentContextualTypeReturnTypeSymbol = currentContextualTypeSignatureSymbol.returnType;
                                        if (currentContextualTypeReturnTypeSymbol) {
                                            inContextuallyTypedAssignment = true;
                                            contextualType = currentContextualTypeReturnTypeSymbol;
                                        }
                                    }
                                }
                            }

                            resolutionContext.pushContextualType(contextualType, false, null);
                        }

                        break;

                    case 11 /* TypeRef */:
                    case 9 /* TypeParameter */:
                        resolutionContext.resolvingTypeReference = true;
                        break;

                    case 14 /* ClassDeclaration */:
                        var classDeclaration = current;
                        if (path.asts[i + 1]) {
                            if (path.asts[i + 1] === classDeclaration.extendsList || path.asts[i + 1] === classDeclaration.implementsList) {
                                resolutionContext.resolvingTypeReference = true;
                            }
                        }

                        break;

                    case 15 /* InterfaceDeclaration */:
                        var interfaceDeclaration = current;
                        if (path.asts[i + 1]) {
                            if (path.asts[i + 1] === interfaceDeclaration.extendsList || path.asts[i + 1] === interfaceDeclaration.implementsList || path.asts[i + 1] === interfaceDeclaration.name) {
                                resolutionContext.resolvingTypeReference = true;
                            }
                        }

                        break;
                }

                var decl = semanticInfo.getDeclForAST(current);
                if (decl && !(decl.kind & (1024 /* Variable */ | 2048 /* Parameter */ | 8192 /* TypeParameter */))) {
                    enclosingDecl = decl;
                    enclosingDeclAST = current;
                }
            }

            if (path.ast().nodeType() === 21 /* Name */ && path.count() > 1) {
                for (var i = path.count() - 1; i >= 0; i--) {
                    if (path.asts[path.top - 1].nodeType() === 33 /* MemberAccessExpression */ && (path.asts[path.top - 1]).operand2 === path.asts[path.top]) {
                        path.pop();
                    } else {
                        break;
                    }
                }
            }

            return {
                ast: path.ast(),
                enclosingDecl: enclosingDecl,
                resolutionContext: resolutionContext,
                inContextuallyTypedAssignment: inContextuallyTypedAssignment
            };
        };

        TypeScriptCompiler.prototype.pullGetSymbolInformationFromPath = function (path, document) {
            var context = this.extractResolutionContextFromPath(path, document, true);
            if (!context) {
                return null;
            }

            TypeScript.globalSemanticInfoChain = this.semanticInfoChain;
            if (TypeScript.globalBinder) {
                TypeScript.globalBinder.semanticInfoChain = this.semanticInfoChain;
            }

            var symbol = this.resolver.resolveAST(path.ast(), context.inContextuallyTypedAssignment, context.enclosingDecl, context.resolutionContext);

            return {
                symbol: symbol,
                ast: path.ast(),
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl)
            };
        };

        TypeScriptCompiler.prototype.pullGetDeclarationSymbolInformation = function (path, document) {
            var script = document.script;
            var scriptName = document.fileName;

            var ast = path.ast();

            if (ast.nodeType() !== 14 /* ClassDeclaration */ && ast.nodeType() !== 15 /* InterfaceDeclaration */ && ast.nodeType() !== 16 /* ModuleDeclaration */ && ast.nodeType() !== 13 /* FunctionDeclaration */ && ast.nodeType() !== 18 /* VariableDeclarator */) {
                return null;
            }

            var context = this.extractResolutionContextFromPath(path, document, true);
            if (!context) {
                return null;
            }

            TypeScript.globalSemanticInfoChain = this.semanticInfoChain;
            if (TypeScript.globalBinder) {
                TypeScript.globalBinder.semanticInfoChain = this.semanticInfoChain;
            }

            var semanticInfo = this.semanticInfoChain.getUnit(scriptName);
            var decl = semanticInfo.getDeclForAST(ast);
            var symbol = (decl.kind & TypeScript.PullElementKind.SomeSignature) ? decl.getSignatureSymbol() : decl.getSymbol();
            this.resolver.resolveDeclaredSymbol(symbol, null, context.resolutionContext);

            symbol.setUnresolved();

            return {
                symbol: symbol,
                ast: path.ast(),
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl)
            };
        };

        TypeScriptCompiler.prototype.pullGetCallInformationFromPath = function (path, document) {
            if (path.ast().nodeType() !== 37 /* InvocationExpression */ && path.ast().nodeType() !== 38 /* ObjectCreationExpression */) {
                return null;
            }

            var isNew = (path.ast().nodeType() === 38 /* ObjectCreationExpression */);

            var context = this.extractResolutionContextFromPath(path, document, true);
            if (!context) {
                return null;
            }

            TypeScript.globalSemanticInfoChain = this.semanticInfoChain;
            if (TypeScript.globalBinder) {
                TypeScript.globalBinder.semanticInfoChain = this.semanticInfoChain;
            }

            var callResolutionResults = new TypeScript.PullAdditionalCallResolutionData();

            if (isNew) {
                this.resolver.resolveObjectCreationExpression(path.ast(), context.inContextuallyTypedAssignment, context.enclosingDecl, context.resolutionContext, callResolutionResults);
            } else {
                this.resolver.resolveInvocationExpression(path.ast(), context.inContextuallyTypedAssignment, context.enclosingDecl, context.resolutionContext, callResolutionResults);
            }

            return {
                targetSymbol: callResolutionResults.targetSymbol,
                resolvedSignatures: callResolutionResults.resolvedSignatures,
                candidateSignature: callResolutionResults.candidateSignature,
                ast: path.ast(),
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl),
                isConstructorCall: isNew
            };
        };

        TypeScriptCompiler.prototype.pullGetVisibleMemberSymbolsFromPath = function (path, document) {
            TypeScript.globalSemanticInfoChain = this.semanticInfoChain;
            if (TypeScript.globalBinder) {
                TypeScript.globalBinder.semanticInfoChain = this.semanticInfoChain;
            }

            var context = this.extractResolutionContextFromPath(path, document, true);
            if (!context) {
                return null;
            }

            var symbols = this.resolver.getVisibleMembersFromExpression(path.ast(), context.enclosingDecl, context.resolutionContext);
            if (!symbols) {
                return null;
            }

            return {
                symbols: symbols,
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl)
            };
        };

        TypeScriptCompiler.prototype.pullGetVisibleDeclsFromPath = function (path, document) {
            TypeScript.globalSemanticInfoChain = this.semanticInfoChain;
            if (TypeScript.globalBinder) {
                TypeScript.globalBinder.semanticInfoChain = this.semanticInfoChain;
            }

            var context = this.extractResolutionContextFromPath(path, document, false);
            if (!context) {
                return null;
            }

            return this.resolver.getVisibleDecls(context.enclosingDecl, context.resolutionContext);
        };

        TypeScriptCompiler.prototype.pullGetContextualMembersFromPath = function (path, document) {
            TypeScript.globalSemanticInfoChain = this.semanticInfoChain;
            if (TypeScript.globalBinder) {
                TypeScript.globalBinder.semanticInfoChain = this.semanticInfoChain;
            }

            if (path.ast().nodeType() !== 23 /* ObjectLiteralExpression */) {
                return null;
            }

            var context = this.extractResolutionContextFromPath(path, document, true);
            if (!context) {
                return null;
            }

            var members = this.resolver.getVisibleContextSymbols(context.enclosingDecl, context.resolutionContext);

            return {
                symbols: members,
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl)
            };
        };

        TypeScriptCompiler.prototype.pullGetDeclInformation = function (decl, path, document) {
            var context = this.extractResolutionContextFromPath(path, document, true);
            if (!context) {
                return null;
            }

            TypeScript.globalSemanticInfoChain = this.semanticInfoChain;
            if (TypeScript.globalBinder) {
                TypeScript.globalBinder.semanticInfoChain = this.semanticInfoChain;
            }

            var symbol = decl.getSymbol();
            this.resolver.resolveDeclaredSymbol(symbol, context.enclosingDecl, context.resolutionContext);
            symbol.setUnresolved();

            return {
                symbol: symbol,
                ast: path.ast(),
                enclosingScopeSymbol: this.getSymbolOfDeclaration(context.enclosingDecl)
            };
        };

        TypeScriptCompiler.prototype.pullGetTypeInfoAtPosition = function (pos, document) {
            var _this = this;
            return this.timeFunction("pullGetTypeInfoAtPosition for pos " + pos + ":", function () {
                return _this.resolvePosition(pos, document);
            });
        };

        TypeScriptCompiler.prototype.getTopLevelDeclarations = function (scriptName) {
            var unit = this.semanticInfoChain.getUnit(scriptName);

            if (!unit) {
                return null;
            }

            return unit.getTopLevelDecls();
        };

        TypeScriptCompiler.prototype.reportDiagnostics = function (errors, errorReporter) {
            for (var i = 0; i < errors.length; i++) {
                errorReporter.addDiagnostic(errors[i]);
            }
        };
        return TypeScriptCompiler;
    })();
    TypeScript.TypeScriptCompiler = TypeScriptCompiler;
})(TypeScript || (TypeScript = {}));
var TypeScript;
(function (TypeScript) {
    var ASTSpan = (function () {
        function ASTSpan() {
            this.minChar = -1;
            this.limChar = -1;
            this.trailingTriviaWidth = 0;
        }
        return ASTSpan;
    })();
    TypeScript.ASTSpan = ASTSpan;

    var astID = 0;

    function structuralEqualsNotIncludingPosition(ast1, ast2) {
        return structuralEquals(ast1, ast2, false);
    }
    TypeScript.structuralEqualsNotIncludingPosition = structuralEqualsNotIncludingPosition;

    function structuralEqualsIncludingPosition(ast1, ast2) {
        return structuralEquals(ast1, ast2, true);
    }
    TypeScript.structuralEqualsIncludingPosition = structuralEqualsIncludingPosition;

    function structuralEquals(ast1, ast2, includingPosition) {
        if (ast1 === ast2) {
            return true;
        }

        return ast1 !== null && ast2 !== null && ast1.nodeType() === ast2.nodeType() && ast1.structuralEquals(ast2, includingPosition);
    }

    function astArrayStructuralEquals(array1, array2, includingPosition) {
        return TypeScript.ArrayUtilities.sequenceEquals(array1, array2, includingPosition ? structuralEqualsIncludingPosition : structuralEqualsNotIncludingPosition);
    }

    var AST = (function () {
        function AST() {
            this.minChar = -1;
            this.limChar = -1;
            this.trailingTriviaWidth = 0;
            this._flags = 0 /* None */;
            this.typeCheckPhase = -1;
            this.astIDString = astID.toString();
            this.astID = astID++;
            this.symbol = null;
            this.aliasSymbol = null;
            this.decl = null;
            this._preComments = null;
            this._postComments = null;
            this._docComments = null;
        }
        AST.prototype.nodeType = function () {
            throw TypeScript.Errors.abstract();
        };

        AST.prototype.isStatement = function () {
            return false;
        };

        AST.prototype.preComments = function () {
            return this._preComments;
        };

        AST.prototype.postComments = function () {
            return this._postComments;
        };

        AST.prototype.setPreComments = function (comments) {
            if (comments && comments.length) {
                this._preComments = comments;
            } else if (this._preComments) {
                this._preComments = null;
            }
        };

        AST.prototype.setPostComments = function (comments) {
            if (comments && comments.length) {
                this._postComments = comments;
            } else if (this._postComments) {
                this._postComments = null;
            }
        };

        AST.prototype.shouldEmit = function () {
            return true;
        };

        AST.prototype.getFlags = function () {
            return this._flags;
        };

        AST.prototype.setFlags = function (flags) {
            this._flags = flags;
        };

        AST.prototype.getLength = function () {
            return this.limChar - this.minChar;
        };

        AST.prototype.isDeclaration = function () {
            return false;
        };

        AST.prototype.emit = function (emitter) {
            emitter.emitComments(this, true);
            emitter.recordSourceMappingStart(this);
            this.emitWorker(emitter);
            emitter.recordSourceMappingEnd(this);
            emitter.emitComments(this, false);
        };

        AST.prototype.emitWorker = function (emitter) {
            throw TypeScript.Errors.abstract();
        };

        AST.prototype.docComments = function () {
            if (!this.isDeclaration() || !this.preComments() || this.preComments().length === 0) {
                return [];
            }

            if (!this._docComments) {
                var preComments = this.preComments();
                var preCommentsLength = preComments.length;
                var docComments = new Array();
                for (var i = preCommentsLength - 1; i >= 0; i--) {
                    if (preComments[i].isDocComment()) {
                        docComments.push(preComments[i]);
                        continue;
                    }
                    break;
                }

                this._docComments = docComments.reverse();
            }

            return this._docComments;
        };

        AST.prototype.structuralEquals = function (ast, includingPosition) {
            if (includingPosition) {
                if (this.minChar !== ast.minChar || this.limChar !== ast.limChar) {
                    return false;
                }
            }

            return this._flags === ast._flags && astArrayStructuralEquals(this.preComments(), ast.preComments(), includingPosition) && astArrayStructuralEquals(this.postComments(), ast.postComments(), includingPosition);
        };
        return AST;
    })();
    TypeScript.AST = AST;

    var ASTList = (function (_super) {
        __extends(ASTList, _super);
        function ASTList(members, separatorCount) {
            _super.call(this);
            this.members = members;
            this.separatorCount = separatorCount;
        }
        ASTList.prototype.nodeType = function () {
            return 1 /* List */;
        };

        ASTList.prototype.emit = function (emitter) {
            emitter.recordSourceMappingStart(this);
            emitter.emitModuleElements(this);
            emitter.recordSourceMappingEnd(this);
        };

        ASTList.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && astArrayStructuralEquals(this.members, ast.members, includingPosition);
        };
        return ASTList;
    })(AST);
    TypeScript.ASTList = ASTList;

    var Identifier = (function (_super) {
        __extends(Identifier, _super);
        function Identifier(actualText, text) {
            _super.call(this);
            this.actualText = actualText;
            this._text = text;
        }
        Identifier.prototype.text = function () {
            if (!this._text) {
                this._text = TypeScript.Syntax.massageEscapes(this.actualText);
            }

            return this._text;
        };

        Identifier.prototype.nodeType = function () {
            return 21 /* Name */;
        };

        Identifier.prototype.isMissing = function () {
            return false;
        };

        Identifier.prototype.emit = function (emitter) {
            emitter.emitName(this, true);
        };

        Identifier.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this.actualText === ast.actualText && this.isMissing() === ast.isMissing();
        };
        return Identifier;
    })(AST);
    TypeScript.Identifier = Identifier;

    var MissingIdentifier = (function (_super) {
        __extends(MissingIdentifier, _super);
        function MissingIdentifier() {
            _super.call(this, "__missing", "__missing");
        }
        MissingIdentifier.prototype.isMissing = function () {
            return true;
        };

        MissingIdentifier.prototype.emit = function (emitter) {
        };
        return MissingIdentifier;
    })(Identifier);
    TypeScript.MissingIdentifier = MissingIdentifier;

    var LiteralExpression = (function (_super) {
        __extends(LiteralExpression, _super);
        function LiteralExpression(_nodeType) {
            _super.call(this);
            this._nodeType = _nodeType;
        }
        LiteralExpression.prototype.nodeType = function () {
            return this._nodeType;
        };

        LiteralExpression.prototype.emitWorker = function (emitter) {
            switch (this.nodeType()) {
                case 8 /* NullLiteral */:
                    emitter.writeToOutput("null");
                    break;
                case 4 /* FalseLiteral */:
                    emitter.writeToOutput("false");
                    break;
                case 3 /* TrueLiteral */:
                    emitter.writeToOutput("true");
                    break;
                default:
                    throw TypeScript.Errors.abstract();
            }
        };

        LiteralExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition);
        };
        return LiteralExpression;
    })(AST);
    TypeScript.LiteralExpression = LiteralExpression;

    var ThisExpression = (function (_super) {
        __extends(ThisExpression, _super);
        function ThisExpression() {
            _super.apply(this, arguments);
        }
        ThisExpression.prototype.nodeType = function () {
            return 30 /* ThisExpression */;
        };

        ThisExpression.prototype.emitWorker = function (emitter) {
            if (emitter.thisFunctionDeclaration && (TypeScript.hasFlag(emitter.thisFunctionDeclaration.getFunctionFlags(), 2048 /* IsFatArrowFunction */))) {
                emitter.writeToOutput("_this");
            } else {
                emitter.writeToOutput("this");
            }
        };

        ThisExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition);
        };
        return ThisExpression;
    })(AST);
    TypeScript.ThisExpression = ThisExpression;

    var SuperExpression = (function (_super) {
        __extends(SuperExpression, _super);
        function SuperExpression() {
            _super.apply(this, arguments);
        }
        SuperExpression.prototype.nodeType = function () {
            return 31 /* SuperExpression */;
        };

        SuperExpression.prototype.emitWorker = function (emitter) {
            emitter.emitSuperReference();
        };

        SuperExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition);
        };
        return SuperExpression;
    })(AST);
    TypeScript.SuperExpression = SuperExpression;

    var ParenthesizedExpression = (function (_super) {
        __extends(ParenthesizedExpression, _super);
        function ParenthesizedExpression(expression) {
            _super.call(this);
            this.expression = expression;
        }
        ParenthesizedExpression.prototype.nodeType = function () {
            return 80 /* ParenthesizedExpression */;
        };

        ParenthesizedExpression.prototype.emitWorker = function (emitter) {
            emitter.writeToOutput("(");
            this.expression.emit(emitter);
            emitter.writeToOutput(")");
        };

        ParenthesizedExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.expression, ast.expression, includingPosition);
        };
        return ParenthesizedExpression;
    })(AST);
    TypeScript.ParenthesizedExpression = ParenthesizedExpression;

    var UnaryExpression = (function (_super) {
        __extends(UnaryExpression, _super);
        function UnaryExpression(_nodeType, operand, castTerm) {
            _super.call(this);
            this._nodeType = _nodeType;
            this.operand = operand;
            this.castTerm = castTerm;
        }
        UnaryExpression.prototype.nodeType = function () {
            return this._nodeType;
        };

        UnaryExpression.prototype.emitWorker = function (emitter) {
            switch (this.nodeType()) {
                case 77 /* PostIncrementExpression */:
                    this.operand.emit(emitter);
                    emitter.writeToOutput("++");
                    break;
                case 74 /* LogicalNotExpression */:
                    emitter.writeToOutput("!");
                    this.operand.emit(emitter);
                    break;
                case 78 /* PostDecrementExpression */:
                    this.operand.emit(emitter);
                    emitter.writeToOutput("--");
                    break;
                case 23 /* ObjectLiteralExpression */:
                    emitter.emitObjectLiteral(this);
                    break;
                case 22 /* ArrayLiteralExpression */:
                    emitter.emitArrayLiteral(this);
                    break;
                case 73 /* BitwiseNotExpression */:
                    emitter.writeToOutput("~");
                    this.operand.emit(emitter);
                    break;
                case 28 /* NegateExpression */:
                    emitter.writeToOutput("-");
                    if (this.operand.nodeType() === 28 /* NegateExpression */ || this.operand.nodeType() === 76 /* PreDecrementExpression */) {
                        emitter.writeToOutput(" ");
                    }
                    this.operand.emit(emitter);
                    break;
                case 27 /* PlusExpression */:
                    emitter.writeToOutput("+");
                    if (this.operand.nodeType() === 27 /* PlusExpression */ || this.operand.nodeType() === 75 /* PreIncrementExpression */) {
                        emitter.writeToOutput(" ");
                    }
                    this.operand.emit(emitter);
                    break;
                case 75 /* PreIncrementExpression */:
                    emitter.writeToOutput("++");
                    this.operand.emit(emitter);
                    break;
                case 76 /* PreDecrementExpression */:
                    emitter.writeToOutput("--");
                    this.operand.emit(emitter);
                    break;
                case 35 /* TypeOfExpression */:
                    emitter.writeToOutput("typeof ");
                    this.operand.emit(emitter);
                    break;
                case 29 /* DeleteExpression */:
                    emitter.writeToOutput("delete ");
                    this.operand.emit(emitter);
                    break;
                case 25 /* VoidExpression */:
                    emitter.writeToOutput("void ");
                    this.operand.emit(emitter);
                    break;
                case 79 /* CastExpression */:
                    this.operand.emit(emitter);
                    break;
                default:
                    throw TypeScript.Errors.abstract();
            }
        };

        UnaryExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.castTerm, ast.castTerm, includingPosition) && structuralEquals(this.operand, ast.operand, includingPosition);
        };
        return UnaryExpression;
    })(AST);
    TypeScript.UnaryExpression = UnaryExpression;

    var ObjectCreationExpression = (function (_super) {
        __extends(ObjectCreationExpression, _super);
        function ObjectCreationExpression(target, typeArguments, arguments, closeParenSpan) {
            _super.call(this);
            this.target = target;
            this.typeArguments = typeArguments;
            this.arguments = arguments;
            this.closeParenSpan = closeParenSpan;
            this.callResolutionData = null;
        }
        ObjectCreationExpression.prototype.nodeType = function () {
            return 38 /* ObjectCreationExpression */;
        };

        ObjectCreationExpression.prototype.emitWorker = function (emitter) {
            emitter.emitNew(this, this.target, this.arguments);
        };

        ObjectCreationExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.target, ast.target, includingPosition) && structuralEquals(this.typeArguments, ast.typeArguments, includingPosition) && structuralEquals(this.arguments, ast.arguments, includingPosition);
        };
        return ObjectCreationExpression;
    })(AST);
    TypeScript.ObjectCreationExpression = ObjectCreationExpression;

    var InvocationExpression = (function (_super) {
        __extends(InvocationExpression, _super);
        function InvocationExpression(target, typeArguments, arguments, closeParenSpan) {
            _super.call(this);
            this.target = target;
            this.typeArguments = typeArguments;
            this.arguments = arguments;
            this.closeParenSpan = closeParenSpan;
            this.callResolutionData = null;
        }
        InvocationExpression.prototype.nodeType = function () {
            return 37 /* InvocationExpression */;
        };

        InvocationExpression.prototype.emitWorker = function (emitter) {
            emitter.emitCall(this, this.target, this.arguments);
        };

        InvocationExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.target, ast.target, includingPosition) && structuralEquals(this.typeArguments, ast.typeArguments, includingPosition) && structuralEquals(this.arguments, ast.arguments, includingPosition);
        };
        return InvocationExpression;
    })(AST);
    TypeScript.InvocationExpression = InvocationExpression;

    var BinaryExpression = (function (_super) {
        __extends(BinaryExpression, _super);
        function BinaryExpression(_nodeType, operand1, operand2) {
            _super.call(this);
            this._nodeType = _nodeType;
            this.operand1 = operand1;
            this.operand2 = operand2;
        }
        BinaryExpression.prototype.nodeType = function () {
            return this._nodeType;
        };

        BinaryExpression.getTextForBinaryToken = function (nodeType) {
            switch (nodeType) {
                case 26 /* CommaExpression */:
                    return ",";
                case 39 /* AssignmentExpression */:
                    return "=";
                case 40 /* AddAssignmentExpression */:
                    return "+=";
                case 41 /* SubtractAssignmentExpression */:
                    return "-=";
                case 43 /* MultiplyAssignmentExpression */:
                    return "*=";
                case 42 /* DivideAssignmentExpression */:
                    return "/=";
                case 44 /* ModuloAssignmentExpression */:
                    return "%=";
                case 45 /* AndAssignmentExpression */:
                    return "&=";
                case 46 /* ExclusiveOrAssignmentExpression */:
                    return "^=";
                case 47 /* OrAssignmentExpression */:
                    return "|=";
                case 48 /* LeftShiftAssignmentExpression */:
                    return "<<=";
                case 49 /* SignedRightShiftAssignmentExpression */:
                    return ">>=";
                case 50 /* UnsignedRightShiftAssignmentExpression */:
                    return ">>>=";
                case 52 /* LogicalOrExpression */:
                    return "||";
                case 53 /* LogicalAndExpression */:
                    return "&&";
                case 54 /* BitwiseOrExpression */:
                    return "|";
                case 55 /* BitwiseExclusiveOrExpression */:
                    return "^";
                case 56 /* BitwiseAndExpression */:
                    return "&";
                case 57 /* EqualsWithTypeConversionExpression */:
                    return "==";
                case 58 /* NotEqualsWithTypeConversionExpression */:
                    return "!=";
                case 59 /* EqualsExpression */:
                    return "===";
                case 60 /* NotEqualsExpression */:
                    return "!==";
                case 61 /* LessThanExpression */:
                    return "<";
                case 63 /* GreaterThanExpression */:
                    return ">";
                case 62 /* LessThanOrEqualExpression */:
                    return "<=";
                case 64 /* GreaterThanOrEqualExpression */:
                    return ">=";
                case 34 /* InstanceOfExpression */:
                    return "instanceof";
                case 32 /* InExpression */:
                    return "in";
                case 70 /* LeftShiftExpression */:
                    return "<<";
                case 71 /* SignedRightShiftExpression */:
                    return ">>";
                case 72 /* UnsignedRightShiftExpression */:
                    return ">>>";
                case 67 /* MultiplyExpression */:
                    return "*";
                case 68 /* DivideExpression */:
                    return "/";
                case 69 /* ModuloExpression */:
                    return "%";
                case 65 /* AddExpression */:
                    return "+";
                case 66 /* SubtractExpression */:
                    return "-";
            }

            throw TypeScript.Errors.invalidOperation();
        };

        BinaryExpression.prototype.emitWorker = function (emitter) {
            switch (this.nodeType()) {
                case 33 /* MemberAccessExpression */:
                    if (!emitter.tryEmitConstant(this)) {
                        this.operand1.emit(emitter);
                        emitter.writeToOutput(".");
                        emitter.emitName(this.operand2, false);
                    }
                    break;
                case 36 /* ElementAccessExpression */:
                    emitter.emitIndex(this.operand1, this.operand2);
                    break;

                case 81 /* Member */:
                    if (this.operand2.nodeType() === 13 /* FunctionDeclaration */ && (this.operand2).isAccessor()) {
                        var funcDecl = this.operand2;
                        if (TypeScript.hasFlag(funcDecl.getFunctionFlags(), 32 /* GetAccessor */)) {
                            emitter.writeToOutput("get ");
                        } else {
                            emitter.writeToOutput("set ");
                        }
                        this.operand1.emit(emitter);
                    } else {
                        this.operand1.emit(emitter);
                        emitter.writeToOutputTrimmable(": ");
                    }
                    this.operand2.emit(emitter);
                    break;
                case 26 /* CommaExpression */:
                    this.operand1.emit(emitter);
                    emitter.writeToOutput(", ");
                    this.operand2.emit(emitter);
                    break;
                default: {
                    this.operand1.emit(emitter);
                    var binOp = BinaryExpression.getTextForBinaryToken(this.nodeType());
                    if (binOp === "instanceof") {
                        emitter.writeToOutput(" instanceof ");
                    } else if (binOp === "in") {
                        emitter.writeToOutput(" in ");
                    } else {
                        emitter.writeToOutputTrimmable(" " + binOp + " ");
                    }
                    this.operand2.emit(emitter);
                }
            }
        };

        BinaryExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.operand1, ast.operand1, includingPosition) && structuralEquals(this.operand2, ast.operand2, includingPosition);
        };
        return BinaryExpression;
    })(AST);
    TypeScript.BinaryExpression = BinaryExpression;

    var ConditionalExpression = (function (_super) {
        __extends(ConditionalExpression, _super);
        function ConditionalExpression(operand1, operand2, operand3) {
            _super.call(this);
            this.operand1 = operand1;
            this.operand2 = operand2;
            this.operand3 = operand3;
        }
        ConditionalExpression.prototype.nodeType = function () {
            return 51 /* ConditionalExpression */;
        };

        ConditionalExpression.prototype.emitWorker = function (emitter) {
            this.operand1.emit(emitter);
            emitter.writeToOutput(" ? ");
            this.operand2.emit(emitter);
            emitter.writeToOutput(" : ");
            this.operand3.emit(emitter);
        };

        ConditionalExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.operand1, ast.operand1, includingPosition) && structuralEquals(this.operand2, ast.operand2, includingPosition) && structuralEquals(this.operand3, ast.operand3, includingPosition);
        };
        return ConditionalExpression;
    })(AST);
    TypeScript.ConditionalExpression = ConditionalExpression;

    var NumberLiteral = (function (_super) {
        __extends(NumberLiteral, _super);
        function NumberLiteral(value, text) {
            _super.call(this);
            this.value = value;
            this._text = text;
        }
        NumberLiteral.prototype.text = function () {
            return this._text;
        };

        NumberLiteral.prototype.nodeType = function () {
            return 7 /* NumericLiteral */;
        };

        NumberLiteral.prototype.emitWorker = function (emitter) {
            emitter.writeToOutput(this._text);
        };

        NumberLiteral.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this.value === ast.value && this._text === ast._text;
        };
        return NumberLiteral;
    })(AST);
    TypeScript.NumberLiteral = NumberLiteral;

    var RegexLiteral = (function (_super) {
        __extends(RegexLiteral, _super);
        function RegexLiteral(text) {
            _super.call(this);
            this.text = text;
        }
        RegexLiteral.prototype.nodeType = function () {
            return 6 /* RegularExpressionLiteral */;
        };

        RegexLiteral.prototype.emitWorker = function (emitter) {
            emitter.writeToOutput(this.text);
        };

        RegexLiteral.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this.text === ast.text;
        };
        return RegexLiteral;
    })(AST);
    TypeScript.RegexLiteral = RegexLiteral;

    var StringLiteral = (function (_super) {
        __extends(StringLiteral, _super);
        function StringLiteral(actualText, text) {
            _super.call(this);
            this.actualText = actualText;
            this._text = text;
        }
        StringLiteral.prototype.text = function () {
            return this._text;
        };

        StringLiteral.prototype.nodeType = function () {
            return 5 /* StringLiteral */;
        };

        StringLiteral.prototype.emitWorker = function (emitter) {
            emitter.writeToOutput(this.actualText);
        };

        StringLiteral.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this.actualText === ast.actualText;
        };
        return StringLiteral;
    })(AST);
    TypeScript.StringLiteral = StringLiteral;

    var ImportDeclaration = (function (_super) {
        __extends(ImportDeclaration, _super);
        function ImportDeclaration(id, alias) {
            _super.call(this);
            this.id = id;
            this.alias = alias;
            this._varFlags = 0 /* None */;
        }
        ImportDeclaration.prototype.nodeType = function () {
            return 17 /* ImportDeclaration */;
        };

        ImportDeclaration.prototype.isDeclaration = function () {
            return true;
        };

        ImportDeclaration.prototype.getVarFlags = function () {
            return this._varFlags;
        };

        ImportDeclaration.prototype.setVarFlags = function (flags) {
            this._varFlags = flags;
        };

        ImportDeclaration.prototype.isExternalImportDeclaration = function () {
            if (this.alias.nodeType() == 21 /* Name */) {
                var text = (this.alias).actualText;
                return TypeScript.isQuoted(text);
            }

            return false;
        };

        ImportDeclaration.prototype.emit = function (emitter) {
            emitter.emitImportDeclaration(this);
        };

        ImportDeclaration.prototype.getAliasName = function (aliasAST) {
            if (typeof aliasAST === "undefined") { aliasAST = this.alias; }
            if (aliasAST.nodeType() == 11 /* TypeRef */) {
                aliasAST = (aliasAST).term;
            }

            if (aliasAST.nodeType() === 21 /* Name */) {
                return (aliasAST).actualText;
            } else {
                var dotExpr = aliasAST;
                return this.getAliasName(dotExpr.operand1) + "." + this.getAliasName(dotExpr.operand2);
            }
        };

        ImportDeclaration.prototype.firstAliasedModToString = function () {
            if (this.alias.nodeType() === 21 /* Name */) {
                return (this.alias).actualText;
            } else {
                var dotExpr = this.alias;
                var firstMod = (dotExpr.term).operand1;
                return firstMod.actualText;
            }
        };

        ImportDeclaration.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this._varFlags === ast._varFlags && structuralEquals(this.id, ast.id, includingPosition) && structuralEquals(this.alias, ast.alias, includingPosition);
        };
        return ImportDeclaration;
    })(AST);
    TypeScript.ImportDeclaration = ImportDeclaration;

    var ExportAssignment = (function (_super) {
        __extends(ExportAssignment, _super);
        function ExportAssignment(id) {
            _super.call(this);
            this.id = id;
        }
        ExportAssignment.prototype.nodeType = function () {
            return 88 /* ExportAssignment */;
        };

        ExportAssignment.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.id, ast.id, includingPosition);
        };

        ExportAssignment.prototype.emit = function (emitter) {
            emitter.setExportAssignmentIdentifier(this.id.actualText);
        };
        return ExportAssignment;
    })(AST);
    TypeScript.ExportAssignment = ExportAssignment;

    var BoundDecl = (function (_super) {
        __extends(BoundDecl, _super);
        function BoundDecl(id, typeExpr, init) {
            _super.call(this);
            this.id = id;
            this.typeExpr = typeExpr;
            this.init = init;
            this.constantValue = null;
            this._varFlags = 0 /* None */;
        }
        BoundDecl.prototype.isDeclaration = function () {
            return true;
        };

        BoundDecl.prototype.getVarFlags = function () {
            return this._varFlags;
        };

        BoundDecl.prototype.setVarFlags = function (flags) {
            this._varFlags = flags;
        };

        BoundDecl.prototype.isProperty = function () {
            return TypeScript.hasFlag(this.getVarFlags(), 256 /* Property */);
        };

        BoundDecl.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this._varFlags === ast._varFlags && structuralEquals(this.init, ast.init, includingPosition) && structuralEquals(this.typeExpr, ast.typeExpr, includingPosition) && structuralEquals(this.id, ast.id, includingPosition);
        };
        return BoundDecl;
    })(AST);
    TypeScript.BoundDecl = BoundDecl;

    var VariableDeclarator = (function (_super) {
        __extends(VariableDeclarator, _super);
        function VariableDeclarator(id, typeExpr, init) {
            _super.call(this, id, typeExpr, init);
        }
        VariableDeclarator.prototype.nodeType = function () {
            return 18 /* VariableDeclarator */;
        };

        VariableDeclarator.prototype.isStatic = function () {
            return TypeScript.hasFlag(this.getVarFlags(), 16 /* Static */);
        };

        VariableDeclarator.prototype.emit = function (emitter) {
            emitter.emitVariableDeclarator(this);
        };
        return VariableDeclarator;
    })(BoundDecl);
    TypeScript.VariableDeclarator = VariableDeclarator;

    var Parameter = (function (_super) {
        __extends(Parameter, _super);
        function Parameter(id, typeExpr, init, isOptional) {
            _super.call(this, id, typeExpr, init);
            this.isOptional = isOptional;
        }
        Parameter.prototype.nodeType = function () {
            return 20 /* Parameter */;
        };

        Parameter.prototype.isOptionalArg = function () {
            return this.isOptional || this.init;
        };

        Parameter.prototype.emitWorker = function (emitter) {
            emitter.writeToOutput(this.id.actualText);
        };

        Parameter.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this.isOptional === ast.isOptional;
        };
        return Parameter;
    })(BoundDecl);
    TypeScript.Parameter = Parameter;

    var FunctionDeclaration = (function (_super) {
        __extends(FunctionDeclaration, _super);
        function FunctionDeclaration(name, block, isConstructor, typeArguments, arguments, returnTypeAnnotation, variableArgList) {
            _super.call(this);
            this.name = name;
            this.block = block;
            this.isConstructor = isConstructor;
            this.typeArguments = typeArguments;
            this.arguments = arguments;
            this.returnTypeAnnotation = returnTypeAnnotation;
            this.variableArgList = variableArgList;
            this.hint = null;
            this._functionFlags = 0 /* None */;
            this.classDecl = null;
        }
        FunctionDeclaration.prototype.isDeclaration = function () {
            return true;
        };

        FunctionDeclaration.prototype.nodeType = function () {
            return 13 /* FunctionDeclaration */;
        };

        FunctionDeclaration.prototype.getFunctionFlags = function () {
            return this._functionFlags;
        };

        FunctionDeclaration.prototype.setFunctionFlags = function (flags) {
            this._functionFlags = flags;
        };

        FunctionDeclaration.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this._functionFlags === ast._functionFlags && this.hint === ast.hint && this.variableArgList === ast.variableArgList && structuralEquals(this.name, ast.name, includingPosition) && structuralEquals(this.block, ast.block, includingPosition) && this.isConstructor === ast.isConstructor && structuralEquals(this.typeArguments, ast.typeArguments, includingPosition) && structuralEquals(this.arguments, ast.arguments, includingPosition);
        };

        FunctionDeclaration.prototype.shouldEmit = function () {
            return !TypeScript.hasFlag(this.getFunctionFlags(), 128 /* Signature */) && !TypeScript.hasFlag(this.getFunctionFlags(), 8 /* Ambient */);
        };

        FunctionDeclaration.prototype.emit = function (emitter) {
            emitter.emitFunction(this);
        };

        FunctionDeclaration.prototype.getNameText = function () {
            if (this.name) {
                return this.name.actualText;
            } else {
                return this.hint;
            }
        };

        FunctionDeclaration.prototype.isMethod = function () {
            return (this.getFunctionFlags() & 256 /* Method */) !== 0 /* None */;
        };

        FunctionDeclaration.prototype.isCallMember = function () {
            return TypeScript.hasFlag(this.getFunctionFlags(), 512 /* CallMember */);
        };
        FunctionDeclaration.prototype.isConstructMember = function () {
            return TypeScript.hasFlag(this.getFunctionFlags(), 1024 /* ConstructMember */);
        };
        FunctionDeclaration.prototype.isIndexerMember = function () {
            return TypeScript.hasFlag(this.getFunctionFlags(), 4096 /* IndexerMember */);
        };
        FunctionDeclaration.prototype.isSpecialFn = function () {
            return this.isCallMember() || this.isIndexerMember() || this.isConstructMember();
        };
        FunctionDeclaration.prototype.isAccessor = function () {
            return TypeScript.hasFlag(this.getFunctionFlags(), 32 /* GetAccessor */) || TypeScript.hasFlag(this.getFunctionFlags(), 64 /* SetAccessor */);
        };
        FunctionDeclaration.prototype.isGetAccessor = function () {
            return TypeScript.hasFlag(this.getFunctionFlags(), 32 /* GetAccessor */);
        };
        FunctionDeclaration.prototype.isSetAccessor = function () {
            return TypeScript.hasFlag(this.getFunctionFlags(), 64 /* SetAccessor */);
        };
        FunctionDeclaration.prototype.isStatic = function () {
            return TypeScript.hasFlag(this.getFunctionFlags(), 16 /* Static */);
        };

        FunctionDeclaration.prototype.isSignature = function () {
            return (this.getFunctionFlags() & 128 /* Signature */) !== 0 /* None */;
        };
        return FunctionDeclaration;
    })(AST);
    TypeScript.FunctionDeclaration = FunctionDeclaration;

    var Script = (function (_super) {
        __extends(Script, _super);
        function Script() {
            _super.apply(this, arguments);
            this.moduleElements = null;
            this.referencedFiles = new Array();
            this.isDeclareFile = false;
            this.topLevelMod = null;
        }
        Script.prototype.nodeType = function () {
            return 2 /* Script */;
        };

        Script.prototype.emit = function (emitter) {
            if (!this.isDeclareFile) {
                emitter.emitScriptElements(this);
            }
        };

        Script.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.moduleElements, ast.moduleElements, includingPosition);
        };
        return Script;
    })(AST);
    TypeScript.Script = Script;

    var ModuleDeclaration = (function (_super) {
        __extends(ModuleDeclaration, _super);
        function ModuleDeclaration(name, members, endingToken) {
            _super.call(this);
            this.name = name;
            this.members = members;
            this.endingToken = endingToken;
            this._moduleFlags = 0 /* None */;
            this.amdDependencies = new Array();

            this.prettyName = this.name.actualText;
        }
        ModuleDeclaration.prototype.isDeclaration = function () {
            return true;
        };

        ModuleDeclaration.prototype.nodeType = function () {
            return 16 /* ModuleDeclaration */;
        };

        ModuleDeclaration.prototype.getModuleFlags = function () {
            return this._moduleFlags;
        };

        ModuleDeclaration.prototype.setModuleFlags = function (flags) {
            this._moduleFlags = flags;
        };

        ModuleDeclaration.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this._moduleFlags === ast._moduleFlags && structuralEquals(this.name, ast.name, includingPosition) && structuralEquals(this.members, ast.members, includingPosition);
        };

        ModuleDeclaration.prototype.isEnum = function () {
            return TypeScript.hasFlag(this.getModuleFlags(), 128 /* IsEnum */);
        };
        ModuleDeclaration.prototype.isWholeFile = function () {
            return TypeScript.hasFlag(this.getModuleFlags(), 256 /* IsWholeFile */);
        };

        ModuleDeclaration.prototype.shouldEmit = function () {
            if (TypeScript.hasFlag(this.getModuleFlags(), 8 /* Ambient */)) {
                return false;
            }

            if (TypeScript.hasFlag(this.getModuleFlags(), 128 /* IsEnum */)) {
                return true;
            }

            for (var i = 0, n = this.members.members.length; i < n; i++) {
                var member = this.members.members[i];

                if (member.nodeType() === 16 /* ModuleDeclaration */) {
                    if ((member).shouldEmit()) {
                        return true;
                    }
                } else if (member.nodeType() !== 15 /* InterfaceDeclaration */) {
                    return true;
                }
            }

            return false;
        };

        ModuleDeclaration.prototype.emit = function (emitter) {
            if (this.shouldEmit()) {
                emitter.emitComments(this, true);
                emitter.emitModule(this);
                emitter.emitComments(this, false);
            }
        };
        return ModuleDeclaration;
    })(AST);
    TypeScript.ModuleDeclaration = ModuleDeclaration;

    var TypeDeclaration = (function (_super) {
        __extends(TypeDeclaration, _super);
        function TypeDeclaration(name, typeParameters, extendsList, implementsList, members) {
            _super.call(this);
            this.name = name;
            this.typeParameters = typeParameters;
            this.extendsList = extendsList;
            this.implementsList = implementsList;
            this.members = members;
            this._varFlags = 0 /* None */;
        }
        TypeDeclaration.prototype.isDeclaration = function () {
            return true;
        };

        TypeDeclaration.prototype.getVarFlags = function () {
            return this._varFlags;
        };

        TypeDeclaration.prototype.setVarFlags = function (flags) {
            this._varFlags = flags;
        };

        TypeDeclaration.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this._varFlags === ast._varFlags && structuralEquals(this.name, ast.name, includingPosition) && structuralEquals(this.members, ast.members, includingPosition) && structuralEquals(this.typeParameters, ast.typeParameters, includingPosition) && structuralEquals(this.extendsList, ast.extendsList, includingPosition) && structuralEquals(this.implementsList, ast.implementsList, includingPosition);
        };
        return TypeDeclaration;
    })(AST);
    TypeScript.TypeDeclaration = TypeDeclaration;

    var ClassDeclaration = (function (_super) {
        __extends(ClassDeclaration, _super);
        function ClassDeclaration(name, typeParameters, members, extendsList, implementsList, endingToken) {
            _super.call(this, name, typeParameters, extendsList, implementsList, members);
            this.endingToken = endingToken;
            this.constructorDecl = null;
        }
        ClassDeclaration.prototype.nodeType = function () {
            return 14 /* ClassDeclaration */;
        };

        ClassDeclaration.prototype.shouldEmit = function () {
            return !TypeScript.hasFlag(this.getVarFlags(), 8 /* Ambient */);
        };

        ClassDeclaration.prototype.emit = function (emitter) {
            emitter.emitClass(this);
        };
        return ClassDeclaration;
    })(TypeDeclaration);
    TypeScript.ClassDeclaration = ClassDeclaration;

    var InterfaceDeclaration = (function (_super) {
        __extends(InterfaceDeclaration, _super);
        function InterfaceDeclaration(name, typeParameters, members, extendsList, implementsList, isObjectTypeLiteral) {
            _super.call(this, name, typeParameters, extendsList, implementsList, members);
            this.isObjectTypeLiteral = isObjectTypeLiteral;
        }
        InterfaceDeclaration.prototype.nodeType = function () {
            return 15 /* InterfaceDeclaration */;
        };

        InterfaceDeclaration.prototype.shouldEmit = function () {
            return false;
        };
        return InterfaceDeclaration;
    })(TypeDeclaration);
    TypeScript.InterfaceDeclaration = InterfaceDeclaration;

    var ThrowStatement = (function (_super) {
        __extends(ThrowStatement, _super);
        function ThrowStatement(expression) {
            _super.call(this);
            this.expression = expression;
        }
        ThrowStatement.prototype.nodeType = function () {
            return 96 /* ThrowStatement */;
        };

        ThrowStatement.prototype.isStatement = function () {
            return true;
        };

        ThrowStatement.prototype.emitWorker = function (emitter) {
            emitter.writeToOutput("throw ");
            this.expression.emit(emitter);
            emitter.writeToOutput(";");
        };

        ThrowStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.expression, ast.expression, includingPosition);
        };
        return ThrowStatement;
    })(AST);
    TypeScript.ThrowStatement = ThrowStatement;

    var ExpressionStatement = (function (_super) {
        __extends(ExpressionStatement, _super);
        function ExpressionStatement(expression) {
            _super.call(this);
            this.expression = expression;
        }
        ExpressionStatement.prototype.nodeType = function () {
            return 89 /* ExpressionStatement */;
        };

        ExpressionStatement.prototype.isStatement = function () {
            return true;
        };

        ExpressionStatement.prototype.emitWorker = function (emitter) {
            var isArrowExpression = this.expression.nodeType() === 13 /* FunctionDeclaration */ && TypeScript.hasFlag((this.expression).getFunctionFlags(), 2048 /* IsFatArrowFunction */);

            if (isArrowExpression) {
                emitter.writeToOutput("(");
            }

            this.expression.emit(emitter);

            if (isArrowExpression) {
                emitter.writeToOutput(")");
            }

            emitter.writeToOutput(";");
        };

        ExpressionStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.expression, ast.expression, includingPosition);
        };
        return ExpressionStatement;
    })(AST);
    TypeScript.ExpressionStatement = ExpressionStatement;

    var LabeledStatement = (function (_super) {
        __extends(LabeledStatement, _super);
        function LabeledStatement(identifier, statement) {
            _super.call(this);
            this.identifier = identifier;
            this.statement = statement;
        }
        LabeledStatement.prototype.nodeType = function () {
            return 93 /* LabeledStatement */;
        };

        LabeledStatement.prototype.isStatement = function () {
            return true;
        };

        LabeledStatement.prototype.emitWorker = function (emitter) {
            emitter.recordSourceMappingStart(this.identifier);
            emitter.writeToOutput(this.identifier.actualText);
            emitter.recordSourceMappingEnd(this.identifier);
            emitter.writeLineToOutput(":");
            emitter.emitJavascript(this.statement, true);
        };

        LabeledStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.identifier, ast.identifier, includingPosition) && structuralEquals(this.statement, ast.statement, includingPosition);
        };
        return LabeledStatement;
    })(AST);
    TypeScript.LabeledStatement = LabeledStatement;

    var VariableDeclaration = (function (_super) {
        __extends(VariableDeclaration, _super);
        function VariableDeclaration(declarators) {
            _super.call(this);
            this.declarators = declarators;
        }
        VariableDeclaration.prototype.nodeType = function () {
            return 19 /* VariableDeclaration */;
        };

        VariableDeclaration.prototype.emit = function (emitter) {
            emitter.emitVariableDeclaration(this);
        };

        VariableDeclaration.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.declarators, ast.declarators, includingPosition);
        };
        return VariableDeclaration;
    })(AST);
    TypeScript.VariableDeclaration = VariableDeclaration;

    var VariableStatement = (function (_super) {
        __extends(VariableStatement, _super);
        function VariableStatement(declaration) {
            _super.call(this);
            this.declaration = declaration;
        }
        VariableStatement.prototype.nodeType = function () {
            return 98 /* VariableStatement */;
        };

        VariableStatement.prototype.isStatement = function () {
            return true;
        };

        VariableStatement.prototype.shouldEmit = function () {
            var varDecl = this.declaration.declarators.members[0];
            return !TypeScript.hasFlag(varDecl.getVarFlags(), 8 /* Ambient */) || varDecl.init !== null;
        };

        VariableStatement.prototype.emitWorker = function (emitter) {
            if (TypeScript.hasFlag(this.getFlags(), 16 /* EnumElement */)) {
                emitter.emitEnumElement(this.declaration.declarators.members[0]);
            } else {
                this.declaration.emit(emitter);
                emitter.writeToOutput(";");
            }
        };

        VariableStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.declaration, ast.declaration, includingPosition);
        };
        return VariableStatement;
    })(AST);
    TypeScript.VariableStatement = VariableStatement;

    var Block = (function (_super) {
        __extends(Block, _super);
        function Block(statements, closeBraceSpan) {
            _super.call(this);
            this.statements = statements;
            this.closeBraceSpan = closeBraceSpan;
            this.closeBraceLeadingComments = null;
        }
        Block.prototype.nodeType = function () {
            return 82 /* Block */;
        };

        Block.prototype.isStatement = function () {
            return true;
        };

        Block.prototype.emitWorker = function (emitter) {
            emitter.writeLineToOutput(" {");
            emitter.indenter.increaseIndent();
            if (this.statements) {
                emitter.emitModuleElements(this.statements);
            }
            emitter.emitCommentsArray(this.closeBraceLeadingComments);
            emitter.indenter.decreaseIndent();
            emitter.emitIndent();
            emitter.writeToOutput("}");
        };

        Block.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.statements, ast.statements, includingPosition);
        };
        return Block;
    })(AST);
    TypeScript.Block = Block;

    var Jump = (function (_super) {
        __extends(Jump, _super);
        function Jump(_nodeType, target) {
            _super.call(this);
            this._nodeType = _nodeType;
            this.target = target;
        }
        Jump.prototype.nodeType = function () {
            return this._nodeType;
        };

        Jump.prototype.isStatement = function () {
            return true;
        };

        Jump.prototype.hasExplicitTarget = function () {
            return this.target;
        };

        Jump.prototype.emitWorker = function (emitter) {
            if (this.nodeType() === 83 /* BreakStatement */) {
                emitter.writeToOutput("break");
            } else {
                emitter.writeToOutput("continue");
            }
            if (this.hasExplicitTarget()) {
                emitter.writeToOutput(" " + this.target);
            }
            emitter.writeToOutput(";");
        };

        Jump.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this.target === ast.target;
        };
        return Jump;
    })(AST);
    TypeScript.Jump = Jump;

    var WhileStatement = (function (_super) {
        __extends(WhileStatement, _super);
        function WhileStatement(cond, body) {
            _super.call(this);
            this.cond = cond;
            this.body = body;
        }
        WhileStatement.prototype.nodeType = function () {
            return 99 /* WhileStatement */;
        };

        WhileStatement.prototype.isStatement = function () {
            return true;
        };

        WhileStatement.prototype.emitWorker = function (emitter) {
            emitter.writeToOutput("while (");
            this.cond.emit(emitter);
            emitter.writeToOutput(")");
            emitter.emitBlockOrStatement(this.body);
        };

        WhileStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.cond, ast.cond, includingPosition) && structuralEquals(this.body, ast.body, includingPosition);
        };
        return WhileStatement;
    })(AST);
    TypeScript.WhileStatement = WhileStatement;

    var DoStatement = (function (_super) {
        __extends(DoStatement, _super);
        function DoStatement(body, cond, whileSpan) {
            _super.call(this);
            this.body = body;
            this.cond = cond;
            this.whileSpan = whileSpan;
        }
        DoStatement.prototype.nodeType = function () {
            return 86 /* DoStatement */;
        };

        DoStatement.prototype.isStatement = function () {
            return true;
        };

        DoStatement.prototype.emitWorker = function (emitter) {
            emitter.writeToOutput("do");
            emitter.emitBlockOrStatement(this.body);
            emitter.recordSourceMappingStart(this.whileSpan);
            emitter.writeToOutput(" while");
            emitter.recordSourceMappingEnd(this.whileSpan);
            emitter.writeToOutput('(');
            this.cond.emit(emitter);
            emitter.writeToOutput(")");
            emitter.writeToOutput(";");
        };

        DoStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.body, ast.body, includingPosition) && structuralEquals(this.cond, ast.cond, includingPosition);
        };
        return DoStatement;
    })(AST);
    TypeScript.DoStatement = DoStatement;

    var IfStatement = (function (_super) {
        __extends(IfStatement, _super);
        function IfStatement(cond, thenBod, elseBod) {
            _super.call(this);
            this.cond = cond;
            this.thenBod = thenBod;
            this.elseBod = elseBod;
        }
        IfStatement.prototype.nodeType = function () {
            return 92 /* IfStatement */;
        };

        IfStatement.prototype.isStatement = function () {
            return true;
        };

        IfStatement.prototype.emitWorker = function (emitter) {
            emitter.writeToOutput("if (");
            this.cond.emit(emitter);
            emitter.writeToOutput(")");

            emitter.emitBlockOrStatement(this.thenBod);

            if (this.elseBod) {
                if (this.thenBod.nodeType() !== 82 /* Block */) {
                    emitter.writeLineToOutput("");
                } else {
                    emitter.writeToOutput(" ");
                }

                if (this.elseBod.nodeType() === 92 /* IfStatement */) {
                    emitter.writeToOutput("else ");
                    this.elseBod.emit(emitter);
                } else {
                    emitter.writeToOutput("else");
                    emitter.emitBlockOrStatement(this.elseBod);
                }
            }
        };

        IfStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.cond, ast.cond, includingPosition) && structuralEquals(this.thenBod, ast.thenBod, includingPosition) && structuralEquals(this.elseBod, ast.elseBod, includingPosition);
        };
        return IfStatement;
    })(AST);
    TypeScript.IfStatement = IfStatement;

    var ReturnStatement = (function (_super) {
        __extends(ReturnStatement, _super);
        function ReturnStatement(returnExpression) {
            _super.call(this);
            this.returnExpression = returnExpression;
        }
        ReturnStatement.prototype.nodeType = function () {
            return 94 /* ReturnStatement */;
        };

        ReturnStatement.prototype.isStatement = function () {
            return true;
        };

        ReturnStatement.prototype.emitWorker = function (emitter) {
            if (this.returnExpression) {
                emitter.writeToOutput("return ");
                this.returnExpression.emit(emitter);
                emitter.writeToOutput(";");
            } else {
                emitter.writeToOutput("return;");
            }
        };

        ReturnStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.returnExpression, ast.returnExpression, includingPosition);
        };
        return ReturnStatement;
    })(AST);
    TypeScript.ReturnStatement = ReturnStatement;

    var ForInStatement = (function (_super) {
        __extends(ForInStatement, _super);
        function ForInStatement(lval, obj, body) {
            _super.call(this);
            this.lval = lval;
            this.obj = obj;
            this.body = body;
        }
        ForInStatement.prototype.nodeType = function () {
            return 90 /* ForInStatement */;
        };

        ForInStatement.prototype.isStatement = function () {
            return true;
        };

        ForInStatement.prototype.emitWorker = function (emitter) {
            emitter.writeToOutput("for (");
            this.lval.emit(emitter);
            emitter.writeToOutput(" in ");
            this.obj.emit(emitter);
            emitter.writeToOutput(")");
            emitter.emitBlockOrStatement(this.body);
        };

        ForInStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.lval, ast.lval, includingPosition) && structuralEquals(this.obj, ast.obj, includingPosition) && structuralEquals(this.body, ast.body, includingPosition);
        };
        return ForInStatement;
    })(AST);
    TypeScript.ForInStatement = ForInStatement;

    var ForStatement = (function (_super) {
        __extends(ForStatement, _super);
        function ForStatement(init, cond, incr, body) {
            _super.call(this);
            this.init = init;
            this.cond = cond;
            this.incr = incr;
            this.body = body;
        }
        ForStatement.prototype.nodeType = function () {
            return 91 /* ForStatement */;
        };

        ForStatement.prototype.isStatement = function () {
            return true;
        };

        ForStatement.prototype.emitWorker = function (emitter) {
            emitter.writeToOutput("for (");
            if (this.init) {
                if (this.init.nodeType() !== 1 /* List */) {
                    this.init.emit(emitter);
                } else {
                    emitter.setInVarBlock((this.init).members.length);
                    emitter.emitCommaSeparatedList(this.init);
                }
            }

            emitter.writeToOutput("; ");
            emitter.emitJavascript(this.cond, false);
            emitter.writeToOutput(";");
            if (this.incr) {
                emitter.writeToOutput(" ");
                emitter.emitJavascript(this.incr, false);
            }
            emitter.writeToOutput(")");
            emitter.emitBlockOrStatement(this.body);
        };

        ForStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.init, ast.init, includingPosition) && structuralEquals(this.cond, ast.cond, includingPosition) && structuralEquals(this.incr, ast.incr, includingPosition) && structuralEquals(this.body, ast.body, includingPosition);
        };
        return ForStatement;
    })(AST);
    TypeScript.ForStatement = ForStatement;

    var WithStatement = (function (_super) {
        __extends(WithStatement, _super);
        function WithStatement(expr, body) {
            _super.call(this);
            this.expr = expr;
            this.body = body;
        }
        WithStatement.prototype.nodeType = function () {
            return 100 /* WithStatement */;
        };

        WithStatement.prototype.isStatement = function () {
            return true;
        };

        WithStatement.prototype.emitWorker = function (emitter) {
            emitter.writeToOutput("with (");
            if (this.expr) {
                this.expr.emit(emitter);
            }

            emitter.writeToOutput(")");
            emitter.emitBlockOrStatement(this.body);
        };

        WithStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.expr, ast.expr, includingPosition) && structuralEquals(this.body, ast.body, includingPosition);
        };
        return WithStatement;
    })(AST);
    TypeScript.WithStatement = WithStatement;

    var SwitchStatement = (function (_super) {
        __extends(SwitchStatement, _super);
        function SwitchStatement(val, caseList, defaultCase, statement) {
            _super.call(this);
            this.val = val;
            this.caseList = caseList;
            this.defaultCase = defaultCase;
            this.statement = statement;
        }
        SwitchStatement.prototype.nodeType = function () {
            return 95 /* SwitchStatement */;
        };

        SwitchStatement.prototype.isStatement = function () {
            return true;
        };

        SwitchStatement.prototype.emitWorker = function (emitter) {
            emitter.recordSourceMappingStart(this.statement);
            emitter.writeToOutput("switch (");
            this.val.emit(emitter);
            emitter.writeToOutput(")");
            emitter.recordSourceMappingEnd(this.statement);
            emitter.writeLineToOutput(" {");
            emitter.indenter.increaseIndent();

            var lastEmittedNode = null;
            for (var i = 0, n = this.caseList.members.length; i < n; i++) {
                var caseExpr = this.caseList.members[i];

                emitter.emitSpaceBetweenConstructs(lastEmittedNode, caseExpr);
                emitter.emitJavascript(caseExpr, true);

                lastEmittedNode = caseExpr;
            }
            emitter.indenter.decreaseIndent();
            emitter.emitIndent();
            emitter.writeToOutput("}");
        };

        SwitchStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.caseList, ast.caseList, includingPosition) && structuralEquals(this.val, ast.val, includingPosition);
        };
        return SwitchStatement;
    })(AST);
    TypeScript.SwitchStatement = SwitchStatement;

    var CaseClause = (function (_super) {
        __extends(CaseClause, _super);
        function CaseClause(expr, body) {
            _super.call(this);
            this.expr = expr;
            this.body = body;
        }
        CaseClause.prototype.nodeType = function () {
            return 101 /* CaseClause */;
        };

        CaseClause.prototype.emitWorker = function (emitter) {
            if (this.expr) {
                emitter.writeToOutput("case ");
                this.expr.emit(emitter);
            } else {
                emitter.writeToOutput("default");
            }
            emitter.writeToOutput(":");

            if (this.body.members.length === 1 && this.body.members[0].nodeType() === 82 /* Block */) {
                this.body.members[0].emit(emitter);
                emitter.writeLineToOutput("");
            } else {
                emitter.writeLineToOutput("");
                emitter.indenter.increaseIndent();
                this.body.emit(emitter);
                emitter.indenter.decreaseIndent();
            }
        };

        CaseClause.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.expr, ast.expr, includingPosition) && structuralEquals(this.body, ast.body, includingPosition);
        };
        return CaseClause;
    })(AST);
    TypeScript.CaseClause = CaseClause;

    var TypeParameter = (function (_super) {
        __extends(TypeParameter, _super);
        function TypeParameter(name, constraint) {
            _super.call(this);
            this.name = name;
            this.constraint = constraint;
        }
        TypeParameter.prototype.nodeType = function () {
            return 9 /* TypeParameter */;
        };

        TypeParameter.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.name, ast.name, includingPosition) && structuralEquals(this.constraint, ast.constraint, includingPosition);
        };
        return TypeParameter;
    })(AST);
    TypeScript.TypeParameter = TypeParameter;

    var GenericType = (function (_super) {
        __extends(GenericType, _super);
        function GenericType(name, typeArguments) {
            _super.call(this);
            this.name = name;
            this.typeArguments = typeArguments;
        }
        GenericType.prototype.nodeType = function () {
            return 10 /* GenericType */;
        };

        GenericType.prototype.emit = function (emitter) {
            this.name.emit(emitter);
        };

        GenericType.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.name, ast.name, includingPosition) && structuralEquals(this.typeArguments, ast.typeArguments, includingPosition);
        };
        return GenericType;
    })(AST);
    TypeScript.GenericType = GenericType;

    var TypeQuery = (function (_super) {
        __extends(TypeQuery, _super);
        function TypeQuery(name) {
            _super.call(this);
            this.name = name;
        }
        TypeQuery.prototype.nodeType = function () {
            return 12 /* TypeQuery */;
        };

        TypeQuery.prototype.emit = function (emitter) {
            TypeScript.Emitter.throwEmitterError(new Error(TypeScript.getLocalizedText(TypeScript.DiagnosticCode.Should_not_emit_a_type_query, null)));
        };

        TypeQuery.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.name, ast.name, includingPosition);
        };
        return TypeQuery;
    })(AST);
    TypeScript.TypeQuery = TypeQuery;

    var TypeReference = (function (_super) {
        __extends(TypeReference, _super);
        function TypeReference(term, arrayCount) {
            _super.call(this);
            this.term = term;
            this.arrayCount = arrayCount;
            this.minChar = term.minChar;
            this.limChar = term.limChar;
        }
        TypeReference.prototype.nodeType = function () {
            return 11 /* TypeRef */;
        };

        TypeReference.prototype.emit = function (emitter) {
            TypeScript.Emitter.throwEmitterError(new Error(TypeScript.getLocalizedText(TypeScript.DiagnosticCode.Should_not_emit_a_type_reference, null)));
        };

        TypeReference.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.term, ast.term, includingPosition) && this.arrayCount === ast.arrayCount;
        };
        return TypeReference;
    })(AST);
    TypeScript.TypeReference = TypeReference;

    var TryStatement = (function (_super) {
        __extends(TryStatement, _super);
        function TryStatement(tryBody, catchClause, finallyBody) {
            _super.call(this);
            this.tryBody = tryBody;
            this.catchClause = catchClause;
            this.finallyBody = finallyBody;
        }
        TryStatement.prototype.nodeType = function () {
            return 97 /* TryStatement */;
        };

        TryStatement.prototype.isStatement = function () {
            return true;
        };

        TryStatement.prototype.emitWorker = function (emitter) {
            emitter.writeToOutput("try ");
            this.tryBody.emit(emitter);
            emitter.emitJavascript(this.catchClause, false);

            if (this.finallyBody) {
                emitter.writeToOutput(" finally");
                this.finallyBody.emit(emitter);
            }
        };

        TryStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.tryBody, ast.tryBody, includingPosition) && structuralEquals(this.catchClause, ast.catchClause, includingPosition) && structuralEquals(this.finallyBody, ast.finallyBody, includingPosition);
        };
        return TryStatement;
    })(AST);
    TypeScript.TryStatement = TryStatement;

    var CatchClause = (function (_super) {
        __extends(CatchClause, _super);
        function CatchClause(param, body) {
            _super.call(this);
            this.param = param;
            this.body = body;
        }
        CatchClause.prototype.nodeType = function () {
            return 102 /* CatchClause */;
        };

        CatchClause.prototype.emitWorker = function (emitter) {
            emitter.writeToOutput(" ");
            emitter.writeToOutput("catch (");
            this.param.id.emit(emitter);
            emitter.writeToOutput(")");
            this.body.emit(emitter);
        };

        CatchClause.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && structuralEquals(this.param, ast.param, includingPosition) && structuralEquals(this.body, ast.body, includingPosition);
        };
        return CatchClause;
    })(AST);
    TypeScript.CatchClause = CatchClause;

    var DebuggerStatement = (function (_super) {
        __extends(DebuggerStatement, _super);
        function DebuggerStatement() {
            _super.apply(this, arguments);
        }
        DebuggerStatement.prototype.nodeType = function () {
            return 85 /* DebuggerStatement */;
        };

        DebuggerStatement.prototype.isStatement = function () {
            return true;
        };

        DebuggerStatement.prototype.emitWorker = function (emitter) {
            emitter.writeToOutput("debugger;");
        };
        return DebuggerStatement;
    })(AST);
    TypeScript.DebuggerStatement = DebuggerStatement;

    var OmittedExpression = (function (_super) {
        __extends(OmittedExpression, _super);
        function OmittedExpression() {
            _super.apply(this, arguments);
        }
        OmittedExpression.prototype.nodeType = function () {
            return 24 /* OmittedExpression */;
        };

        OmittedExpression.prototype.emitWorker = function (emitter) {
        };

        OmittedExpression.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition);
        };
        return OmittedExpression;
    })(AST);
    TypeScript.OmittedExpression = OmittedExpression;

    var EmptyStatement = (function (_super) {
        __extends(EmptyStatement, _super);
        function EmptyStatement() {
            _super.apply(this, arguments);
        }
        EmptyStatement.prototype.nodeType = function () {
            return 87 /* EmptyStatement */;
        };

        EmptyStatement.prototype.isStatement = function () {
            return true;
        };

        EmptyStatement.prototype.emitWorker = function (emitter) {
            emitter.writeToOutput(";");
        };

        EmptyStatement.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition);
        };
        return EmptyStatement;
    })(AST);
    TypeScript.EmptyStatement = EmptyStatement;

    var Comment = (function (_super) {
        __extends(Comment, _super);
        function Comment(content, isBlockComment, endsLine) {
            _super.call(this);
            this.content = content;
            this.isBlockComment = isBlockComment;
            this.endsLine = endsLine;
            this.text = null;
            this.docCommentText = null;
        }
        Comment.prototype.nodeType = function () {
            return 103 /* Comment */;
        };

        Comment.prototype.structuralEquals = function (ast, includingPosition) {
            return _super.prototype.structuralEquals.call(this, ast, includingPosition) && this.content === ast.content && this.isBlockComment === ast.isBlockComment && this.endsLine === ast.endsLine;
        };

        Comment.prototype.getText = function () {
            if (this.text === null) {
                if (this.isBlockComment) {
                    this.text = this.content.split("\n");
                    for (var i = 0; i < this.text.length; i++) {
                        this.text[i] = this.text[i].replace(/^\s+|\s+$/g, '');
                    }
                } else {
                    this.text = [(this.content.replace(/^\s+|\s+$/g, ''))];
                }
            }

            return this.text;
        };

        Comment.prototype.isDocComment = function () {
            if (this.isBlockComment) {
                return this.content.charAt(2) === "*" && this.content.charAt(3) !== "/";
            }

            return false;
        };

        Comment.prototype.getDocCommentTextValue = function () {
            if (this.docCommentText === null) {
                this.docCommentText = Comment.cleanJSDocComment(this.content);
            }

            return this.docCommentText;
        };

        Comment.consumeLeadingSpace = function (line, startIndex, maxSpacesToRemove) {
            var endIndex = line.length;
            if (maxSpacesToRemove !== undefined) {
                endIndex = TypeScript.min(startIndex + maxSpacesToRemove, endIndex);
            }

            for (; startIndex < endIndex; startIndex++) {
                var charCode = line.charCodeAt(startIndex);
                if (charCode !== 32 /* space */ && charCode !== 9 /* tab */) {
                    return startIndex;
                }
            }

            if (endIndex !== line.length) {
                return endIndex;
            }

            return -1;
        };

        Comment.isSpaceChar = function (line, index) {
            var length = line.length;
            if (index < length) {
                var charCode = line.charCodeAt(index);

                return charCode === 32 /* space */ || charCode === 9 /* tab */;
            }

            return index === length;
        };

        Comment.cleanDocCommentLine = function (line, jsDocStyleComment, jsDocLineSpaceToRemove) {
            var nonSpaceIndex = Comment.consumeLeadingSpace(line, 0);
            if (nonSpaceIndex !== -1) {
                var jsDocSpacesRemoved = nonSpaceIndex;
                if (jsDocStyleComment && line.charAt(nonSpaceIndex) === '*') {
                    var startIndex = nonSpaceIndex + 1;
                    nonSpaceIndex = Comment.consumeLeadingSpace(line, startIndex, jsDocLineSpaceToRemove);

                    if (nonSpaceIndex !== -1) {
                        jsDocSpacesRemoved = nonSpaceIndex - startIndex;
                    } else {
                        return null;
                    }
                }

                return {
                    minChar: nonSpaceIndex,
                    limChar: line.charAt(line.length - 1) === "\r" ? line.length - 1 : line.length,
                    jsDocSpacesRemoved: jsDocSpacesRemoved
                };
            }

            return null;
        };

        Comment.cleanJSDocComment = function (content, spacesToRemove) {
            var docCommentLines = new Array();
            content = content.replace("/**", "");
            if (content.length >= 2 && content.charAt(content.length - 1) === "/" && content.charAt(content.length - 2) === "*") {
                content = content.substring(0, content.length - 2);
            }
            var lines = content.split("\n");
            var inParamTag = false;
            for (var l = 0; l < lines.length; l++) {
                var line = lines[l];
                var cleanLinePos = Comment.cleanDocCommentLine(line, true, spacesToRemove);
                if (!cleanLinePos) {
                    continue;
                }

                var docCommentText = "";
                var prevPos = cleanLinePos.minChar;
                for (var i = line.indexOf("@", cleanLinePos.minChar); 0 <= i && i < cleanLinePos.limChar; i = line.indexOf("@", i + 1)) {
                    var wasInParamtag = inParamTag;

                    if (line.indexOf("param", i + 1) === i + 1 && Comment.isSpaceChar(line, i + 6)) {
                        if (!wasInParamtag) {
                            docCommentText += line.substring(prevPos, i);
                        }

                        prevPos = i;
                        inParamTag = true;
                    } else if (wasInParamtag) {
                        prevPos = i;
                        inParamTag = false;
                    }
                }

                if (!inParamTag) {
                    docCommentText += line.substring(prevPos, cleanLinePos.limChar);
                }

                var newCleanPos = Comment.cleanDocCommentLine(docCommentText, false);
                if (newCleanPos) {
                    if (spacesToRemove === undefined) {
                        spacesToRemove = cleanLinePos.jsDocSpacesRemoved;
                    }
                    docCommentLines.push(docCommentText);
                }
            }

            return docCommentLines.join("\n");
        };

        Comment.getDocCommentText = function (comments) {
            var docCommentText = new Array();
            for (var c = 0; c < comments.length; c++) {
                var commentText = comments[c].getDocCommentTextValue();
                if (commentText !== "") {
                    docCommentText.push(commentText);
                }
            }
            return docCommentText.join("\n");
        };

        Comment.getParameterDocCommentText = function (param, fncDocComments) {
            if (fncDocComments.length === 0 || !fncDocComments[0].isBlockComment) {
                return "";
            }

            for (var i = 0; i < fncDocComments.length; i++) {
                var commentContents = fncDocComments[i].content;
                for (var j = commentContents.indexOf("@param", 0); 0 <= j; j = commentContents.indexOf("@param", j)) {
                    j += 6;
                    if (!Comment.isSpaceChar(commentContents, j)) {
                        continue;
                    }

                    j = Comment.consumeLeadingSpace(commentContents, j);
                    if (j === -1) {
                        break;
                    }

                    if (commentContents.charCodeAt(j) === 123 /* openBrace */) {
                        j++;

                        var charCode = 0;
                        for (var curlies = 1; j < commentContents.length; j++) {
                            charCode = commentContents.charCodeAt(j);

                            if (charCode === 123 /* openBrace */) {
                                curlies++;
                                continue;
                            }

                            if (charCode === 125 /* closeBrace */) {
                                curlies--;
                                if (curlies === 0) {
                                    break;
                                } else {
                                    continue;
                                }
                            }

                            if (charCode === 64 /* at */) {
                                break;
                            }
                        }

                        if (j === commentContents.length) {
                            break;
                        }

                        if (charCode === 64 /* at */) {
                            continue;
                        }

                        j = Comment.consumeLeadingSpace(commentContents, j + 1);
                        if (j === -1) {
                            break;
                        }
                    }

                    if (param !== commentContents.substr(j, param.length) || !Comment.isSpaceChar(commentContents, j + param.length)) {
                        continue;
                    }

                    j = Comment.consumeLeadingSpace(commentContents, j + param.length);
                    if (j === -1) {
                        return "";
                    }

                    var endOfParam = commentContents.indexOf("@", j);
                    var paramHelpString = commentContents.substring(j, endOfParam < 0 ? commentContents.length : endOfParam);

                    var paramSpacesToRemove = undefined;
                    var paramLineIndex = commentContents.substring(0, j).lastIndexOf("\n") + 1;
                    if (paramLineIndex !== 0) {
                        if (paramLineIndex < j && commentContents.charAt(paramLineIndex + 1) === "\r") {
                            paramLineIndex++;
                        }
                    }
                    var startSpaceRemovalIndex = Comment.consumeLeadingSpace(commentContents, paramLineIndex);
                    if (startSpaceRemovalIndex !== j && commentContents.charAt(startSpaceRemovalIndex) === "*") {
                        paramSpacesToRemove = j - startSpaceRemovalIndex - 1;
                    }

                    return Comment.cleanJSDocComment(paramHelpString, paramSpacesToRemove);
                }
            }

            return "";
        };
        return Comment;
    })(AST);
    TypeScript.Comment = Comment;
})(TypeScript || (TypeScript = {}));
