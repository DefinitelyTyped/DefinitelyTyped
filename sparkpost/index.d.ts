// Type definitions for sparkpost v1.3
// Project: https://github.com/SparkPost/node-sparkpost
// Definitions by: Joshua DeVinney <https://github.com/geoffreak>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped

/// <reference types="request"/>
/// <reference types="node"/>

import * as Request from "request";
import * as Http from "http";

declare class SparkPost {
    /** Specifying an inbound domain enables you to customize the address to which inbound messages are sent. */
    inboundDomains: {
        /**
         * List all your inbound domains.
         * @param callback The request callback with Domain results array
         */
        all(callback: SparkPost.ResultsCallback<SparkPost.Domain[]>): void;
        /**
         * Retrieve an inbound domain by specifying its domain name in the URI path.
         * @param domain Domain name
         * @param callback The request callback with Domain results
         */
        find(domain: string, callback: SparkPost.ResultsCallback<SparkPost.Domain>): void;
        /**
         * Create an inbound domain by providing an inbound domains object as the POST request body.
         * @param domain Domain name
         * @param callback The request callback
         */
        create(domain: string, callback: SparkPost.Callback<void>): void;
        /**
         * Delete an inbound domain by specifying its domain name in the URI path.
         * @param domain Domain name
         * @param callback The request callback
         */
        delete(domain: string, callback: SparkPost.Callback<void>): void;
    };
    /** The Message Events API provides the means to search the raw events generated by SparkPost. */
    messageEvents: {
        /**
         * Retrieves list of message events according to given params
         * @param parameters Query parameters
         * @param callback The request callback with MessageEvent results array
         */
        search(parameters: SparkPost.MessageEventParameters, callback: SparkPost.ResultsCallback<SparkPost.MessageEvent[]>): void;
    };
    /** A recipient list is a collection of recipients that can be used in a transmission. */
    recipientLists: {
        /**
         * List a summary of all recipient lists. The recipients for each list are not included in the results.
         * To retrieve recipient details, use the RETRIEVE API for a specified recipient list.
         * @param callback The request callback with RecipientList results array
         */
        all(callback: SparkPost.ResultsCallback<SparkPost.RecipientList[]>): void;
        /**
         * Retrieve details about a specified recipient list by specifying its id in the URI path.
         * To retrieve the recipients contained in a list, the show_recipients parameter must be set to true.
         * @param options The find options
         * @param callback The request callback with RecipientList results
         */
        find(options: { id: string, show_recipients?: false }, callback: SparkPost.Callback<SparkPost.RecipientList>): void;
        /**
         * Retrieve details about a specified recipient list by specifying its id in the URI path.
         * To retrieve the recipients contained in a list, the show_recipients parameter must be set to true.
         * @param options The find options
         * @param callback The request callback with RecipientList results (with recipients)
         */
        find(options: { id: string, show_recipients: true }, callback: SparkPost.Callback<SparkPost.RecipientListWithRecipients>): void;
        /**
         * Create a recipient list by providing a recipient list object as the POST request body.
         * At a minimum, the “recipients” array is required, which must contain a valid “address”.
         * If the recipient list “id” is not provided in the POST request body, one will be generated and returned in the results body.
         * Use the num_rcpt_errors parameter to limit the number of recipient errors returned.
         * @param options The create options
         * @param callback The request callback with metadata results
         */
        create(options: SparkPost.CreateRecipientList, callback: SparkPost.ResultsCallback<SparkPost.RecipientListMetadata>): void;
        /**
         * Update an existing recipient list by specifying its ID in the URI path and use a recipient list object as the PUT request body.
         * Use the num_rcpt_errors parameter to limit the number of recipient errors returned.
         * @param options The update options
         * @param callback The request callback with metadata results
         */
        update(options: SparkPost.UpdateRecipientList, callback: SparkPost.ResultsCallback<SparkPost.RecipientListMetadata>): void;
        /**
         * Permanently delete the specified recipient list.
         * @param id The list id
         * @param callback The request callback
         */
        delete(id: string, callback: SparkPost.Callback<void>): void;
    };
    /** Relay Webhooks are a way to instruct SparkPost to accept inbound email on your behalf and forward it to you over HTTP for your own consumption. */
    relayWebhooks: {
        /**
         * List all your relay webhooks.
         * @param callback The request callback with RelayWebhook results array
         */
        all(callback: SparkPost.ResultsCallback<SparkPost.RelayWebhook[]>): void;
        /**
         * Delete a relay webhook by specifying the webhook ID in the URI path.
         * @param relayWebhookId The webhook id
         * @param callback The request callback with RelayWebhook results
         */
        find(relayWebhookId: string, callback: SparkPost.ResultsCallback<SparkPost.RelayWebhook>): void;
        /**
         * Create a relay webhook by providing a relay webhooks object as the POST request body.
         * @param options The create options
         * @param callback The request callback with webhook id results
         */
        create(options: SparkPost.RelayWebhook, callback: SparkPost.ResultsCallback<{ id: string }>): void;
        /**
         * Update a relay webhook by specifying the webhook ID in the URI path.
         * @param options The update options
         * @param callback The request callback with webhook id results
         */
        update(options: SparkPost.UpdateRelayWebhook & { relayWebhookId: string }, callback: SparkPost.ResultsCallback<{ id: string }>): void;
        /**
         * Delete a relay webhook by specifying the webhook ID in the URI path.
         * @param relayWebhookId The webhook id
         * @param callback The request callback
         */
        delete(relayWebhookId: string, callback: SparkPost.Callback<void>): void;
    };
    sendingDomains: {
        /**
         * List an overview of all sending domains in the system.
         * @param callback The request callback with SendingDomain results array
         */
        all(callback: SparkPost.ResultsCallback<SparkPost.SendingDomain[]>): void;
        /**
         * Retrieve a sending domain by specifying its domain name in the URI path. The response includes details about its DKIM key configuration.
         * @param domain The domain
         * @param callback The request callback with SendingDomain results
         */
        find(domain: string, callback: SparkPost.ResultsCallback<SparkPost.SendingDomain>): void;
        /**
         * Create a sending domain by providing a sending domain object as the POST request body.
         * @param options The create options
         * @param callback The request callback with basic info results
         */
        create(options: SparkPost.CreateSendingDomain, callback: SparkPost.ResultsCallback<{ message: string, domain: string }>): void;
        /**
         * Update the attributes of an existing sending domain by specifying its domain name in the URI path and use a sending domain object as the PUT request body.
         * @param options The update options
         * @param callback The request callback with basic info results
         */
        update(options: SparkPost.UpdateSendingDomain, callback: SparkPost.ResultsCallback<{ message: string, domain: string }>): void;
        /**
         * Delete an existing sending domain.
         * @param domain The domain
         * @param callback The request callback
         */
        delete(domain: string, callback: SparkPost.Callback<void>): void;
        /**
         * Verify a Sending Domain
         * @param options The verify options
         * @param callback The request callback with verify results
         */
        verify(options: SparkPost.VerifyOptions, callback: SparkPost.ResultsCallback<SparkPost.VerifyResults>): void;
    };
    subaccounts: {
        /**
         * Endpoint for retrieving a list of your subaccounts.
         * This endpoint only returns information about the subaccounts themselves, not the data associated with the subaccount.
         * @param callback The request callback with subaccount information results array
         */
        all(callback: SparkPost.ResultsCallback<SparkPost.SubaccountInformation[]>): void;
        /**
         * 
         * @param subaccountId The webhook id
         * @param callback The request callback with subaccount information results
         */
        find(subaccountId: string | number, callback: SparkPost.ResultsCallback<SparkPost.SubaccountInformation>): void;
        /**
         * Provisions a new subaccount and an initial subaccount API key.
         * @param options The create options
         * @param callback The request callback with basic subaccount information results
         */
        create(options: SparkPost.CreateSubaccount, callback: SparkPost.ResultsCallback<SparkPost.CreateSubaccountResponse>): void;
        /**
         * Update an existing subaccount’s information.
         * @param options The create options
         * @param callback The request callback with webhook id results
         */
        update(options: SparkPost.UpdateSubaccount, callback: SparkPost.ResultsCallback<{ message: string }>): void;
    };
    suppressionList: {
        /**
         * Perform a filtered search for entries in your suppression list.
         * @param parameters Object of search parameters
         * @param callback The request callback with RelayWebhook results
         */
        search(parameters: SparkPost.SupressionSearch, callback: SparkPost.ResultsCallback<SparkPost.SupressionListEntry[]>): void;
        /**
         * Retrieve the suppression status for a specific recipient by specifying the recipient’s email address in the URI path.
         * @param email Email address to check
         * @param callback The request callback with webhook id results
         */
        checkStatus(email: string, callback: SparkPost.ResultsCallback<SparkPost.SupressionListEntry[]>): void;
        /**
         * Delete a recipient from the list by specifying the recipient’s email address in the URI path.
         * @param email Email address to check
         * @param callback The request callback
         */
        removeStatus(email: string, callback: SparkPost.Callback<void>): void;
        /**
         * Bulk insert or update entries in the customer-specific exclusion list.
         * @param parameters The suppression entry list
         * @param callback The request callback
         */
        upsert(parameters: SparkPost.CreateSupressionListEntry | SparkPost.CreateSupressionListEntry[], callback: SparkPost.ResultsCallback<{ message: string }>): void;
    };
    templates: {
        /**
         * List a summary of all templates.
         * @param callback The request callback with TemplateMeta results array
         */
        all(callback: SparkPost.ResultsCallback<SparkPost.TemplateMeta[]>): void;
        /**
         * Retrieve details about a specified template by its id
         * @param options The id and draft status information
         * @param callback The request callback with Template results
         */
        find(options: { id: string, draft?: boolean }, callback: SparkPost.ResultsCallback<SparkPost.Template>): void;
        /**
         * Create a new template
         * @param options The create options
         * @param callback The request callback with template id results
         */
        create(options: { template: SparkPost.CreateTemplate }, callback: SparkPost.ResultsCallback<{ id: string }>): void;
        /**
         * Update an existing template
         * @param options The create options
         * @param callback The request callback with template id results
         */
        update(options: {
            id: string,
            template: SparkPost.UpdateTemplate,
            update_published?: boolean;
        }, callback: SparkPost.ResultsCallback<{ id: string }>): void;
        /**
         * Delete an existing template
         * @param id The template id
         * @param callback The request callback
         */
        delete(id: string, callback: SparkPost.Callback<void>): void;
        /**
         * Preview the most recent version of an existing template by id
         * @param options The preview options
         * @param callback The request callback with webhook id results
         */
        preview(options: { id: string, data: any, draft?: boolean }, callback: SparkPost.ResultsCallback<SparkPost.TemplateContent>): void;
    };
    transmissions: {
        /**
         * List an overview of all transmissions in the account
         * @param callback The request callback with Transmission results array
         */
        all(callback: SparkPost.ResultsCallback<SparkPost.TransmissionSummary[]>): void;
        /**
         * List an overview of all transmissions in the account, with added filters
         * @param options The search options { campaign_id?, template_id? }
         * @param callback The request callback with Transmission results array
         */
        all(options: { campaign_id?: string, template_id?: string }, callback: SparkPost.ResultsCallback<SparkPost.TransmissionSummary[]>): void;
        /**
         * Retrieve the details about a transmission by its ID
         * @param transmissionID The transmission id
         * @param callback The request callback with Transmission results
         */
        find(transmissionID: string, callback: SparkPost.ResultsCallback<SparkPost.Transmission>): void;
        /**
         * Sends a message by creating a new transmission
         * @param options The create options
         * @param callback The request callback with metadata and id results
         */
        send(options: { transmissionBody: SparkPost.CreateTransmission, num_rcpt_errors?: number }, callback: SparkPost.ResultsCallback<{
            total_rejected_recipients: number;
            total_accepted_recipients: number;
            id: string;
        }>): void;
    };
    webhooks: {
        /**
         * List currently existing webhooks.
         * @param callback The request callback with RelayWebhook results array
         */
        all(callback: SparkPost.ResultsCallback<Array<SparkPost.WebhookLinks & SparkPost.Webhook>>): void;
        /**
         * List currently existing webhooks.
         * @param options Object containing optional timezone
         * @param callback The request callback with RelayWebhook results array
         */
        all(options: { timezone?: string }, callback: SparkPost.ResultsCallback<Array<SparkPost.WebhookLinks & SparkPost.Webhook>>): void;
        /**
         * Retrieve details about a specified webhook by its id
         * @param options Object containing id and optional timezone
         * @param callback The request callback with RelayWebhook results
         */
        describe(options: { id: string, timezone?: string }, callback: SparkPost.ResultsCallback<SparkPost.WebhookLinks & SparkPost.Webhook>): void;
        /**
         * Create a new webhook
         * @param options The create options
         * @param callback The request callback with webhook id results
         */
        create(options: SparkPost.Webhook, callback: SparkPost.ResultsCallback<SparkPost.WebhookLinks & { id: string }>): void;
        /**
         * Update an existing webhook
         * @param options The update options
         * @param callback The request callback with webhook id results
         */
        update(options: SparkPost.UpdateWebhook, callback: SparkPost.ResultsCallback<SparkPost.WebhookLinks & { id: string }>): void;
        /**
         * Delete an existing webhook
         * @param id The webhook id
         * @param callback The request callback
         */
        delete(id: string, callback: SparkPost.Callback<void>): void;
        /**
         * Sends an example message event batch from the Webhook API to the target URL
         * @param options The webhook id and message
         * @param callback The request callback with validation results
         */
        validate(options: { id: string, message: any }, callback: SparkPost.ResultsCallback<{
            msg: string;
            response: {
                status: number;
                headers: any;
                body: string;
            }
        }>): void;
        /**
         * Sends an example message event batch from the Webhook API to the target URL
         * @param options The webhook id and optional limit
         * @param callback The request callback with status results
         */
        getBatchStatus(options: { id: string, limit?: number }, callback: SparkPost.ResultsCallback<{
            batch_id: string;
            ts: string;
            attempts: number;
            response_code: number;
        }[]>): void;
        /**
         * Lists descriptions of the events, event types, and event fields that could be included in a Webhooks post to your target URL.
         * @param callback The request callback containing documentation results 
         */
        getDocumentation(callback: SparkPost.ResultsCallback<any>): void;
        /**
         * List an example of the event data that will be posted by a Webhook for the specified events.
         * @param callback The request callback containing examples
         */
        getSamples(callback: SparkPost.Callback<any>): void;
        /**
         * List an example of the event data that will be posted by a Webhook for the specified events.
         * @param options The optional event name
         * @param callback The request callback containing examples
         */
        getSamples(options: { events?: string }, callback: SparkPost.Callback<any>): void;
    };

    /**
     * The official Node.js binding for your favorite SparkPost APIs!
     * @param apiKey A passed in apiKey will take precedence over an environment variable
     * @param options Additional options
     */
    constructor(apiKey?: string, options?: SparkPost.ConstructorOptions);

    request(options: Request.Options, callback: SparkPost.Callback<any>): void;
    get(options: Request.Options, callback: SparkPost.Callback<any>): void;
    post(options: Request.Options, callback: SparkPost.Callback<any>): void;
    put(options: Request.Options, callback: SparkPost.Callback<any>): void;
    delete(options: Request.Options, callback: SparkPost.Callback<any>): void;
}

declare namespace SparkPost {

    export interface ErrorWithDescription {
        message: string;
        code: string;
        description: string;
    }
    export interface ErrorWithParam {
        message: string;
        param: string;
        value: string | null;
    }
    export interface SparkPostError extends Error {
        name: "SparkPostError";
        errors: ErrorWithDescription[] | ErrorWithParam[];
        statusCode: number;
    }

    export interface ConstructorOptions {
        origin?: string;
        endpoint?: string;
        apiVersion?: string;
        headers?: any;
    }

    export interface Response<T> extends Http.IncomingMessage {
        body: T;
    }
    export interface Callback<T> {
        (err: Error | SparkPostError | null, res: Response<T>): void;
    }
    export type ResultsCallback<T> = Callback<{ results: T }>;

    export interface Domain {
        domain: string;
    }

    export interface MessageEvent {
        /** Type of event this record describes */
        type: string;
        /** Classification code for a given message (see [Bounce Classification Codes](https://support.sparkpost.com/customer/portal/articles/1929896)) */
        bounce_class: string;
        /** Campaign of which this message was a part */
        campaign_id: string;
        /** SparkPost-customer identifier through which this message was sent */
        customer_id: string;
        /** Protocol by which SparkPost delivered this message */
        delv_method: string;
        /** Token of the device / application targeted by this PUSH notification message. Applies only when delv_method is gcm or apn. */
        device_token: string;
        /** Error code by which the remote server described a failed delivery attempt */
        error_code: string;
        /** IP address of the host to which SparkPost delivered this message; in engagement events, the IP address of the host where the HTTP request originated */
        ip_address: string;
        /** SparkPost-cluster-wide unique identifier for this message */
        message_id: string;
        /** Sender address used on this message"s SMTP envelope */
        msg_from: string;
        /** Message"s size in bytes */
        msg_size: string;
        /** Number of failed attempts before this message was successfully delivered; when the first attempt succeeds, zero */
        num_retries: string;
        /** Metadata describing the message recipient */
        rcpt_meta: any;
        /** Tags applied to the message which generated this event */
        rcpt_tags: string[];
        /** Recipient address used on this message"s SMTP envelope */
        rcpt_to: string;
        /** Indicates that a recipient address appeared in the Cc or Bcc header or the archive JSON array */
        rcpt_type: string;
        /** Unmodified, exact response returned by the remote server due to a failed delivery attempt */
        raw_reason: string;
        /** Canonicalized text of the response returned by the remote server due to a failed delivery attempt */
        reason: string;
        /** Domain receiving this message */
        routing_domain: string;
        /** Subject line from the email header */
        subject: string;
        /** Slug of the template used to construct this message */
        template_id: string;
        /** Version of the template used to construct this message */
        template_version: string;
        /** Event date and time formatted as: YYYY-MM-DDTHH:MM:SS.SSS±hh:mm */
        timestamp: string;
        /** Transmission which originated this message */
        transmission_id: string;
    }

    export interface MessageEventParameters {
        /** delimited list of bounce classification codes to search. (See Bounce Classification Codes.) */
        bounce_classes?: Array<string | number> | string | number;
        /** delimited list of campaign ID’s to search (i.e. the campaign id used during creation of a transmission). */
        campaign_ids?: string[] | string;
        /** Specifies the delimiter for query parameter lists */
        delimiter?: string;
        /** delimited list of event types to search. Defaults to all event types. */
        events?: string[] | string;
        /** delimited list of friendly from emails to search. */
        friendly_froms?: string[] | string;
        /** Datetime in format of YYYY-MM-DDTHH:MM. */
        from?: string;
        /** delimited list of message ID’s to search. */
        message_ids?: string[] | string;
        /** The results page number to return. Used with per_page for paging through results. */
        page?: number;
        /** Number of results to return per page. Must be between 1 and 10,000 (inclusive). */
        per_page?: number;
        /** Bounce/failure/rejection reason that will be matched using a wildcard (e.g., %reason%). */
        reason?: string[] | string;
        /** delimited list of recipients to search. */
        recipients?: string[] | string;
        /** delimited list of subaccount ID’s to search. */
        subaccounts?: number[] | number;
        /** delimited list of template ID’s to search. */
        template_ids?: string[] | string;
        /** Standard timezone identification string. */
        timezone?: string;
        /** Datetime in format of YYYY-MM-DDTHH:MM. */
        to?: string;
        /** delimited list of transmission ID’s to search (i.e. id generated during creation of a transmission). */
        transmission_ids?: string[] | string;
    }

    export interface RecipientListMetadata {
        total_rejected_recipients: number;
        total_accepted_recipients: number;
        id: string;
        name: string;
    }

    export interface RecipientList {
        /** Short, unique, recipient list identifier */
        id: string;
        /** Short, pretty/readable recipient list display name, not required to be unique */
        name: string;
        /** Detailed description of the recipient list */
        description: string;
        /** Recipient list attribute object */
        attributes: any;
        /** Number of accepted recipients */
        total_accepted_recipients: number;
    }
    export interface RecipientListWithRecipients extends RecipientList {
        /** Array of recipient objects */
        recipients: Recipient[];
    }

    export interface CreateRecipientList {
        /** Short, unique, recipient list identifier */
        id?: string;
        /** Short, pretty/readable recipient list display name, not required to be unique */
        name?: string;
        /** Detailed description of the recipient list */
        description?: string;
        /** Recipient list attribute object */
        attributes?: any;
        /** limit the number of recipient errors returned. */
        num_rcpt_errors?: number;
        /** Array of recipient objects */
        recipients: Recipient[];
    }
    export interface UpdateRecipientList {
        /** Short, unique, recipient list identifier */
        id?: string;
        /** Short, pretty/readable recipient list display name, not required to be unique */
        name?: string;
        /** Detailed description of the recipient list */
        description?: string;
        /** Recipient list attribute object */
        attributes?: any;
        /** limit the number of recipient errors returned. */
        num_rcpt_errors?: number;
        /** Array of recipient objects */
        recipients?: Recipient[];
    }

    export interface BaseRecipient {
        /** SparkPost Enterprise API only. Email to use for envelope FROM. */
        return_path?: string;
        /** Array of text labels associated with a recipient. */
        tags?: string[];
        /** Key/value pairs associated with a recipient. */
        metadata?: any;
        /** Key/value pairs associated with a recipient that are provided to the substitution engine. */
        substitution_data?: any;
    }
    export interface RecipientWithAddress {
        /** Address information for a recipient  At a minimum, address or multichannel_addresses is required. */
        address: Address | string;
    }
    export interface RecipientWithMultichannelAddresses {
        /** Address information for a recipient. At a minimum, address or multichannel_addresses is required. If both address and multichannel_addresses are specified only multichannel_addresses will be used. */
        address?: Address | string;
        /** Array of Multichannel Address objects for a recipient. At a minimum, address or multichannel_addresses is required. If both address and multichannel_addresses are specified only multichannel_addresses will be used. */
        multichannel_addresses: MultichannelAddress[];
    }
    export type Recipient = (RecipientWithAddress | RecipientWithMultichannelAddresses) & BaseRecipient;

    export interface Address {
        /** Valid email address */
        email: string;
        /** User-friendly name for the email address */
        name?: string;
        /** Email address to display in the “To” header instead of address.email (for CC and BCC) */
        header_to?: string;
    }

    export interface MultichannelAddress {
        /** The communication channel used to reach recipient. Valid values are “email”, “gcm”, “apns”. */
        channel: string;
        /** Valid email address. Required if channel is “email”. */
        email: string;
        /** User-friendly name for the email address. Used when channel is “email” */
        name: string;
        /** Email address to display in the “To” header instead of address.email (for BCC). Used when channel is “email” */
        header_to: string;
        /** SparkPost Enterprise API only. Required if channel is “gcm” or “apns” */
        token: string;
        /** SparkPost Enterprise API only. Required if channel is “gcm” or “apns” */
        app_id: string;
    }

    export interface RelayWebhook {
        /** User-friendly name  no  example: Inbound Customer Replies */
        name?: string;
        /** URL of the target to which to POST relay batches */
        target: string;
        /** Authentication token to present in the X-MessageSystems-Webhook-Token header of POST requests to target */
        auth_token?: string;
        /** Restrict which inbound messages will be relayed to the target */
        match: Match;
    }

    export interface UpdateRelayWebhook {
        /** User-friendly name  no  example: Inbound Customer Replies */
        name?: string;
        /** URL of the target to which to POST relay batches */
        target?: string;
        /** Authentication token to present in the X-MessageSystems-Webhook-Token header of POST requests to target */
        auth_token?: string;
        /** Restrict which inbound messages will be relayed to the target */
        match?: Match;
    }

    export interface Match {
        /** Inbound messaging protocol associated with this webhook. Defaults to “SMTP” */
        protocol?: string;
        /** Inbound domain associated with this webhook. Required when protocol is “SMTP”. */
        domain?: string;
        /** ESME address binding associated with this webhook  yes, when protocol is “SMPP”. SparkPost Enterprise API only. */
        esme_address?: string;
    }

    export interface SendingDomain {
        /** Name of the sending domain. */
        domain: string;
        /** Associated tracking domain. */
        tracking_domain: string;
        /** JSON object containing status details, including whether this domain’s ownership has been verified. */
        status: Status;
        /** JSON object in which DKIM key configuration is defined. */
        dkim?: DKIM;
        /** Whether to generate a DKIM keypair on creation. */
        generate_dkim?: boolean;
        /** Size, in bits, of the DKIM private key to be generated. This option only applies if generate_dkim is ‘true’. */
        dkim_key_length?: number;
        /** Setting to true allows this domain to be used by subaccounts. Defaults to false, only available to domains belonging to a master account. */
        shared_with_subaccounts: boolean;
    }

    export interface CreateSendingDomain {
        /** Name of the sending domain. */
        domain: string;
        /** Associated tracking domain. */
        tracking_domain?: string;
        /** JSON object containing status details, including whether this domain’s ownership has been verified. */
        status?: Status;
        /** JSON object in which DKIM key configuration is defined. */
        dkim?: DKIM;
        /** Whether to generate a DKIM keypair on creation. */
        generate_dkim?: boolean;
        /** Size, in bits, of the DKIM private key to be generated. This option only applies if generate_dkim is ‘true’. */
        dkim_key_length?: number;
        /** Setting to true allows this domain to be used by subaccounts. Defaults to false, only available to domains belonging to a master account. */
        shared_with_subaccounts?: boolean;
    }

    export interface UpdateSendingDomain {
        /** Name of the sending domain. */
        domain: string;
        /** Associated tracking domain. */
        tracking_domain?: string;
        /** JSON object in which DKIM key configuration is defined. */
        dkim?: DKIM;
        /** Whether to generate a DKIM keypair on creation. */
        generate_dkim?: boolean;
        /** Size, in bits, of the DKIM private key to be generated. This option only applies if generate_dkim is ‘true’. */
        dkim_key_length?: number;
        /** Setting to true allows this domain to be used by subaccounts. Defaults to false, only available to domains belonging to a master account. */
        shared_with_subaccounts?: boolean;
    }

    export interface DKIM {
        /** Signing Domain Identifier (SDID). SparkPost Enterprise API only. */
        signing_domain?: string;
        /** DKIM private key. */
        private?: string;
        /** DKIM public key. */
        public: string;
        /** DomainKey selector. */
        selector: string;
        /** Header fields to be included in the DKIM signature. This field is currently ignored. */
        headers?: string;
    }

    export interface Status {
        /** Whether domain ownership has been verified */
        ownership_verified: boolean;
        /** Verification status of SPF configuration */
        spf_status: "valid" | "invalid" | "unverified" | "pending";
        /** Compliance status */
        compliance_status: "valid" | "pending" | "blocked";
        /** Verification status of DKIM configuration */
        dkim_status: "valid" | "invalid" | "unverified" | "pending";
        /** Verification status of abuse@ mailbox */
        abuse_at_status: "valid" | "invalid" | "unverified" | "pending";
        /** Verification status of postmaster@ mailbox */
        postmaster_at_status: "valid" | "invalid" | "unverified" | "pending";
    }

    export interface VerifyOptions {
        domain: string;
        verifyDKIM?: boolean;
        verifySPF?: boolean;
    }

    export interface VerifyResults extends Status {
        dns?: {
            dkim_record: string;
            spf_record: string;
        };
    }

    export interface CreateSubaccount {
        /** user-friendly name */
        name: string;
        /** user-friendly identifier for subaccount API key */
        keyLabel: string;
        /** list of grants to give the subaccount API key */
        keyGrants: string[];
        /** list of IPs the subaccount may be used from */
        keyValidIps?: string[];
        /** id of the default IP pool assigned to subaccount"s transmissions */
        ipPool?: string;
    }

    export interface CreateSubaccountResponse {
        subaccount_id: number;
        key: string;
        label: string;
        short_key: string;
    }

    export interface UpdateSubaccount {
        /** the id of the subaccount you want to update */
        subaccountId: string | number;
        /** user-friendly name */
        name: string;
        /** status of the subaccount */
        status: string;
        /** id of the default IP pool assigned to subaccount"s transmissions */
        ipPool?: string;
    }

    export interface SubaccountInformation {
        /** ID of subaccount */
        id: number;
        /** User friendly identifier for a specific subaccount */
        name: string;
        /** Status of the account */
        status: "active" | "suspended" | "terminated";
        /** The ID of the default IP Pool assigned to this subaccount’s transmissions */
        ip_pool?: string;
        compliance_status: string;
    }

    export interface CreateSupressionListEntry {
        recipient: string;
        /** Whether the recipient requested to not receive any transactional messages. At a minimum, transactional or non_transactional is required upon creation of the entry.   */
        transactional?: boolean;
        /** Whether the recipient requested to not receive any non-transactional messages. At a minimum, transactional or non_transactional is required upon creation of the entry.   */
        non_transactional?: boolean;
        /** Short explanation of the suppression */
        description?: string;
    }

    export interface SupressionListEntry {
        recipient: string;
        /** Whether the recipient requested to not receive any transactional messages. At a minimum, transactional or non_transactional is required upon creation of the entry.   */
        transactional?: boolean;
        /** Whether the recipient requested to not receive any non-transactional messages. At a minimum, transactional or non_transactional is required upon creation of the entry.   */
        non_transactional?: boolean;
        /** Coming soon */
        type?: "transactional" | "non_transactional";
        /** Source responsible for inserting the list entry. Valid values include: Spam Complaint, List Unsubscribe, Bounce Rule, Unsubscribe Link, Manually Added, Compliance. */
        source?: string;
        /** Short explanation of the suppression */
        description?: string;
        created: string;
        updated: string;
    }

    export interface SupressionSearch {
        /** Datetime the entries were last updated, in the format of YYYY-MM-DDTHH:mm:ssZ */
        to?: string;
        /** Datetime the entries were last updated, in the format YYYY-MM-DDTHH:mm:ssZ */
        from?: string;
        /** Types of entries to include in the search, i.e. entries with “transactional” and/or “non_transactional” keys set to true */
        types?: string;
        /** Sources of the entries to include in the search, i.e. entries that were added by this source */
        sources?: string;
        /** Maximum number of results to return. Must be between 1 and 100000. Default value is 100000. */
        limit?: number;
    }

    export interface TemplateContent {
        /** HTML content for the email’s text/html MIME part */
        html: string;
        /** Text content for the email’s text/plain MIME part */
        text: string;
        /** Email subject line. */
        subject: string;
        /** Address “from” : "deals@company.com" or JSON object composed of the “name” and “email” fields “from” : { “name” : “My Company”, “email” : "deals@company.com" } used to compose the email’s “From” header. */
        from: Address | string;
        /** Email address used to compose the email’s “Reply-To” header. */
        reply_to?: string;
        /**  JSON dictionary containing headers other than “Subject”, “From”, “To”, and “Reply-To”. */
        headers?: any;
    }

    export interface CreateTemplateContent {
        /** HTML content for the email’s text/html MIME part */
        html?: string;
        /** Text content for the email’s text/plain MIME part */
        text?: string;
        /** Email subject line. */
        subject: string;
        /** Address “from” : "deals@company.com" or JSON object composed of the “name” and “email” fields “from” : { “name” : “My Company”, “email” : "deals@company.com" } used to compose the email’s “From” header. */
        from: Address | string;
        /** Email address used to compose the email’s “Reply-To” header. */
        reply_to?: string;
        /**  JSON dictionary containing headers other than “Subject”, “From”, “To”, and “Reply-To”. */
        headers?: any;
    }

    export interface TemplateMeta {
        /** Unique template ID */
        id: string;
        /** Template name */
        name: string;
        /** Published state of the template (true = published, false = draft) */
        published: boolean;
        /** Template description */
        description: string;
    }

    export interface Template {
        /** Short, unique, alphanumeric ID used to reference the template  At a minimum, id or name is required upon creation. It is auto generated if not provided.  After a template has been created, this property cannot be changed. Maximum length - 64 bytes */
        id: string;
        /** Content that will be used to construct a message  yes  For a full description, see the Content Attributes. Maximum length - 20 MBs */
        content: TemplateContent | { email_rfc822: string };
        /** Whether the template is published or is a draft version  no - defaults to false  A template cannot be changed from published to draft. */
        published: boolean;
        /** Editable display name  At a minimum, id or name is required upon creation.  The name does not have to be unique. Maximum length - 1024 bytes */
        name: string;
        /** Detailed description of the template  no  Maximum length - 1024 bytes */
        description: string;
        /** JSON object in which template options are defined  no  For a full description, see the Options Attributes. */
        options: TemplateOptions;
        /** The “last_update_time” is the time the template was last updated, for both draft and published versions */
        last_update_time: string;
        /** The “last_use” time represents the last time any version of this template was used (draft or published). */
        last_use?: string;
    }

    export interface CreateTemplate {
        /** Short, unique, alphanumeric ID used to reference the template  At a minimum, id or name is required upon creation. It is auto generated if not provided.  After a template has been created, this property cannot be changed. Maximum length - 64 bytes */
        id?: string;
        /** Content that will be used to construct a message  yes  For a full description, see the Content Attributes. Maximum length - 20 MBs */
        content: CreateTemplateContent | { email_rfc822: string };
        /** Whether the template is published or is a draft version  no - defaults to false  A template cannot be changed from published to draft. */
        published?: boolean;
        /** Editable display name  At a minimum, id or name is required upon creation.  The name does not have to be unique. Maximum length - 1024 bytes */
        name?: string;
        /** Detailed description of the template  no  Maximum length - 1024 bytes */
        description?: string;
        /** JSON object in which template options are defined  no  For a full description, see the Options Attributes. */
        options?: CreateTemplateOptions;
    }

    export interface UpdateTemplate {
        /** Content that will be used to construct a message  yes  For a full description, see the Content Attributes. Maximum length - 20 MBs */
        content?: CreateTemplateContent | { email_rfc822: string };
        /** Whether the template is published or is a draft version  no - defaults to false  A template cannot be changed from published to draft. */
        published?: boolean;
        /** Editable display name  At a minimum, id or name is required upon creation.  The name does not have to be unique. Maximum length - 1024 bytes */
        name?: string;
        /** Detailed description of the template  no  Maximum length - 1024 bytes */
        description?: string;
        /** JSON object in which template options are defined  no  For a full description, see the Options Attributes. */
        options?: CreateTemplateOptions;
    }

    export interface TemplateOptions {
        /** Enable or disable open tracking */
        open_tracking: boolean;
        /** Enable or disable click tracking */
        click_tracking: boolean;
        /** Distinguish between transactional and non-transactional messages for unsubscribe and suppression purposes */
        transactional: boolean;
    }

    export interface CreateTemplateOptions {
        /** Enable or disable open tracking */
        open_tracking?: boolean;
        /** Enable or disable click tracking */
        click_tracking?: boolean;
        /** Distinguish between transactional and non-transactional messages for unsubscribe and suppression purposes */
        transactional?: boolean;
    }

    export interface CreateTransmission {
        /** JSON object in which transmission options are defined */
        options?: TransmissionOptions;
        /** Inline recipient objects or object containing stored recipient list ID */
        recipients?: Recipient[] | { list_id: string };
        /** Name of the campaign */
        campaign_id?: string;
        /** Description of the transmission */
        description?: string;
        /** Transmission level metadata containing key/value pairs */
        metadata?: any;
        /** Key/value pairs that are provided to the substitution engine */
        substitution_data?: any;
        /** SparkPost Enterprise API only: email to use for envelope FROM */
        return_path?: string;
        /** Content that will be used to construct a message */
        content: InlineContent | { template_id: string, use_draft_template?: boolean } | { email_rfc822: string };
    }

    export interface TransmissionSummary {
        /** ID of the transmission */
        id: string;
        /** State of the transmission */
        state: "submitted" | "Generating" | "Success" | "Canceled";
        /** Description of the transmission */
        description: string;
        /** Name of the campaign */
        campaign_id: string;
        /** Content that will be used to construct a message */
        content: { template_id: string };
    }

    export interface Transmission {
        /** ID of the transmission */
        id: string;
        /** State of the transmission */
        state: "submitted" | "Generating" | "Success" | "Canceled";
        /** JSON object in which transmission options are defined */
        options: TransmissionOptions;
        /** Name of the campaign */
        campaign_id: string;
        /** Description of the transmission */
        description: string;
        /** Transmission level metadata containing key/value pairs */
        metadata: any;
        /** Key/value pairs that are provided to the substitution engine */
        substitution_data: any;
        /** Content that will be used to construct a message */
        content: InlineContent | { template_id: string, use_draft_template?: boolean } | { email_rfc822: string };
        /** Computed total number of messages generated */
        num_generated: number;
        /** Computed total number of failed messages */
        num_failed_generation: number;
        /** Number of recipients that failed input validation */
        num_invalid_recipients: number;
        rcpt_list_chunk_size: number;
        rcpt_list_total_chunks: number;
    }

    export interface TransmissionOptions {
        /** Delay generation of messages until this datetime. */
        start_time?: string;
        /** Whether open tracking is enabled for this transmission */
        open_tracking?: boolean;
        /** Whether click tracking is enabled for this transmission */
        click_tracking?: boolean;
        /** Whether message is transactional or non-transactional for unsubscribe and suppression purposes */
        transactional?: boolean;
        /** Whether or not to use the sandbox sending domain */
        sandbox?: boolean;
        /** SparkPost Enterprise API only: Whether or not to ignore customer suppression rules, for this transmission only. Only applicable if your configuration supports this parameter. */
        skip_suppression?: boolean;
        /** The ID of a dedicated IP pool associated with your account ( Note: SparkPost only ). */
        ip_pool?: string;
        /** Whether or not to perform CSS inlining in HTML content */
        inline_css?: boolean;
    }

    export interface InlineContent {
        /** HTML content for the email’s text/html MIME part  At a minimum, html, text, or push is required. */
        html?: string;
        /** Text content for the email’s text/plain MIME part  At a minimum, html, text, or push is required. */
        text?: string;
        /**  Content of push notifications  At a minimum, html, text, or push is required.  SparkPost Enterprise API only. */
        push?: PushData;
        /** Email subject line  required for email transmissions  Expected in the UTF-8 charset without RFC2047 encoding. Substitution syntax is supported. */
        subject?: string;
        /** "deals@company.com" or JSON object composed of the “name” and “email” fields “from” : { “name” : “My Company”, “email” : "deals@company.com" } used to compose the email’s “From” header */
        from?: string | { email: string, name: string };
        /** Email address used to compose the email’s “Reply-To” header */
        reply_to?: string;
        /** JSON dictionary containing headers other than “Subject”, “From”, “To”, and “Reply-To” */
        headers?: any;
        /** JSON array of attachments. */
        attachments?: Attachment[];
        /** JSON array of inline images. */
        inline_images?: Attachment[];
    }

    export interface PushData {
        /** payload for APNs messages */
        apns?: any;
        /** payload for GCM messages */
        gcm?: any;
    }

    export interface Attachment {
        /** The MIME type of the attachment; e.g., “text/plain”, “image/jpeg”, “audio/mp3”, “video/mp4”, “application/msword”, “application/pdf”, etc., including the “charset” parameter (text/html; charset=“UTF-8”) if needed. The value will apply “as-is” to the “Content-Type” header of the generated MIME part for the attachment. */
        type: string;
        /**   The filename of the attachment (for example, “document.pdf”). This is inserted into the filename parameter of the Content-Disposition header. */
        name: string;
        /** The content of the attachment as a Base64 encoded string. The string should not contain \r\n line breaks. The SparkPost systems will add line breaks as necessary to ensure the Base64 encoded lines contain no more than 76 characters each. */
        data: string;
    }

    export interface Webhook {
        /** User-friendly name for webhook */
        name: string;
        /** URL of the target to which to POST event batches */
        target: string;
        /** Array of event types this webhook will receive */
        events: string[];
        /** Type of authentication to be used during POST requests to target */
        auth_type?: string;
        /** Object containing details needed to request authorization credentials, as necessary */
        auth_request_details?: any;
        /** Object containing credentials needed to make authorized POST requests to target */
        auth_credentials?: any;
        /** Authentication token to present in the X-MessageSystems-Webhook-Token header of POST requests to target */
        auth_token?: string;
    }

    export interface UpdateWebhook {
        id: string;
        /** User-friendly name for webhook */
        name?: string;
        /** URL of the target to which to POST event batches */
        target?: string;
        /** Array of event types this webhook will receive */
        events?: string[];
        /** Type of authentication to be used during POST requests to target */
        auth_type?: string;
        /** Object containing details needed to request authorization credentials, as necessary */
        auth_request_details?: any;
        /** Object containing credentials needed to make authorized POST requests to target */
        auth_credentials?: any;
        /** Authentication token to present in the X-MessageSystems-Webhook-Token header of POST requests to target */
        auth_token?: string;
    }

    export interface WebhookLinks {
        links: {
            href: string;
            rel: string;
            method: string[];
        }[];
    }
}

export = SparkPost;
