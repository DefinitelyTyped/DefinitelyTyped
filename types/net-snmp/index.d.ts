// Type definitions for net-snmp
// Project: https://github.com/markabrahams/node-net-snmp
// Definitions by: Ori Erel <https://github.com/0rierel>
// Definitions: https://github.com/DefinitelyTyped/net-snmp
/** Declaration file generated by dts-gen */

export class Session {
    constructor(target: any, authenticator: any, options: any);

    cancelRequests(error: any): void;

    close(): this;

    get(oids: string | string[], responseCb: GetCallback): Session;

    getBulk(oids: string[], nonRepeaters: number, maxRepetitions: number, responseCb: GetBulkCallback): this;
    getBulk(oids: string[], nonRepeaters: number, responseCb: GetBulkCallback): this;
    getBulk(oids: string[], responseCb: GetBulkCallback): this;

    getNext(oids: string[], responseCb: GetCallback): this;

    simpleGet(
        pduClass: any,
        feedCb: (req: any, message: any) => void,
        varbinds: Varbind[],
        responseCb: (error: Error | null, result?: any) => void,
        options?: SimpleGetOptions
    ): void;

    inform(typeOrOid: string | number, varbinds: Varbind[], options: InformOptions, responseCb: InformCallback): this;
    inform(typeOrOid: string | number, varbinds: Varbind[], responseCb: InformCallback): this;
    inform(typeOrOid: string | number, options: InformOptions, responseCb: InformCallback): this;
    inform(typeOrOid: string | number, responseCb: InformCallback): this;
    onClose(): void;

    onError(error: any): void;

    onMsg(buffer: any): void;

    onProxyResponse(req: any, message: any): void;

    onSimpleGetResponse(req: any, message: any): void;

    registerRequest(req: any): void;

    send(req: any, noWait: any): any;

    sendV3Discovery(originalPdu: any, feedCb: any, responseCb: any, options: any): void;

    sendV3Req(pdu: any, feedCb: any, responseCb: any, options: any, port: any, allowReport: any): void;

    set(varbinds: any, responseCb: any): any;

    subtree(...args: any[]): any;

    table(...args: any[]): any;

    tableColumns(...args: any[]): any;

    trap(...args: any[]): any;

    unregisterRequest(id: any): any;

    userSecurityModelError(req: any, oid: any): void;

    walk(...args: any[]): any;

    static create(target: string, community: string, options: SessionOptions): Session;

    static createV3(target: string, user: User, options?: SessionOptionsV3): Session;

    on(event: "close", listener: () => void): this;
    on(event: "error", listener: (err: Error) => void): this;
    on(event: "message", listener: (buffer: Buffer) => void): this;
    on(event: string, listener: (...args: any[]) => void): this;
}
export interface SessionOptions {
    version?: 0 | 1; // Version1 | Version2c
    transport?: "udp4" | "udp6";
    port?: number;
    trapPort?: number;
    retries?: number;
    timeout?: number;
    backoff?: number;
    sourceAddress?: string;
    sourcePort?: number;
    idBitsSize?: number;
    context?: string;
    backwardsGetNexts?: boolean;
    reportOidMismatchErrors?: boolean;
    debug?: boolean;
    dgramModule?: any;
}
export interface InformOptions extends RequestOptions {
    upTime?: number;
}
export type InformCallback = (error: RequestInvalidError | ResponseInvalidError | null, varbinds?: Varbind[]) => void;
export type GetCallback = (error: ResponseInvalidError | null, varbinds?: Varbind[]) => void;

export type GetBulkCallback = (error: ResponseInvalidError | null, varbinds?: (Varbind | Varbind[])[]) => void;

export interface RequestOptions {
    port?: number;
    context?: string;
    timeout?: number;
    retries?: number;
    backoff?: number;
}
export interface SimpleGetOptions extends RequestOptions {
    nonRepeaters?: number;
    maxRepetitions?: number;
}
export interface User {
    name: string;
    level: SecurityLevel;
    authProtocol?: AuthProtocols;
    authKey?: string;
    privProtocol?: PrivProtocols;
    privKey?: string;
}

export interface SessionOptionsV3 {
    version?: 3;
    transport?: "udp4" | "udp6";
    port?: number;
    trapPort?: number;
    retries?: number;
    timeout?: number;
    backoff?: number;
    sourceAddress?: string;
    sourcePort?: number;
    idBitsSize?: number;
    context?: string;
    backwardsGetNexts?: boolean;
    reportOidMismatchErrors?: boolean;
    engineID?: string | Buffer;
    debug?: boolean;
    dgramModule?: any;
}

export const enum AccessControlModelType {
    None,
    Simple,
}

export const enum AccessLevel {
    None,
    ReadOnly,
    ReadWrite,
}

export const enum AgentXPduType {
    Open = 1,
    Close,
    Register,
    Unregister,
    Get,
    GetNext,
    GetBulk,
    TestSet,
    CommitSet,
    UndoSet,
    CleanupSet,
    Notify,
    Ping,
    IndexAllocate,
    IndexDeallocate,
    AddAgentCaps,
    RemoveAgentCaps,
    Response,
}

export const enum AuthProtocols {
    none = 1,
    md5,
    sha,
    sha224,
    sha256,
    sha384,
    sha512,
}

export const enum ErrorStatus {
    NoError,
    TooBig,
    NoSuchName,
    BadValue,
    ReadOnly,
    GeneralError,
    NoAccess,
    WrongType,
    WrongLength,
    WrongEncoding,
    WrongValue,
    NoCreation,
    InconsistentValue,
    ResourceUnavailable,
    CommitFailed,
    UndoFailed,
    AuthorizationError,
    NotWritable,
    InconsistentName,
}

export const enum MaxAccess {
    "not-accessible",
    "accessible-for-notify",
    "read-only",
    "read-write",
    "read-create",
}

export const enum MibProviderType {
    Scalar,
    Table,
}
export const enum ObjectType {
    Boolean = 1,
    Integer,
    INTEGER = Integer,
    Integer32 = Integer,
    BitString,
    OctetString,
    "OCTET STRING" = OctetString,
    Null,
    OID,
    "OBJECT IDENTIFIER" = OID,
    IpAddress = 64,
    Counter = 65,
    Counter32 = Counter,
    Gauge = 66,
    Gauge32 = Gauge,
    Unsigned32 = Gauge32,
    TimeTicks = 67,
    Opaque = 68,
    Counter64 = 70,
    NoSuchObject = 128,
    NoSuchInstance = 129,
    EndOfMibView = 130,
}

export const OidFormat: {
    module: string;
    oid: string;
    path: string;
};

export const enum PduType {
    GetRequest = 160,
    GetNextRequest,
    GetResponse,
    SetRequest,
    Trap,
    GetBulkRequest,
    InformRequest,
    TrapV2,
    Report,
}

export const enum PrivProtocols {
    none = 1,
    des,
    aes = 4,
    aes256b = 6,
    aes256r = 8,
}

export const enum ResponseInvalidCode {
    EIp4AddressSize = 1,
    EUnknownObjectType,
    EUnknownPduType,
    ECouldNotDecrypt,
    EAuthFailure,
    EReqResOidNoMatch,
    EOutOfOrder = 8,
    EVersionNoMatch,
    ECommunityNoMatch,
    EUnexpectedReport,
    EResponseNotHandled,
    EUnexpectedResponse,
}

export const enum RowStatus {
    active = 1,
    notInService,
    notReady,
    createAndGo,
    createAndWait,
    destroy,
}

export const enum SecurityLevel {
    noAuthNoPriv = 1,
    authNoPriv,
    authPriv,
}

export const enum TrapType {
    ColdStart,
    WarmStart,
    LinkDown,
    LinkUp,
    AuthenticationFailure,
    EgpNeighborLoss,
    EnterpriseSpecific,
}
export const Version1: 0;

export const Version2c: 1;

export const Version3: 3;

export const Version: {
    "1": typeof Version1;
    "2c": typeof Version2c;
    "3": typeof Version3;
};

export interface RequestFailedError extends Error {
    name: "RequestFailedError";
    message: string;
    status: ErrorStatus;
}

export const RequestFailedError: {
    new (message: string, status: ErrorStatus): RequestFailedError;
    prototype: RequestFailedError;
};

export interface RequestTimedOutError extends Error {
    name: "RequestTimedOutError";
}

export interface ResponseInvalidError extends Error {
    name: "ResponseInvalidError";
    code: ResponseInvalidCode;
    info?: any;
}

export interface RequestInvalidError extends Error {
    name: "RequestInvalidError";
}

export const ResponseInvalidError: {
    new (message: string, code: ResponseInvalidCode, info?: any): ResponseInvalidError;
    prototype: ResponseInvalidError;
};
export function createAgent(options: any, callback: Function, mib?: any): any;

export function createMib(options?: MibOptions): any;
export interface MibOptions {
    addScalarDefaultsOnRegistration?: boolean;
}

export function createModuleStore(options?: ModuleStoreOptions): any;

export interface ModuleStoreOptions {
    baseModules?: string[];
}

export function createReceiver(options: any, callback: Function): any;

declare function createSession(target?: string, community?: string, options?: SessionOptions): Session;
declare namespace createSession {
    const prototype: {};
}

export { createSession };

export function createSubagent(options: any): any;

declare function createV3Session(target: string, user: User, options?: SessionOptionsV3): Session;

declare namespace createV3Session {
    const prototype: {};
}

export { createV3Session };
export function isVarbindError(varbind: Varbind): boolean;

export function varbindError(varbind: Varbind): string;

export interface Varbind {
    oid: string;
    type?: ObjectType;
    value?: any;
}
export namespace Authentication {
    const HMAC_BUFFER_SIZE: number;

    const algorithms: {
        readonly [AuthProtocols.none]: undefined; // none has no algorithm
        readonly [AuthProtocols.md5]: {
            KEY_LENGTH: 16;
            AUTHENTICATION_CODE_LENGTH: 12;
            CRYPTO_ALGORITHM: "md5";
        };
        readonly [AuthProtocols.sha]: {
            KEY_LENGTH: 20;
            AUTHENTICATION_CODE_LENGTH: 12;
            CRYPTO_ALGORITHM: "sha1";
        };
        readonly [AuthProtocols.sha224]: {
            KEY_LENGTH: 28;
            AUTHENTICATION_CODE_LENGTH: 16;
            CRYPTO_ALGORITHM: "sha224";
        };
        readonly [AuthProtocols.sha256]: {
            KEY_LENGTH: 32;
            AUTHENTICATION_CODE_LENGTH: 24;
            CRYPTO_ALGORITHM: "sha256";
        };
        readonly [AuthProtocols.sha384]: {
            KEY_LENGTH: 48;
            AUTHENTICATION_CODE_LENGTH: 32;
            CRYPTO_ALGORITHM: "sha384";
        };
        readonly [AuthProtocols.sha512]: {
            KEY_LENGTH: 64;
            AUTHENTICATION_CODE_LENGTH: 48;
            CRYPTO_ALGORITHM: "sha512";
        };
    };

    const authToKeyCache: {
        [key: string]: Buffer;
    };

    function calculateDigest(
        messageBuffer: Buffer,
        authProtocol: Exclude<AuthProtocol, AuthProtocols.none>,
        authPassword: string,
        engineID: Buffer
    ): Buffer;

    function computeCacheKey(authProtocol: AuthProtocol, authPasswordString: string, engineID: Buffer): string;

    function getParametersLength(authProtocol: Exclude<AuthProtocol, AuthProtocols.none>): number;

    function isAuthentic(
        messageBuffer: Buffer,
        authProtocol: AuthProtocol,
        authPassword: string,
        engineID: Buffer,
        digestInMessage: Buffer
    ): boolean;

    function passwordToKey(
        authProtocol: Exclude<AuthProtocol, AuthProtocols.none>,
        authPasswordString: string,
        engineID: Buffer
    ): Buffer;

    function writeParameters(
        messageBuffer: Buffer,
        authProtocol: Exclude<AuthProtocol, AuthProtocols.none>,
        authPassword: string,
        engineID: Buffer,
        digestInMessage: Buffer
    ): void;
}

export type AuthProtocol = 1 | 2 | 3 | 4 | 5 | 6 | 7;

export namespace Encryption {
    const algorithms: {
        readonly [PrivProtocols.des]: {
            BLOCK_LENGTH: 8;
            CRYPTO_ALGORITHM: "des-cbc";
            KEY_LENGTH: 8;
            decryptPdu: typeof Encryption.decryptPduDes;
            encryptPdu: typeof Encryption.encryptPduDes;
            localizationAlgorithm: typeof Encryption.generateLocalizedKey;
        };
        readonly [PrivProtocols.aes]: {
            BLOCK_LENGTH: 16;
            CRYPTO_ALGORITHM: "aes-128-cfb";
            KEY_LENGTH: 16;
            decryptPdu: typeof Encryption.decryptPduAes;
            encryptPdu: typeof Encryption.encryptPduAes;
            localizationAlgorithm: typeof Encryption.generateLocalizedKey;
        };
        readonly [PrivProtocols.aes256b]: {
            BLOCK_LENGTH: 16;
            CRYPTO_ALGORITHM: "aes-256-cfb";
            KEY_LENGTH: 32;
            decryptPdu: typeof Encryption.decryptPduAes;
            encryptPdu: typeof Encryption.encryptPduAes;
            localizationAlgorithm: typeof Encryption.generateLocalizedKeyBlumenthal;
        };
        readonly [PrivProtocols.aes256r]: {
            BLOCK_LENGTH: 16;
            CRYPTO_ALGORITHM: "aes-256-cfb";
            KEY_LENGTH: 32;
            decryptPdu: typeof Encryption.decryptPduAes;
            encryptPdu: typeof Encryption.encryptPduAes;
            localizationAlgorithm: typeof Encryption.generateLocalizedKeyReeder;
        };
    };

    function decryptPduDes(
        encryptedPdu: Buffer,
        privProtocol: PrivProtocol,
        privParameters: Buffer,
        privPassword: string,
        authProtocol: AuthProtocol,
        engine: Algorithm
    ): Buffer;

    function encryptPduDes(
        scopedPdu: Buffer,
        privProtocol: PrivProtocol,
        privPassword: string,
        authProtocol: AuthProtocol,
        engine: Algorithm
    ): { encryptedPdu: Buffer; msgPrivacyParameters: Buffer };

    function decryptPduAes(
        encryptedPdu: Buffer,
        privProtocol: PrivProtocol,
        privParameters: Buffer,
        privPassword: string,
        authProtocol: AuthProtocol,
        engine: Algorithm
    ): Buffer;

    function encryptPduAes(
        scopedPdu: Buffer,
        privProtocol: PrivProtocol,
        privPassword: string,
        authProtocol: AuthProtocol,
        engine: Algorithm
    ): { encryptedPdu: Buffer; msgPrivacyParameters: Buffer };

    function generateLocalizedKey(
        algorithm: Algorithm,
        authProtocol: AuthProtocol,
        privPassword: string,
        engineID: Buffer
    ): Buffer;

    function generateLocalizedKeyBlumenthal(
        algorithm: Algorithm,
        authProtocol: AuthProtocol,
        privPassword: string,
        engineID: Buffer
    ): Buffer;

    function generateLocalizedKeyReeder(
        algorithm: Algorithm,
        authProtocol: AuthProtocol,
        privPassword: string,
        engineID: Buffer
    ): Buffer;
}
declare interface Algorithm {
    readonly BLOCK_LENGTH: number;
    readonly CRYPTO_ALGORITHM: string;
    readonly KEY_LENGTH: number;
    readonly decryptPdu: typeof Encryption.decryptPduAes;
    readonly encryptPdu: typeof Encryption.encryptPduAes;
    readonly localizationAlgorithm: typeof Encryption.generateLocalizedKey;
}

export type PrivProtocol = 1 | 2 | 4 | 6 | 8;
//module asn1-ber doesn't have type support so we to create completing type for the buffer used in Object Parser
declare class BerReader {
    readInt(): number;
    readString(type?: number, explicit?: boolean): string | Buffer;
    readBoolean(): boolean;
    readBitString(): string;
    readOID(): string;
    readByte(): number;
    readSequence(): number;
    peek(): number | null;
    readBuffer(type: number, explicit?: boolean): Buffer;
    readLength(): number;
}

export namespace ObjectParser {
    function readInt32(buffer: BerReader): number;

    function readUint32(buffer: BerReader): number;

    function readUint64(buffer: BerReader): bigint | string;
}

export namespace ObjectTypeUtil {
    function castSetValue(type: any, value: any, constraints: any): any;

    function doesIntegerMeetConstraints(value: any, constraints: any): boolean;

    function doesStringMeetConstraints(value: any, constraints: any): boolean;

    function getEnumerationNumberFromName(enumeration: any, name: any): any;

    function isValid(type: ObjectType, value: any, constraints: any): boolean;
}
