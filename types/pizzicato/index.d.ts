export const context: AudioContext;
export const masterGainNode: GainNode;

export type UnknownFunction = (...args: unknown[]) => unknown;

/** Utility methods for inspecting runtime objects */
export namespace Util {
    function isString(arg: any): arg is string;
    function isObject(arg: any): arg is object;
    function isFunction(arg: any): arg is UnknownFunction;
    function isNumber(arg: any): arg is number;
    function isArray(arg: any): arg is unknown[];
    function isInRange(arg: number, min: number, max: number): boolean;
    function isBool(arg: any): arg is boolean;
    function isOscillator(arg: any): arg is OscillatorNode;
    function isAudioBufferSourceNode(arg: any): arg is AudioBufferSourceNode;
    function isSound(sound: any): sound is Sound;
    function isEffect(effect: any): effect is Effect;

    /**
     * Takes a number from 0 to 1 and normalizes it to fit within range
     * floor to ceiling.
     */
    function normalize(num: number, floor: number, ceil: number): number;
    function getDryLevel(mix: number): number;
    function getWetLevel(mix: number): number;
}

/** Master volume of Pizzicato */
export let volume: number;

/** Pizzicato's implementation of events. */
export interface Events<Name extends string> {
    on: <Context>(name: Name, callback: (this: Context, ...args: any[]) => void, context?: Context) => void;
    off: (name: Name) => void;
}

/**
 * An events object used as a prototype for `Sound` and `Group`. It
 * should not be used directly, but new instances can be
 * `Object.create`-ed from it.
 */
export const Events: Events<string>;

/** Options that all sounds have */
export interface SoundOptions {
    /** Loudness of the sound. Min: 0, Max: 1, Default: 1 */
    volume?: number;
    /**
     * Value in seconds that indicates the fade-out time once the sound
     * is stopped. Min: 0, Max: 1, Default: 1.
     */
    release?: number;
    /**
     * Value in seconds that indicates the fade-in time when the sound
     * is played. Defaults to 0.04.
     */
    attack?: number;
    /**
     * If true, the sound will not be connected to the context's
     * destination, and thus, will not be audible. Defaults to false.
     */
    detached?: boolean;
}

/** A sound generated from a wave */
export type WaveType = "sine" | "square" | "triangle" | "sawtooth";
export interface WaveSoundOptions extends SoundOptions {
    /** The frequency of the wave. Defaults to 440, which is an A note. */
    frequency?: number;
    type?: WaveType;
}

/** A sound loaded from a file retrieved by an http request */
export interface FileSoundOptions extends SoundOptions {
    /**
     * When given a list of paths, Pizzicato uses the first path that
     * loads successfully.
     */
    path: string | ReadonlyArray<string>;
    /** Whether or not to loop the sound */
    loop?: boolean;
}

/** A function used to generate a sound */
export type AudioFunction = (e: AudioProcessingEvent) => void;

/** A sound generated by a function */
export interface ScriptSoundOptions extends SoundOptions {
    audioFunction: AudioFunction;
    bufferSize?: number;
}

/** The description of the sound to build */
export type SoundDescription =
    | string
    | AudioFunction
    | { source: "file"; options: FileSoundOptions }
    | { source: "wave"; options?: WaveSoundOptions }
    | { source: "input"; options?: SoundOptions }
    | { source: "script"; options: ScriptSoundOptions };

/** Events emitted when a Sound changes state */
export type SoundEvent = "play" | "pause" | "stop" | "end";

/** A Pizzicato Sound */
export class Sound<D extends SoundDescription = SoundDescription> implements Events<SoundEvent> {
    constructor(description?: D, callback?: (error?: Error) => void);

    /**
     * Whether the sound is connected to an output destination and is
     * playable.
     */
    readonly detached: boolean;
    /** The effects attached to the sound */
    effects: ReadonlyArray<Effect>;
    readonly playing: boolean;
    readonly loop: boolean;
    volume: number;
    /** Frequency of the wave if the sound's source is a wave */
    frequency: D extends { source: "wave" } ? number : null;
    /**
     * Value in seconds that indicates the fade-in time when the sound
     *  is played. Defaults to 0.04.
     */
    attack: number;
    /**
     * Value in seconds that indicates the fade-out time once the sound
     * is stopped. Min: 0, Max: 1, Default: 1.
     */
    release: number;

    /**
     * Play the sound.
     * @param when the time in seconds to wait before playing.
     * @param offset the position in seconds where the sound will start
     *  playing from. Both default to zero.
     */
    play(when?: number, offset?: number): void;
    /**
     * Pause the sound. The next time it is played, it will continue
     * from where it left off.
     */
    pause(): void;
    /**
     *  Stop the sound. The next time it is played, it will start from
     * the beginning.
     */
    stop(): void;
    /** Create a copy of the sound */
    clone(): Sound<D>;
    addEffect(effect: Effect): void;
    removeEffect(effect: Effect): void;
    /** Connect a detached sound to a destination */
    connect(audioNode: AudioNode): this;
    /**
     * Disconnect a sound from the context's destination so it can be
     * garbage collected.
     */
    disconnect(audioNode: AudioNode): this;

    on<Context>(name: SoundEvent, callback: (this: Context) => void, context?: Context): void;
    off(name: SoundEvent): void;
}

/** Events emitted when a Group changes state */
export type GroupEvent = "play" | "pause" | "stop";

/** A collection of sounds */
export class Group implements Events<GroupEvent> {
    constructor(sounds?: ReadonlyArray<Sound>);

    /** The master volume of the group */
    volume: number;
    /** The Sounds in the group */
    readonly sounds: ReadonlyArray<Sound>;
    /** The effects attached to the group */
    readonly effects: ReadonlyArray<Effect>;

    /** Play all the sounds in the group */
    play(): void;
    /** Pause all the sounds in the group */
    pause(): void;
    /** Stop all the sounds in the group */
    stop(): void;
    /** Add a sound to the group */
    addSound(sound: Sound): void;
    /** Remove a sound from the group */
    removeSound(sound: Sound): void;
    /** Connect a detached group to a destination */
    connect(audioNode: AudioNode): this;
    /**
     * Disconnect a group from the context's destination so it can be
     * garbage collected.
     */
    disconnect(audioNode: AudioNode): this;
    /** Add an effect to the group. The effect is applied to all sounds. */
    addEffect(effect: Effect): this;
    /** Remove an effect from the group */
    removeEffect(effect: Effect): this;

    on<Context>(name: GroupEvent, callback: (this: Context) => void, context?: Context): void;
    off(name: GroupEvent): void;
}

/** Changes the quality and characteristics of the sound it is applied to. */
export type Effect =
    | Effects.Compressor
    | Effects.Convolver
    | Effects.Delay
    | Effects.Distortion
    | Effects.DubDelay
    | Effects.Flanger
    | Effects.HighPassFilter
    | Effects.LowPassFilter
    | Effects.PingPongDelay
    | Effects.Quadrafuzz
    | Effects.Reverb
    | Effects.RingModulator
    | Effects.StereoPanner
    | Effects.Tremolo;

/**
 * The base interface that all Pizzicato effects implemnet.
 * NOTE that when adding an `Effect` to a `Sound` or `Group`,
 * Pizzicato performs a runtime `instanceof` check to make sure
 * the `Effect` is a Pizzicato effect, so custom effects are not
 * supported.
 */
export interface BaseEffect {
    connect(audioNode: AudioNode): this;
    disconnect(audioNode: AudioNode): this;
}

export namespace Effects {
    /**
     * A compressor allows reducing the range between the loudest and
     * the quietest parts of a sound. This is done by boosting the quiet
     *  segments and attenuating the loud ones.
     */
    interface CompressorOptions {
        /**
         * The decibel value above which the compression will start
         * taking effect. min: -100, max: 0, defaults to -24.
         */
        threshold?: number;
        /**
         * A value representing the range above the threshold where the
         * curve smoothly transitions to the "ratio" portion.
         * min: 0, max: 40, defaults to 30.
         */
        knee?: number;
        /**
         * How soon the compressor starts to compress the dynamics after
         * the threshold is exceeded. Short values will result in a fast
         * response to sudden, loud sounds, but will make the changes in
         * volume more obvious to listeners. min: 0, max: 1, defaults to
         * 0.003.
         */
        attack?: number;
        /**
         * How soon the compressor starts to release the volume level
         * back to normal after the level drops below the threshold.
         * min: 0, max: 1, defaults to 0.025.
         */
        release?: number;
        /**
         * The amount of compression applied to the audio once it passes
         * the threshold level. The higher the Ratio the more the loud
         * parts of the audio will be compressed. min: 1, max: 20,
         * defaults to 12.
         */
        ratio?: number;
        /**
         * Volume balance between the original audio and the effected
         * output. min: 0, max: 1, defaults to 0.5.
         */
        mix?: number;
    }
    type Compressor = BaseEffect & Required<CompressorOptions>;
    const Compressor: Compressor & { new(options?: CompressorOptions): Compressor };

    /**
     * The convolver effect allows the sound to be heard with a certain
     * ressonance or repercussion. This can be useful to simulate
     * certain environments such as auditoriums, concert halls, or small
     * rooms.
     */
    interface ConvolverOptions {
        /** Path to the impulse file. */
        impulse: string;
        /**
         * Volume balance between the original audio and the effected
         * output. min: 0, max: 1, defaults to 0.5.
         */
        mix?: number;
    }
    type Convolver = BaseEffect & Required<ConvolverOptions>;
    const Convolver: Convolver & { new(options: ConvolverOptions): Convolver };

    /**
     * The delay effect plays back the sound a certain number of times
     * in defined intervals, giving the impression of an echo.
     */
    interface DelayOptions {
        /**
         * The intensity with which the input will echo back. A larger
         * value will result in more echo repetitions. min: 0, max: 1,
         * defaults to 0.5.
         */
        feedback?: number;
        /** Interval time in seconds. min: 0, max: 1, defaults to 0.3. */
        time?: number;
        /**
         * Volume balance between the original audio and the effected
         * output (the delayed sound). min: 0, max: 1, defaults to 0.5.
         */
        mix?: number;
    }
    type Delay = BaseEffect & Required<DelayOptions>;
    const Delay: Delay & { new(options?: DelayOptions): Delay };

    /** The distortion effect adds a basic "override" to the sound. */
    interface DistortionOptions {
        /** Amount of distortion applied. min: 0, max: 1, defaults to 0.5 */
        gain?: number;
    }
    type Distortion = BaseEffect & Required<DistortionOptions>;
    const Distortion: Distortion & { new(options?: DistortionOptions): Distortion };

    /**
     * The dub delay effect is similar to a regular Delay effect,
     * however on each feedback loop the output is routed through a
     * biquad filter.
     */
    interface DubDelayOptions {
        /**
         * The intensity with which the input will echo back. A larger
         * value will result in more echo repetitions. min: 0, max: 1,
         * defaults to 0.5.
         */
        feedback?: number;
        /** Interval time in seconds. min: 0, max: 1, defaults to 0.3. */
        time?: number;
        /**
         * Volume balance between the original audio and the effected
         * output (the delayed sound). min: 0, max: 1, defaults to 0.5.
         */
        mix?: number;
        /**
         * Frequency value applied to each successive loop. The lower
         * the value, the more different each repetition will be
         * perceived. min: 0, max: 4000, defaults to 700.
         */
        cutoff?: number;
    }
    type DubDelay = BaseEffect & Required<DubDelayOptions>;
    const DubDelay: DubDelay & { new(options?: DubDelayOptions): DubDelay };

    /**
     * The flanger produces a swirling effect by delaying a "copy" of
     * the sound by a small, gradually changing period.
     */
    interface FlangerOptions {
        /**
         * The small delay time applied to the copied signal. min: 0,
         * max: 1, defaults to 0.45.
         */
        time?: number;
        /**
         * The speed at which the flanging occurs. min: 0, max: 1,
         * defaults to 0.2.
         */
        speed?: number;
        /**
         * The depth/intensity of the swirling effect. min: 0, max: 1,
         * defaults to 0.1.
         */
        depth?: number;
        /**
         * Changes the volume of the delayed sound. min: 0, max: 1,
         * defaults to 0.1 .
         */
        feedback?: number;
        /**
         * Volume balance between the original audio and the effected
         * output. min: 0, max: 1, defaults to 0.5.
         */
        mix?: number;
    }
    type Flanger = BaseEffect & Required<FlangerOptions>;
    const Flanger: Flanger & { new(options?: FlangerOptions): Flanger };

    /**
     * A high-pass filter attenuates signals with a frequency lower than
     * a pre-determined cutoff frequency and passes signals with
     * frequencies higher than the cutoff frequency.
     */
    interface HighPassFilterOptions {
        /**
         * The cutoff frequency of the high-pass filter. min: 10,
         * max: 22050, defaults to 350.
         */
        frequency?: number;
        /**
         * Indicates how peaked the frequency is around the cutoff
         * frequency. The greater the value is, the greater is the peak.
         * min: 0.0001, max: 1000, defaults to 1.
         */
        peak?: number;
    }
    type HighPassFilter = BaseEffect & Required<HighPassFilterOptions>;
    const HighPassFilter: HighPassFilter & { new(options?: HighPassFilterOptions): HighPassFilter };

    /**
     * A low-pass filter passes signals with a frequency lower than a
     * pre-determined cutoff frequency and attenuates signals with
     * frequencies higher than the cutoff frequency.
     */
    interface LowPassFilterOptions {
        /**
         * The cutoff frequency of the low-pass filter. min: 10,
         * max: 22050, defaults to 350.
         */
        frequency?: number;
        /**
         * Indicates how peaked the frequency is around the cutoff
         * frequency. The greater the value is, the greater is the peak.
         * min: 0.0001, max: 1000, defaults to 1.
         */
        peak?: number;
    }
    type LowPassFilter = BaseEffect & Required<LowPassFilterOptions>;
    const LowPassFilter: LowPassFilter & { new(options?: LowPassFilterOptions): LowPassFilter };

    /**
     * The ping pong delay effect is similar to a regular Delay effect,
     * however on each feedback loop the output is swapped between left
     * and right channels.
     */
    interface PingPongDelayOptions {
        /**
         * The intensity with which the input will echo back. A larger
         * value will result in more echo repetitions. min: 0, max: 1,
         * defaults to 0.5. =
         */
        feedback?: number;
        /** Interval time in seconds. min: 0, max: 1, defaults to 0.3. */
        time?: number;
        /**
         * Volume balance between the original audio and the effected
         * output (the delayed sound). min: 0, max: 1, defaults to 0.5.
         */
        mix?: number;
    }
    type PingPongDelay = BaseEffect & Required<PingPongDelayOptions>;
    const PingPongDelay: PingPongDelay & { new(options?: PingPongDelayOptions): PingPongDelay };

    /**
     * The quadrafuzz effect divides the sound into separate bands and
     * then distorts each band independently, allowing you to control
     * which frequencies you distort and how much.
     */
    interface QuadrafuzzOptions {
        /** min: 0, max: 1, defaults to 0.6. */
        lowGain?: number;
        /** min: 0, max: 1, defaults to 0.8. */
        midLowGain?: number;
        /** min: 0, max: 1, defaults to 0.5. */
        midHighGain?: number;
        /** min: 0, max: 1, defaults to 0.6. */
        highGain?: number;
    }
    type Quadrafuzz = BaseEffect & Required<QuadrafuzzOptions>;
    const Quadrafuzz: Quadrafuzz & { new(options?: QuadrafuzzOptions): Quadrafuzz };

    /**
     * The reverb effect is similar to the convolver effect in that it
     * allows the sound to be heard with a certain ressonance or
     * repercussion. This simulates a particular physical environment in
     * which the sound could be played (e.g., an auditorium, a concert
     * hall, etc).
     */
    interface ReverbOptions {
        /**
         * Duration of impulse, in seconds. min: 0.0001, max: 10,
         * defaults to 0.01.
         */
        time?: number;
        /**
         * The rate for the reflections of sound to fade away. min: 0,
         * max: 10, defaults to 0.01.
         */
        decay?: number;
        /** Whether or not to reverse the impulse shape. */
        reverse?: boolean;
        /**
         * Volume balance between the original audio and the effected
         * output. min: 0, max: 1, defaults to 0.5.
         */
        mix?: number;
    }
    type Reverb = BaseEffect & Required<ReverbOptions>;
    const Reverb: Reverb & { new(options?: ReverbOptions): Reverb };

    /**
     * The ring modulator effect combines two input signals, where one
     * of the inputs is a sine wave modulating the other.
     */
    interface RingModulatorOptions {
        /**
         * Level of distortion applied to the diode nodes. min: 0.2,
         * max: 50, defaults to 1.
         */
        distortion?: number;
        /**
         * The frequency of the modulating signal. min: 0, max: 2000,
         * defaults to 30.
         */
        speed?: number;
        /**
         * Volume balance between the original audio and the effected
         *  output. min: 0, max: 1, defaults to 0.5.
         */
        mix?: number;
    }
    type RingModulator = BaseEffect & Required<RingModulatorOptions>;
    const RingModulator: RingModulator & { new(options?: RingModulatorOptions): RingModulator };

    /**
     * The stereo panner is used to adjust the level of a sound through
     * the left and right speakers.
     */
    interface StereoPannerOptions {
        /**
         * Pan value between -1 (full left pan) and 1 (full right pan).
         * Defaults to zero.
         */
        pan?: number;
    }
    type StereoPanner = BaseEffect & Required<StereoPannerOptions>;
    const StereoPanner: StereoPanner & { new(options?: StereoPannerOptions): StereoPanner };

    /** The tremolo effect changes the volume of the sound over time. */
    interface TremoloOptions {
        /**
         * The speed at which the volume will change. min: 0, max: 20,
         * defaults to 4.
         */
        speed?: number;
        /** The intensity of the volume change. min: 0, max: 1, defaults to 1. */
        depth?: number;
        /**
         * Volume balance between the original audio and the effected
         * output. min: 0, max: 1, defaults to 0.5.
         */
        mix?: number;
    }
    type Tremolo = BaseEffect & Required<TremoloOptions>;
    const Tremolo: Tremolo & { new(options?: TremoloOptions): Tremolo };
}

export as namespace Pizzicato;
export as namespace Pz;
