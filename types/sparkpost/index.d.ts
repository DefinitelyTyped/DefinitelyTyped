// Type definitions for sparkpost 2.1
// Project: https://github.com/SparkPost/node-sparkpost
// Definitions by: Joshua DeVinney <https://github.com/geoffreak>, Bond <https://github.com/bondz>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped

/// <reference types="node"/>

import * as Request from "request";
import * as Http from "http";

declare class SparkPost {
    /** Specifying an inbound domain enables you to customize the address to which inbound messages are sent. */
    inboundDomains: {
        /**
         * List all your inbound domains.
         * @param callback The request callback with Domain results array
         */
        list(callback: SparkPost.ResultsCallback<SparkPost.Domain[]>): void;
        /**
         * List all your inbound domains.
         * @returns Promise The Domain results array
         */
        list(): SparkPost.ResultsPromise<SparkPost.Domain[]>;
        /**
         * Retrieve an inbound domain by specifying its domain name in the URI path.
         * @param domain Domain name
         * @param callback The request callback with Domain results
         */
        get(domain: string, callback: SparkPost.ResultsCallback<SparkPost.Domain>): void;
        /**
         * Retrieve an inbound domain by specifying its domain name in the URI path.
         * @param domain Domain name
         * @returns Promise The Domain results
         */
        get(domain: string): SparkPost.ResultsPromise<SparkPost.Domain>;
        /**
         * Create an inbound domain by providing an inbound domains object as the POST request body.
         * @param createOpts a hash of [inbound domain attributes]{@link https://developers.sparkpost.com/api/inbound-domains#header-inbound-domains-attributes}
         * @param callback The request callback
         */
        create(createOpts: SparkPost.CreateOpts, callback: SparkPost.Callback<void>): void;
        /**
         * Create an inbound domain by providing an inbound domains object as the POST request body.
         * @param createOpts a hash of [inbound domain attributes]{@link https://developers.sparkpost.com/api/inbound-domains#header-inbound-domains-attributes}
         * @returns Promise void
         */
        create(createOpts: SparkPost.CreateOpts): Promise<void>;
        /**
         * Delete an inbound domain by specifying its domain name in the URI path.
         * @param domain Domain name
         * @param callback The request callback
         */
        delete(domain: string, callback: SparkPost.Callback<void>): void;
        /**
         * Delete an inbound domain by specifying its domain name in the URI path.
         * @param domain Domain name
         * @returns Promise void
         */
        delete(domain: string): Promise<void>;
    };
    /** The Message Events API provides the means to search the raw events generated by SparkPost. */
    messageEvents: {
        /**
         * Retrieves list of message events according to given params
         * @param parameters Query parameters
         * @param callback The request callback with MessageEvent results array
         */
        search(parameters: SparkPost.MessageEventParameters, callback: SparkPost.ResultsCallback<SparkPost.MessageEvent[]>): void;
        /**
         * Retrieves list of message events according to given params
         * @param parameters Query parameters
         * @returns Promise The MessageEvent results array
         */
        search(parameters: SparkPost.MessageEventParameters): SparkPost.ResultsPromise<SparkPost.MessageEvent[]>;
    };
    /** A recipient list is a collection of recipients that can be used in a transmission. */
    recipientLists: {
        /**
         * List a summary of all recipient lists. The recipients for each list are not included in the results.
         * To retrieve recipient details, use the [Retrieve a Recipient List endpoint]{@link https://developers.sparkpost.com/api/recipient-lists.html#recipient-lists-retrieve-get},
         * and specify the recipient list.
         *
         * @param callback The request callback with RecipientList results array
         */
        list(callback: SparkPost.ResultsCallback<SparkPost.RecipientList[]>): void;
        /**
         * List a summary of all recipient lists. The recipients for each list are not included in the results.
         * To retrieve recipient details, use the [Retrieve a Recipient List endpoint]{@link https://developers.sparkpost.com/api/recipient-lists.html#recipient-lists-retrieve-get},
         * and specify the recipient list.
         *
         * @returns Promise The RecipientList results array
         */
        list(): SparkPost.ResultsPromise<SparkPost.RecipientList[]>;
        /**
         * Retrieve details about a specified recipient list by specifying its id in the URI path.
         * To retrieve the recipients contained in a list, the show_recipients parameter must be set to true.
         *
         * @param {string} id
         * @param {{ show_recipients?: boolean }} specifies whether to retrieve the recipients. Defaults to false
         * @param {SparkPost.Callback<SparkPost.RecipientListWithRecipients>} callback
         */
        get(id: string, options: { show_recipients?: boolean }, callback: SparkPost.Callback<SparkPost.RecipientListWithRecipients>): void;
        /**
         * Retrieve details about a specified recipient list by specifying its id in the URI path.
         * To retrieve the recipients contained in a list, the show_recipients parameter must be set to true.
         *
         * @param {string} id
         * @param {SparkPost.Callback<SparkPost.RecipientListWithRecipients>} callback
         */
        get(id: string, callback: SparkPost.Callback<SparkPost.RecipientListWithRecipients>): void;
        /**
         * Retrieve details about a specified recipient list by specifying its id in the URI path.
         * To retrieve the recipients contained in a list, the show_recipients parameter must be set to true.
         *
         * @param {string} id
         * @param {{ show_recipients?: boolean }} [options] specifies whether to retrieve the recipients. Defaults to false
         * @returns {Promise<SparkPost.RecipientListWithRecipients>}
         */
        get(id: string, options?: { show_recipients?: boolean }): SparkPost.ResultsPromise<SparkPost.RecipientListWithRecipients>;
        /**
         * Create a recipient list by providing a recipient list object as the POST request body.
         * At a minimum, the “recipients” array is required, which must contain a valid “address”.
         * If the recipient list “id” is not provided in the POST request body, one will be generated and returned in the results body.
         * Use the num_rcpt_errors parameter to limit the number of recipient errors returned.
         * @param options The create options
         * @param callback The request callback with metadata results
         */
        create(options: SparkPost.CreateRecipientList, callback: SparkPost.ResultsCallback<SparkPost.RecipientListMetadata>): void;
        /**
         * Create a recipient list by providing a recipient list object as the POST request body.
         * At a minimum, the “recipients” array is required, which must contain a valid “address”.
         * If the recipient list “id” is not provided in the POST request body, one will be generated and returned in the results body.
         * Use the num_rcpt_errors parameter to limit the number of recipient errors returned.
         * @param options The create options
         * @returns Promise metadata results
         */
        create(options: SparkPost.CreateRecipientList): SparkPost.ResultsPromise<SparkPost.RecipientListMetadata>;
        /**
         * Update an existing recipient list by specifying its ID in the URI path and use a recipient list object as the PUT request body.
         * Use the num_rcpt_errors parameter to limit the number of recipient errors returned.
         *
         * @param {string} id Identifier of the recipient list
         * @param options The update options
         * @param callback The request callback with metadata results
         */
        update(id: string, options: SparkPost.UpdateRecipientList, callback: SparkPost.ResultsCallback<SparkPost.RecipientListMetadata>): void;
        /**
         * Update an existing recipient list by specifying its ID in the URI path and use a recipient list object as the PUT request body.
         * Use the num_rcpt_errors parameter to limit the number of recipient errors returned.
         *
         * @param {string} id Identifier of the recipient list
         * @param {SparkPost.UpdateRecipientList} options
         * @returns {SparkPost.ResultsPromise<SparkPost.RecipientListMetadata>}
         */
        update(id: string, options: SparkPost.UpdateRecipientList): SparkPost.ResultsPromise<SparkPost.RecipientListMetadata>;
        /**
         * Permanently delete the specified recipient list.
         *
         * @param id The list id
         * @param callback The request callback
         */
        delete(id: string, callback: SparkPost.Callback<void>): void;
        /**
         * Permanently delete the specified recipient list.
         *
         * @param id The list id
         * @returns Promise void
         */
        delete(id: string): Promise<void>;
    };
    /** Relay Webhooks are a way to instruct SparkPost to accept inbound email on your behalf and forward it to you over HTTP for your own consumption. */
    relayWebhooks: {
        /**
         * List all your relay webhooks.
         * @param callback The request callback with RelayWebhook results array
         */
        list(callback: SparkPost.ResultsCallback<SparkPost.RelayWebhook[]>): void;
        /**
         * List all your relay webhooks.
         * @returns Promise The RelayWebhook results array
         */
        list(): SparkPost.ResultsPromise<SparkPost.RelayWebhook[]>;
        /**
         * Delete a relay webhook by specifying the webhook ID in the URI path.
         * @param relayWebhookId The webhook id
         * @param callback The request callback with RelayWebhook results
         */
        get(relayWebhookId: string, callback: SparkPost.ResultsCallback<SparkPost.RelayWebhook>): void;
        /**
         * Delete a relay webhook by specifying the webhook ID in the URI path.
         * @param relayWebhookId The webhook id
         * @returns Promise The RelayWebhook results
         */
        get(relayWebhookId: string): SparkPost.ResultsPromise<SparkPost.RelayWebhook>;
        /**
         * Create a relay webhook by providing a relay webhooks object as the POST request body.
         * @param options The create options
         * @param callback The request callback with webhook id results
         */
        create(options: SparkPost.RelayWebhook, callback: SparkPost.ResultsCallback<{ id: string }>): void;
        /**
         * Create a relay webhook by providing a relay webhooks object as the POST request body.
         * @param options The create options
         * @returns Promise The webhook id results
         */
        create(options: SparkPost.RelayWebhook): SparkPost.ResultsPromise<{ id: string }>;
        /**
         * Update a relay webhook by specifying the webhook ID in the URI path.
         * @param options The update options
         * @param callback The request callback with webhook id results
         */
        update(id: string, options: SparkPost.UpdateRelayWebhook, callback: SparkPost.ResultsCallback<{ id: string }>): void;
        /**
         * Update a relay webhook by specifying the webhook ID in the URI path.
         * @param options The update options
         * @returns Promise The webhook id results
         */
        update(id: string, options: SparkPost.UpdateRelayWebhook): SparkPost.ResultsPromise<{ id: string }>;
        /**
         * Delete a relay webhook by specifying the webhook ID in the URI path.
         * @param relayWebhookId The webhook id
         * @param callback The request callback
         */
        delete(relayWebhookId: string, callback: SparkPost.Callback<void>): void;
        /**
         * Delete a relay webhook by specifying the webhook ID in the URI path.
         * @param relayWebhookId The webhook id
         * @returns Promise void
         */
        delete(relayWebhookId: string): Promise<void>;
    };
    sendingDomains: {
        /**
         * List an overview of all sending domains in the system.
         * @param callback The request callback with SendingDomain results array
         */
        list(callback: SparkPost.ResultsCallback<SparkPost.SendingDomain[]>): void;
        /**
         * List an overview of all sending domains in the system.
         *
         * @returns The SendingDomain results array
         */
        list(): SparkPost.ResultsPromise<SparkPost.SendingDomain[]>;
        /**
         * Retrieve a sending domain by specifying its domain name in the URI path. The response includes details about its DKIM key configuration.
         * @param domain The domain
         * @param callback The request callback with SendingDomain results
         */
        get(domain: string, callback: SparkPost.ResultsCallback<SparkPost.SendingDomain>): void;
        /**
         * Retrieve a sending domain by specifying its domain name in the URI path. The response includes details about its DKIM key configuration.
         *
         * @param domain The domain
         * @returns Promise The SendingDomain results
         */
        get(domain: string): SparkPost.ResultsPromise<SparkPost.SendingDomain>;
        /**
         * Create a sending domain by providing a sending domain object as the POST request body.
         * @param options The create options
         * @param callback The request callback with basic info results
         */
        create(options: SparkPost.CreateSendingDomain, callback: SparkPost.ResultsCallback<{ message: string, domain: string }>): void;
        /**
         * Create a sending domain by providing a sending domain object as the POST request body.
         *
         * @param options The create options
         * @returns Promise The basic info results
         */
        create(options: SparkPost.CreateSendingDomain): SparkPost.ResultsPromise<{ message: string, domain: string }>;
        /**
         * Update the attributes of an existing sending domain by specifying its domain name in the URI path and use a sending domain object as the PUT request body.
         * @param domain The domain
         * @param updateOpts The update options
         * @param callback The request callback with basic info results
         */
        update(domain: string, updateOpts: SparkPost.UpdateSendingDomain, callback: SparkPost.ResultsCallback<{ message: string, domain: string }>): void;
        /**
         * Update the attributes of an existing sending domain by specifying its domain name in the URI path and use a sending domain object as the PUT request body.
         *
         * @param domain The domain
         * @param updateOpts The update options
         * @returns Promise The basic info results
         */
        update(domain: string, updateOpts: SparkPost.UpdateSendingDomain): SparkPost.ResultsPromise<{ message: string, domain: string }>;
        /**
         * Delete an existing sending domain.
         * @param domain The domain
         * @param callback The request callback
         */
        delete(domain: string, callback: SparkPost.Callback<void>): void;
        /**
         * Delete an existing sending domain.
         *
         * @param domain The domain
         * @returns Promise void
         */
        delete(domain: string): Promise<void>;
        /**
         * Verify a Sending Domain
         * @param domain The domain
         * @param options a hash of [verify attributes]{@link https://developers.sparkpost.com/api/sending-domains#header-verify-attributes}
         * @param callback The request callback with verify results
         */
        verify(domain: string, options: SparkPost.VerifyOptions, callback: SparkPost.ResultsCallback<SparkPost.VerifyResults>): void;
        /**
         * Verify a Sending Domain
         *
         * @param domain The domain
         * @param options a hash of [verify attributes]{@link https://developers.sparkpost.com/api/sending-domains#header-verify-attributes}
         * @returns Promise The verify results
         */
        verify(domain: string, options: SparkPost.VerifyOptions): SparkPost.ResultsPromise<SparkPost.VerifyResults>;
    };
    subaccounts: {
        /**
         * Endpoint for retrieving a list of your subaccounts.
         * This endpoint only returns information about the subaccounts themselves, not the data associated with the subaccount.
         * @param callback The request callback with subaccount information results array
         */
        list(callback: SparkPost.ResultsCallback<SparkPost.SubaccountInformation[]>): void;
        /**
         * Endpoint for retrieving a list of your subaccounts.
         * This endpoint only returns information about the subaccounts themselves, not the data associated with the subaccount.
         *
         * @returns Promise The subaccount information results array
         */
        list(): SparkPost.ResultsPromise<SparkPost.SubaccountInformation[]>;
        /**
         * Get details about a specified subaccount by its id
         *
         * @param id the id of the subaccount you want to look up
         * @param callback The request callback with subaccount information results
         */
        get(id: string | number, callback: SparkPost.ResultsCallback<SparkPost.SubaccountInformation>): void;
        /**
         * Get details about a specified subaccount by its id
         *
         * @param id the id of the subaccount you want to look up
         * @returns Promise The subaccount information results
         */
        get(id: string | number): SparkPost.ResultsPromise<SparkPost.SubaccountInformation>;
        /**
         * Provisions a new subaccount and an initial subaccount API key.
         * @param subaccount The create options
         * @param callback The request callback with basic subaccount information results
         */
        create(subaccount: SparkPost.CreateSubaccount, callback: SparkPost.ResultsCallback<SparkPost.CreateSubaccountResponse>): void;
        /**
         * Provisions a new subaccount and an initial subaccount API key.
         *
         * @param subaccount The create options
         * @returns Promise The basic subaccount information results
         */
        create(subaccount: SparkPost.CreateSubaccount): SparkPost.ResultsPromise<SparkPost.CreateSubaccountResponse>;
        /**
         * Update an existing subaccount’s information.
         *
         * @param id the id of the subaccount you want to update
         * @param subaccount an object of [updatable subaccount attributes]{@link https://developers.sparkpost.com/api/subaccounts#header-request-body-attributes-1}
         * @param callback The request callback with webhook id results
         */
        update(id: string, subaccount: SparkPost.UpdateSubaccount, callback: SparkPost.ResultsCallback<{ message: string }>): void;
        /**
         * Update an existing subaccount’s information.
         *
         * @param id the id of the subaccount you want to update
         * @param subaccount an object of [updatable subaccount attributes]{@link https://developers.sparkpost.com/api/subaccounts#header-request-body-attributes-1}
         * @returns Promise The webhook id results
         */
        update(id: string, subaccount: SparkPost.UpdateSubaccount): SparkPost.ResultsPromise<{ message: string }>;
    };
    suppressionList: {
        /**
         * List all entries in your suppression list, filtered by an optional set of search parameters.
         *
         * @param {SparkPost.ResultsCallback<SparkPost.SupressionListEntry[]>} callback The request callback with supression lists.
         */
        list(callback: SparkPost.ResultsCallback<SparkPost.SupressionListEntry[]>): void;
        /**
         * List all entries in your suppression list, filtered by an optional set of search parameters.
         *
         * @param {SparkPost.SupressionSearchParameters} parameters an object of [search parameters]{@link https://developers.sparkpost.com/api/suppression-list#suppression-list-search-get}
         * @param {SparkPost.ResultsCallback<SparkPost.SupressionListEntry[]>} callback The request callback with supression lists.
         */
        list(parameters: SparkPost.SupressionSearchParameters, callback: SparkPost.ResultsCallback<SparkPost.SupressionListEntry[]>): void;
        /**
         * List all entries in your suppression list, filtered by an optional set of search parameters.
         *
         * @param {SparkPost.SupressionSearchParameters} [parameters] an object of [search parameters]{@link https://developers.sparkpost.com/api/suppression-list#suppression-list-search-get}
         * @returns {Promise<SparkPost.SupressionListEntry[]>} Promise The supression lists
         */
        list(parameters?: SparkPost.SupressionSearchParameters): SparkPost.ResultsPromise<SparkPost.SupressionListEntry[]>;
        /**
         * Retrieve an entry by recipient email.
         *
         * @param {string} email address to check
         * @returns void
         */
        get(email: string, callback: SparkPost.ResultsCallback<SparkPost.SupressionListEntry[]>): void;
        /**
         * Retrieve an entry by recipient email.
         *
         * @param {string} email address to check
         * @returns void
         */
        get(email: string): SparkPost.ResultsPromise<SparkPost.SupressionListEntry[]>;
        /**
         * Delete a recipient from the list by specifying the recipient’s email address in the URI path.
         *
         * @param {string} email Recipient email address
         * @param callback
         */
        delete(email: string, callback: SparkPost.Callback<void>): void;
        /**
         * Delete a recipient from the list by specifying the recipient’s email address in the URI path.
         *
         * @param {string} email Recipient email address
         * @returns {Promise<void>} void
         */
        delete(email: string): Promise<void>;
        /**
         * Insert or update one or many entries.
         *
         * @param listEntries The suppression entry list
         * @param callback The request callback
         */
        upsert(listEntries: SparkPost.CreateSupressionListEntry | SparkPost.CreateSupressionListEntry[], callback: SparkPost.ResultsCallback<{ message: string }>): void;
        /**
         * Insert or update one or many entries.
         *
         * @param {(SparkPost.CreateSupressionListEntry | SparkPost.CreateSupressionListEntry[])} listEntries The suppression entry list
         * @returns {Promise<{ message: string }>}
         */
        upsert(listEntries: SparkPost.CreateSupressionListEntry | SparkPost.CreateSupressionListEntry[]): SparkPost.ResultsPromise<{ message: string }>;
    };
    templates: {
        /**
         * List a summary of all templates.
         * @param callback The request callback with TemplateMeta results array
         */
        list(callback: SparkPost.ResultsCallback<SparkPost.TemplateMeta[]>): void;
        /**
         * List a summary of all templates.
         *
         * @returns {SparkPost.ResultsPromise<SparkPost.TemplateMeta[]>} The TemplateMeta results array
         */
        list(): SparkPost.ResultsPromise<SparkPost.TemplateMeta[]>;
        /**
         * Retrieve details about a specified template by its id
         *
         * @param id the id of the template you want to look up
         * @param options specifies a draft or published template
         * @param callback The request callback with Template results
         */
        get(id: string, options: { draft?: boolean }, callback: SparkPost.ResultsCallback<SparkPost.Template>): void;
        /**
         * Retrieve details about a specified template by its id
         *
         * @param {string} id the id of the template you want to look up
         * @param {SparkPost.ResultsCallback<SparkPost.Template>} callback The request callback with Template results
         */
        get(id: string, callback: SparkPost.ResultsCallback<SparkPost.Template>): void;
        /**
         * Retrieve details about a specified template by its id
         *
         * @param {string} id the id of the template you want to look up
         * @param {{ draft?: boolean }} [options] specifies a draft or published template
         * @returns {SparkPost.ResultsPromise<SparkPost.Template>} The Template results
         */
        get(id: string, options?: { draft?: boolean }): SparkPost.ResultsPromise<SparkPost.Template>;
        /**
         * Create a new template
         *
         * @param template an object of [template attributes]{@link https://developers.sparkpost.com/api/templates#header-template-attributes}
         * @param callback The request callback with template id results
         */
        create(template: SparkPost.CreateTemplate, callback: SparkPost.ResultsCallback<{ id: string }>): void;
        /**
         * Create a new template
         *
         * @param {SparkPost.CreateTemplate} template an object of [template attributes]{@link https://developers.sparkpost.com/api/templates#header-template-attributes}
         * @returns {SparkPost.ResultsPromise<{ id: string }>} The template id results
         */
        create(template: SparkPost.CreateTemplate): SparkPost.ResultsPromise<{ id: string }>;
        /**
         * Update an existing template
         *
         * @param {string} id the id of the template you want to update
         * @param template an object of [template attributes]{@link https://developers.sparkpost.com/api/templates#header-template-attributes}
         * @param options The create options. If true, directly overwrite the existing published template. If false, create a new draft
         * @param callback The request callback with template id results
         */
        update(
            id: string,
            template: SparkPost.UpdateTemplate,
            options: { update_published?: boolean },
            callback: SparkPost.ResultsCallback<{ id: string }>): void;
        /**
         * Update an existing template
         *
         * @param {string} id the id of the template you want to update
         * @param {SparkPost.UpdateTemplate} template an object of [template attributes]{@link https://developers.sparkpost.com/api/templates#header-template-attributes}
         * @param {SparkPost.ResultsCallback<{ id: string }>} callback The request callback with template id results
         */
        update(
            id: string,
            template: SparkPost.UpdateTemplate,
            callback: SparkPost.ResultsCallback<{ id: string }>): void;
        /**
         * Update an existing template
         *
         * @param {string} id the id of the template you want to update
         * @param {SparkPost.UpdateTemplate} template an object of [template attributes]{@link https://developers.sparkpost.com/api/templates#header-template-attributes}
         * @param {{
         *             update_published?: boolean;
         *         }} [options] If true, directly overwrite the existing published template. If false, create a new draft
         * @returns {SparkPost.ResultsPromise<{ id: string }>} The template id results
         */
        update(id: string, template: SparkPost.UpdateTemplate, options?: {
            update_published?: boolean;
        }): SparkPost.ResultsPromise<{ id: string }>;
        /**
         * Delete an existing template
         * @param id The template id
         * @param callback The request callback
         */
        delete(id: string, callback: SparkPost.Callback<void>): void;
        /**
         * Delete an existing template
         *
         * @param id The template id
         * @returns Promise void
         */
        delete(id: string): Promise<void>;
        /**
         * Preview the most recent version of an existing template by id
         *
         * @param {string} id the id of the template you want to look up
         * @param options The preview options
         * @param callback The request callback with webhook id results
         */
        preview(id: string, options: { substitution_data?: any, draft?: boolean }, callback: SparkPost.ResultsCallback<SparkPost.TemplateContent>): void;
        /**
         * Preview the most recent version of an existing template by id
         *
         * @param {string} id the id of the template you want to look up
         * @param {SparkPost.ResultsCallback<SparkPost.TemplateContent>} callback The request callback with webhook id results
         */
        preview(id: string, callback: SparkPost.ResultsCallback<SparkPost.TemplateContent>): void;
        /**
         * Preview the most recent version of an existing template by id
         *
         * @param {string} id the id of the template you want to look up
         * @param {{ substitution_data: any, draft?: boolean }} [options]
         * @returns {SparkPost.ResultsPromise<SparkPost.TemplateContent>} The webhook id results
         */
        preview(id: string, options?: { substitution_data?: any, draft?: boolean }): SparkPost.ResultsPromise<SparkPost.TemplateContent>;
    };
    transmissions: {
        /**
         * List an overview of all transmissions in the account
         *
         * @param callback The request callback with Transmission results array
         */
        list(callback: SparkPost.ResultsCallback<SparkPost.TransmissionSummary[]>): void;
        /**
         * List an overview of all transmissions in the account
         *
         * @param {{ campaign_id?: string, template_id: string }} options
         * @param {SparkPost.ResultsCallback<SparkPost.TransmissionSummary[]>} callback The request callback with Transmission results array
         */
        list(options: { campaign_id?: string, template_id?: string }, callback: SparkPost.ResultsCallback<SparkPost.TransmissionSummary[]>): void;
        /**
         * List an overview of all transmissions in the account
         *
         * @param {{ campaign_id?: string, template_id: string }} [options]
         * @returns {SparkPost.ResultsPromise<SparkPost.TransmissionSummary[]>} The Transmission results array
         */
        list(options?: { campaign_id?: string, template_id?: string }): SparkPost.ResultsPromise<SparkPost.TransmissionSummary[]>;
        /**
         * Retrieve the details about a transmission by its ID
         *
         * @param id The id of the transmission you want to look up
         * @param callback The request callback with Transmission results
         */
        get(transmissionID: string, callback: SparkPost.ResultsCallback<SparkPost.Transmission>): void;
        /**
         * Retrieve the details about a transmission by its ID
         *
         * @param {string} id The id of the transmission you want to look up
         * @returns {SparkPost.ResultsPromise<SparkPost.Transmission>} The Transmission results
         */
        get(id: string): SparkPost.ResultsPromise<SparkPost.Transmission>;
        /**
         * Sends a message by creating a new transmission
         *
         * @param transmission an object of [transmission attributes]{@link https://developers.sparkpost.com/api/transmissions#header-transmission-attributes}
         * @param options The create options. Specify maximum number of recipient errors returned
         * @param callback The request callback with metadata and id results
         */
        send(transmission: SparkPost.CreateTransmission, options: { num_rcpt_errors?: number }, callback: SparkPost.ResultsCallback<{
            total_rejected_recipients: number;
            total_accepted_recipients: number;
            id: string;
        }>): void;
        /**
         *
         *
         * @param {SparkPost.CreateTransmission} transmission an object of [transmission attributes]{@link https://developers.sparkpost.com/api/transmissions#header-transmission-attributes}
         * @param {SparkPost.ResultsCallback<{
         *             total_rejected_recipients: number;
         *             total_accepted_recipients: number;
         *             id: string;
         *         }>} callback The request callback with metadata and id results
         */
        send(transmission: SparkPost.CreateTransmission, callback: SparkPost.ResultsCallback<{
            total_rejected_recipients: number;
            total_accepted_recipients: number;
            id: string;
        }>): void;
        /**
         * Sends a message by creating a new transmission
         *
         * @param {SparkPost.CreateTransmission} transmission an object of [transmission attributes]{@link https://developers.sparkpost.com/api/transmissions#header-transmission-attributes}
         * @param {{ num_rcpt_errors?: number }} [options] specify maximum number of recipient errors returned
         * @returns {SparkPost.ResultsPromise<{
         *             total_rejected_recipients: number;
         *             total_accepted_recipients: number;
         *             id: string;
         *         }>} The metadata and id results
         */
        send(transmission: SparkPost.CreateTransmission, options?: { num_rcpt_errors?: number }): SparkPost.ResultsPromise<{
            total_rejected_recipients: number;
            total_accepted_recipients: number;
            id: string;
        }>;
    };
    webhooks: {
        /**
         * List currently existing webhooks.
         * @param callback The request callback with RelayWebhook results array
         */
        list(callback: SparkPost.ResultsCallback<Array<SparkPost.WebhookLinks & SparkPost.Webhook>>): void;
        /**
         * List currently existing webhooks.
         * @param options Object containing optional timezone
         * @param callback The request callback with RelayWebhook results array
         */
        list(options: { timezone?: string }, callback: SparkPost.ResultsCallback<Array<SparkPost.WebhookLinks & SparkPost.Webhook>>): void;
        /**
         * List currently existing webhooks.the timezone to use for the last_successful and last_failure properties | Default: UTC
         *
         * @param {{ timezone?: string }} [options]
         * @returns {(SparkPost.ResultsPromise<Array<SparkPost.WebhookLinks & SparkPost.Webhook>>)}
         */
        list(options?: { timezone?: string }): SparkPost.ResultsPromise<Array<SparkPost.WebhookLinks & SparkPost.Webhook>>;
        /**
         * Retrieve details about a specified webhook by its id
         *
         * @param {string} id The id of the webhook to get
         * @param options Object containing id and optional timezone
         * @param callback The request callback with RelayWebhook results
         */
        get(id: string, options: { timezone?: string }, callback: SparkPost.ResultsCallback<SparkPost.WebhookLinks & SparkPost.Webhook>): void;
        /**
         * Retrieve details about a specified webhook by its id
         *
         * @param {string} id The id of the webhook to get
         * @param {(SparkPost.ResultsCallback<SparkPost.WebhookLinks & SparkPost.Webhook>)} callback The request callback with RelayWebhook results
         */
        get(id: string, callback: SparkPost.ResultsCallback<SparkPost.WebhookLinks & SparkPost.Webhook>): void;
        /**
         * Retrieve details about a specified webhook by its id
         *
         * @param {string} id The id of the webhook to get
         * @param {{ timezone?: string }} [options] the timezone to use for the last_successful and last_failure properties
         * @returns {(SparkPost.ResultsPromise<SparkPost.WebhookLinks & SparkPost.Webhook>)} The RelayWebhook results
         */
        get(id: string, options?: { timezone?: string }): SparkPost.ResultsPromise<SparkPost.WebhookLinks & SparkPost.Webhook>;
        /**
         * Create a new webhook
         *
         * @param options a hash of [webhook attributes]{@link https://developers.sparkpost.com/api/webhooks#header-webhooks-object-properties}
         * @param callback The request callback with webhook id results
         */
        create(options: SparkPost.Webhook, callback: SparkPost.ResultsCallback<SparkPost.WebhookLinks & { id: string }>): void;
        /**
         * Create a new webhook
         *
         * @param {SparkPost.Webhook} options a hash of [webhook attributes]{@link https://developers.sparkpost.com/api/webhooks#header-webhooks-object-properties}
         * @returns {(SparkPost.ResultsPromise<SparkPost.WebhookLinks & { id: string }>)} The webhook id results
         */
        create(options: SparkPost.Webhook): SparkPost.ResultsPromise<SparkPost.WebhookLinks & { id: string }>;
        /**
         * Update an existing webhook
         * @param {string} id the id of the webhook to update
         * @param options A hash of [webhook attribues]{@link https://developers.sparkpost.com/api/webhooks#header-webhooks-object-properties}
         * @param callback The request callback with webhook id results
         */
        update(id: string, options: SparkPost.UpdateWebhook, callback: SparkPost.ResultsCallback<SparkPost.WebhookLinks & { id: string }>): void;
        /**
         * Update an existing webhook
         *
         * @param {string} id
         * @param {SparkPost.UpdateWebhook} options
         * @returns {(SparkPost.ResultsPromise<SparkPost.WebhookLinks & { id: string }>)}
         */
        update(id: string, options: SparkPost.UpdateWebhook): SparkPost.ResultsPromise<SparkPost.WebhookLinks & { id: string }>;
        /**
         * Delete an existing webhook
         * @param id The webhook id
         * @param callback The request callback
         */
        delete(id: string, callback: SparkPost.Callback<void>): void;
        /**
         * Delete an existing webhook.
         *
         * @param {string} id The id of the webhook to delete
         * @returns {Promise<void>}
         */
        delete(id: string): Promise<void>;
        /**
         * Sends an example message event batch from the Webhook API to the target URL
         *
         * @param {string} id The id of the webhook to validate
         * @param options the message (payload) to send to the webhook consumer
         * @param callback The request callback with validation results
         */
        validate(id: string, options: { message: any }, callback: SparkPost.ResultsCallback<{
            msg: string;
            response: {
                status: number;
                headers: any;
                body: string;
            }
        }>): void;
        /**
         * Sends an example message event batch from the Webhook API to the target URL.
         *
         * @param {string} id The id of the webhook to validate
         * @param {{ message: any }} options The message (payload) to send to the webhook consumer
         * @returns {SparkPost.ResultsPromise<{
         *             msg: string;
         *             response: {
         *                 status: number;
         *                 headers: any;
         *                 body: string;
         *             }
         *         }>} The validation results
         */
        validate(id: string, options: { message: any }): SparkPost.ResultsPromise<{
            msg: string;
            response: {
                status: number;
                headers: any;
                body: string;
            }
        }>;
        /**
         * Gets recent status information about a webhook.
         *
         * @param {string} id The id of the webhook
         * @param options  An optional limit that specifies the maximum number of results to return. Defaults to 1000
         * @param callback The request callback with status results
         */
        getBatchStatus(id: string, options: { limit?: number }, callback: SparkPost.ResultsCallback<Array<{
            batch_id: string;
            ts: string;
            attempts: number;
            response_code: number;
        }>>): void;
        /**
         * Gets recent status information about a webhook.
         *
         * @param {string} id The id of the webhook
         * @param {SparkPost.ResultsCallback<{
         *             batch_id: string;
         *             ts: string;
         *             attempts: number;
         *             response_code: number;
         *         }[]>} callback The request callback with status results
         */
        getBatchStatus(id: string, callback: SparkPost.ResultsCallback<Array<{
            batch_id: string;
            ts: string;
            attempts: number;
            response_code: number;
        }>>): void;
        /**
         * Gets recent status information about a webhook.
         *
         * @param {string} id The id of the webhook
         * @param {{ limit?: number }} Maximum number of results to return. Defaults to 1000
         * @returns {SparkPost.ResultsPromise<{
         *             batch_id: string;
         *             ts: string;
         *             attempts: number;
         *             response_code: number;
         *         }[]>} The status results
         */
        getBatchStatus(id: string, options: { limit?: number }): SparkPost.ResultsPromise<Array<{
            batch_id: string;
            ts: string;
            attempts: number;
            response_code: number;
        }>>;
        /**
         * Lists descriptions of the events, event types, and event fields that could be included in a Webhooks post to your target URL.
         * @param callback The request callback containing documentation results
         */
        getDocumentation(callback: SparkPost.ResultsCallback<any>): void;
        /**
         * Lists descriptions of the events, event types, and event fields that could be included in a Webhooks post to your target URL.
         *
         * @returns {SparkPost.ResultsPromise<any>} The documentation results
         */
        getDocumentation(): SparkPost.ResultsPromise<any>;
        /**
         * List an example of the event data that will be posted by a Webhook for the specified events.
         * @param callback The request callback containing examples
         */
        getSamples(callback: SparkPost.Callback<any>): void;
        /**
         * List an example of the event data that will be posted by a Webhook for the specified events.
         * @param options The optional event name
         * @param callback The request callback containing examples
         */
        getSamples(options: { events?: string }, callback: SparkPost.Callback<any>): void;
        /**
         * List an example of the event data that will be posted by a Webhook for the specified events.
         *
         * @param {{ events?: string }} options [event types]{@link https://support.sparkpost.com/customer/portal/articles/1976204} for which to get a sample payload
         * Default: all event types returned
         * @returns {Promise<SparkPost.Response<any>>}
         */
        getSamples(options?: { events?: string }): Promise<SparkPost.Response<any>>;
    };

    /**
     * The official Node.js binding for your favorite SparkPost APIs!
     * @param apiKey A passed in apiKey will take precedence over an environment variable
     * @param options Additional options
     */
    constructor(apiKey?: string, options?: SparkPost.ConstructorOptions);

    request(options: Request.Options, callback: SparkPost.Callback<any>): void;
    request(options: Request.Options): Promise<SparkPost.Response<any>>;
    get(options: Request.Options, callback: SparkPost.Callback<any>): void;
    get(options: Request.Options): Promise<SparkPost.Response<any>>;
    post(options: Request.Options, callback: SparkPost.Callback<any>): void;
    post(options: Request.Options): Promise<SparkPost.Response<any>>;
    put(options: Request.Options, callback: SparkPost.Callback<any>): void;
    put(options: Request.Options): Promise<SparkPost.Response<any>>;
    delete(options: Request.Options, callback: SparkPost.Callback<any>): void;
    delete(options: Request.Options): Promise<SparkPost.Response<any>>;
}

declare namespace SparkPost {
    interface ErrorWithDescription {
        message: string;
        code: string;
        description: string;
    }
    interface ErrorWithParam {
        message: string;
        param: string;
        value: string | null;
    }
    interface SparkPostError extends Error {
        name: "SparkPostError";
        errors: ErrorWithDescription[] | ErrorWithParam[];
        statusCode: number;
    }

    interface ConstructorOptions {
        origin?: string;
        endpoint?: string;
        apiVersion?: string;
        headers?: any;
    }

    interface Response<T> extends Http.IncomingMessage {
        body: T;
    }
    type Callback<T> = (err: Error | SparkPostError | null, res: Response<T>) => void;
    type ResultsCallback<T> = Callback<{ results: T }>;
    type ResultsPromise<T> = Promise<{ results: T }>;

    interface Domain {
        domain: string;
    }

    interface MessageEvent {
        /** Type of event this record describes */
        type: string;
        /** Classification code for a given message (see [Bounce Classification Codes](https://support.sparkpost.com/customer/portal/articles/1929896)) */
        bounce_class: string;
        /** Campaign of which this message was a part */
        campaign_id: string;
        /** SparkPost-customer identifier through which this message was sent */
        customer_id: string;
        /** Protocol by which SparkPost delivered this message */
        delv_method: string;
        /** Token of the device / application targeted by this PUSH notification message. Applies only when delv_method is gcm or apn. */
        device_token: string;
        /** Error code by which the remote server described a failed delivery attempt */
        error_code: string;
        /** IP address of the host to which SparkPost delivered this message; in engagement events, the IP address of the host where the HTTP request originated */
        ip_address: string;
        /** SparkPost-cluster-wide unique identifier for this message */
        message_id: string;
        /** Sender address used on this message"s SMTP envelope */
        msg_from: string;
        /** Message"s size in bytes */
        msg_size: string;
        /** Number of failed attempts before this message was successfully delivered; when the first attempt succeeds, zero */
        num_retries: string;
        /** Metadata describing the message recipient */
        rcpt_meta: any;
        /** Tags applied to the message which generated this event */
        rcpt_tags: string[];
        /** Recipient address used on this message"s SMTP envelope */
        rcpt_to: string;
        /** Indicates that a recipient address appeared in the Cc or Bcc header or the archive JSON array */
        rcpt_type: string;
        /** Unmodified, exact response returned by the remote server due to a failed delivery attempt */
        raw_reason: string;
        /** Canonicalized text of the response returned by the remote server due to a failed delivery attempt */
        reason: string;
        /** Domain receiving this message */
        routing_domain: string;
        /** Subject line from the email header */
        subject: string;
        /** Slug of the template used to construct this message */
        template_id: string;
        /** Version of the template used to construct this message */
        template_version: string;
        /** Event date and time formatted as: YYYY-MM-DDTHH:MM:SS.SSS±hh:mm */
        timestamp: string;
        /** Transmission which originated this message */
        transmission_id: string;
    }

    interface MessageEventParameters {
        /** delimited list of bounce classification codes to search. (See Bounce Classification Codes.) */
        bounce_classes?: Array<string | number> | string | number;
        /** delimited list of campaign ID’s to search (i.e. the campaign id used during creation of a transmission). */
        campaign_ids?: string[] | string;
        /** Specifies the delimiter for query parameter lists */
        delimiter?: string;
        /** delimited list of event types to search. Defaults to all event types. */
        events?: string[] | string;
        /** delimited list of friendly from emails to search. */
        friendly_froms?: string[] | string;
        /** Datetime in format of YYYY-MM-DDTHH:MM. */
        from?: string;
        /** delimited list of message ID’s to search. */
        message_ids?: string[] | string;
        /** The results page number to return. Used with per_page for paging through results. */
        page?: number;
        /** Number of results to return per page. Must be between 1 and 10,000 (inclusive). */
        per_page?: number;
        /** Bounce/failure/rejection reason that will be matched using a wildcard (e.g., %reason%). */
        reason?: string[] | string;
        /** delimited list of recipients to search. */
        recipients?: string[] | string;
        /** delimited list of subaccount ID’s to search. */
        subaccounts?: number[] | number;
        /** delimited list of template ID’s to search. */
        template_ids?: string[] | string;
        /** Standard timezone identification string. */
        timezone?: string;
        /** Datetime in format of YYYY-MM-DDTHH:MM. */
        to?: string;
        /** delimited list of transmission ID’s to search (i.e. id generated during creation of a transmission). */
        transmission_ids?: string[] | string;
    }

    interface RecipientListMetadata {
        total_rejected_recipients: number;
        total_accepted_recipients: number;
        id: string;
        name: string;
    }

    interface RecipientList {
        /** Short, unique, recipient list identifier */
        id: string;
        /** Short, pretty/readable recipient list display name, not required to be unique */
        name: string;
        /** Detailed description of the recipient list */
        description: string;
        /** Recipient list attribute object */
        attributes: any;
        /** Number of accepted recipients */
        total_accepted_recipients: number;
    }
    interface RecipientListWithRecipients extends RecipientList {
        /** Array of recipient objects */
        recipients: Recipient[];
    }

    interface CreateRecipientList {
        /** Short, unique, recipient list identifier */
        id?: string;
        /** Short, pretty/readable recipient list display name, not required to be unique */
        name?: string;
        /** Detailed description of the recipient list */
        description?: string;
        /** Recipient list attribute object */
        attributes?: any;
        /** limit the number of recipient errors returned. */
        num_rcpt_errors?: number;
        /** Array of recipient objects */
        recipients: Recipient[];
    }
    interface UpdateRecipientList {
        /** Short, unique, recipient list identifier */
        id?: string;
        /** Short, pretty/readable recipient list display name, not required to be unique */
        name?: string;
        /** Detailed description of the recipient list */
        description?: string;
        /** Recipient list attribute object */
        attributes?: any;
        /** Array of recipient objects */
        recipients: Recipient[];
    }

    interface BaseRecipient {
        /** SparkPost Enterprise API only. Email to use for envelope FROM. */
        return_path?: string;
        /** Array of text labels associated with a recipient. */
        tags?: string[];
        /** Key/value pairs associated with a recipient. */
        metadata?: any;
        /** Key/value pairs associated with a recipient that are provided to the substitution engine. */
        substitution_data?: any;
    }
    interface RecipientWithAddress {
        /** Address information for a recipient  At a minimum, address or multichannel_addresses is required. */
        address: Address | string;
    }
    interface RecipientWithMultichannelAddresses {
        /**
         * Address information for a recipient. At a minimum, address or multichannel_addresses is required.
         * If both address and multichannel_addresses are specified only multichannel_addresses will be used.
         *
         * @type {(Address | string)}
         * @memberOf RecipientWithMultichannelAddresses
         */
        address?: Address | string;
        /**
         * Array of Multichannel Address objects for a recipient. At a minimum, address or multichannel_addresses is required.
         * If both address and multichannel_addresses are specified only multichannel_addresses will be used.
         *
         * @type {MultichannelAddress[]}
         * @memberOf RecipientWithMultichannelAddresses
         */
        multichannel_addresses: MultichannelAddress[];
    }
    type Recipient = (RecipientWithAddress | RecipientWithMultichannelAddresses) & BaseRecipient;

    interface Address {
        /** Valid email address */
        email: string;
        /** User-friendly name for the email address */
        name?: string;
        /** Email address to display in the “To” header instead of address.email (for CC and BCC) */
        header_to?: string;
    }

    interface MultichannelAddress {
        /** The communication channel used to reach recipient. Valid values are “email”, “gcm”, “apns”. */
        channel: string;
        /** Valid email address. Required if channel is “email”. */
        email: string;
        /** User-friendly name for the email address. Used when channel is “email” */
        name: string;
        /** Email address to display in the “To” header instead of address.email (for BCC). Used when channel is “email” */
        header_to: string;
        /** SparkPost Enterprise API only. Required if channel is “gcm” or “apns” */
        token: string;
        /** SparkPost Enterprise API only. Required if channel is “gcm” or “apns” */
        app_id: string;
    }

    interface RelayWebhook {
        /** User-friendly name  no  example: Inbound Customer Replies */
        name?: string;
        /** URL of the target to which to POST relay batches */
        target: string;
        /** Authentication token to present in the X-MessageSystems-Webhook-Token header of POST requests to target */
        auth_token?: string;
        /** Restrict which inbound messages will be relayed to the target */
        match: Match;
    }

    interface UpdateRelayWebhook {
        /** User-friendly name  no  example: Inbound Customer Replies */
        name?: string;
        /** URL of the target to which to POST relay batches */
        target: string;
        /** Authentication token to present in the X-MessageSystems-Webhook-Token header of POST requests to target */
        auth_token?: string;
        /** Restrict which inbound messages will be relayed to the target */
        match?: Match;
    }

    interface Match {
        /** Inbound messaging protocol associated with this webhook. Defaults to “SMTP” */
        protocol?: string;
        /** Inbound domain associated with this webhook. Required when protocol is “SMTP”. */
        domain?: string;
        /** ESME address binding associated with this webhook  yes, when protocol is “SMPP”. SparkPost Enterprise API only. */
        esme_address?: string;
    }

    interface SendingDomain {
        /** Name of the sending domain. */
        domain: string;
        /** Associated tracking domain. */
        tracking_domain: string;
        /** JSON object containing status details, including whether this domain’s ownership has been verified. */
        status: Status;
        /** JSON object in which DKIM key configuration is defined. */
        dkim?: DKIM;
        /** Whether to generate a DKIM keypair on creation. */
        generate_dkim?: boolean;
        /** Size, in bits, of the DKIM private key to be generated. This option only applies if generate_dkim is ‘true’. */
        dkim_key_length?: number;
        /** Setting to true allows this domain to be used by subaccounts. Defaults to false, only available to domains belonging to a master account. */
        shared_with_subaccounts: boolean;
    }

    interface CreateSendingDomain {
        /** Name of the sending domain. */
        domain: string;
        /** Associated tracking domain. */
        tracking_domain?: string;
        /** JSON object containing status details, including whether this domain’s ownership has been verified. */
        status?: Status;
        /** JSON object in which DKIM key configuration is defined. */
        dkim?: DKIM;
        /** Whether to generate a DKIM keypair on creation. */
        generate_dkim?: boolean;
        /** Size, in bits, of the DKIM private key to be generated. This option only applies if generate_dkim is ‘true’. */
        dkim_key_length?: number;
        /** Setting to true allows this domain to be used by subaccounts. Defaults to false, only available to domains belonging to a master account. */
        shared_with_subaccounts?: boolean;
    }

    interface UpdateSendingDomain {
        /** Associated tracking domain. */
        tracking_domain?: string;
        /** JSON object in which DKIM key configuration is defined. */
        dkim?: DKIM;
        /** Whether to generate a DKIM keypair on creation. */
        generate_dkim?: boolean;
        /** Size, in bits, of the DKIM private key to be generated. This option only applies if generate_dkim is ‘true’. */
        dkim_key_length?: number;
        /** Setting to true allows this domain to be used by subaccounts. Defaults to false, only available to domains belonging to a master account. */
        shared_with_subaccounts?: boolean;
    }

    interface DKIM {
        /** Signing Domain Identifier (SDID). SparkPost Enterprise API only. */
        signing_domain?: string;
        /** DKIM private key. */
        private?: string;
        /** DKIM public key. */
        public: string;
        /** DomainKey selector. */
        selector: string;
        /** Header fields to be included in the DKIM signature. This field is currently ignored. */
        headers?: string;
    }

    interface Status {
        /** Whether domain ownership has been verified */
        ownership_verified: boolean;
        /** Verification status of SPF configuration */
        spf_status: "valid" | "invalid" | "unverified" | "pending";
        /** Compliance status */
        compliance_status: "valid" | "pending" | "blocked";
        /** Verification status of DKIM configuration */
        dkim_status: "valid" | "invalid" | "unverified" | "pending";
        /** Verification status of abuse@ mailbox */
        abuse_at_status: "valid" | "invalid" | "unverified" | "pending";
        /** Verification status of postmaster@ mailbox */
        postmaster_at_status: "valid" | "invalid" | "unverified" | "pending";
    }

    interface VerifyOptions {
        /**
         * Request verification of DKIM record
         *
         * @type {boolean}
         * @memberOf VerifyOptions
         */
        dkim_verify?: boolean;
        /**
         * Request verification of SPF record
         *
         * @type {boolean}
         * @deprecated
         * @memberOf VerifyOptions
         */
        spf_verify?: boolean;
        /**
         * Request an email with a verification link to be sent to the sending domain’s postmaster@ mailbox.
         *
         * @type {boolean}
         * @memberOf VerifyOptions
         */
        postmaster_at_verify?: boolean;
        /**
         * Request an email with a verification link to be sent to the sending domain’s abuse@ mailbox.
         *
         * @type {boolean}
         * @memberOf VerifyOptions
         */
        abuse_at_verify?: boolean;
        /**
         * A token retrieved from the verification link contained in the postmaster@ verification email.
         *
         * @type {string}
         * @memberOf VerifyOptions
         */
        postmaster_at_token?: string;
        /**
         * A token retrieved from the verification link contained in the abuse@ verification email.
         *
         * @type {string}
         * @memberOf VerifyOptions
         */
        abuse_at_token?: string;
    }

    interface VerifyResults extends Status {
        dns?: {
            dkim_record: string;
            spf_record: string;
        };
    }

    interface CreateSubaccount {
        /** user-friendly name */
        name: string;
        /** user-friendly identifier for subaccount API key */
        key_label: string;
        /** list of grants to give the subaccount API key */
        key_grants: string[];
        /** list of IPs the subaccount may be used from */
        key_valid_ips?: string[];
        /** id of the default IP pool assigned to subaccount"s transmissions */
        ip_pool?: string;
    }

    interface CreateSubaccountResponse {
        subaccount_id: number;
        key: string;
        label: string;
        short_key: string;
    }

    interface UpdateSubaccount {
        /** user-friendly name */
        name: string;
        /** status of the subaccount */
        status: string;
        /** id of the default IP pool assigned to subaccount"s transmissions */
        ip_pool?: string;
    }

    interface SubaccountInformation {
        /** ID of subaccount */
        id: number;
        /** User friendly identifier for a specific subaccount */
        name: string;
        /** Status of the account */
        status: "active" | "suspended" | "terminated";
        /** The ID of the default IP Pool assigned to this subaccount’s transmissions */
        ip_pool?: string;
        compliance_status: string;
    }

    interface CreateSupressionListEntry {
        /**
         * Email address to be suppressed
         *
         * @type {string}
         * @memberOf CreateSupressionListEntry
         */
        recipient: string;
        /**
         * Type of suppression record
         *
         * @type {("transactional" | "non_transactional")}
         * @memberOf CreateSupressionListEntry
         */
        type?: "transactional" | "non_transactional";
        /**
         * Whether the recipient requested to not receive any non-transactional messages
         * Not required if a valid type is passed
         *
         * @deprecated Available, but deprecated in favor of type
         * @type {boolean}
         * @memberOf CreateSupressionListEntry
         */
        transactional?: boolean;
        /**
         * Whether the recipient requested to not receive any non-transactional messages
         * Not required if a valid type is passed
         *
         * @deprecated Available, but deprecated in favor of type
         * @type {boolean}
         * @memberOf CreateSupressionListEntry
         */
        non_transactional?: boolean;
        /**
         * Source responsible for inserting the list entry
         * no - entries created by the user are marked as Manually Added
         *
         * @type {("Spam Complaint" | "List Unsubscribe" | "Bounce Rule" | "Unsubscribe Link" | "Manually Added" | "Compliance")}
         * @memberOf CreateSupressionListEntry
         */
        readonly source?: "Spam Complaint" | "List Unsubscribe" | "Bounce Rule" | "Unsubscribe Link" | "Manually Added" | "Compliance";
        /** Short explanation of the suppression */
        description?: string;
    }

    interface SupressionListEntry {
        /**
         * Email address to be suppressed
         *
         * @type {string}
         * @memberOf SupressionListEntry
         */
        recipient: string;
        /**
         * Whether the recipient requested to not receive any transactional messages
         * Not required if a valid type is passed
         *
         * @deprecated Available, but deprecated in favor of type
         * @type {boolean}
         * @memberOf SupressionListEntry
         */
        transactional?: boolean;
        /**
         * Whether the recipient requested to not receive any non-transactional messages
         * Not required if a valid type is passed
         *
         * @deprecated Available, but deprecated in favor of type
         * @type {boolean}
         * @memberOf SupressionListEntry
         */
        non_transactional?: boolean;
        /** Type of suppression record: transactional or non_transactional */
        type?: "transactional" | "non_transactional";
        /**
         * Source responsible for inserting the list entry
         *
         * no - entries created by the user are marked as Manually Added
         *
         * @type {("Spam Complaint" | "List Unsubscribe" | "Bounce Rule" | "Unsubscribe Link" | "Manually Added" | "Compliance")}
         * @memberOf SupressionListEntry
         */
        source?: "Spam Complaint" | "List Unsubscribe" | "Bounce Rule" | "Unsubscribe Link" | "Manually Added" | "Compliance";
        /** Short explanation of the suppression */
        description?: string;
        created: string;
        updated: string;
    }

    interface SupressionSearchParameters {
        /** Datetime the entries were last updated, in the format of YYYY-MM-DDTHH:mm:ssZ */
        to?: string;
        /** Datetime the entries were last updated, in the format YYYY-MM-DDTHH:mm:ssZ */
        from?: string;
        /**
         * Domain of entries to include in the search. ( Note: SparkPost only)
         *
         * @type {string}
         * @memberOf SupressionSearch
         */
        domain?: string;
        /**
         * The results cursor location to return, to start paging with cursor, use the value of ‘initial’.
         * When cursor is provided the page parameter is ignored. (Note: SparkPost only)
         *
         * @type {string}
         * @memberOf SupressionSearch
         */
        cursor?: string;
        /**
         * Maximum number of results to return per page. Must be between 1 and 10,000.
         * ( Note: SparkPost only)
         * @default 1000
         * @type {string}
         * @memberOf SupressionSearch
         */
        per_page?: string | number;
        /**
         * The results page number to return. Used with per_page for paging through results.
         * The page parameter works up to 10,000 results.
         * You must use the cursor parameter and start with cursor=initial to page result sets larger than 10,000
         * ( Note: SparkPost only)
         *
         * @type {string}
         * @memberOf SupressionSearch
         */
        page?: string | number;
        /** Types of entries to include in the search, i.e. entries with “transactional” and/or “non_transactional” keys set to true */
        types?: string;
        /** Sources of the entries to include in the search, i.e. entries that were added by this source */
        sources?: string;
        /**
         * Description of the entries to include in the search, i.e descriptions that include the text submitted.
         * ( Note: SparkPost only)
         *
         * @type {string}
         * @memberOf SupressionSearch
         */
        description?: string;
        /**
         * Maximum number of results to return per page. Must be between 1 and 10,000.
         * @type {number}
         * @deprecated use per_page instead
         * @memberOf SupressionSearch
         */
        limit?: number;
    }

    interface TemplateContent {
        /** HTML content for the email’s text/html MIME part */
        html: string;
        /** Text content for the email’s text/plain MIME part */
        text: string;
        /** Email subject line. */
        subject: string;
        /**
         * Address "from" : "deals@company.com" or JSON object composed of the "name" and "email" fields.
         * "from" : { "name" : "My Company", "email" : "deals@company.com" } used to compose the email’s "From" header.
         *
         * @type {(Address | string)}
         * @memberOf TemplateContent
         */
        from: Address | string;
        /** Email address used to compose the email’s “Reply-To” header. */
        reply_to?: string;
        /**  JSON dictionary containing headers other than “Subject”, “From”, “To”, and “Reply-To”. */
        headers?: any;
    }

    interface CreateTemplateContent {
        /** HTML content for the email’s text/html MIME part */
        html?: string;
        /** Text content for the email’s text/plain MIME part */
        text?: string;
        /** Email subject line. */
        subject: string;
        /**
         * Address "from" : "deals@company.com" or JSON object composed of the "name" and "email" fields.
         * "from" : { "name" : "My Company", "email" : "deals@company.com" } used to compose the email’s "From" header.
         *
         * @type {(Address | string)}
         * @memberOf TemplateContent
         */
        from: Address | string;
        /** Email address used to compose the email’s “Reply-To” header. */
        reply_to?: string;
        /**  JSON dictionary containing headers other than “Subject”, “From”, “To”, and “Reply-To”. */
        headers?: any;
    }

    interface TemplateMeta {
        /** Unique template ID */
        id: string;
        /** Template name */
        name: string;
        /** Published state of the template (true = published, false = draft) */
        published: boolean;
        /** Template description */
        description: string;
    }

    interface Template {
        /**
         * Short, unique, alphanumeric ID used to reference the template.
         * At a minimum, id or name is required upon creation.
         * It is auto generated if not provided.
         * After a template has been created, this property cannot be changed. Maximum length - 64 bytes
         *
         * @type {string}
         * @memberOf Template
         */
        id: string;
        /** Content that will be used to construct a message  yes  For a full description, see the Content Attributes. Maximum length - 20 MBs */
        content: TemplateContent | { email_rfc822: string };
        /** Whether the template is published or is a draft version  no - defaults to false  A template cannot be changed from published to draft. */
        published: boolean;
        /** Editable display name  At a minimum, id or name is required upon creation.  The name does not have to be unique. Maximum length - 1024 bytes */
        name: string;
        /** Detailed description of the template  no  Maximum length - 1024 bytes */
        description: string;
        /** JSON object in which template options are defined  no  For a full description, see the Options Attributes. */
        options: TemplateOptions;
        /** The “last_update_time” is the time the template was last updated, for both draft and published versions */
        last_update_time: string;
        /** The “last_use” time represents the last time any version of this template was used (draft or published). */
        last_use?: string;
    }

    interface CreateTemplate {
        /**
         * Short, unique, alphanumeric ID used to reference the template.
         * At a minimum, id or name is required upon creation.
         * It is auto generated if not provided.
         * After a template has been created, this property cannot be changed. Maximum length - 64 bytes
         *
         * @type {string}
         * @memberOf CreateTemplate
         */
        id?: string;
        /** Content that will be used to construct a message  yes  For a full description, see the Content Attributes. Maximum length - 20 MBs */
        content: CreateTemplateContent | { email_rfc822: string };
        /** Whether the template is published or is a draft version  no - defaults to false  A template cannot be changed from published to draft. */
        published?: boolean;
        /** Editable display name  At a minimum, id or name is required upon creation.  The name does not have to be unique. Maximum length - 1024 bytes */
        name?: string;
        /** Detailed description of the template  no  Maximum length - 1024 bytes */
        description?: string;
        /** JSON object in which template options are defined  no  For a full description, see the Options Attributes. */
        options?: CreateTemplateOptions;
    }

    interface UpdateTemplate {
        /** Content that will be used to construct a message  yes  For a full description, see the Content Attributes. Maximum length - 20 MBs */
        content?: CreateTemplateContent | { email_rfc822: string };
        /** Whether the template is published or is a draft version  no - defaults to false  A template cannot be changed from published to draft. */
        published?: boolean;
        /** Editable display name  At a minimum, id or name is required upon creation.  The name does not have to be unique. Maximum length - 1024 bytes */
        name?: string;
        /** Detailed description of the template  no  Maximum length - 1024 bytes */
        description?: string;
        /** JSON object in which template options are defined  no  For a full description, see the Options Attributes. */
        options?: CreateTemplateOptions;
    }

    interface TemplateOptions {
        /** Enable or disable open tracking */
        open_tracking: boolean;
        /** Enable or disable click tracking */
        click_tracking: boolean;
        /** Distinguish between transactional and non-transactional messages for unsubscribe and suppression purposes */
        transactional: boolean;
    }

    interface CreateTemplateOptions {
        /** Enable or disable open tracking */
        open_tracking?: boolean;
        /** Enable or disable click tracking */
        click_tracking?: boolean;
        /** Distinguish between transactional and non-transactional messages for unsubscribe and suppression purposes */
        transactional?: boolean;
    }

    interface CreateTransmission {
        /** JSON object in which transmission options are defined */
        options?: TransmissionOptions;
        /**
         * Recipients to receive a carbon copy of the transmission
         *
         * @type {Recipient[]}
         * @memberOf CreateTransmission
         */
        cc?: Recipient[];
        /**
         * Recipients to discreetly receive a carbon copy of the transmission
         *
         * @type {Recipient[]}
         * @memberOf CreateTransmission
         */
        bcc?: Recipient[];
        /** Inline recipient objects or object containing stored recipient list ID */
        recipients?: Recipient[] | { list_id: string };
        /** Name of the campaign */
        campaign_id?: string;
        /** Description of the transmission */
        description?: string;
        /** Transmission level metadata containing key/value pairs */
        metadata?: any;
        /** Key/value pairs that are provided to the substitution engine */
        substitution_data?: any;
        /** SparkPost Enterprise API only: email to use for envelope FROM */
        return_path?: string;
        /** Content that will be used to construct a message */
        content: InlineContent | { template_id: string, use_draft_template?: boolean } | { email_rfc822: string };
    }

    interface TransmissionSummary {
        /** ID of the transmission */
        id: string;
        /** State of the transmission */
        state: "submitted" | "Generating" | "Success" | "Canceled";
        /** Description of the transmission */
        description: string;
        /** Name of the campaign */
        campaign_id: string;
        /** Content that will be used to construct a message */
        content: { template_id: string };
    }

    interface Transmission {
        /** ID of the transmission */
        id: string;
        /** State of the transmission */
        state: "submitted" | "Generating" | "Success" | "Canceled";
        /** JSON object in which transmission options are defined */
        options: TransmissionOptions;
        /** Name of the campaign */
        campaign_id: string;
        /** Description of the transmission */
        description: string;
        /** Transmission level metadata containing key/value pairs */
        metadata: any;
        /** Key/value pairs that are provided to the substitution engine */
        substitution_data: any;
        /** Content that will be used to construct a message */
        content: InlineContent | { template_id: string, use_draft_template?: boolean } | { email_rfc822: string };
        /** Computed total number of messages generated */
        num_generated: number;
        /** Computed total number of failed messages */
        num_failed_generation: number;
        /** Number of recipients that failed input validation */
        num_invalid_recipients: number;
        rcpt_list_chunk_size: number;
        rcpt_list_total_chunks: number;
    }

    interface TransmissionOptions {
        /** Delay generation of messages until this datetime. */
        start_time?: string;
        /** Whether open tracking is enabled for this transmission */
        open_tracking?: boolean;
        /** Whether click tracking is enabled for this transmission */
        click_tracking?: boolean;
        /** Whether message is transactional or non-transactional for unsubscribe and suppression purposes */
        transactional?: boolean;
        /** Whether or not to use the sandbox sending domain */
        sandbox?: boolean;
        /** SparkPost Enterprise API only: Whether or not to ignore customer suppression rules, for this transmission only. Only applicable if your configuration supports this parameter. */
        skip_suppression?: boolean;
        /** The ID of a dedicated IP pool associated with your account ( Note: SparkPost only ). */
        ip_pool?: string;
        /** Whether or not to perform CSS inlining in HTML content */
        inline_css?: boolean;
    }

    interface InlineContent {
        /** HTML content for the email’s text/html MIME part  At a minimum, html, text, or push is required. */
        html?: string;
        /** Text content for the email’s text/plain MIME part  At a minimum, html, text, or push is required. */
        text?: string;
        /**  Content of push notifications  At a minimum, html, text, or push is required.  SparkPost Enterprise API only. */
        push?: PushData;
        /** Email subject line  required for email transmissions  Expected in the UTF-8 charset without RFC2047 encoding. Substitution syntax is supported. */
        subject?: string;
        /** "deals@company.com" or JSON object composed of the “name” and “email” fields “from” : { “name” : “My Company”, “email” : "deals@company.com" } used to compose the email’s “From” header */
        from?: string | { email: string, name: string };
        /** Email address used to compose the email’s “Reply-To” header */
        reply_to?: string;
        /** JSON dictionary containing headers other than “Subject”, “From”, “To”, and “Reply-To” */
        headers?: any;
        /** JSON array of attachments. */
        attachments?: Attachment[];
        /** JSON array of inline images. */
        inline_images?: Attachment[];
    }

    interface PushData {
        /** payload for APNs messages */
        apns?: any;
        /** payload for GCM messages */
        gcm?: any;
    }

    interface Attachment {
        /**
         * The MIME type of the attachment; e.g., “text/plain”, “image/jpeg”, “audio/mp3”, “video/mp4”, “application/msword”, “application/pdf”, etc.,
         * including the “charset” parameter (text/html; charset=“UTF-8”) if needed.
         * The value will apply “as-is” to the “Content-Type” header of the generated MIME part for the attachment.
         *
         * @type {string}
         * @memberOf Attachment
         */
        type: string;
        /**   The filename of the attachment (for example, “document.pdf”). This is inserted into the filename parameter of the Content-Disposition header. */
        name: string;
        /**
         * The content of the attachment as a Base64 encoded string.
         * The string should not contain \r\n line breaks.
         * The SparkPost systems will add line breaks as necessary to ensure the Base64 encoded lines contain no more than 76 characters each.
         *
         * @type {string}
         * @memberOf Attachment
         */
        data: string;
    }

    interface Webhook {
        /** User-friendly name for webhook */
        name: string;
        /** URL of the target to which to POST event batches */
        target: string;
        /** Array of event types this webhook will receive */
        events: string[];
        /**
         * Reserved for future use
         *
         * @default {true}
         * @type {boolean}
         * @memberOf Webhook
         */
        active?: boolean;
        /** Type of authentication to be used during POST requests to target */
        auth_type?: string;
        /** Object containing details needed to request authorization credentials, as necessary */
        auth_request_details?: any;
        /** Object containing credentials needed to make authorized POST requests to target */
        auth_credentials?: any;
        /** Authentication token to present in the X-MessageSystems-Webhook-Token header of POST requests to target */
        auth_token?: string;
    }

    interface UpdateWebhook {
        /** User-friendly name for webhook */
        name?: string;
        /** URL of the target to which to POST event batches */
        target?: string;
        /** Array of event types this webhook will receive */
        events?: string[];
        active?: boolean;
        /** Type of authentication to be used during POST requests to target */
        auth_type?: string;
        /** Object containing details needed to request authorization credentials, as necessary */
        auth_request_details?: any;
        /** Object containing credentials needed to make authorized POST requests to target */
        auth_credentials?: any;
        /** Authentication token to present in the X-MessageSystems-Webhook-Token header of POST requests to target */
        auth_token?: string;
    }

    interface WebhookLinks {
        links: Array<{
            href: string;
            rel: string;
            method: string[];
        }>;
    }

    interface CreateOpts {
        /**
         * Domain (or subdomain) name for which SparkPost will receive inbound emails
         *
         * @type {string}
         * @memberOf CreateOpts
         */
        domain: string;
    }
}

export = SparkPost;
