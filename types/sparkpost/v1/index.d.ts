/// <reference types="node"/>

import * as Http from "http";
import * as Request from "request";

declare class SparkPost {
    /** Specifying an inbound domain enables you to customize the address to which inbound messages are sent. */
    inboundDomains: {
        /**
         * List all your inbound domains.
         * @param callback The request callback with Domain results array
         */
        all(callback: SparkPost.ResultsCallback<SparkPost.Domain[]>): void;
        /**
         * Retrieve an inbound domain by specifying its domain name in the URI path.
         * @param domain Domain name
         * @param callback The request callback with Domain results
         */
        find(domain: string, callback: SparkPost.ResultsCallback<SparkPost.Domain>): void;
        /**
         * Create an inbound domain by providing an inbound domains object as the POST request body.
         * @param domain Domain name
         * @param callback The request callback
         */
        create(domain: string, callback: SparkPost.Callback<void>): void;
        /**
         * Delete an inbound domain by specifying its domain name in the URI path.
         * @param domain Domain name
         * @param callback The request callback
         */
        delete(domain: string, callback: SparkPost.Callback<void>): void;
    };
    /** The Message Events API provides the means to search the raw events generated by SparkPost. */
    messageEvents: {
        /**
         * Retrieves list of message events according to given params
         * @param parameters Query parameters
         * @param callback The request callback with MessageEvent results array
         */
        search(
            parameters: SparkPost.MessageEventParameters,
            callback: SparkPost.ResultsCallback<SparkPost.MessageEvent[]>,
        ): void;
    };
    /** A recipient list is a collection of recipients that can be used in a transmission. */
    recipientLists: {
        /**
         * List a summary of all recipient lists. The recipients for each list are not included in the results.
         * To retrieve recipient details, use the RETRIEVE API for a specified recipient list.
         * @param callback The request callback with RecipientList results array
         */
        all(callback: SparkPost.ResultsCallback<SparkPost.RecipientList[]>): void;
        /**
         * Retrieve details about a specified recipient list by specifying its id in the URI path.
         * To retrieve the recipients contained in a list, the show_recipients parameter must be set to true.
         * @param options The find options
         * @param callback The request callback with RecipientList results
         */
        find(
            options: { id: string; show_recipients?: false | undefined },
            callback: SparkPost.Callback<SparkPost.RecipientList>,
        ): void;
        /**
         * Retrieve details about a specified recipient list by specifying its id in the URI path.
         * To retrieve the recipients contained in a list, the show_recipients parameter must be set to true.
         * @param options The find options
         * @param callback The request callback with RecipientList results (with recipients)
         */
        find(
            options: { id: string; show_recipients: true },
            callback: SparkPost.Callback<SparkPost.RecipientListWithRecipients>,
        ): void;
        /**
         * Create a recipient list by providing a recipient list object as the POST request body.
         * At a minimum, the “recipients” array is required, which must contain a valid “address”.
         * If the recipient list “id” is not provided in the POST request body, one will be generated and returned in the results body.
         * Use the num_rcpt_errors parameter to limit the number of recipient errors returned.
         * @param options The create options
         * @param callback The request callback with metadata results
         */
        create(
            options: SparkPost.CreateRecipientList,
            callback: SparkPost.ResultsCallback<SparkPost.RecipientListMetadata>,
        ): void;
        /**
         * Update an existing recipient list by specifying its ID in the URI path and use a recipient list object as the PUT request body.
         * Use the num_rcpt_errors parameter to limit the number of recipient errors returned.
         * @param options The update options
         * @param callback The request callback with metadata results
         */
        update(
            options: SparkPost.UpdateRecipientList,
            callback: SparkPost.ResultsCallback<SparkPost.RecipientListMetadata>,
        ): void;
        /**
         * Permanently delete the specified recipient list.
         * @param id The list id
         * @param callback The request callback
         */
        delete(id: string, callback: SparkPost.Callback<void>): void;
    };
    /** Relay Webhooks are a way to instruct SparkPost to accept inbound email on your behalf and forward it to you over HTTP for your own consumption. */
    relayWebhooks: {
        /**
         * List all your relay webhooks.
         * @param callback The request callback with RelayWebhook results array
         */
        all(callback: SparkPost.ResultsCallback<SparkPost.RelayWebhook[]>): void;
        /**
         * Delete a relay webhook by specifying the webhook ID in the URI path.
         * @param relayWebhookId The webhook id
         * @param callback The request callback with RelayWebhook results
         */
        find(relayWebhookId: string, callback: SparkPost.ResultsCallback<SparkPost.RelayWebhook>): void;
        /**
         * Create a relay webhook by providing a relay webhooks object as the POST request body.
         * @param options The create options
         * @param callback The request callback with webhook id results
         */
        create(options: SparkPost.RelayWebhook, callback: SparkPost.ResultsCallback<{ id: string }>): void;
        /**
         * Update a relay webhook by specifying the webhook ID in the URI path.
         * @param options The update options
         * @param callback The request callback with webhook id results
         */
        update(
            options: SparkPost.UpdateRelayWebhook & { relayWebhookId: string },
            callback: SparkPost.ResultsCallback<{ id: string }>,
        ): void;
        /**
         * Delete a relay webhook by specifying the webhook ID in the URI path.
         * @param relayWebhookId The webhook id
         * @param callback The request callback
         */
        delete(relayWebhookId: string, callback: SparkPost.Callback<void>): void;
    };
    sendingDomains: {
        /**
         * List an overview of all sending domains in the system.
         * @param callback The request callback with SendingDomain results array
         */
        all(callback: SparkPost.ResultsCallback<SparkPost.SendingDomain[]>): void;
        /**
         * Retrieve a sending domain by specifying its domain name in the URI path. The response includes details about its DKIM key configuration.
         * @param domain The domain
         * @param callback The request callback with SendingDomain results
         */
        find(domain: string, callback: SparkPost.ResultsCallback<SparkPost.SendingDomain>): void;
        /**
         * Create a sending domain by providing a sending domain object as the POST request body.
         * @param options The create options
         * @param callback The request callback with basic info results
         */
        create(
            options: SparkPost.CreateSendingDomain,
            callback: SparkPost.ResultsCallback<{ message: string; domain: string }>,
        ): void;
        /**
         * Update the attributes of an existing sending domain by specifying its domain name in the URI path and use a sending domain object as the PUT request body.
         * @param options The update options
         * @param callback The request callback with basic info results
         */
        update(
            options: SparkPost.UpdateSendingDomain,
            callback: SparkPost.ResultsCallback<{ message: string; domain: string }>,
        ): void;
        /**
         * Delete an existing sending domain.
         * @param domain The domain
         * @param callback The request callback
         */
        delete(domain: string, callback: SparkPost.Callback<void>): void;
        /**
         * Verify a Sending Domain
         * @param options The verify options
         * @param callback The request callback with verify results
         */
        verify(options: SparkPost.VerifyOptions, callback: SparkPost.ResultsCallback<SparkPost.VerifyResults>): void;
    };
    subaccounts: {
        /**
         * Endpoint for retrieving a list of your subaccounts.
         * This endpoint only returns information about the subaccounts themselves, not the data associated with the subaccount.
         * @param callback The request callback with subaccount information results array
         */
        all(callback: SparkPost.ResultsCallback<SparkPost.SubaccountInformation[]>): void;
        /**
         * @param subaccountId The webhook id
         * @param callback The request callback with subaccount information results
         */
        find(subaccountId: string | number, callback: SparkPost.ResultsCallback<SparkPost.SubaccountInformation>): void;
        /**
         * Provisions a new subaccount and an initial subaccount API key.
         * @param options The create options
         * @param callback The request callback with basic subaccount information results
         */
        create(
            options: SparkPost.CreateSubaccount,
            callback: SparkPost.ResultsCallback<SparkPost.CreateSubaccountResponse>,
        ): void;
        /**
         * Update an existing subaccount’s information.
         * @param options The create options
         * @param callback The request callback with webhook id results
         */
        update(options: SparkPost.UpdateSubaccount, callback: SparkPost.ResultsCallback<{ message: string }>): void;
    };
    suppressionList: {
        /**
         * Perform a filtered search for entries in your suppression list.
         * @param parameters Object of search parameters
         * @param callback The request callback with RelayWebhook results
         */
        search(
            parameters: SparkPost.SupressionSearch,
            callback: SparkPost.ResultsCallback<SparkPost.SupressionListEntry[]>,
        ): void;
        /**
         * Retrieve the suppression status for a specific recipient by specifying the recipient’s email address in the URI path.
         * @param email Email address to check
         * @param callback The request callback with webhook id results
         */
        checkStatus(email: string, callback: SparkPost.ResultsCallback<SparkPost.SupressionListEntry[]>): void;
        /**
         * Delete a recipient from the list by specifying the recipient’s email address in the URI path.
         * @param email Email address to check
         * @param callback The request callback
         */
        removeStatus(email: string, callback: SparkPost.Callback<void>): void;
        /**
         * Bulk insert or update entries in the customer-specific exclusion list.
         * @param parameters The suppression entry list
         * @param callback The request callback
         */
        upsert(
            parameters: SparkPost.CreateSupressionListEntry | SparkPost.CreateSupressionListEntry[],
            callback: SparkPost.ResultsCallback<{ message: string }>,
        ): void;
    };
    templates: {
        /**
         * List a summary of all templates.
         * @param callback The request callback with TemplateMeta results array
         */
        all(callback: SparkPost.ResultsCallback<SparkPost.TemplateMeta[]>): void;
        /**
         * Retrieve details about a specified template by its id
         * @param options The id and draft status information
         * @param callback The request callback with Template results
         */
        find(
            options: { id: string; draft?: boolean | undefined },
            callback: SparkPost.ResultsCallback<SparkPost.Template>,
        ): void;
        /**
         * Create a new template
         * @param options The create options
         * @param callback The request callback with template id results
         */
        create(
            options: { template: SparkPost.CreateTemplate },
            callback: SparkPost.ResultsCallback<{ id: string }>,
        ): void;
        /**
         * Update an existing template
         * @param options The create options
         * @param callback The request callback with template id results
         */
        update(options: {
            id: string;
            template: SparkPost.UpdateTemplate;
            update_published?: boolean | undefined;
        }, callback: SparkPost.ResultsCallback<{ id: string }>): void;
        /**
         * Delete an existing template
         * @param id The template id
         * @param callback The request callback
         */
        delete(id: string, callback: SparkPost.Callback<void>): void;
        /**
         * Preview the most recent version of an existing template by id
         * @param options The preview options
         * @param callback The request callback with webhook id results
         */
        preview(
            options: { id: string; data: any; draft?: boolean | undefined },
            callback: SparkPost.ResultsCallback<SparkPost.TemplateContent>,
        ): void;
    };
    transmissions: {
        /**
         * List an overview of all transmissions in the account
         * @param callback The request callback with Transmission results array
         */
        all(callback: SparkPost.ResultsCallback<SparkPost.TransmissionSummary[]>): void;
        /**
         * List an overview of all transmissions in the account, with added filters
         * @param options The search options { campaign_id?, template_id? }
         * @param callback The request callback with Transmission results array
         */
        all(
            options: { campaign_id?: string | undefined; template_id?: string | undefined },
            callback: SparkPost.ResultsCallback<SparkPost.TransmissionSummary[]>,
        ): void;
        /**
         * Retrieve the details about a transmission by its ID
         * @param transmissionID The transmission id
         * @param callback The request callback with Transmission results
         */
        find(transmissionID: string, callback: SparkPost.ResultsCallback<SparkPost.Transmission>): void;
        /**
         * Sends a message by creating a new transmission
         * @param options The create options
         * @param callback The request callback with metadata and id results
         */
        send(
            options: { transmissionBody: SparkPost.CreateTransmission; num_rcpt_errors?: number | undefined },
            callback: SparkPost.ResultsCallback<{
                total_rejected_recipients: number;
                total_accepted_recipients: number;
                id: string;
            }>,
        ): void;
    };
    webhooks: {
        /**
         * List currently existing webhooks.
         * @param callback The request callback with RelayWebhook results array
         */
        all(callback: SparkPost.ResultsCallback<Array<SparkPost.WebhookLinks & SparkPost.Webhook>>): void;
        /**
         * List currently existing webhooks.
         * @param options Object containing optional timezone
         * @param callback The request callback with RelayWebhook results array
         */
        all(
            options: { timezone?: string | undefined },
            callback: SparkPost.ResultsCallback<Array<SparkPost.WebhookLinks & SparkPost.Webhook>>,
        ): void;
        /**
         * Retrieve details about a specified webhook by its id
         * @param options Object containing id and optional timezone
         * @param callback The request callback with RelayWebhook results
         */
        describe(
            options: { id: string; timezone?: string | undefined },
            callback: SparkPost.ResultsCallback<SparkPost.WebhookLinks & SparkPost.Webhook>,
        ): void;
        /**
         * Create a new webhook
         * @param options The create options
         * @param callback The request callback with webhook id results
         */
        create(
            options: SparkPost.Webhook,
            callback: SparkPost.ResultsCallback<SparkPost.WebhookLinks & { id: string }>,
        ): void;
        /**
         * Update an existing webhook
         * @param options The update options
         * @param callback The request callback with webhook id results
         */
        update(
            options: SparkPost.UpdateWebhook,
            callback: SparkPost.ResultsCallback<SparkPost.WebhookLinks & { id: string }>,
        ): void;
        /**
         * Delete an existing webhook
         * @param id The webhook id
         * @param callback The request callback
         */
        delete(id: string, callback: SparkPost.Callback<void>): void;
        /**
         * Sends an example message event batch from the Webhook API to the target URL
         * @param options The webhook id and message
         * @param callback The request callback with validation results
         */
        validate(
            options: { id: string; message: any },
            callback: SparkPost.ResultsCallback<{
                msg: string;
                response: {
                    status: number;
                    headers: any;
                    body: string;
                };
            }>,
        ): void;
        /**
         * Sends an example message event batch from the Webhook API to the target URL
         * @param options The webhook id and optional limit
         * @param callback The request callback with status results
         */
        getBatchStatus(
            options: { id: string; limit?: number | undefined },
            callback: SparkPost.ResultsCallback<{
                batch_id: string;
                ts: string;
                attempts: number;
                response_code: number;
            }[]>,
        ): void;
        /**
         * Lists descriptions of the events, event types, and event fields that could be included in a Webhooks post to your target URL.
         * @param callback The request callback containing documentation results
         */
        getDocumentation(callback: SparkPost.ResultsCallback<any>): void;
        /**
         * List an example of the event data that will be posted by a Webhook for the specified events.
         * @param callback The request callback containing examples
         */
        getSamples(callback: SparkPost.Callback<any>): void;
        /**
         * List an example of the event data that will be posted by a Webhook for the specified events.
         * @param options The optional event name
         * @param callback The request callback containing examples
         */
        getSamples(options: { events?: string | undefined }, callback: SparkPost.Callback<any>): void;
    };

    /**
     * The official Node.js binding for your favorite SparkPost APIs!
     * @param apiKey A passed in apiKey will take precedence over an environment variable
     * @param options Additional options
     */
    constructor(apiKey?: string, options?: SparkPost.ConstructorOptions);

    request(options: Request.Options, callback: SparkPost.Callback<any>): void;
    get(options: Request.Options, callback: SparkPost.Callback<any>): void;
    post(options: Request.Options, callback: SparkPost.Callback<any>): void;
    put(options: Request.Options, callback: SparkPost.Callback<any>): void;
    delete(options: Request.Options, callback: SparkPost.Callback<any>): void;
}

declare namespace SparkPost {
    export interface ErrorWithDescription {
        message: string;
        code: string;
        description: string;
    }
    export interface ErrorWithParam {
        message: string;
        param: string;
        value: string | null;
    }
    export interface SparkPostError extends Error {
        name: "SparkPostError";
        errors: ErrorWithDescription[] | ErrorWithParam[];
        statusCode: number;
    }

    export interface ConstructorOptions {
        origin?: string | undefined;
        endpoint?: string | undefined;
        apiVersion?: string | undefined;
        headers?: any;
    }

    export interface Response<T> extends Http.IncomingMessage {
        body: T;
    }
    export interface Callback<T> {
        (err: Error | SparkPostError | null, res: Response<T>): void;
    }
    export type ResultsCallback<T> = Callback<{ results: T }>;

    export interface Domain {
        domain: string;
    }

    export interface MessageEvent {
        /** Type of event this record describes */
        type: string;
        /** Classification code for a given message (see [Bounce Classification Codes](https://support.sparkpost.com/customer/portal/articles/1929896)) */
        bounce_class: string;
        /** Campaign of which this message was a part */
        campaign_id: string;
        /** SparkPost-customer identifier through which this message was sent */
        customer_id: string;
        /** Protocol by which SparkPost delivered this message */
        delv_method: string;
        /** Token of the device / application targeted by this PUSH notification message. Applies only when delv_method is gcm or apn. */
        device_token: string;
        /** Error code by which the remote server described a failed delivery attempt */
        error_code: string;
        /** IP address of the host to which SparkPost delivered this message; in engagement events, the IP address of the host where the HTTP request originated */
        ip_address: string;
        /** SparkPost-cluster-wide unique identifier for this message */
        message_id: string;
        /** Sender address used on this message"s SMTP envelope */
        msg_from: string;
        /** Message"s size in bytes */
        msg_size: string;
        /** Number of failed attempts before this message was successfully delivered; when the first attempt succeeds, zero */
        num_retries: string;
        /** Metadata describing the message recipient */
        rcpt_meta: any;
        /** Tags applied to the message which generated this event */
        rcpt_tags: string[];
        /** Recipient address used on this message"s SMTP envelope */
        rcpt_to: string;
        /** Indicates that a recipient address appeared in the Cc or Bcc header or the archive JSON array */
        rcpt_type: string;
        /** Unmodified, exact response returned by the remote server due to a failed delivery attempt */
        raw_reason: string;
        /** Canonicalized text of the response returned by the remote server due to a failed delivery attempt */
        reason: string;
        /** Domain receiving this message */
        routing_domain: string;
        /** Subject line from the email header */
        subject: string;
        /** Slug of the template used to construct this message */
        template_id: string;
        /** Version of the template used to construct this message */
        template_version: string;
        /** Event date and time formatted as: YYYY-MM-DDTHH:MM:SS.SSS±hh:mm */
        timestamp: string;
        /** Transmission which originated this message */
        transmission_id: string;
    }

    export interface MessageEventParameters {
        /** delimited list of bounce classification codes to search. (See Bounce Classification Codes.) */
        bounce_classes?: Array<string | number> | string | number | undefined;
        /** delimited list of campaign ID’s to search (i.e. the campaign id used during creation of a transmission). */
        campaign_ids?: string[] | string | undefined;
        /** Specifies the delimiter for query parameter lists */
        delimiter?: string | undefined;
        /** delimited list of event types to search. Defaults to all event types. */
        events?: string[] | string | undefined;
        /** delimited list of friendly from emails to search. */
        friendly_froms?: string[] | string | undefined;
        /** Datetime in format of YYYY-MM-DDTHH:MM. */
        from?: string | undefined;
        /** delimited list of message ID’s to search. */
        message_ids?: string[] | string | undefined;
        /** The results page number to return. Used with per_page for paging through results. */
        page?: number | undefined;
        /** Number of results to return per page. Must be between 1 and 10,000 (inclusive). */
        per_page?: number | undefined;
        /** Bounce/failure/rejection reason that will be matched using a wildcard (e.g., %reason%). */
        reason?: string[] | string | undefined;
        /** delimited list of recipients to search. */
        recipients?: string[] | string | undefined;
        /** delimited list of subaccount ID’s to search. */
        subaccounts?: number[] | number | undefined;
        /** delimited list of template ID’s to search. */
        template_ids?: string[] | string | undefined;
        /** Standard timezone identification string. */
        timezone?: string | undefined;
        /** Datetime in format of YYYY-MM-DDTHH:MM. */
        to?: string | undefined;
        /** delimited list of transmission ID’s to search (i.e. id generated during creation of a transmission). */
        transmission_ids?: string[] | string | undefined;
    }

    export interface RecipientListMetadata {
        total_rejected_recipients: number;
        total_accepted_recipients: number;
        id: string;
        name: string;
    }

    export interface RecipientList {
        /** Short, unique, recipient list identifier */
        id: string;
        /** Short, pretty/readable recipient list display name, not required to be unique */
        name: string;
        /** Detailed description of the recipient list */
        description: string;
        /** Recipient list attribute object */
        attributes: any;
        /** Number of accepted recipients */
        total_accepted_recipients: number;
    }
    export interface RecipientListWithRecipients extends RecipientList {
        /** Array of recipient objects */
        recipients: Recipient[];
    }

    export interface CreateRecipientList {
        /** Short, unique, recipient list identifier */
        id?: string | undefined;
        /** Short, pretty/readable recipient list display name, not required to be unique */
        name?: string | undefined;
        /** Detailed description of the recipient list */
        description?: string | undefined;
        /** Recipient list attribute object */
        attributes?: any;
        /** limit the number of recipient errors returned. */
        num_rcpt_errors?: number | undefined;
        /** Array of recipient objects */
        recipients: Recipient[];
    }
    export interface UpdateRecipientList {
        /** Short, unique, recipient list identifier */
        id?: string | undefined;
        /** Short, pretty/readable recipient list display name, not required to be unique */
        name?: string | undefined;
        /** Detailed description of the recipient list */
        description?: string | undefined;
        /** Recipient list attribute object */
        attributes?: any;
        /** limit the number of recipient errors returned. */
        num_rcpt_errors?: number | undefined;
        /** Array of recipient objects */
        recipients?: Recipient[] | undefined;
    }

    export interface BaseRecipient {
        /** SparkPost Enterprise API only. Email to use for envelope FROM. */
        return_path?: string | undefined;
        /** Array of text labels associated with a recipient. */
        tags?: string[] | undefined;
        /** Key/value pairs associated with a recipient. */
        metadata?: any;
        /** Key/value pairs associated with a recipient that are provided to the substitution engine. */
        substitution_data?: any;
    }
    export interface RecipientWithAddress {
        /** Address information for a recipient  At a minimum, address or multichannel_addresses is required. */
        address: Address | string;
    }
    export interface RecipientWithMultichannelAddresses {
        /**
         * Address information for a recipient.
         * At a minimum, address or multichannel_addresses is required.
         * If both address and multichannel_addresses are specified only multichannel_addresses will be used.
         */
        address?: Address | string | undefined;
        /**
         * Array of Multichannel Address objects for a recipient.
         * At a minimum, address or multichannel_addresses is required.
         * If both address and multichannel_addresses are specified only multichannel_addresses will be used.
         */
        multichannel_addresses: MultichannelAddress[];
    }
    export type Recipient = (RecipientWithAddress | RecipientWithMultichannelAddresses) & BaseRecipient;

    export interface Address {
        /** Valid email address */
        email: string;
        /** User-friendly name for the email address */
        name?: string | undefined;
        /** Email address to display in the “To” header instead of address.email (for CC and BCC) */
        header_to?: string | undefined;
    }

    export interface MultichannelAddress {
        /** The communication channel used to reach recipient. Valid values are “email”, “gcm”, “apns”. */
        channel: string;
        /** Valid email address. Required if channel is “email”. */
        email: string;
        /** User-friendly name for the email address. Used when channel is “email” */
        name: string;
        /** Email address to display in the “To” header instead of address.email (for BCC). Used when channel is “email” */
        header_to: string;
        /** SparkPost Enterprise API only. Required if channel is “gcm” or “apns” */
        token: string;
        /** SparkPost Enterprise API only. Required if channel is “gcm” or “apns” */
        app_id: string;
    }

    export interface RelayWebhook {
        /** User-friendly name  no  example: Inbound Customer Replies */
        name?: string | undefined;
        /** URL of the target to which to POST relay batches */
        target: string;
        /** Authentication token to present in the X-MessageSystems-Webhook-Token header of POST requests to target */
        auth_token?: string | undefined;
        /** Restrict which inbound messages will be relayed to the target */
        match: Match;
    }

    export interface UpdateRelayWebhook {
        /** User-friendly name  no  example: Inbound Customer Replies */
        name?: string | undefined;
        /** URL of the target to which to POST relay batches */
        target?: string | undefined;
        /** Authentication token to present in the X-MessageSystems-Webhook-Token header of POST requests to target */
        auth_token?: string | undefined;
        /** Restrict which inbound messages will be relayed to the target */
        match?: Match | undefined;
    }

    export interface Match {
        /** Inbound messaging protocol associated with this webhook. Defaults to “SMTP” */
        protocol?: string | undefined;
        /** Inbound domain associated with this webhook. Required when protocol is “SMTP”. */
        domain?: string | undefined;
        /** ESME address binding associated with this webhook  yes, when protocol is “SMPP”. SparkPost Enterprise API only. */
        esme_address?: string | undefined;
    }

    export interface SendingDomain {
        /** Name of the sending domain. */
        domain: string;
        /** Associated tracking domain. */
        tracking_domain: string;
        /** JSON object containing status details, including whether this domain’s ownership has been verified. */
        status: Status;
        /** JSON object in which DKIM key configuration is defined. */
        dkim?: DKIM | undefined;
        /** Whether to generate a DKIM keypair on creation. */
        generate_dkim?: boolean | undefined;
        /** Size, in bits, of the DKIM private key to be generated. This option only applies if generate_dkim is ‘true’. */
        dkim_key_length?: number | undefined;
        /** Setting to true allows this domain to be used by subaccounts. Defaults to false, only available to domains belonging to a master account. */
        shared_with_subaccounts: boolean;
    }

    export interface CreateSendingDomain {
        /** Name of the sending domain. */
        domain: string;
        /** Associated tracking domain. */
        tracking_domain?: string | undefined;
        /** JSON object containing status details, including whether this domain’s ownership has been verified. */
        status?: Status | undefined;
        /** JSON object in which DKIM key configuration is defined. */
        dkim?: DKIM | undefined;
        /** Whether to generate a DKIM keypair on creation. */
        generate_dkim?: boolean | undefined;
        /** Size, in bits, of the DKIM private key to be generated. This option only applies if generate_dkim is ‘true’. */
        dkim_key_length?: number | undefined;
        /** Setting to true allows this domain to be used by subaccounts. Defaults to false, only available to domains belonging to a master account. */
        shared_with_subaccounts?: boolean | undefined;
    }

    export interface UpdateSendingDomain {
        /** Name of the sending domain. */
        domain: string;
        /** Associated tracking domain. */
        tracking_domain?: string | undefined;
        /** JSON object in which DKIM key configuration is defined. */
        dkim?: DKIM | undefined;
        /** Whether to generate a DKIM keypair on creation. */
        generate_dkim?: boolean | undefined;
        /** Size, in bits, of the DKIM private key to be generated. This option only applies if generate_dkim is ‘true’. */
        dkim_key_length?: number | undefined;
        /** Setting to true allows this domain to be used by subaccounts. Defaults to false, only available to domains belonging to a master account. */
        shared_with_subaccounts?: boolean | undefined;
    }

    export interface DKIM {
        /** Signing Domain Identifier (SDID). SparkPost Enterprise API only. */
        signing_domain?: string | undefined;
        /** DKIM private key. */
        private?: string | undefined;
        /** DKIM public key. */
        public: string;
        /** DomainKey selector. */
        selector: string;
        /** Header fields to be included in the DKIM signature. This field is currently ignored. */
        headers?: string | undefined;
    }

    export interface Status {
        /** Whether domain ownership has been verified */
        ownership_verified: boolean;
        /** Verification status of SPF configuration */
        spf_status: "valid" | "invalid" | "unverified" | "pending";
        /** Compliance status */
        compliance_status: "valid" | "pending" | "blocked";
        /** Verification status of DKIM configuration */
        dkim_status: "valid" | "invalid" | "unverified" | "pending";
        /** Verification status of abuse@ mailbox */
        abuse_at_status: "valid" | "invalid" | "unverified" | "pending";
        /** Verification status of postmaster@ mailbox */
        postmaster_at_status: "valid" | "invalid" | "unverified" | "pending";
    }

    export interface VerifyOptions {
        domain: string;
        verifyDKIM?: boolean | undefined;
        verifySPF?: boolean | undefined;
    }

    export interface VerifyResults extends Status {
        dns?: {
            dkim_record: string;
            spf_record: string;
        } | undefined;
    }

    export interface CreateSubaccount {
        /** user-friendly name */
        name: string;
        /** user-friendly identifier for subaccount API key */
        keyLabel: string;
        /** list of grants to give the subaccount API key */
        keyGrants: string[];
        /** list of IPs the subaccount may be used from */
        keyValidIps?: string[] | undefined;
        /** id of the default IP pool assigned to subaccount"s transmissions */
        ipPool?: string | undefined;
    }

    export interface CreateSubaccountResponse {
        subaccount_id: number;
        key: string;
        label: string;
        short_key: string;
    }

    export interface UpdateSubaccount {
        /** the id of the subaccount you want to update */
        subaccountId: string | number;
        /** user-friendly name */
        name: string;
        /** status of the subaccount */
        status: string;
        /** id of the default IP pool assigned to subaccount"s transmissions */
        ipPool?: string | undefined;
    }

    export interface SubaccountInformation {
        /** ID of subaccount */
        id: number;
        /** User friendly identifier for a specific subaccount */
        name: string;
        /** Status of the account */
        status: "active" | "suspended" | "terminated";
        /** The ID of the default IP Pool assigned to this subaccount’s transmissions */
        ip_pool?: string | undefined;
        compliance_status: string;
    }

    export interface CreateSupressionListEntry {
        recipient: string;
        /** Whether the recipient requested to not receive any transactional messages. At a minimum, transactional or non_transactional is required upon creation of the entry.   */
        transactional?: boolean | undefined;
        /** Whether the recipient requested to not receive any non-transactional messages. At a minimum, transactional or non_transactional is required upon creation of the entry.   */
        non_transactional?: boolean | undefined;
        /** Short explanation of the suppression */
        description?: string | undefined;
    }

    export interface SupressionListEntry {
        recipient: string;
        /** Whether the recipient requested to not receive any transactional messages. At a minimum, transactional or non_transactional is required upon creation of the entry.   */
        transactional?: boolean | undefined;
        /** Whether the recipient requested to not receive any non-transactional messages. At a minimum, transactional or non_transactional is required upon creation of the entry.   */
        non_transactional?: boolean | undefined;
        /** Coming soon */
        type?: "transactional" | "non_transactional" | undefined;
        /** Source responsible for inserting the list entry. Valid values include: Spam Complaint, List Unsubscribe, Bounce Rule, Unsubscribe Link, Manually Added, Compliance. */
        source?: string | undefined;
        /** Short explanation of the suppression */
        description?: string | undefined;
        created: string;
        updated: string;
    }

    export interface SupressionSearch {
        /** Datetime the entries were last updated, in the format of YYYY-MM-DDTHH:mm:ssZ */
        to?: string | undefined;
        /** Datetime the entries were last updated, in the format YYYY-MM-DDTHH:mm:ssZ */
        from?: string | undefined;
        /** Types of entries to include in the search, i.e. entries with “transactional” and/or “non_transactional” keys set to true */
        types?: string | undefined;
        /** Sources of the entries to include in the search, i.e. entries that were added by this source */
        sources?: string | undefined;
        /** Maximum number of results to return. Must be between 1 and 100000. Default value is 100000. */
        limit?: number | undefined;
    }

    export interface TemplateContent {
        /** HTML content for the email’s text/html MIME part */
        html: string;
        /** Text content for the email’s text/plain MIME part */
        text: string;
        /** Email subject line. */
        subject: string;
        /**
         * Address “from” : "deals@company.com" or JSON object composed of the “name” and “email” fields
         * “from” : { “name” : “My Company”, “email” : "deals@company.com" } used to compose the email’s “From” header.
         */
        from: Address | string;
        /** Email address used to compose the email’s “Reply-To” header. */
        reply_to?: string | undefined;
        /**  JSON dictionary containing headers other than “Subject”, “From”, “To”, and “Reply-To”. */
        headers?: any;
    }

    export interface CreateTemplateContent {
        /** HTML content for the email’s text/html MIME part */
        html?: string | undefined;
        /** Text content for the email’s text/plain MIME part */
        text?: string | undefined;
        /** Email subject line. */
        subject: string;
        /**
         * Address “from” : "deals@company.com" or JSON object composed of the “name” and “email” fields
         * “from” : { “name” : “My Company”, “email” : "deals@company.com" } used to compose the email’s “From” header.
         */
        from: Address | string;
        /** Email address used to compose the email’s “Reply-To” header. */
        reply_to?: string | undefined;
        /**  JSON dictionary containing headers other than “Subject”, “From”, “To”, and “Reply-To”. */
        headers?: any;
    }

    export interface TemplateMeta {
        /** Unique template ID */
        id: string;
        /** Template name */
        name: string;
        /** Published state of the template (true = published, false = draft) */
        published: boolean;
        /** Template description */
        description: string;
    }

    export interface Template {
        /**
         * Short, unique, alphanumeric ID used to reference the template.
         * At a minimum, id or name is required upon creation. It is auto generated if not provided.
         * After a template has been created, this property cannot be changed. Maximum length - 64 bytes
         */
        id: string;
        /** Content that will be used to construct a message  yes  For a full description, see the Content Attributes. Maximum length - 20 MBs */
        content: TemplateContent | { email_rfc822: string };
        /** Whether the template is published or is a draft version  no - defaults to false  A template cannot be changed from published to draft. */
        published: boolean;
        /** Editable display name  At a minimum, id or name is required upon creation.  The name does not have to be unique. Maximum length - 1024 bytes */
        name: string;
        /** Detailed description of the template  no  Maximum length - 1024 bytes */
        description: string;
        /** JSON object in which template options are defined  no  For a full description, see the Options Attributes. */
        options: TemplateOptions;
        /** The “last_update_time” is the time the template was last updated, for both draft and published versions */
        last_update_time: string;
        /** The “last_use” time represents the last time any version of this template was used (draft or published). */
        last_use?: string | undefined;
    }

    export interface CreateTemplate {
        /**
         * Short, unique, alphanumeric ID used to reference the template.
         * At a minimum, id or name is required upon creation. It is auto generated if not provided.
         * After a template has been created, this property cannot be changed. Maximum length - 64 bytes
         */
        id?: string | undefined;
        /** Content that will be used to construct a message  yes  For a full description, see the Content Attributes. Maximum length - 20 MBs */
        content: CreateTemplateContent | { email_rfc822: string };
        /** Whether the template is published or is a draft version  no - defaults to false  A template cannot be changed from published to draft. */
        published?: boolean | undefined;
        /** Editable display name  At a minimum, id or name is required upon creation.  The name does not have to be unique. Maximum length - 1024 bytes */
        name?: string | undefined;
        /** Detailed description of the template  no  Maximum length - 1024 bytes */
        description?: string | undefined;
        /** JSON object in which template options are defined  no  For a full description, see the Options Attributes. */
        options?: CreateTemplateOptions | undefined;
    }

    export interface UpdateTemplate {
        /** Content that will be used to construct a message  yes  For a full description, see the Content Attributes. Maximum length - 20 MBs */
        content?: CreateTemplateContent | { email_rfc822: string } | undefined;
        /** Whether the template is published or is a draft version  no - defaults to false  A template cannot be changed from published to draft. */
        published?: boolean | undefined;
        /** Editable display name  At a minimum, id or name is required upon creation.  The name does not have to be unique. Maximum length - 1024 bytes */
        name?: string | undefined;
        /** Detailed description of the template  no  Maximum length - 1024 bytes */
        description?: string | undefined;
        /** JSON object in which template options are defined  no  For a full description, see the Options Attributes. */
        options?: CreateTemplateOptions | undefined;
    }

    export interface TemplateOptions {
        /** Enable or disable open tracking */
        open_tracking: boolean;
        /** Enable or disable click tracking */
        click_tracking: boolean;
        /** Distinguish between transactional and non-transactional messages for unsubscribe and suppression purposes */
        transactional: boolean;
    }

    export interface CreateTemplateOptions {
        /** Enable or disable open tracking */
        open_tracking?: boolean | undefined;
        /** Enable or disable click tracking */
        click_tracking?: boolean | undefined;
        /** Distinguish between transactional and non-transactional messages for unsubscribe and suppression purposes */
        transactional?: boolean | undefined;
    }

    export interface CreateTransmission {
        /** JSON object in which transmission options are defined */
        options?: TransmissionOptions | undefined;
        /** Inline recipient objects or object containing stored recipient list ID */
        recipients?: Recipient[] | { list_id: string } | undefined;
        /** Name of the campaign */
        campaign_id?: string | undefined;
        /** Description of the transmission */
        description?: string | undefined;
        /** Transmission level metadata containing key/value pairs */
        metadata?: any;
        /** Key/value pairs that are provided to the substitution engine */
        substitution_data?: any;
        /** SparkPost Enterprise API only: email to use for envelope FROM */
        return_path?: string | undefined;
        /** Content that will be used to construct a message */
        content: InlineContent | { template_id: string; use_draft_template?: boolean | undefined } | {
            email_rfc822: string;
        };
    }

    export interface TransmissionSummary {
        /** ID of the transmission */
        id: string;
        /** State of the transmission */
        state: "submitted" | "Generating" | "Success" | "Canceled";
        /** Description of the transmission */
        description: string;
        /** Name of the campaign */
        campaign_id: string;
        /** Content that will be used to construct a message */
        content: { template_id: string };
    }

    export interface Transmission {
        /** ID of the transmission */
        id: string;
        /** State of the transmission */
        state: "submitted" | "Generating" | "Success" | "Canceled";
        /** JSON object in which transmission options are defined */
        options: TransmissionOptions;
        /** Name of the campaign */
        campaign_id: string;
        /** Description of the transmission */
        description: string;
        /** Transmission level metadata containing key/value pairs */
        metadata: any;
        /** Key/value pairs that are provided to the substitution engine */
        substitution_data: any;
        /** Content that will be used to construct a message */
        content: InlineContent | { template_id: string; use_draft_template?: boolean | undefined } | {
            email_rfc822: string;
        };
        /** Computed total number of messages generated */
        num_generated: number;
        /** Computed total number of failed messages */
        num_failed_generation: number;
        /** Number of recipients that failed input validation */
        num_invalid_recipients: number;
        rcpt_list_chunk_size: number;
        rcpt_list_total_chunks: number;
    }

    export interface TransmissionOptions {
        /** Delay generation of messages until this datetime. */
        start_time?: string | undefined;
        /** Whether open tracking is enabled for this transmission */
        open_tracking?: boolean | undefined;
        /** Whether click tracking is enabled for this transmission */
        click_tracking?: boolean | undefined;
        /** Whether message is transactional or non-transactional for unsubscribe and suppression purposes */
        transactional?: boolean | undefined;
        /** Whether or not to use the sandbox sending domain */
        sandbox?: boolean | undefined;
        /** SparkPost Enterprise API only: Whether or not to ignore customer suppression rules, for this transmission only. Only applicable if your configuration supports this parameter. */
        skip_suppression?: boolean | undefined;
        /** The ID of a dedicated IP pool associated with your account ( Note: SparkPost only ). */
        ip_pool?: string | undefined;
        /** Whether or not to perform CSS inlining in HTML content */
        inline_css?: boolean | undefined;
    }

    export interface InlineContent {
        /** HTML content for the email’s text/html MIME part  At a minimum, html, text, or push is required. */
        html?: string | undefined;
        /** Text content for the email’s text/plain MIME part  At a minimum, html, text, or push is required. */
        text?: string | undefined;
        /**  Content of push notifications  At a minimum, html, text, or push is required.  SparkPost Enterprise API only. */
        push?: PushData | undefined;
        /** Email subject line  required for email transmissions  Expected in the UTF-8 charset without RFC2047 encoding. Substitution syntax is supported. */
        subject?: string | undefined;
        /** "deals@company.com" or JSON object composed of the “name” and “email” fields “from” : { “name” : “My Company”, “email” : "deals@company.com" } used to compose the email’s “From” header */
        from?: string | { email: string; name: string } | undefined;
        /** Email address used to compose the email’s “Reply-To” header */
        reply_to?: string | undefined;
        /** JSON dictionary containing headers other than “Subject”, “From”, “To”, and “Reply-To” */
        headers?: any;
        /** JSON array of attachments. */
        attachments?: Attachment[] | undefined;
        /** JSON array of inline images. */
        inline_images?: Attachment[] | undefined;
    }

    export interface PushData {
        /** payload for APNs messages */
        apns?: any;
        /** payload for GCM messages */
        gcm?: any;
    }

    export interface Attachment {
        /**
         * The MIME type of the attachment; e.g., “text/plain”, “image/jpeg”, “audio/mp3”, “video/mp4”, “application/msword”, “application/pdf”, etc.,
         * including the “charset” parameter (text/html; charset=“UTF-8”) if needed.
         * The value will apply “as-is” to the “Content-Type” header of the generated MIME part for the attachment.
         */
        type: string;
        /**   The filename of the attachment (for example, “document.pdf”). This is inserted into the filename parameter of the Content-Disposition header. */
        name: string;
        /**
         * The content of the attachment as a Base64 encoded string.
         * The string should not contain \r\n line breaks.
         * The SparkPost systems will add line breaks as necessary to ensure the Base64 encoded lines contain no more than 76 characters each.
         */
        data: string;
    }

    export interface Webhook {
        /** User-friendly name for webhook */
        name: string;
        /** URL of the target to which to POST event batches */
        target: string;
        /** Array of event types this webhook will receive */
        events: string[];
        /** Type of authentication to be used during POST requests to target */
        auth_type?: string | undefined;
        /** Object containing details needed to request authorization credentials, as necessary */
        auth_request_details?: any;
        /** Object containing credentials needed to make authorized POST requests to target */
        auth_credentials?: any;
        /** Authentication token to present in the X-MessageSystems-Webhook-Token header of POST requests to target */
        auth_token?: string | undefined;
    }

    export interface UpdateWebhook {
        id: string;
        /** User-friendly name for webhook */
        name?: string | undefined;
        /** URL of the target to which to POST event batches */
        target?: string | undefined;
        /** Array of event types this webhook will receive */
        events?: string[] | undefined;
        /** Type of authentication to be used during POST requests to target */
        auth_type?: string | undefined;
        /** Object containing details needed to request authorization credentials, as necessary */
        auth_request_details?: any;
        /** Object containing credentials needed to make authorized POST requests to target */
        auth_credentials?: any;
        /** Authentication token to present in the X-MessageSystems-Webhook-Token header of POST requests to target */
        auth_token?: string | undefined;
    }

    export interface WebhookLinks {
        links: {
            href: string;
            rel: string;
            method: string[];
        }[];
    }
}

export = SparkPost;
