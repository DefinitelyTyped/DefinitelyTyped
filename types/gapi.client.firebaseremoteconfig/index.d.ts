// Type definitions for non-npm package Google Firebase Remote Config API v1 1.0
// Project: https://firebase.google.com/docs/remote-config/
// Definitions by: Bolisov Alexey <https://github.com/Bolisov>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped
// TypeScript Version: 2.3

// IMPORTANT
// This file was generated by https://github.com/Bolisov/google-api-typings-generator. Please do not edit it manually.
// In case of any problems please post issue to https://github.com/Bolisov/google-api-typings-generator
// Generated from: https://firebaseremoteconfig.googleapis.com/$discovery/rest?version=v1

/// <reference types="gapi.client" />

declare namespace gapi.client {
    /** Load Firebase Remote Config API v1 */
    function load(name: "firebaseremoteconfig", version: "v1"): PromiseLike<void>;
    function load(name: "firebaseremoteconfig", version: "v1", callback: () => any): void;

    const projects: firebaseremoteconfig.ProjectsResource;

    namespace firebaseremoteconfig {
        interface RemoteConfig {
            /**
             * The list of named conditions. The order &#42;does&#42; affect the semantics.
             * The condition_name values of these entries must be unique.
             *
             * The resolved value of a config parameter P is determined as follow:
             * &#42; Let Y be the set of values from the submap of P that refer to conditions
             * that evaluate to <code>true</code>.
             * &#42; If Y is non empty, the value is taken from the specific submap in Y whose
             * condition_name is the earliest in this condition list.
             * &#42; Else, if P has a default value option (condition_name is empty) then
             * the value is taken from that option.
             * &#42; Else, parameter P has no value and is omitted from the config result.
             *
             * Example: parameter key "p1", default value "v1", submap specified as
             * {"c1": v2, "c2": v3} where "c1" and "c2" are names of conditions in the
             * condition list (where "c1" in this example appears before "c2").  The
             * value of p1 would be v2 as long as c1 is true.  Otherwise, if c2 is true,
             * p1 would evaluate to v3, and if c1 and c2 are both false, p1 would evaluate
             * to v1.  If no default value was specified, and c1 and c2 were both false,
             * no value for p1 would be generated.
             */
            conditions?: RemoteConfigCondition[];
            /**
             * Map of parameter keys to their optional default values and optional submap
             * of (condition name : value). Order doesn't affect semantics, and so is
             * sorted by the server. The 'key' values of the params must be unique.
             */
            parameters?: Record<string, RemoteConfigParameter>;
        }
        interface RemoteConfigCondition {
            /** Required. */
            expression?: string;
            /**
             * Required.
             * A non empty and unique name of this condition.
             */
            name?: string;
            /**
             * Optional.
             * The display (tag) color of this condition. This serves as part of a tag
             * (in the future, we may add tag text as well as tag color, but that is not
             * yet implemented in the UI).
             * This value has no affect on the semantics of the delivered config and it
             * is ignored by the backend, except for passing it through write/read
             * requests.
             * Not having this value or having the "CONDITION_DISPLAY_COLOR_UNSPECIFIED"
             * value (0) have the same meaning:  Let the UI choose any valid color when
             * displaying the condition.
             */
            tagColor?: string;
        }
        interface RemoteConfigParameter {
            /**
             * Optional - a map of (condition_name, value). The condition_name of the
             * highest priority (the one listed first in the conditions array) determines
             * the value of this parameter.
             */
            conditionalValues?: Record<string, RemoteConfigParameterValue>;
            /**
             * Optional - value to set the parameter to, when none of the named conditions
             * evaluate to <code>true</code>.
             */
            defaultValue?: RemoteConfigParameterValue;
        }
        interface RemoteConfigParameterValue {
            /** if true, omit the parameter from the map of fetched parameter values */
            useInAppDefault?: boolean;
            /** the string to set the parameter to */
            value?: string;
        }
        interface ProjectsResource {
            /**
             * Get the latest version Remote Configuration for a project.
             * Returns the RemoteConfig as the payload, and also the eTag as a
             * response header.
             */
            getRemoteConfig(request: {
                /** V1 error format. */
                "$.xgafv"?: string;
                /** OAuth access token. */
                access_token?: string;
                /** Data format for response. */
                alt?: string;
                /** OAuth bearer token. */
                bearer_token?: string;
                /** JSONP */
                callback?: string;
                /** Selector specifying which fields to include in a partial response. */
                fields?: string;
                /** API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token. */
                key?: string;
                /** OAuth 2.0 token for the current user. */
                oauth_token?: string;
                /** Pretty-print response. */
                pp?: boolean;
                /** Returns response with indentations and line breaks. */
                prettyPrint?: boolean;
                /**
                 * The GMP project identifier. Required.
                 * See note at the beginning of this file regarding project ids.
                 */
                project: string;
                /** Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. */
                quotaUser?: string;
                /** Legacy upload protocol for media (e.g. "media", "multipart"). */
                uploadType?: string;
                /** Upload protocol for media (e.g. "raw", "multipart"). */
                upload_protocol?: string;
            }): Request<RemoteConfig>;
            /**
             * Update a RemoteConfig. We treat this as an always-existing
             * resource (when it is not found in our data store, we treat it as version
             * 0, a template with zero conditions and zero parameters). Hence there are
             * no Create or Delete operations. Returns the updated template when
             * successful (and the updated eTag as a response header), or an error if
             * things go wrong.
             * Possible error messages:
             * &#42; VALIDATION_ERROR (HTTP status 400) with additional details if the
             * template being passed in can not be validated.
             * &#42; AUTHENTICATION_ERROR (HTTP status 401) if the request can not be
             * authenticate (e.g. no access token, or invalid access token).
             * &#42; AUTHORIZATION_ERROR (HTTP status 403) if the request can not be
             * authorized (e.g. the user has no access to the specified project id).
             * &#42; VERSION_MISMATCH (HTTP status 412) when trying to update when the
             * expected eTag (passed in via the "If-match" header) is not specified, or
             * is specified but does does not match the current eTag.
             * &#42; Internal error (HTTP status 500) for Database problems or other internal
             * errors.
             */
            updateRemoteConfig(request: {
                /** V1 error format. */
                "$.xgafv"?: string;
                /** OAuth access token. */
                access_token?: string;
                /** Data format for response. */
                alt?: string;
                /** OAuth bearer token. */
                bearer_token?: string;
                /** JSONP */
                callback?: string;
                /** Selector specifying which fields to include in a partial response. */
                fields?: string;
                /** API key. Your API key identifies your project and provides you with API access, quota, and reports. Required unless you provide an OAuth 2.0 token. */
                key?: string;
                /** OAuth 2.0 token for the current user. */
                oauth_token?: string;
                /** Pretty-print response. */
                pp?: boolean;
                /** Returns response with indentations and line breaks. */
                prettyPrint?: boolean;
                /**
                 * The GMP project identifier. Required.
                 * See note at the beginning of this file regarding project ids.
                 */
                project: string;
                /** Available to use for quota purposes for server-side applications. Can be any arbitrary string assigned to a user, but should not exceed 40 characters. */
                quotaUser?: string;
                /** Legacy upload protocol for media (e.g. "media", "multipart"). */
                uploadType?: string;
                /** Upload protocol for media (e.g. "raw", "multipart"). */
                upload_protocol?: string;
                /**
                 * Optional. Defaults to <code>false</code> (UpdateRemoteConfig call should
                 * update the backend if there are no validation/interal errors). May be set
                 * to <code>true</code> to indicate that, should no validation errors occur,
                 * the call should return a "200 OK" instead of performing the update. Note
                 * that other error messages (500 Internal Error, 412 Version Mismatch, etc)
                 * may still result after flipping to <code>false</code>, even if getting a
                 * "200 OK" when calling with <code>true</code>.
                 */
                validateOnly?: boolean;
            }): Request<RemoteConfig>;
        }
    }
}
