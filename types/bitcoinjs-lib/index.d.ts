/** Declaration file initially generated by dts-gen for bitcoinjs-lib 3.0.3*/

// Definitions by: Daniel <https://github.com/dlebrecht>.
/* modified by dlebrecht based on the flow version found at https://github.com/flowtype/flow-typed/blob/master/definitions/npm/bitcoinjs-lib_v2.x.x/flow_v0.17.x-/bitcoinjs-lib_v2.x.x.js */


export type Utxo = {
  address: string;
  amount: number;
  scriptPubKey: Buffer;
  txid: string;
  vout: number;
}

export type Output = {
    script: Buffer;
    value: number;
};

export type Input = {
  script: Buffer;
  hash: Buffer;
  index: number;
  sequence: number;
};

export type Network = {
  bip32: {
    public: number;
    private: number;
  };
  messagePrefix: string;
  pubKeyHash: number;
  scriptHash: number;
  wif: number;
}


export class Block {
    constructor();

    byteLength(headersOnly: any): any;

    checkMerkleRoot(): any;

    checkProofOfWork(): any;

    getHash(): Buffer;

    getId(): string;

    getUTCDate(): any;

    toBuffer(headersOnly?: boolean): Buffer;

    toHex(headersOnly?: boolean): string;

    static calculateMerkleRoot(transactions: any): any;

    static calculateTarget(bits: any): any;

    static fromBuffer(buffer: Buffer): any;

    static fromHex(hex: string): any;

}

export class ECPair {
    constructor(d: any, Q: any, options: any);

    getAddress(): string;

    getNetwork(): Network;

    getPublicKeyBuffer(): Buffer;

    sign(hash: Buffer): Buffer;

    toWIF(): string;

    verify(hash: Buffer, signature: ECSignature): boolean;

    static fromPublicKeyBuffer(buffer: Buffer, network: Network): ECPair;

    static fromWIF(string: string, network: Network): ECPair;

    static makeRandom(options: any): ECPair;

}

export class ECSignature {
    constructor(r: any, s: any, ...args: any[]);

    toCompact(i: any, compressed: any): any;

    toDER(): any;

    toScriptSignature(hashType: any): any;

    static fromDER(buffer: Buffer): any;

    static parseCompact(buffer: Buffer): any;

    static parseScriptSignature(buffer: Buffer): any;

}

export class HDNode {
    constructor(keyPair: ECPair, chainCode: any, ...args: any[]);

    keyPair: ECPair // dl added manually TODO check if correct

    derive(index: number): HDNode;

    deriveHardened(index: number): HDNode;

    derivePath(path: string): HDNode;

    getAddress(): string;

    getFingerprint(): Buffer;

    getIdentifier(): Buffer;

    getNetwork(): any;

    getPublicKeyBuffer(): Buffer;

    isNeutered(): boolean;

    neutered(): HDNode;

    sign(hash: Buffer): ECSignature;

    toBase58(__isPrivate?: any): string;

    verify(hash: Buffer, signature: any): Buffer;

    static HIGHEST_BIT: number;

    static LENGTH: number;

    static fromBase58(string: string, networks?: any): HDNode;

    static fromSeedBuffer(seed: Buffer, network: Network, ...args: any[]): HDNode;

    static fromSeedHex(hex: string, network: Network): HDNode;

}

export class Transaction {
    version: number;
    locktime: number;
    ins: Array<Input>;
    outs: Array<Output>;
    constructor();

    addInput(hash: Buffer, index: number, sequence: any, scriptSig: Buffer, ...args: any[]): any;

    addOutput(scriptPubKey: any, value: any, ...args: any[]): any;

    byteLength(): any;

    clone(): Transaction;

    getHash(): Buffer;

    getId(): any;

    hasWitnesses(): any;

    hashForSignature(inindex: number, prevOutScript: any, hashType: any, ...args: any[]): any;

    hashForWitnessV0(inindex: number, prevOutScript: any, value: any, hashType: any, ...args: any[]): any;

    isCoinbase(): boolean;

    setInputScript(index: number, scriptSig: Buffer, ...args: any[]): void;

    setWitness(index: number, witness: any, ...args: any[]): void;

    toBuffer(buffer: Buffer, initialOffset: any): Buffer;

    toHex(): any;

    static ADVANCED_TRANSACTION_FLAG: number;

    static ADVANCED_TRANSACTION_MARKER: number;

    static DEFAULT_SEQUENCE: number;

    static SIGHASH_ALL: number;

    static SIGHASH_ANYONECANPAY: number;

    static SIGHASH_NONE: number;

    static SIGHASH_SINGLE: number;

    static fromBuffer(buffer: Buffer, __noStrict: any): Transaction;

    static fromHex(hex: string): Transaction;

    static isCoinbaseHash(buffer: Buffer): any;

}

export class TransactionBuilder {
    constructor(network: Network, maximumFeeRate?: any);

  addInput(txhash: Buffer|string|Transaction, vout: number, sequence?: number, prevOutScript?: Buffer): void;

  addOutput(scriptPubKey: Buffer|string, value: any): any;

    build(): Transaction;

    buildIncomplete(): Transaction;

    setLockTime(locktime: number): void;

    setVersion(version: number): void;

    sign(vin: number, keyPair: ECPair, redeemScript?: Buffer, hashType?: number, witnessValue?: any, witnessScript?: any): void;

    static fromTransaction(transaction: Transaction, network: Network): TransactionBuilder;

}


export const networks: {
    bitcoin: Network ;
    litecoin: Network;
    testnet: Network;
};

export const opcodes: {
    OP_0: number;
    OP_0NOTEQUAL: number;
    OP_1: number;
    OP_10: number;
    OP_11: number;
    OP_12: number;
    OP_13: number;
    OP_14: number;
    OP_15: number;
    OP_16: number;
    OP_1ADD: number;
    OP_1NEGATE: number;
    OP_1SUB: number;
    OP_2: number;
    OP_2DIV: number;
    OP_2DROP: number;
    OP_2DUP: number;
    OP_2MUL: number;
    OP_2OVER: number;
    OP_2ROT: number;
    OP_2SWAP: number;
    OP_3: number;
    OP_3DUP: number;
    OP_4: number;
    OP_5: number;
    OP_6: number;
    OP_7: number;
    OP_8: number;
    OP_9: number;
    OP_ABS: number;
    OP_ADD: number;
    OP_AND: number;
    OP_BOOLAND: number;
    OP_BOOLOR: number;
    OP_CAT: number;
    OP_CHECKLOCKTIMEVERIFY: number;
    OP_CHECKMULTISIG: number;
    OP_CHECKMULTISIGVERIFY: number;
    OP_CHECKSIG: number;
    OP_CHECKSIGVERIFY: number;
    OP_CODESEPARATOR: number;
    OP_DEPTH: number;
    OP_DIV: number;
    OP_DROP: number;
    OP_DUP: number;
    OP_ELSE: number;
    OP_ENDIF: number;
    OP_EQUAL: number;
    OP_EQUALVERIFY: number;
    OP_FALSE: number;
    OP_FROMALTSTACK: number;
    OP_GREATERTHAN: number;
    OP_GREATERTHANOREQUAL: number;
    OP_HASH160: number;
    OP_HASH256: number;
    OP_IF: number;
    OP_IFDUP: number;
    OP_INVALIDOPCODE: number;
    OP_INVERT: number;
    OP_LEFT: number;
    OP_LESSTHAN: number;
    OP_LESSTHANOREQUAL: number;
    OP_LSHIFT: number;
    OP_MAX: number;
    OP_MIN: number;
    OP_MOD: number;
    OP_MUL: number;
    OP_NEGATE: number;
    OP_NIP: number;
    OP_NOP: number;
    OP_NOP1: number;
    OP_NOP10: number;
    OP_NOP2: number;
    OP_NOP3: number;
    OP_NOP4: number;
    OP_NOP5: number;
    OP_NOP6: number;
    OP_NOP7: number;
    OP_NOP8: number;
    OP_NOP9: number;
    OP_NOT: number;
    OP_NOTIF: number;
    OP_NUMEQUAL: number;
    OP_NUMEQUALVERIFY: number;
    OP_NUMNOTEQUAL: number;
    OP_OR: number;
    OP_OVER: number;
    OP_PICK: number;
    OP_PUBKEY: number;
    OP_PUBKEYHASH: number;
    OP_PUSHDATA1: number;
    OP_PUSHDATA2: number;
    OP_PUSHDATA4: number;
    OP_RESERVED: number;
    OP_RESERVED1: number;
    OP_RESERVED2: number;
    OP_RETURN: number;
    OP_RIGHT: number;
    OP_RIPEMD160: number;
    OP_ROLL: number;
    OP_ROT: number;
    OP_RSHIFT: number;
    OP_SHA1: number;
    OP_SHA256: number;
    OP_SIZE: number;
    OP_SUB: number;
    OP_SUBSTR: number;
    OP_SWAP: number;
    OP_TOALTSTACK: number;
    OP_TRUE: number;
    OP_TUCK: number;
    OP_VER: number;
    OP_VERIF: number;
    OP_VERIFY: number;
    OP_VERNOTIF: number;
    OP_WITHIN: number;
    OP_XOR: number;
};

export namespace HDNode {
    namespace MASTER_SECRET {
        const BYTES_PER_ELEMENT: number;

        const byteLength: number;

        const byteOffset: number;

        const length: number;

        const offset: number;

        function asciiSlice(): any;

        function asciiWrite(): any;

        function base64Slice(): any;

        function base64Write(): any;

        function compare(target: any, start: any, end: any, thisStart: any, thisEnd: any, ...args: any[]): any;

        function copy(): any;

        function copyWithin(p0: any, p1: any): any;

        function entries(): any;

        function equals(b: any): any;

        function every(p0: any): any;

        function fill(val: any, start: any, end: any, encoding: any): any;

        function filter(p0: any): any;

        function find(p0: any): any;

        function findIndex(p0: any): any;

        function forEach(p0: any): any;

        function hexSlice(): any;

        function hexWrite(): any;

        function includes(val: any, byteOffset: any, encoding: any): any;

        function indexOf(val: any, byteOffset: any, encoding: any): any;

        function inspect(): any;

        function join(p0: any): any;

        function keys(): any;

        function lastIndexOf(val: any, byteOffset: any, encoding: any): any;

        function latin1Slice(): any;

        function latin1Write(): any;

        function map(p0: any): any;

        function readDoubleBE(offset: any, noAssert: any): any;

        function readDoubleLE(offset: any, noAssert: any): any;

        function readFloatBE(offset: any, noAssert: any): any;

        function readFloatLE(offset: any, noAssert: any): any;

        function readInt16BE(offset: any, noAssert: any): any;

        function readInt16LE(offset: any, noAssert: any): any;

        function readInt32BE(offset: any, noAssert: any): any;

        function readInt32LE(offset: any, noAssert: any): any;

        function readInt8(offset: any, noAssert: any): any;

        function readIntBE(offset: any, byteLength: any, noAssert: any): any;

        function readIntLE(offset: any, byteLength: any, noAssert: any): any;

        function readUInt16BE(offset: any, noAssert: any): any;

        function readUInt16LE(offset: any, noAssert: any): any;

        function readUInt32BE(offset: any, noAssert: any): any;

        function readUInt32LE(offset: any, noAssert: any): any;

        function readUInt8(offset: any, noAssert: any): any;

        function readUIntBE(offset: any, byteLength: any, noAssert: any): any;

        function readUIntLE(offset: any, byteLength: any, noAssert: any): any;

        function reduce(p0: any): any;

        function reduceRight(p0: any): any;

        function reverse(): any;

        function set(p0: any): any;

        function slice(start: any, end: any): any;

        function some(p0: any): any;

        function sort(p0: any): any;

        function subarray(p0: any, p1: any): any;

        function swap16(): any;

        function swap32(): any;

        function swap64(): any;

        function toJSON(): any;

        function toLocaleString(encoding: any, start: any, end: any, ...args: any[]): any;

        function toString(encoding: any, start: any, end: any, ...args: any[]): any;

        function ucs2Slice(): any;

        function ucs2Write(): any;

        function utf8Slice(): any;

        function utf8Write(): any;

        function values(): any;

        function write(string: any, offset: any, length: any, encoding: any): any;

        function writeDoubleBE(val: any, offset: any, noAssert: any): any;

        function writeDoubleLE(val: any, offset: any, noAssert: any): any;

        function writeFloatBE(val: any, offset: any, noAssert: any): any;

        function writeFloatLE(val: any, offset: any, noAssert: any): any;

        function writeInt16BE(value: any, offset: any, noAssert: any): any;

        function writeInt16LE(value: any, offset: any, noAssert: any): any;

        function writeInt32BE(value: any, offset: any, noAssert: any): any;

        function writeInt32LE(value: any, offset: any, noAssert: any): any;

        function writeInt8(value: any, offset: any, noAssert: any): any;

        function writeIntBE(value: any, offset: any, byteLength: any, noAssert: any): any;

        function writeIntLE(value: any, offset: any, byteLength: any, noAssert: any): any;

        function writeUInt16BE(value: any, offset: any, noAssert: any): any;

        function writeUInt16LE(value: any, offset: any, noAssert: any): any;

        function writeUInt32BE(value: any, offset: any, noAssert: any): any;

        function writeUInt32LE(value: any, offset: any, noAssert: any): any;

        function writeUInt8(value: any, offset: any, noAssert: any): any;

        function writeUIntBE(value: any, offset: any, byteLength: any, noAssert: any): any;

        function writeUIntLE(value: any, offset: any, byteLength: any, noAssert: any): any;

        namespace asciiSlice {
            const prototype: {
            };

        }

        namespace asciiWrite {
            const prototype: {
            };

        }

        namespace base64Slice {
            const prototype: {
            };

        }

        namespace base64Write {
            const prototype: {
            };

        }

        namespace buffer {
            const byteLength: number;

            function slice(p0: any, p1: any): any;

        }

        namespace compare {
            const prototype: {
            };

        }

        namespace copy {
            const prototype: {
            };

        }

        namespace equals {
            const prototype: {
            };

        }

        namespace fill {
            const prototype: {
            };

        }

        namespace hexSlice {
            const prototype: {
            };

        }

        namespace hexWrite {
            const prototype: {
            };

        }

        namespace includes {
            const prototype: {
            };

        }

        namespace indexOf {
            const prototype: {
            };

        }

        namespace inspect {
            const prototype: {
            };

        }

        namespace lastIndexOf {
            const prototype: {
            };

        }

        namespace latin1Slice {
            const prototype: {
            };

        }

        namespace latin1Write {
            const prototype: {
            };

        }

        namespace parent {
            const byteLength: number;

            function slice(p0: any, p1: any): any;

        }

        namespace readDoubleBE {
            const prototype: {
            };

        }

        namespace readDoubleLE {
            const prototype: {
            };

        }

        namespace readFloatBE {
            const prototype: {
            };

        }

        namespace readFloatLE {
            const prototype: {
            };

        }

        namespace readInt16BE {
            const prototype: {
            };

        }

        namespace readInt16LE {
            const prototype: {
            };

        }

        namespace readInt32BE {
            const prototype: {
            };

        }

        namespace readInt32LE {
            const prototype: {
            };

        }

        namespace readInt8 {
            const prototype: {
            };

        }

        namespace readIntBE {
            const prototype: {
            };

        }

        namespace readIntLE {
            const prototype: {
            };

        }

        namespace readUInt16BE {
            const prototype: {
            };

        }

        namespace readUInt16LE {
            const prototype: {
            };

        }

        namespace readUInt32BE {
            const prototype: {
            };

        }

        namespace readUInt32LE {
            const prototype: {
            };

        }

        namespace readUInt8 {
            const prototype: {
            };

        }

        namespace readUIntBE {
            const prototype: {
            };

        }

        namespace readUIntLE {
            const prototype: {
            };

        }

        namespace slice {
            const prototype: {
            };

        }

        namespace swap16 {
            const prototype: {
            };

        }

        namespace swap32 {
            const prototype: {
            };

        }

        namespace swap64 {
            const prototype: {
            };

        }

        namespace toJSON {
            const prototype: {
            };

        }

        namespace toLocaleString {
            const prototype: {
            };

        }

        namespace toString {
            const prototype: {
            };

        }

        namespace ucs2Slice {
            const prototype: {
            };

        }

        namespace ucs2Write {
            const prototype: {
            };

        }

        namespace utf8Slice {
            const prototype: {
            };

        }

        namespace utf8Write {
            const prototype: {
            };

        }

        namespace write {
            const prototype: {
            };

        }

        namespace writeDoubleBE {
            const prototype: {
            };

        }

        namespace writeDoubleLE {
            const prototype: {
            };

        }

        namespace writeFloatBE {
            const prototype: {
            };

        }

        namespace writeFloatLE {
            const prototype: {
            };

        }

        namespace writeInt16BE {
            const prototype: {
            };

        }

        namespace writeInt16LE {
            const prototype: {
            };

        }

        namespace writeInt32BE {
            const prototype: {
            };

        }

        namespace writeInt32LE {
            const prototype: {
            };

        }

        namespace writeInt8 {
            const prototype: {
            };

        }

        namespace writeIntBE {
            const prototype: {
            };

        }

        namespace writeIntLE {
            const prototype: {
            };

        }

        namespace writeUInt16BE {
            const prototype: {
            };

        }

        namespace writeUInt16LE {
            const prototype: {
            };

        }

        namespace writeUInt32BE {
            const prototype: {
            };

        }

        namespace writeUInt32LE {
            const prototype: {
            };

        }

        namespace writeUInt8 {
            const prototype: {
            };

        }

        namespace writeUIntBE {
            const prototype: {
            };

        }

        namespace writeUIntLE {
            const prototype: {
            };

        }

    }


}



export namespace address {
    function fromBase58Check(address: string): string;

    function fromOutputScript(outputScript: Buffer, network: Network): string;

    function toBase58Check(hash: Buffer, version: number, ...args: any[]): any;

    function toOutputScript(address: string, network: Network): any;

    namespace fromBase58Check {
        const prototype: {
        };

    }

    namespace fromOutputScript {
        const prototype: {
        };

    }

    namespace toBase58Check {
        const prototype: {
        };

    }

    namespace toOutputScript {
        const prototype: {
        };

    }

}

export namespace bufferutils {
    function pushDataSize(i: any): any;

    function readPushDataInt(buffer: Buffer, offset: any): any;

    function readUInt64LE(buffer: Buffer, offset: any): any;

    function readVarInt(buffer: Buffer, offset: any): any;

    function varIntBuffer(number: number, buffer: Buffer, offset: any): any;

    function varIntSize(number: number): any;

    function writePushDataInt(buffer: Buffer, number: number, offset: any): any;

    function writeUInt64LE(buffer: Buffer, value: any, offset: any): any;

    function writeVarInt(buffer: Buffer, number: number, offset: any): any;

    namespace pushDataSize {
        const prototype: {
        };

    }

    namespace readPushDataInt {
        const prototype: {
        };

    }

    namespace readUInt64LE {
        const prototype: {
        };

    }

    namespace readVarInt {
        const prototype: {
        };

    }

    namespace varIntBuffer {
        const prototype: {
        };

    }

    namespace varIntSize {
        const prototype: {
        };

    }

    namespace writePushDataInt {
        const prototype: {
        };

    }

    namespace writeUInt64LE {
        const prototype: {
        };

    }

    namespace writeVarInt {
        const prototype: {
        };

    }

}

export namespace crypto {
    function hash160(buffer: Buffer): Buffer;

    function hash256(buffer: Buffer): any;

    function ripemd160(buffer: Buffer): any;

    function sha1(buffer: Buffer): any;

    function sha256(buffer: Buffer): any;

    namespace hash160 {
        const prototype: {
        };

    }

    namespace hash256 {
        const prototype: {
        };

    }

    namespace ripemd160 {
        const prototype: {
        };

    }

    namespace sha1 {
        const prototype: {
        };

    }

    namespace sha256 {
        const prototype: {
        };

    }

}

export namespace script {
    const multisig: {
        input: {
            check: any;
            decode: any;
            decodeStack: any;
            encode: any;
            encodeStack: any;
        };
        output: {
            check: any;
            decode: any;
            encode: any;
        };
    };

    const nullData: {
        output: {
            check: any;
            decode: any;
            encode: any;
        };
    };

    const pubKey: {
        input: {
            check: any;
            decode: any;
            decodeStack: any;
            encode: any;
            encodeStack: any;
        };
        output: {
            check: any;
            decode: any;
            encode: any;
        };
    };

    const pubKeyHash: {
        input: {
            check: any;
            decode: any;
            decodeStack: any;
            encode: any;
            encodeStack: any;
        };
        output: {
            check: any;
            decode: any;
            encode: any;
        };
    };

    const scriptHash: {
        input: {
            check: any;
            decode: any;
            decodeStack: any;
            encode: any;
            encodeStack: any;
        };
        output: {
            check: any;
            decode: any;
            encode: any;
        };
    };

    const types: {
        MULTISIG: string;
        NONSTANDARD: string;
        NULLDATA: string;
        P2PK: string;
        P2PKH: string;
        P2SH: string;
        P2WPKH: string;
        P2WSH: string;
        WITNESS_COMMITMENT: string;
    };

    const witnessCommitment: {
        output: {
            check: any;
            decode: any;
            encode: any;
        };
    };

    const witnessPubKeyHash: {
        input: {
            check: any;
            decodeStack: any;
            encodeStack: any;
        };
        output: {
            check: any;
            decode: any;
            encode: any;
        };
    };

    const witnessScriptHash: {
        input: {
            check: any;
            decodeStack: any;
            encodeStack: any;
        };
        output: {
            check: any;
            decode: any;
            encode: any;
        };
    };

    function classifyInput(script: any, allowIncomplete: any): any;

    function classifyOutput(script: any): any;

    function classifyWitness(script: any, allowIncomplete: any): any;

    function compile(chunks: any): any;

    function decompile(buffer: Buffer): any;

    function fromASM(asm: any): any;

    function isCanonicalPubKey(buffer: Buffer): any;

    function isCanonicalSignature(buffer: Buffer): any;

    function isDefinedHashType(hashType: any): any;

    function isPushOnly(value: any): any;

    function toASM(chunks: any): any;

    function toStack(chunks: any): any;

    namespace classifyInput {
        const prototype: {
        };

    }

    namespace classifyOutput {
        const prototype: {
        };

    }

    namespace classifyWitness {
        const prototype: {
        };

    }

    namespace compile {
        const prototype: {
        };

    }

    namespace decompile {
        const prototype: {
        };

    }

    namespace fromASM {
        const prototype: {
        };

    }

    namespace isCanonicalPubKey {
        const prototype: {
        };

    }

    namespace isCanonicalSignature {
        const prototype: {
        };

    }

    namespace isDefinedHashType {
        const prototype: {
        };

    }

    namespace isPushOnly {
        const prototype: {
        };

    }

    namespace number {
        function decode(buffer: Buffer, maxLength: any, minimal: any): any;

        function encode(number: number): any;

        namespace decode {
            const prototype: {
            };

        }

        namespace encode {
            const prototype: {
            };

        }

    }

    namespace toASM {
        const prototype: {
        };

    }

    namespace toStack {
        const prototype: {
        };

    }

}
