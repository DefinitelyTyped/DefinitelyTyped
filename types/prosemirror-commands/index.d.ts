// Type definitions for prosemirror-commands 1.0
// Project: https://github.com/ProseMirror/prosemirror-commands
// Definitions by: Bradley Ayers <https://github.com/bradleyayers>
//                 David Hahn <https://github.com/davidka>
//                 Tim Baumann <https://github.com/timjb>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped
// TypeScript Version: 2.1

// IMPORTANT
// This file was generated by https://github.com/bradleyayers/getdocs2ts. Please do not edit manually.
// When you find an error in these declarations, fix the getdocs comment upstream or 'getdocs2ts', then regenerate.

import { MarkType, Node as ProsemirrorNode, NodeType } from 'prosemirror-model';
import { EditorState, Transaction } from 'prosemirror-state';
import { EditorView } from 'prosemirror-view';

/**
 * Delete the selection, if there is one.
 */
export function deleteSelection(state: EditorState, dispatch?: (tr: Transaction) => void): boolean;
/**
 * If the selection is empty and at the start of a textblock, try to
 * reduce the distance between that block and the one before itâ€”if
 * there's a block directly before it that can be joined, join them.
 * If not, try to move the selected block closer to the next one in
 * the document structure by lifting it out of its parent or moving it
 * into a parent of the previous block. Will use the view for accurate
 * (bidi-aware) start-of-textblock detection if given.
 */
export function joinBackward(state: EditorState, dispatch?: (tr: Transaction) => void, view?: EditorView): boolean;
/**
 * When the selection is empty and at the start of a textblock, select
 * the node before that textblock, if possible. This is intended to be
 * bound to keys like backspace, after
 * [`joinBackward`](#commands.joinBackward) or other deleting
 * commands, as a fall-back behavior when the schema doesn't allow
 * deletion at the selected point.
 */
export function selectNodeBackward(state: EditorState, dispatch?: (tr: Transaction) => void, view?: EditorView): boolean;
/**
 * If the selection is empty and the cursor is at the end of a
 * textblock, try to reduce or remove the boundary between that block
 * and the one after it, either by joining them or by moving the other
 * block closer to this one in the tree structure. Will use the view
 * for accurate start-of-textblock detection if given.
 */
export function joinForward(state: EditorState, dispatch?: (tr: Transaction) => void, view?: EditorView): boolean;
/**
 * When the selection is empty and at the end of a textblock, select
 * the node coming after that textblock, if possible. This is intended
 * to be bound to keys like delete, after
 * [`joinForward`](#commands.joinForward) and similar deleting
 * commands, to provide a fall-back behavior when the schema doesn't
 * allow deletion at the selected point.
 */
export function selectNodeForward(state: EditorState, dispatch?: (tr: Transaction) => void, view?: EditorView): boolean;
/**
 * Join the selected block or, if there is a text selection, the
 * closest ancestor block of the selection that can be joined, with
 * the sibling above it.
 */
export function joinUp(state: EditorState, dispatch?: (tr: Transaction) => void): boolean;
/**
 * Join the selected block, or the closest ancestor of the selection
 * that can be joined, with the sibling after it.
 */
export function joinDown(state: EditorState, dispatch?: (tr: Transaction) => void): boolean;
/**
 * Lift the selected block, or the closest ancestor block of the
 * selection that can be lifted, out of its parent node.
 */
export function lift(state: EditorState, dispatch?: (tr: Transaction) => void): boolean;
/**
 * If the selection is in a node whose type has a truthy
 * [`code`](#model.NodeSpec.code) property in its spec, replace the
 * selection with a newline character.
 */
export function newlineInCode(state: EditorState, dispatch?: (tr: Transaction) => void): boolean;
/**
 * When the selection is in a node with a truthy
 * [`code`](#model.NodeSpec.code) property in its spec, create a
 * default block after the code block, and move the cursor there.
 */
export function exitCode(state: EditorState, dispatch?: (tr: Transaction) => void): boolean;
/**
 * If a block node is selected, create an empty paragraph before (if
 * it is its parent's first child) or after it.
 */
export function createParagraphNear(state: EditorState, dispatch?: (tr: Transaction) => void): boolean;
/**
 * If the cursor is in an empty textblock that can be lifted, lift the
 * block.
 */
export function liftEmptyBlock(state: EditorState, dispatch?: (tr: Transaction) => void): boolean;
/**
 * Split the parent block of the selection. If the selection is a text
 * selection, also delete its content.
 */
export function splitBlock(state: EditorState, dispatch?: (tr: Transaction) => void): boolean;
/**
 * Acts like [`splitBlock`](#commands.splitBlock), but without
 * resetting the set of active marks at the cursor.
 */
export function splitBlockKeepMarks(state: EditorState, dispatch?: (tr: Transaction) => void): boolean;
/**
 * Move the selection to the node wrapping the current selection, if
 * any. (Will not select the document node.)
 */
export function selectParentNode(state: EditorState, dispatch?: (tr: Transaction) => void): boolean;
/**
 * Select the whole document.
 */
export function selectAll(state: EditorState, dispatch?: (tr: Transaction) => void): boolean;
/**
 * Wrap the selection in a node of the given type with the given
 * attributes.
 */
export function wrapIn(nodeType: NodeType, attrs?: { [key: string]: any }): (state: EditorState, dispatch?: (tr: Transaction) => void) => boolean;
/**
 * Returns a command that tries to set the textblock around the
 * selection to the given node type with the given attributes.
 */
export function setBlockType(nodeType: NodeType, attrs?: { [key: string]: any }): (state: EditorState, dispatch?: (tr: Transaction) => void) => boolean;
/**
 * Create a command function that toggles the given mark with the
 * given attributes. Will return `false` when the current selection
 * doesn't support that mark. This will remove the mark if any marks
 * of that type exist in the selection, or add it otherwise. If the
 * selection is empty, this applies to the [stored
 * marks](#state.EditorState.storedMarks) instead of a range of the
 * document.
 */
export function toggleMark(markType: MarkType, attrs?: { [key: string]: any }): (state: EditorState, dispatch?: (tr: Transaction) => void) => boolean;
/**
 * Wrap a command so that, when it produces a transform that causes
 * two joinable nodes to end up next to each other, those are joined.
 * Nodes are considered joinable when they are of the same type and
 * when the `isJoinable` predicate returns true for them or, if an
 * array of strings was passed, if their node type name is in that
 * array.
 */
export function autoJoin(
  command: (state: EditorState, p1?: (tr: Transaction) => void) => boolean,
  isJoinable: ((before: ProsemirrorNode, after: ProsemirrorNode) => boolean) | string[]
): (state: EditorState, p1?: (tr: Transaction) => void) => boolean;
/**
 * Combine a number of command functions into a single function (which
 * calls them one by one until one returns true).
 */
export function chainCommands(
  ...commands: Array<(p1: EditorState, p2?: (tr: Transaction) => void, p3?: EditorView) => boolean>
): (p1: EditorState, p2?: (tr: Transaction) => void, p3?: EditorView) => boolean;
/**
 * A basic keymap containing bindings not specific to any schema.
 * Binds the following keys (when multiple commands are listed, they
 * are chained with [`chainCommands`](#commands.chainCommands)):
 *
 * * **Enter** to `newlineInCode`, `createParagraphNear`, `liftEmptyBlock`, `splitBlock`
 * * **Mod-Enter** to `exitCode`
 * * **Backspace** and **Mod-Backspace** to `deleteSelection`, `joinBackward`, `selectNodeBackward`
 * * **Delete** and **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`
 * * **Mod-Delete** to `deleteSelection`, `joinForward`, `selectNodeForward`
 * * **Mod-a** to `selectAll`
 */
export let pcBaseKeymap: { [key: string]: any };
/**
 * A copy of `pcBaseKeymap` that also binds **Ctrl-h** like Backspace,
 * **Ctrl-d** like Delete, **Alt-Backspace** like Ctrl-Backspace, and
 * **Ctrl-Alt-Backspace**, **Alt-Delete**, and **Alt-d** like
 * Ctrl-Delete.
 */
export let macBaseKeymap: { [key: string]: any };
/**
 * Depending on the detected platform, this will hold
 * [`pcBasekeymap`](#commands.pcBaseKeymap) or
 * [`macBaseKeymap`](#commands.macBaseKeymap).
 */
export let baseKeymap: { [key: string]: any };
