import { YGFlexDirection, YGDirection, YGNodeType, YGEdge, YGAlign, YGMeasureMode } from './enums';
import { YGFloatOptional } from './ygfloatoptional';
import { YGConfig } from './ygconfig';
import { YGLayout } from './yglayout';
import { YGStyle } from './ygstyle';
import { YGValue } from './ygvalue';
import { YGPrintFunc, YGMeasureFunc, YGBaselineFunc, YGDirtiedFunc, YGSize } from './yoga';
interface IterChildrenCallback {
    (node: YGNode, cloneContext: any): void;
}
declare class YGNode {
    private context_;
    private print_;
    private hasNewLayout_;
    private isReferenceBaseline_;
    private nodeType_;
    private measure_;
    private baseline_;
    private dirtied_;
    private style_;
    private layout_;
    private lineIndex_;
    private owner_;
    private children_;
    private config_;
    private isDirty_;
    private resolvedDimensions_;
    private relativePosition;
    constructor(node?: YGNode);
    constructor(config?: YGConfig);
    initialize(print?: YGPrintFunc, hasNewLayout?: boolean, isReferenceBaseline?: boolean, nodeType?: YGNodeType, measure?: YGMeasureFunc, baseline?: YGBaselineFunc, dirtied?: YGDirtiedFunc, style?: YGStyle, layout?: YGLayout, lineIndex?: number, owner?: YGNode, children?: Array<YGNode>, config?: YGConfig, isDirty?: boolean, resolvedDimensions?: [YGValue, YGValue]): void;
    operatorAtrib(node: YGNode): YGNode;
    fromNode(node: YGNode): void;
    print(printContext?: any): void;
    computeEdgeValueForRow(edges: Array<YGValue>, rowEdge: YGEdge, edge: YGEdge, defaultValue: YGValue): YGValue;
    computeEdgeValueForColumn(edges: Array<YGValue>, edge: YGEdge, defaultValue: YGValue): YGValue;
    measure(width: number, widthMode: YGMeasureMode, height: number, heightMode: YGMeasureMode, layoutContext?: any): YGSize;
    baseline(width: number, height: number, layoutContext?: any): number;
    useWebDefaults(): void;
    hasMeasureFunc(): boolean;
    hasBaselineFunc(): boolean;
    getContext(): any;
    getHasNewLayout(): boolean;
    getNodeType(): YGNodeType;
    getDirtied(): YGDirtiedFunc;
    getStyle(): YGStyle;
    getLayout(): YGLayout;
    getLineIndex(): number;
    isReferenceBaseline(): boolean;
    getOwner(): YGNode;
    getParent(): YGNode;
    getChildren(): Array<YGNode>;
    getChildrenCount(): number;
    getChild(index: number): YGNode;
    getConfig(): YGConfig;
    isDirty(): boolean;
    getResolvedDimensions(): [YGValue, YGValue];
    getResolvedDimension(index: number): YGValue;
    getLeadingPosition(axis: YGFlexDirection, axisSize: number): YGFloatOptional;
    isLeadingPositionDefined(axis: YGFlexDirection): boolean;
    isTrailingPosDefined(axis: YGFlexDirection): boolean;
    getTrailingPosition(axis: YGFlexDirection, axisSize: number): YGFloatOptional;
    getLeadingMargin(axis: YGFlexDirection, widthSize: number): YGFloatOptional;
    getTrailingMargin(axis: YGFlexDirection, widthSize: number): YGFloatOptional;
    getLeadingBorder(axis: YGFlexDirection): number;
    getTrailingBorder(axis: YGFlexDirection): number;
    getLeadingPadding(axis: YGFlexDirection, widthSize: number): YGFloatOptional;
    getTrailingPadding(axis: YGFlexDirection, widthSize: number): YGFloatOptional;
    getLeadingPaddingAndBorder(axis: YGFlexDirection, widthSize: number): YGFloatOptional;
    getTrailingPaddingAndBorder(axis: YGFlexDirection, widthSize: number): YGFloatOptional;
    getMarginForAxis(axis: YGFlexDirection, widthSize: number): YGFloatOptional;
    setContext(context: any): void;
    setPrintFunc(printFunc: YGPrintFunc): void;
    setHasNewLayout(hasNewLayout: boolean): void;
    setNodeType(nodeType: YGNodeType): void;
    /**
     * deviation: Upstream uses method overloading with a union for callbacks
     * with and without context functions. TypeScript doesn't support method
     * overloading in classes the same way C++ does, so the context function is
     * made an optional parameter of YGMeasureFunc.
     */
    setMeasureFunc(measureFunc: YGMeasureFunc): void;
    setBaseLineFunc(baseLineFunc: YGBaselineFunc): void;
    setDirtiedFunc(dirtiedFunc: YGDirtiedFunc): void;
    setStyle(style: YGStyle): void;
    setStyleFlexDirection(direction: YGFlexDirection): void;
    setStyleAlignContent(alignContent: YGAlign): void;
    setLayout(layout: YGLayout): void;
    setLineIndex(lineIndex: number): void;
    setIsReferenceBaseline(isReferenceBaseline: boolean): void;
    setOwner(owner: YGNode): void;
    setChildren(children: Array<YGNode>): void;
    setConfig(config: YGConfig): void;
    setDirty(isDirty: boolean): void;
    setLayoutLastOwnerDirection(direction: YGDirection): void;
    setLayoutComputedFlexBasis(computedFlexBasis: YGFloatOptional): void;
    setLayoutComputedFlexBasisGeneration(computedFlexBasisGeneration: number): void;
    setLayoutMeasuredDimension(measuredDimension: number, index: number): void;
    setLayoutHadOverflow(hadOverflow: boolean): void;
    setLayoutDimension(dimension: number, index: number): void;
    setLayoutDirection(direction: YGDirection): void;
    setLayoutMargin(margin: number, index: number): void;
    setLayoutBorder(border: number, index: number): void;
    setLayoutPadding(padding: number, index: number): void;
    setLayoutPosition(position: number, index: number): void;
    setPosition(direction: YGDirection, mainSize: number, crossSize: number, ownerWidth: number): void;
    setLayoutDoesLegacyFlagAffectsLayout(doesLegacyFlagAffectsLayout: boolean): void;
    setLayoutDidUseLegacyFlag(didUseLegacyFlag: boolean): void;
    markDirtyAndPropogateDownwards(): void;
    marginLeadingValue(axis: YGFlexDirection): YGValue;
    marginTrailingValue(axis: YGFlexDirection): YGValue;
    resolveFlexBasisPtr(): YGValue;
    resolveDimension(): void;
    resolveDirection(ownerDirection: YGDirection): YGDirection;
    clearChildren(): void;
    replaceChild(oldChild: YGNode, newChild: YGNode): void;
    replaceChildIndex(child: YGNode, index: number): void;
    insertChildIndex(child: YGNode, index: number): void;
    removeChild(child: YGNode): boolean;
    removeChildIndex(index: number): void;
    iterChildrenAfterCloningIfNeeded(callback: IterChildrenCallback, cloneContext: any): void;
    cloneChildrenIfNeeded(cloneContext?: any): void;
    markDirtyAndPropogate(): void;
    resolveFlexGrow(): number;
    resolveFlexShrink(): number;
    isNodeFlexible(): boolean;
    didUseLegacyFlag(): boolean;
    isLayoutTreeEqualToNode(node: YGNode): boolean;
    reset(): void;
}
export { YGNode };
