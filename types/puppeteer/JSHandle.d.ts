import { Evalable } from './able';
import { ExecutionContext } from './ExecutionContext';
import { Keys, ClickOptions } from './Input';
import { Frame } from './FrameManager';

/**
 * JSHandle represents an in-page JavaScript object.
 * Defines `asElement`, `dispose`, `executionContext`, `getProperties`, `getProperty`, `jsonValue`
 */
export interface JSHandle {
  /**
   * Returns a ElementHandle
   */
  asElement(): ElementHandle | null;
  /**
   * Stops referencing the element handle.
   */
  dispose(): Promise<void>;
  /**
   * Gets the execution context.
   */
  executionContext(): ExecutionContext;
  /**
   * Returns a map with property names as keys and JSHandle instances for the property values.
   */
  getProperties(): Promise<Map<string, JSHandle>>;
  /**
   * Fetches a single property from the objectHandle.
   * @param propertyName The property to get.
   */
  getProperty(propertyName: string): Promise<JSHandle>;

  /**
   * Returns a JSON representation of the object.
   * The JSON is generated by running JSON.stringify on the object in page and consequent JSON.parse in puppeteer.
   * @throws The method will throw if the referenced object is not stringifiable.
   */
  jsonValue(): Promise<any>;
}
/**
 * Represents an in-page DOM element. ElementHandles can be created with the `$`, `waitForSelector`, `waitForXPath`... methods.
 * implemented in JSHamdle.js
 */
export interface ElementHandle<E extends Element = Element> extends JSHandle, Evalable {
  /**
   * This method returns the value resolve to the bounding box of the element (relative to the main frame), or null if the element is not visible.
   */
  boundingBox(): Promise<BoundingBox | null>;
  /**
   * This method returns boxes of the element, or null if the element is not visible.
   * Boxes are represented as an array of points; each Point is an object {x, y}. Box points are sorted clock-wise.
   */
  boxModel(): Promise<BoxModel | null>;
  /**
   * This method scrolls element into view if needed, and then uses page.mouse to click in the center of the element.
   * If the element is detached from DOM, the method throws an error.
   * @param options Specifies the options.
   * @since 0.9.0
   */
  click(options?: ClickOptions): Promise<void>;
  /**
   * @returns Resolves to the content frame for element handles referencing iframe nodes, or null otherwise.
   * @since 1.2.0
   */
  contentFrame(): Promise<Frame | null>;
  /**
   * Calls focus on the element.
   */
  focus(): Promise<void>;
  /**
   * This method scrolls element into view if needed, and then uses page.mouse to hover over the center of the element.
   * If the element is detached from DOM, the method throws an error.
   */
  hover(): Promise<void>;
  /**
   * Resolves to true if the element is visible in the current viewport.
   */
  isIntersectingViewport(): Promise<boolean>;
  /**
   * Focuses the element, and then uses keyboard.down and keyboard.up.
   * @param key Name of key to press, such as ArrowLeft. See USKeyboardLayout for a list of all key names.
   * @param options The text and delay options.
   * @param options.text If specified, generates an input event with this text.
   * @param options.delay Time to wait between keydown and keyup in milliseconds. Defaults to 0.
   */
  press(key: Keys, options?: { text?: string, delay?: number }): Promise<void>;
  /**
   * This method scrolls element into view if needed, and then uses page.screenshot to take a screenshot of the element.
   * If the element is detached from DOM, the method throws an error.
   * @param options Same options as in page.screenshot.
   */
  screenshot(options?: Base64ScreenShotOptions): Promise<string>;
  screenshot(options?: BinaryScreenShotOptions): Promise<Buffer>;
  screenshot(options?: ScreenshotOptions): Promise<string | Buffer>;
  /**
   * This method scrolls element into view if needed, and then uses touchscreen.tap to tap in the center of the element.
   * If the element is detached from DOM, the method throws an error.
   */
  tap(): Promise<void>;
  toString(): string;
  /**
   * Focuses the element, and then sends a keydown, keypress/input, and keyup event for each character in the text.
   * @param text A text to type into a focused element.
   * @param options The typing options.
   * @param options.delay Time to wait between key presses in milliseconds. Defaults to 0.
   */
  type(text: string, options?: { delay: number }): Promise<void>;
  /**
   * This method expects elementHandle to point to an input element.
   * @param filePaths Sets the value of the file input these paths. If some of the filePaths are relative paths, then they are resolved relative to current working directory.
   */
  uploadFile(...filePaths: string[]): Promise<void>;
}

export interface BinaryScreenShotOptions extends ScreenshotOptions {
  encoding?: "binary";
}

export interface Base64ScreenShotOptions extends ScreenshotOptions {
  encoding: "base64";
}
/** Defines the screenshot options. */
export interface ScreenshotOptions {
  /**
   * The file path to save the image to. The screenshot type will be inferred from file extension.
   * If `path` is a relative path, then it is resolved relative to current working directory.
   * If no path is provided, the image won't be saved to the disk.
   */
  path?: string;
  /**
   * The screenshot type.
   * @default png
   */
  type?: "jpeg" | "png";
  /** The quality of the image, between 0-100. Not applicable to png images. */
  quality?: number;
  /**
   * When true, takes a screenshot of the full scrollable page.
   * @default false
   */
  fullPage?: boolean;
  /**
   * An object which specifies clipping region of the page.
   */
  clip?: BoundingBox;
  /**
   * Hides default white background and allows capturing screenshots with transparency.
   * @default false
   */
  omitBackground?: boolean;
  /**
   * The encoding of the image, can be either base64 or binary.
   * @default binary
   */
  encoding?: "base64" | "binary";
}

export interface BoxModel {
  /** Content box, represented as an array of {x, y} points. */
  content: Box[];
  /** Padding box, represented as an array of {x, y} points. */
  padding: Box[];
  /** Border box, represented as an array of {x, y} points. */
  border: Box[];
  /** Margin box, represented as an array of {x, y} points. */
  margin: Box[];
  width: number;
  height: number;
}

export interface Box {
  x: number;
  y: number;
}

export interface BoundingBox {
  /** The x-coordinate of top-left corner. */
  x: number;
  /** The y-coordinate of top-left corner. */
  y: number;
  /** The width. */
  width: number;
  /** The height. */
  height: number;
}
