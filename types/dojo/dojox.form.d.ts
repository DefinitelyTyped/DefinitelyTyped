// Type definitions for Dojo v1.9
// Project: http://dojotoolkit.org
// Definitions by: Michael Van Sickle <https://github.com/vansimke>
// Definitions: https://github.com/DefinitelyTyped/DefinitelyTyped


declare namespace dojox {

    namespace form {
        /**
         * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/_FormSelectWidget.html
         *
         * Extends _FormValueWidget in order to provide "select-specific"
         * values - i.e., those values that are unique to <select> elements.
         * This also provides the mechanism for reading the elements from
         * a store, if desired.
         *
         * @param params Hash of initialization parameters for widget, including scalar values (like title, duration etc.)and functions, typically callbacks like onClick.The hash can contain any of the widget's properties, excluding read-only properties.
         * @param srcNodeRef       OptionalIf a srcNodeRef (DOM node) is specified, replace srcNodeRef with my generated DOM tree
         */
        class _FormSelectWidget extends dijit.form._FormValueWidget {
            constructor(params?: Object, srcNodeRef?: HTMLElement);
            /**
             * True if mouse was pressed while over this widget, and hasn't been released yet
             *
             */
            "active": boolean;
            set(property:"active", value: boolean): void;
            get(property:"active"): boolean;
            watch(property:"active", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "alt": string;
            set(property:"alt", value: string): void;
            get(property:"alt"): string;
            watch(property:"alt", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "aria-label": string;
            set(property:"aria-label", value: string): void;
            get(property:"aria-label"): string;
            watch(property:"aria-label", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Object to which attach points and events will be scoped.  Defaults
             * to 'this'.
             *
             */
            "attachScope": Object;
            set(property:"attachScope", value: Object): void;
            get(property:"attachScope"): Object;
            watch(property:"attachScope", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute
             * for each XXX attribute to be mapped to the DOM.
             *
             * attributeMap sets up a "binding" between attributes (aka properties)
             * of the widget and the widget's DOM.
             * Changes to widget attributes listed in attributeMap will be
             * reflected into the DOM.
             *
             * For example, calling set('title', 'hello')
             * on a TitlePane will automatically cause the TitlePane's DOM to update
             * with the new title.
             *
             * attributeMap is a hash where the key is an attribute of the widget,
             * and the value reflects a binding to a:
             *
             * DOM node attribute
             *   focus: {node: "focusNode", type: "attribute"}
             * Maps this.focus to this.focusNode.focus
             *
             * DOM node innerHTML
             *   title: { node: "titleNode", type: "innerHTML" }
             * Maps this.title to this.titleNode.innerHTML
             *
             * DOM node innerText
             *   title: { node: "titleNode", type: "innerText" }
             * Maps this.title to this.titleNode.innerText
             *
             * DOM node CSS class
             *   myClass: { node: "domNode", type: "class" }
             * Maps this.myClass to this.domNode.className
             *
             * If the value is an array, then each element in the array matches one of the
             * formats of the above list.
             *
             * There are also some shorthands for backwards compatibility:
             *
             * string --> { node: string, type: "attribute" }, for example:
             * "focusNode" ---> { node: "focusNode", type: "attribute" }
             * "" --> { node: "domNode", type: "attribute" }
             *
             */
            "attributeMap": Object;
            set(property:"attributeMap", value: Object): void;
            get(property:"attributeMap"): Object;
            watch(property:"attributeMap", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate
             * widget state.
             *
             */
            "baseClass": string;
            set(property:"baseClass", value: string): void;
            get(property:"baseClass"): string;
            watch(property:"baseClass", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "class": string;
            set(property:"class", value: string): void;
            get(property:"class"): string;
            watch(property:"class", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Designates where children of the source DOM node will be placed.
             * "Children" in this case refers to both DOM nodes and widgets.
             * For example, for myWidget:
             *
             * <div data-dojo-type=myWidget>
             *     <b> here's a plain DOM node
             *     <span data-dojo-type=subWidget>and a widget</span>
             *     <i> and another plain DOM node </i>
             * </div>
             * containerNode would point to:
             *
             * <b> here's a plain DOM node
             * <span data-dojo-type=subWidget>and a widget</span>
             * <i> and another plain DOM node </i>
             * In templated widgets, "containerNode" is set via a
             * data-dojo-attach-point assignment.
             *
             * containerNode must be defined for any widget that accepts innerHTML
             * (like ContentPane or BorderContainer or even Button), and conversely
             * is null for widgets that don't, like TextBox.
             *
             */
            "containerNode": HTMLElement;
            set(property:"containerNode", value: HTMLElement): void;
            get(property:"containerNode"): HTMLElement;
            watch(property:"containerNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * Subclasses may define a cssStateNodes property that lists sub-nodes within the widget that
             * need CSS classes applied on mouse hover/press and focus.
             *
             * Each entry in this optional hash is a an attach-point name (like "upArrowButton") mapped to a CSS class name
             * (like "dijitUpArrowButton"). Example:
             *
             * {
             *     "upArrowButton": "dijitUpArrowButton",
             *     "downArrowButton": "dijitDownArrowButton"
             * }
             * The above will set the CSS class dijitUpArrowButton to the this.upArrowButton DOMNode when it
             *
             * is hovered, etc.
             *
             */
            "cssStateNodes": Object;
            set(property:"cssStateNodes", value: Object): void;
            get(property:"cssStateNodes"): Object;
            watch(property:"cssStateNodes", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Bi-directional support, as defined by the HTML DIR
             * attribute. Either left-to-right "ltr" or right-to-left "rtl".  If undefined, widgets renders in page's
             * default direction.
             *
             */
            "dir": string;
            set(property:"dir", value: string): void;
            get(property:"dir"): string;
            watch(property:"dir", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Should this widget respond to user input?
             * In markup, this is specified as "disabled='disabled'", or just "disabled".
             *
             */
            "disabled": boolean;
            set(property:"disabled", value: boolean): void;
            get(property:"disabled"): boolean;
            watch(property:"disabled", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * This is our visible representation of the widget! Other DOM
             * Nodes may by assigned to other properties, usually through the
             * template system's data-dojo-attach-point syntax, but the domNode
             * property is the canonical "top level" node in widget UI.
             *
             */
            "domNode": HTMLElement;
            set(property:"domNode", value: HTMLElement): void;
            get(property:"domNode"): HTMLElement;
            watch(property:"domNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * This widget or a widget it contains has focus, or is "active" because
             * it was recently clicked.
             *
             */
            "focused": boolean;
            set(property:"focused", value: boolean): void;
            get(property:"focused"): boolean;
            watch(property:"focused", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * True if cursor is over this widget
             *
             */
            "hovering": boolean;
            set(property:"hovering", value: boolean): void;
            get(property:"hovering"): boolean;
            watch(property:"hovering", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * A unique, opaque ID string that can be assigned by users or by the
             * system. If the developer passes an ID which is known not to be
             * unique, the specified ID is ignored and the system-generated ID is
             * used instead.
             *
             */
            "id": string;
            set(property:"id", value: string): void;
            get(property:"id"): string;
            watch(property:"id", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Fires onChange for each value change or only on demand
             *
             */
            "intermediateChanges": boolean;
            set(property:"intermediateChanges", value: boolean): void;
            get(property:"intermediateChanges"): boolean;
            watch(property:"intermediateChanges", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * The entries in the drop down list come from this attribute in the dojo.store items.
             * If store is set, labelAttr must be set too, unless store is an old-style
             * dojo.data store rather than a new dojo/store.
             *
             */
            "labelAttr": Object;
            set(property:"labelAttr", value: Object): void;
            get(property:"labelAttr"): Object;
            watch(property:"labelAttr", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Rarely used.  Overrides the default Dojo locale used to render this widget,
             * as defined by the HTML LANG attribute.
             * Value must be among the list of locales specified during by the Dojo bootstrap,
             * formatted according to RFC 3066 (like en-us).
             *
             */
            "lang": string;
            set(property:"lang", value: string): void;
            get(property:"lang"): string;
            watch(property:"lang", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * By default loadChildren is called when the items are fetched from the
             * store.  This property allows delaying loadChildren (and the creation
             * of the options/menuitems) until the user clicks the button to open the
             * dropdown.
             *
             */
            "loadChildrenOnOpen": boolean;
            set(property:"loadChildrenOnOpen", value: boolean): void;
            get(property:"loadChildrenOnOpen"): boolean;
            watch(property:"loadChildrenOnOpen", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Whether or not we are multi-valued
             *
             */
            "multiple": boolean;
            set(property:"multiple", value: boolean): void;
            get(property:"multiple"): boolean;
            watch(property:"multiple", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Name used when submitting form; same as "name" attribute or plain HTML elements
             *
             */
            "name": string;
            set(property:"name", value: string): void;
            get(property:"name"): string;
            watch(property:"name", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * A callback to do with an onFetch - but before any items are actually
             * iterated over (i.e. to filter even further what you want to add)
             *
             */
            "onFetch": Function;
            set(property:"onFetch", value: Function): void;
            get(property:"onFetch"): Function;
            watch(property:"onFetch", callback:{(property?:string, oldValue?:Function, newValue?: Function):void}) :{unwatch():void}
            /**
             * This is the dojo.Deferred returned by setStore().
             * Calling onLoadDeferred.then() registers your
             * callback to be called only once, when the prior setStore completes.
             *
             */
            "onLoadDeferred": Object;
            set(property:"onLoadDeferred", value: Object): void;
            get(property:"onLoadDeferred"): Object;
            watch(property:"onLoadDeferred", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * The set of options for our select item.  Roughly corresponds to
             * the html <option> tag.
             *
             */
            "options": Object;
            set(property:"options", value: Object): void;
            get(property:"options"): Object;
            watch(property:"options", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * The document this widget belongs to.  If not specified to constructor, will default to
             * srcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global
             *
             */
            "ownerDocument": Object;
            set(property:"ownerDocument", value: Object): void;
            get(property:"ownerDocument"): Object;
            watch(property:"ownerDocument", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * A query to use when fetching items from our store
             *
             */
            "query": Object;
            set(property:"query", value: Object): void;
            get(property:"query"): Object;
            watch(property:"query", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Query options to use when fetching from the store
             *
             */
            "queryOptions": Object;
            set(property:"queryOptions", value: Object): void;
            get(property:"queryOptions"): Object;
            watch(property:"queryOptions", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Should this widget respond to user input?
             * In markup, this is specified as "readOnly".
             * Similar to disabled except readOnly form values are submitted.
             *
             */
            "readOnly": boolean;
            set(property:"readOnly", value: boolean): void;
            get(property:"readOnly"): boolean;
            watch(property:"readOnly", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * On focus, should this widget scroll into view?
             *
             */
            "scrollOnFocus": boolean;
            set(property:"scrollOnFocus", value: boolean): void;
            get(property:"scrollOnFocus"): boolean;
            watch(property:"scrollOnFocus", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             *
             */
            "searchContainerNode": boolean;
            set(property:"searchContainerNode", value: boolean): void;
            get(property:"searchContainerNode"): boolean;
            watch(property:"searchContainerNode", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Flag to sort the options returned from a store by the label of
             * the store.
             *
             */
            "sortByLabel": boolean;
            set(property:"sortByLabel", value: boolean): void;
            get(property:"sortByLabel"): boolean;
            watch(property:"sortByLabel", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * pointer to original DOM node
             *
             */
            "srcNodeRef": HTMLElement;
            set(property:"srcNodeRef", value: HTMLElement): void;
            get(property:"srcNodeRef"): HTMLElement;
            watch(property:"srcNodeRef", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * A store to use for getting our list of options - rather than reading them
             * from the <option> html tags.   Should support getIdentity().
             * For back-compat store can also be a dojo/data/api/Identity.
             *
             */
            "store": Object;
            set(property:"store", value: Object): void;
            get(property:"store"): Object;
            watch(property:"store", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * HTML style attributes as cssText string or name/value hash
             *
             */
            "style": string;
            set(property:"style", value: string): void;
            get(property:"style"): string;
            watch(property:"style", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Order fields are traversed when user hits the tab key
             *
             */
            "tabIndex": string;
            set(property:"tabIndex", value: string): void;
            get(property:"tabIndex"): string;
            watch(property:"tabIndex", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Path to template (HTML file) for this widget relative to dojo.baseUrl.
             * Deprecated: use templateString with require([... "dojo/text!..."], ...) instead
             *
             */
            "templatePath": string;
            set(property:"templatePath", value: string): void;
            get(property:"templatePath"): string;
            watch(property:"templatePath", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * A string that represents the widget template.
             * Use in conjunction with dojo.cache() to load from a file.
             *
             */
            "templateString": string;
            set(property:"templateString", value: string): void;
            get(property:"templateString"): string;
            watch(property:"templateString", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * HTML title attribute.
             *
             * For form widgets this specifies a tooltip to display when hovering over
             * the widget (just like the native HTML title attribute).
             *
             * For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,
             * etc., it's used to specify the tab label, accordion pane title, etc.  In this case it's
             * interpreted as HTML.
             *
             */
            "title": string;
            set(property:"title", value: string): void;
            get(property:"title"): string;
            watch(property:"title", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * When this widget's title attribute is used to for a tab label, accordion pane title, etc.,
             * this specifies the tooltip to appear when the mouse is hovered over that text.
             *
             */
            "tooltip": string;
            set(property:"tooltip", value: string): void;
            get(property:"tooltip"): string;
            watch(property:"tooltip", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "type": string;
            set(property:"type", value: string): void;
            get(property:"type"): string;
            watch(property:"type", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "value": string;
            set(property:"value", value: string): void;
            get(property:"value"): string;
            watch(property:"value", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Adds an option or options to the end of the select.  If value
             * of the option is empty or missing, a separator is created instead.
             * Passing in an array of options will yield slightly better performance
             * since the children are only loaded once.
             *
             * @param option
             */
            addOption(option: dijit.form._FormSelectWidget.__SelectOption): void;
            /**
             * Adds an option or options to the end of the select.  If value
             * of the option is empty or missing, a separator is created instead.
             * Passing in an array of options will yield slightly better performance
             * since the children are only loaded once.
             *
             * @param option
             */
            addOption(option: dijit.form._FormSelectWidget.__SelectOption[]): void;
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: String, value: Object): any;
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: Object, value: Object): any;
            /**
             *
             */
            buildRendering(): void;
            /**
             * Compare 2 values (as returned by get('value') for this widget).
             *
             * @param val1
             * @param val2
             */
            compare(val1: any, val2: any): number;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: Function): any;
            /**
             * Wrapper to setTimeout to avoid deferred functions executing
             * after the originating widget has been destroyed.
             * Returns an object handle with a remove method (that returns null) (replaces clearTimeout).
             *
             * @param fcn Function reference.
             * @param delay               OptionalDelay, defaults to 0.
             */
            defer(fcn: Function, delay: number): Object;
            /**
             * Clean up our connections
             *
             */
            destroy(): void;
            /**
             * Recursively destroy the children of this widget and their
             * descendants.
             *
             * @param preserveDom               OptionalIf true, the preserveDom attribute is passed to all descendantwidget's .destroy() method. Not for use with _Templatedwidgets.
             */
            destroyDescendants(preserveDom: boolean): void;
            /**
             * Destroy this widget and its descendants
             * This is the generic "destructor" function that all widget users
             * should call to cleanly discard with a widget. Once a widget is
             * destroyed, it is removed from the manager object.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structurealone of descendant Widgets. Note: This will NOT work withdijit._TemplatedMixin widgets.
             */
            destroyRecursive(preserveDom: boolean): void;
            /**
             * Destroys the DOM nodes associated with this widget.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structure aloneduring tear-down. Note: this will not work with _Templatedwidgets yet.
             */
            destroyRendering(preserveDom?: boolean): void;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Disconnects handle created by connect.
             *
             * @param handle
             */
            disconnect(handle: any): void;
            /**
             * Used by widgets to signal that a synthetic event occurred, ex:
             *
             * myWidget.emit("attrmodified-selectedChildWidget", {}).
             * Emits an event on this.domNode named type.toLowerCase(), based on eventObj.
             * Also calls onType() method, if present, and returns value from that method.
             * By default passes eventObj to callback, but will pass callbackArgs instead, if specified.
             * Modifies eventObj by adding missing parameters (bubbles, cancelable, widget).
             *
             * @param type
             * @param eventObj               Optional
             * @param callbackArgs               Optional
             */
            emit(type: String, eventObj: Object, callbackArgs: any[]): any;
            /**
             * Put focus on this widget
             *
             */
            focus(): void;
            /**
             * Get a property from a widget.
             * Get a named property from a widget. The property may
             * potentially be retrieved via a getter method. If no getter is defined, this
             * just retrieves the object's property.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _getFooAttr(), calling:
             * myWidget.get("foo") would be equivalent to calling
             * widget._getFooAttr() and myWidget.get("bar")
             * would be equivalent to the expression
             * widget.bar2
             *
             * @param name The property to get.
             */
            get(name: any): any;
            /**
             * Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent
             * is this widget.   Note that it does not return all descendants, but rather just direct children.
             * Analogous to Node.childNodes,
             * except containing widgets rather than DOMNodes.
             *
             * The result intentionally excludes internally created widgets (a.k.a. supporting widgets)
             * outside of this.containerNode.
             *
             * Note that the array returned is a simple array.  Application code should not assume
             * existence of methods like forEach().
             *
             */
            getChildren(): any[];
            /**
             * Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
             * This method should generally be avoided as it returns widgets declared in templates, which are
             * supposed to be internal/hidden, but it's left here for back-compat reasons.
             *
             */
            getDescendants(): any[];
            /**
             * Returns a given option (or options).
             *
             * @param valueOrIdx If passed in as a string, that string is used to look up the optionin the array of options - based on the value property.(See dijit/form/_FormSelectWidget.__SelectOption).If passed in a number, then the option with the given index (0-based)within this select will be returned.If passed in a dijit/form/_FormSelectWidget.__SelectOption, the same option will bereturned if and only if it exists within this select.If passed an array, then an array will be returned with each elementin the array being looked up.If not passed a value, then all options will be returned
             */
            getOptions(valueOrIdx: any): any;
            /**
             * Returns the parent widget of this widget.
             *
             */
            getParent(): any;
            /**
             * Deprecated.  Use get('value') instead.
             *
             */
            getValue(): any;
            /**
             * Return true if this widget can currently be focused
             * and false if not
             *
             */
            isFocusable(): any;
            /**
             * Return this widget's explicit or implicit orientation (true for LTR, false for RTL)
             *
             */
            isLeftToRight(): any;
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: String, func: Function): any;
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: Function, func: Function): any;
            /**
             * Track specified handles and remove/destroy them when this instance is destroyed, unless they were
             * already removed/destroyed manually.
             *
             */
            own(): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: number): any;
            /**
             * sets up our event handling that we need for functioning
             * as a select
             *
             */
            postCreate(): void;
            /**
             *
             */
            postMixInProperties(): void;
            /**
             * Removes the given option or options.  You can remove by string
             * (in which case the value is removed), number (in which case the
             * index in the options array is removed), or select option (in
             * which case, the select option with a matching value is removed).
             * You can also pass in an array of those values for a slightly
             * better performance since the children are only loaded once.
             * For numeric option values, specify {value: number} as the argument.
             *
             * @param valueOrIdx
             */
            removeOption(valueOrIdx: String): void;
            /**
             * Removes the given option or options.  You can remove by string
             * (in which case the value is removed), number (in which case the
             * index in the options array is removed), or select option (in
             * which case, the select option with a matching value is removed).
             * You can also pass in an array of those values for a slightly
             * better performance since the children are only loaded once.
             * For numeric option values, specify {value: number} as the argument.
             *
             * @param valueOrIdx
             */
            removeOption(valueOrIdx: dijit.form._FormSelectWidget.__SelectOption): void;
            /**
             * Removes the given option or options.  You can remove by string
             * (in which case the value is removed), number (in which case the
             * index in the options array is removed), or select option (in
             * which case, the select option with a matching value is removed).
             * You can also pass in an array of those values for a slightly
             * better performance since the children are only loaded once.
             * For numeric option values, specify {value: number} as the argument.
             *
             * @param valueOrIdx
             */
            removeOption(valueOrIdx: number): void;
            /**
             * Removes the given option or options.  You can remove by string
             * (in which case the value is removed), number (in which case the
             * index in the options array is removed), or select option (in
             * which case, the select option with a matching value is removed).
             * You can also pass in an array of those values for a slightly
             * better performance since the children are only loaded once.
             * For numeric option values, specify {value: number} as the argument.
             *
             * @param valueOrIdx
             */
            removeOption(valueOrIdx: any[]): void;
            /**
             * Reset the widget's value to what it was at initialization time
             *
             */
            reset(): void;
            /**
             * Set a property on a widget
             * Sets named properties on a widget which may potentially be handled by a
             * setter in the widget.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _setFooAttr(), calling
             * myWidget.set("foo", "Howdy!") would be equivalent to calling
             * widget._setFooAttr("Howdy!") and myWidget.set("bar", 3)
             * would be equivalent to the statement widget.bar = 3;
             *
             * set() may also be called with a hash of name/value pairs, ex:
             *
             * myWidget.set({
             *     foo: "Howdy",
             *     bar: 3
             * });
             * This is equivalent to calling set(foo, "Howdy") and set(bar, 3)
             *
             * @param name The property to set.
             * @param value The value to set in the property.
             */
            set(name: any, value: any): any;
            /**
             * Deprecated.  Use set() instead.
             *
             * @param attr
             * @param value
             */
            setAttribute(attr: String, value: any): void;
            /**
             * Deprecated.  Use set('disabled', ...) instead.
             *
             * @param disabled
             */
            setDisabled(disabled: boolean): void;
            /**
             * Sets the store you would like to use with this select widget.
             * The selected value is the value of the new store to set.  This
             * function returns the original store, in case you want to reuse
             * it or something.
             *
             * @param store The dojo.store you would like to use - it MUST implement getIdentity()and MAY implement observe().For backwards-compatibility this can also be a data.data store, in which caseit MUST implement dojo/data/api/Identity,and MAY implement dojo/data/api/Notification.
             * @param selectedValue               OptionalThe value that this widget should set itself to after the storehas been loaded
             * @param fetchArgs               OptionalHash of parameters to set filter on store, etc.query: new value for Select.query,queryOptions: new value for Select.queryOptions,onFetch: callback function for each item in data (Deprecated)
             */
            setStore(store: dojo.store.api.Store, selectedValue: any, fetchArgs: Object): any;
            /**
             * Deprecated.  Use set('value', ...) instead.
             *
             * @param value
             */
            setValue(value: String): void;
            /**
             *
             */
            startup(): void;
            /**
             * Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.
             *
             * Subscribes to the specified topic and calls the specified method
             * of this object and registers for unsubscribe() on widget destroy.
             *
             * Provide widget-specific analog to dojo.subscribe, except with the
             * implicit use of this widget as the target object.
             *
             * @param t The topic
             * @param method The callback
             */
            subscribe(t: String, method: Function): any;
            /**
             * Returns a string that represents the widget.
             * When a widget is cast to a string, this method will be used to generate the
             * output. Currently, it does not implement any sort of reversible
             * serialization.
             *
             */
            toString(): string;
            /**
             * Restore the value to the last value passed to onChange
             *
             */
            undo(): void;
            /**
             * Deprecated. Override destroy() instead to implement custom widget tear-down
             * behavior.
             *
             */
            uninitialize(): boolean;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Unsubscribes handle created by this.subscribe.
             * Also removes handle from this widget's list of subscriptions
             *
             * @param handle
             */
            unsubscribe(handle: Object): void;
            /**
             * Updates the values of the given option.  The option to update
             * is matched based on the value of the entered option.  Passing
             * in an array of new options will yield better performance since
             * the children will only be loaded once.
             *
             * @param newOption
             */
            updateOption(newOption: dijit.form._FormSelectWidget.__SelectOption): void;
            /**
             * Updates the values of the given option.  The option to update
             * is matched based on the value of the entered option.  Passing
             * in an array of new options will yield better performance since
             * the children will only be loaded once.
             *
             * @param newOption
             */
            updateOption(newOption: dijit.form._FormSelectWidget.__SelectOption[]): void;
            /**
             * Watches a property for changes
             *
             * @param name               OptionalIndicates the property to watch. This is optional (the callback may be theonly parameter), and if omitted, all the properties will be watched
             * @param callback The function to execute when the property changes. This will be called afterthe property has been changed. The callback will be called with the |this|set to the instance, the first argument as the name of the property, thesecond argument as the old value and the third argument as the new value.
             */
            watch(property: string, callback:{(property?:string, oldValue?:any, newValue?: any):void}) :{unwatch():void};
            /**
             * Static method to get a template based on the templatePath or
             * templateString key
             */
            getCachedTemplate(): any;
            /**
             * Called when the widget stops being "active" because
             * focus moved to something outside of it, or the user
             * clicked somewhere outside of it, or the widget was
             * hidden.
             *
             */
            onBlur(): void;
            /**
             * Callback when this widget's value is changed.
             *
             * @param newValue
             */
            onChange(newValue: any): void;
            /**
             * Connect to this function to receive notifications of mouse click events.
             *
             * @param event mouse Event
             */
            onClick(event: any): void;
            /**
             * Called when this widget is being displayed as a popup (ex: a Calendar popped
             * up from a DateTextBox), and it is hidden.
             * This is called from the dijit.popup code, and should not be called directly.
             *
             * Also used as a parameter for children of dijit/layout/StackContainer or subclasses.
             * Callback if a user tries to close the child.   Child will be closed if this function returns true.
             *
             */
            onClose(): boolean;
            /**
             * Connect to this function to receive notifications of mouse double click events.
             *
             * @param event mouse Event
             */
            onDblClick(event: any): void;
            /**
             * Called when the widget becomes "active" because
             * it or a widget inside of it either has focus, or has recently
             * been clicked.
             *
             */
            onFocus(): void;
            /**
             * Called when another widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate hide of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onHide(): void;
            /**
             * Connect to this function to receive notifications of keys being pressed down.
             *
             * @param event key Event
             */
            onKeyDown(event: any): void;
            /**
             * Connect to this function to receive notifications of printable keys being typed.
             *
             * @param event key Event
             */
            onKeyPress(event: any): void;
            /**
             * Connect to this function to receive notifications of keys being released.
             *
             * @param event key Event
             */
            onKeyUp(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is pressed down.
             *
             * @param event mouse Event
             */
            onMouseDown(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto this widget.
             *
             * @param event mouse Event
             */
            onMouseEnter(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of this widget.
             *
             * @param event mouse Event
             */
            onMouseLeave(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseMove(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOut(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOver(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is released.
             *
             * @param event mouse Event
             */
            onMouseUp(event: any): void;
            /**
             * a function that can be connected to in order to receive a
             * notification that the store has finished loading and all options
             * from that store are available
             *
             */
            onSetStore(): void;
            /**
             * Called when this widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate display of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onShow(): void;
        }
        module _FormSelectWidget {
            /**
             * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/_FormSelectWidget.__SelectOption.html
             *
             *
             */
            interface __SelectOption {
                /**
                 * Whether or not this specific option is disabled
                 *
                 */
                disabled: boolean;
                /**
                 * The label for our option.  It can contain html tags.
                 *
                 */
                label: string;
                /**
                 * Whether or not we are a selected option
                 *
                 */
                selected: boolean;
                /**
                 * The value of the option.  Setting to empty (or missing) will
                 * place a separator at that location
                 *
                 */
                value: string;
            }
        }

        /**
         * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/_SelectStackMixin.html
         *
         * Mix this class in to a dijit.form._FormSelectWidget in order to
         * provide support for "selectable" multiforms.  The widget is pointed
         * to a dijit.layout.StackContainer and will handle displaying and
         * submitting the values of only the appropriate pane.
         *
         * The options for this widget will be automatically set - based on
         * the panes that are in the stack container.  The "title" attribute of
         * the pane will be used for the display of the option.  The "id" attribute
         * of the pane will be used as the value of the option.  In order to
         * avoid running into unique ID constraint issues, a stackPrefix mechanism
         * is provided.
         *
         */
        class _SelectStackMixin {
            constructor();
            /**
             * The id of the stack that this widget is supposed to control
             *
             */
            "stackId": string;
            /**
             * A prefix to remove from our stack pane ids when setting our options.
             * This exists so that we won't run into unique ID constraints.  For
             * example, if stackPrefix is set to "foo_", and there are three panes
             * in our stack with ids of "foo_a", "foo_b", and "foo_c", then the values
             * of the options created for the stack controller widget will be "a",
             * "b", and "c".  This allows you to have multiple select stack widgets
             * with the same values - without having to have the panes require the
             * same ids.
             *
             */
            "stackPrefix": string;
            /**
             *
             * @param name
             * @param value               Optional
             */
            attr(name: String, value: Object): any;
            /**
             *
             * @param name
             * @param value               Optional
             */
            attr(name: Object, value: Object): any;
            /**
             *
             */
            destroy(): void;
            /**
             *
             */
            postCreate(): void;
            /**
             *
             */
            postMixInProperties(): void;
            /**
             * Called when the stack container adds a new pane
             *
             * @param pane
             * @param insertIndex               Optional
             */
            onAddChild(pane: dijit._Widget, insertIndex: number): void;
            /**
             * Called when the stack container removes a pane
             *
             * @param pane
             */
            onRemoveChild(pane: dijit._Widget): void;
            /**
             * Called when the stack container selects a new pane
             *
             * @param pane
             */
            onSelectChild(pane: dijit._Widget): void;
            /**
             * Called when the stack container is started up
             *
             * @param info
             */
            onStartup(info: Object): void;
        }
        /**
         * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/BusyButton.html
         *
         * BusyButton is a simple widget which provides implementing more
         * user friendly form submission.
         * When a form gets submitted by a user, many times it is recommended to disable
         * the submit buttons to prevent double submission. BusyButton provides a simple set
         * of features for this purpose
         *
         * @param params Hash of initialization parameters for widget, including scalar values (like title, duration etc.)and functions, typically callbacks like onClick.The hash can contain any of the widget's properties, excluding read-only properties.
         * @param srcNodeRef       OptionalIf a srcNodeRef (DOM node) is specified:use srcNodeRef.innerHTML as my contentsif this is a behavioral widget then apply behavior to that srcNodeRefotherwise, replace srcNodeRef with my generated DOM tree
         */
        class BusyButton extends dijit.form.Button {
            constructor(params?: Object, srcNodeRef?: HTMLElement);
            /**
             * True if mouse was pressed while over this widget, and hasn't been released yet
             *
             */
            "active": boolean;
            set(property:"active", value: boolean): void;
            get(property:"active"): boolean;
            watch(property:"active", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "alt": string;
            set(property:"alt", value: string): void;
            get(property:"alt"): string;
            watch(property:"alt", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "aria-label": string;
            set(property:"aria-label", value: string): void;
            get(property:"aria-label"): string;
            watch(property:"aria-label", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Object to which attach points and events will be scoped.  Defaults
             * to 'this'.
             *
             */
            "attachScope": Object;
            set(property:"attachScope", value: Object): void;
            get(property:"attachScope"): Object;
            watch(property:"attachScope", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute
             * for each XXX attribute to be mapped to the DOM.
             *
             * attributeMap sets up a "binding" between attributes (aka properties)
             * of the widget and the widget's DOM.
             * Changes to widget attributes listed in attributeMap will be
             * reflected into the DOM.
             *
             * For example, calling set('title', 'hello')
             * on a TitlePane will automatically cause the TitlePane's DOM to update
             * with the new title.
             *
             * attributeMap is a hash where the key is an attribute of the widget,
             * and the value reflects a binding to a:
             *
             * DOM node attribute
             *   focus: {node: "focusNode", type: "attribute"}
             * Maps this.focus to this.focusNode.focus
             *
             * DOM node innerHTML
             *   title: { node: "titleNode", type: "innerHTML" }
             * Maps this.title to this.titleNode.innerHTML
             *
             * DOM node innerText
             *   title: { node: "titleNode", type: "innerText" }
             * Maps this.title to this.titleNode.innerText
             *
             * DOM node CSS class
             *   myClass: { node: "domNode", type: "class" }
             * Maps this.myClass to this.domNode.className
             *
             * If the value is an array, then each element in the array matches one of the
             * formats of the above list.
             *
             * There are also some shorthands for backwards compatibility:
             *
             * string --> { node: string, type: "attribute" }, for example:
             * "focusNode" ---> { node: "focusNode", type: "attribute" }
             * "" --> { node: "domNode", type: "attribute" }
             *
             */
            "attributeMap": Object;
            set(property:"attributeMap", value: Object): void;
            get(property:"attributeMap"): Object;
            watch(property:"attributeMap", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             *
             */
            "baseClass": string;
            set(property:"baseClass", value: string): void;
            get(property:"baseClass"): string;
            watch(property:"baseClass", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * text while button is busy
             *
             */
            "busyLabel": string;
            set(property:"busyLabel", value: string): void;
            get(property:"busyLabel"): string;
            watch(property:"busyLabel", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "class": string;
            set(property:"class", value: string): void;
            get(property:"class"): string;
            watch(property:"class", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Designates where children of the source DOM node will be placed.
             * "Children" in this case refers to both DOM nodes and widgets.
             * For example, for myWidget:
             *
             * <div data-dojo-type=myWidget>
             *     <b> here's a plain DOM node
             *     <span data-dojo-type=subWidget>and a widget</span>
             *     <i> and another plain DOM node </i>
             * </div>
             * containerNode would point to:
             *
             * <b> here's a plain DOM node
             * <span data-dojo-type=subWidget>and a widget</span>
             * <i> and another plain DOM node </i>
             * In templated widgets, "containerNode" is set via a
             * data-dojo-attach-point assignment.
             *
             * containerNode must be defined for any widget that accepts innerHTML
             * (like ContentPane or BorderContainer or even Button), and conversely
             * is null for widgets that don't, like TextBox.
             *
             */
            "containerNode": HTMLElement;
            set(property:"containerNode", value: HTMLElement): void;
            get(property:"containerNode"): HTMLElement;
            watch(property:"containerNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * Subclasses may define a cssStateNodes property that lists sub-nodes within the widget that
             * need CSS classes applied on mouse hover/press and focus.
             *
             * Each entry in this optional hash is a an attach-point name (like "upArrowButton") mapped to a CSS class name
             * (like "dijitUpArrowButton"). Example:
             *
             * {
             *     "upArrowButton": "dijitUpArrowButton",
             *     "downArrowButton": "dijitDownArrowButton"
             * }
             * The above will set the CSS class dijitUpArrowButton to the this.upArrowButton DOMNode when it
             *
             * is hovered, etc.
             *
             */
            "cssStateNodes": Object;
            set(property:"cssStateNodes", value: Object): void;
            get(property:"cssStateNodes"): Object;
            watch(property:"cssStateNodes", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Bi-directional support, as defined by the HTML DIR
             * attribute. Either left-to-right "ltr" or right-to-left "rtl".  If undefined, widgets renders in page's
             * default direction.
             *
             */
            "dir": string;
            set(property:"dir", value: string): void;
            get(property:"dir"): string;
            watch(property:"dir", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Should this widget respond to user input?
             * In markup, this is specified as "disabled='disabled'", or just "disabled".
             *
             */
            "disabled": boolean;
            set(property:"disabled", value: boolean): void;
            get(property:"disabled"): boolean;
            watch(property:"disabled", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * This is our visible representation of the widget! Other DOM
             * Nodes may by assigned to other properties, usually through the
             * template system's data-dojo-attach-point syntax, but the domNode
             * property is the canonical "top level" node in widget UI.
             *
             */
            "domNode": HTMLElement;
            set(property:"domNode", value: HTMLElement): void;
            get(property:"domNode"): HTMLElement;
            watch(property:"domNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * This widget or a widget it contains has focus, or is "active" because
             * it was recently clicked.
             *
             */
            "focused": boolean;
            set(property:"focused", value: boolean): void;
            get(property:"focused"): boolean;
            watch(property:"focused", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * True if cursor is over this widget
             *
             */
            "hovering": boolean;
            set(property:"hovering", value: boolean): void;
            get(property:"hovering"): boolean;
            watch(property:"hovering", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Class to apply to DOMNode in button to make it display an icon
             *
             */
            "iconClass": string;
            set(property:"iconClass", value: string): void;
            get(property:"iconClass"): string;
            watch(property:"iconClass", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * A unique, opaque ID string that can be assigned by users or by the
             * system. If the developer passes an ID which is known not to be
             * unique, the specified ID is ignored and the system-generated ID is
             * used instead.
             *
             */
            "id": string;
            set(property:"id", value: string): void;
            get(property:"id"): string;
            watch(property:"id", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Fires onChange for each value change or only on demand
             *
             */
            "intermediateChanges": boolean;
            set(property:"intermediateChanges", value: boolean): void;
            get(property:"intermediateChanges"): boolean;
            watch(property:"intermediateChanges", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             *
             */
            "isBusy": boolean;
            set(property:"isBusy", value: boolean): void;
            get(property:"isBusy"): boolean;
            watch(property:"isBusy", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Content to display in button.
             *
             */
            "label": string;
            set(property:"label", value: string): void;
            get(property:"label"): string;
            watch(property:"label", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Rarely used.  Overrides the default Dojo locale used to render this widget,
             * as defined by the HTML LANG attribute.
             * Value must be among the list of locales specified during by the Dojo bootstrap,
             * formatted according to RFC 3066 (like en-us).
             *
             */
            "lang": string;
            set(property:"lang", value: string): void;
            get(property:"lang"): string;
            watch(property:"lang", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Name used when submitting form; same as "name" attribute or plain HTML elements
             *
             */
            "name": string;
            set(property:"name", value: string): void;
            get(property:"name"): string;
            watch(property:"name", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * The document this widget belongs to.  If not specified to constructor, will default to
             * srcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global
             *
             */
            "ownerDocument": Object;
            set(property:"ownerDocument", value: Object): void;
            get(property:"ownerDocument"): Object;
            watch(property:"ownerDocument", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * On focus, should this widget scroll into view?
             *
             */
            "scrollOnFocus": boolean;
            set(property:"scrollOnFocus", value: boolean): void;
            get(property:"scrollOnFocus"): boolean;
            watch(property:"scrollOnFocus", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             *
             */
            "searchContainerNode": boolean;
            set(property:"searchContainerNode", value: boolean): void;
            get(property:"searchContainerNode"): boolean;
            watch(property:"searchContainerNode", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Set this to true to hide the label text and display only the icon.
             * (If showLabel=false then iconClass must be specified.)
             * Especially useful for toolbars.
             * If showLabel=true, the label will become the title (a.k.a. tooltip/hint) of the icon.
             *
             * The exception case is for computers in high-contrast mode, where the label
             * will still be displayed, since the icon doesn't appear.
             *
             */
            "showLabel": boolean;
            set(property:"showLabel", value: boolean): void;
            get(property:"showLabel"): boolean;
            watch(property:"showLabel", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * pointer to original DOM node
             *
             */
            "srcNodeRef": HTMLElement;
            set(property:"srcNodeRef", value: HTMLElement): void;
            get(property:"srcNodeRef"): HTMLElement;
            watch(property:"srcNodeRef", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * HTML style attributes as cssText string or name/value hash
             *
             */
            "style": string;
            set(property:"style", value: string): void;
            get(property:"style"): string;
            watch(property:"style", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Order fields are traversed when user hits the tab key
             *
             */
            "tabIndex": string;
            set(property: "tabIndex", value: string): void;
            get(property: "tabIndex"): string;
            watch(property: "tabIndex", callback: { (property?: string, oldValue?: string, newValue?: string):void}) :{unwatch():void}
            /**
             * Path to template (HTML file) for this widget relative to dojo.baseUrl.
             * Deprecated: use templateString with require([... "dojo/text!..."], ...) instead
             *
             */
            "templatePath": string;
            set(property:"templatePath", value: string): void;
            get(property:"templatePath"): string;
            watch(property:"templatePath", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "templateString": string;
            set(property:"templateString", value: string): void;
            get(property:"templateString"): string;
            watch(property:"templateString", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "timeout": Object;
            set(property:"timeout", value: Object): void;
            get(property:"timeout"): Object;
            watch(property:"timeout", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * HTML title attribute.
             *
             * For form widgets this specifies a tooltip to display when hovering over
             * the widget (just like the native HTML title attribute).
             *
             * For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,
             * etc., it's used to specify the tab label, accordion pane title, etc.  In this case it's
             * interpreted as HTML.
             *
             */
            "title": string;
            set(property:"title", value: string): void;
            get(property:"title"): string;
            watch(property:"title", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * When this widget's title attribute is used to for a tab label, accordion pane title, etc.,
             * this specifies the tooltip to appear when the mouse is hovered over that text.
             *
             */
            "tooltip": string;
            set(property:"tooltip", value: string): void;
            get(property:"tooltip"): string;
            watch(property:"tooltip", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "type": string;
            set(property:"type", value: string): void;
            get(property:"type"): string;
            watch(property:"type", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * use a busy icon
             *
             */
            "useIcon": boolean;
            set(property:"useIcon", value: boolean): void;
            get(property:"useIcon"): boolean;
            watch(property:"useIcon", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "value": string;
            set(property:"value", value: string): void;
            get(property:"value"): string;
            watch(property:"value", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: String, value: Object): any;
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: Object, value: Object): any;
            /**
             * Construct the UI for this widget, setting this.domNode.
             * Most widgets will mixin dijit._TemplatedMixin, which implements this method.
             *
             */
            buildRendering(): void;
            /**
             * if no timeout is set or for other reason the user can put the button back
             * to being idle
             *
             */
            cancel(): void;
            /**
             * Compare 2 values (as returned by get('value') for this widget).
             *
             * @param val1
             * @param val2
             */
            compare(val1: any, val2: any): number;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: Function): any;
            /**
             * Wrapper to setTimeout to avoid deferred functions executing
             * after the originating widget has been destroyed.
             * Returns an object handle with a remove method (that returns null) (replaces clearTimeout).
             *
             * @param fcn Function reference.
             * @param delay               OptionalDelay, defaults to 0.
             */
            defer(fcn: Function, delay: number): Object;
            /**
             * Destroy this widget, but not its descendants.  Descendants means widgets inside of
             * this.containerNode.   Will also destroy any resources (including widgets) registered via this.own().
             *
             * This method will also destroy internal widgets such as those created from a template,
             * assuming those widgets exist inside of this.domNode but outside of this.containerNode.
             *
             * For 2.0 it's planned that this method will also destroy descendant widgets, so apps should not
             * depend on the current ability to destroy a widget without destroying its descendants.   Generally
             * they should use destroyRecursive() for widgets with children.
             *
             * @param preserveDom If true, this method will leave the original DOM structure alone.Note: This will not yet work with _TemplatedMixin widgets
             */
            destroy(preserveDom?: boolean): void;
            /**
             * Recursively destroy the children of this widget and their
             * descendants.
             *
             * @param preserveDom               OptionalIf true, the preserveDom attribute is passed to all descendantwidget's .destroy() method. Not for use with _Templatedwidgets.
             */
            destroyDescendants(preserveDom: boolean): void;
            /**
             * Destroy this widget and its descendants
             * This is the generic "destructor" function that all widget users
             * should call to cleanly discard with a widget. Once a widget is
             * destroyed, it is removed from the manager object.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structurealone of descendant Widgets. Note: This will NOT work withdijit._TemplatedMixin widgets.
             */
            destroyRecursive(preserveDom: boolean): void;
            /**
             * Destroys the DOM nodes associated with this widget.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structure aloneduring tear-down. Note: this will not work with _Templatedwidgets yet.
             */
            destroyRendering(preserveDom?: boolean): void;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Disconnects handle created by connect.
             *
             * @param handle
             */
            disconnect(handle: any): void;
            /**
             * Used by widgets to signal that a synthetic event occurred, ex:
             *
             * myWidget.emit("attrmodified-selectedChildWidget", {}).
             * Emits an event on this.domNode named type.toLowerCase(), based on eventObj.
             * Also calls onType() method, if present, and returns value from that method.
             * By default passes eventObj to callback, but will pass callbackArgs instead, if specified.
             * Modifies eventObj by adding missing parameters (bubbles, cancelable, widget).
             *
             * @param type
             * @param eventObj               Optional
             * @param callbackArgs               Optional
             */
            emit(type: String, eventObj: Object, callbackArgs: any[]): any;
            /**
             * Put focus on this widget
             *
             */
            focus(): void;
            /**
             * Get a property from a widget.
             * Get a named property from a widget. The property may
             * potentially be retrieved via a getter method. If no getter is defined, this
             * just retrieves the object's property.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _getFooAttr(), calling:
             * myWidget.get("foo") would be equivalent to calling
             * widget._getFooAttr() and myWidget.get("bar")
             * would be equivalent to the expression
             * widget.bar2
             *
             * @param name The property to get.
             */
            get(name: any): any;
            /**
             * Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent
             * is this widget.   Note that it does not return all descendants, but rather just direct children.
             * Analogous to Node.childNodes,
             * except containing widgets rather than DOMNodes.
             *
             * The result intentionally excludes internally created widgets (a.k.a. supporting widgets)
             * outside of this.containerNode.
             *
             * Note that the array returned is a simple array.  Application code should not assume
             * existence of methods like forEach().
             *
             */
            getChildren(): any[];
            /**
             * Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
             * This method should generally be avoided as it returns widgets declared in templates, which are
             * supposed to be internal/hidden, but it's left here for back-compat reasons.
             *
             */
            getDescendants(): any[];
            /**
             * Returns the parent widget of this widget.
             *
             */
            getParent(): any;
            /**
             * Deprecated.  Use get('value') instead.
             *
             */
            getValue(): any;
            /**
             * Return true if this widget can currently be focused
             * and false if not
             *
             */
            isFocusable(): any;
            /**
             * Return this widget's explicit or implicit orientation (true for LTR, false for RTL)
             *
             */
            isLeftToRight(): any;
            /**
             * sets state from idle to busy
             *
             */
            makeBusy(): void;
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: String, func: Function): any;
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: Function, func: Function): any;
            /**
             * Track specified handles and remove/destroy them when this instance is destroyed, unless they were
             * already removed/destroyed manually.
             *
             */
            own(): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: number): any;
            /**
             *
             */
            postCreate(): void;
            /**
             *
             */
            postMixInProperties(): void;
            /**
             * to reset existing timeout and setting a new timeout
             *
             * @param timeout
             */
            resetTimeout(timeout: number): void;
            /**
             * Set a property on a widget
             * Sets named properties on a widget which may potentially be handled by a
             * setter in the widget.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _setFooAttr(), calling
             * myWidget.set("foo", "Howdy!") would be equivalent to calling
             * widget._setFooAttr("Howdy!") and myWidget.set("bar", 3)
             * would be equivalent to the statement widget.bar = 3;
             *
             * set() may also be called with a hash of name/value pairs, ex:
             *
             * myWidget.set({
             *     foo: "Howdy",
             *     bar: 3
             * });
             * This is equivalent to calling set(foo, "Howdy") and set(bar, 3)
             *
             * @param name The property to set.
             * @param value The value to set in the property.
             */
            set(name: any, value: any): any;
            /**
             * Deprecated.  Use set() instead.
             *
             * @param attr
             * @param value
             */
            setAttribute(attr: String, value: any): void;
            /**
             * Deprecated.  Use set('disabled', ...) instead.
             *
             * @param disabled
             */
            setDisabled(disabled: boolean): void;
            /**
             * Deprecated.  Use set('label', ...) instead.
             *
             * @param content
             */
            setLabel(content: String): void;
            /**
             * Deprecated.  Use set('value', ...) instead.
             *
             * @param value
             */
            setValue(value: String): void;
            /**
             * Processing after the DOM fragment is added to the document
             * Called after a widget and its children have been created and added to the page,
             * and all related widgets have finished their create() cycle, up through postCreate().
             *
             * Note that startup() may be called while the widget is still hidden, for example if the widget is
             * inside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.
             * For widgets that need to do layout, it's best to put that layout code inside resize(), and then
             * extend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.
             *
             */
            startup(): void;
            /**
             * Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.
             *
             * Subscribes to the specified topic and calls the specified method
             * of this object and registers for unsubscribe() on widget destroy.
             *
             * Provide widget-specific analog to dojo.subscribe, except with the
             * implicit use of this widget as the target object.
             *
             * @param t The topic
             * @param method The callback
             */
            subscribe(t: String, method: Function): any;
            /**
             * Returns a string that represents the widget.
             * When a widget is cast to a string, this method will be used to generate the
             * output. Currently, it does not implement any sort of reversible
             * serialization.
             *
             */
            toString(): string;
            /**
             * Deprecated. Override destroy() instead to implement custom widget tear-down
             * behavior.
             *
             */
            uninitialize(): boolean;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Unsubscribes handle created by this.subscribe.
             * Also removes handle from this widget's list of subscriptions
             *
             * @param handle
             */
            unsubscribe(handle: Object): void;
            /**
             * Watches a property for changes
             *
             * @param name               OptionalIndicates the property to watch. This is optional (the callback may be theonly parameter), and if omitted, all the properties will be watched
             * @param callback The function to execute when the property changes. This will be called afterthe property has been changed. The callback will be called with the |this|set to the instance, the first argument as the name of the property, thesecond argument as the old value and the third argument as the new value.
             */
            watch(property: string, callback:{(property?:string, oldValue?:any, newValue?: any):void}) :{unwatch():void};
            /**
             * Static method to get a template based on the templatePath or
             * templateString key
             */
            getCachedTemplate(): any;
            /**
             * Called when the widget stops being "active" because
             * focus moved to something outside of it, or the user
             * clicked somewhere outside of it, or the widget was
             * hidden.
             *
             */
            onBlur(): void;
            /**
             * Callback when this widget's value is changed.
             *
             * @param newValue
             */
            onChange(newValue: any): void;
            /**
             * Connect to this function to receive notifications of mouse click events.
             *
             * @param event mouse Event
             */
            onClick(event: Event): boolean;
            /**
             * Called when this widget is being displayed as a popup (ex: a Calendar popped
             * up from a DateTextBox), and it is hidden.
             * This is called from the dijit.popup code, and should not be called directly.
             *
             * Also used as a parameter for children of dijit/layout/StackContainer or subclasses.
             * Callback if a user tries to close the child.   Child will be closed if this function returns true.
             *
             */
            onClose(): boolean;
            /**
             * Connect to this function to receive notifications of mouse double click events.
             *
             * @param event mouse Event
             */
            onDblClick(event: any): void;
            /**
             * Called when the widget becomes "active" because
             * it or a widget inside of it either has focus, or has recently
             * been clicked.
             *
             */
            onFocus(): void;
            /**
             * Called when another widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate hide of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onHide(): void;
            /**
             * Connect to this function to receive notifications of keys being pressed down.
             *
             * @param event key Event
             */
            onKeyDown(event: any): void;
            /**
             * Connect to this function to receive notifications of printable keys being typed.
             *
             * @param event key Event
             */
            onKeyPress(event: any): void;
            /**
             * Connect to this function to receive notifications of keys being released.
             *
             * @param event key Event
             */
            onKeyUp(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is pressed down.
             *
             * @param event mouse Event
             */
            onMouseDown(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto this widget.
             *
             * @param event mouse Event
             */
            onMouseEnter(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of this widget.
             *
             * @param event mouse Event
             */
            onMouseLeave(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseMove(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOut(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOver(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is released.
             *
             * @param event mouse Event
             */
            onMouseUp(event: any): void;
            /**
             * Called when this widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate display of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onShow(): void;
        }
        /**
         * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/CheckedMultiSelect.html
         *
         * Extends the core dijit MultiSelect to provide a "checkbox" selector
         *
         * @param params Hash of initialization parameters for widget, including scalar values (like title, duration etc.)and functions, typically callbacks like onClick.The hash can contain any of the widget's properties, excluding read-only properties.
         * @param srcNodeRef       OptionalIf a srcNodeRef (DOM node) is specified, replace srcNodeRef with my generated DOM tree
         */
        class CheckedMultiSelect extends dijit.form._FormSelectWidget {
            constructor(params?: Object, srcNodeRef?: HTMLElement);
            /**
             * True if mouse was pressed while over this widget, and hasn't been released yet
             *
             */
            "active": boolean;
            set(property:"active", value: boolean): void;
            get(property:"active"): boolean;
            watch(property:"active", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "alt": string;
            set(property:"alt", value: string): void;
            get(property:"alt"): string;
            watch(property:"alt", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "aria-label": string;
            set(property:"aria-label", value: string): void;
            get(property:"aria-label"): string;
            watch(property:"aria-label", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Object to which attach points and events will be scoped.  Defaults
             * to 'this'.
             *
             */
            "attachScope": Object;
            set(property:"attachScope", value: Object): void;
            get(property:"attachScope"): Object;
            watch(property:"attachScope", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute
             * for each XXX attribute to be mapped to the DOM.
             *
             * attributeMap sets up a "binding" between attributes (aka properties)
             * of the widget and the widget's DOM.
             * Changes to widget attributes listed in attributeMap will be
             * reflected into the DOM.
             *
             * For example, calling set('title', 'hello')
             * on a TitlePane will automatically cause the TitlePane's DOM to update
             * with the new title.
             *
             * attributeMap is a hash where the key is an attribute of the widget,
             * and the value reflects a binding to a:
             *
             * DOM node attribute
             *   focus: {node: "focusNode", type: "attribute"}
             * Maps this.focus to this.focusNode.focus
             *
             * DOM node innerHTML
             *   title: { node: "titleNode", type: "innerHTML" }
             * Maps this.title to this.titleNode.innerHTML
             *
             * DOM node innerText
             *   title: { node: "titleNode", type: "innerText" }
             * Maps this.title to this.titleNode.innerText
             *
             * DOM node CSS class
             *   myClass: { node: "domNode", type: "class" }
             * Maps this.myClass to this.domNode.className
             *
             * If the value is an array, then each element in the array matches one of the
             * formats of the above list.
             *
             * There are also some shorthands for backwards compatibility:
             *
             * string --> { node: string, type: "attribute" }, for example:
             * "focusNode" ---> { node: "focusNode", type: "attribute" }
             * "" --> { node: "domNode", type: "attribute" }
             *
             */
            "attributeMap": Object;
            set(property:"attributeMap", value: Object): void;
            get(property:"attributeMap"): Object;
            watch(property:"attributeMap", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             *
             */
            "baseClass": string;
            set(property:"baseClass", value: string): void;
            get(property:"baseClass"): string;
            watch(property:"baseClass", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "class": string;
            set(property:"class", value: string): void;
            get(property:"class"): string;
            watch(property:"class", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Designates where children of the source DOM node will be placed.
             * "Children" in this case refers to both DOM nodes and widgets.
             * For example, for myWidget:
             *
             * <div data-dojo-type=myWidget>
             *     <b> here's a plain DOM node
             *     <span data-dojo-type=subWidget>and a widget</span>
             *     <i> and another plain DOM node </i>
             * </div>
             * containerNode would point to:
             *
             * <b> here's a plain DOM node
             * <span data-dojo-type=subWidget>and a widget</span>
             * <i> and another plain DOM node </i>
             * In templated widgets, "containerNode" is set via a
             * data-dojo-attach-point assignment.
             *
             * containerNode must be defined for any widget that accepts innerHTML
             * (like ContentPane or BorderContainer or even Button), and conversely
             * is null for widgets that don't, like TextBox.
             *
             */
            "containerNode": HTMLElement;
            set(property:"containerNode", value: HTMLElement): void;
            get(property:"containerNode"): HTMLElement;
            watch(property:"containerNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * Subclasses may define a cssStateNodes property that lists sub-nodes within the widget that
             * need CSS classes applied on mouse hover/press and focus.
             *
             * Each entry in this optional hash is a an attach-point name (like "upArrowButton") mapped to a CSS class name
             * (like "dijitUpArrowButton"). Example:
             *
             * {
             *     "upArrowButton": "dijitUpArrowButton",
             *     "downArrowButton": "dijitDownArrowButton"
             * }
             * The above will set the CSS class dijitUpArrowButton to the this.upArrowButton DOMNode when it
             *
             * is hovered, etc.
             *
             */
            "cssStateNodes": Object;
            set(property:"cssStateNodes", value: Object): void;
            get(property:"cssStateNodes"): Object;
            watch(property:"cssStateNodes", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Bi-directional support, as defined by the HTML DIR
             * attribute. Either left-to-right "ltr" or right-to-left "rtl".  If undefined, widgets renders in page's
             * default direction.
             *
             */
            "dir": string;
            set(property:"dir", value: string): void;
            get(property:"dir"): string;
            watch(property:"dir", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Should this widget respond to user input?
             * In markup, this is specified as "disabled='disabled'", or just "disabled".
             *
             */
            "disabled": boolean;
            set(property:"disabled", value: boolean): void;
            get(property:"disabled"): boolean;
            watch(property:"disabled", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * This is our visible representation of the widget! Other DOM
             * Nodes may by assigned to other properties, usually through the
             * template system's data-dojo-attach-point syntax, but the domNode
             * property is the canonical "top level" node in widget UI.
             *
             */
            "domNode": HTMLElement;
            set(property:"domNode", value: HTMLElement): void;
            get(property:"domNode"): HTMLElement;
            watch(property:"domNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * Drop down version or not
             *
             */
            "dropDown": boolean;
            set(property:"dropDown", value: boolean): void;
            get(property:"dropDown"): boolean;
            watch(property:"dropDown", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * This widget or a widget it contains has focus, or is "active" because
             * it was recently clicked.
             *
             */
            "focused": boolean;
            set(property:"focused", value: boolean): void;
            get(property:"focused"): boolean;
            watch(property:"focused", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * True if cursor is over this widget
             *
             */
            "hovering": boolean;
            set(property:"hovering", value: boolean): void;
            get(property:"hovering"): boolean;
            watch(property:"hovering", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * A unique, opaque ID string that can be assigned by users or by the
             * system. If the developer passes an ID which is known not to be
             * unique, the specified ID is ignored and the system-generated ID is
             * used instead.
             *
             */
            "id": string;
            set(property:"id", value: string): void;
            get(property:"id"): string;
            watch(property:"id", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Fires onChange for each value change or only on demand
             *
             */
            "intermediateChanges": boolean;
            set(property:"intermediateChanges", value: boolean): void;
            get(property:"intermediateChanges"): boolean;
            watch(property:"intermediateChanges", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * The message to display if value is invalid.
             *
             */
            "invalidMessage": string;
            set(property:"invalidMessage", value: string): void;
            get(property:"invalidMessage"): string;
            watch(property:"invalidMessage", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * The entries in the drop down list come from this attribute in the dojo.store items.
             * If store is set, labelAttr must be set too, unless store is an old-style
             * dojo.data store rather than a new dojo/store.
             *
             */
            "labelAttr": Object;
            set(property:"labelAttr", value: Object): void;
            get(property:"labelAttr"): Object;
            watch(property:"labelAttr", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Label of the drop down button
             *
             */
            "labelText": string;
            set(property:"labelText", value: string): void;
            get(property:"labelText"): string;
            watch(property:"labelText", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Rarely used.  Overrides the default Dojo locale used to render this widget,
             * as defined by the HTML LANG attribute.
             * Value must be among the list of locales specified during by the Dojo bootstrap,
             * formatted according to RFC 3066 (like en-us).
             *
             */
            "lang": string;
            set(property:"lang", value: string): void;
            get(property:"lang"): string;
            watch(property:"lang", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * By default loadChildren is called when the items are fetched from the
             * store.  This property allows delaying loadChildren (and the creation
             * of the options/menuitems) until the user clicks the button to open the
             * dropdown.
             *
             */
            "loadChildrenOnOpen": boolean;
            set(property:"loadChildrenOnOpen", value: boolean): void;
            get(property:"loadChildrenOnOpen"): boolean;
            watch(property:"loadChildrenOnOpen", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Whether or not we are multi-valued
             *
             */
            "multiple": boolean;
            set(property:"multiple", value: boolean): void;
            get(property:"multiple"): boolean;
            watch(property:"multiple", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Name used when submitting form; same as "name" attribute or plain HTML elements
             *
             */
            "name": string;
            set(property:"name", value: string): void;
            get(property:"name"): string;
            watch(property:"name", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * A callback to do with an onFetch - but before any items are actually
             * iterated over (i.e. to filter even further what you want to add)
             *
             */
            "onFetch": Function;
            set(property:"onFetch", value: Function): void;
            get(property:"onFetch"): Function;
            watch(property:"onFetch", callback:{(property?:string, oldValue?:Function, newValue?: Function):void}) :{unwatch():void}
            /**
             * This is the dojo.Deferred returned by setStore().
             * Calling onLoadDeferred.then() registers your
             * callback to be called only once, when the prior setStore completes.
             *
             */
            "onLoadDeferred": Object;
            set(property:"onLoadDeferred", value: Object): void;
            get(property:"onLoadDeferred"): Object;
            watch(property:"onLoadDeferred", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * The set of options for our select item.  Roughly corresponds to
             * the html <option> tag.
             *
             */
            "options": Object;
            set(property:"options", value: Object): void;
            get(property:"options"): Object;
            watch(property:"options", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * The document this widget belongs to.  If not specified to constructor, will default to
             * srcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global
             *
             */
            "ownerDocument": Object;
            set(property:"ownerDocument", value: Object): void;
            get(property:"ownerDocument"): Object;
            watch(property:"ownerDocument", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * A query to use when fetching items from our store
             *
             */
            "query": Object;
            set(property:"query", value: Object): void;
            get(property:"query"): Object;
            watch(property:"query", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Query options to use when fetching from the store
             *
             */
            "queryOptions": Object;
            set(property:"queryOptions", value: Object): void;
            get(property:"queryOptions"): Object;
            watch(property:"queryOptions", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Should this widget respond to user input?
             * In markup, this is specified as "readOnly".
             * Similar to disabled except readOnly form values are submitted.
             *
             */
            "readOnly": boolean;
            set(property:"readOnly", value: boolean): void;
            get(property:"readOnly"): boolean;
            watch(property:"readOnly", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * User is required to check at least one item.
             *
             */
            "required": boolean;
            set(property:"required", value: boolean): void;
            get(property:"required"): boolean;
            watch(property:"required", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * On focus, should this widget scroll into view?
             *
             */
            "scrollOnFocus": boolean;
            set(property:"scrollOnFocus", value: boolean): void;
            get(property:"scrollOnFocus"): boolean;
            watch(property:"scrollOnFocus", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             *
             */
            "searchContainerNode": boolean;
            set(property:"searchContainerNode", value: boolean): void;
            get(property:"searchContainerNode"): boolean;
            watch(property:"searchContainerNode", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Flag to sort the options returned from a store by the label of
             * the store.
             *
             */
            "sortByLabel": boolean;
            set(property:"sortByLabel", value: boolean): void;
            get(property:"sortByLabel"): boolean;
            watch(property:"sortByLabel", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * pointer to original DOM node
             *
             */
            "srcNodeRef": HTMLElement;
            set(property:"srcNodeRef", value: HTMLElement): void;
            get(property:"srcNodeRef"): HTMLElement;
            watch(property:"srcNodeRef", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * A store to use for getting our list of options - rather than reading them
             * from the <option> html tags.   Should support getIdentity().
             * For back-compat store can also be a dojo/data/api/Identity.
             *
             */
            "store": Object;
            set(property:"store", value: Object): void;
            get(property:"store"): Object;
            watch(property:"store", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * HTML style attributes as cssText string or name/value hash
             *
             */
            "style": string;
            set(property:"style", value: string): void;
            get(property:"style"): string;
            watch(property:"style", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Order fields are traversed when user hits the tab key
             *
             */
            "tabIndex": string;
            set(property:"tabIndex", value: string): void;
            get(property:"tabIndex"): string;
            watch(property:"tabIndex", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Path to template (HTML file) for this widget relative to dojo.baseUrl.
             * Deprecated: use templateString with require([... "dojo/text!..."], ...) instead
             *
             */
            "templatePath": string;
            set(property:"templatePath", value: string): void;
            get(property:"templatePath"): string;
            watch(property:"templatePath", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "templateString": string;
            set(property:"templateString", value: string): void;
            get(property:"templateString"): string;
            watch(property:"templateString", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * HTML title attribute.
             *
             * For form widgets this specifies a tooltip to display when hovering over
             * the widget (just like the native HTML title attribute).
             *
             * For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,
             * etc., it's used to specify the tab label, accordion pane title, etc.  In this case it's
             * interpreted as HTML.
             *
             */
            "title": string;
            set(property:"title", value: string): void;
            get(property:"title"): string;
            watch(property:"title", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * When this widget's title attribute is used to for a tab label, accordion pane title, etc.,
             * this specifies the tooltip to appear when the mouse is hovered over that text.
             *
             */
            "tooltip": string;
            set(property:"tooltip", value: string): void;
            get(property:"tooltip"): string;
            watch(property:"tooltip", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * See description of Tooltip.defaultPosition for details on this parameter.
             *
             */
            "tooltipPosition": Object;
            set(property:"tooltipPosition", value: Object): void;
            get(property:"tooltipPosition"): Object;
            watch(property:"tooltipPosition", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "type": string;
            set(property:"type", value: string): void;
            get(property:"type"): string;
            watch(property:"type", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "value": string;
            set(property:"value", value: string): void;
            get(property:"value"): string;
            watch(property:"value", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Adds an option or options to the end of the select.  If value
             * of the option is empty or missing, a separator is created instead.
             * Passing in an array of options will yield slightly better performance
             * since the children are only loaded once.
             *
             * @param option
             */
            addOption(option: dijit.form._FormSelectWidget.__SelectOption): void;
            /**
             * Adds an option or options to the end of the select.  If value
             * of the option is empty or missing, a separator is created instead.
             * Passing in an array of options will yield slightly better performance
             * since the children are only loaded once.
             *
             * @param option
             */
            addOption(option: dijit.form._FormSelectWidget.__SelectOption[]): void;
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: String, value: Object): any;
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: Object, value: Object): any;
            /**
             *
             */
            buildRendering(): void;
            /**
             * Compare 2 values (as returned by get('value') for this widget).
             *
             * @param val1
             * @param val2
             */
            compare(val1: any, val2: any): number;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: Function): any;
            /**
             * Wrapper to setTimeout to avoid deferred functions executing
             * after the originating widget has been destroyed.
             * Returns an object handle with a remove method (that returns null) (replaces clearTimeout).
             *
             * @param fcn Function reference.
             * @param delay               OptionalDelay, defaults to 0.
             */
            defer(fcn: Function, delay: number): Object;
            /**
             * Clean up our connections
             *
             */
            destroy(): void;
            /**
             * Recursively destroy the children of this widget and their
             * descendants.
             *
             * @param preserveDom               OptionalIf true, the preserveDom attribute is passed to all descendantwidget's .destroy() method. Not for use with _Templatedwidgets.
             */
            destroyDescendants(preserveDom: boolean): void;
            /**
             * Destroy this widget and its descendants
             * This is the generic "destructor" function that all widget users
             * should call to cleanly discard with a widget. Once a widget is
             * destroyed, it is removed from the manager object.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structurealone of descendant Widgets. Note: This will NOT work withdijit._TemplatedMixin widgets.
             */
            destroyRecursive(preserveDom: boolean): void;
            /**
             * Destroys the DOM nodes associated with this widget.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structure aloneduring tear-down. Note: this will not work with _Templatedwidgets yet.
             */
            destroyRendering(preserveDom?: boolean): void;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Disconnects handle created by connect.
             *
             * @param handle
             */
            disconnect(handle: any): void;
            /**
             * Overridable method to display validation errors/hints.
             * By default uses a tooltip.
             *
             * @param message
             */
            displayMessage(message: String): void;
            /**
             * Used by widgets to signal that a synthetic event occurred, ex:
             *
             * myWidget.emit("attrmodified-selectedChildWidget", {}).
             * Emits an event on this.domNode named type.toLowerCase(), based on eventObj.
             * Also calls onType() method, if present, and returns value from that method.
             * By default passes eventObj to callback, but will pass callbackArgs instead, if specified.
             * Modifies eventObj by adding missing parameters (bubbles, cancelable, widget).
             *
             * @param type
             * @param eventObj               Optional
             * @param callbackArgs               Optional
             */
            emit(type: String, eventObj: Object, callbackArgs: any[]): any;
            /**
             * Put focus on this widget
             *
             */
            focus(): void;
            /**
             * Get a property from a widget.
             * Get a named property from a widget. The property may
             * potentially be retrieved via a getter method. If no getter is defined, this
             * just retrieves the object's property.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _getFooAttr(), calling:
             * myWidget.get("foo") would be equivalent to calling
             * widget._getFooAttr() and myWidget.get("bar")
             * would be equivalent to the expression
             * widget.bar2
             *
             * @param name The property to get.
             */
            get(name: any): any;
            /**
             * Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent
             * is this widget.   Note that it does not return all descendants, but rather just direct children.
             * Analogous to Node.childNodes,
             * except containing widgets rather than DOMNodes.
             *
             * The result intentionally excludes internally created widgets (a.k.a. supporting widgets)
             * outside of this.containerNode.
             *
             * Note that the array returned is a simple array.  Application code should not assume
             * existence of methods like forEach().
             *
             */
            getChildren(): any[];
            /**
             * Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
             * This method should generally be avoided as it returns widgets declared in templates, which are
             * supposed to be internal/hidden, but it's left here for back-compat reasons.
             *
             */
            getDescendants(): any[];
            /**
             * Return an error message to show if appropriate
             *
             * @param isFocused
             */
            getErrorMessage(isFocused: boolean): any;
            /**
             * Returns a given option (or options).
             *
             * @param valueOrIdx If passed in as a string, that string is used to look up the optionin the array of options - based on the value property.(See dijit/form/_FormSelectWidget.__SelectOption).If passed in a number, then the option with the given index (0-based)within this select will be returned.If passed in a dijit/form/_FormSelectWidget.__SelectOption, the same option will bereturned if and only if it exists within this select.If passed an array, then an array will be returned with each elementin the array being looked up.If not passed a value, then all options will be returned
             */
            getOptions(valueOrIdx: any): any;
            /**
             * Returns the parent widget of this widget.
             *
             */
            getParent(): any;
            /**
             * Deprecated.  Use get('value') instead.
             *
             */
            getValue(): any;
            /**
             * Invert the selection
             *
             * @param onChange If null, onChange is not fired.
             */
            invertSelection(onChange: boolean): void;
            /**
             * Return true if this widget can currently be focused
             * and false if not
             *
             */
            isFocusable(): any;
            /**
             * Return this widget's explicit or implicit orientation (true for LTR, false for RTL)
             *
             */
            isLeftToRight(): any;
            /**
             * Tests if the required items are selected.
             * Can override with your own routine in a subclass.
             *
             * @param isFocused
             */
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: String, func: Function): any;
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: Function, func: Function): any;
            /**
             * Track specified handles and remove/destroy them when this instance is destroyed, unless they were
             * already removed/destroyed manually.
             *
             */
            own(): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: number): any;
            /**
             * sets up our event handling that we need for functioning
             * as a select
             *
             */
            postCreate(): void;
            /**
             *
             */
            postMixInProperties(): void;
            /**
             * Removes the given option or options.  You can remove by string
             * (in which case the value is removed), number (in which case the
             * index in the options array is removed), or select option (in
             * which case, the select option with a matching value is removed).
             * You can also pass in an array of those values for a slightly
             * better performance since the children are only loaded once.
             * For numeric option values, specify {value: number} as the argument.
             *
             * @param valueOrIdx
             */
            removeOption(valueOrIdx: String): void;
            /**
             * Removes the given option or options.  You can remove by string
             * (in which case the value is removed), number (in which case the
             * index in the options array is removed), or select option (in
             * which case, the select option with a matching value is removed).
             * You can also pass in an array of those values for a slightly
             * better performance since the children are only loaded once.
             * For numeric option values, specify {value: number} as the argument.
             *
             * @param valueOrIdx
             */
            removeOption(valueOrIdx: dijit.form._FormSelectWidget.__SelectOption): void;
            /**
             * Removes the given option or options.  You can remove by string
             * (in which case the value is removed), number (in which case the
             * index in the options array is removed), or select option (in
             * which case, the select option with a matching value is removed).
             * You can also pass in an array of those values for a slightly
             * better performance since the children are only loaded once.
             * For numeric option values, specify {value: number} as the argument.
             *
             * @param valueOrIdx
             */
            removeOption(valueOrIdx: number): void;
            /**
             * Removes the given option or options.  You can remove by string
             * (in which case the value is removed), number (in which case the
             * index in the options array is removed), or select option (in
             * which case, the select option with a matching value is removed).
             * You can also pass in an array of those values for a slightly
             * better performance since the children are only loaded once.
             * For numeric option values, specify {value: number} as the argument.
             *
             * @param valueOrIdx
             */
            removeOption(valueOrIdx: any[]): void;
            /**
             *
             */
            reset(): void;
            /**
             * Set a property on a widget
             * Sets named properties on a widget which may potentially be handled by a
             * setter in the widget.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _setFooAttr(), calling
             * myWidget.set("foo", "Howdy!") would be equivalent to calling
             * widget._setFooAttr("Howdy!") and myWidget.set("bar", 3)
             * would be equivalent to the statement widget.bar = 3;
             *
             * set() may also be called with a hash of name/value pairs, ex:
             *
             * myWidget.set({
             *     foo: "Howdy",
             *     bar: 3
             * });
             * This is equivalent to calling set(foo, "Howdy") and set(bar, 3)
             *
             * @param name The property to set.
             * @param value The value to set in the property.
             */
            set(name: any, value: any): any;
            /**
             * Deprecated.  Use set() instead.
             *
             * @param attr
             * @param value
             */
            setAttribute(attr: String, value: any): void;
            /**
             * Deprecated.  Use set('disabled', ...) instead.
             *
             * @param disabled
             */
            setDisabled(disabled: boolean): void;
            /**
             * Sets the store you would like to use with this select widget.
             * The selected value is the value of the new store to set.  This
             * function returns the original store, in case you want to reuse
             * it or something.
             *
             * @param store The dojo.store you would like to use - it MUST implement getIdentity()and MAY implement observe().For backwards-compatibility this can also be a data.data store, in which caseit MUST implement dojo/data/api/Identity,and MAY implement dojo/data/api/Notification.
             * @param selectedValue               OptionalThe value that this widget should set itself to after the storehas been loaded
             * @param fetchArgs               OptionalHash of parameters to set filter on store, etc.query: new value for Select.query,queryOptions: new value for Select.queryOptions,onFetch: callback function for each item in data (Deprecated)
             */
            setStore(store: dojo.store.api.Store, selectedValue: any, fetchArgs: Object): any;
            /**
             * Deprecated.  Use set('value', ...) instead.
             *
             * @param value
             */
            setValue(value: String): void;
            /**
             * Set the value to be the first, or the selected index
             *
             */
            startup(): void;
            /**
             * Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.
             *
             * Subscribes to the specified topic and calls the specified method
             * of this object and registers for unsubscribe() on widget destroy.
             *
             * Provide widget-specific analog to dojo.subscribe, except with the
             * implicit use of this widget as the target object.
             *
             * @param t The topic
             * @param method The callback
             */
            subscribe(t: String, method: Function): any;
            /**
             * Returns a string that represents the widget.
             * When a widget is cast to a string, this method will be used to generate the
             * output. Currently, it does not implement any sort of reversible
             * serialization.
             *
             */
            toString(): string;
            /**
             * Restore the value to the last value passed to onChange
             *
             */
            undo(): void;
            /**
             *
             */
            uninitialize(): boolean;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Unsubscribes handle created by this.subscribe.
             * Also removes handle from this widget's list of subscriptions
             *
             * @param handle
             */
            unsubscribe(handle: Object): void;
            /**
             * Updates the values of the given option.  The option to update
             * is matched based on the value of the entered option.  Passing
             * in an array of new options will yield better performance since
             * the children will only be loaded once.
             *
             * @param newOption
             */
            updateOption(newOption: dijit.form._FormSelectWidget.__SelectOption): void;
            /**
             * Updates the values of the given option.  The option to update
             * is matched based on the value of the entered option.  Passing
             * in an array of new options will yield better performance since
             * the children will only be loaded once.
             *
             * @param newOption
             */
            updateOption(newOption: dijit.form._FormSelectWidget.__SelectOption[]): void;
            /**
             *
             * @param isFocused
             */
            validate(isFocused: any): any;
            /**
             * Overridable function used to validate that an item is selected if required =
             * true.
             *
             */
            validator(): any;
            /**
             * Watches a property for changes
             *
             * @param name               OptionalIndicates the property to watch. This is optional (the callback may be theonly parameter), and if omitted, all the properties will be watched
             * @param callback The function to execute when the property changes. This will be called afterthe property has been changed. The callback will be called with the |this|set to the instance, the first argument as the name of the property, thesecond argument as the old value and the third argument as the new value.
             */
            watch(property: string, callback:{(property?:string, oldValue?:any, newValue?: any):void}) :{unwatch():void};
            /**
             * Static method to get a template based on the templatePath or
             * templateString key
             */
            getCachedTemplate(): any;
            /**
             * a function that can be connected to in order to receive a
             * notification that an item as been added to this dijit.
             *
             * @param item
             * @param option
             */
            onAfterAddOptionItem(item: any, option: any): void;
            /**
             * Called when the widget stops being "active" because
             * focus moved to something outside of it, or the user
             * clicked somewhere outside of it, or the widget was
             * hidden.
             *
             */
            onBlur(): void;
            /**
             * Validate if selection changes.
             *
             * @param newValue
             */
            onChange(newValue: any): void;
            /**
             * Connect to this function to receive notifications of mouse click events.
             *
             * @param event mouse Event
             */
            onClick(event: any): void;
            /**
             * Called when this widget is being displayed as a popup (ex: a Calendar popped
             * up from a DateTextBox), and it is hidden.
             * This is called from the dijit.popup code, and should not be called directly.
             *
             * Also used as a parameter for children of dijit/layout/StackContainer or subclasses.
             * Callback if a user tries to close the child.   Child will be closed if this function returns true.
             *
             */
            onClose(): boolean;
            /**
             * Connect to this function to receive notifications of mouse double click events.
             *
             * @param event mouse Event
             */
            onDblClick(event: any): void;
            /**
             * Called when the widget becomes "active" because
             * it or a widget inside of it either has focus, or has recently
             * been clicked.
             *
             */
            onFocus(): void;
            /**
             * Called when another widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate hide of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onHide(): void;
            /**
             * Connect to this function to receive notifications of keys being pressed down.
             *
             * @param event key Event
             */
            onKeyDown(event: any): void;
            /**
             * Connect to this function to receive notifications of printable keys being typed.
             *
             * @param event key Event
             */
            onKeyPress(event: any): void;
            /**
             * Connect to this function to receive notifications of keys being released.
             *
             * @param event key Event
             */
            onKeyUp(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is pressed down.
             *
             * @param event mouse Event
             */
            onMouseDown(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto this widget.
             *
             * @param event mouse Event
             */
            onMouseEnter(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of this widget.
             *
             * @param event mouse Event
             */
            onMouseLeave(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseMove(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOut(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOver(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is released.
             *
             * @param event mouse Event
             */
            onMouseUp(event: any): void;
            /**
             * a function that can be connected to in order to receive a
             * notification that the store has finished loading and all options
             * from that store are available
             *
             */
            onSetStore(): void;
            /**
             * Called when this widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate display of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onShow(): void;
        }
        /**
         * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/DateTextBox.html
         *
         * A validating, serializable, range-bound date text box with a popup calendar
         *
         * @param params Hash of initialization parameters for widget, including scalar values (like title, duration etc.)and functions, typically callbacks like onClick.The hash can contain any of the widget's properties, excluding read-only properties.
         * @param srcNodeRef       OptionalIf a srcNodeRef (DOM node) is specified, replace srcNodeRef with my generated DOM tree
         */
        class DateTextBox extends dijit.form._DateTimeTextBox {
            constructor(params?: Object, srcNodeRef?: HTMLElement);
            /**
             * True if mouse was pressed while over this widget, and hasn't been released yet
             *
             */
            "active": boolean;
            set(property:"active", value: boolean): void;
            get(property:"active"): boolean;
            watch(property:"active", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "alt": string;
            set(property:"alt", value: string): void;
            get(property:"alt"): string;
            watch(property:"alt", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "aria-label": string;
            set(property:"aria-label", value: string): void;
            get(property:"aria-label"): string;
            watch(property:"aria-label", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Object to which attach points and events will be scoped.  Defaults
             * to 'this'.
             *
             */
            "attachScope": Object;
            set(property:"attachScope", value: Object): void;
            get(property:"attachScope"): Object;
            watch(property:"attachScope", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute
             * for each XXX attribute to be mapped to the DOM.
             *
             * attributeMap sets up a "binding" between attributes (aka properties)
             * of the widget and the widget's DOM.
             * Changes to widget attributes listed in attributeMap will be
             * reflected into the DOM.
             *
             * For example, calling set('title', 'hello')
             * on a TitlePane will automatically cause the TitlePane's DOM to update
             * with the new title.
             *
             * attributeMap is a hash where the key is an attribute of the widget,
             * and the value reflects a binding to a:
             *
             * DOM node attribute
             *   focus: {node: "focusNode", type: "attribute"}
             * Maps this.focus to this.focusNode.focus
             *
             * DOM node innerHTML
             *   title: { node: "titleNode", type: "innerHTML" }
             * Maps this.title to this.titleNode.innerHTML
             *
             * DOM node innerText
             *   title: { node: "titleNode", type: "innerText" }
             * Maps this.title to this.titleNode.innerText
             *
             * DOM node CSS class
             *   myClass: { node: "domNode", type: "class" }
             * Maps this.myClass to this.domNode.className
             *
             * If the value is an array, then each element in the array matches one of the
             * formats of the above list.
             *
             * There are also some shorthands for backwards compatibility:
             *
             * string --> { node: string, type: "attribute" }, for example:
             * "focusNode" ---> { node: "focusNode", type: "attribute" }
             * "" --> { node: "domNode", type: "attribute" }
             *
             */
            "attributeMap": Object;
            set(property:"attributeMap", value: Object): void;
            get(property:"attributeMap"): Object;
            watch(property:"attributeMap", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             *
             */
            "autoWidth": boolean;
            set(property:"autoWidth", value: boolean): void;
            get(property:"autoWidth"): boolean;
            watch(property:"autoWidth", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             *
             */
            "baseClass": string;
            set(property:"baseClass", value: string): void;
            get(property:"baseClass"): string;
            watch(property:"baseClass", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "class": string;
            set(property:"class", value: string): void;
            get(property:"class"): string;
            watch(property:"class", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Despite the name, this parameter specifies both constraints on the input
             * (including starting/ending dates/times allowed) as well as
             * formatting options like whether the date is displayed in long (ex: December 25, 2005)
             * or short (ex: 12/25/2005) format.  See dijit/form/_DateTimeTextBox.__Constraints for details.
             *
             */
            "constraints": Object;
            set(property:"constraints", value: Object): void;
            get(property:"constraints"): Object;
            watch(property:"constraints", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Designates where children of the source DOM node will be placed.
             * "Children" in this case refers to both DOM nodes and widgets.
             * For example, for myWidget:
             *
             * <div data-dojo-type=myWidget>
             *     <b> here's a plain DOM node
             *     <span data-dojo-type=subWidget>and a widget</span>
             *     <i> and another plain DOM node </i>
             * </div>
             * containerNode would point to:
             *
             * <b> here's a plain DOM node
             * <span data-dojo-type=subWidget>and a widget</span>
             * <i> and another plain DOM node </i>
             * In templated widgets, "containerNode" is set via a
             * data-dojo-attach-point assignment.
             *
             * containerNode must be defined for any widget that accepts innerHTML
             * (like ContentPane or BorderContainer or even Button), and conversely
             * is null for widgets that don't, like TextBox.
             *
             */
            "containerNode": HTMLElement;
            set(property:"containerNode", value: HTMLElement): void;
            get(property:"containerNode"): HTMLElement;
            watch(property:"containerNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             *
             */
            "cssStateNodes": Object;
            set(property:"cssStateNodes", value: Object): void;
            get(property:"cssStateNodes"): Object;
            watch(property:"cssStateNodes", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * JavaScript namespace to find calendar routines.  If unspecified, uses Gregorian calendar routines
             * at dojo/date and dojo/date/locale.
             *
             */
            "datePackage": string;
            set(property:"datePackage", value: string): void;
            get(property:"datePackage"): string;
            watch(property:"datePackage", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Bi-directional support, as defined by the HTML DIR
             * attribute. Either left-to-right "ltr" or right-to-left "rtl".  If undefined, widgets renders in page's
             * default direction.
             *
             */
            "dir": string;
            set(property:"dir", value: string): void;
            get(property:"dir"): string;
            watch(property:"dir", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Should this widget respond to user input?
             * In markup, this is specified as "disabled='disabled'", or just "disabled".
             *
             */
            "disabled": boolean;
            set(property:"disabled", value: boolean): void;
            get(property:"disabled"): boolean;
            watch(property:"disabled", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * For subclasses like ComboBox where the displayed value
             * (ex: Kentucky) and the serialized value (ex: KY) are different,
             * this represents the displayed value.
             *
             * Setting 'displayedValue' through set('displayedValue', ...)
             * updates 'value', and vice-versa.  Otherwise 'value' is updated
             * from 'displayedValue' periodically, like onBlur etc.
             *
             * TODO: move declaration to MappedTextBox?
             * Problem is that ComboBox references displayedValue,
             * for benefit of FilteringSelect.
             *
             */
            "displayedValue": string;
            set(property:"displayedValue", value: string): void;
            get(property:"displayedValue"): string;
            watch(property:"displayedValue", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * This is our visible representation of the widget! Other DOM
             * Nodes may by assigned to other properties, usually through the
             * template system's data-dojo-attach-point syntax, but the domNode
             * property is the canonical "top level" node in widget UI.
             *
             */
            "domNode": HTMLElement;
            set(property:"domNode", value: HTMLElement): void;
            get(property:"domNode"): HTMLElement;
            watch(property:"domNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * The widget to display as a popup.  This widget must be
             * defined before the startup function is called.
             *
             */
            "dropDown": Object;
            set(property:"dropDown", value: Object): void;
            get(property:"dropDown"): Object;
            watch(property:"dropDown", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * The default value to focus in the popupClass widget when the textbox value is empty.
             *
             */
            "dropDownDefaultValue": Date;
            set(property:"dropDownDefaultValue", value: Date): void;
            get(property:"dropDownDefaultValue"): Date;
            watch(property:"dropDownDefaultValue", callback:{(property?:string, oldValue?:Date, newValue?: Date):void}) :{unwatch():void}
            /**
             * This variable controls the position of the drop down.
             * It's an array of strings with the following values:
             *
             * before: places drop down to the left of the target node/widget, or to the right in
             * the case of RTL scripts like Hebrew and Arabic
             * after: places drop down to the right of the target node/widget, or to the left in
             * the case of RTL scripts like Hebrew and Arabic
             * above: drop down goes above target node
             * below: drop down goes below target node
             * The list is positions is tried, in order, until a position is found where the drop down fits
             * within the viewport.
             *
             */
            "dropDownPosition": Object;
            set(property:"dropDownPosition", value: Object): void;
            get(property:"dropDownPosition"): Object;
            watch(property:"dropDownPosition", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * This widget or a widget it contains has focus, or is "active" because
             * it was recently clicked.
             *
             */
            "focused": boolean;
            set(property:"focused", value: boolean): void;
            get(property:"focused"): boolean;
            watch(property:"focused", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Set to true to make the drop down exactly as wide as this
             * widget.  Overrides autoWidth.
             *
             */
            "forceWidth": boolean;
            set(property:"forceWidth", value: boolean): void;
            get(property:"forceWidth"): boolean;
            watch(property:"forceWidth", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Set this textbox to display a down arrow button, to open the drop down list.
             *
             */
            "hasDownArrow": boolean;
            set(property:"hasDownArrow", value: boolean): void;
            get(property:"hasDownArrow"): boolean;
            watch(property:"hasDownArrow", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * True if cursor is over this widget
             *
             */
            "hovering": boolean;
            set(property:"hovering", value: boolean): void;
            get(property:"hovering"): boolean;
            watch(property:"hovering", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * A unique, opaque ID string that can be assigned by users or by the
             * system. If the developer passes an ID which is known not to be
             * unique, the specified ID is ignored and the system-generated ID is
             * used instead.
             *
             */
            "id": string;
            set(property:"id", value: string): void;
            get(property:"id"): string;
            watch(property:"id", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Fires onChange for each value change or only on demand
             *
             */
            "intermediateChanges": boolean;
            set(property:"intermediateChanges", value: boolean): void;
            get(property:"intermediateChanges"): boolean;
            watch(property:"intermediateChanges", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * The message to display if value is invalid.
             * The translated string value is read from the message file by default.
             * Set to "" to use the promptMessage instead.
             *
             */
            "invalidMessage": string;
            set(property:"invalidMessage", value: string): void;
            get(property:"invalidMessage"): string;
            watch(property:"invalidMessage", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Rarely used.  Overrides the default Dojo locale used to render this widget,
             * as defined by the HTML LANG attribute.
             * Value must be among the list of locales specified during by the Dojo bootstrap,
             * formatted according to RFC 3066 (like en-us).
             *
             */
            "lang": string;
            set(property:"lang", value: string): void;
            get(property:"lang"): string;
            watch(property:"lang", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Converts all characters to lowercase if true.  Default is false.
             *
             */
            "lowercase": boolean;
            set(property:"lowercase", value: boolean): void;
            get(property:"lowercase"): boolean;
            watch(property:"lowercase", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * The max height for our dropdown.
             * Any dropdown taller than this will have scrollbars.
             * Set to 0 for no max height, or -1 to limit height to available space in viewport
             *
             */
            "maxHeight": number;
            set(property:"maxHeight", value: number): void;
            get(property:"maxHeight"): number;
            watch(property:"maxHeight", callback:{(property?:string, oldValue?:number, newValue?: number):void}) :{unwatch():void}
            /**
             * HTML INPUT tag maxLength declaration.
             *
             */
            "maxLength": string;
            set(property:"maxLength", value: string): void;
            get(property:"maxLength"): string;
            watch(property:"maxLength", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Currently error/prompt message.
             * When using the default tooltip implementation, this will only be
             * displayed when the field is focused.
             *
             */
            "message": string;
            set(property:"message", value: string): void;
            get(property:"message"): string;
            watch(property:"message", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * The message to display if value is empty and the field is required.
             * The translated string value is read from the message file by default.
             * Set to "" to use the invalidMessage instead.
             *
             */
            "missingMessage": string;
            set(property:"missingMessage", value: string): void;
            get(property:"missingMessage"): string;
            watch(property:"missingMessage", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Name used when submitting form; same as "name" attribute or plain HTML elements
             *
             */
            "name": string;
            set(property:"name", value: string): void;
            get(property:"name"): string;
            watch(property:"name", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * The document this widget belongs to.  If not specified to constructor, will default to
             * srcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global
             *
             */
            "ownerDocument": Object;
            set(property:"ownerDocument", value: Object): void;
            get(property:"ownerDocument"): Object;
            watch(property:"ownerDocument", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Defines a hint to help users fill out the input field (as defined in HTML 5).
             * This should only contain plain text (no html markup).
             *
             */
            "placeHolder": string;
            set(property:"placeHolder", value: string): void;
            get(property:"placeHolder"): string;
            watch(property:"placeHolder", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * If defined, display this hint string immediately on focus to the textbox, if empty.
             * Also displays if the textbox value is Incomplete (not yet valid but will be with additional input).
             * Think of this like a tooltip that tells the user what to do, not an error message
             * that tells the user what they've done wrong.
             *
             * Message disappears when user starts typing.
             *
             */
            "promptMessage": string;
            set(property:"promptMessage", value: string): void;
            get(property:"promptMessage"): string;
            watch(property:"promptMessage", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Converts the first character of each word to uppercase if true.
             *
             */
            "propercase": boolean;
            set(property:"propercase", value: boolean): void;
            get(property:"propercase"): boolean;
            watch(property:"propercase", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * The message to display if value is out-of-range
             *
             */
            "rangeMessage": string;
            set(property:"rangeMessage", value: string): void;
            get(property:"rangeMessage"): string;
            watch(property:"rangeMessage", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Should this widget respond to user input?
             * In markup, this is specified as "readOnly".
             * Similar to disabled except readOnly form values are submitted.
             *
             */
            "readOnly": boolean;
            set(property:"readOnly", value: boolean): void;
            get(property:"readOnly"): boolean;
            watch(property:"readOnly", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             *
             */
            "regExp": string;
            set(property:"regExp", value: string): void;
            get(property:"regExp"): string;
            watch(property:"regExp", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * User is required to enter data into this field.
             *
             */
            "required": boolean;
            set(property:"required", value: boolean): void;
            get(property:"required"): boolean;
            watch(property:"required", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * On focus, should this widget scroll into view?
             *
             */
            "scrollOnFocus": boolean;
            set(property:"scrollOnFocus", value: boolean): void;
            get(property:"scrollOnFocus"): boolean;
            watch(property:"scrollOnFocus", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             *
             */
            "searchContainerNode": boolean;
            set(property:"searchContainerNode", value: boolean): void;
            get(property:"searchContainerNode"): boolean;
            watch(property:"searchContainerNode", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * If true, all text will be selected when focused with mouse
             *
             */
            "selectOnClick": boolean;
            set(property:"selectOnClick", value: boolean): void;
            get(property:"selectOnClick"): boolean;
            watch(property:"selectOnClick", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * pointer to original DOM node
             *
             */
            "srcNodeRef": HTMLElement;
            set(property:"srcNodeRef", value: HTMLElement): void;
            get(property:"srcNodeRef"): HTMLElement;
            watch(property:"srcNodeRef", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * Shows current state (ie, validation result) of input (""=Normal, Incomplete, or Error)
             *
             */
            "state": string;
            set(property:"state", value: string): void;
            get(property:"state"): string;
            watch(property:"state", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * HTML style attributes as cssText string or name/value hash
             *
             */
            "style": string;
            set(property:"style", value: string): void;
            get(property:"style"): string;
            watch(property:"style", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Order fields are traversed when user hits the tab key
             *
             */
            "tabIndex": string;
            set(property:"tabIndex", value: string): void;
            get(property:"tabIndex"): string;
            watch(property:"tabIndex", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Path to template (HTML file) for this widget relative to dojo.baseUrl.
             * Deprecated: use templateString with require([... "dojo/text!..."], ...) instead
             *
             */
            "templatePath": string;
            set(property:"templatePath", value: string): void;
            get(property:"templatePath"): string;
            watch(property:"templatePath", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "templateString": string;
            set(property:"templateString", value: string): void;
            get(property:"templateString"): string;
            watch(property:"templateString", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * HTML title attribute.
             *
             * For form widgets this specifies a tooltip to display when hovering over
             * the widget (just like the native HTML title attribute).
             *
             * For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,
             * etc., it's used to specify the tab label, accordion pane title, etc.  In this case it's
             * interpreted as HTML.
             *
             */
            "title": string;
            set(property:"title", value: string): void;
            get(property:"title"): string;
            watch(property:"title", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * When this widget's title attribute is used to for a tab label, accordion pane title, etc.,
             * this specifies the tooltip to appear when the mouse is hovered over that text.
             *
             */
            "tooltip": string;
            set(property:"tooltip", value: string): void;
            get(property:"tooltip"): string;
            watch(property:"tooltip", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * See description of dijit/Tooltip.defaultPosition for details on this parameter.
             *
             */
            "tooltipPosition": Object;
            set(property:"tooltipPosition", value: Object): void;
            get(property:"tooltipPosition"): Object;
            watch(property:"tooltipPosition", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Removes leading and trailing whitespace if true.  Default is false.
             *
             */
            "trim": boolean;
            set(property:"trim", value: boolean): void;
            get(property:"trim"): boolean;
            watch(property:"trim", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "type": string;
            set(property:"type", value: string): void;
            get(property:"type"): string;
            watch(property:"type", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Converts all characters to uppercase if true.  Default is false.
             *
             */
            "uppercase": boolean;
            set(property:"uppercase", value: boolean): void;
            get(property:"uppercase"): boolean;
            watch(property:"uppercase", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * The value of this widget as a JavaScript Date object.  Use get("value") / set("value", val) to manipulate.
             * When passed to the parser in markup, must be specified according to dojo/date/stamp.fromISOString()
             *
             */
            "value": Date;
            set(property:"value", value: Date): void;
            get(property:"value"): Date;
            watch(property:"value", callback:{(property?:string, oldValue?:Date, newValue?: Date):void}) :{unwatch():void}
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: String, value: Object): any;
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: Object, value: Object): any;
            /**
             *
             */
            buildRendering(): void;
            /**
             * Closes the drop down on this widget
             *
             * @param focus If true, refocuses the button widget
             */
            closeDropDown(focus: boolean): void;
            /**
             *
             * @param val1
             * @param val2
             */
            compare(val1: Date, val2: Date): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: Function): any;
            /**
             * Wrapper to setTimeout to avoid deferred functions executing
             * after the originating widget has been destroyed.
             * Returns an object handle with a remove method (that returns null) (replaces clearTimeout).
             *
             * @param fcn Function reference.
             * @param delay               OptionalDelay, defaults to 0.
             */
            defer(fcn: Function, delay: number): Object;
            /**
             * Destroy this widget, but not its descendants.  Descendants means widgets inside of
             * this.containerNode.   Will also destroy any resources (including widgets) registered via this.own().
             *
             * This method will also destroy internal widgets such as those created from a template,
             * assuming those widgets exist inside of this.domNode but outside of this.containerNode.
             *
             * For 2.0 it's planned that this method will also destroy descendant widgets, so apps should not
             * depend on the current ability to destroy a widget without destroying its descendants.   Generally
             * they should use destroyRecursive() for widgets with children.
             *
             * @param preserveDom If true, this method will leave the original DOM structure alone.Note: This will not yet work with _TemplatedMixin widgets
             */
            destroy(preserveDom?: boolean): void;
            /**
             * Recursively destroy the children of this widget and their
             * descendants.
             *
             * @param preserveDom               OptionalIf true, the preserveDom attribute is passed to all descendantwidget's .destroy() method. Not for use with _Templatedwidgets.
             */
            destroyDescendants(preserveDom: boolean): void;
            /**
             * Destroy this widget and its descendants
             * This is the generic "destructor" function that all widget users
             * should call to cleanly discard with a widget. Once a widget is
             * destroyed, it is removed from the manager object.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structurealone of descendant Widgets. Note: This will NOT work withdijit._TemplatedMixin widgets.
             */
            destroyRecursive(preserveDom: boolean): void;
            /**
             * Destroys the DOM nodes associated with this widget.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structure aloneduring tear-down. Note: this will not work with _Templatedwidgets yet.
             */
            destroyRendering(preserveDom?: boolean): void;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Disconnects handle created by connect.
             *
             * @param handle
             */
            disconnect(handle: any): void;
            /**
             * Overridable method to display validation errors/hints.
             * By default uses a tooltip.
             *
             * @param message
             */
            displayMessage(message: String): void;
            /**
             * Used by widgets to signal that a synthetic event occurred, ex:
             *
             * myWidget.emit("attrmodified-selectedChildWidget", {}).
             * Emits an event on this.domNode named type.toLowerCase(), based on eventObj.
             * Also calls onType() method, if present, and returns value from that method.
             * By default passes eventObj to callback, but will pass callbackArgs instead, if specified.
             * Modifies eventObj by adding missing parameters (bubbles, cancelable, widget).
             *
             * @param type
             * @param eventObj               Optional
             * @param callbackArgs               Optional
             */
            emit(type: String, eventObj: Object, callbackArgs: any[]): any;
            /**
             * Auto-corrections (such as trimming) that are applied to textbox
             * value on blur or form submit.
             * For MappedTextBox subclasses, this is called twice
             *
             * once with the display value
             * once the value as set/returned by set('value', ...)
             * and get('value'), ex: a Number for NumberTextBox.
             *
             * In the latter case it does corrections like converting null to NaN.  In
             * the former case the NumberTextBox.filter() method calls this.inherited()
             * to execute standard trimming code in TextBox.filter().
             *
             * TODO: break this into two methods in 2.0
             *
             * @param val
             */
            filter(val: any): any;
            /**
             * Put focus on this widget
             *
             */
            focus(): void;
            /**
             * Formats the value as a Date, according to specified locale (second argument)
             *
             * @param value
             * @param constraints An object with the following properties:selector (String): choice of 'time','date' (default: date and time)formatLength (String): choice of long, short, medium or full (plus any custom additions).  Defaults to 'short'datePattern (String): override pattern with this stringtimePattern (String): override pattern with this stringam (String): override strings for am in timespm (String): override strings for pm in timeslocale (String): override the locale used to determine formatting rulesfullYear (Boolean): (format only) use 4 digit years whenever 2 digit years are called forstrict (Boolean): (parse only) strict parsing, off by default
             */
            format(value: Date, constraints: Object): any;
            /**
             * Get a property from a widget.
             * Get a named property from a widget. The property may
             * potentially be retrieved via a getter method. If no getter is defined, this
             * just retrieves the object's property.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _getFooAttr(), calling:
             * myWidget.get("foo") would be equivalent to calling
             * widget._getFooAttr() and myWidget.get("bar")
             * would be equivalent to the expression
             * widget.bar2
             *
             * @param name The property to get.
             */
            get(name: any): any;
            /**
             * Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent
             * is this widget.   Note that it does not return all descendants, but rather just direct children.
             * Analogous to Node.childNodes,
             * except containing widgets rather than DOMNodes.
             *
             * The result intentionally excludes internally created widgets (a.k.a. supporting widgets)
             * outside of this.containerNode.
             *
             * Note that the array returned is a simple array.  Application code should not assume
             * existence of methods like forEach().
             *
             */
            getChildren(): any[];
            /**
             * Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
             * This method should generally be avoided as it returns widgets declared in templates, which are
             * supposed to be internal/hidden, but it's left here for back-compat reasons.
             *
             */
            getDescendants(): any[];
            /**
             * Deprecated.  Use get('displayedValue') instead.
             *
             */
            getDisplayedValue(): any;
            /**
             *
             * @param isFocused
             */
            getErrorMessage(isFocused: boolean): any;
            /**
             * Returns the parent widget of this widget.
             *
             */
            getParent(): any;
            /**
             * Return a hint message to show when widget is first focused
             *
             * @param isFocused
             */
            getPromptMessage(isFocused: boolean): any;
            /**
             * Deprecated.  Use get('value') instead.
             *
             */
            getValue(): any;
            /**
             * Return true if this widget can currently be focused
             * and false if not
             *
             */
            isFocusable(): any;
            /**
             * Tests if the value is in the min/max range specified in constraints
             *
             * @param isFocused
             */
            isInRange(isFocused: boolean): any;
            /**
             * Return this widget's explicit or implicit orientation (true for LTR, false for RTL)
             *
             */
            isLeftToRight(): any;
            /**
             * Returns true if the dropdown exists and it's data is loaded.  This can
             * be overridden in order to force a call to loadDropDown().
             *
             */
            isLoaded(): boolean;
            /**
             *
             * @param isFocused
             */
            isValid: { (isFocused: boolean): any };
            /**
             * Creates the drop down if it doesn't exist, loads the data
             * if there's an href and it hasn't been loaded yet, and
             * then opens the drop down.  This is basically a callback when the
             * user presses the down arrow button to open the drop down.
             *
             */
            loadAndOpenDropDown(): any;
            /**
             * Creates the drop down if it doesn't exist, loads the data
             * if there's an href and it hasn't been loaded yet, and then calls
             * the given callback.
             *
             * @param loadCallback
             */
            loadDropDown(loadCallback: Function): void;
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: String, func: Function): any;
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: Function, func: Function): any;
            /**
             *
             */
            openDropDown(): void;
            /**
             * Track specified handles and remove/destroy them when this instance is destroyed, unless they were
             * already removed/destroyed manually.
             *
             */
            own(): any;
            /**
             * Parses as string as a Date, according to constraints
             *
             * @param value
             * @param constraints An object with the following properties:selector (String): choice of 'time','date' (default: date and time)formatLength (String): choice of long, short, medium or full (plus any custom additions).  Defaults to 'short'datePattern (String): override pattern with this stringtimePattern (String): override pattern with this stringam (String): override strings for am in timespm (String): override strings for pm in timeslocale (String): override the locale used to determine formatting rulesfullYear (Boolean): (format only) use 4 digit years whenever 2 digit years are called forstrict (Boolean): (parse only) strict parsing, off by default
             */
            parse(value: String, constraints: Object): any;
            /**
             * Builds the regular needed to parse a localized date
             *
             * @param options               OptionalAn object with the following properties:selector (String): choice of 'time','date' (default: date and time)formatLength (String): choice of long, short, medium or full (plus any custom additions).  Defaults to 'short'datePattern (String): override pattern with this stringtimePattern (String): override pattern with this stringam (String): override strings for am in timespm (String): override strings for pm in timeslocale (String): override the locale used to determine formatting rulesfullYear (Boolean): (format only) use 4 digit years whenever 2 digit years are called forstrict (Boolean): (parse only) strict parsing, off by default
             */
            pattern: { (options: Object): any };
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: number): any;
            /**
             * The popup widget to use. In this case, a calendar with Day, Month and Year views.
             *
             */
            popupClass: { (): void };
            /**
             *
             */
            postCreate(): void;
            /**
             *
             */
            postMixInProperties(): void;
            /**
             * Overridable function used to validate the range of the numeric input value.
             *
             * @param primitive
             * @param constraints
             */
            rangeCheck(primitive: number, constraints: dijit.form.RangeBoundTextBox.__Constraints): boolean;
            /**
             * Deprecated.  Use set('pattern', Function) instead.
             *
             * @param constraints An object with the following properties:locale (String): locale used for validation, picks up value from this widget's lang attribute_flags_ (anything): various flags passed to pattern function
             */
            regExpGen(constraints: Object): void;
            /**
             *
             */
            reset(): void;
            /**
             *
             * @param val
             * @param options               Optional
             */
            serialize(val: any, options: Object): any;
            /**
             * Set a property on a widget
             * Sets named properties on a widget which may potentially be handled by a
             * setter in the widget.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _setFooAttr(), calling
             * myWidget.set("foo", "Howdy!") would be equivalent to calling
             * widget._setFooAttr("Howdy!") and myWidget.set("bar", 3)
             * would be equivalent to the statement widget.bar = 3;
             *
             * set() may also be called with a hash of name/value pairs, ex:
             *
             * myWidget.set({
             *     foo: "Howdy",
             *     bar: 3
             * });
             * This is equivalent to calling set(foo, "Howdy") and set(bar, 3)
             *
             * @param name The property to set.
             * @param value The value to set in the property.
             */
            set(name: any, value: any): any;
            /**
             * Deprecated.  Use set() instead.
             *
             * @param attr
             * @param value
             */
            setAttribute(attr: String, value: any): void;
            /**
             * Deprecated.  Use set('disabled', ...) instead.
             *
             * @param disabled
             */
            setDisabled(disabled: boolean): void;
            /**
             * Deprecated.  Use set('displayedValue', ...) instead.
             *
             * @param value
             */
            setDisplayedValue(value: String): void;
            /**
             * Deprecated.  Use set('value', ...) instead.
             *
             * @param value
             */
            setValue(value: String): void;
            /**
             *
             */
            startup(): void;
            /**
             * Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.
             *
             * Subscribes to the specified topic and calls the specified method
             * of this object and registers for unsubscribe() on widget destroy.
             *
             * Provide widget-specific analog to dojo.subscribe, except with the
             * implicit use of this widget as the target object.
             *
             * @param t The topic
             * @param method The callback
             */
            subscribe(t: String, method: Function): any;
            /**
             * Callback when the user presses the down arrow button or presses
             * the down arrow key to open/close the drop down.
             * Toggle the drop-down widget; if it is up, close it, if not, open it
             *
             */
            toggleDropDown(): void;
            /**
             * Returns widget as a printable string using the widget's value
             *
             */
            toString(): string;
            /**
             * Restore the value to the last value passed to onChange
             *
             */
            undo(): void;
            /**
             * Deprecated. Override destroy() instead to implement custom widget tear-down
             * behavior.
             *
             */
            uninitialize(): boolean;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Unsubscribes handle created by this.subscribe.
             * Also removes handle from this widget's list of subscriptions
             *
             * @param handle
             */
            unsubscribe(handle: Object): void;
            /**
             *
             */
            validate(): any;
            /**
             * Overridable function used to validate the text input against the regular expression.
             *
             * @param value
             * @param constraints An object with the following properties:locale (String): locale used for validation, picks up value from this widget's lang attribute_flags_ (anything): various flags passed to pattern function
             */
            validator(value: any, constraints: Object): any;
            /**
             * Watches a property for changes
             *
             * @param name               OptionalIndicates the property to watch. This is optional (the callback may be theonly parameter), and if omitted, all the properties will be watched
             * @param callback The function to execute when the property changes. This will be called afterthe property has been changed. The callback will be called with the |this|set to the instance, the first argument as the name of the property, thesecond argument as the old value and the third argument as the new value.
             */
            watch(property: string, callback:{(property?:string, oldValue?:any, newValue?: any):void}) :{unwatch():void};
            /**
             * Static method to get a template based on the templatePath or
             * templateString key
             */
            getCachedTemplate(): any;
            /**
             * Called when the widget stops being "active" because
             * focus moved to something outside of it, or the user
             * clicked somewhere outside of it, or the widget was
             * hidden.
             *
             */
            onBlur(): void;
            /**
             * Callback when this widget's value is changed.
             *
             * @param newValue
             */
            onChange(newValue: any): void;
            /**
             * Connect to this function to receive notifications of mouse click events.
             *
             * @param event mouse Event
             */
            onClick(event: any): void;
            /**
             * Called when this widget is being displayed as a popup (ex: a Calendar popped
             * up from a DateTextBox), and it is hidden.
             * This is called from the dijit.popup code, and should not be called directly.
             *
             * Also used as a parameter for children of dijit/layout/StackContainer or subclasses.
             * Callback if a user tries to close the child.   Child will be closed if this function returns true.
             *
             */
            onClose(): boolean;
            /**
             * Connect to this function to receive notifications of mouse double click events.
             *
             * @param event mouse Event
             */
            onDblClick(event: any): void;
            /**
             * Called when the widget becomes "active" because
             * it or a widget inside of it either has focus, or has recently
             * been clicked.
             *
             */
            onFocus(): void;
            /**
             * Called when another widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate hide of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onHide(): void;
            /**
             * Connect to this function to receive notifications of various user data-input events.
             * Return false to cancel the event and prevent it from being processed.
             *
             * @param event keydown | keypress | cut | paste | input
             */
            onInput(event: any): void;
            /**
             * Connect to this function to receive notifications of keys being pressed down.
             *
             * @param event key Event
             */
            onKeyDown(event: any): void;
            /**
             * Connect to this function to receive notifications of printable keys being typed.
             *
             * @param event key Event
             */
            onKeyPress(event: any): void;
            /**
             * Connect to this function to receive notifications of keys being released.
             *
             * @param event key Event
             */
            onKeyUp(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is pressed down.
             *
             * @param event mouse Event
             */
            onMouseDown(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto this widget.
             *
             * @param event mouse Event
             */
            onMouseEnter(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of this widget.
             *
             * @param event mouse Event
             */
            onMouseLeave(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseMove(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOut(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOver(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is released.
             *
             * @param event mouse Event
             */
            onMouseUp(event: any): void;
            /**
             * Called when this widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate display of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onShow(): void;
        }
        /**
         * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/DayTextBox.html
         *
         * A validating, serializable, range-bound date text box with a popup calendar that contains just months.
         *
         * @param params Hash of initialization parameters for widget, including scalar values (like title, duration etc.)and functions, typically callbacks like onClick.The hash can contain any of the widget's properties, excluding read-only properties.
         * @param srcNodeRef       OptionalIf a srcNodeRef (DOM node) is specified, replace srcNodeRef with my generated DOM tree
         */
        class DayTextBox extends dojox.form.DateTextBox {
            constructor(params?: Object, srcNodeRef?: HTMLElement);
            /**
             * True if mouse was pressed while over this widget, and hasn't been released yet
             *
             */
            "active": boolean;
            set(property:"active", value: boolean): void;
            get(property:"active"): boolean;
            watch(property:"active", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "alt": string;
            set(property:"alt", value: string): void;
            get(property:"alt"): string;
            watch(property:"alt", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "aria-label": string;
            set(property:"aria-label", value: string): void;
            get(property:"aria-label"): string;
            watch(property:"aria-label", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Object to which attach points and events will be scoped.  Defaults
             * to 'this'.
             *
             */
            "attachScope": Object;
            set(property:"attachScope", value: Object): void;
            get(property:"attachScope"): Object;
            watch(property:"attachScope", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute
             * for each XXX attribute to be mapped to the DOM.
             *
             * attributeMap sets up a "binding" between attributes (aka properties)
             * of the widget and the widget's DOM.
             * Changes to widget attributes listed in attributeMap will be
             * reflected into the DOM.
             *
             * For example, calling set('title', 'hello')
             * on a TitlePane will automatically cause the TitlePane's DOM to update
             * with the new title.
             *
             * attributeMap is a hash where the key is an attribute of the widget,
             * and the value reflects a binding to a:
             *
             * DOM node attribute
             *   focus: {node: "focusNode", type: "attribute"}
             * Maps this.focus to this.focusNode.focus
             *
             * DOM node innerHTML
             *   title: { node: "titleNode", type: "innerHTML" }
             * Maps this.title to this.titleNode.innerHTML
             *
             * DOM node innerText
             *   title: { node: "titleNode", type: "innerText" }
             * Maps this.title to this.titleNode.innerText
             *
             * DOM node CSS class
             *   myClass: { node: "domNode", type: "class" }
             * Maps this.myClass to this.domNode.className
             *
             * If the value is an array, then each element in the array matches one of the
             * formats of the above list.
             *
             * There are also some shorthands for backwards compatibility:
             *
             * string --> { node: string, type: "attribute" }, for example:
             * "focusNode" ---> { node: "focusNode", type: "attribute" }
             * "" --> { node: "domNode", type: "attribute" }
             *
             */
            "attributeMap": Object;
            set(property:"attributeMap", value: Object): void;
            get(property:"attributeMap"): Object;
            watch(property:"attributeMap", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             *
             */
            "autoWidth": boolean;
            set(property:"autoWidth", value: boolean): void;
            get(property:"autoWidth"): boolean;
            watch(property:"autoWidth", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             *
             */
            "baseClass": string;
            set(property:"baseClass", value: string): void;
            get(property:"baseClass"): string;
            watch(property:"baseClass", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "class": string;
            set(property:"class", value: string): void;
            get(property:"class"): string;
            watch(property:"class", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Despite the name, this parameter specifies both constraints on the input
             * (including starting/ending dates/times allowed) as well as
             * formatting options like whether the date is displayed in long (ex: December 25, 2005)
             * or short (ex: 12/25/2005) format.  See dijit/form/_DateTimeTextBox.__Constraints for details.
             *
             */
            "constraints": Object;
            set(property:"constraints", value: Object): void;
            get(property:"constraints"): Object;
            watch(property:"constraints", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Designates where children of the source DOM node will be placed.
             * "Children" in this case refers to both DOM nodes and widgets.
             * For example, for myWidget:
             *
             * <div data-dojo-type=myWidget>
             *     <b> here's a plain DOM node
             *     <span data-dojo-type=subWidget>and a widget</span>
             *     <i> and another plain DOM node </i>
             * </div>
             * containerNode would point to:
             *
             * <b> here's a plain DOM node
             * <span data-dojo-type=subWidget>and a widget</span>
             * <i> and another plain DOM node </i>
             * In templated widgets, "containerNode" is set via a
             * data-dojo-attach-point assignment.
             *
             * containerNode must be defined for any widget that accepts innerHTML
             * (like ContentPane or BorderContainer or even Button), and conversely
             * is null for widgets that don't, like TextBox.
             *
             */
            "containerNode": HTMLElement;
            set(property:"containerNode", value: HTMLElement): void;
            get(property:"containerNode"): HTMLElement;
            watch(property:"containerNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             *
             */
            "cssStateNodes": Object;
            set(property:"cssStateNodes", value: Object): void;
            get(property:"cssStateNodes"): Object;
            watch(property:"cssStateNodes", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * JavaScript namespace to find calendar routines.  If unspecified, uses Gregorian calendar routines
             * at dojo/date and dojo/date/locale.
             *
             */
            "datePackage": string;
            set(property:"datePackage", value: string): void;
            get(property:"datePackage"): string;
            watch(property:"datePackage", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Bi-directional support, as defined by the HTML DIR
             * attribute. Either left-to-right "ltr" or right-to-left "rtl".  If undefined, widgets renders in page's
             * default direction.
             *
             */
            "dir": string;
            set(property:"dir", value: string): void;
            get(property:"dir"): string;
            watch(property:"dir", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Should this widget respond to user input?
             * In markup, this is specified as "disabled='disabled'", or just "disabled".
             *
             */
            "disabled": boolean;
            set(property:"disabled", value: boolean): void;
            get(property:"disabled"): boolean;
            watch(property:"disabled", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * For subclasses like ComboBox where the displayed value
             * (ex: Kentucky) and the serialized value (ex: KY) are different,
             * this represents the displayed value.
             *
             * Setting 'displayedValue' through set('displayedValue', ...)
             * updates 'value', and vice-versa.  Otherwise 'value' is updated
             * from 'displayedValue' periodically, like onBlur etc.
             *
             * TODO: move declaration to MappedTextBox?
             * Problem is that ComboBox references displayedValue,
             * for benefit of FilteringSelect.
             *
             */
            "displayedValue": string;
            set(property:"displayedValue", value: string): void;
            get(property:"displayedValue"): string;
            watch(property:"displayedValue", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * This is our visible representation of the widget! Other DOM
             * Nodes may by assigned to other properties, usually through the
             * template system's data-dojo-attach-point syntax, but the domNode
             * property is the canonical "top level" node in widget UI.
             *
             */
            "domNode": HTMLElement;
            set(property:"domNode", value: HTMLElement): void;
            get(property:"domNode"): HTMLElement;
            watch(property:"domNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * The widget to display as a popup.  This widget must be
             * defined before the startup function is called.
             *
             */
            "dropDown": Object;
            set(property:"dropDown", value: Object): void;
            get(property:"dropDown"): Object;
            watch(property:"dropDown", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * The default value to focus in the popupClass widget when the textbox value is empty.
             *
             */
            "dropDownDefaultValue": Date;
            set(property:"dropDownDefaultValue", value: Date): void;
            get(property:"dropDownDefaultValue"): Date;
            watch(property:"dropDownDefaultValue", callback:{(property?:string, oldValue?:Date, newValue?: Date):void}) :{unwatch():void}
            /**
             * This variable controls the position of the drop down.
             * It's an array of strings with the following values:
             *
             * before: places drop down to the left of the target node/widget, or to the right in
             * the case of RTL scripts like Hebrew and Arabic
             * after: places drop down to the right of the target node/widget, or to the left in
             * the case of RTL scripts like Hebrew and Arabic
             * above: drop down goes above target node
             * below: drop down goes below target node
             * The list is positions is tried, in order, until a position is found where the drop down fits
             * within the viewport.
             *
             */
            "dropDownPosition": Object;
            set(property:"dropDownPosition", value: Object): void;
            get(property:"dropDownPosition"): Object;
            watch(property:"dropDownPosition", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * This widget or a widget it contains has focus, or is "active" because
             * it was recently clicked.
             *
             */
            "focused": boolean;
            set(property:"focused", value: boolean): void;
            get(property:"focused"): boolean;
            watch(property:"focused", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Set to true to make the drop down exactly as wide as this
             * widget.  Overrides autoWidth.
             *
             */
            "forceWidth": boolean;
            set(property:"forceWidth", value: boolean): void;
            get(property:"forceWidth"): boolean;
            watch(property:"forceWidth", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Set this textbox to display a down arrow button, to open the drop down list.
             *
             */
            "hasDownArrow": boolean;
            set(property:"hasDownArrow", value: boolean): void;
            get(property:"hasDownArrow"): boolean;
            watch(property:"hasDownArrow", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * True if cursor is over this widget
             *
             */
            "hovering": boolean;
            set(property:"hovering", value: boolean): void;
            get(property:"hovering"): boolean;
            watch(property:"hovering", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * A unique, opaque ID string that can be assigned by users or by the
             * system. If the developer passes an ID which is known not to be
             * unique, the specified ID is ignored and the system-generated ID is
             * used instead.
             *
             */
            "id": string;
            set(property:"id", value: string): void;
            get(property:"id"): string;
            watch(property:"id", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Fires onChange for each value change or only on demand
             *
             */
            "intermediateChanges": boolean;
            set(property:"intermediateChanges", value: boolean): void;
            get(property:"intermediateChanges"): boolean;
            watch(property:"intermediateChanges", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * The message to display if value is invalid.
             * The translated string value is read from the message file by default.
             * Set to "" to use the promptMessage instead.
             *
             */
            "invalidMessage": string;
            set(property:"invalidMessage", value: string): void;
            get(property:"invalidMessage"): string;
            watch(property:"invalidMessage", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Rarely used.  Overrides the default Dojo locale used to render this widget,
             * as defined by the HTML LANG attribute.
             * Value must be among the list of locales specified during by the Dojo bootstrap,
             * formatted according to RFC 3066 (like en-us).
             *
             */
            "lang": string;
            set(property:"lang", value: string): void;
            get(property:"lang"): string;
            watch(property:"lang", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Converts all characters to lowercase if true.  Default is false.
             *
             */
            "lowercase": boolean;
            set(property:"lowercase", value: boolean): void;
            get(property:"lowercase"): boolean;
            watch(property:"lowercase", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * The max height for our dropdown.
             * Any dropdown taller than this will have scrollbars.
             * Set to 0 for no max height, or -1 to limit height to available space in viewport
             *
             */
            "maxHeight": number;
            set(property:"maxHeight", value: number): void;
            get(property:"maxHeight"): number;
            watch(property:"maxHeight", callback:{(property?:string, oldValue?:number, newValue?: number):void}) :{unwatch():void}
            /**
             * HTML INPUT tag maxLength declaration.
             *
             */
            "maxLength": string;
            set(property:"maxLength", value: string): void;
            get(property:"maxLength"): string;
            watch(property:"maxLength", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Currently error/prompt message.
             * When using the default tooltip implementation, this will only be
             * displayed when the field is focused.
             *
             */
            "message": string;
            set(property:"message", value: string): void;
            get(property:"message"): string;
            watch(property:"message", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * The message to display if value is empty and the field is required.
             * The translated string value is read from the message file by default.
             * Set to "" to use the invalidMessage instead.
             *
             */
            "missingMessage": string;
            set(property:"missingMessage", value: string): void;
            get(property:"missingMessage"): string;
            watch(property:"missingMessage", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Name used when submitting form; same as "name" attribute or plain HTML elements
             *
             */
            "name": string;
            set(property:"name", value: string): void;
            get(property:"name"): string;
            watch(property:"name", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * The document this widget belongs to.  If not specified to constructor, will default to
             * srcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global
             *
             */
            "ownerDocument": Object;
            set(property:"ownerDocument", value: Object): void;
            get(property:"ownerDocument"): Object;
            watch(property:"ownerDocument", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Defines a hint to help users fill out the input field (as defined in HTML 5).
             * This should only contain plain text (no html markup).
             *
             */
            "placeHolder": string;
            set(property:"placeHolder", value: string): void;
            get(property:"placeHolder"): string;
            watch(property:"placeHolder", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * If defined, display this hint string immediately on focus to the textbox, if empty.
             * Also displays if the textbox value is Incomplete (not yet valid but will be with additional input).
             * Think of this like a tooltip that tells the user what to do, not an error message
             * that tells the user what they've done wrong.
             *
             * Message disappears when user starts typing.
             *
             */
            "promptMessage": string;
            set(property:"promptMessage", value: string): void;
            get(property:"promptMessage"): string;
            watch(property:"promptMessage", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Converts the first character of each word to uppercase if true.
             *
             */
            "propercase": boolean;
            set(property:"propercase", value: boolean): void;
            get(property:"propercase"): boolean;
            watch(property:"propercase", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * The message to display if value is out-of-range
             *
             */
            "rangeMessage": string;
            set(property:"rangeMessage", value: string): void;
            get(property:"rangeMessage"): string;
            watch(property:"rangeMessage", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Should this widget respond to user input?
             * In markup, this is specified as "readOnly".
             * Similar to disabled except readOnly form values are submitted.
             *
             */
            "readOnly": boolean;
            set(property:"readOnly", value: boolean): void;
            get(property:"readOnly"): boolean;
            watch(property:"readOnly", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             *
             */
            "regExp": string;
            set(property:"regExp", value: string): void;
            get(property:"regExp"): string;
            watch(property:"regExp", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * User is required to enter data into this field.
             *
             */
            "required": boolean;
            set(property:"required", value: boolean): void;
            get(property:"required"): boolean;
            watch(property:"required", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * On focus, should this widget scroll into view?
             *
             */
            "scrollOnFocus": boolean;
            set(property:"scrollOnFocus", value: boolean): void;
            get(property:"scrollOnFocus"): boolean;
            watch(property:"scrollOnFocus", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             *
             */
            "searchContainerNode": boolean;
            set(property:"searchContainerNode", value: boolean): void;
            get(property:"searchContainerNode"): boolean;
            watch(property:"searchContainerNode", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * If true, all text will be selected when focused with mouse
             *
             */
            "selectOnClick": boolean;
            set(property:"selectOnClick", value: boolean): void;
            get(property:"selectOnClick"): boolean;
            watch(property:"selectOnClick", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * pointer to original DOM node
             *
             */
            "srcNodeRef": HTMLElement;
            set(property:"srcNodeRef", value: HTMLElement): void;
            get(property:"srcNodeRef"): HTMLElement;
            watch(property:"srcNodeRef", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * Shows current state (ie, validation result) of input (""=Normal, Incomplete, or Error)
             *
             */
            "state": string;
            set(property:"state", value: string): void;
            get(property:"state"): string;
            watch(property:"state", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * HTML style attributes as cssText string or name/value hash
             *
             */
            "style": string;
            set(property:"style", value: string): void;
            get(property:"style"): string;
            watch(property:"style", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Order fields are traversed when user hits the tab key
             *
             */
            "tabIndex": string;
            set(property:"tabIndex", value: string): void;
            get(property:"tabIndex"): string;
            watch(property:"tabIndex", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Path to template (HTML file) for this widget relative to dojo.baseUrl.
             * Deprecated: use templateString with require([... "dojo/text!..."], ...) instead
             *
             */
            "templatePath": string;
            set(property:"templatePath", value: string): void;
            get(property:"templatePath"): string;
            watch(property:"templatePath", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "templateString": string;
            set(property:"templateString", value: string): void;
            get(property:"templateString"): string;
            watch(property:"templateString", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * HTML title attribute.
             *
             * For form widgets this specifies a tooltip to display when hovering over
             * the widget (just like the native HTML title attribute).
             *
             * For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,
             * etc., it's used to specify the tab label, accordion pane title, etc.  In this case it's
             * interpreted as HTML.
             *
             */
            "title": string;
            set(property:"title", value: string): void;
            get(property:"title"): string;
            watch(property:"title", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * When this widget's title attribute is used to for a tab label, accordion pane title, etc.,
             * this specifies the tooltip to appear when the mouse is hovered over that text.
             *
             */
            "tooltip": string;
            set(property:"tooltip", value: string): void;
            get(property:"tooltip"): string;
            watch(property:"tooltip", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * See description of dijit/Tooltip.defaultPosition for details on this parameter.
             *
             */
            "tooltipPosition": Object;
            set(property:"tooltipPosition", value: Object): void;
            get(property:"tooltipPosition"): Object;
            watch(property:"tooltipPosition", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Removes leading and trailing whitespace if true.  Default is false.
             *
             */
            "trim": boolean;
            set(property:"trim", value: boolean): void;
            get(property:"trim"): boolean;
            watch(property:"trim", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "type": string;
            set(property:"type", value: string): void;
            get(property:"type"): string;
            watch(property:"type", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Converts all characters to uppercase if true.  Default is false.
             *
             */
            "uppercase": boolean;
            set(property:"uppercase", value: boolean): void;
            get(property:"uppercase"): boolean;
            watch(property:"uppercase", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * The value of this widget as a JavaScript Date object.  Use get("value") / set("value", val) to manipulate.
             * When passed to the parser in markup, must be specified according to dojo/date/stamp.fromISOString()
             *
             */
            "value": Date;
            set(property:"value", value: Date): void;
            get(property:"value"): Date;
            watch(property:"value", callback:{(property?:string, oldValue?:Date, newValue?: Date):void}) :{unwatch():void}
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: String, value: Object): any;
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: Object, value: Object): any;
            /**
             *
             */
            buildRendering(): void;
            /**
             * Closes the drop down on this widget
             *
             * @param focus If true, refocuses the button widget
             */
            closeDropDown(focus: boolean): void;
            /**
             *
             * @param val1
             * @param val2
             */
            compare(val1: Date, val2: Date): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: Function): any;
            /**
             * Wrapper to setTimeout to avoid deferred functions executing
             * after the originating widget has been destroyed.
             * Returns an object handle with a remove method (that returns null) (replaces clearTimeout).
             *
             * @param fcn Function reference.
             * @param delay               OptionalDelay, defaults to 0.
             */
            defer(fcn: Function, delay: number): Object;
            /**
             * Destroy this widget, but not its descendants.  Descendants means widgets inside of
             * this.containerNode.   Will also destroy any resources (including widgets) registered via this.own().
             *
             * This method will also destroy internal widgets such as those created from a template,
             * assuming those widgets exist inside of this.domNode but outside of this.containerNode.
             *
             * For 2.0 it's planned that this method will also destroy descendant widgets, so apps should not
             * depend on the current ability to destroy a widget without destroying its descendants.   Generally
             * they should use destroyRecursive() for widgets with children.
             *
             * @param preserveDom If true, this method will leave the original DOM structure alone.Note: This will not yet work with _TemplatedMixin widgets
             */
            destroy(preserveDom?: boolean): void;
            /**
             * Recursively destroy the children of this widget and their
             * descendants.
             *
             * @param preserveDom               OptionalIf true, the preserveDom attribute is passed to all descendantwidget's .destroy() method. Not for use with _Templatedwidgets.
             */
            destroyDescendants(preserveDom: boolean): void;
            /**
             * Destroy this widget and its descendants
             * This is the generic "destructor" function that all widget users
             * should call to cleanly discard with a widget. Once a widget is
             * destroyed, it is removed from the manager object.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structurealone of descendant Widgets. Note: This will NOT work withdijit._TemplatedMixin widgets.
             */
            destroyRecursive(preserveDom: boolean): void;
            /**
             * Destroys the DOM nodes associated with this widget.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structure aloneduring tear-down. Note: this will not work with _Templatedwidgets yet.
             */
            destroyRendering(preserveDom?: boolean): void;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Disconnects handle created by connect.
             *
             * @param handle
             */
            disconnect(handle: any): void;
            /**
             * Overridable method to display validation errors/hints.
             * By default uses a tooltip.
             *
             * @param message
             */
            displayMessage(message: String): void;
            /**
             * Used by widgets to signal that a synthetic event occurred, ex:
             *
             * myWidget.emit("attrmodified-selectedChildWidget", {}).
             * Emits an event on this.domNode named type.toLowerCase(), based on eventObj.
             * Also calls onType() method, if present, and returns value from that method.
             * By default passes eventObj to callback, but will pass callbackArgs instead, if specified.
             * Modifies eventObj by adding missing parameters (bubbles, cancelable, widget).
             *
             * @param type
             * @param eventObj               Optional
             * @param callbackArgs               Optional
             */
            emit(type: String, eventObj: Object, callbackArgs: any[]): any;
            /**
             * Auto-corrections (such as trimming) that are applied to textbox
             * value on blur or form submit.
             * For MappedTextBox subclasses, this is called twice
             *
             * once with the display value
             * once the value as set/returned by set('value', ...)
             * and get('value'), ex: a Number for NumberTextBox.
             *
             * In the latter case it does corrections like converting null to NaN.  In
             * the former case the NumberTextBox.filter() method calls this.inherited()
             * to execute standard trimming code in TextBox.filter().
             *
             * TODO: break this into two methods in 2.0
             *
             * @param val
             */
            filter(val: any): any;
            /**
             * Put focus on this widget
             *
             */
            focus(): void;
            /**
             *
             * @param value
             */
            format(value: any): any;
            /**
             * Get a property from a widget.
             * Get a named property from a widget. The property may
             * potentially be retrieved via a getter method. If no getter is defined, this
             * just retrieves the object's property.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _getFooAttr(), calling:
             * myWidget.get("foo") would be equivalent to calling
             * widget._getFooAttr() and myWidget.get("bar")
             * would be equivalent to the expression
             * widget.bar2
             *
             * @param name The property to get.
             */
            get(name: any): any;
            /**
             * Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent
             * is this widget.   Note that it does not return all descendants, but rather just direct children.
             * Analogous to Node.childNodes,
             * except containing widgets rather than DOMNodes.
             *
             * The result intentionally excludes internally created widgets (a.k.a. supporting widgets)
             * outside of this.containerNode.
             *
             * Note that the array returned is a simple array.  Application code should not assume
             * existence of methods like forEach().
             *
             */
            getChildren(): any[];
            /**
             * Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
             * This method should generally be avoided as it returns widgets declared in templates, which are
             * supposed to be internal/hidden, but it's left here for back-compat reasons.
             *
             */
            getDescendants(): any[];
            /**
             * Deprecated.  Use get('displayedValue') instead.
             *
             */
            getDisplayedValue(): any;
            /**
             *
             * @param isFocused
             */
            getErrorMessage(isFocused: boolean): any;
            /**
             * Returns the parent widget of this widget.
             *
             */
            getParent(): any;
            /**
             * Return a hint message to show when widget is first focused
             *
             * @param isFocused
             */
            getPromptMessage(isFocused: boolean): any;
            /**
             * Deprecated.  Use get('value') instead.
             *
             */
            getValue(): any;
            /**
             * Return true if this widget can currently be focused
             * and false if not
             *
             */
            isFocusable(): any;
            /**
             * Tests if the value is in the min/max range specified in constraints
             *
             * @param isFocused
             */
            isInRange(isFocused: boolean): any;
            /**
             * Return this widget's explicit or implicit orientation (true for LTR, false for RTL)
             *
             */
            isLeftToRight(): any;
            /**
             * Returns true if the dropdown exists and it's data is loaded.  This can
             * be overridden in order to force a call to loadDropDown().
             *
             */
            isLoaded(): boolean;
            /**
             *
             * @param isFocused
             */
            isValid: {(isFocused: boolean): any};
            /**
             * Creates the drop down if it doesn't exist, loads the data
             * if there's an href and it hasn't been loaded yet, and
             * then opens the drop down.  This is basically a callback when the
             * user presses the down arrow button to open the drop down.
             *
             */
            loadAndOpenDropDown(): any;
            /**
             * Creates the drop down if it doesn't exist, loads the data
             * if there's an href and it hasn't been loaded yet, and then calls
             * the given callback.
             *
             * @param loadCallback
             */
            loadDropDown(loadCallback: Function): void;
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: String, func: Function): any;
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: Function, func: Function): any;
            /**
             *
             */
            openDropDown(): void;
            /**
             * Track specified handles and remove/destroy them when this instance is destroyed, unless they were
             * already removed/destroyed manually.
             *
             */
            own(): any;
            /**
             *
             * @param displayVal
             */
            parse(displayVal: any): any;
            /**
             * Builds the regular needed to parse a localized date
             *
             * @param options               OptionalAn object with the following properties:selector (String): choice of 'time','date' (default: date and time)formatLength (String): choice of long, short, medium or full (plus any custom additions).  Defaults to 'short'datePattern (String): override pattern with this stringtimePattern (String): override pattern with this stringam (String): override strings for am in timespm (String): override strings for pm in timeslocale (String): override the locale used to determine formatting rulesfullYear (Boolean): (format only) use 4 digit years whenever 2 digit years are called forstrict (Boolean): (parse only) strict parsing, off by default
             */
            pattern: {(options?: Object): any};
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: number): any;
            /**
             * The popup widget to use. In this case, a calendar with just a Month view.
             *
             */
            popupClass: {(): void};
            /**
             *
             */
            postCreate(): void;
            /**
             *
             */
            postMixInProperties(): void;
            /**
             * Overridable function used to validate the range of the numeric input value.
             *
             * @param primitive
             * @param constraints
             */
            rangeCheck(primitive: number, constraints: dijit.form.RangeBoundTextBox.__Constraints): boolean;
            /**
             * Deprecated.  Use set('pattern', Function) instead.
             *
             * @param constraints An object with the following properties:locale (String): locale used for validation, picks up value from this widget's lang attribute_flags_ (anything): various flags passed to pattern function
             */
            regExpGen(constraints: Object): void;
            /**
             *
             */
            reset(): void;
            /**
             *
             * @param val
             * @param options               Optional
             */
            serialize(val: any, options: Object): any;
            /**
             * Set a property on a widget
             * Sets named properties on a widget which may potentially be handled by a
             * setter in the widget.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _setFooAttr(), calling
             * myWidget.set("foo", "Howdy!") would be equivalent to calling
             * widget._setFooAttr("Howdy!") and myWidget.set("bar", 3)
             * would be equivalent to the statement widget.bar = 3;
             *
             * set() may also be called with a hash of name/value pairs, ex:
             *
             * myWidget.set({
             *     foo: "Howdy",
             *     bar: 3
             * });
             * This is equivalent to calling set(foo, "Howdy") and set(bar, 3)
             *
             * @param name The property to set.
             * @param value The value to set in the property.
             */
            set(name: any, value: any): any;
            /**
             * Deprecated.  Use set() instead.
             *
             * @param attr
             * @param value
             */
            setAttribute(attr: String, value: any): void;
            /**
             * Deprecated.  Use set('disabled', ...) instead.
             *
             * @param disabled
             */
            setDisabled(disabled: boolean): void;
            /**
             * Deprecated.  Use set('displayedValue', ...) instead.
             *
             * @param value
             */
            setDisplayedValue(value: String): void;
            /**
             * Deprecated.  Use set('value', ...) instead.
             *
             * @param value
             */
            setValue(value: String): void;
            /**
             *
             */
            startup(): void;
            /**
             * Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.
             *
             * Subscribes to the specified topic and calls the specified method
             * of this object and registers for unsubscribe() on widget destroy.
             *
             * Provide widget-specific analog to dojo.subscribe, except with the
             * implicit use of this widget as the target object.
             *
             * @param t The topic
             * @param method The callback
             */
            subscribe(t: String, method: Function): any;
            /**
             * Callback when the user presses the down arrow button or presses
             * the down arrow key to open/close the drop down.
             * Toggle the drop-down widget; if it is up, close it, if not, open it
             *
             */
            toggleDropDown(): void;
            /**
             * Returns widget as a printable string using the widget's value
             *
             */
            toString(): string;
            /**
             * Restore the value to the last value passed to onChange
             *
             */
            undo(): void;
            /**
             * Deprecated. Override destroy() instead to implement custom widget tear-down
             * behavior.
             *
             */
            uninitialize(): boolean;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Unsubscribes handle created by this.subscribe.
             * Also removes handle from this widget's list of subscriptions
             *
             * @param handle
             */
            unsubscribe(handle: Object): void;
            /**
             *
             */
            validate(): any;
            /**
             *
             * @param value
             */
            validator(value: any): boolean;
            /**
             * Watches a property for changes
             *
             * @param name               OptionalIndicates the property to watch. This is optional (the callback may be theonly parameter), and if omitted, all the properties will be watched
             * @param callback The function to execute when the property changes. This will be called afterthe property has been changed. The callback will be called with the |this|set to the instance, the first argument as the name of the property, thesecond argument as the old value and the third argument as the new value.
             */
            watch(property: string, callback:{(property?:string, oldValue?:any, newValue?: any):void}) :{unwatch():void};
            /**
             * Static method to get a template based on the templatePath or
             * templateString key
             */
            getCachedTemplate(): any;
            /**
             * Called when the widget stops being "active" because
             * focus moved to something outside of it, or the user
             * clicked somewhere outside of it, or the widget was
             * hidden.
             *
             */
            onBlur(): void;
            /**
             * Callback when this widget's value is changed.
             *
             * @param newValue
             */
            onChange(newValue: any): void;
            /**
             * Connect to this function to receive notifications of mouse click events.
             *
             * @param event mouse Event
             */
            onClick(event: any): void;
            /**
             * Called when this widget is being displayed as a popup (ex: a Calendar popped
             * up from a DateTextBox), and it is hidden.
             * This is called from the dijit.popup code, and should not be called directly.
             *
             * Also used as a parameter for children of dijit/layout/StackContainer or subclasses.
             * Callback if a user tries to close the child.   Child will be closed if this function returns true.
             *
             */
            onClose(): boolean;
            /**
             * Connect to this function to receive notifications of mouse double click events.
             *
             * @param event mouse Event
             */
            onDblClick(event: any): void;
            /**
             * Called when the widget becomes "active" because
             * it or a widget inside of it either has focus, or has recently
             * been clicked.
             *
             */
            onFocus(): void;
            /**
             * Called when another widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate hide of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onHide(): void;
            /**
             * Connect to this function to receive notifications of various user data-input events.
             * Return false to cancel the event and prevent it from being processed.
             *
             * @param event keydown | keypress | cut | paste | input
             */
            onInput(event: any): void;
            /**
             * Connect to this function to receive notifications of keys being pressed down.
             *
             * @param event key Event
             */
            onKeyDown(event: any): void;
            /**
             * Connect to this function to receive notifications of printable keys being typed.
             *
             * @param event key Event
             */
            onKeyPress(event: any): void;
            /**
             * Connect to this function to receive notifications of keys being released.
             *
             * @param event key Event
             */
            onKeyUp(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is pressed down.
             *
             * @param event mouse Event
             */
            onMouseDown(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto this widget.
             *
             * @param event mouse Event
             */
            onMouseEnter(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of this widget.
             *
             * @param event mouse Event
             */
            onMouseLeave(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseMove(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOut(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOver(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is released.
             *
             * @param event mouse Event
             */
            onMouseUp(event: any): void;
            /**
             * Called when this widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate display of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onShow(): void;
        }
        /**
         * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/DropDownSelect.html
         *
         *
         * @param params Hash of initialization parameters for widget, including scalar values (like title, duration etc.)and functions, typically callbacks like onClick.The hash can contain any of the widget's properties, excluding read-only properties.
         * @param srcNodeRef       OptionalIf a srcNodeRef (DOM node) is specified, replace srcNodeRef with my generated DOM tree
         */
        class DropDownSelect extends dijit.form._FormSelectWidget implements dijit._HasDropDown, dijit._KeyNavMixin {
            constructor(params?: Object, srcNodeRef?: HTMLElement);
            /**
             * True if mouse was pressed while over this widget, and hasn't been released yet
             *
             */
            "active": boolean;
            set(property:"active", value: boolean): void;
            get(property:"active"): boolean;
            watch(property:"active", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "alt": string;
            set(property:"alt", value: string): void;
            get(property:"alt"): string;
            watch(property:"alt", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "aria-label": string;
            set(property:"aria-label", value: string): void;
            get(property:"aria-label"): string;
            watch(property:"aria-label", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Object to which attach points and events will be scoped.  Defaults
             * to 'this'.
             *
             */
            "attachScope": Object;
            set(property:"attachScope", value: Object): void;
            get(property:"attachScope"): Object;
            watch(property:"attachScope", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute
             * for each XXX attribute to be mapped to the DOM.
             *
             * attributeMap sets up a "binding" between attributes (aka properties)
             * of the widget and the widget's DOM.
             * Changes to widget attributes listed in attributeMap will be
             * reflected into the DOM.
             *
             * For example, calling set('title', 'hello')
             * on a TitlePane will automatically cause the TitlePane's DOM to update
             * with the new title.
             *
             * attributeMap is a hash where the key is an attribute of the widget,
             * and the value reflects a binding to a:
             *
             * DOM node attribute
             *   focus: {node: "focusNode", type: "attribute"}
             * Maps this.focus to this.focusNode.focus
             *
             * DOM node innerHTML
             *   title: { node: "titleNode", type: "innerHTML" }
             * Maps this.title to this.titleNode.innerHTML
             *
             * DOM node innerText
             *   title: { node: "titleNode", type: "innerText" }
             * Maps this.title to this.titleNode.innerText
             *
             * DOM node CSS class
             *   myClass: { node: "domNode", type: "class" }
             * Maps this.myClass to this.domNode.className
             *
             * If the value is an array, then each element in the array matches one of the
             * formats of the above list.
             *
             * There are also some shorthands for backwards compatibility:
             *
             * string --> { node: string, type: "attribute" }, for example:
             * "focusNode" ---> { node: "focusNode", type: "attribute" }
             * "" --> { node: "domNode", type: "attribute" }
             *
             */
            "attributeMap": Object;
            set(property:"attributeMap", value: Object): void;
            get(property:"attributeMap"): Object;
            watch(property:"attributeMap", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Set to true to make the drop down at least as wide as this
             * widget.  Set to false if the drop down should just be its
             * default width.
             *
             */
            "autoWidth": boolean;
            set(property:"autoWidth", value: boolean): void;
            get(property:"autoWidth"): boolean;
            watch(property:"autoWidth", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             *
             */
            "baseClass": string;
            set(property:"baseClass", value: string): void;
            get(property:"baseClass"): string;
            watch(property:"baseClass", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "class": string;
            set(property:"class", value: string): void;
            get(property:"class"): string;
            watch(property:"class", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Designates where children of the source DOM node will be placed.
             * "Children" in this case refers to both DOM nodes and widgets.
             * For example, for myWidget:
             *
             * <div data-dojo-type=myWidget>
             *     <b> here's a plain DOM node
             *     <span data-dojo-type=subWidget>and a widget</span>
             *     <i> and another plain DOM node </i>
             * </div>
             * containerNode would point to:
             *
             * <b> here's a plain DOM node
             * <span data-dojo-type=subWidget>and a widget</span>
             * <i> and another plain DOM node </i>
             * In templated widgets, "containerNode" is set via a
             * data-dojo-attach-point assignment.
             *
             * containerNode must be defined for any widget that accepts innerHTML
             * (like ContentPane or BorderContainer or even Button), and conversely
             * is null for widgets that don't, like TextBox.
             *
             */
            "containerNode": HTMLElement;
            set(property:"containerNode", value: HTMLElement): void;
            get(property:"containerNode"): HTMLElement;
            watch(property:"containerNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * Subclasses may define a cssStateNodes property that lists sub-nodes within the widget that
             * need CSS classes applied on mouse hover/press and focus.
             *
             * Each entry in this optional hash is a an attach-point name (like "upArrowButton") mapped to a CSS class name
             * (like "dijitUpArrowButton"). Example:
             *
             * {
             *     "upArrowButton": "dijitUpArrowButton",
             *     "downArrowButton": "dijitDownArrowButton"
             * }
             * The above will set the CSS class dijitUpArrowButton to the this.upArrowButton DOMNode when it
             *
             * is hovered, etc.
             *
             */
            "cssStateNodes": Object;
            set(property:"cssStateNodes", value: Object): void;
            get(property:"cssStateNodes"): Object;
            watch(property:"cssStateNodes", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Bi-directional support, as defined by the HTML DIR
             * attribute. Either left-to-right "ltr" or right-to-left "rtl".  If undefined, widgets renders in page's
             * default direction.
             *
             */
            "dir": string;
            set(property:"dir", value: string): void;
            get(property:"dir"): string;
            watch(property:"dir", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Should this widget respond to user input?
             * In markup, this is specified as "disabled='disabled'", or just "disabled".
             *
             */
            "disabled": boolean;
            set(property:"disabled", value: boolean): void;
            get(property:"disabled"): boolean;
            watch(property:"disabled", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * This is our visible representation of the widget! Other DOM
             * Nodes may by assigned to other properties, usually through the
             * template system's data-dojo-attach-point syntax, but the domNode
             * property is the canonical "top level" node in widget UI.
             *
             */
            "domNode": HTMLElement;
            set(property:"domNode", value: HTMLElement): void;
            get(property:"domNode"): HTMLElement;
            watch(property:"domNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * The widget to display as a popup.  This widget must be
             * defined before the startup function is called.
             *
             */
            "dropDown": Object;
            set(property:"dropDown", value: Object): void;
            get(property:"dropDown"): Object;
            watch(property:"dropDown", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * This variable controls the position of the drop down.
             * It's an array of strings with the following values:
             *
             * before: places drop down to the left of the target node/widget, or to the right in
             * the case of RTL scripts like Hebrew and Arabic
             * after: places drop down to the right of the target node/widget, or to the left in
             * the case of RTL scripts like Hebrew and Arabic
             * above: drop down goes above target node
             * below: drop down goes below target node
             * The list is positions is tried, in order, until a position is found where the drop down fits
             * within the viewport.
             *
             */
            "dropDownPosition": Object;
            set(property:"dropDownPosition", value: Object): void;
            get(property:"dropDownPosition"): Object;
            watch(property:"dropDownPosition", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * What to display in an "empty" dropdown
             *
             */
            "emptyLabel": string;
            set(property:"emptyLabel", value: string): void;
            get(property:"emptyLabel"): string;
            watch(property:"emptyLabel", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * This widget or a widget it contains has focus, or is "active" because
             * it was recently clicked.
             *
             */
            "focused": boolean;
            set(property:"focused", value: boolean): void;
            get(property:"focused"): boolean;
            watch(property:"focused", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * The currently focused child widget, or null if there isn't one
             *
             */
            "focusedChild": Object;
            set(property:"focusedChild", value: Object): void;
            get(property:"focusedChild"): Object;
            watch(property:"focusedChild", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Set to true to make the drop down exactly as wide as this
             * widget.  Overrides autoWidth.
             *
             */
            "forceWidth": boolean;
            set(property:"forceWidth", value: boolean): void;
            get(property:"forceWidth"): boolean;
            watch(property:"forceWidth", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * True if cursor is over this widget
             *
             */
            "hovering": boolean;
            set(property:"hovering", value: boolean): void;
            get(property:"hovering"): boolean;
            watch(property:"hovering", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * A unique, opaque ID string that can be assigned by users or by the
             * system. If the developer passes an ID which is known not to be
             * unique, the specified ID is ignored and the system-generated ID is
             * used instead.
             *
             */
            "id": string;
            set(property:"id", value: string): void;
            get(property:"id"): string;
            watch(property:"id", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Fires onChange for each value change or only on demand
             *
             */
            "intermediateChanges": boolean;
            set(property:"intermediateChanges", value: boolean): void;
            get(property:"intermediateChanges"): boolean;
            watch(property:"intermediateChanges", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * The entries in the drop down list come from this attribute in the dojo.store items.
             * If store is set, labelAttr must be set too, unless store is an old-style
             * dojo.data store rather than a new dojo/store.
             *
             */
            "labelAttr": Object;
            set(property:"labelAttr", value: Object): void;
            get(property:"labelAttr"): Object;
            watch(property:"labelAttr", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Rarely used.  Overrides the default Dojo locale used to render this widget,
             * as defined by the HTML LANG attribute.
             * Value must be among the list of locales specified during by the Dojo bootstrap,
             * formatted according to RFC 3066 (like en-us).
             *
             */
            "lang": string;
            set(property:"lang", value: string): void;
            get(property:"lang"): string;
            watch(property:"lang", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * By default loadChildren is called when the items are fetched from the
             * store.  This property allows delaying loadChildren (and the creation
             * of the options/menuitems) until the user clicks the button to open the
             * dropdown.
             *
             */
            "loadChildrenOnOpen": boolean;
            set(property:"loadChildrenOnOpen", value: boolean): void;
            get(property:"loadChildrenOnOpen"): boolean;
            watch(property:"loadChildrenOnOpen", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * The max height for our dropdown.
             * Any dropdown taller than this will have scrollbars.
             * Set to 0 for no max height, or -1 to limit height to available space in viewport
             *
             */
            "maxHeight": number;
            set(property:"maxHeight", value: number): void;
            get(property:"maxHeight"): number;
            watch(property:"maxHeight", callback:{(property?:string, oldValue?:number, newValue?: number):void}) :{unwatch():void}
            /**
             * Currently displayed error/prompt message
             *
             */
            "message": string;
            set(property:"message", value: string): void;
            get(property:"message"): string;
            watch(property:"message", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * If multiple characters are typed where each keystroke happens within
             * multiCharSearchDuration of the previous keystroke,
             * search for nodes matching all the keystrokes.
             *
             * For example, typing "ab" will search for entries starting with
             * "ab" unless the delay between "a" and "b" is greater than multiCharSearchDuration.
             *
             */
            "multiCharSearchDuration": number;
            set(property:"multiCharSearchDuration", value: number): void;
            get(property:"multiCharSearchDuration"): number;
            watch(property:"multiCharSearchDuration", callback:{(property?:string, oldValue?:number, newValue?: number):void}) :{unwatch():void}
            /**
             * Whether or not we are multi-valued
             *
             */
            "multiple": boolean;
            set(property:"multiple", value: boolean): void;
            get(property:"multiple"): boolean;
            watch(property:"multiple", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Name used when submitting form; same as "name" attribute or plain HTML elements
             *
             */
            "name": string;
            set(property:"name", value: string): void;
            get(property:"name"): string;
            watch(property:"name", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * A callback to do with an onFetch - but before any items are actually
             * iterated over (i.e. to filter even further what you want to add)
             *
             */
            "onFetch": Function;
            set(property:"onFetch", value: Function): void;
            get(property:"onFetch"): Function;
            watch(property:"onFetch", callback:{(property?:string, oldValue?:Function, newValue?: Function):void}) :{unwatch():void}
            /**
             * This is the dojo.Deferred returned by setStore().
             * Calling onLoadDeferred.then() registers your
             * callback to be called only once, when the prior setStore completes.
             *
             */
            "onLoadDeferred": Object;
            set(property:"onLoadDeferred", value: Object): void;
            get(property:"onLoadDeferred"): Object;
            watch(property:"onLoadDeferred", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * The set of options for our select item.  Roughly corresponds to
             * the html <option> tag.
             *
             */
            "options": Object;
            set(property:"options", value: Object): void;
            get(property:"options"): Object;
            watch(property:"options", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * The document this widget belongs to.  If not specified to constructor, will default to
             * srcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global
             *
             */
            "ownerDocument": Object;
            set(property:"ownerDocument", value: Object): void;
            get(property:"ownerDocument"): Object;
            watch(property:"ownerDocument", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * A query to use when fetching items from our store
             *
             */
            "query": Object;
            set(property:"query", value: Object): void;
            get(property:"query"): Object;
            watch(property:"query", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Query options to use when fetching from the store
             *
             */
            "queryOptions": Object;
            set(property:"queryOptions", value: Object): void;
            get(property:"queryOptions"): Object;
            watch(property:"queryOptions", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Should this widget respond to user input?
             * In markup, this is specified as "readOnly".
             * Similar to disabled except readOnly form values are submitted.
             *
             */
            "readOnly": boolean;
            set(property:"readOnly", value: boolean): void;
            get(property:"readOnly"): boolean;
            watch(property:"readOnly", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Can be true or false, default is false.
             *
             */
            "required": boolean;
            set(property:"required", value: boolean): void;
            get(property:"required"): boolean;
            watch(property:"required", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * On focus, should this widget scroll into view?
             *
             */
            "scrollOnFocus": boolean;
            set(property:"scrollOnFocus", value: boolean): void;
            get(property:"scrollOnFocus"): boolean;
            watch(property:"scrollOnFocus", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             *
             */
            "searchContainerNode": boolean;
            set(property:"searchContainerNode", value: boolean): void;
            get(property:"searchContainerNode"): boolean;
            watch(property:"searchContainerNode", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Flag to sort the options returned from a store by the label of
             * the store.
             *
             */
            "sortByLabel": boolean;
            set(property:"sortByLabel", value: boolean): void;
            get(property:"sortByLabel"): boolean;
            watch(property:"sortByLabel", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * pointer to original DOM node
             *
             */
            "srcNodeRef": HTMLElement;
            set(property:"srcNodeRef", value: HTMLElement): void;
            get(property:"srcNodeRef"): HTMLElement;
            watch(property:"srcNodeRef", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * "Incomplete" if this select is required but unset (i.e. blank value), "" otherwise
             *
             */
            "state": string;
            set(property:"state", value: string): void;
            get(property:"state"): string;
            watch(property:"state", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * A store to use for getting our list of options - rather than reading them
             * from the <option> html tags.   Should support getIdentity().
             * For back-compat store can also be a dojo/data/api/Identity.
             *
             */
            "store": Object;
            set(property:"store", value: Object): void;
            get(property:"store"): Object;
            watch(property:"store", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * HTML style attributes as cssText string or name/value hash
             *
             */
            "style": string;
            set(property:"style", value: string): void;
            get(property:"style"): string;
            watch(property:"style", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Order fields are traversed when user hits the tab key
             *
             */
            "tabIndex": string;
            set(property:"tabIndex", value: string): void;
            get(property:"tabIndex"): string;
            watch(property:"tabIndex", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Path to template (HTML file) for this widget relative to dojo.baseUrl.
             * Deprecated: use templateString with require([... "dojo/text!..."], ...) instead
             *
             */
            "templatePath": string;
            set(property:"templatePath", value: string): void;
            get(property:"templatePath"): string;
            watch(property:"templatePath", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "templateString": string;
            set(property:"templateString", value: string): void;
            get(property:"templateString"): string;
            watch(property:"templateString", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * HTML title attribute.
             *
             * For form widgets this specifies a tooltip to display when hovering over
             * the widget (just like the native HTML title attribute).
             *
             * For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,
             * etc., it's used to specify the tab label, accordion pane title, etc.  In this case it's
             * interpreted as HTML.
             *
             */
            "title": string;
            set(property:"title", value: string): void;
            get(property:"title"): string;
            watch(property:"title", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * When this widget's title attribute is used to for a tab label, accordion pane title, etc.,
             * this specifies the tooltip to appear when the mouse is hovered over that text.
             *
             */
            "tooltip": string;
            set(property:"tooltip", value: string): void;
            get(property:"tooltip"): string;
            watch(property:"tooltip", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * See description of dijit/Tooltip.defaultPosition for details on this parameter.
             *
             */
            "tooltipPosition": Object;
            set(property:"tooltipPosition", value: Object): void;
            get(property:"tooltipPosition"): Object;
            watch(property:"tooltipPosition", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "type": string;
            set(property:"type", value: string): void;
            get(property:"type"): string;
            watch(property:"type", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "value": string;
            set(property:"value", value: string): void;
            get(property:"value"): string;
            watch(property:"value", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Adds an option or options to the end of the select.  If value
             * of the option is empty or missing, a separator is created instead.
             * Passing in an array of options will yield slightly better performance
             * since the children are only loaded once.
             *
             * @param option
             */
            addOption(option: dijit.form._FormSelectWidget.__SelectOption): void;
            /**
             * Adds an option or options to the end of the select.  If value
             * of the option is empty or missing, a separator is created instead.
             * Passing in an array of options will yield slightly better performance
             * since the children are only loaded once.
             *
             * @param option
             */
            addOption(option: dijit.form._FormSelectWidget.__SelectOption[]): void;
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: String, value: Object): any;
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: Object, value: Object): any;
            /**
             *
             */
            buildRendering(): void;
            /**
             *
             * @param node
             */
            childSelector(node: HTMLElement): any;
            /**
             * Closes the drop down on this widget
             *
             * @param focus If true, refocuses the button widget
             */
            closeDropDown(focus: boolean): void;
            /**
             * Compare 2 values (as returned by get('value') for this widget).
             *
             * @param val1
             * @param val2
             */
            compare(val1: any, val2: any): number;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: Function): any;
            /**
             * Wrapper to setTimeout to avoid deferred functions executing
             * after the originating widget has been destroyed.
             * Returns an object handle with a remove method (that returns null) (replaces clearTimeout).
             *
             * @param fcn Function reference.
             * @param delay               OptionalDelay, defaults to 0.
             */
            defer(fcn: Function, delay: number): Object;
            /**
             *
             * @param preserveDom
             */
            destroy(preserveDom?: any): void;
            /**
             * Recursively destroy the children of this widget and their
             * descendants.
             *
             * @param preserveDom               OptionalIf true, the preserveDom attribute is passed to all descendantwidget's .destroy() method. Not for use with _Templatedwidgets.
             */
            destroyDescendants(preserveDom: boolean): void;
            /**
             * Destroy this widget and its descendants
             * This is the generic "destructor" function that all widget users
             * should call to cleanly discard with a widget. Once a widget is
             * destroyed, it is removed from the manager object.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structurealone of descendant Widgets. Note: This will NOT work withdijit._TemplatedMixin widgets.
             */
            destroyRecursive(preserveDom: boolean): void;
            /**
             * Destroys the DOM nodes associated with this widget.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structure aloneduring tear-down. Note: this will not work with _Templatedwidgets yet.
             */
            destroyRendering(preserveDom?: boolean): void;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Disconnects handle created by connect.
             *
             * @param handle
             */
            disconnect(handle: any): void;
            /**
             * Used by widgets to signal that a synthetic event occurred, ex:
             *
             * myWidget.emit("attrmodified-selectedChildWidget", {}).
             * Emits an event on this.domNode named type.toLowerCase(), based on eventObj.
             * Also calls onType() method, if present, and returns value from that method.
             * By default passes eventObj to callback, but will pass callbackArgs instead, if specified.
             * Modifies eventObj by adding missing parameters (bubbles, cancelable, widget).
             *
             * @param type
             * @param eventObj               Optional
             * @param callbackArgs               Optional
             */
            emit(type: String, eventObj: Object, callbackArgs: any[]): any;
            /**
             *
             */
            focus(): void;
            /**
             * Sets the value to the given option, used during search by letter.
             *
             * @param widget Reference to option's widget
             */
            focusChild(widget: dijit._WidgetBase): void;
            /**
             * Focus the first focusable child in the container.
             *
             */
            focusFirstChild(): void;
            /**
             * Focus the last focusable child in the container.
             *
             */
            focusLastChild(): void;
            /**
             * Get a property from a widget.
             * Get a named property from a widget. The property may
             * potentially be retrieved via a getter method. If no getter is defined, this
             * just retrieves the object's property.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _getFooAttr(), calling:
             * myWidget.get("foo") would be equivalent to calling
             * widget._getFooAttr() and myWidget.get("bar")
             * would be equivalent to the expression
             * widget.bar2
             *
             * @param name The property to get.
             */
            get(name: any): any;
            /**
             * Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent
             * is this widget.   Note that it does not return all descendants, but rather just direct children.
             * Analogous to Node.childNodes,
             * except containing widgets rather than DOMNodes.
             *
             * The result intentionally excludes internally created widgets (a.k.a. supporting widgets)
             * outside of this.containerNode.
             *
             * Note that the array returned is a simple array.  Application code should not assume
             * existence of methods like forEach().
             *
             */
            getChildren(): any[];
            /**
             * Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
             * This method should generally be avoided as it returns widgets declared in templates, which are
             * supposed to be internal/hidden, but it's left here for back-compat reasons.
             *
             */
            getDescendants(): any[];
            /**
             * Returns a given option (or options).
             *
             * @param valueOrIdx If passed in as a string, that string is used to look up the optionin the array of options - based on the value property.(See dijit/form/_FormSelectWidget.__SelectOption).If passed in a number, then the option with the given index (0-based)within this select will be returned.If passed in a dijit/form/_FormSelectWidget.__SelectOption, the same option will bereturned if and only if it exists within this select.If passed an array, then an array will be returned with each elementin the array being looked up.If not passed a value, then all options will be returned
             */
            getOptions(valueOrIdx: any): any;
            /**
             * Returns the parent widget of this widget.
             *
             */
            getParent(): any;
            /**
             * Deprecated.  Use get('value') instead.
             *
             */
            getValue(): any;
            /**
             * Return true if this widget can currently be focused
             * and false if not
             *
             */
            isFocusable(): any;
            /**
             * Return this widget's explicit or implicit orientation (true for LTR, false for RTL)
             *
             */
            isLeftToRight(): any;
            /**
             *
             */
            isLoaded(): any;
            /**
             * Whether or not this is a valid value.  The only way a Select
             * can be invalid is when it's required but nothing is selected.
             *
             * @param isFocused
             */
            isValid: {(isFocused: boolean): boolean};
            /**
             * Creates the drop down if it doesn't exist, loads the data
             * if there's an href and it hasn't been loaded yet, and
             * then opens the drop down.  This is basically a callback when the
             * user presses the down arrow button to open the drop down.
             *
             */
            loadAndOpenDropDown(): any;
            /**
             * populates the menu
             *
             * @param loadCallback
             */
            loadDropDown(loadCallback: Function): void;
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: String, func: Function): any;
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: Function, func: Function): any;
            /**
             * Opens the dropdown for this widget.   To be called only when this.dropDown
             * has been created and is ready to display (ie, it's data is loaded).
             *
             */
            openDropDown(): any;
            /**
             * Track specified handles and remove/destroy them when this instance is destroyed, unless they were
             * already removed/destroyed manually.
             *
             */
            own(): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: number): any;
            /**
             * stop mousemove from selecting text on IE to be consistent with other browsers
             *
             */
            postCreate(): void;
            /**
             * set the missing message
             *
             */
            postMixInProperties(): void;
            /**
             * Removes the given option or options.  You can remove by string
             * (in which case the value is removed), number (in which case the
             * index in the options array is removed), or select option (in
             * which case, the select option with a matching value is removed).
             * You can also pass in an array of those values for a slightly
             * better performance since the children are only loaded once.
             * For numeric option values, specify {value: number} as the argument.
             *
             * @param valueOrIdx
             */
            removeOption(valueOrIdx: String): void;
            /**
             * Removes the given option or options.  You can remove by string
             * (in which case the value is removed), number (in which case the
             * index in the options array is removed), or select option (in
             * which case, the select option with a matching value is removed).
             * You can also pass in an array of those values for a slightly
             * better performance since the children are only loaded once.
             * For numeric option values, specify {value: number} as the argument.
             *
             * @param valueOrIdx
             */
            removeOption(valueOrIdx: dijit.form._FormSelectWidget.__SelectOption): void;
            /**
             * Removes the given option or options.  You can remove by string
             * (in which case the value is removed), number (in which case the
             * index in the options array is removed), or select option (in
             * which case, the select option with a matching value is removed).
             * You can also pass in an array of those values for a slightly
             * better performance since the children are only loaded once.
             * For numeric option values, specify {value: number} as the argument.
             *
             * @param valueOrIdx
             */
            removeOption(valueOrIdx: number): void;
            /**
             * Removes the given option or options.  You can remove by string
             * (in which case the value is removed), number (in which case the
             * index in the options array is removed), or select option (in
             * which case, the select option with a matching value is removed).
             * You can also pass in an array of those values for a slightly
             * better performance since the children are only loaded once.
             * For numeric option values, specify {value: number} as the argument.
             *
             * @param valueOrIdx
             */
            removeOption(valueOrIdx: any[]): void;
            /**
             * Overridden so that the state will be cleared.
             *
             */
            reset(): void;
            /**
             * Set a property on a widget
             * Sets named properties on a widget which may potentially be handled by a
             * setter in the widget.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _setFooAttr(), calling
             * myWidget.set("foo", "Howdy!") would be equivalent to calling
             * widget._setFooAttr("Howdy!") and myWidget.set("bar", 3)
             * would be equivalent to the statement widget.bar = 3;
             *
             * set() may also be called with a hash of name/value pairs, ex:
             *
             * myWidget.set({
             *     foo: "Howdy",
             *     bar: 3
             * });
             * This is equivalent to calling set(foo, "Howdy") and set(bar, 3)
             *
             * @param name The property to set.
             * @param value The value to set in the property.
             */
            set(name: any, value: any): any;
            /**
             * Deprecated.  Use set() instead.
             *
             * @param attr
             * @param value
             */
            setAttribute(attr: String, value: any): void;
            /**
             * Deprecated.  Use set('disabled', ...) instead.
             *
             * @param disabled
             */
            setDisabled(disabled: boolean): void;
            /**
             * Sets the store you would like to use with this select widget.
             * The selected value is the value of the new store to set.  This
             * function returns the original store, in case you want to reuse
             * it or something.
             *
             * @param store The dojo.store you would like to use - it MUST implement getIdentity()and MAY implement observe().For backwards-compatibility this can also be a data.data store, in which caseit MUST implement dojo/data/api/Identity,and MAY implement dojo/data/api/Notification.
             * @param selectedValue               OptionalThe value that this widget should set itself to after the storehas been loaded
             * @param fetchArgs               OptionalHash of parameters to set filter on store, etc.query: new value for Select.query,queryOptions: new value for Select.queryOptions,onFetch: callback function for each item in data (Deprecated)
             */
            setStore(store: dojo.store.api.Store, selectedValue: any, fetchArgs: Object): any;
            /**
             * Deprecated.  Use set('value', ...) instead.
             *
             * @param value
             */
            setValue(value: String): void;
            /**
             *
             */
            startup(): void;
            /**
             * Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.
             *
             * Subscribes to the specified topic and calls the specified method
             * of this object and registers for unsubscribe() on widget destroy.
             *
             * Provide widget-specific analog to dojo.subscribe, except with the
             * implicit use of this widget as the target object.
             *
             * @param t The topic
             * @param method The callback
             */
            subscribe(t: String, method: Function): any;
            /**
             * Callback when the user presses the down arrow button or presses
             * the down arrow key to open/close the drop down.
             * Toggle the drop-down widget; if it is up, close it, if not, open it
             *
             */
            toggleDropDown(): void;
            /**
             * Returns a string that represents the widget.
             * When a widget is cast to a string, this method will be used to generate the
             * output. Currently, it does not implement any sort of reversible
             * serialization.
             *
             */
            toString(): string;
            /**
             * Restore the value to the last value passed to onChange
             *
             */
            undo(): void;
            /**
             * Deprecated. Override destroy() instead to implement custom widget tear-down
             * behavior.
             *
             */
            uninitialize(): boolean;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Unsubscribes handle created by this.subscribe.
             * Also removes handle from this widget's list of subscriptions
             *
             * @param handle
             */
            unsubscribe(handle: Object): void;
            /**
             * Updates the values of the given option.  The option to update
             * is matched based on the value of the entered option.  Passing
             * in an array of new options will yield better performance since
             * the children will only be loaded once.
             *
             * @param newOption
             */
            updateOption(newOption: dijit.form._FormSelectWidget.__SelectOption): void;
            /**
             * Updates the values of the given option.  The option to update
             * is matched based on the value of the entered option.  Passing
             * in an array of new options will yield better performance since
             * the children will only be loaded once.
             *
             * @param newOption
             */
            updateOption(newOption: dijit.form._FormSelectWidget.__SelectOption[]): void;
            /**
             * Called by oninit, onblur, and onkeypress, and whenever required/disabled state changes
             * Show missing or invalid messages if appropriate, and highlight textbox field.
             * Used when a select is initially set to no value and the user is required to
             * set the value.
             *
             * @param isFocused
             */
            validate(isFocused: boolean): any;
            /**
             * Watches a property for changes
             *
             * @param name               OptionalIndicates the property to watch. This is optional (the callback may be theonly parameter), and if omitted, all the properties will be watched
             * @param callback The function to execute when the property changes. This will be called afterthe property has been changed. The callback will be called with the |this|set to the instance, the first argument as the name of the property, thesecond argument as the old value and the third argument as the new value.
             */
            watch(property: string, callback:{(property?:string, oldValue?:any, newValue?: any):void}) :{unwatch():void};
            /**
             * Static method to get a template based on the templatePath or
             * templateString key
             */
            getCachedTemplate(): any;
            /**
             * Called when the widget stops being "active" because
             * focus moved to something outside of it, or the user
             * clicked somewhere outside of it, or the widget was
             * hidden.
             *
             */
            onBlur(): void;
            /**
             * Callback when this widget's value is changed.
             *
             * @param newValue
             */
            onChange(newValue: any): void;
            /**
             * Connect to this function to receive notifications of mouse click events.
             *
             * @param event mouse Event
             */
            onClick(event: any): void;
            /**
             * Called when this widget is being displayed as a popup (ex: a Calendar popped
             * up from a DateTextBox), and it is hidden.
             * This is called from the dijit.popup code, and should not be called directly.
             *
             * Also used as a parameter for children of dijit/layout/StackContainer or subclasses.
             * Callback if a user tries to close the child.   Child will be closed if this function returns true.
             *
             */
            onClose(): boolean;
            /**
             * Connect to this function to receive notifications of mouse double click events.
             *
             * @param event mouse Event
             */
            onDblClick(event: any): void;
            /**
             * Called when the widget becomes "active" because
             * it or a widget inside of it either has focus, or has recently
             * been clicked.
             *
             */
            onFocus(): void;
            /**
             * Called when another widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate hide of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onHide(): void;
            /**
             * When a key is pressed that matches a child item,
             * this method is called so that a widget can take appropriate action is necessary.
             *
             * @param item
             * @param evt
             * @param searchString
             * @param numMatches
             */
            onKeyboardSearch(item: dijit._WidgetBase, evt: Event, searchString: String, numMatches: number): void;
            /**
             * Connect to this function to receive notifications of keys being pressed down.
             *
             * @param event key Event
             */
            onKeyDown(event: any): void;
            /**
             * Connect to this function to receive notifications of printable keys being typed.
             *
             * @param event key Event
             */
            onKeyPress(event: any): void;
            /**
             * Connect to this function to receive notifications of keys being released.
             *
             * @param event key Event
             */
            onKeyUp(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is pressed down.
             *
             * @param event mouse Event
             */
            onMouseDown(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto this widget.
             *
             * @param event mouse Event
             */
            onMouseEnter(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of this widget.
             *
             * @param event mouse Event
             */
            onMouseLeave(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseMove(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOut(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOver(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is released.
             *
             * @param event mouse Event
             */
            onMouseUp(event: any): void;
            /**
             * a function that can be connected to in order to receive a
             * notification that the store has finished loading and all options
             * from that store are available
             *
             */
            onSetStore(): void;
            /**
             * Called when this widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate display of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onShow(): void;
        }
        namespace DropDownSelect {
            /**
             * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/DropDownSelect._Menu.html
             *
             * An internally-used menu for dropdown that allows us a vertical scrollbar
             *
             * @param params Hash of initialization parameters for widget, including scalar values (like title, duration etc.)and functions, typically callbacks like onClick.The hash can contain any of the widget's properties, excluding read-only properties.
             * @param srcNodeRef       OptionalIf a srcNodeRef (DOM node) is specified:use srcNodeRef.innerHTML as my contentsif this is a behavioral widget then apply behavior to that srcNodeRefotherwise, replace srcNodeRef with my generated DOM tree
             */
            class _Menu extends dijit.DropDownMenu {
                constructor(params?: Object, srcNodeRef?: HTMLElement);
                /**
                 * This Menu has been clicked (mouse or via space/arrow key) or opened as a submenu,
                 * so mere mouseover will open submenus.  Focusing a menu via TAB does NOT automatically make it active
                 * since TAB is a navigation operation and not a selection one.
                 * For Windows apps, pressing the ALT key focuses the menubar menus (similar to TAB navigation) but the
                 * menu is not active (ie no dropdown) until an item is clicked.
                 *
                 */
                "activated": boolean;
                set(property:"activated", value: boolean): void;
                get(property:"activated"): boolean;
                watch(property:"activated", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
                /**
                 * True if mouse was pressed while over this widget, and hasn't been released yet
                 *
                 */
                "active": boolean;
                set(property:"active", value: boolean): void;
                get(property:"active"): boolean;
                watch(property:"active", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
                /**
                 * Object to which attach points and events will be scoped.  Defaults
                 * to 'this'.
                 *
                 */
                "attachScope": Object;
                set(property:"attachScope", value: Object): void;
                get(property:"attachScope"): Object;
                watch(property:"attachScope", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
                /**
                 * Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute
                 * for each XXX attribute to be mapped to the DOM.
                 *
                 * attributeMap sets up a "binding" between attributes (aka properties)
                 * of the widget and the widget's DOM.
                 * Changes to widget attributes listed in attributeMap will be
                 * reflected into the DOM.
                 *
                 * For example, calling set('title', 'hello')
                 * on a TitlePane will automatically cause the TitlePane's DOM to update
                 * with the new title.
                 *
                 * attributeMap is a hash where the key is an attribute of the widget,
                 * and the value reflects a binding to a:
                 *
                 * DOM node attribute
                 *   focus: {node: "focusNode", type: "attribute"}
                 * Maps this.focus to this.focusNode.focus
                 *
                 * DOM node innerHTML
                 *   title: { node: "titleNode", type: "innerHTML" }
                 * Maps this.title to this.titleNode.innerHTML
                 *
                 * DOM node innerText
                 *   title: { node: "titleNode", type: "innerText" }
                 * Maps this.title to this.titleNode.innerText
                 *
                 * DOM node CSS class
                 *   myClass: { node: "domNode", type: "class" }
                 * Maps this.myClass to this.domNode.className
                 *
                 * If the value is an array, then each element in the array matches one of the
                 * formats of the above list.
                 *
                 * There are also some shorthands for backwards compatibility:
                 *
                 * string --> { node: string, type: "attribute" }, for example:
                 * "focusNode" ---> { node: "focusNode", type: "attribute" }
                 * "" --> { node: "domNode", type: "attribute" }
                 *
                 */
                "attributeMap": Object;
                set(property:"attributeMap", value: Object): void;
                get(property:"attributeMap"): Object;
                watch(property:"attributeMap", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
                /**
                 *
                 */
                "autoFocus": boolean;
                set(property:"autoFocus", value: boolean): void;
                get(property:"autoFocus"): boolean;
                watch(property:"autoFocus", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
                /**
                 *
                 */
                "baseClass": string;
                set(property:"baseClass", value: string): void;
                get(property:"baseClass"): string;
                watch(property:"baseClass", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
                /**
                 *
                 */
                "class": string;
                set(property:"class", value: string): void;
                get(property:"class"): string;
                watch(property:"class", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
                /**
                 * Designates where children of the source DOM node will be placed.
                 * "Children" in this case refers to both DOM nodes and widgets.
                 * For example, for myWidget:
                 *
                 * <div data-dojo-type=myWidget>
                 *     <b> here's a plain DOM node
                 *     <span data-dojo-type=subWidget>and a widget</span>
                 *     <i> and another plain DOM node </i>
                 * </div>
                 * containerNode would point to:
                 *
                 * <b> here's a plain DOM node
                 * <span data-dojo-type=subWidget>and a widget</span>
                 * <i> and another plain DOM node </i>
                 * In templated widgets, "containerNode" is set via a
                 * data-dojo-attach-point assignment.
                 *
                 * containerNode must be defined for any widget that accepts innerHTML
                 * (like ContentPane or BorderContainer or even Button), and conversely
                 * is null for widgets that don't, like TextBox.
                 *
                 */
                "containerNode": HTMLElement;
                set(property:"containerNode", value: HTMLElement): void;
                get(property:"containerNode"): HTMLElement;
                watch(property:"containerNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
                /**
                 * Subclasses may define a cssStateNodes property that lists sub-nodes within the widget that
                 * need CSS classes applied on mouse hover/press and focus.
                 *
                 * Each entry in this optional hash is a an attach-point name (like "upArrowButton") mapped to a CSS class name
                 * (like "dijitUpArrowButton"). Example:
                 *
                 * {
                 *     "upArrowButton": "dijitUpArrowButton",
                 *     "downArrowButton": "dijitDownArrowButton"
                 * }
                 * The above will set the CSS class dijitUpArrowButton to the this.upArrowButton DOMNode when it
                 *
                 * is hovered, etc.
                 *
                 */
                "cssStateNodes": Object;
                set(property:"cssStateNodes", value: Object): void;
                get(property:"cssStateNodes"): Object;
                watch(property:"cssStateNodes", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
                /**
                 * Bi-directional support, as defined by the HTML DIR
                 * attribute. Either left-to-right "ltr" or right-to-left "rtl".  If undefined, widgets renders in page's
                 * default direction.
                 *
                 */
                "dir": string;
                set(property:"dir", value: string): void;
                get(property:"dir"): string;
                watch(property:"dir", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
                /**
                 * This is our visible representation of the widget! Other DOM
                 * Nodes may by assigned to other properties, usually through the
                 * template system's data-dojo-attach-point syntax, but the domNode
                 * property is the canonical "top level" node in widget UI.
                 *
                 */
                "domNode": HTMLElement;
                set(property:"domNode", value: HTMLElement): void;
                get(property:"domNode"): HTMLElement;
                watch(property:"domNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
                /**
                 * This widget or a widget it contains has focus, or is "active" because
                 * it was recently clicked.
                 *
                 */
                "focused": boolean;
                set(property:"focused", value: boolean): void;
                get(property:"focused"): boolean;
                watch(property:"focused", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
                /**
                 * The currently focused child widget, or null if there isn't one
                 *
                 */
                "focusedChild": Object;
                set(property:"focusedChild", value: Object): void;
                get(property:"focusedChild"): Object;
                watch(property:"focusedChild", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
                /**
                 * True if cursor is over this widget
                 *
                 */
                "hovering": boolean;
                set(property:"hovering", value: boolean): void;
                get(property:"hovering"): boolean;
                watch(property:"hovering", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
                /**
                 * A unique, opaque ID string that can be assigned by users or by the
                 * system. If the developer passes an ID which is known not to be
                 * unique, the specified ID is ignored and the system-generated ID is
                 * used instead.
                 *
                 */
                "id": string;
                set(property:"id", value: string): void;
                get(property:"id"): string;
                watch(property:"id", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
                /**
                 * Rarely used.  Overrides the default Dojo locale used to render this widget,
                 * as defined by the HTML LANG attribute.
                 * Value must be among the list of locales specified during by the Dojo bootstrap,
                 * formatted according to RFC 3066 (like en-us).
                 *
                 */
                "lang": string;
                set(property:"lang", value: string): void;
                get(property:"lang"): string;
                watch(property:"lang", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
                /**
                 * If multiple characters are typed where each keystroke happens within
                 * multiCharSearchDuration of the previous keystroke,
                 * search for nodes matching all the keystrokes.
                 *
                 * For example, typing "ab" will search for entries starting with
                 * "ab" unless the delay between "a" and "b" is greater than multiCharSearchDuration.
                 *
                 */
                "multiCharSearchDuration": number;
                set(property:"multiCharSearchDuration", value: number): void;
                get(property:"multiCharSearchDuration"): number;
                watch(property:"multiCharSearchDuration", callback:{(property?:string, oldValue?:number, newValue?: number):void}) :{unwatch():void}
                /**
                 * The document this widget belongs to.  If not specified to constructor, will default to
                 * srcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global
                 *
                 */
                "ownerDocument": Object;
                set(property:"ownerDocument", value: Object): void;
                get(property:"ownerDocument"): Object;
                watch(property:"ownerDocument", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
                /**
                 * pointer to menu that displayed me
                 *
                 */
                "parentMenu": Object;
                set(property:"parentMenu", value: Object): void;
                get(property:"parentMenu"): Object;
                watch(property:"parentMenu", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
                /**
                 * For a passive (unclicked) Menu, number of milliseconds before hovering (without clicking) will cause
                 * the popup to open.  Default is Infinity, meaning you need to click the menu to open it.
                 *
                 */
                "passivePopupDelay": number;
                set(property:"passivePopupDelay", value: number): void;
                get(property:"passivePopupDelay"): number;
                watch(property:"passivePopupDelay", callback:{(property?:string, oldValue?:number, newValue?: number):void}) :{unwatch():void}
                /**
                 * After a menu has been activated (by clicking on it etc.), number of milliseconds before hovering
                 * (without clicking) another MenuItem causes that MenuItem's popup to automatically open.
                 *
                 */
                "popupDelay": number;
                set(property:"popupDelay", value: number): void;
                get(property:"popupDelay"): number;
                watch(property:"popupDelay", callback:{(property?:string, oldValue?:number, newValue?: number):void}) :{unwatch():void}
                /**
                 *
                 */
                "searchContainerNode": boolean;
                set(property:"searchContainerNode", value: boolean): void;
                get(property:"searchContainerNode"): boolean;
                watch(property:"searchContainerNode", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
                /**
                 * Currently selected (a.k.a. highlighted) MenuItem, or null if no MenuItem is selected.
                 * If a submenu is open, will be set to MenuItem that displayed the submenu.   OTOH, if
                 * this Menu is in passive mode (i.e. hasn't been clicked yet), will be null, because
                 * "selected" is not merely "hovered".
                 *
                 */
                "selected": Object;
                set(property:"selected", value: Object): void;
                get(property:"selected"): Object;
                watch(property:"selected", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
                /**
                 * pointer to original DOM node
                 *
                 */
                "srcNodeRef": HTMLElement;
                set(property:"srcNodeRef", value: HTMLElement): void;
                get(property:"srcNodeRef"): HTMLElement;
                watch(property:"srcNodeRef", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
                /**
                 * HTML style attributes as cssText string or name/value hash
                 *
                 */
                "style": string;
                set(property:"style", value: string): void;
                get(property:"style"): string;
                watch(property:"style", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
                /**
                 * Tab index of the container; same as HTML tabIndex attribute.
                 * Note then when user tabs into the container, focus is immediately
                 * moved to the first item in the container.
                 *
                 */
                "tabIndex": string;
                set(property:"tabIndex", value: string): void;
                get(property:"tabIndex"): string;
                watch(property:"tabIndex", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
                /**
                 * Path to template (HTML file) for this widget relative to dojo.baseUrl.
                 * Deprecated: use templateString with require([... "dojo/text!..."], ...) instead
                 *
                 */
                "templatePath": string;
                set(property:"templatePath", value: string): void;
                get(property:"templatePath"): string;
                watch(property:"templatePath", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
                /**
                 *
                 */
                "templateString": string;
                set(property:"templateString", value: string): void;
                get(property:"templateString"): string;
                watch(property:"templateString", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
                /**
                 * HTML title attribute.
                 *
                 * For form widgets this specifies a tooltip to display when hovering over
                 * the widget (just like the native HTML title attribute).
                 *
                 * For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,
                 * etc., it's used to specify the tab label, accordion pane title, etc.  In this case it's
                 * interpreted as HTML.
                 *
                 */
                "title": string;
                set(property:"title", value: string): void;
                get(property:"title"): string;
                watch(property:"title", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
                /**
                 * When this widget's title attribute is used to for a tab label, accordion pane title, etc.,
                 * this specifies the tooltip to appear when the mouse is hovered over that text.
                 *
                 */
                "tooltip": string;
                set(property:"tooltip", value: string): void;
                get(property:"tooltip"): string;
                watch(property:"tooltip", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
                /**
                 *
                 * @param widget
                 * @param insertIndex               Optional
                 */
                addChild(widget: dijit._WidgetBase, insertIndex: number): void;
                /**
                 * This method is deprecated, use get() or set() directly.
                 *
                 * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
                 * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
                 */
                attr(name: String, value: Object): any;
                /**
                 * This method is deprecated, use get() or set() directly.
                 *
                 * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
                 * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
                 */
                attr(name: Object, value: Object): any;
                /**
                 *
                 */
                buildRendering(): void;
                /**
                 * Selector (passed to on.selector()) used to identify MenuItem child widgets, but exclude inert children
                 * like MenuSeparator.  If subclass overrides to a string (ex: "> *"), the subclass must require dojo/query.
                 *
                 * @param node
                 */
                childSelector(node: HTMLElement): any;
                /**
                 * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
                 *
                 * Connects specified obj/event to specified method of this object
                 * and registers for disconnect() on widget destroy.
                 *
                 * Provide widget-specific analog to dojo.connect, except with the
                 * implicit use of this widget as the target object.
                 * Events connected with this.connect are disconnected upon
                 * destruction.
                 *
                 * @param obj
                 * @param event
                 * @param method
                 */
                connect(obj: Object, event: String, method: String): any;
                /**
                 * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
                 *
                 * Connects specified obj/event to specified method of this object
                 * and registers for disconnect() on widget destroy.
                 *
                 * Provide widget-specific analog to dojo.connect, except with the
                 * implicit use of this widget as the target object.
                 * Events connected with this.connect are disconnected upon
                 * destruction.
                 *
                 * @param obj
                 * @param event
                 * @param method
                 */
                connect(obj: any, event: String, method: String): any;
                /**
                 * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
                 *
                 * Connects specified obj/event to specified method of this object
                 * and registers for disconnect() on widget destroy.
                 *
                 * Provide widget-specific analog to dojo.connect, except with the
                 * implicit use of this widget as the target object.
                 * Events connected with this.connect are disconnected upon
                 * destruction.
                 *
                 * @param obj
                 * @param event
                 * @param method
                 */
                connect(obj: Object, event: Function, method: String): any;
                /**
                 * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
                 *
                 * Connects specified obj/event to specified method of this object
                 * and registers for disconnect() on widget destroy.
                 *
                 * Provide widget-specific analog to dojo.connect, except with the
                 * implicit use of this widget as the target object.
                 * Events connected with this.connect are disconnected upon
                 * destruction.
                 *
                 * @param obj
                 * @param event
                 * @param method
                 */
                connect(obj: any, event: Function, method: String): any;
                /**
                 * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
                 *
                 * Connects specified obj/event to specified method of this object
                 * and registers for disconnect() on widget destroy.
                 *
                 * Provide widget-specific analog to dojo.connect, except with the
                 * implicit use of this widget as the target object.
                 * Events connected with this.connect are disconnected upon
                 * destruction.
                 *
                 * @param obj
                 * @param event
                 * @param method
                 */
                connect(obj: Object, event: String, method: Function): any;
                /**
                 * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
                 *
                 * Connects specified obj/event to specified method of this object
                 * and registers for disconnect() on widget destroy.
                 *
                 * Provide widget-specific analog to dojo.connect, except with the
                 * implicit use of this widget as the target object.
                 * Events connected with this.connect are disconnected upon
                 * destruction.
                 *
                 * @param obj
                 * @param event
                 * @param method
                 */
                connect(obj: any, event: String, method: Function): any;
                /**
                 * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
                 *
                 * Connects specified obj/event to specified method of this object
                 * and registers for disconnect() on widget destroy.
                 *
                 * Provide widget-specific analog to dojo.connect, except with the
                 * implicit use of this widget as the target object.
                 * Events connected with this.connect are disconnected upon
                 * destruction.
                 *
                 * @param obj
                 * @param event
                 * @param method
                 */
                connect(obj: Object, event: Function, method: Function): any;
                /**
                 * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
                 *
                 * Connects specified obj/event to specified method of this object
                 * and registers for disconnect() on widget destroy.
                 *
                 * Provide widget-specific analog to dojo.connect, except with the
                 * implicit use of this widget as the target object.
                 * Events connected with this.connect are disconnected upon
                 * destruction.
                 *
                 * @param obj
                 * @param event
                 * @param method
                 */
                connect(obj: any, event: Function, method: Function): any;
                /**
                 * Deprecated.  You can call this in postCreate() to attach the keyboard handlers to the container,
                 * but the preferred method is to override _onLeftArrow() and _onRightArrow(), or
                 * _onUpArrow() and _onDownArrow(), to call focusPrev() and focusNext().
                 *
                 * @param prevKeyCodes Key codes for navigating to the previous child.
                 * @param nextKeyCodes Key codes for navigating to the next child.
                 */
                connectKeyNavHandlers(prevKeyCodes: dojo.keys, nextKeyCodes: dojo.keys): void;
                /**
                 * Wrapper to setTimeout to avoid deferred functions executing
                 * after the originating widget has been destroyed.
                 * Returns an object handle with a remove method (that returns null) (replaces clearTimeout).
                 *
                 * @param fcn Function reference.
                 * @param delay               OptionalDelay, defaults to 0.
                 */
                defer(fcn: Function, delay: number): Object;
                /**
                 * Destroy this widget, but not its descendants.  Descendants means widgets inside of
                 * this.containerNode.   Will also destroy any resources (including widgets) registered via this.own().
                 *
                 * This method will also destroy internal widgets such as those created from a template,
                 * assuming those widgets exist inside of this.domNode but outside of this.containerNode.
                 *
                 * For 2.0 it's planned that this method will also destroy descendant widgets, so apps should not
                 * depend on the current ability to destroy a widget without destroying its descendants.   Generally
                 * they should use destroyRecursive() for widgets with children.
                 *
                 * @param preserveDom If true, this method will leave the original DOM structure alone.Note: This will not yet work with _TemplatedMixin widgets
                 */
                destroy(preserveDom?: boolean): void;
                /**
                 * Recursively destroy the children of this widget and their
                 * descendants.
                 *
                 * @param preserveDom               OptionalIf true, the preserveDom attribute is passed to all descendantwidget's .destroy() method. Not for use with _Templatedwidgets.
                 */
                destroyDescendants(preserveDom: boolean): void;
                /**
                 * Destroy this widget and its descendants
                 * This is the generic "destructor" function that all widget users
                 * should call to cleanly discard with a widget. Once a widget is
                 * destroyed, it is removed from the manager object.
                 *
                 * @param preserveDom               OptionalIf true, this method will leave the original DOM structurealone of descendant Widgets. Note: This will NOT work withdijit._TemplatedMixin widgets.
                 */
                destroyRecursive(preserveDom: boolean): void;
                /**
                 * Destroys the DOM nodes associated with this widget.
                 *
                 * @param preserveDom               OptionalIf true, this method will leave the original DOM structure aloneduring tear-down. Note: this will not work with _Templatedwidgets yet.
                 */
                destroyRendering(preserveDom?: boolean): void;
                /**
                 * Deprecated, will be removed in 2.0, use handle.remove() instead.
                 *
                 * Disconnects handle created by connect.
                 *
                 * @param handle
                 */
                disconnect(handle: any): void;
                /**
                 * Used by widgets to signal that a synthetic event occurred, ex:
                 *
                 * myWidget.emit("attrmodified-selectedChildWidget", {}).
                 * Emits an event on this.domNode named type.toLowerCase(), based on eventObj.
                 * Also calls onType() method, if present, and returns value from that method.
                 * By default passes eventObj to callback, but will pass callbackArgs instead, if specified.
                 * Modifies eventObj by adding missing parameters (bubbles, cancelable, widget).
                 *
                 * @param type
                 * @param eventObj               Optional
                 * @param callbackArgs               Optional
                 */
                emit(type: String, eventObj: Object, callbackArgs: any[]): any;
                /**
                 * Overridden so that the previously selected value will be focused instead of only the first item
                 *
                 */
                focus(): void;
                /**
                 * Focus specified child widget.
                 *
                 * @param widget Reference to container's child widget
                 * @param last If true and if widget has multiple focusable nodes, focus thelast one instead of the first one
                 */
                focusChild(widget: dijit._WidgetBase, last: boolean): void;
                /**
                 * Focus the first focusable child in the container.
                 *
                 */
                focusFirstChild(): void;
                /**
                 * Focus the last focusable child in the container.
                 *
                 */
                focusLastChild(): void;
                /**
                 * Focus the next widget
                 *
                 */
                focusNext(): void;
                /**
                 * Focus the last focusable node in the previous widget
                 * (ex: go to the ComboButton icon section rather than button section)
                 *
                 */
                focusPrev(): void;
                /**
                 * Get a property from a widget.
                 * Get a named property from a widget. The property may
                 * potentially be retrieved via a getter method. If no getter is defined, this
                 * just retrieves the object's property.
                 *
                 * For example, if the widget has properties foo and bar
                 * and a method named _getFooAttr(), calling:
                 * myWidget.get("foo") would be equivalent to calling
                 * widget._getFooAttr() and myWidget.get("bar")
                 * would be equivalent to the expression
                 * widget.bar2
                 *
                 * @param name The property to get.
                 */
                get(name: any): any;
                /**
                 * Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent
                 * is this widget.   Note that it does not return all descendants, but rather just direct children.
                 * Analogous to Node.childNodes,
                 * except containing widgets rather than DOMNodes.
                 *
                 * The result intentionally excludes internally created widgets (a.k.a. supporting widgets)
                 * outside of this.containerNode.
                 *
                 * Note that the array returned is a simple array.  Application code should not assume
                 * existence of methods like forEach().
                 *
                 */
                getChildren(): any[];
                /**
                 * Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
                 * This method should generally be avoided as it returns widgets declared in templates, which are
                 * supposed to be internal/hidden, but it's left here for back-compat reasons.
                 *
                 */
                getDescendants(): any[];
                /**
                 * Gets the index of the child in this container or -1 if not found
                 *
                 * @param child
                 */
                getIndexOfChild(child: dijit._WidgetBase): any;
                /**
                 * Returns the parent widget of this widget.
                 *
                 */
                getParent(): any;
                /**
                 * Returns true if widget has child widgets, i.e. if this.containerNode contains widgets.
                 *
                 */
                hasChildren(): boolean;
                /**
                 * Return true if this widget can currently be focused
                 * and false if not
                 *
                 */
                isFocusable(): any;
                /**
                 * Return this widget's explicit or implicit orientation (true for LTR, false for RTL)
                 *
                 */
                isLeftToRight(): any;
                /**
                 *
                 * @param type protected
                 * @param func
                 */
                on(type: String, func: Function): any;
                /**
                 *
                 * @param type protected
                 * @param func
                 */
                on(type: Function, func: Function): any;
                /**
                 * Track specified handles and remove/destroy them when this instance is destroyed, unless they were
                 * already removed/destroyed manually.
                 *
                 */
                own(): any;
                /**
                 * Place this widget somewhere in the DOM based
                 * on standard domConstruct.place() conventions.
                 * A convenience function provided in all _Widgets, providing a simple
                 * shorthand mechanism to put an existing (or newly created) Widget
                 * somewhere in the dom, and allow chaining.
                 *
                 * @param reference Widget, DOMNode, or id of widget or DOMNode
                 * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
                 */
                placeAt(reference: String, position: String): any;
                /**
                 * Place this widget somewhere in the DOM based
                 * on standard domConstruct.place() conventions.
                 * A convenience function provided in all _Widgets, providing a simple
                 * shorthand mechanism to put an existing (or newly created) Widget
                 * somewhere in the dom, and allow chaining.
                 *
                 * @param reference Widget, DOMNode, or id of widget or DOMNode
                 * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
                 */
                placeAt(reference: HTMLElement, position: String): any;
                /**
                 * Place this widget somewhere in the DOM based
                 * on standard domConstruct.place() conventions.
                 * A convenience function provided in all _Widgets, providing a simple
                 * shorthand mechanism to put an existing (or newly created) Widget
                 * somewhere in the dom, and allow chaining.
                 *
                 * @param reference Widget, DOMNode, or id of widget or DOMNode
                 * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
                 */
                placeAt(reference: dijit._WidgetBase, position: String): any;
                /**
                 * Place this widget somewhere in the DOM based
                 * on standard domConstruct.place() conventions.
                 * A convenience function provided in all _Widgets, providing a simple
                 * shorthand mechanism to put an existing (or newly created) Widget
                 * somewhere in the dom, and allow chaining.
                 *
                 * @param reference Widget, DOMNode, or id of widget or DOMNode
                 * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
                 */
                placeAt(reference: String, position: number): any;
                /**
                 * Place this widget somewhere in the DOM based
                 * on standard domConstruct.place() conventions.
                 * A convenience function provided in all _Widgets, providing a simple
                 * shorthand mechanism to put an existing (or newly created) Widget
                 * somewhere in the dom, and allow chaining.
                 *
                 * @param reference Widget, DOMNode, or id of widget or DOMNode
                 * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
                 */
                placeAt(reference: HTMLElement, position: number): any;
                /**
                 * Place this widget somewhere in the DOM based
                 * on standard domConstruct.place() conventions.
                 * A convenience function provided in all _Widgets, providing a simple
                 * shorthand mechanism to put an existing (or newly created) Widget
                 * somewhere in the dom, and allow chaining.
                 *
                 * @param reference Widget, DOMNode, or id of widget or DOMNode
                 * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
                 */
                placeAt(reference: dijit._WidgetBase, position: number): any;
                /**
                 * stop mousemove from selecting text on IE to be consistent with other browsers
                 *
                 */
                postCreate(): void;
                /**
                 * Called after the parameters to the widget have been read-in,
                 * but before the widget template is instantiated. Especially
                 * useful to set properties that are referenced in the widget
                 * template.
                 *
                 */
                postMixInProperties(): void;
                /**
                 * Removes the passed widget instance from this widget but does
                 * not destroy it.  You can also pass in an integer indicating
                 * the index within the container to remove (ie, removeChild(5) removes the sixth widget).
                 *
                 * @param widget
                 */
                removeChild(widget: dijit._WidgetBase): void;
                /**
                 * Removes the passed widget instance from this widget but does
                 * not destroy it.  You can also pass in an integer indicating
                 * the index within the container to remove (ie, removeChild(5) removes the sixth widget).
                 *
                 * @param widget
                 */
                removeChild(widget: number): void;
                /**
                 * Set a property on a widget
                 * Sets named properties on a widget which may potentially be handled by a
                 * setter in the widget.
                 *
                 * For example, if the widget has properties foo and bar
                 * and a method named _setFooAttr(), calling
                 * myWidget.set("foo", "Howdy!") would be equivalent to calling
                 * widget._setFooAttr("Howdy!") and myWidget.set("bar", 3)
                 * would be equivalent to the statement widget.bar = 3;
                 *
                 * set() may also be called with a hash of name/value pairs, ex:
                 *
                 * myWidget.set({
                 *     foo: "Howdy",
                 *     bar: 3
                 * });
                 * This is equivalent to calling set(foo, "Howdy") and set(bar, 3)
                 *
                 * @param name The property to set.
                 * @param value The value to set in the property.
                 */
                set(name: any, value: any): any;
                /**
                 * Deprecated.  Use set() instead.
                 *
                 * @param attr
                 * @param value
                 */
                setAttribute(attr: String, value: any): void;
                /**
                 * Processing after the DOM fragment is added to the document
                 * Called after a widget and its children have been created and added to the page,
                 * and all related widgets have finished their create() cycle, up through postCreate().
                 *
                 * Note that startup() may be called while the widget is still hidden, for example if the widget is
                 * inside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.
                 * For widgets that need to do layout, it's best to put that layout code inside resize(), and then
                 * extend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.
                 *
                 */
                startup(): void;
                /**
                 *
                 */
                startupKeyNavChildren(): void;
                /**
                 * Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.
                 *
                 * Subscribes to the specified topic and calls the specified method
                 * of this object and registers for unsubscribe() on widget destroy.
                 *
                 * Provide widget-specific analog to dojo.subscribe, except with the
                 * implicit use of this widget as the target object.
                 *
                 * @param t The topic
                 * @param method The callback
                 */
                subscribe(t: String, method: Function): any;
                /**
                 * Returns a string that represents the widget.
                 * When a widget is cast to a string, this method will be used to generate the
                 * output. Currently, it does not implement any sort of reversible
                 * serialization.
                 *
                 */
                toString(): string;
                /**
                 * Deprecated. Override destroy() instead to implement custom widget tear-down
                 * behavior.
                 *
                 */
                uninitialize(): boolean;
                /**
                 * Deprecated, will be removed in 2.0, use handle.remove() instead.
                 *
                 * Unsubscribes handle created by this.subscribe.
                 * Also removes handle from this widget's list of subscriptions
                 *
                 * @param handle
                 */
                unsubscribe(handle: Object): void;
                /**
                 * Watches a property for changes
                 *
                 * @param name               OptionalIndicates the property to watch. This is optional (the callback may be theonly parameter), and if omitted, all the properties will be watched
                 * @param callback The function to execute when the property changes. This will be called afterthe property has been changed. The callback will be called with the |this|set to the instance, the first argument as the name of the property, thesecond argument as the old value and the third argument as the new value.
                 */
                watch(property: string, callback:{(property?:string, oldValue?:any, newValue?: any):void}) :{unwatch():void};
                /**
                 * Static method to get a template based on the templatePath or
                 * templateString key
                 */
                getCachedTemplate(): any;
                /**
                 * Called when the widget stops being "active" because
                 * focus moved to something outside of it, or the user
                 * clicked somewhere outside of it, or the widget was
                 * hidden.
                 *
                 */
                onBlur(): void;
                /**
                 * Attach point for notification about when the user cancels the current menu
                 * This is an internal mechanism used for Menus to signal to their parent to
                 * close them.  In general developers should not attach to or override this method.
                 *
                 * @param closeAll
                 */
                onCancel(closeAll: boolean): void;
                /**
                 * Connect to this function to receive notifications of mouse click events.
                 *
                 * @param event mouse Event
                 */
                onClick(event: any): void;
                /**
                 * Connect to this function to receive notifications of mouse double click events.
                 *
                 * @param event mouse Event
                 */
                onDblClick(event: any): void;
                /**
                 * Attach point for notification about when a menu item has been executed.
                 * This is an internal mechanism used for Menus to signal to their parent to
                 * close them, because they are about to execute the onClick handler.  In
                 * general developers should not attach to or override this method.
                 *
                 */
                onExecute(): void;
                /**
                 * Called when the widget becomes "active" because
                 * it or a widget inside of it either has focus, or has recently
                 * been clicked.
                 *
                 */
                onFocus(): void;
                /**
                 * Called when another widget becomes the selected pane in a
                 * dijit/layout/TabContainer, dijit/layout/StackContainer,
                 * dijit/layout/AccordionContainer, etc.
                 *
                 * Also called to indicate hide of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
                 *
                 */
                onHide(): void;
                /**
                 * Called when cursor is over a MenuItem.
                 *
                 * @param item
                 */
                onItemHover(item: dijit.MenuItem): void;
                /**
                 * Callback fires when mouse exits a MenuItem
                 *
                 * @param item
                 */
                onItemUnhover(item: dijit.MenuItem): void;
                /**
                 * Attach point for notification about when a menu item has been searched for
                 * via the keyboard search mechanism.
                 *
                 * @param item
                 * @param evt
                 * @param searchString
                 * @param numMatches
                 */
                onKeyboardSearch(item: dijit.MenuItem, evt: Event, searchString: String, numMatches: number): void;
                /**
                 * Connect to this function to receive notifications of keys being pressed down.
                 *
                 * @param event key Event
                 */
                onKeyDown(event: any): void;
                /**
                 * Connect to this function to receive notifications of printable keys being typed.
                 *
                 * @param event key Event
                 */
                onKeyPress(event: any): void;
                /**
                 * Connect to this function to receive notifications of keys being released.
                 *
                 * @param event key Event
                 */
                onKeyUp(event: any): void;
                /**
                 * Connect to this function to receive notifications of when the mouse button is pressed down.
                 *
                 * @param event mouse Event
                 */
                onMouseDown(event: any): void;
                /**
                 * Connect to this function to receive notifications of when the mouse moves onto this widget.
                 *
                 * @param event mouse Event
                 */
                onMouseEnter(event: any): void;
                /**
                 * Connect to this function to receive notifications of when the mouse moves off of this widget.
                 *
                 * @param event mouse Event
                 */
                onMouseLeave(event: any): void;
                /**
                 * Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.
                 *
                 * @param event mouse Event
                 */
                onMouseMove(event: any): void;
                /**
                 * Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.
                 *
                 * @param event mouse Event
                 */
                onMouseOut(event: any): void;
                /**
                 * Connect to this function to receive notifications of when the mouse moves onto nodes contained within this widget.
                 *
                 * @param event mouse Event
                 */
                onMouseOver(event: any): void;
                /**
                 * Connect to this function to receive notifications of when the mouse button is released.
                 *
                 * @param event mouse Event
                 */
                onMouseUp(event: any): void;
                /**
                 * Called when this widget becomes the selected pane in a
                 * dijit/layout/TabContainer, dijit/layout/StackContainer,
                 * dijit/layout/AccordionContainer, etc.
                 *
                 * Also called to indicate display of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
                 *
                 */
                onShow(): void;
            }
        }

        /**
         * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/FileInput.html
         *
         * A styled input type="file"
         * A input type="file" form widget, with a button for uploading to be styled via css,
         * a cancel button to clear selection, and FormWidget mixin to provide standard dijit.form.Form
         * support (FIXME: maybe not fully implemented)
         *
         * @param params Hash of initialization parameters for widget, including scalar values (like title, duration etc.)and functions, typically callbacks like onClick.The hash can contain any of the widget's properties, excluding read-only properties.
         * @param srcNodeRef       OptionalIf a srcNodeRef (DOM node) is specified:use srcNodeRef.innerHTML as my contentsif this is a behavioral widget then apply behavior to that srcNodeRefotherwise, replace srcNodeRef with my generated DOM tree
         */
        class FileInput extends dijit.form._FormWidget {
            constructor(params?: Object, srcNodeRef?: HTMLElement);
            /**
             * True if mouse was pressed while over this widget, and hasn't been released yet
             *
             */
            "active": boolean;
            set(property:"active", value: boolean): void;
            get(property:"active"): boolean;
            watch(property:"active", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "alt": string;
            set(property:"alt", value: string): void;
            get(property:"alt"): string;
            watch(property:"alt", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "aria-label": string;
            set(property:"aria-label", value: string): void;
            get(property:"aria-label"): string;
            watch(property:"aria-label", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Object to which attach points and events will be scoped.  Defaults
             * to 'this'.
             *
             */
            "attachScope": Object;
            set(property:"attachScope", value: Object): void;
            get(property:"attachScope"): Object;
            watch(property:"attachScope", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute
             * for each XXX attribute to be mapped to the DOM.
             *
             * attributeMap sets up a "binding" between attributes (aka properties)
             * of the widget and the widget's DOM.
             * Changes to widget attributes listed in attributeMap will be
             * reflected into the DOM.
             *
             * For example, calling set('title', 'hello')
             * on a TitlePane will automatically cause the TitlePane's DOM to update
             * with the new title.
             *
             * attributeMap is a hash where the key is an attribute of the widget,
             * and the value reflects a binding to a:
             *
             * DOM node attribute
             *   focus: {node: "focusNode", type: "attribute"}
             * Maps this.focus to this.focusNode.focus
             *
             * DOM node innerHTML
             *   title: { node: "titleNode", type: "innerHTML" }
             * Maps this.title to this.titleNode.innerHTML
             *
             * DOM node innerText
             *   title: { node: "titleNode", type: "innerText" }
             * Maps this.title to this.titleNode.innerText
             *
             * DOM node CSS class
             *   myClass: { node: "domNode", type: "class" }
             * Maps this.myClass to this.domNode.className
             *
             * If the value is an array, then each element in the array matches one of the
             * formats of the above list.
             *
             * There are also some shorthands for backwards compatibility:
             *
             * string --> { node: string, type: "attribute" }, for example:
             * "focusNode" ---> { node: "focusNode", type: "attribute" }
             * "" --> { node: "domNode", type: "attribute" }
             *
             */
            "attributeMap": Object;
            set(property:"attributeMap", value: Object): void;
            get(property:"attributeMap"): Object;
            watch(property:"attributeMap", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate
             * widget state.
             *
             */
            "baseClass": string;
            set(property:"baseClass", value: string): void;
            get(property:"baseClass"): string;
            watch(property:"baseClass", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * the title of the "Cancel" button
             *
             */
            "cancelText": string;
            set(property:"cancelText", value: string): void;
            get(property:"cancelText"): string;
            watch(property:"cancelText", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "class": string;
            set(property:"class", value: string): void;
            get(property:"class"): string;
            watch(property:"class", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Designates where children of the source DOM node will be placed.
             * "Children" in this case refers to both DOM nodes and widgets.
             * For example, for myWidget:
             *
             * <div data-dojo-type=myWidget>
             *     <b> here's a plain DOM node
             *     <span data-dojo-type=subWidget>and a widget</span>
             *     <i> and another plain DOM node </i>
             * </div>
             * containerNode would point to:
             *
             * <b> here's a plain DOM node
             * <span data-dojo-type=subWidget>and a widget</span>
             * <i> and another plain DOM node </i>
             * In templated widgets, "containerNode" is set via a
             * data-dojo-attach-point assignment.
             *
             * containerNode must be defined for any widget that accepts innerHTML
             * (like ContentPane or BorderContainer or even Button), and conversely
             * is null for widgets that don't, like TextBox.
             *
             */
            "containerNode": HTMLElement;
            set(property:"containerNode", value: HTMLElement): void;
            get(property:"containerNode"): HTMLElement;
            watch(property:"containerNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * Subclasses may define a cssStateNodes property that lists sub-nodes within the widget that
             * need CSS classes applied on mouse hover/press and focus.
             *
             * Each entry in this optional hash is a an attach-point name (like "upArrowButton") mapped to a CSS class name
             * (like "dijitUpArrowButton"). Example:
             *
             * {
             *     "upArrowButton": "dijitUpArrowButton",
             *     "downArrowButton": "dijitDownArrowButton"
             * }
             * The above will set the CSS class dijitUpArrowButton to the this.upArrowButton DOMNode when it
             *
             * is hovered, etc.
             *
             */
            "cssStateNodes": Object;
            set(property:"cssStateNodes", value: Object): void;
            get(property:"cssStateNodes"): Object;
            watch(property:"cssStateNodes", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Bi-directional support, as defined by the HTML DIR
             * attribute. Either left-to-right "ltr" or right-to-left "rtl".  If undefined, widgets renders in page's
             * default direction.
             *
             */
            "dir": string;
            set(property:"dir", value: string): void;
            get(property:"dir"): string;
            watch(property:"dir", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Should this widget respond to user input?
             * In markup, this is specified as "disabled='disabled'", or just "disabled".
             *
             */
            "disabled": boolean;
            set(property:"disabled", value: boolean): void;
            get(property:"disabled"): boolean;
            watch(property:"disabled", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * This is our visible representation of the widget! Other DOM
             * Nodes may by assigned to other properties, usually through the
             * template system's data-dojo-attach-point syntax, but the domNode
             * property is the canonical "top level" node in widget UI.
             *
             */
            "domNode": HTMLElement;
            set(property:"domNode", value: HTMLElement): void;
            get(property:"domNode"): HTMLElement;
            watch(property:"domNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * This widget or a widget it contains has focus, or is "active" because
             * it was recently clicked.
             *
             */
            "focused": boolean;
            set(property:"focused", value: boolean): void;
            get(property:"focused"): boolean;
            watch(property:"focused", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * True if cursor is over this widget
             *
             */
            "hovering": boolean;
            set(property:"hovering", value: boolean): void;
            get(property:"hovering"): boolean;
            watch(property:"hovering", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * A unique, opaque ID string that can be assigned by users or by the
             * system. If the developer passes an ID which is known not to be
             * unique, the specified ID is ignored and the system-generated ID is
             * used instead.
             *
             */
            "id": string;
            set(property:"id", value: string): void;
            get(property:"id"): string;
            watch(property:"id", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Fires onChange for each value change or only on demand
             *
             */
            "intermediateChanges": boolean;
            set(property:"intermediateChanges", value: boolean): void;
            get(property:"intermediateChanges"): boolean;
            watch(property:"intermediateChanges", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * the title text of the "Browse" button
             *
             */
            "label": string;
            set(property:"label", value: string): void;
            get(property:"label"): string;
            watch(property:"label", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Rarely used.  Overrides the default Dojo locale used to render this widget,
             * as defined by the HTML LANG attribute.
             * Value must be among the list of locales specified during by the Dojo bootstrap,
             * formatted according to RFC 3066 (like en-us).
             *
             */
            "lang": string;
            set(property:"lang", value: string): void;
            get(property:"lang"): string;
            watch(property:"lang", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * ugh, this should be pulled from this.domNode
             *
             */
            "name": string;
            set(property:"name", value: string): void;
            get(property:"name"): string;
            watch(property:"name", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * The document this widget belongs to.  If not specified to constructor, will default to
             * srcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global
             *
             */
            "ownerDocument": Object;
            set(property:"ownerDocument", value: Object): void;
            get(property:"ownerDocument"): Object;
            watch(property:"ownerDocument", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * On focus, should this widget scroll into view?
             *
             */
            "scrollOnFocus": boolean;
            set(property:"scrollOnFocus", value: boolean): void;
            get(property:"scrollOnFocus"): boolean;
            watch(property:"scrollOnFocus", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             *
             */
            "searchContainerNode": boolean;
            set(property:"searchContainerNode", value: boolean): void;
            get(property:"searchContainerNode"): boolean;
            watch(property:"searchContainerNode", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * pointer to original DOM node
             *
             */
            "srcNodeRef": HTMLElement;
            set(property:"srcNodeRef", value: HTMLElement): void;
            get(property:"srcNodeRef"): HTMLElement;
            watch(property:"srcNodeRef", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * HTML style attributes as cssText string or name/value hash
             *
             */
            "style": string;
            set(property:"style", value: string): void;
            get(property:"style"): string;
            watch(property:"style", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Order fields are traversed when user hits the tab key
             *
             */
            "tabIndex": string;
            set(property:"tabIndex", value: string): void;
            get(property:"tabIndex"): string;
            watch(property:"tabIndex", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Path to template (HTML file) for this widget relative to dojo.baseUrl.
             * Deprecated: use templateString with require([... "dojo/text!..."], ...) instead
             *
             */
            "templatePath": string;
            set(property:"templatePath", value: string): void;
            get(property:"templatePath"): string;
            watch(property:"templatePath", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "templateString": string;
            set(property:"templateString", value: string): void;
            get(property:"templateString"): string;
            watch(property:"templateString", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * HTML title attribute.
             *
             * For form widgets this specifies a tooltip to display when hovering over
             * the widget (just like the native HTML title attribute).
             *
             * For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,
             * etc., it's used to specify the tab label, accordion pane title, etc.  In this case it's
             * interpreted as HTML.
             *
             */
            "title": string;
            set(property:"title", value: string): void;
            get(property:"title"): string;
            watch(property:"title", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * When this widget's title attribute is used to for a tab label, accordion pane title, etc.,
             * this specifies the tooltip to appear when the mouse is hovered over that text.
             *
             */
            "tooltip": string;
            set(property:"tooltip", value: string): void;
            get(property:"tooltip"): string;
            watch(property:"tooltip", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "type": string;
            set(property:"type", value: string): void;
            get(property:"type"): string;
            watch(property:"type", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "value": string;
            set(property:"value", value: string): void;
            get(property:"value"): string;
            watch(property:"value", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: String, value: Object): any;
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: Object, value: Object): any;
            /**
             * Construct the UI for this widget, setting this.domNode.
             * Most widgets will mixin dijit._TemplatedMixin, which implements this method.
             *
             */
            buildRendering(): void;
            /**
             * Compare 2 values (as returned by get('value') for this widget).
             *
             * @param val1
             * @param val2
             */
            compare(val1: any, val2: any): number;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: Function): any;
            /**
             * Wrapper to setTimeout to avoid deferred functions executing
             * after the originating widget has been destroyed.
             * Returns an object handle with a remove method (that returns null) (replaces clearTimeout).
             *
             * @param fcn Function reference.
             * @param delay               OptionalDelay, defaults to 0.
             */
            defer(fcn: Function, delay: number): Object;
            /**
             * Destroy this widget, but not its descendants.  Descendants means widgets inside of
             * this.containerNode.   Will also destroy any resources (including widgets) registered via this.own().
             *
             * This method will also destroy internal widgets such as those created from a template,
             * assuming those widgets exist inside of this.domNode but outside of this.containerNode.
             *
             * For 2.0 it's planned that this method will also destroy descendant widgets, so apps should not
             * depend on the current ability to destroy a widget without destroying its descendants.   Generally
             * they should use destroyRecursive() for widgets with children.
             *
             * @param preserveDom If true, this method will leave the original DOM structure alone.Note: This will not yet work with _TemplatedMixin widgets
             */
            destroy(preserveDom?: boolean): void;
            /**
             * Recursively destroy the children of this widget and their
             * descendants.
             *
             * @param preserveDom               OptionalIf true, the preserveDom attribute is passed to all descendantwidget's .destroy() method. Not for use with _Templatedwidgets.
             */
            destroyDescendants(preserveDom: boolean): void;
            /**
             * Destroy this widget and its descendants
             * This is the generic "destructor" function that all widget users
             * should call to cleanly discard with a widget. Once a widget is
             * destroyed, it is removed from the manager object.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structurealone of descendant Widgets. Note: This will NOT work withdijit._TemplatedMixin widgets.
             */
            destroyRecursive(preserveDom: boolean): void;
            /**
             * Destroys the DOM nodes associated with this widget.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structure aloneduring tear-down. Note: this will not work with _Templatedwidgets yet.
             */
            destroyRendering(preserveDom?: boolean): void;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Disconnects handle created by connect.
             *
             * @param handle
             */
            disconnect(handle: any): void;
            /**
             * Used by widgets to signal that a synthetic event occurred, ex:
             *
             * myWidget.emit("attrmodified-selectedChildWidget", {}).
             * Emits an event on this.domNode named type.toLowerCase(), based on eventObj.
             * Also calls onType() method, if present, and returns value from that method.
             * By default passes eventObj to callback, but will pass callbackArgs instead, if specified.
             * Modifies eventObj by adding missing parameters (bubbles, cancelable, widget).
             *
             * @param type
             * @param eventObj               Optional
             * @param callbackArgs               Optional
             */
            emit(type: String, eventObj: Object, callbackArgs: any[]): any;
            /**
             * Put focus on this widget
             *
             */
            focus(): void;
            /**
             * Get a property from a widget.
             * Get a named property from a widget. The property may
             * potentially be retrieved via a getter method. If no getter is defined, this
             * just retrieves the object's property.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _getFooAttr(), calling:
             * myWidget.get("foo") would be equivalent to calling
             * widget._getFooAttr() and myWidget.get("bar")
             * would be equivalent to the expression
             * widget.bar2
             *
             * @param name The property to get.
             */
            get(name: any): any;
            /**
             * Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent
             * is this widget.   Note that it does not return all descendants, but rather just direct children.
             * Analogous to Node.childNodes,
             * except containing widgets rather than DOMNodes.
             *
             * The result intentionally excludes internally created widgets (a.k.a. supporting widgets)
             * outside of this.containerNode.
             *
             * Note that the array returned is a simple array.  Application code should not assume
             * existence of methods like forEach().
             *
             */
            getChildren(): any[];
            /**
             * Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
             * This method should generally be avoided as it returns widgets declared in templates, which are
             * supposed to be internal/hidden, but it's left here for back-compat reasons.
             *
             */
            getDescendants(): any[];
            /**
             * Returns the parent widget of this widget.
             *
             */
            getParent(): any;
            /**
             * Deprecated.  Use get('value') instead.
             *
             */
            getValue(): any;
            /**
             * Return true if this widget can currently be focused
             * and false if not
             *
             */
            isFocusable(): any;
            /**
             * Return this widget's explicit or implicit orientation (true for LTR, false for RTL)
             *
             */
            isLeftToRight(): any;
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: String, func: Function): any;
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: Function, func: Function): any;
            /**
             * Track specified handles and remove/destroy them when this instance is destroyed, unless they were
             * already removed/destroyed manually.
             *
             */
            own(): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: number): any;
            /**
             *
             */
            postCreate(): void;
            /**
             *
             */
            postMixInProperties(): void;
            /**
             * on click of cancel button, since we can't clear the input because of
             * security reasons, we destroy it, and add a new one in it's place.
             *
             * @param e
             */
            reset(e: Event): void;
            /**
             * Set a property on a widget
             * Sets named properties on a widget which may potentially be handled by a
             * setter in the widget.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _setFooAttr(), calling
             * myWidget.set("foo", "Howdy!") would be equivalent to calling
             * widget._setFooAttr("Howdy!") and myWidget.set("bar", 3)
             * would be equivalent to the statement widget.bar = 3;
             *
             * set() may also be called with a hash of name/value pairs, ex:
             *
             * myWidget.set({
             *     foo: "Howdy",
             *     bar: 3
             * });
             * This is equivalent to calling set(foo, "Howdy") and set(bar, 3)
             *
             * @param name The property to set.
             * @param value The value to set in the property.
             */
            set(name: any, value: any): any;
            /**
             * Deprecated.  Use set() instead.
             *
             * @param attr
             * @param value
             */
            setAttribute(attr: String, value: any): void;
            /**
             * Deprecated.  Use set('disabled', ...) instead.
             *
             * @param disabled
             */
            setDisabled(disabled: boolean): void;
            /**
             * method to allow use to change button label
             *
             * @param label
             * @param cssClass               OptionalThe class to use during the manipulation
             */
            setLabel(label: String, cssClass: String): void;
            /**
             * Deprecated.  Use set('value', ...) instead.
             *
             * @param value
             */
            setValue(value: String): void;
            /**
             * listen for changes on our real file input
             *
             */
            startup(): void;
            /**
             * Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.
             *
             * Subscribes to the specified topic and calls the specified method
             * of this object and registers for unsubscribe() on widget destroy.
             *
             * Provide widget-specific analog to dojo.subscribe, except with the
             * implicit use of this widget as the target object.
             *
             * @param t The topic
             * @param method The callback
             */
            subscribe(t: String, method: Function): any;
            /**
             * Returns a string that represents the widget.
             * When a widget is cast to a string, this method will be used to generate the
             * output. Currently, it does not implement any sort of reversible
             * serialization.
             *
             */
            toString(): string;
            /**
             * Deprecated. Override destroy() instead to implement custom widget tear-down
             * behavior.
             *
             */
            uninitialize(): boolean;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Unsubscribes handle created by this.subscribe.
             * Also removes handle from this widget's list of subscriptions
             *
             * @param handle
             */
            unsubscribe(handle: Object): void;
            /**
             * Watches a property for changes
             *
             * @param name               OptionalIndicates the property to watch. This is optional (the callback may be theonly parameter), and if omitted, all the properties will be watched
             * @param callback The function to execute when the property changes. This will be called afterthe property has been changed. The callback will be called with the |this|set to the instance, the first argument as the name of the property, thesecond argument as the old value and the third argument as the new value.
             */
            watch(property: string, callback:{(property?:string, oldValue?:any, newValue?: any):void}) :{unwatch():void};
            /**
             * Static method to get a template based on the templatePath or
             * templateString key
             */
            getCachedTemplate(): any;
            /**
             * Called when the widget stops being "active" because
             * focus moved to something outside of it, or the user
             * clicked somewhere outside of it, or the widget was
             * hidden.
             *
             */
            onBlur(): void;
            /**
             * Callback when this widget's value is changed.
             *
             * @param newValue
             */
            onChange(newValue: any): void;
            /**
             * Connect to this function to receive notifications of mouse click events.
             *
             * @param event mouse Event
             */
            onClick(event: any): void;
            /**
             * Called when this widget is being displayed as a popup (ex: a Calendar popped
             * up from a DateTextBox), and it is hidden.
             * This is called from the dijit.popup code, and should not be called directly.
             *
             * Also used as a parameter for children of dijit/layout/StackContainer or subclasses.
             * Callback if a user tries to close the child.   Child will be closed if this function returns true.
             *
             */
            onClose(): boolean;
            /**
             * Connect to this function to receive notifications of mouse double click events.
             *
             * @param event mouse Event
             */
            onDblClick(event: any): void;
            /**
             * Called when the widget becomes "active" because
             * it or a widget inside of it either has focus, or has recently
             * been clicked.
             *
             */
            onFocus(): void;
            /**
             * Called when another widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate hide of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onHide(): void;
            /**
             * Connect to this function to receive notifications of keys being pressed down.
             *
             * @param event key Event
             */
            onKeyDown(event: any): void;
            /**
             * Connect to this function to receive notifications of printable keys being typed.
             *
             * @param event key Event
             */
            onKeyPress(event: any): void;
            /**
             * Connect to this function to receive notifications of keys being released.
             *
             * @param event key Event
             */
            onKeyUp(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is pressed down.
             *
             * @param event mouse Event
             */
            onMouseDown(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto this widget.
             *
             * @param event mouse Event
             */
            onMouseEnter(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of this widget.
             *
             * @param event mouse Event
             */
            onMouseLeave(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseMove(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOut(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOver(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is released.
             *
             * @param event mouse Event
             */
            onMouseUp(event: any): void;
            /**
             * Called when this widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate display of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onShow(): void;
        }
        /**
         * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/FileInputAuto.html
         *
         * An extension on FileInput providing background upload progress
         * An extended version of FileInput - when the user focuses away from the input
         * the selected file is posted via ioIframe to the url. example implementation
         * comes with PHP solution for handling upload, and returning required data.
         *
         * notes: the return data from the io.iframe is used to populate the input element with
         * data regarding the results. it will be a JSON object, like:
         *
         * results = { size: "1024", filename: "file.txt" }
         * all the parameters allowed to FileInput apply
         *
         * @param params Hash of initialization parameters for widget, including scalar values (like title, duration etc.)and functions, typically callbacks like onClick.The hash can contain any of the widget's properties, excluding read-only properties.
         * @param srcNodeRef       OptionalIf a srcNodeRef (DOM node) is specified:use srcNodeRef.innerHTML as my contentsif this is a behavioral widget then apply behavior to that srcNodeRefotherwise, replace srcNodeRef with my generated DOM tree
         */
        class FileInputAuto extends dojox.form.FileInput {
            constructor(params?: Object, srcNodeRef?: HTMLElement);
            /**
             * True if mouse was pressed while over this widget, and hasn't been released yet
             *
             */
            "active": boolean;
            set(property:"active", value: boolean): void;
            get(property:"active"): boolean;
            watch(property:"active", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "alt": string;
            set(property:"alt", value: string): void;
            get(property:"alt"): string;
            watch(property:"alt", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "aria-label": string;
            set(property:"aria-label", value: string): void;
            get(property:"aria-label"): string;
            watch(property:"aria-label", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Object to which attach points and events will be scoped.  Defaults
             * to 'this'.
             *
             */
            "attachScope": Object;
            set(property:"attachScope", value: Object): void;
            get(property:"attachScope"): Object;
            watch(property:"attachScope", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute
             * for each XXX attribute to be mapped to the DOM.
             *
             * attributeMap sets up a "binding" between attributes (aka properties)
             * of the widget and the widget's DOM.
             * Changes to widget attributes listed in attributeMap will be
             * reflected into the DOM.
             *
             * For example, calling set('title', 'hello')
             * on a TitlePane will automatically cause the TitlePane's DOM to update
             * with the new title.
             *
             * attributeMap is a hash where the key is an attribute of the widget,
             * and the value reflects a binding to a:
             *
             * DOM node attribute
             *   focus: {node: "focusNode", type: "attribute"}
             * Maps this.focus to this.focusNode.focus
             *
             * DOM node innerHTML
             *   title: { node: "titleNode", type: "innerHTML" }
             * Maps this.title to this.titleNode.innerHTML
             *
             * DOM node innerText
             *   title: { node: "titleNode", type: "innerText" }
             * Maps this.title to this.titleNode.innerText
             *
             * DOM node CSS class
             *   myClass: { node: "domNode", type: "class" }
             * Maps this.myClass to this.domNode.className
             *
             * If the value is an array, then each element in the array matches one of the
             * formats of the above list.
             *
             * There are also some shorthands for backwards compatibility:
             *
             * string --> { node: string, type: "attribute" }, for example:
             * "focusNode" ---> { node: "focusNode", type: "attribute" }
             * "" --> { node: "domNode", type: "attribute" }
             *
             */
            "attributeMap": Object;
            set(property:"attributeMap", value: Object): void;
            get(property:"attributeMap"): Object;
            watch(property:"attributeMap", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate
             * widget state.
             *
             */
            "baseClass": string;
            set(property:"baseClass", value: string): void;
            get(property:"baseClass"): string;
            watch(property:"baseClass", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * time in ms before an un-focused widget will wait before uploading the file to the url="" specified
             * default: 2 seconds
             *
             */
            "blurDelay": number;
            set(property:"blurDelay", value: number): void;
            get(property:"blurDelay"): number;
            watch(property:"blurDelay", callback:{(property?:string, oldValue?:number, newValue?: number):void}) :{unwatch():void}
            /**
             * the title of the "Cancel" button
             *
             */
            "cancelText": string;
            set(property:"cancelText", value: string): void;
            get(property:"cancelText"): string;
            watch(property:"cancelText", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "class": string;
            set(property:"class", value: string): void;
            get(property:"class"): string;
            watch(property:"class", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Designates where children of the source DOM node will be placed.
             * "Children" in this case refers to both DOM nodes and widgets.
             * For example, for myWidget:
             *
             * <div data-dojo-type=myWidget>
             *     <b> here's a plain DOM node
             *     <span data-dojo-type=subWidget>and a widget</span>
             *     <i> and another plain DOM node </i>
             * </div>
             * containerNode would point to:
             *
             * <b> here's a plain DOM node
             * <span data-dojo-type=subWidget>and a widget</span>
             * <i> and another plain DOM node </i>
             * In templated widgets, "containerNode" is set via a
             * data-dojo-attach-point assignment.
             *
             * containerNode must be defined for any widget that accepts innerHTML
             * (like ContentPane or BorderContainer or even Button), and conversely
             * is null for widgets that don't, like TextBox.
             *
             */
            "containerNode": HTMLElement;
            set(property:"containerNode", value: HTMLElement): void;
            get(property:"containerNode"): HTMLElement;
            watch(property:"containerNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * Subclasses may define a cssStateNodes property that lists sub-nodes within the widget that
             * need CSS classes applied on mouse hover/press and focus.
             *
             * Each entry in this optional hash is a an attach-point name (like "upArrowButton") mapped to a CSS class name
             * (like "dijitUpArrowButton"). Example:
             *
             * {
             *     "upArrowButton": "dijitUpArrowButton",
             *     "downArrowButton": "dijitDownArrowButton"
             * }
             * The above will set the CSS class dijitUpArrowButton to the this.upArrowButton DOMNode when it
             *
             * is hovered, etc.
             *
             */
            "cssStateNodes": Object;
            set(property:"cssStateNodes", value: Object): void;
            get(property:"cssStateNodes"): Object;
            watch(property:"cssStateNodes", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Bi-directional support, as defined by the HTML DIR
             * attribute. Either left-to-right "ltr" or right-to-left "rtl".  If undefined, widgets renders in page's
             * default direction.
             *
             */
            "dir": string;
            set(property:"dir", value: string): void;
            get(property:"dir"): string;
            watch(property:"dir", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Should this widget respond to user input?
             * In markup, this is specified as "disabled='disabled'", or just "disabled".
             *
             */
            "disabled": boolean;
            set(property:"disabled", value: boolean): void;
            get(property:"disabled"): boolean;
            watch(property:"disabled", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * This is our visible representation of the widget! Other DOM
             * Nodes may by assigned to other properties, usually through the
             * template system's data-dojo-attach-point syntax, but the domNode
             * property is the canonical "top level" node in widget UI.
             *
             */
            "domNode": HTMLElement;
            set(property:"domNode", value: HTMLElement): void;
            get(property:"domNode"): HTMLElement;
            watch(property:"domNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * The time in ms to use as the generic timing mechanism for the animations
             * set to 1 or 0 for "immediate response"
             *
             */
            "duration": number;
            set(property:"duration", value: number): void;
            get(property:"duration"): number;
            watch(property:"duration", callback:{(property?:string, oldValue?:number, newValue?: number):void}) :{unwatch():void}
            /**
             * This widget or a widget it contains has focus, or is "active" because
             * it was recently clicked.
             *
             */
            "focused": boolean;
            set(property:"focused", value: boolean): void;
            get(property:"focused"): boolean;
            watch(property:"focused", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * True if cursor is over this widget
             *
             */
            "hovering": boolean;
            set(property:"hovering", value: boolean): void;
            get(property:"hovering"): boolean;
            watch(property:"hovering", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * A unique, opaque ID string that can be assigned by users or by the
             * system. If the developer passes an ID which is known not to be
             * unique, the specified ID is ignored and the system-generated ID is
             * used instead.
             *
             */
            "id": string;
            set(property:"id", value: string): void;
            get(property:"id"): string;
            watch(property:"id", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Fires onChange for each value change or only on demand
             *
             */
            "intermediateChanges": boolean;
            set(property:"intermediateChanges", value: boolean): void;
            get(property:"intermediateChanges"): boolean;
            watch(property:"intermediateChanges", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * the title text of the "Browse" button
             *
             */
            "label": string;
            set(property:"label", value: string): void;
            get(property:"label"): string;
            watch(property:"label", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Rarely used.  Overrides the default Dojo locale used to render this widget,
             * as defined by the HTML LANG attribute.
             * Value must be among the list of locales specified during by the Dojo bootstrap,
             * formatted according to RFC 3066 (like en-us).
             *
             */
            "lang": string;
            set(property:"lang", value: string): void;
            get(property:"lang"): string;
            watch(property:"lang", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * ugh, this should be pulled from this.domNode
             *
             */
            "name": string;
            set(property:"name", value: string): void;
            get(property:"name"): string;
            watch(property:"name", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * The document this widget belongs to.  If not specified to constructor, will default to
             * srcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global
             *
             */
            "ownerDocument": Object;
            set(property:"ownerDocument", value: Object): void;
            get(property:"ownerDocument"): Object;
            watch(property:"ownerDocument", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * On focus, should this widget scroll into view?
             *
             */
            "scrollOnFocus": boolean;
            set(property:"scrollOnFocus", value: boolean): void;
            get(property:"scrollOnFocus"): boolean;
            watch(property:"scrollOnFocus", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             *
             */
            "searchContainerNode": boolean;
            set(property:"searchContainerNode", value: boolean): void;
            get(property:"searchContainerNode"): boolean;
            watch(property:"searchContainerNode", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * pointer to original DOM node
             *
             */
            "srcNodeRef": HTMLElement;
            set(property:"srcNodeRef", value: HTMLElement): void;
            get(property:"srcNodeRef"): HTMLElement;
            watch(property:"srcNodeRef", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * HTML style attributes as cssText string or name/value hash
             *
             */
            "style": string;
            set(property:"style", value: string): void;
            get(property:"style"): string;
            watch(property:"style", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Order fields are traversed when user hits the tab key
             *
             */
            "tabIndex": string;
            set(property:"tabIndex", value: string): void;
            get(property:"tabIndex"): string;
            watch(property:"tabIndex", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Path to template (HTML file) for this widget relative to dojo.baseUrl.
             * Deprecated: use templateString with require([... "dojo/text!..."], ...) instead
             *
             */
            "templatePath": string;
            set(property:"templatePath", value: string): void;
            get(property:"templatePath"): string;
            watch(property:"templatePath", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "templateString": string;
            set(property:"templateString", value: string): void;
            get(property:"templateString"): string;
            watch(property:"templateString", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * HTML title attribute.
             *
             * For form widgets this specifies a tooltip to display when hovering over
             * the widget (just like the native HTML title attribute).
             *
             * For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,
             * etc., it's used to specify the tab label, accordion pane title, etc.  In this case it's
             * interpreted as HTML.
             *
             */
            "title": string;
            set(property:"title", value: string): void;
            get(property:"title"): string;
            watch(property:"title", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * When this widget's title attribute is used to for a tab label, accordion pane title, etc.,
             * this specifies the tooltip to appear when the mouse is hovered over that text.
             *
             */
            "tooltip": string;
            set(property:"tooltip", value: string): void;
            get(property:"tooltip"): string;
            watch(property:"tooltip", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Event which triggers the upload. Defaults to onblur, sending the file selected
             * 'blurDelay' milliseconds after losing focus. Set to "onchange" with a low blurDelay
             * to send files immediately after uploading.
             *
             */
            "triggerEvent": string;
            set(property:"triggerEvent", value: string): void;
            get(property:"triggerEvent"): string;
            watch(property:"triggerEvent", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "type": string;
            set(property:"type", value: string): void;
            get(property:"type"): string;
            watch(property:"type", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * FIXME: i18n somehow?
             *
             */
            "uploadMessage": string;
            set(property:"uploadMessage", value: string): void;
            get(property:"uploadMessage"): string;
            watch(property:"uploadMessage", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * the URL where our background FileUpload will be sent
             *
             */
            "url": string;
            set(property:"url", value: string): void;
            get(property:"url"): string;
            watch(property:"url", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "value": string;
            set(property:"value", value: string): void;
            get(property:"value"): string;
            watch(property:"value", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: String, value: Object): any;
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: Object, value: Object): any;
            /**
             * Construct the UI for this widget, setting this.domNode.
             * Most widgets will mixin dijit._TemplatedMixin, which implements this method.
             *
             */
            buildRendering(): void;
            /**
             * Compare 2 values (as returned by get('value') for this widget).
             *
             * @param val1
             * @param val2
             */
            compare(val1: any, val2: any): number;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: Function): any;
            /**
             * Wrapper to setTimeout to avoid deferred functions executing
             * after the originating widget has been destroyed.
             * Returns an object handle with a remove method (that returns null) (replaces clearTimeout).
             *
             * @param fcn Function reference.
             * @param delay               OptionalDelay, defaults to 0.
             */
            defer(fcn: Function, delay: number): Object;
            /**
             * Destroy this widget, but not its descendants.  Descendants means widgets inside of
             * this.containerNode.   Will also destroy any resources (including widgets) registered via this.own().
             *
             * This method will also destroy internal widgets such as those created from a template,
             * assuming those widgets exist inside of this.domNode but outside of this.containerNode.
             *
             * For 2.0 it's planned that this method will also destroy descendant widgets, so apps should not
             * depend on the current ability to destroy a widget without destroying its descendants.   Generally
             * they should use destroyRecursive() for widgets with children.
             *
             * @param preserveDom If true, this method will leave the original DOM structure alone.Note: This will not yet work with _TemplatedMixin widgets
             */
            destroy(preserveDom?: boolean): void;
            /**
             * Recursively destroy the children of this widget and their
             * descendants.
             *
             * @param preserveDom               OptionalIf true, the preserveDom attribute is passed to all descendantwidget's .destroy() method. Not for use with _Templatedwidgets.
             */
            destroyDescendants(preserveDom: boolean): void;
            /**
             * Destroy this widget and its descendants
             * This is the generic "destructor" function that all widget users
             * should call to cleanly discard with a widget. Once a widget is
             * destroyed, it is removed from the manager object.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structurealone of descendant Widgets. Note: This will NOT work withdijit._TemplatedMixin widgets.
             */
            destroyRecursive(preserveDom: boolean): void;
            /**
             * Destroys the DOM nodes associated with this widget.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structure aloneduring tear-down. Note: this will not work with _Templatedwidgets yet.
             */
            destroyRendering(preserveDom?: boolean): void;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Disconnects handle created by connect.
             *
             * @param handle
             */
            disconnect(handle: any): void;
            /**
             * Used by widgets to signal that a synthetic event occurred, ex:
             *
             * myWidget.emit("attrmodified-selectedChildWidget", {}).
             * Emits an event on this.domNode named type.toLowerCase(), based on eventObj.
             * Also calls onType() method, if present, and returns value from that method.
             * By default passes eventObj to callback, but will pass callbackArgs instead, if specified.
             * Modifies eventObj by adding missing parameters (bubbles, cancelable, widget).
             *
             * @param type
             * @param eventObj               Optional
             * @param callbackArgs               Optional
             */
            emit(type: String, eventObj: Object, callbackArgs: any[]): any;
            /**
             * Put focus on this widget
             *
             */
            focus(): void;
            /**
             * Get a property from a widget.
             * Get a named property from a widget. The property may
             * potentially be retrieved via a getter method. If no getter is defined, this
             * just retrieves the object's property.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _getFooAttr(), calling:
             * myWidget.get("foo") would be equivalent to calling
             * widget._getFooAttr() and myWidget.get("bar")
             * would be equivalent to the expression
             * widget.bar2
             *
             * @param name The property to get.
             */
            get(name: any): any;
            /**
             * Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent
             * is this widget.   Note that it does not return all descendants, but rather just direct children.
             * Analogous to Node.childNodes,
             * except containing widgets rather than DOMNodes.
             *
             * The result intentionally excludes internally created widgets (a.k.a. supporting widgets)
             * outside of this.containerNode.
             *
             * Note that the array returned is a simple array.  Application code should not assume
             * existence of methods like forEach().
             *
             */
            getChildren(): any[];
            /**
             * Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
             * This method should generally be avoided as it returns widgets declared in templates, which are
             * supposed to be internal/hidden, but it's left here for back-compat reasons.
             *
             */
            getDescendants(): any[];
            /**
             * Returns the parent widget of this widget.
             *
             */
            getParent(): any;
            /**
             * Deprecated.  Use get('value') instead.
             *
             */
            getValue(): any;
            /**
             * Return true if this widget can currently be focused
             * and false if not
             *
             */
            isFocusable(): any;
            /**
             * Return this widget's explicit or implicit orientation (true for LTR, false for RTL)
             *
             */
            isLeftToRight(): any;
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: String, func: Function): any;
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: Function, func: Function): any;
            /**
             * Track specified handles and remove/destroy them when this instance is destroyed, unless they were
             * already removed/destroyed manually.
             *
             */
            own(): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: number): any;
            /**
             *
             */
            postCreate(): void;
            /**
             *
             */
            postMixInProperties(): void;
            /**
             * accommodate our extra focusListeners
             *
             * @param e
             */
            reset(e: any): void;
            /**
             * Set a property on a widget
             * Sets named properties on a widget which may potentially be handled by a
             * setter in the widget.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _setFooAttr(), calling
             * myWidget.set("foo", "Howdy!") would be equivalent to calling
             * widget._setFooAttr("Howdy!") and myWidget.set("bar", 3)
             * would be equivalent to the statement widget.bar = 3;
             *
             * set() may also be called with a hash of name/value pairs, ex:
             *
             * myWidget.set({
             *     foo: "Howdy",
             *     bar: 3
             * });
             * This is equivalent to calling set(foo, "Howdy") and set(bar, 3)
             *
             * @param name The property to set.
             * @param value The value to set in the property.
             */
            set(name: any, value: any): any;
            /**
             * Deprecated.  Use set() instead.
             *
             * @param attr
             * @param value
             */
            setAttribute(attr: String, value: any): void;
            /**
             * Deprecated.  Use set('disabled', ...) instead.
             *
             * @param disabled
             */
            setDisabled(disabled: boolean): void;
            /**
             * method to allow use to change button label
             *
             * @param label
             * @param cssClass               OptionalThe class to use during the manipulation
             */
            setLabel(label: String, cssClass: String): void;
            /**
             * set the text of the progressbar
             *
             * @param title
             */
            setMessage(title: String): void;
            /**
             * Deprecated.  Use set('value', ...) instead.
             *
             * @param value
             */
            setValue(value: String): void;
            /**
             * add our extra blur listeners
             *
             */
            startup(): void;
            /**
             * Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.
             *
             * Subscribes to the specified topic and calls the specified method
             * of this object and registers for unsubscribe() on widget destroy.
             *
             * Provide widget-specific analog to dojo.subscribe, except with the
             * implicit use of this widget as the target object.
             *
             * @param t The topic
             * @param method The callback
             */
            subscribe(t: String, method: Function): any;
            /**
             * Returns a string that represents the widget.
             * When a widget is cast to a string, this method will be used to generate the
             * output. Currently, it does not implement any sort of reversible
             * serialization.
             *
             */
            toString(): string;
            /**
             * Deprecated. Override destroy() instead to implement custom widget tear-down
             * behavior.
             *
             */
            uninitialize(): boolean;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Unsubscribes handle created by this.subscribe.
             * Also removes handle from this widget's list of subscriptions
             *
             * @param handle
             */
            unsubscribe(handle: Object): void;
            /**
             * Watches a property for changes
             *
             * @param name               OptionalIndicates the property to watch. This is optional (the callback may be theonly parameter), and if omitted, all the properties will be watched
             * @param callback The function to execute when the property changes. This will be called afterthe property has been changed. The callback will be called with the |this|set to the instance, the first argument as the name of the property, thesecond argument as the old value and the third argument as the new value.
             */
            watch(property: string, callback:{(property?:string, oldValue?:any, newValue?: any):void}) :{unwatch():void};
            /**
             * Static method to get a template based on the templatePath or
             * templateString key
             */
            getCachedTemplate(): any;
            /**
             * Called immediately before a FileInput sends it's file via io.iframe.send.
             * The return of this function is passed as the content member in the io.iframe IOArgs
             * object.
             *
             */
            onBeforeSend(): Object;
            /**
             * Called when the widget stops being "active" because
             * focus moved to something outside of it, or the user
             * clicked somewhere outside of it, or the widget was
             * hidden.
             *
             */
            onBlur(): void;
            /**
             * Callback when this widget's value is changed.
             *
             * @param newValue
             */
            onChange(newValue: any): void;
            /**
             * Connect to this function to receive notifications of mouse click events.
             *
             * @param event mouse Event
             */
            onClick(event: any): void;
            /**
             * Called when this widget is being displayed as a popup (ex: a Calendar popped
             * up from a DateTextBox), and it is hidden.
             * This is called from the dijit.popup code, and should not be called directly.
             *
             * Also used as a parameter for children of dijit/layout/StackContainer or subclasses.
             * Callback if a user tries to close the child.   Child will be closed if this function returns true.
             *
             */
            onClose(): boolean;
            /**
             * stub function fired when an upload has finished.
             *
             * @param data the raw data found in the first [TEXTAREA] tag of the post url
             * @param ioArgs the Deferred data being passed from the handle: callback
             * @param widgetRef this widget pointer, so you can set this.overlay to a completed/error message easily
             */
            onComplete(data: any, ioArgs: any, widgetRef: any): void;
            /**
             * Connect to this function to receive notifications of mouse double click events.
             *
             * @param event mouse Event
             */
            onDblClick(event: any): void;
            /**
             * Called when the widget becomes "active" because
             * it or a widget inside of it either has focus, or has recently
             * been clicked.
             *
             */
            onFocus(): void;
            /**
             * Called when another widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate hide of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onHide(): void;
            /**
             * Connect to this function to receive notifications of keys being pressed down.
             *
             * @param event key Event
             */
            onKeyDown(event: any): void;
            /**
             * Connect to this function to receive notifications of printable keys being typed.
             *
             * @param event key Event
             */
            onKeyPress(event: any): void;
            /**
             * Connect to this function to receive notifications of keys being released.
             *
             * @param event key Event
             */
            onKeyUp(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is pressed down.
             *
             * @param event mouse Event
             */
            onMouseDown(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto this widget.
             *
             * @param event mouse Event
             */
            onMouseEnter(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of this widget.
             *
             * @param event mouse Event
             */
            onMouseLeave(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseMove(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOut(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOver(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is released.
             *
             * @param event mouse Event
             */
            onMouseUp(event: any): void;
            /**
             * Called when this widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate display of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onShow(): void;
        }
        /**
         * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/FileInputBlind.html
         *
         * An extension on FileInput providing background upload progress
         * An extended version of FileInput - when the user focuses away from the input
         * the selected file is posted via ioIframe to the url. example implementation
         * comes with PHP solution for handling upload, and returning required data.
         *
         * notes: the return data from the io.iframe is used to populate the input element with
         * data regarding the results. it will be a JSON object, like:
         *
         * results = { size: "1024", filename: "file.txt" }
         * all the parameters allowed to FileInput apply
         *
         * @param params Hash of initialization parameters for widget, including scalar values (like title, duration etc.)and functions, typically callbacks like onClick.The hash can contain any of the widget's properties, excluding read-only properties.
         * @param srcNodeRef       OptionalIf a srcNodeRef (DOM node) is specified:use srcNodeRef.innerHTML as my contentsif this is a behavioral widget then apply behavior to that srcNodeRefotherwise, replace srcNodeRef with my generated DOM tree
         */
        class FileInputBlind extends dojox.form.FileInput {
            constructor(params?: Object, srcNodeRef?: HTMLElement);
            /**
             * True if mouse was pressed while over this widget, and hasn't been released yet
             *
             */
            "active": boolean;
            set(property:"active", value: boolean): void;
            get(property:"active"): boolean;
            watch(property:"active", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "alt": string;
            set(property:"alt", value: string): void;
            get(property:"alt"): string;
            watch(property:"alt", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "aria-label": string;
            set(property:"aria-label", value: string): void;
            get(property:"aria-label"): string;
            watch(property:"aria-label", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Object to which attach points and events will be scoped.  Defaults
             * to 'this'.
             *
             */
            "attachScope": Object;
            set(property:"attachScope", value: Object): void;
            get(property:"attachScope"): Object;
            watch(property:"attachScope", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute
             * for each XXX attribute to be mapped to the DOM.
             *
             * attributeMap sets up a "binding" between attributes (aka properties)
             * of the widget and the widget's DOM.
             * Changes to widget attributes listed in attributeMap will be
             * reflected into the DOM.
             *
             * For example, calling set('title', 'hello')
             * on a TitlePane will automatically cause the TitlePane's DOM to update
             * with the new title.
             *
             * attributeMap is a hash where the key is an attribute of the widget,
             * and the value reflects a binding to a:
             *
             * DOM node attribute
             *   focus: {node: "focusNode", type: "attribute"}
             * Maps this.focus to this.focusNode.focus
             *
             * DOM node innerHTML
             *   title: { node: "titleNode", type: "innerHTML" }
             * Maps this.title to this.titleNode.innerHTML
             *
             * DOM node innerText
             *   title: { node: "titleNode", type: "innerText" }
             * Maps this.title to this.titleNode.innerText
             *
             * DOM node CSS class
             *   myClass: { node: "domNode", type: "class" }
             * Maps this.myClass to this.domNode.className
             *
             * If the value is an array, then each element in the array matches one of the
             * formats of the above list.
             *
             * There are also some shorthands for backwards compatibility:
             *
             * string --> { node: string, type: "attribute" }, for example:
             * "focusNode" ---> { node: "focusNode", type: "attribute" }
             * "" --> { node: "domNode", type: "attribute" }
             *
             */
            "attributeMap": Object;
            set(property:"attributeMap", value: Object): void;
            get(property:"attributeMap"): Object;
            watch(property:"attributeMap", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate
             * widget state.
             *
             */
            "baseClass": string;
            set(property:"baseClass", value: string): void;
            get(property:"baseClass"): string;
            watch(property:"baseClass", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * time in ms before an un-focused widget will wait before uploading the file to the url="" specified
             * default: 2 seconds
             *
             */
            "blurDelay": number;
            set(property:"blurDelay", value: number): void;
            get(property:"blurDelay"): number;
            watch(property:"blurDelay", callback:{(property?:string, oldValue?:number, newValue?: number):void}) :{unwatch():void}
            /**
             * the title of the "Cancel" button
             *
             */
            "cancelText": string;
            set(property:"cancelText", value: string): void;
            get(property:"cancelText"): string;
            watch(property:"cancelText", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "class": string;
            set(property:"class", value: string): void;
            get(property:"class"): string;
            watch(property:"class", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Designates where children of the source DOM node will be placed.
             * "Children" in this case refers to both DOM nodes and widgets.
             * For example, for myWidget:
             *
             * <div data-dojo-type=myWidget>
             *     <b> here's a plain DOM node
             *     <span data-dojo-type=subWidget>and a widget</span>
             *     <i> and another plain DOM node </i>
             * </div>
             * containerNode would point to:
             *
             * <b> here's a plain DOM node
             * <span data-dojo-type=subWidget>and a widget</span>
             * <i> and another plain DOM node </i>
             * In templated widgets, "containerNode" is set via a
             * data-dojo-attach-point assignment.
             *
             * containerNode must be defined for any widget that accepts innerHTML
             * (like ContentPane or BorderContainer or even Button), and conversely
             * is null for widgets that don't, like TextBox.
             *
             */
            "containerNode": HTMLElement;
            set(property:"containerNode", value: HTMLElement): void;
            get(property:"containerNode"): HTMLElement;
            watch(property:"containerNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * Subclasses may define a cssStateNodes property that lists sub-nodes within the widget that
             * need CSS classes applied on mouse hover/press and focus.
             *
             * Each entry in this optional hash is a an attach-point name (like "upArrowButton") mapped to a CSS class name
             * (like "dijitUpArrowButton"). Example:
             *
             * {
             *     "upArrowButton": "dijitUpArrowButton",
             *     "downArrowButton": "dijitDownArrowButton"
             * }
             * The above will set the CSS class dijitUpArrowButton to the this.upArrowButton DOMNode when it
             *
             * is hovered, etc.
             *
             */
            "cssStateNodes": Object;
            set(property:"cssStateNodes", value: Object): void;
            get(property:"cssStateNodes"): Object;
            watch(property:"cssStateNodes", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Bi-directional support, as defined by the HTML DIR
             * attribute. Either left-to-right "ltr" or right-to-left "rtl".  If undefined, widgets renders in page's
             * default direction.
             *
             */
            "dir": string;
            set(property:"dir", value: string): void;
            get(property:"dir"): string;
            watch(property:"dir", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Should this widget respond to user input?
             * In markup, this is specified as "disabled='disabled'", or just "disabled".
             *
             */
            "disabled": boolean;
            set(property:"disabled", value: boolean): void;
            get(property:"disabled"): boolean;
            watch(property:"disabled", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * This is our visible representation of the widget! Other DOM
             * Nodes may by assigned to other properties, usually through the
             * template system's data-dojo-attach-point syntax, but the domNode
             * property is the canonical "top level" node in widget UI.
             *
             */
            "domNode": HTMLElement;
            set(property:"domNode", value: HTMLElement): void;
            get(property:"domNode"): HTMLElement;
            watch(property:"domNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * The time in ms to use as the generic timing mechanism for the animations
             * set to 1 or 0 for "immediate response"
             *
             */
            "duration": number;
            set(property:"duration", value: number): void;
            get(property:"duration"): number;
            watch(property:"duration", callback:{(property?:string, oldValue?:number, newValue?: number):void}) :{unwatch():void}
            /**
             * This widget or a widget it contains has focus, or is "active" because
             * it was recently clicked.
             *
             */
            "focused": boolean;
            set(property:"focused", value: boolean): void;
            get(property:"focused"): boolean;
            watch(property:"focused", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * True if cursor is over this widget
             *
             */
            "hovering": boolean;
            set(property:"hovering", value: boolean): void;
            get(property:"hovering"): boolean;
            watch(property:"hovering", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * A unique, opaque ID string that can be assigned by users or by the
             * system. If the developer passes an ID which is known not to be
             * unique, the specified ID is ignored and the system-generated ID is
             * used instead.
             *
             */
            "id": string;
            set(property:"id", value: string): void;
            get(property:"id"): string;
            watch(property:"id", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Fires onChange for each value change or only on demand
             *
             */
            "intermediateChanges": boolean;
            set(property:"intermediateChanges", value: boolean): void;
            get(property:"intermediateChanges"): boolean;
            watch(property:"intermediateChanges", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * the title text of the "Browse" button
             *
             */
            "label": string;
            set(property:"label", value: string): void;
            get(property:"label"): string;
            watch(property:"label", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Rarely used.  Overrides the default Dojo locale used to render this widget,
             * as defined by the HTML LANG attribute.
             * Value must be among the list of locales specified during by the Dojo bootstrap,
             * formatted according to RFC 3066 (like en-us).
             *
             */
            "lang": string;
            set(property:"lang", value: string): void;
            get(property:"lang"): string;
            watch(property:"lang", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * ugh, this should be pulled from this.domNode
             *
             */
            "name": string;
            set(property:"name", value: string): void;
            get(property:"name"): string;
            watch(property:"name", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * The document this widget belongs to.  If not specified to constructor, will default to
             * srcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global
             *
             */
            "ownerDocument": Object;
            set(property:"ownerDocument", value: Object): void;
            get(property:"ownerDocument"): Object;
            watch(property:"ownerDocument", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * On focus, should this widget scroll into view?
             *
             */
            "scrollOnFocus": boolean;
            set(property:"scrollOnFocus", value: boolean): void;
            get(property:"scrollOnFocus"): boolean;
            watch(property:"scrollOnFocus", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             *
             */
            "searchContainerNode": boolean;
            set(property:"searchContainerNode", value: boolean): void;
            get(property:"searchContainerNode"): boolean;
            watch(property:"searchContainerNode", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * pointer to original DOM node
             *
             */
            "srcNodeRef": HTMLElement;
            set(property:"srcNodeRef", value: HTMLElement): void;
            get(property:"srcNodeRef"): HTMLElement;
            watch(property:"srcNodeRef", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * HTML style attributes as cssText string or name/value hash
             *
             */
            "style": string;
            set(property:"style", value: string): void;
            get(property:"style"): string;
            watch(property:"style", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Order fields are traversed when user hits the tab key
             *
             */
            "tabIndex": string;
            set(property:"tabIndex", value: string): void;
            get(property:"tabIndex"): string;
            watch(property:"tabIndex", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Path to template (HTML file) for this widget relative to dojo.baseUrl.
             * Deprecated: use templateString with require([... "dojo/text!..."], ...) instead
             *
             */
            "templatePath": string;
            set(property:"templatePath", value: string): void;
            get(property:"templatePath"): string;
            watch(property:"templatePath", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "templateString": string;
            set(property:"templateString", value: string): void;
            get(property:"templateString"): string;
            watch(property:"templateString", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * HTML title attribute.
             *
             * For form widgets this specifies a tooltip to display when hovering over
             * the widget (just like the native HTML title attribute).
             *
             * For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,
             * etc., it's used to specify the tab label, accordion pane title, etc.  In this case it's
             * interpreted as HTML.
             *
             */
            "title": string;
            set(property:"title", value: string): void;
            get(property:"title"): string;
            watch(property:"title", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * When this widget's title attribute is used to for a tab label, accordion pane title, etc.,
             * this specifies the tooltip to appear when the mouse is hovered over that text.
             *
             */
            "tooltip": string;
            set(property:"tooltip", value: string): void;
            get(property:"tooltip"): string;
            watch(property:"tooltip", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Event which triggers the upload. Defaults to onblur, sending the file selected
             * 'blurDelay' milliseconds after losing focus. Set to "onchange" with a low blurDelay
             * to send files immediately after uploading.
             *
             */
            "triggerEvent": string;
            set(property:"triggerEvent", value: string): void;
            get(property:"triggerEvent"): string;
            watch(property:"triggerEvent", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "type": string;
            set(property:"type", value: string): void;
            get(property:"type"): string;
            watch(property:"type", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * FIXME: i18n somehow?
             *
             */
            "uploadMessage": string;
            set(property:"uploadMessage", value: string): void;
            get(property:"uploadMessage"): string;
            watch(property:"uploadMessage", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * the URL where our background FileUpload will be sent
             *
             */
            "url": string;
            set(property:"url", value: string): void;
            get(property:"url"): string;
            watch(property:"url", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "value": string;
            set(property:"value", value: string): void;
            get(property:"value"): string;
            watch(property:"value", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: String, value: Object): any;
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: Object, value: Object): any;
            /**
             * Construct the UI for this widget, setting this.domNode.
             * Most widgets will mixin dijit._TemplatedMixin, which implements this method.
             *
             */
            buildRendering(): void;
            /**
             * Compare 2 values (as returned by get('value') for this widget).
             *
             * @param val1
             * @param val2
             */
            compare(val1: any, val2: any): number;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: Function): any;
            /**
             * Wrapper to setTimeout to avoid deferred functions executing
             * after the originating widget has been destroyed.
             * Returns an object handle with a remove method (that returns null) (replaces clearTimeout).
             *
             * @param fcn Function reference.
             * @param delay               OptionalDelay, defaults to 0.
             */
            defer(fcn: Function, delay: number): Object;
            /**
             * Destroy this widget, but not its descendants.  Descendants means widgets inside of
             * this.containerNode.   Will also destroy any resources (including widgets) registered via this.own().
             *
             * This method will also destroy internal widgets such as those created from a template,
             * assuming those widgets exist inside of this.domNode but outside of this.containerNode.
             *
             * For 2.0 it's planned that this method will also destroy descendant widgets, so apps should not
             * depend on the current ability to destroy a widget without destroying its descendants.   Generally
             * they should use destroyRecursive() for widgets with children.
             *
             * @param preserveDom If true, this method will leave the original DOM structure alone.Note: This will not yet work with _TemplatedMixin widgets
             */
            destroy(preserveDom?: boolean): void;
            /**
             * Recursively destroy the children of this widget and their
             * descendants.
             *
             * @param preserveDom               OptionalIf true, the preserveDom attribute is passed to all descendantwidget's .destroy() method. Not for use with _Templatedwidgets.
             */
            destroyDescendants(preserveDom: boolean): void;
            /**
             * Destroy this widget and its descendants
             * This is the generic "destructor" function that all widget users
             * should call to cleanly discard with a widget. Once a widget is
             * destroyed, it is removed from the manager object.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structurealone of descendant Widgets. Note: This will NOT work withdijit._TemplatedMixin widgets.
             */
            destroyRecursive(preserveDom: boolean): void;
            /**
             * Destroys the DOM nodes associated with this widget.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structure aloneduring tear-down. Note: this will not work with _Templatedwidgets yet.
             */
            destroyRendering(preserveDom?: boolean): void;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Disconnects handle created by connect.
             *
             * @param handle
             */
            disconnect(handle: any): void;
            /**
             * Used by widgets to signal that a synthetic event occurred, ex:
             *
             * myWidget.emit("attrmodified-selectedChildWidget", {}).
             * Emits an event on this.domNode named type.toLowerCase(), based on eventObj.
             * Also calls onType() method, if present, and returns value from that method.
             * By default passes eventObj to callback, but will pass callbackArgs instead, if specified.
             * Modifies eventObj by adding missing parameters (bubbles, cancelable, widget).
             *
             * @param type
             * @param eventObj               Optional
             * @param callbackArgs               Optional
             */
            emit(type: String, eventObj: Object, callbackArgs: any[]): any;
            /**
             * Put focus on this widget
             *
             */
            focus(): void;
            /**
             * Get a property from a widget.
             * Get a named property from a widget. The property may
             * potentially be retrieved via a getter method. If no getter is defined, this
             * just retrieves the object's property.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _getFooAttr(), calling:
             * myWidget.get("foo") would be equivalent to calling
             * widget._getFooAttr() and myWidget.get("bar")
             * would be equivalent to the expression
             * widget.bar2
             *
             * @param name The property to get.
             */
            get(name: any): any;
            /**
             * Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent
             * is this widget.   Note that it does not return all descendants, but rather just direct children.
             * Analogous to Node.childNodes,
             * except containing widgets rather than DOMNodes.
             *
             * The result intentionally excludes internally created widgets (a.k.a. supporting widgets)
             * outside of this.containerNode.
             *
             * Note that the array returned is a simple array.  Application code should not assume
             * existence of methods like forEach().
             *
             */
            getChildren(): any[];
            /**
             * Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
             * This method should generally be avoided as it returns widgets declared in templates, which are
             * supposed to be internal/hidden, but it's left here for back-compat reasons.
             *
             */
            getDescendants(): any[];
            /**
             * Returns the parent widget of this widget.
             *
             */
            getParent(): any;
            /**
             * Deprecated.  Use get('value') instead.
             *
             */
            getValue(): any;
            /**
             * Return true if this widget can currently be focused
             * and false if not
             *
             */
            isFocusable(): any;
            /**
             * Return this widget's explicit or implicit orientation (true for LTR, false for RTL)
             *
             */
            isLeftToRight(): any;
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: String, func: Function): any;
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: Function, func: Function): any;
            /**
             * Track specified handles and remove/destroy them when this instance is destroyed, unless they were
             * already removed/destroyed manually.
             *
             */
            own(): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: number): any;
            /**
             *
             */
            postCreate(): void;
            /**
             *
             */
            postMixInProperties(): void;
            /**
             * accommodate our extra focusListeners
             *
             * @param e
             */
            reset(e: any): void;
            /**
             * Set a property on a widget
             * Sets named properties on a widget which may potentially be handled by a
             * setter in the widget.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _setFooAttr(), calling
             * myWidget.set("foo", "Howdy!") would be equivalent to calling
             * widget._setFooAttr("Howdy!") and myWidget.set("bar", 3)
             * would be equivalent to the statement widget.bar = 3;
             *
             * set() may also be called with a hash of name/value pairs, ex:
             *
             * myWidget.set({
             *     foo: "Howdy",
             *     bar: 3
             * });
             * This is equivalent to calling set(foo, "Howdy") and set(bar, 3)
             *
             * @param name The property to set.
             * @param value The value to set in the property.
             */
            set(name: any, value: any): any;
            /**
             * Deprecated.  Use set() instead.
             *
             * @param attr
             * @param value
             */
            setAttribute(attr: String, value: any): void;
            /**
             * Deprecated.  Use set('disabled', ...) instead.
             *
             * @param disabled
             */
            setDisabled(disabled: boolean): void;
            /**
             * method to allow use to change button label
             *
             * @param label
             * @param cssClass               OptionalThe class to use during the manipulation
             */
            setLabel(label: String, cssClass: String): void;
            /**
             * set the text of the progressbar
             *
             * @param title
             */
            setMessage(title: String): void;
            /**
             * Deprecated.  Use set('value', ...) instead.
             *
             * @param value
             */
            setValue(value: String): void;
            /**
             * add our extra blur listeners
             *
             */
            startup(): void;
            /**
             * Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.
             *
             * Subscribes to the specified topic and calls the specified method
             * of this object and registers for unsubscribe() on widget destroy.
             *
             * Provide widget-specific analog to dojo.subscribe, except with the
             * implicit use of this widget as the target object.
             *
             * @param t The topic
             * @param method The callback
             */
            subscribe(t: String, method: Function): any;
            /**
             * Returns a string that represents the widget.
             * When a widget is cast to a string, this method will be used to generate the
             * output. Currently, it does not implement any sort of reversible
             * serialization.
             *
             */
            toString(): string;
            /**
             * Deprecated. Override destroy() instead to implement custom widget tear-down
             * behavior.
             *
             */
            uninitialize(): boolean;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Unsubscribes handle created by this.subscribe.
             * Also removes handle from this widget's list of subscriptions
             *
             * @param handle
             */
            unsubscribe(handle: Object): void;
            /**
             * Watches a property for changes
             *
             * @param name               OptionalIndicates the property to watch. This is optional (the callback may be theonly parameter), and if omitted, all the properties will be watched
             * @param callback The function to execute when the property changes. This will be called afterthe property has been changed. The callback will be called with the |this|set to the instance, the first argument as the name of the property, thesecond argument as the old value and the third argument as the new value.
             */
            watch(property: string, callback:{(property?:string, oldValue?:any, newValue?: any):void}) :{unwatch():void};
            /**
             * Static method to get a template based on the templatePath or
             * templateString key
             */
            getCachedTemplate(): any;
            /**
             * Called immediately before a FileInput sends it's file via io.iframe.send.
             * The return of this function is passed as the content member in the io.iframe IOArgs
             * object.
             *
             */
            onBeforeSend(): Object;
            /**
             * Called when the widget stops being "active" because
             * focus moved to something outside of it, or the user
             * clicked somewhere outside of it, or the widget was
             * hidden.
             *
             */
            onBlur(): void;
            /**
             * Callback when this widget's value is changed.
             *
             * @param newValue
             */
            onChange(newValue: any): void;
            /**
             * Connect to this function to receive notifications of mouse click events.
             *
             * @param event mouse Event
             */
            onClick(event: any): void;
            /**
             * Called when this widget is being displayed as a popup (ex: a Calendar popped
             * up from a DateTextBox), and it is hidden.
             * This is called from the dijit.popup code, and should not be called directly.
             *
             * Also used as a parameter for children of dijit/layout/StackContainer or subclasses.
             * Callback if a user tries to close the child.   Child will be closed if this function returns true.
             *
             */
            onClose(): boolean;
            /**
             * stub function fired when an upload has finished.
             *
             * @param data the raw data found in the first [TEXTAREA] tag of the post url
             * @param ioArgs the Deferred data being passed from the handle: callback
             * @param widgetRef this widget pointer, so you can set this.overlay to a completed/error message easily
             */
            onComplete(data: any, ioArgs: any, widgetRef: any): void;
            /**
             * Connect to this function to receive notifications of mouse double click events.
             *
             * @param event mouse Event
             */
            onDblClick(event: any): void;
            /**
             * Called when the widget becomes "active" because
             * it or a widget inside of it either has focus, or has recently
             * been clicked.
             *
             */
            onFocus(): void;
            /**
             * Called when another widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate hide of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onHide(): void;
            /**
             * Connect to this function to receive notifications of keys being pressed down.
             *
             * @param event key Event
             */
            onKeyDown(event: any): void;
            /**
             * Connect to this function to receive notifications of printable keys being typed.
             *
             * @param event key Event
             */
            onKeyPress(event: any): void;
            /**
             * Connect to this function to receive notifications of keys being released.
             *
             * @param event key Event
             */
            onKeyUp(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is pressed down.
             *
             * @param event mouse Event
             */
            onMouseDown(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto this widget.
             *
             * @param event mouse Event
             */
            onMouseEnter(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of this widget.
             *
             * @param event mouse Event
             */
            onMouseLeave(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseMove(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOut(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOver(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is released.
             *
             * @param event mouse Event
             */
            onMouseUp(event: any): void;
            /**
             * Called when this widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate display of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onShow(): void;
        }
        /**
         * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/FileUploader.html
         *
         * Handles File Uploading to a server (PHP script included for testing)
         *
         * FileUploader is now a WIDGET. You do not have to pass a button
         * in. Passing a button is still supported until version 1.5 to maintain
         * backwards compatibility, but it is not recommended. Just create your
         * uploader like any other widget.
         * If the correct version of Flash Player is available (> 9.0) , a SWF
         * is used. If Flash Player is not installed or is outdated, a typical
         * html fileInput is used. This process can be overridden with
         * force:"flash" or force:"html".
         *
         * FileUploader works with Flash 10.
         *
         * The button styles are now recreated in Flash, so there is no longer
         * using an invisible Flash movie with wmode=transparent. This way the Flash button
         * is actually placed inline with the DOM, not floating above it and constantly
         * resetting its position. The "Windows Firefox clickable bug" should be fixed (and
         * hopefully some Linux problems).
         *
         * The HTML button is created in a new way and it is now inline as is the
         * FLash button. Styling is much easier and more versatile.
         *
         * Dependencies
         * FileUploader no longer uses FileInput.css. It now uses FileUploader.css
         * See requires for JavaScript dependencies.
         *
         * NEW FEATURES
         * There are a ton of features and fixes in this version:
         *
         * Disabled: Can be toggled with widget.set("disabled", true|false)
         * Submit: A convenience method has been added for if the uploader is in a form.
         *   Instead of submitting the form, call uploader.submit(theForm), and the
         *   Uploader will handle all of the form values and post the data.
         * Selected List: If passing the ID of a container, the Uploaders will populate it
         *   with the selected files.
         * Deleting Files: You can now delete pending files.
         * Progress Built in: showProgress:true will change the button to a progress
         *   bar on upload.
         * Progress Attach: Passing progressWidgetId will tell the Uploader of a progress
         *   widget. If the Progress widget is initially hidden, it will change to
         *   visible and then restored after upload.
         * A11Y: The Flash button can be accessed with the TAB key. (The HTML cannot due
         *   to browser limitations)
         * Deferred Uploading: (Flash only) throttles the upload to one file at a time
         * CDN USERS
         * FileUpload now works with the CDN but with limitations. The SWF must
         * be from the same domain as the HTML page. 'swfPath' has been exposed
         * so that you may link to that file (could of course be the same SWF in
         * dojox resource folder). The SWF will NOT work from the
         * CDN server. This would require a special XML file that would allow
         * access to your server, and the logistics to that is impossible.
         *
         * LIMITATIONS
         * This is not designed to be a part of a form, it contains its own. (See submit())
         * Currently does not in a Dialog box or a Tab where it is not initially visible,
         * The default style inherits font sizes - but a parent container should have a font size
         *   set somewhere of the results could be inconsistent.
         * OPERA USERS
         * It works better than the 1.3 version. fileInputs apperantly can't have opacity
         * set to zero. The Flash uploader works but files are auto-uploaded. Must be a
         * flashVar problem.
         *
         * Safari Bug note:
         * The bug is in the way Safari handles the connection:
         * https://bugs.webkit.org/show_bug.cgi?id=5760
         * I added this to the virtual host in the Apache conf file, and now it
         * works like a charm:
         *
         * BrowserMatch Safari nokeepalive
         *
         */
        class FileUploader extends dijit._Widget implements dijit._TemplatedMixin, dijit._Contained {
            constructor();
            /**
             * The name of the class that will style the button in a "press" state. A specific
             * class should be made to do this. Do not rely on a target like button:active{...}
             *
             */
            "activeClass": string;
            set(property:"activeClass", value: string): void;
            get(property:"activeClass"): string;
            watch(property:"activeClass", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Object to which attach points and events will be scoped.  Defaults
             * to 'this'.
             *
             */
            "attachScope": Object;
            set(property:"attachScope", value: Object): void;
            get(property:"attachScope"): Object;
            watch(property:"attachScope", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute
             * for each XXX attribute to be mapped to the DOM.
             *
             * attributeMap sets up a "binding" between attributes (aka properties)
             * of the widget and the widget's DOM.
             * Changes to widget attributes listed in attributeMap will be
             * reflected into the DOM.
             *
             * For example, calling set('title', 'hello')
             * on a TitlePane will automatically cause the TitlePane's DOM to update
             * with the new title.
             *
             * attributeMap is a hash where the key is an attribute of the widget,
             * and the value reflects a binding to a:
             *
             * DOM node attribute
             *   focus: {node: "focusNode", type: "attribute"}
             * Maps this.focus to this.focusNode.focus
             *
             * DOM node innerHTML
             *   title: { node: "titleNode", type: "innerHTML" }
             * Maps this.title to this.titleNode.innerHTML
             *
             * DOM node innerText
             *   title: { node: "titleNode", type: "innerText" }
             * Maps this.title to this.titleNode.innerText
             *
             * DOM node CSS class
             *   myClass: { node: "domNode", type: "class" }
             * Maps this.myClass to this.domNode.className
             *
             * If the value is an array, then each element in the array matches one of the
             * formats of the above list.
             *
             * There are also some shorthands for backwards compatibility:
             *
             * string --> { node: string, type: "attribute" }, for example:
             * "focusNode" ---> { node: "focusNode", type: "attribute" }
             * "" --> { node: "domNode", type: "attribute" }
             *
             */
            "attributeMap": Object;
            set(property:"attributeMap", value: Object): void;
            get(property:"attributeMap"): Object;
            watch(property:"attributeMap", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * The name of the class that will style the button in a "normal" state.
             * If baseClass is not defined, 'class' will be used.
             * NOTE: By default the uploader will be styled like a dijit buttons and
             * adhere to the the themes. Tundra, Soria, and Nihilo are supported.
             * You can cascade the existing style by using 'class' or 'style'. If you
             * overwrite baseClass, you should overwrite the remaing state classes
             * that follow) as well.
             *
             */
            "baseClass": string;
            set(property:"baseClass", value: string): void;
            get(property:"baseClass"): string;
            watch(property:"baseClass", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "class": string;
            set(property:"class", value: string): void;
            get(property:"class"): string;
            watch(property:"class", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Designates where children of the source DOM node will be placed.
             * "Children" in this case refers to both DOM nodes and widgets.
             * For example, for myWidget:
             *
             * <div data-dojo-type=myWidget>
             *     <b> here's a plain DOM node
             *     <span data-dojo-type=subWidget>and a widget</span>
             *     <i> and another plain DOM node </i>
             * </div>
             * containerNode would point to:
             *
             * <b> here's a plain DOM node
             * <span data-dojo-type=subWidget>and a widget</span>
             * <i> and another plain DOM node </i>
             * In templated widgets, "containerNode" is set via a
             * data-dojo-attach-point assignment.
             *
             * containerNode must be defined for any widget that accepts innerHTML
             * (like ContentPane or BorderContainer or even Button), and conversely
             * is null for widgets that don't, like TextBox.
             *
             */
            "containerNode": HTMLElement;
            set(property:"containerNode", value: HTMLElement): void;
            get(property:"containerNode"): HTMLElement;
            watch(property:"containerNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * (Flash only) throttles the upload to a certain amount of files at a time.
             * By default, Flash uploads file one at a time to the server, but in parallel.
             * Firefox will try to queue all files at once, leading to problems. Set this
             * to the amount to upload in parallel at a time.
             * Generally, 1 should work fine, but you can experiment with queuing more than
             * one at a time.
             * This is of course ignored if selectMultipleFiles equals false.
             *
             */
            "deferredUploading": number;
            set(property:"deferredUploading", value: number): void;
            get(property:"deferredUploading"): number;
            watch(property:"deferredUploading", callback:{(property?:string, oldValue?:number, newValue?: number):void}) :{unwatch():void}
            /**
             * Re-implemented. devMode increases the logging, adding style tracing from the SWF.
             *
             */
            "devMode": boolean;
            set(property:"devMode", value: boolean): void;
            get(property:"devMode"): boolean;
            watch(property:"devMode", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Bi-directional support, as defined by the HTML DIR
             * attribute. Either left-to-right "ltr" or right-to-left "rtl".  If undefined, widgets renders in page's
             * default direction.
             *
             */
            "dir": string;
            set(property:"dir", value: string): void;
            get(property:"dir"): string;
            watch(property:"dir", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * The name of the class that will style the button when its disabled.
             *
             */
            "disabledClass": string;
            set(property:"disabledClass", value: string): void;
            get(property:"disabledClass"): string;
            watch(property:"disabledClass", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * This is our visible representation of the widget! Other DOM
             * Nodes may by assigned to other properties, usually through the
             * template system's data-dojo-attach-point syntax, but the domNode
             * property is the canonical "top level" node in widget UI.
             *
             */
            "domNode": HTMLElement;
            set(property:"domNode", value: HTMLElement): void;
            get(property:"domNode"): HTMLElement;
            watch(property:"domNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * The id of a dom node to be used as a container for the pending file list.
             *
             */
            "fileListId": string;
            set(property:"fileListId", value: string): void;
            get(property:"fileListId"): string;
            watch(property:"fileListId", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * (an array, or an array of arrays)
             * Restrict file selection to certain file types
             * Empty array defaults to "All Files"
             *
             * example:
             *
             * fileMask = ["Images", "*.jpg;*.jpeg;*.gif;*.png"]
             * or
             *
             * fileMask = [
             *     ["Jpeg File",   "*.jpg;*.jpeg"],
             *     ["GIF File",    "*.gif"],
             *     ["PNG File",    "*.png"],
             *     ["All Images",  "*.jpg;*.jpeg;*.gif;*.png"],
             * ]
             * NOTE: MacType is not supported, as it does not work very well.
             * fileMask will work on a Mac, but differently than
             * Windows.
             *
             */
            "fileMask": Object;
            set(property:"fileMask", value: Object): void;
            get(property:"fileMask"): Object;
            watch(property:"fileMask", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * The name of the field of the flash uploaded files that the server is expecting
             *
             */
            "flashFieldName": string;
            set(property:"flashFieldName", value: string): void;
            get(property:"flashFieldName"): string;
            watch(property:"flashFieldName", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * The SWF. Mostly Internal.
             *
             */
            "flashMovie": Function;
            set(property:"flashMovie", value: Function): void;
            get(property:"flashMovie"): Function;
            watch(property:"flashMovie", callback:{(property?:string, oldValue?:Function, newValue?: Function):void}) :{unwatch():void}
            /**
             * The object that creates the SWF embed object. Mostly Internal.
             *
             */
            "flashObject": Object;
            set(property:"flashObject", value: Object): void;
            get(property:"flashObject"): Object;
            watch(property:"flashObject", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * This widget or a widget it contains has focus, or is "active" because
             * it was recently clicked.
             *
             */
            "focused": boolean;
            set(property:"focused", value: boolean): void;
            get(property:"focused"): boolean;
            watch(property:"focused", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Use "flash" to always use Flash (and hopefully force the user to download the plugin
             * if they don't have it). Use "html" to always use the HTML uploader. An empty string
             * (default) will check for the right version of Flash and use HTML if not available.
             *
             */
            "force": string;
            set(property:"force", value: string): void;
            get(property:"force"): string;
            watch(property:"force", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * The name of the class that will style the button in a "hover" state. A specific
             * class should be made to do this. Do not rely on a target like button:hover{...}
             *
             */
            "hoverClass": string;
            set(property:"hoverClass", value: string): void;
            get(property:"hoverClass"): string;
            watch(property:"hoverClass", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * The name of the field of the fileInput that the server is expecting
             *
             */
            "htmlFieldName": string;
            set(property:"htmlFieldName", value: string): void;
            get(property:"htmlFieldName"): string;
            watch(property:"htmlFieldName", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * The object id, just like any other widget in Dojo. However, this id
             * is also used as a reference for the SWF
             *
             */
            "id": string;
            set(property:"id", value: string): void;
            get(property:"id"): string;
            watch(property:"id", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * The div that holds the SWF and form/fileInput
             *
             */
            "insideNode": Object;
            set(property:"insideNode", value: Object): void;
            get(property:"insideNode"): Object;
            watch(property:"insideNode", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * If true, outputs traces from the SWF to console. What exactly gets passed
             * is very relative, and depends upon what traces have been left in the DEFT SWF.
             *
             */
            "isDebug": boolean;
            set(property:"isDebug", value: boolean): void;
            get(property:"isDebug"): boolean;
            watch(property:"isDebug", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Rarely used.  Overrides the default Dojo locale used to render this widget,
             * as defined by the HTML LANG attribute.
             * Value must be among the list of locales specified during by the Dojo bootstrap,
             * formatted according to RFC 3066 (like en-us).
             *
             */
            "lang": string;
            set(property:"lang", value: string): void;
            get(property:"lang"): string;
            watch(property:"lang", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * The minimum of version of Flash player to target. 0 would always install Flash, 100
             * would never install it. The Flash Player has supported multiple uploads since
             * version 8, so it could go as low as that safely.
             *
             */
            "minFlashVersion": number;
            set(property:"minFlashVersion", value: number): void;
            get(property:"minFlashVersion"): number;
            watch(property:"minFlashVersion", callback:{(property?:string, oldValue?:number, newValue?: number):void}) :{unwatch():void}
            /**
             * The document this widget belongs to.  If not specified to constructor, will default to
             * srcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global
             *
             */
            "ownerDocument": Object;
            set(property:"ownerDocument", value: Object): void;
            get(property:"ownerDocument"): Object;
            watch(property:"ownerDocument", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * The background color to use for the button-progress
             *
             */
            "progressBackgroundColor": string;
            set(property:"progressBackgroundColor", value: string): void;
            get(property:"progressBackgroundColor"): string;
            watch(property:"progressBackgroundColor", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * The background image to use for the button-progress
             *
             */
            "progressBackgroundUrl": string;
            set(property:"progressBackgroundUrl", value: string): void;
            get(property:"progressBackgroundUrl"): string;
            watch(property:"progressBackgroundUrl", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * The message shown while the button is changed to a progress bar
             *
             */
            "progressMessage": string;
            set(property:"progressMessage", value: string): void;
            get(property:"progressMessage"): string;
            watch(property:"progressMessage", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * The widget id of a Dijit Progress bar. The Uploader will bind to it and update it
             * automatically.
             *
             */
            "progressWidgetId": string;
            set(property:"progressWidgetId", value: string): void;
            get(property:"progressWidgetId"): string;
            watch(property:"progressWidgetId", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "searchContainerNode": boolean;
            set(property:"searchContainerNode", value: boolean): void;
            get(property:"searchContainerNode"): boolean;
            watch(property:"searchContainerNode", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * If true and flash mode, multiple files may be selected from the dialog.
             * If html mode, files are not uploaded until upload() is called. The references
             * to each file is incremented:uploadedfile0, uploadedfile1, uploadedfile2... etc.
             *
             */
            "selectMultipleFiles": boolean;
            set(property:"selectMultipleFiles", value: boolean): void;
            get(property:"selectMultipleFiles"): boolean;
            watch(property:"selectMultipleFiles", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * The amount of time given to the uploaded file
             * to wait for a server response. After this amount
             * of time, the onComplete is fired but with a 'server timeout'
             * error in the returned item.
             *
             */
            "serverTimeout": number;
            set(property:"serverTimeout", value: number): void;
            get(property:"serverTimeout"): number;
            watch(property:"serverTimeout", callback:{(property?:string, oldValue?:number, newValue?: number):void}) :{unwatch():void}
            /**
             * If true, the button changes to a progress bar during upload.
             *
             */
            "showProgress": boolean;
            set(property:"showProgress", value: boolean): void;
            get(property:"showProgress"): boolean;
            watch(property:"showProgress", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * If true, will not verify that the server was sent the correct format.
             * This can be safely set to true. The purpose of the server side check
             * is mainly to show the dev if they've implemented the different returns
             * correctly.
             *
             */
            "skipServerCheck": boolean;
            set(property:"skipServerCheck", value: boolean): void;
            get(property:"skipServerCheck"): boolean;
            watch(property:"skipServerCheck", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * pointer to original DOM node
             *
             */
            "srcNodeRef": HTMLElement;
            set(property:"srcNodeRef", value: HTMLElement): void;
            get(property:"srcNodeRef"): HTMLElement;
            watch(property:"srcNodeRef", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * HTML style attributes as cssText string or name/value hash
             *
             */
            "style": string;
            set(property:"style", value: string): void;
            get(property:"style"): string;
            watch(property:"style", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "swfPath": Object;
            set(property:"swfPath", value: Object): void;
            get(property:"swfPath"): Object;
            watch(property:"swfPath", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * The tab order in the DOM. Only supported by Flash. HTML Uploaders have security
             * protection to prevent you from tabbing to the uploader. Stupid.
             *
             */
            "tabIndex": number;
            set(property:"tabIndex", value: number): void;
            get(property:"tabIndex"): number;
            watch(property:"tabIndex", callback:{(property?:string, oldValue?:number, newValue?: number):void}) :{unwatch():void}
            /**
             * Path to template (HTML file) for this widget relative to dojo.baseUrl.
             * Deprecated: use templateString with require([... "dojo/text!..."], ...) instead
             *
             */
            "templatePath": string;
            set(property:"templatePath", value: string): void;
            get(property:"templatePath"): string;
            watch(property:"templatePath", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "templateString": string;
            set(property:"templateString", value: string): void;
            get(property:"templateString"): string;
            watch(property:"templateString", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * HTML title attribute.
             *
             * For form widgets this specifies a tooltip to display when hovering over
             * the widget (just like the native HTML title attribute).
             *
             * For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,
             * etc., it's used to specify the tab label, accordion pane title, etc.  In this case it's
             * interpreted as HTML.
             *
             */
            "title": string;
            set(property:"title", value: string): void;
            get(property:"title"): string;
            watch(property:"title", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * When this widget's title attribute is used to for a tab label, accordion pane title, etc.,
             * this specifies the tooltip to appear when the mouse is hovered over that text.
             *
             */
            "tooltip": string;
            set(property:"tooltip", value: string): void;
            get(property:"tooltip"): string;
            watch(property:"tooltip", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Internal. What type of uploader is being used: "flash" or "html"
             *
             */
            "uploaderType": string;
            set(property:"uploaderType", value: string): void;
            get(property:"uploaderType"): string;
            watch(property:"uploaderType", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * If true, uploads immediately after a file has been selected. If false,
             * waits for upload() to be called.
             *
             */
            "uploadOnChange": boolean;
            set(property:"uploadOnChange", value: boolean): void;
            get(property:"uploadOnChange"): boolean;
            watch(property:"uploadOnChange", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * The url targeted for upload. An absolute URL is preferred. Relative URLs are
             * changed to absolute.
             *
             */
            "uploadUrl": string;
            set(property:"uploadUrl", value: string): void;
            get(property:"uploadUrl"): string;
            watch(property:"uploadUrl", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * 1.5 (deprecated)
             *
             */
            "version": Object;
            set(property:"version", value: Object): void;
            get(property:"version"): Object;
            watch(property:"version", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: String, value: Object): any;
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: Object, value: Object): any;
            /**
             * Construct the UI for this widget, setting this.domNode.
             * Most widgets will mixin dijit._TemplatedMixin, which implements this method.
             *
             */
            buildRendering(): void;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: Function): any;
            /**
             * Internal. Creates Flash Uploader
             *
             */
            createFlashUploader(): void;
            /**
             * Internal. Fires of methods to build HTML Uploader.
             *
             */
            createHtmlUploader(): void;
            /**
             * Wrapper to setTimeout to avoid deferred functions executing
             * after the originating widget has been destroyed.
             * Returns an object handle with a remove method (that returns null) (replaces clearTimeout).
             *
             * @param fcn Function reference.
             * @param delay               OptionalDelay, defaults to 0.
             */
            defer(fcn: Function, delay: number): Object;
            /**
             * Destroys uploader button
             *
             */
            destroy(): void;
            /**
             * Recursively destroy the children of this widget and their
             * descendants.
             *
             * @param preserveDom               OptionalIf true, the preserveDom attribute is passed to all descendantwidget's .destroy() method. Not for use with _Templatedwidgets.
             */
            destroyDescendants(preserveDom: boolean): void;
            /**
             * Destroy this widget and its descendants
             * This is the generic "destructor" function that all widget users
             * should call to cleanly discard with a widget. Once a widget is
             * destroyed, it is removed from the manager object.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structurealone of descendant Widgets. Note: This will NOT work withdijit._TemplatedMixin widgets.
             */
            destroyRecursive(preserveDom: boolean): void;
            /**
             * Destroys the DOM nodes associated with this widget.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structure aloneduring tear-down. Note: this will not work with _Templatedwidgets yet.
             */
            destroyRendering(preserveDom?: boolean): void;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Disconnects handle created by connect.
             *
             * @param handle
             */
            disconnect(handle: any): void;
            /**
             * Used by widgets to signal that a synthetic event occurred, ex:
             *
             * myWidget.emit("attrmodified-selectedChildWidget", {}).
             * Emits an event on this.domNode named type.toLowerCase(), based on eventObj.
             * Also calls onType() method, if present, and returns value from that method.
             * By default passes eventObj to callback, but will pass callbackArgs instead, if specified.
             * Modifies eventObj by adding missing parameters (bubbles, cancelable, widget).
             *
             * @param type
             * @param eventObj               Optional
             * @param callbackArgs               Optional
             */
            emit(type: String, eventObj: Object, callbackArgs: any[]): any;
            /**
             * Get a property from a widget.
             * Get a named property from a widget. The property may
             * potentially be retrieved via a getter method. If no getter is defined, this
             * just retrieves the object's property.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _getFooAttr(), calling:
             * myWidget.get("foo") would be equivalent to calling
             * widget._getFooAttr() and myWidget.get("bar")
             * would be equivalent to the expression
             * widget.bar2
             *
             * @param name The property to get.
             */
            get(name: any): any;
            /**
             * Internal.
             * Get necessary style information from srcRefNode and
             * assigned styles
             *
             */
            getButtonStyle(): void;
            /**
             * Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent
             * is this widget.   Note that it does not return all descendants, but rather just direct children.
             * Analogous to Node.childNodes,
             * except containing widgets rather than DOMNodes.
             *
             * The result intentionally excludes internally created widgets (a.k.a. supporting widgets)
             * outside of this.containerNode.
             *
             * Note that the array returned is a simple array.  Application code should not assume
             * existence of methods like forEach().
             *
             */
            getChildren(): any[];
            /**
             * Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
             * This method should generally be avoided as it returns widgets declared in templates, which are
             * supposed to be internal/hidden, but it's left here for back-compat reasons.
             *
             */
            getDescendants(): any[];
            /**
             * Internal.
             * If a parent node is styled as display:none,
             * returns that node. This node will be temporarilly
             * changed to display:block. Note if the node is in
             * a widget that has an onShow event, this is
             * overridden.
             *
             * @param node
             */
            getHiddenNode(node: HTMLElement): any;
            /**
             * Returns the index of this widget within its container parent.
             * It returns -1 if the parent does not exist, or if the parent
             * is not a dijit/_Container
             *
             */
            getIndexInParent(): any;
            /**
             * Returns null if this is the last child of the parent,
             * otherwise returns the next element sibling to the "right".
             *
             */
            getNextSibling(): any;
            /**
             * Returns the parent widget of this widget.
             *
             */
            getParent(): any;
            /**
             * Returns null if this is the first child of the parent,
             * otherwise returns the next element sibling to the "left".
             *
             */
            getPreviousSibling(): any;
            /**
             *
             * @param node
             */
            getStyle(node: any): Object;
            /**
             *
             * @param node
             * @param _class
             * @param isDijitButton
             */
            getTempNodeStyle(node: any, _class: any, isDijitButton: any): any;
            /**
             *
             * @param node
             */
            getText(node: any): any;
            /**
             *
             * @param node
             */
            getTextStyle(node: any): Object;
            /**
             *
             * @param node
             */
            isButton(node: any): boolean;
            /**
             * Return true if this widget can currently be focused
             * and false if not
             *
             */
            isFocusable(): any;
            /**
             * Return this widget's explicit or implicit orientation (true for LTR, false for RTL)
             *
             */
            isLeftToRight(): any;
            /**
             * Due to the excessive logging necessary to make this code happen,
             * It's easier to turn it on and off here in one place.
             * Also helpful if there are multiple uploaders on one page.
             *
             */
            log(): void;
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: String, func: Function): any;
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: Function, func: Function): any;
            /**
             * Track specified handles and remove/destroy them when this instance is destroyed, unless they were
             * already removed/destroyed manually.
             *
             */
            own(): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: number): any;
            /**
             *
             */
            postCreate(): void;
            /**
             *
             */
            postMixInProperties(): void;
            /**
             * Removes a file from the pending file list.
             * Removes pending data from the Flash movie
             * and fileInputes from the HTML uploader.
             * If a file container node is bound, the file
             * will also be removed.
             *
             * @param name The name of the file to be removed. Typically the file name,such as: picture01.png
             * @param noListEdit Internal. If true don't remove files from list.
             */
            removeFile(name: String, noListEdit: boolean): void;
            /**
             * Set a property on a widget
             * Sets named properties on a widget which may potentially be handled by a
             * setter in the widget.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _setFooAttr(), calling
             * myWidget.set("foo", "Howdy!") would be equivalent to calling
             * widget._setFooAttr("Howdy!") and myWidget.set("bar", 3)
             * would be equivalent to the statement widget.bar = 3;
             *
             * set() may also be called with a hash of name/value pairs, ex:
             *
             * myWidget.set({
             *     foo: "Howdy",
             *     bar: 3
             * });
             * This is equivalent to calling set(foo, "Howdy") and set(bar, 3)
             *
             * @param name The property to set.
             * @param value The value to set in the property.
             */
            set(name: any, value: any): any;
            /**
             * Deprecated.  Use set() instead.
             *
             * @param attr
             * @param value
             */
            setAttribute(attr: String, value: any): void;
            /**
             * Internal.
             * Set up internal dom nodes for button construction.
             *
             */
            setButtonStyle(): void;
            /**
             *
             */
            startup(): void;
            /**
             * If FileUploader is in a form, and other data should be sent
             * along with the files, use this instead of form submit.
             *
             * @param form               Optional
             */
            submit(form: HTMLFormElement): boolean;
            /**
             * Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.
             *
             * Subscribes to the specified topic and calls the specified method
             * of this object and registers for unsubscribe() on widget destroy.
             *
             * Provide widget-specific analog to dojo.subscribe, except with the
             * implicit use of this widget as the target object.
             *
             * @param t The topic
             * @param method The callback
             */
            subscribe(t: String, method: Function): any;
            /**
             * Returns a string that represents the widget.
             * When a widget is cast to a string, this method will be used to generate the
             * output. Currently, it does not implement any sort of reversible
             * serialization.
             *
             */
            toString(): string;
            /**
             * Deprecated. Override destroy() instead to implement custom widget tear-down
             * behavior.
             *
             */
            uninitialize(): boolean;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Unsubscribes handle created by this.subscribe.
             * Also removes handle from this widget's list of subscriptions
             *
             * @param handle
             */
            unsubscribe(handle: Object): void;
            /**
             * When called, begins file upload
             *
             * @param data               OptionalpostData to be sent to server
             */
            upload(data: Object): boolean;
            /**
             * Internal. You should use upload() or submit();
             *
             */
            uploadFlash(): void;
            /**
             * Internal. You could use this, but you should use upload() or submit();
             * which can also handle the post data.
             *
             */
            uploadHTML(): void;
            /**
             *
             * @param url
             */
            urlencode(url: any): any;
            /**
             * Watches a property for changes
             *
             * @param name               OptionalIndicates the property to watch. This is optional (the callback may be theonly parameter), and if omitted, all the properties will be watched
             * @param callback The function to execute when the property changes. This will be called afterthe property has been changed. The callback will be called with the |this|set to the instance, the first argument as the name of the property, thesecond argument as the old value and the third argument as the new value.
             */
            watch(property: string, callback:{(property?:string, oldValue?:any, newValue?: any):void}) :{unwatch():void};
            /**
             * Static method to get a template based on the templatePath or
             * templateString key
             */
            getCachedTemplate(): any;
            /**
             * Called when the widget stops being "active" because
             * focus moved to something outside of it, or the user
             * clicked somewhere outside of it, or the widget was
             * hidden.
             *
             */
            onBlur(): void;
            /**
             * Stub to connect
             * Fires when dialog box has been closed
             * without a file selection
             *
             */
            onCancel(): void;
            /**
             * stub to connect
             * Fires when files are selected
             * Event is an array of last files selected
             *
             * @param dataArray
             */
            onChange(dataArray: any): void;
            /**
             * Connect to this function to receive notifications of mouse click events.
             *
             * @param event mouse Event
             */
            onClick(event: any): void;
            /**
             * Called when this widget is being displayed as a popup (ex: a Calendar popped
             * up from a DateTextBox), and it is hidden.
             * This is called from the dijit.popup code, and should not be called directly.
             *
             * Also used as a parameter for children of dijit/layout/StackContainer or subclasses.
             * Callback if a user tries to close the child.   Child will be closed if this function returns true.
             *
             */
            onClose(): boolean;
            /**
             * stub to connect
             * Fires when all files have uploaded
             * Event is an array of all files
             *
             * @param dataArray
             */
            onComplete(dataArray: any): void;
            /**
             * Connect to this function to receive notifications of mouse double click events.
             *
             * @param event mouse Event
             */
            onDblClick(event: any): void;
            /**
             * Fires on errors
             *
             * @param evtObject
             */
            onError(evtObject: Object): void;
            /**
             * Fires on errors
             *
             * @param evtObject
             */
            onError(evtObject: String): void;
            /**
             * Called when the widget becomes "active" because
             * it or a widget inside of it either has focus, or has recently
             * been clicked.
             *
             */
            onFocus(): void;
            /**
             * Called when another widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate hide of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onHide(): void;
            /**
             * Connect to this function to receive notifications of keys being pressed down.
             *
             * @param event key Event
             */
            onKeyDown(event: any): void;
            /**
             * Connect to this function to receive notifications of printable keys being typed.
             *
             * @param event key Event
             */
            onKeyPress(event: any): void;
            /**
             * Connect to this function to receive notifications of keys being released.
             *
             * @param event key Event
             */
            onKeyUp(event: any): void;
            /**
             * Stub - SWF has been downloaded 100%.
             *
             * @param uploader
             */
            onLoad(uploader: dojox.form.FileUploader): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is pressed down.
             *
             * @param event mouse Event
             */
            onMouseDown(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto this widget.
             *
             * @param event mouse Event
             */
            onMouseEnter(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of this widget.
             *
             * @param event mouse Event
             */
            onMouseLeave(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseMove(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOut(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOver(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is released.
             *
             * @param event mouse Event
             */
            onMouseUp(event: any): void;
            /**
             * Stub to connect
             * Fires as progress returns from SWF
             * Event is an array of all files uploading
             * Can be connected to for HTML uploader,
             * but will not return anything.
             *
             * @param dataArray
             */
            onProgress(dataArray: any): void;
            /**
             * Stub - Fired when embedFlash has created the
             * Flash object, but it has not necessarilly finished
             * downloading, and is ready to be communicated with.
             *
             * @param uploader
             */
            onReady(uploader: dojox.form.FileUploader): void;
            /**
             * Called when this widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate display of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onShow(): void;
        }
        /**
         * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/ListInput.html
         *
         * An automatic list maker
         * you can add value to list with add method.
         * you can only remove by clicking close button
         *
         */
        class ListInput extends dijit.form._FormValueWidget {
            constructor();
            /**
             * True if mouse was pressed while over this widget, and hasn't been released yet
             *
             */
            "active": boolean;
            set(property:"active", value: boolean): void;
            get(property:"active"): boolean;
            watch(property:"active", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "alt": string;
            set(property:"alt", value: string): void;
            get(property:"alt"): string;
            watch(property:"alt", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "aria-label": string;
            set(property:"aria-label", value: string): void;
            get(property:"aria-label"): string;
            watch(property:"aria-label", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Object to which attach points and events will be scoped.  Defaults
             * to 'this'.
             *
             */
            "attachScope": Object;
            set(property:"attachScope", value: Object): void;
            get(property:"attachScope"): Object;
            watch(property:"attachScope", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute
             * for each XXX attribute to be mapped to the DOM.
             *
             * attributeMap sets up a "binding" between attributes (aka properties)
             * of the widget and the widget's DOM.
             * Changes to widget attributes listed in attributeMap will be
             * reflected into the DOM.
             *
             * For example, calling set('title', 'hello')
             * on a TitlePane will automatically cause the TitlePane's DOM to update
             * with the new title.
             *
             * attributeMap is a hash where the key is an attribute of the widget,
             * and the value reflects a binding to a:
             *
             * DOM node attribute
             *   focus: {node: "focusNode", type: "attribute"}
             * Maps this.focus to this.focusNode.focus
             *
             * DOM node innerHTML
             *   title: { node: "titleNode", type: "innerHTML" }
             * Maps this.title to this.titleNode.innerHTML
             *
             * DOM node innerText
             *   title: { node: "titleNode", type: "innerText" }
             * Maps this.title to this.titleNode.innerText
             *
             * DOM node CSS class
             *   myClass: { node: "domNode", type: "class" }
             * Maps this.myClass to this.domNode.className
             *
             * If the value is an array, then each element in the array matches one of the
             * formats of the above list.
             *
             * There are also some shorthands for backwards compatibility:
             *
             * string --> { node: string, type: "attribute" }, for example:
             * "focusNode" ---> { node: "focusNode", type: "attribute" }
             * "" --> { node: "domNode", type: "attribute" }
             *
             */
            "attributeMap": Object;
            set(property:"attributeMap", value: Object): void;
            get(property:"attributeMap"): Object;
            watch(property:"attributeMap", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             *
             */
            "baseClass": string;
            set(property:"baseClass", value: string): void;
            get(property:"baseClass"): string;
            watch(property:"baseClass", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "class": string;
            set(property:"class", value: string): void;
            get(property:"class"): string;
            watch(property:"class", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * user-defined object needed to pass parameters to the validator functions
             *
             */
            "constraints": Object;
            set(property:"constraints", value: Object): void;
            get(property:"constraints"): Object;
            watch(property:"constraints", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Designates where children of the source DOM node will be placed.
             * "Children" in this case refers to both DOM nodes and widgets.
             * For example, for myWidget:
             *
             * <div data-dojo-type=myWidget>
             *     <b> here's a plain DOM node
             *     <span data-dojo-type=subWidget>and a widget</span>
             *     <i> and another plain DOM node </i>
             * </div>
             * containerNode would point to:
             *
             * <b> here's a plain DOM node
             * <span data-dojo-type=subWidget>and a widget</span>
             * <i> and another plain DOM node </i>
             * In templated widgets, "containerNode" is set via a
             * data-dojo-attach-point assignment.
             *
             * containerNode must be defined for any widget that accepts innerHTML
             * (like ContentPane or BorderContainer or even Button), and conversely
             * is null for widgets that don't, like TextBox.
             *
             */
            "containerNode": HTMLElement;
            set(property:"containerNode", value: HTMLElement): void;
            get(property:"containerNode"): HTMLElement;
            watch(property:"containerNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * Subclasses may define a cssStateNodes property that lists sub-nodes within the widget that
             * need CSS classes applied on mouse hover/press and focus.
             *
             * Each entry in this optional hash is a an attach-point name (like "upArrowButton") mapped to a CSS class name
             * (like "dijitUpArrowButton"). Example:
             *
             * {
             *     "upArrowButton": "dijitUpArrowButton",
             *     "downArrowButton": "dijitDownArrowButton"
             * }
             * The above will set the CSS class dijitUpArrowButton to the this.upArrowButton DOMNode when it
             *
             * is hovered, etc.
             *
             */
            "cssStateNodes": Object;
            set(property:"cssStateNodes", value: Object): void;
            get(property:"cssStateNodes"): Object;
            watch(property:"cssStateNodes", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * delimiter for the string. Every match will be splitted.
             * The string can contain only one delimiter.
             *
             */
            "delimiter": string;
            set(property:"delimiter", value: string): void;
            get(property:"delimiter"): string;
            watch(property:"delimiter", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Bi-directional support, as defined by the HTML DIR
             * attribute. Either left-to-right "ltr" or right-to-left "rtl".  If undefined, widgets renders in page's
             * default direction.
             *
             */
            "dir": string;
            set(property:"dir", value: string): void;
            get(property:"dir"): string;
            watch(property:"dir", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Should this widget respond to user input?
             * In markup, this is specified as "disabled='disabled'", or just "disabled".
             *
             */
            "disabled": boolean;
            set(property:"disabled", value: boolean): void;
            get(property:"disabled"): boolean;
            watch(property:"disabled", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * This is our visible representation of the widget! Other DOM
             * Nodes may by assigned to other properties, usually through the
             * template system's data-dojo-attach-point syntax, but the domNode
             * property is the canonical "top level" node in widget UI.
             *
             */
            "domNode": HTMLElement;
            set(property:"domNode", value: HTMLElement): void;
            get(property:"domNode"): HTMLElement;
            watch(property:"domNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * Animation duration
             *
             */
            "duration": number;
            set(property:"duration", value: number): void;
            get(property:"duration"): number;
            watch(property:"duration", callback:{(property?:string, oldValue?:number, newValue?: number):void}) :{unwatch():void}
            /**
             * function used to easing on fadeIn end
             *
             */
            "easingIn": Function;
            set(property:"easingIn", value: Function): void;
            get(property:"easingIn"): Function;
            watch(property:"easingIn", callback:{(property?:string, oldValue?:Function, newValue?: Function):void}) :{unwatch():void}
            /**
             * function used to easing on fadeOut end
             *
             */
            "easingOut": Function;
            set(property:"easingOut", value: Function): void;
            get(property:"easingOut"): Function;
            watch(property:"easingOut", callback:{(property?:string, oldValue?:Function, newValue?: Function):void}) :{unwatch():void}
            /**
             * This widget or a widget it contains has focus, or is "active" because
             * it was recently clicked.
             *
             */
            "focused": boolean;
            set(property:"focused", value: boolean): void;
            get(property:"focused"): boolean;
            watch(property:"focused", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * True if cursor is over this widget
             *
             */
            "hovering": boolean;
            set(property:"hovering", value: boolean): void;
            get(property:"hovering"): boolean;
            watch(property:"hovering", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * A unique, opaque ID string that can be assigned by users or by the
             * system. If the developer passes an ID which is known not to be
             * unique, the specified ID is ignored and the system-generated ID is
             * used instead.
             *
             */
            "id": string;
            set(property:"id", value: string): void;
            get(property:"id"): string;
            watch(property:"id", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Class which will be used to create the input box. You can implements yours.
             * It must be a widget, focusNode or domNode must have "onkeydown" event
             * It must have .attr("value") to get value
             * It also must implement an (or more) handler for the "onChange" method
             *
             */
            "inputClass": string;
            set(property:"inputClass", value: string): void;
            get(property:"inputClass"): string;
            watch(property:"inputClass", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * The widget will connect on all handler to check input value
             * You can use comma separated list
             *
             */
            "inputHandler": string;
            set(property:"inputHandler", value: string): void;
            get(property:"inputHandler"): string;
            watch(property:"inputHandler", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Properties used to create input box
             * If String, it must be a valid JSON
             *
             */
            "inputProperties": string;
            set(property:"inputProperties", value: string): void;
            get(property:"inputProperties"): string;
            watch(property:"inputProperties", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Fires onChange for each value change or only on demand
             *
             */
            "intermediateChanges": boolean;
            set(property:"intermediateChanges", value: boolean): void;
            get(property:"intermediateChanges"): boolean;
            watch(property:"intermediateChanges", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Rarely used.  Overrides the default Dojo locale used to render this widget,
             * as defined by the HTML LANG attribute.
             * Value must be among the list of locales specified during by the Dojo bootstrap,
             * formatted according to RFC 3066 (like en-us).
             *
             */
            "lang": string;
            set(property:"lang", value: string): void;
            get(property:"lang"): string;
            watch(property:"lang", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Specify max item the list can have
             * null = infinity
             *
             */
            "maxItems": number;
            set(property:"maxItems", value: number): void;
            get(property:"maxItems"): number;
            watch(property:"maxItems", callback:{(property?:string, oldValue?:number, newValue?: number):void}) :{unwatch():void}
            /**
             * Name used when submitting form; same as "name" attribute or plain HTML elements
             *
             */
            "name": string;
            set(property:"name", value: string): void;
            get(property:"name"): string;
            watch(property:"name", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * The document this widget belongs to.  If not specified to constructor, will default to
             * srcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global
             *
             */
            "ownerDocument": Object;
            set(property:"ownerDocument", value: Object): void;
            get(property:"ownerDocument"): Object;
            watch(property:"ownerDocument", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Should this widget respond to user input?
             * In markup, this is specified as "readOnly".
             * Similar to disabled except readOnly form values are submitted.
             *
             */
            "readOnly": boolean;
            set(property:"readOnly", value: boolean): void;
            get(property:"readOnly"): boolean;
            watch(property:"readOnly", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * if false, the list will be editable
             * Can only be set when instantiate
             *
             */
            "readOnlyInput": boolean;
            set(property:"readOnlyInput", value: boolean): void;
            get(property:"readOnlyInput"): boolean;
            watch(property:"readOnlyInput", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * If true, items can be edited
             * Can only be set when instantiate
             *
             */
            "readOnlyItem": boolean;
            set(property:"readOnlyItem", value: boolean): void;
            get(property:"readOnlyItem"): boolean;
            watch(property:"readOnlyItem", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * regular expression string used to validate the input
             * Do not specify both regExp and regExpGen
             *
             */
            "regExp": string;
            set(property:"regExp", value: string): void;
            get(property:"regExp"): string;
            watch(property:"regExp", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * On focus, should this widget scroll into view?
             *
             */
            "scrollOnFocus": boolean;
            set(property:"scrollOnFocus", value: boolean): void;
            get(property:"scrollOnFocus"): boolean;
            watch(property:"scrollOnFocus", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             *
             */
            "searchContainerNode": boolean;
            set(property:"searchContainerNode", value: boolean): void;
            get(property:"searchContainerNode"): boolean;
            watch(property:"searchContainerNode", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * if true, a close button will be added on invalid item
             *
             */
            "showCloseButtonWhenInvalid": boolean;
            set(property:"showCloseButtonWhenInvalid", value: boolean): void;
            get(property:"showCloseButtonWhenInvalid"): boolean;
            watch(property:"showCloseButtonWhenInvalid", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * if true, a close button will be added on valid item
             *
             */
            "showCloseButtonWhenValid": boolean;
            set(property:"showCloseButtonWhenValid", value: boolean): void;
            get(property:"showCloseButtonWhenValid"): boolean;
            watch(property:"showCloseButtonWhenValid", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * pointer to original DOM node
             *
             */
            "srcNodeRef": HTMLElement;
            set(property:"srcNodeRef", value: HTMLElement): void;
            get(property:"srcNodeRef"): HTMLElement;
            watch(property:"srcNodeRef", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * HTML style attributes as cssText string or name/value hash
             *
             */
            "style": string;
            set(property:"style", value: string): void;
            get(property:"style"): string;
            watch(property:"style", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * If true, only valid value will be submitted with form
             *
             */
            "submitOnlyValidValue": boolean;
            set(property:"submitOnlyValidValue", value: boolean): void;
            get(property:"submitOnlyValidValue"): boolean;
            watch(property:"submitOnlyValidValue", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Order fields are traversed when user hits the tab key
             *
             */
            "tabIndex": string;
            set(property:"tabIndex", value: string): void;
            get(property:"tabIndex"): string;
            watch(property:"tabIndex", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Path to template (HTML file) for this widget relative to dojo.baseUrl.
             * Deprecated: use templateString with require([... "dojo/text!..."], ...) instead
             *
             */
            "templatePath": string;
            set(property:"templatePath", value: string): void;
            get(property:"templatePath"): string;
            watch(property:"templatePath", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "templateString": string;
            set(property:"templateString", value: string): void;
            get(property:"templateString"): string;
            watch(property:"templateString", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * HTML title attribute.
             *
             * For form widgets this specifies a tooltip to display when hovering over
             * the widget (just like the native HTML title attribute).
             *
             * For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,
             * etc., it's used to specify the tab label, accordion pane title, etc.  In this case it's
             * interpreted as HTML.
             *
             */
            "title": string;
            set(property:"title", value: string): void;
            get(property:"title"): string;
            watch(property:"title", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * When this widget's title attribute is used to for a tab label, accordion pane title, etc.,
             * this specifies the tooltip to appear when the mouse is hovered over that text.
             *
             */
            "tooltip": string;
            set(property:"tooltip", value: string): void;
            get(property:"tooltip"): string;
            watch(property:"tooltip", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "type": string;
            set(property:"type", value: string): void;
            get(property:"type"): string;
            watch(property:"type", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * If true, then item will use an animation to show hide itself
             *
             */
            "useAnim": boolean;
            set(property:"useAnim", value: boolean): void;
            get(property:"useAnim"): boolean;
            watch(property:"useAnim", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * If true, arraow left and right can be used for editing
             * Can only be set when instantiate
             *
             */
            "useArrowForEdit": boolean;
            set(property:"useArrowForEdit", value: boolean): void;
            get(property:"useArrowForEdit"): boolean;
            watch(property:"useArrowForEdit", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * If true, onBlur event do a validate (like pressing ENTER)
             *
             */
            "useOnBlur": boolean;
            set(property:"useOnBlur", value: boolean): void;
            get(property:"useOnBlur"): boolean;
            watch(property:"useOnBlur", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             *
             */
            "value": string;
            set(property:"value", value: string): void;
            get(property:"value"): string;
            watch(property:"value", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Create new list element
             *
             * @param values
             */
            add(values: String): void;
            /**
             * Create new list element
             *
             * @param values
             */
            add(values: any[]): void;
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: String, value: Object): any;
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: Object, value: Object): any;
            /**
             * Construct the UI for this widget, setting this.domNode.
             * Most widgets will mixin dijit._TemplatedMixin, which implements this method.
             *
             */
            buildRendering(): void;
            /**
             * Compare 2 values (as returned by attr('value') for this widget).
             *
             * @param val1
             * @param val2
             */
            compare(val1: any[], val2: any[]): number;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: Function): any;
            /**
             * Wrapper to setTimeout to avoid deferred functions executing
             * after the originating widget has been destroyed.
             * Returns an object handle with a remove method (that returns null) (replaces clearTimeout).
             *
             * @param fcn Function reference.
             * @param delay               OptionalDelay, defaults to 0.
             */
            defer(fcn: Function, delay: number): Object;
            /**
             * Destroy all widget
             *
             */
            destroy(): void;
            /**
             * Recursively destroy the children of this widget and their
             * descendants.
             *
             * @param preserveDom               OptionalIf true, the preserveDom attribute is passed to all descendantwidget's .destroy() method. Not for use with _Templatedwidgets.
             */
            destroyDescendants(preserveDom: boolean): void;
            /**
             * Destroy this widget and its descendants
             * This is the generic "destructor" function that all widget users
             * should call to cleanly discard with a widget. Once a widget is
             * destroyed, it is removed from the manager object.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structurealone of descendant Widgets. Note: This will NOT work withdijit._TemplatedMixin widgets.
             */
            destroyRecursive(preserveDom: boolean): void;
            /**
             * Destroys the DOM nodes associated with this widget.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structure aloneduring tear-down. Note: this will not work with _Templatedwidgets yet.
             */
            destroyRendering(preserveDom?: boolean): void;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Disconnects handle created by connect.
             *
             * @param handle
             */
            disconnect(handle: any): void;
            /**
             * Used by widgets to signal that a synthetic event occurred, ex:
             *
             * myWidget.emit("attrmodified-selectedChildWidget", {}).
             * Emits an event on this.domNode named type.toLowerCase(), based on eventObj.
             * Also calls onType() method, if present, and returns value from that method.
             * By default passes eventObj to callback, but will pass callbackArgs instead, if specified.
             * Modifies eventObj by adding missing parameters (bubbles, cancelable, widget).
             *
             * @param type
             * @param eventObj               Optional
             * @param callbackArgs               Optional
             */
            emit(type: String, eventObj: Object, callbackArgs: any[]): any;
            /**
             * Put focus on this widget
             *
             */
            focus(): void;
            /**
             * Get a property from a widget.
             * Get a named property from a widget. The property may
             * potentially be retrieved via a getter method. If no getter is defined, this
             * just retrieves the object's property.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _getFooAttr(), calling:
             * myWidget.get("foo") would be equivalent to calling
             * widget._getFooAttr() and myWidget.get("bar")
             * would be equivalent to the expression
             * widget.bar2
             *
             * @param name The property to get.
             */
            get(name: any): any;
            /**
             * Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent
             * is this widget.   Note that it does not return all descendants, but rather just direct children.
             * Analogous to Node.childNodes,
             * except containing widgets rather than DOMNodes.
             *
             * The result intentionally excludes internally created widgets (a.k.a. supporting widgets)
             * outside of this.containerNode.
             *
             * Note that the array returned is a simple array.  Application code should not assume
             * existence of methods like forEach().
             *
             */
            getChildren(): any[];
            /**
             * Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
             * This method should generally be avoided as it returns widgets declared in templates, which are
             * supposed to be internal/hidden, but it's left here for back-compat reasons.
             *
             */
            getDescendants(): any[];
            /**
             * Returns the parent widget of this widget.
             *
             */
            getParent(): any;
            /**
             * Deprecated.  Use get('value') instead.
             *
             */
            getValue(): any;
            /**
             * Return true if this widget can currently be focused
             * and false if not
             *
             */
            isFocusable(): any;
            /**
             * Return this widget's explicit or implicit orientation (true for LTR, false for RTL)
             *
             */
            isLeftToRight(): any;
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: String, func: Function): any;
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: Function, func: Function): any;
            /**
             * Track specified handles and remove/destroy them when this instance is destroyed, unless they were
             * already removed/destroyed manually.
             *
             */
            own(): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: number): any;
            /**
             * If closeButton is used, add a class
             *
             */
            postCreate(): void;
            /**
             *
             */
            postMixInProperties(): void;
            /**
             * Overridable function used to generate regExp when dependent on constraints.
             * Do not specify both regExp and regExpGen.
             *
             * @param constraints An object with the following properties:locale (String): locale used for validation, picks up value from this widget's lang attribute_flags_ (anything): various flags passed to pattern function
             */
            regExpGen(constraints: Object): any;
            /**
             * Reset the widget's value to what it was at initialization time
             *
             */
            reset(): void;
            /**
             * Set a property on a widget
             * Sets named properties on a widget which may potentially be handled by a
             * setter in the widget.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _setFooAttr(), calling
             * myWidget.set("foo", "Howdy!") would be equivalent to calling
             * widget._setFooAttr("Howdy!") and myWidget.set("bar", 3)
             * would be equivalent to the statement widget.bar = 3;
             *
             * set() may also be called with a hash of name/value pairs, ex:
             *
             * myWidget.set({
             *     foo: "Howdy",
             *     bar: 3
             * });
             * This is equivalent to calling set(foo, "Howdy") and set(bar, 3)
             *
             * @param name The property to set.
             * @param value The value to set in the property.
             */
            set(name: any, value: any): any;
            /**
             * Deprecated.  Use set() instead.
             *
             * @param attr
             * @param value
             */
            setAttribute(attr: String, value: any): void;
            /**
             * Deprecated.  Use set('disabled', ...) instead.
             *
             * @param disabled
             */
            setDisabled(disabled: boolean): void;
            /**
             * Deprecated.  Use set('value', ...) instead.
             *
             * @param value
             */
            setValue(value: String): void;
            /**
             * Processing after the DOM fragment is added to the document
             * Called after a widget and its children have been created and added to the page,
             * and all related widgets have finished their create() cycle, up through postCreate().
             *
             * Note that startup() may be called while the widget is still hidden, for example if the widget is
             * inside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.
             * For widgets that need to do layout, it's best to put that layout code inside resize(), and then
             * extend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.
             *
             */
            startup(): void;
            /**
             * Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.
             *
             * Subscribes to the specified topic and calls the specified method
             * of this object and registers for unsubscribe() on widget destroy.
             *
             * Provide widget-specific analog to dojo.subscribe, except with the
             * implicit use of this widget as the target object.
             *
             * @param t The topic
             * @param method The callback
             */
            subscribe(t: String, method: Function): any;
            /**
             * Returns a string that represents the widget.
             * When a widget is cast to a string, this method will be used to generate the
             * output. Currently, it does not implement any sort of reversible
             * serialization.
             *
             */
            toString(): string;
            /**
             * Restore the value to the last value passed to onChange
             *
             */
            undo(): void;
            /**
             * Deprecated. Override destroy() instead to implement custom widget tear-down
             * behavior.
             *
             */
            uninitialize(): boolean;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Unsubscribes handle created by this.subscribe.
             * Also removes handle from this widget's list of subscriptions
             *
             * @param handle
             */
            unsubscribe(handle: Object): void;
            /**
             * Watches a property for changes
             *
             * @param name               OptionalIndicates the property to watch. This is optional (the callback may be theonly parameter), and if omitted, all the properties will be watched
             * @param callback The function to execute when the property changes. This will be called afterthe property has been changed. The callback will be called with the |this|set to the instance, the first argument as the name of the property, thesecond argument as the old value and the third argument as the new value.
             */
            watch(property: string, callback:{(property?:string, oldValue?:any, newValue?: any):void}) :{unwatch():void};
            /**
             * Static method to get a template based on the templatePath or
             * templateString key
             */
            getCachedTemplate(): any;
            /**
             * Called when the widget stops being "active" because
             * focus moved to something outside of it, or the user
             * clicked somewhere outside of it, or the widget was
             * hidden.
             *
             */
            onBlur(): void;
            /**
             * Callback when this widget's value is changed.
             *
             * @param newValue
             */
            onChange(newValue: any): void;
            /**
             * Connect to this function to receive notifications of mouse click events.
             *
             * @param event mouse Event
             */
            onClick(event: any): void;
            /**
             * Called when this widget is being displayed as a popup (ex: a Calendar popped
             * up from a DateTextBox), and it is hidden.
             * This is called from the dijit.popup code, and should not be called directly.
             *
             * Also used as a parameter for children of dijit/layout/StackContainer or subclasses.
             * Callback if a user tries to close the child.   Child will be closed if this function returns true.
             *
             */
            onClose(): boolean;
            /**
             * Connect to this function to receive notifications of mouse double click events.
             *
             * @param event mouse Event
             */
            onDblClick(event: any): void;
            /**
             * Called when the widget becomes "active" because
             * it or a widget inside of it either has focus, or has recently
             * been clicked.
             *
             */
            onFocus(): void;
            /**
             * Called when another widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate hide of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onHide(): void;
            /**
             * Connect to this function to receive notifications of keys being pressed down.
             *
             * @param event key Event
             */
            onKeyDown(event: any): void;
            /**
             * Connect to this function to receive notifications of printable keys being typed.
             *
             * @param event key Event
             */
            onKeyPress(event: any): void;
            /**
             * Connect to this function to receive notifications of keys being released.
             *
             * @param event key Event
             */
            onKeyUp(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is pressed down.
             *
             * @param event mouse Event
             */
            onMouseDown(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto this widget.
             *
             * @param event mouse Event
             */
            onMouseEnter(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of this widget.
             *
             * @param event mouse Event
             */
            onMouseLeave(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseMove(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOut(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOver(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is released.
             *
             * @param event mouse Event
             */
            onMouseUp(event: any): void;
            /**
             * Called when this widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate display of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onShow(): void;
        }
        /**
         * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/FilePickerTextBox.html
         *
         * A validating text box tied to a file picker popup
         *
         * @param params Hash of initialization parameters for widget, including scalar values (like title, duration etc.)and functions, typically callbacks like onClick.The hash can contain any of the widget's properties, excluding read-only properties.
         * @param srcNodeRef       OptionalIf a srcNodeRef (DOM node) is specified, replace srcNodeRef with my generated DOM tree.
         */
        class FilePickerTextBox extends dijit.form.ValidationTextBox implements dijit._HasDropDown {
            constructor(params?: Object, srcNodeRef?: HTMLElement);
            /**
             * True if mouse was pressed while over this widget, and hasn't been released yet
             *
             */
            "active": boolean;
            set(property:"active", value: boolean): void;
            get(property:"active"): boolean;
            watch(property:"active", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "alt": string;
            set(property:"alt", value: string): void;
            get(property:"alt"): string;
            watch(property:"alt", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "aria-label": string;
            set(property:"aria-label", value: string): void;
            get(property:"aria-label"): string;
            watch(property:"aria-label", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Object to which attach points and events will be scoped.  Defaults
             * to 'this'.
             *
             */
            "attachScope": Object;
            set(property:"attachScope", value: Object): void;
            get(property:"attachScope"): Object;
            watch(property:"attachScope", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute
             * for each XXX attribute to be mapped to the DOM.
             *
             * attributeMap sets up a "binding" between attributes (aka properties)
             * of the widget and the widget's DOM.
             * Changes to widget attributes listed in attributeMap will be
             * reflected into the DOM.
             *
             * For example, calling set('title', 'hello')
             * on a TitlePane will automatically cause the TitlePane's DOM to update
             * with the new title.
             *
             * attributeMap is a hash where the key is an attribute of the widget,
             * and the value reflects a binding to a:
             *
             * DOM node attribute
             *   focus: {node: "focusNode", type: "attribute"}
             * Maps this.focus to this.focusNode.focus
             *
             * DOM node innerHTML
             *   title: { node: "titleNode", type: "innerHTML" }
             * Maps this.title to this.titleNode.innerHTML
             *
             * DOM node innerText
             *   title: { node: "titleNode", type: "innerText" }
             * Maps this.title to this.titleNode.innerText
             *
             * DOM node CSS class
             *   myClass: { node: "domNode", type: "class" }
             * Maps this.myClass to this.domNode.className
             *
             * If the value is an array, then each element in the array matches one of the
             * formats of the above list.
             *
             * There are also some shorthands for backwards compatibility:
             *
             * string --> { node: string, type: "attribute" }, for example:
             * "focusNode" ---> { node: "focusNode", type: "attribute" }
             * "" --> { node: "domNode", type: "attribute" }
             *
             */
            "attributeMap": Object;
            set(property:"attributeMap", value: Object): void;
            get(property:"attributeMap"): Object;
            watch(property:"attributeMap", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Set to true to make the drop down at least as wide as this
             * widget.  Set to false if the drop down should just be its
             * default width.
             *
             */
            "autoWidth": boolean;
            set(property:"autoWidth", value: boolean): void;
            get(property:"autoWidth"): boolean;
            watch(property:"autoWidth", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             *
             */
            "baseClass": string;
            set(property:"baseClass", value: string): void;
            get(property:"baseClass"): string;
            watch(property:"baseClass", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "class": string;
            set(property:"class", value: string): void;
            get(property:"class"): string;
            watch(property:"class", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * user-defined object needed to pass parameters to the validator functions
             *
             */
            "constraints": Object;
            set(property:"constraints", value: Object): void;
            get(property:"constraints"): Object;
            watch(property:"constraints", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Designates where children of the source DOM node will be placed.
             * "Children" in this case refers to both DOM nodes and widgets.
             * For example, for myWidget:
             *
             * <div data-dojo-type=myWidget>
             *     <b> here's a plain DOM node
             *     <span data-dojo-type=subWidget>and a widget</span>
             *     <i> and another plain DOM node </i>
             * </div>
             * containerNode would point to:
             *
             * <b> here's a plain DOM node
             * <span data-dojo-type=subWidget>and a widget</span>
             * <i> and another plain DOM node </i>
             * In templated widgets, "containerNode" is set via a
             * data-dojo-attach-point assignment.
             *
             * containerNode must be defined for any widget that accepts innerHTML
             * (like ContentPane or BorderContainer or even Button), and conversely
             * is null for widgets that don't, like TextBox.
             *
             */
            "containerNode": HTMLElement;
            set(property:"containerNode", value: HTMLElement): void;
            get(property:"containerNode"): HTMLElement;
            watch(property:"containerNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * Subclasses may define a cssStateNodes property that lists sub-nodes within the widget that
             * need CSS classes applied on mouse hover/press and focus.
             *
             * Each entry in this optional hash is a an attach-point name (like "upArrowButton") mapped to a CSS class name
             * (like "dijitUpArrowButton"). Example:
             *
             * {
             *     "upArrowButton": "dijitUpArrowButton",
             *     "downArrowButton": "dijitDownArrowButton"
             * }
             * The above will set the CSS class dijitUpArrowButton to the this.upArrowButton DOMNode when it
             *
             * is hovered, etc.
             *
             */
            "cssStateNodes": Object;
            set(property:"cssStateNodes", value: Object): void;
            get(property:"cssStateNodes"): Object;
            watch(property:"cssStateNodes", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Bi-directional support, as defined by the HTML DIR
             * attribute. Either left-to-right "ltr" or right-to-left "rtl".  If undefined, widgets renders in page's
             * default direction.
             *
             */
            "dir": string;
            set(property:"dir", value: string): void;
            get(property:"dir"): string;
            watch(property:"dir", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Should this widget respond to user input?
             * In markup, this is specified as "disabled='disabled'", or just "disabled".
             *
             */
            "disabled": boolean;
            set(property:"disabled", value: boolean): void;
            get(property:"disabled"): boolean;
            watch(property:"disabled", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * For subclasses like ComboBox where the displayed value
             * (ex: Kentucky) and the serialized value (ex: KY) are different,
             * this represents the displayed value.
             *
             * Setting 'displayedValue' through set('displayedValue', ...)
             * updates 'value', and vice-versa.  Otherwise 'value' is updated
             * from 'displayedValue' periodically, like onBlur etc.
             *
             * TODO: move declaration to MappedTextBox?
             * Problem is that ComboBox references displayedValue,
             * for benefit of FilteringSelect.
             *
             */
            "displayedValue": string;
            set(property:"displayedValue", value: string): void;
            get(property:"displayedValue"): string;
            watch(property:"displayedValue", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * This is our visible representation of the widget! Other DOM
             * Nodes may by assigned to other properties, usually through the
             * template system's data-dojo-attach-point syntax, but the domNode
             * property is the canonical "top level" node in widget UI.
             *
             */
            "domNode": HTMLElement;
            set(property:"domNode", value: HTMLElement): void;
            get(property:"domNode"): HTMLElement;
            watch(property:"domNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * The widget to display as a popup.  This widget must be
             * defined before the startup function is called.
             *
             */
            "dropDown": Object;
            set(property:"dropDown", value: Object): void;
            get(property:"dropDown"): Object;
            watch(property:"dropDown", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * This variable controls the position of the drop down.
             * It's an array of strings with the following values:
             *
             * before: places drop down to the left of the target node/widget, or to the right in
             * the case of RTL scripts like Hebrew and Arabic
             * after: places drop down to the right of the target node/widget, or to the left in
             * the case of RTL scripts like Hebrew and Arabic
             * above: drop down goes above target node
             * below: drop down goes below target node
             * The list is positions is tried, in order, until a position is found where the drop down fits
             * within the viewport.
             *
             */
            "dropDownPosition": Object;
            set(property:"dropDownPosition", value: Object): void;
            get(property:"dropDownPosition"): Object;
            watch(property:"dropDownPosition", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * This widget or a widget it contains has focus, or is "active" because
             * it was recently clicked.
             *
             */
            "focused": boolean;
            set(property:"focused", value: boolean): void;
            get(property:"focused"): boolean;
            watch(property:"focused", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Set to true to make the drop down exactly as wide as this
             * widget.  Overrides autoWidth.
             *
             */
            "forceWidth": boolean;
            set(property:"forceWidth", value: boolean): void;
            get(property:"forceWidth"): boolean;
            watch(property:"forceWidth", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * True if cursor is over this widget
             *
             */
            "hovering": boolean;
            set(property:"hovering", value: boolean): void;
            get(property:"hovering"): boolean;
            watch(property:"hovering", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * A unique, opaque ID string that can be assigned by users or by the
             * system. If the developer passes an ID which is known not to be
             * unique, the specified ID is ignored and the system-generated ID is
             * used instead.
             *
             */
            "id": string;
            set(property:"id", value: string): void;
            get(property:"id"): string;
            watch(property:"id", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Fires onChange for each value change or only on demand
             *
             */
            "intermediateChanges": boolean;
            set(property:"intermediateChanges", value: boolean): void;
            get(property:"intermediateChanges"): boolean;
            watch(property:"intermediateChanges", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * The message to display if value is invalid.
             * The translated string value is read from the message file by default.
             * Set to "" to use the promptMessage instead.
             *
             */
            "invalidMessage": string;
            set(property:"invalidMessage", value: string): void;
            get(property:"invalidMessage"): string;
            watch(property:"invalidMessage", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Rarely used.  Overrides the default Dojo locale used to render this widget,
             * as defined by the HTML LANG attribute.
             * Value must be among the list of locales specified during by the Dojo bootstrap,
             * formatted according to RFC 3066 (like en-us).
             *
             */
            "lang": string;
            set(property:"lang", value: string): void;
            get(property:"lang"): string;
            watch(property:"lang", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Converts all characters to lowercase if true.  Default is false.
             *
             */
            "lowercase": boolean;
            set(property:"lowercase", value: boolean): void;
            get(property:"lowercase"): boolean;
            watch(property:"lowercase", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * The max height for our dropdown.
             * Any dropdown taller than this will have scrollbars.
             * Set to 0 for no max height, or -1 to limit height to available space in viewport
             *
             */
            "maxHeight": number;
            set(property:"maxHeight", value: number): void;
            get(property:"maxHeight"): number;
            watch(property:"maxHeight", callback:{(property?:string, oldValue?:number, newValue?: number):void}) :{unwatch():void}
            /**
             * HTML INPUT tag maxLength declaration.
             *
             */
            "maxLength": string;
            set(property:"maxLength", value: string): void;
            get(property:"maxLength"): string;
            watch(property:"maxLength", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Currently error/prompt message.
             * When using the default tooltip implementation, this will only be
             * displayed when the field is focused.
             *
             */
            "message": string;
            set(property:"message", value: string): void;
            get(property:"message"): string;
            watch(property:"message", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * The message to display if value is empty and the field is required.
             * The translated string value is read from the message file by default.
             * Set to "" to use the invalidMessage instead.
             *
             */
            "missingMessage": string;
            set(property:"missingMessage", value: string): void;
            get(property:"missingMessage"): string;
            watch(property:"missingMessage", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Name used when submitting form; same as "name" attribute or plain HTML elements
             *
             */
            "name": string;
            set(property:"name", value: string): void;
            get(property:"name"): string;
            watch(property:"name", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * The number of panes to display in our box (if we don't have any
             * minPaneWidth specified by our constraints)
             *
             */
            "numPanes": number;
            set(property:"numPanes", value: number): void;
            get(property:"numPanes"): number;
            watch(property:"numPanes", callback:{(property?:string, oldValue?:number, newValue?: number):void}) :{unwatch():void}
            /**
             * The document this widget belongs to.  If not specified to constructor, will default to
             * srcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global
             *
             */
            "ownerDocument": Object;
            set(property:"ownerDocument", value: Object): void;
            get(property:"ownerDocument"): Object;
            watch(property:"ownerDocument", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * This defines the regular expression used to validate the input.
             * Do not add leading ^ or $ characters since the widget adds these.
             * A function may be used to generate a valid pattern when dependent on constraints or other runtime factors.
             * set('pattern', String|Function).
             *
             */
            "pattern": string;
            set(property:"pattern", value: string): void;
            get(property:"pattern"): string;
            watch(property:"pattern", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Defines a hint to help users fill out the input field (as defined in HTML 5).
             * This should only contain plain text (no html markup).
             *
             */
            "placeHolder": string;
            set(property:"placeHolder", value: string): void;
            get(property:"placeHolder"): string;
            watch(property:"placeHolder", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * If defined, display this hint string immediately on focus to the textbox, if empty.
             * Also displays if the textbox value is Incomplete (not yet valid but will be with additional input).
             * Think of this like a tooltip that tells the user what to do, not an error message
             * that tells the user what they've done wrong.
             *
             * Message disappears when user starts typing.
             *
             */
            "promptMessage": string;
            set(property:"promptMessage", value: string): void;
            get(property:"promptMessage"): string;
            watch(property:"promptMessage", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Converts the first character of each word to uppercase if true.
             *
             */
            "propercase": boolean;
            set(property:"propercase", value: boolean): void;
            get(property:"propercase"): boolean;
            watch(property:"propercase", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Should this widget respond to user input?
             * In markup, this is specified as "readOnly".
             * Similar to disabled except readOnly form values are submitted.
             *
             */
            "readOnly": boolean;
            set(property:"readOnly", value: boolean): void;
            get(property:"readOnly"): boolean;
            watch(property:"readOnly", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             *
             */
            "regExp": string;
            set(property:"regExp", value: string): void;
            get(property:"regExp"): string;
            watch(property:"regExp", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * User is required to enter data into this field.
             *
             */
            "required": boolean;
            set(property:"required", value: boolean): void;
            get(property:"required"): boolean;
            watch(property:"required", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * On focus, should this widget scroll into view?
             *
             */
            "scrollOnFocus": boolean;
            set(property:"scrollOnFocus", value: boolean): void;
            get(property:"scrollOnFocus"): boolean;
            watch(property:"scrollOnFocus", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             *
             */
            "searchContainerNode": boolean;
            set(property:"searchContainerNode", value: boolean): void;
            get(property:"searchContainerNode"): boolean;
            watch(property:"searchContainerNode", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Delay in milliseconds between when user types something and we start
             * searching based on that value
             *
             */
            "searchDelay": number;
            set(property:"searchDelay", value: number): void;
            get(property:"searchDelay"): number;
            watch(property:"searchDelay", callback:{(property?:string, oldValue?:number, newValue?: number):void}) :{unwatch():void}
            /**
             * If true, all text will be selected when focused with mouse
             *
             */
            "selectOnClick": boolean;
            set(property:"selectOnClick", value: boolean): void;
            get(property:"selectOnClick"): boolean;
            watch(property:"selectOnClick", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * pointer to original DOM node
             *
             */
            "srcNodeRef": HTMLElement;
            set(property:"srcNodeRef", value: HTMLElement): void;
            get(property:"srcNodeRef"): HTMLElement;
            watch(property:"srcNodeRef", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * Shows current state (ie, validation result) of input (""=Normal, Incomplete, or Error)
             *
             */
            "state": string;
            set(property:"state", value: string): void;
            get(property:"state"): string;
            watch(property:"state", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * HTML style attributes as cssText string or name/value hash
             *
             */
            "style": string;
            set(property:"style", value: string): void;
            get(property:"style"): string;
            watch(property:"style", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Order fields are traversed when user hits the tab key
             *
             */
            "tabIndex": string;
            set(property:"tabIndex", value: string): void;
            get(property:"tabIndex"): string;
            watch(property:"tabIndex", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Path to template (HTML file) for this widget relative to dojo.baseUrl.
             * Deprecated: use templateString with require([... "dojo/text!..."], ...) instead
             *
             */
            "templatePath": string;
            set(property:"templatePath", value: string): void;
            get(property:"templatePath"): string;
            watch(property:"templatePath", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "templateString": string;
            set(property:"templateString", value: string): void;
            get(property:"templateString"): string;
            watch(property:"templateString", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * HTML title attribute.
             *
             * For form widgets this specifies a tooltip to display when hovering over
             * the widget (just like the native HTML title attribute).
             *
             * For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,
             * etc., it's used to specify the tab label, accordion pane title, etc.  In this case it's
             * interpreted as HTML.
             *
             */
            "title": string;
            set(property:"title", value: string): void;
            get(property:"title"): string;
            watch(property:"title", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * When this widget's title attribute is used to for a tab label, accordion pane title, etc.,
             * this specifies the tooltip to appear when the mouse is hovered over that text.
             *
             */
            "tooltip": string;
            set(property:"tooltip", value: string): void;
            get(property:"tooltip"): string;
            watch(property:"tooltip", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * See description of dijit/Tooltip.defaultPosition for details on this parameter.
             *
             */
            "tooltipPosition": Object;
            set(property:"tooltipPosition", value: Object): void;
            get(property:"tooltipPosition"): Object;
            watch(property:"tooltipPosition", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Removes leading and trailing whitespace if true.  Default is false.
             *
             */
            "trim": boolean;
            set(property:"trim", value: boolean): void;
            get(property:"trim"): boolean;
            watch(property:"trim", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "type": string;
            set(property:"type", value: string): void;
            get(property:"type"): string;
            watch(property:"type", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Converts all characters to uppercase if true.  Default is false.
             *
             */
            "uppercase": boolean;
            set(property:"uppercase", value: boolean): void;
            get(property:"uppercase"): boolean;
            watch(property:"uppercase", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "value": string;
            set(property:"value", value: string): void;
            get(property:"value"): string;
            watch(property:"value", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * The item, in our store, of the directory relating to our value
             *
             */
            "valueItem": Object;
            set(property:"valueItem", value: Object): void;
            get(property:"valueItem"): Object;
            watch(property:"valueItem", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: String, value: Object): any;
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: Object, value: Object): any;
            /**
             * Construct the UI for this widget, setting this.domNode.
             * Most widgets will mixin dijit._TemplatedMixin, which implements this method.
             *
             */
            buildRendering(): void;
            /**
             * Closes the drop down on this widget
             *
             * @param focus If true, refocuses the button widget
             */
            closeDropDown(focus: boolean): void;
            /**
             * Compare 2 values (as returned by get('value') for this widget).
             *
             * @param val1
             * @param val2
             */
            compare(val1: any, val2: any): number;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: Function): any;
            /**
             * Wrapper to setTimeout to avoid deferred functions executing
             * after the originating widget has been destroyed.
             * Returns an object handle with a remove method (that returns null) (replaces clearTimeout).
             *
             * @param fcn Function reference.
             * @param delay               OptionalDelay, defaults to 0.
             */
            defer(fcn: Function, delay: number): Object;
            /**
             * Destroy this widget, but not its descendants.  Descendants means widgets inside of
             * this.containerNode.   Will also destroy any resources (including widgets) registered via this.own().
             *
             * This method will also destroy internal widgets such as those created from a template,
             * assuming those widgets exist inside of this.domNode but outside of this.containerNode.
             *
             * For 2.0 it's planned that this method will also destroy descendant widgets, so apps should not
             * depend on the current ability to destroy a widget without destroying its descendants.   Generally
             * they should use destroyRecursive() for widgets with children.
             *
             * @param preserveDom If true, this method will leave the original DOM structure alone.Note: This will not yet work with _TemplatedMixin widgets
             */
            destroy(preserveDom?: boolean): void;
            /**
             * Recursively destroy the children of this widget and their
             * descendants.
             *
             * @param preserveDom               OptionalIf true, the preserveDom attribute is passed to all descendantwidget's .destroy() method. Not for use with _Templatedwidgets.
             */
            destroyDescendants(preserveDom: boolean): void;
            /**
             * Destroy this widget and its descendants
             * This is the generic "destructor" function that all widget users
             * should call to cleanly discard with a widget. Once a widget is
             * destroyed, it is removed from the manager object.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structurealone of descendant Widgets. Note: This will NOT work withdijit._TemplatedMixin widgets.
             */
            destroyRecursive(preserveDom: boolean): void;
            /**
             * Destroys the DOM nodes associated with this widget.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structure aloneduring tear-down. Note: this will not work with _Templatedwidgets yet.
             */
            destroyRendering(preserveDom?: boolean): void;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Disconnects handle created by connect.
             *
             * @param handle
             */
            disconnect(handle: any): void;
            /**
             * Overridable method to display validation errors/hints.
             * By default uses a tooltip.
             *
             * @param message
             */
            displayMessage(message: String): void;
            /**
             * Used by widgets to signal that a synthetic event occurred, ex:
             *
             * myWidget.emit("attrmodified-selectedChildWidget", {}).
             * Emits an event on this.domNode named type.toLowerCase(), based on eventObj.
             * Also calls onType() method, if present, and returns value from that method.
             * By default passes eventObj to callback, but will pass callbackArgs instead, if specified.
             * Modifies eventObj by adding missing parameters (bubbles, cancelable, widget).
             *
             * @param type
             * @param eventObj               Optional
             * @param callbackArgs               Optional
             */
            emit(type: String, eventObj: Object, callbackArgs: any[]): any;
            /**
             * Auto-corrections (such as trimming) that are applied to textbox
             * value on blur or form submit.
             * For MappedTextBox subclasses, this is called twice
             *
             * once with the display value
             * once the value as set/returned by set('value', ...)
             * and get('value'), ex: a Number for NumberTextBox.
             *
             * In the latter case it does corrections like converting null to NaN.  In
             * the former case the NumberTextBox.filter() method calls this.inherited()
             * to execute standard trimming code in TextBox.filter().
             *
             * TODO: break this into two methods in 2.0
             *
             * @param val
             */
            filter(val: any): any;
            /**
             * Put focus on this widget
             *
             */
            focus(): void;
            /**
             * Replaceable function to convert a value to a properly formatted string.
             *
             * @param value
             * @param constraints
             */
            format(value: String, constraints: Object): String;
            /**
             * Get a property from a widget.
             * Get a named property from a widget. The property may
             * potentially be retrieved via a getter method. If no getter is defined, this
             * just retrieves the object's property.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _getFooAttr(), calling:
             * myWidget.get("foo") would be equivalent to calling
             * widget._getFooAttr() and myWidget.get("bar")
             * would be equivalent to the expression
             * widget.bar2
             *
             * @param name The property to get.
             */
            get(name: any): any;
            /**
             * Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent
             * is this widget.   Note that it does not return all descendants, but rather just direct children.
             * Analogous to Node.childNodes,
             * except containing widgets rather than DOMNodes.
             *
             * The result intentionally excludes internally created widgets (a.k.a. supporting widgets)
             * outside of this.containerNode.
             *
             * Note that the array returned is a simple array.  Application code should not assume
             * existence of methods like forEach().
             *
             */
            getChildren(): any[];
            /**
             * Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
             * This method should generally be avoided as it returns widgets declared in templates, which are
             * supposed to be internal/hidden, but it's left here for back-compat reasons.
             *
             */
            getDescendants(): any[];
            /**
             * Deprecated.  Use get('displayedValue') instead.
             *
             */
            getDisplayedValue(): any;
            /**
             * Return an error message to show if appropriate
             *
             * @param isFocused
             */
            getErrorMessage(isFocused: boolean): any;
            /**
             * Returns the parent widget of this widget.
             *
             */
            getParent(): any;
            /**
             * Return a hint message to show when widget is first focused
             *
             * @param isFocused
             */
            getPromptMessage(isFocused: boolean): any;
            /**
             * Deprecated.  Use get('value') instead.
             *
             */
            getValue(): any;
            /**
             * Return true if this widget can currently be focused
             * and false if not
             *
             */
            isFocusable(): any;
            /**
             * Return this widget's explicit or implicit orientation (true for LTR, false for RTL)
             *
             */
            isLeftToRight(): any;
            /**
             * Returns true if the dropdown exists and it's data is loaded.  This can
             * be overridden in order to force a call to loadDropDown().
             *
             */
            isLoaded(): boolean;
            /**
             * Tests if value is valid.
             * Can override with your own routine in a subclass.
             *
             * @param isFocused
             */
            isValid: {(isFocused: boolean): any};
            /**
             * Creates the drop down if it doesn't exist, loads the data
             * if there's an href and it hasn't been loaded yet, and
             * then opens the drop down.  This is basically a callback when the
             * user presses the down arrow button to open the drop down.
             *
             */
            loadAndOpenDropDown(): any;
            /**
             * Creates the drop down if it doesn't exist, loads the data
             * if there's an href and it hasn't been loaded yet, and then calls
             * the given callback.
             *
             * @param loadCallback
             */
            loadDropDown(loadCallback: Function): void;
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: String, func: Function): any;
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: Function, func: Function): any;
            /**
             *
             */
            openDropDown(): void;
            /**
             * Track specified handles and remove/destroy them when this instance is destroyed, unless they were
             * already removed/destroyed manually.
             *
             */
            own(): any;
            /**
             * Function to convert a formatted string to a value - we use
             * it to verify that it really is a valid value
             *
             * @param value
             * @param constraints
             */
            parse(value: String, constraints: Object): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: number): any;
            /**
             *
             */
            postCreate(): void;
            /**
             *
             */
            postMixInProperties(): void;
            /**
             * Deprecated.  Use set('pattern', Function) instead.
             *
             * @param constraints An object with the following properties:locale (String): locale used for validation, picks up value from this widget's lang attribute_flags_ (anything): various flags passed to pattern function
             */
            regExpGen(constraints: Object): void;
            /**
             *
             */
            reset(): void;
            /**
             * Set a property on a widget
             * Sets named properties on a widget which may potentially be handled by a
             * setter in the widget.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _setFooAttr(), calling
             * myWidget.set("foo", "Howdy!") would be equivalent to calling
             * widget._setFooAttr("Howdy!") and myWidget.set("bar", 3)
             * would be equivalent to the statement widget.bar = 3;
             *
             * set() may also be called with a hash of name/value pairs, ex:
             *
             * myWidget.set({
             *     foo: "Howdy",
             *     bar: 3
             * });
             * This is equivalent to calling set(foo, "Howdy") and set(bar, 3)
             *
             * @param name The property to set.
             * @param value The value to set in the property.
             */
            set(name: any, value: any): any;
            /**
             * Deprecated.  Use set() instead.
             *
             * @param attr
             * @param value
             */
            setAttribute(attr: String, value: any): void;
            /**
             * Deprecated.  Use set('disabled', ...) instead.
             *
             * @param disabled
             */
            setDisabled(disabled: boolean): void;
            /**
             * Deprecated.  Use set('displayedValue', ...) instead.
             *
             * @param value
             */
            setDisplayedValue(value: String): void;
            /**
             * Deprecated.  Use set('value', ...) instead.
             *
             * @param value
             */
            setValue(value: String): void;
            /**
             *
             */
            startup(): void;
            /**
             * Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.
             *
             * Subscribes to the specified topic and calls the specified method
             * of this object and registers for unsubscribe() on widget destroy.
             *
             * Provide widget-specific analog to dojo.subscribe, except with the
             * implicit use of this widget as the target object.
             *
             * @param t The topic
             * @param method The callback
             */
            subscribe(t: String, method: Function): any;
            /**
             *
             */
            toggleDropDown(): void;
            /**
             * Returns a string that represents the widget.
             * When a widget is cast to a string, this method will be used to generate the
             * output. Currently, it does not implement any sort of reversible
             * serialization.
             *
             */
            toString(): string;
            /**
             * Restore the value to the last value passed to onChange
             *
             */
            undo(): void;
            /**
             * Deprecated. Override destroy() instead to implement custom widget tear-down
             * behavior.
             *
             */
            uninitialize(): boolean;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Unsubscribes handle created by this.subscribe.
             * Also removes handle from this widget's list of subscriptions
             *
             * @param handle
             */
            unsubscribe(handle: Object): void;
            /**
             * Called by oninit, onblur, and onkeypress.
             * Show missing or invalid messages if appropriate, and highlight textbox field.
             *
             * @param isFocused
             */
            validate(isFocused: boolean): any;
            /**
             * Overridable function used to validate the text input against the regular expression.
             *
             * @param value
             * @param constraints An object with the following properties:locale (String): locale used for validation, picks up value from this widget's lang attribute_flags_ (anything): various flags passed to pattern function
             */
            validator(value: any, constraints: Object): any;
            /**
             * Watches a property for changes
             *
             * @param name               OptionalIndicates the property to watch. This is optional (the callback may be theonly parameter), and if omitted, all the properties will be watched
             * @param callback The function to execute when the property changes. This will be called afterthe property has been changed. The callback will be called with the |this|set to the instance, the first argument as the name of the property, thesecond argument as the old value and the third argument as the new value.
             */
            watch(property: string, callback:{(property?:string, oldValue?:any, newValue?: any):void}) :{unwatch():void};
            /**
             * Static method to get a template based on the templatePath or
             * templateString key
             */
            getCachedTemplate(): any;
            /**
             * Called when the widget stops being "active" because
             * focus moved to something outside of it, or the user
             * clicked somewhere outside of it, or the widget was
             * hidden.
             *
             */
            onBlur(): void;
            /**
             * Callback when this widget's value is changed.
             *
             * @param newValue
             */
            onChange(newValue: any): void;
            /**
             * Connect to this function to receive notifications of mouse click events.
             *
             * @param event mouse Event
             */
            onClick(event: any): void;
            /**
             * Called when this widget is being displayed as a popup (ex: a Calendar popped
             * up from a DateTextBox), and it is hidden.
             * This is called from the dijit.popup code, and should not be called directly.
             *
             * Also used as a parameter for children of dijit/layout/StackContainer or subclasses.
             * Callback if a user tries to close the child.   Child will be closed if this function returns true.
             *
             */
            onClose(): boolean;
            /**
             * Connect to this function to receive notifications of mouse double click events.
             *
             * @param event mouse Event
             */
            onDblClick(event: any): void;
            /**
             * Called when the widget becomes "active" because
             * it or a widget inside of it either has focus, or has recently
             * been clicked.
             *
             */
            onFocus(): void;
            /**
             * Called when another widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate hide of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onHide(): void;
            /**
             * Connect to this function to receive notifications of various user data-input events.
             * Return false to cancel the event and prevent it from being processed.
             *
             * @param event keydown | keypress | cut | paste | input
             */
            onInput(event: any): void;
            /**
             * Connect to this function to receive notifications of keys being pressed down.
             *
             * @param event key Event
             */
            onKeyDown(event: any): void;
            /**
             * Connect to this function to receive notifications of printable keys being typed.
             *
             * @param event key Event
             */
            onKeyPress(event: any): void;
            /**
             * Connect to this function to receive notifications of keys being released.
             *
             * @param event key Event
             */
            onKeyUp(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is pressed down.
             *
             * @param event mouse Event
             */
            onMouseDown(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto this widget.
             *
             * @param event mouse Event
             */
            onMouseEnter(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of this widget.
             *
             * @param event mouse Event
             */
            onMouseLeave(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseMove(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOut(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOver(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is released.
             *
             * @param event mouse Event
             */
            onMouseUp(event: any): void;
            /**
             * Called when this widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate display of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onShow(): void;
        }
        /**
         * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/Manager.html
         *
         * The widget to orchestrate dynamic forms.
         * This widget hosts dojox.form.manager mixins.
         * See _Mixin for more info.
         *
         * @param params Hash of initialization parameters for widget, including scalar values (like title, duration etc.)and functions, typically callbacks like onClick.The hash can contain any of the widget's properties, excluding read-only properties.
         * @param srcNodeRef       OptionalIf a srcNodeRef (DOM node) is specified:use srcNodeRef.innerHTML as my contentsif this is a behavioral widget then apply behavior to that srcNodeRefotherwise, replace srcNodeRef with my generated DOM tree
         */
        class Manager extends dijit._Widget implements dijit._WidgetsInTemplateMixin, dijit._AttachMixin, dojox.form.manager._Mixin, dojox.form.manager._NodeMixin, dojox.form.manager._FormMixin, dojox.form.manager._ValueMixin, dojox.form.manager._EnableMixin, dojox.form.manager._DisplayMixin, dojox.form.manager._ClassMixin {
            constructor(params?: Object, srcNodeRef?: HTMLElement);
            /**
             *
             */
            "accept": string;
            set(property:"accept", value: string): void;
            get(property:"accept"): string;
            watch(property:"accept", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "accept-charset": string;
            set(property:"accept-charset", value: string): void;
            get(property:"accept-charset"): string;
            watch(property:"accept-charset", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "action": string;
            set(property:"action", value: string): void;
            get(property:"action"): string;
            watch(property:"action", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Object to which attach points and events will be scoped.  Defaults
             * to 'this'.
             *
             */
            "attachScope": Object;
            set(property:"attachScope", value: Object): void;
            get(property:"attachScope"): Object;
            watch(property:"attachScope", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute
             * for each XXX attribute to be mapped to the DOM.
             *
             * attributeMap sets up a "binding" between attributes (aka properties)
             * of the widget and the widget's DOM.
             * Changes to widget attributes listed in attributeMap will be
             * reflected into the DOM.
             *
             * For example, calling set('title', 'hello')
             * on a TitlePane will automatically cause the TitlePane's DOM to update
             * with the new title.
             *
             * attributeMap is a hash where the key is an attribute of the widget,
             * and the value reflects a binding to a:
             *
             * DOM node attribute
             *   focus: {node: "focusNode", type: "attribute"}
             * Maps this.focus to this.focusNode.focus
             *
             * DOM node innerHTML
             *   title: { node: "titleNode", type: "innerHTML" }
             * Maps this.title to this.titleNode.innerHTML
             *
             * DOM node innerText
             *   title: { node: "titleNode", type: "innerText" }
             * Maps this.title to this.titleNode.innerText
             *
             * DOM node CSS class
             *   myClass: { node: "domNode", type: "class" }
             * Maps this.myClass to this.domNode.className
             *
             * If the value is an array, then each element in the array matches one of the
             * formats of the above list.
             *
             * There are also some shorthands for backwards compatibility:
             *
             * string --> { node: string, type: "attribute" }, for example:
             * "focusNode" ---> { node: "focusNode", type: "attribute" }
             * "" --> { node: "domNode", type: "attribute" }
             *
             */
            "attributeMap": Object;
            set(property:"attributeMap", value: Object): void;
            get(property:"attributeMap"): Object;
            watch(property:"attributeMap", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate
             * widget state.
             *
             */
            "baseClass": string;
            set(property:"baseClass", value: string): void;
            get(property:"baseClass"): string;
            watch(property:"baseClass", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "class": string;
            set(property:"class", value: string): void;
            get(property:"class"): string;
            watch(property:"class", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Designates where children of the source DOM node will be placed.
             * "Children" in this case refers to both DOM nodes and widgets.
             * For example, for myWidget:
             *
             * <div data-dojo-type=myWidget>
             *     <b> here's a plain DOM node
             *     <span data-dojo-type=subWidget>and a widget</span>
             *     <i> and another plain DOM node </i>
             * </div>
             * containerNode would point to:
             *
             * <b> here's a plain DOM node
             * <span data-dojo-type=subWidget>and a widget</span>
             * <i> and another plain DOM node </i>
             * In templated widgets, "containerNode" is set via a
             * data-dojo-attach-point assignment.
             *
             * containerNode must be defined for any widget that accepts innerHTML
             * (like ContentPane or BorderContainer or even Button), and conversely
             * is null for widgets that don't, like TextBox.
             *
             */
            "containerNode": HTMLElement;
            set(property:"containerNode", value: HTMLElement): void;
            get(property:"containerNode"): HTMLElement;
            watch(property:"containerNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * Used to provide a context require to the dojo/parser in order to be
             * able to use relative MIDs (e.g. ./Widget) in the widget's template.
             *
             */
            "contextRequire": Function;
            set(property:"contextRequire", value: Function): void;
            get(property:"contextRequire"): Function;
            watch(property:"contextRequire", callback:{(property?:string, oldValue?:Function, newValue?: Function):void}) :{unwatch():void}
            /**
             * Bi-directional support, as defined by the HTML DIR
             * attribute. Either left-to-right "ltr" or right-to-left "rtl".  If undefined, widgets renders in page's
             * default direction.
             *
             */
            "dir": string;
            set(property:"dir", value: string): void;
            get(property:"dir"): string;
            watch(property:"dir", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * This is our visible representation of the widget! Other DOM
             * Nodes may by assigned to other properties, usually through the
             * template system's data-dojo-attach-point syntax, but the domNode
             * property is the canonical "top level" node in widget UI.
             *
             */
            "domNode": HTMLElement;
            set(property:"domNode", value: HTMLElement): void;
            get(property:"domNode"): HTMLElement;
            watch(property:"domNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             *
             */
            "encType": string;
            set(property:"encType", value: string): void;
            get(property:"encType"): string;
            watch(property:"encType", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * This widget or a widget it contains has focus, or is "active" because
             * it was recently clicked.
             *
             */
            "focused": boolean;
            set(property:"focused", value: boolean): void;
            get(property:"focused"): boolean;
            watch(property:"focused", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * A unique, opaque ID string that can be assigned by users or by the
             * system. If the developer passes an ID which is known not to be
             * unique, the specified ID is ignored and the system-generated ID is
             * used instead.
             *
             */
            "id": string;
            set(property:"id", value: string): void;
            get(property:"id"): string;
            watch(property:"id", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Rarely used.  Overrides the default Dojo locale used to render this widget,
             * as defined by the HTML LANG attribute.
             * Value must be among the list of locales specified during by the Dojo bootstrap,
             * formatted according to RFC 3066 (like en-us).
             *
             */
            "lang": string;
            set(property:"lang", value: string): void;
            get(property:"lang"): string;
            watch(property:"lang", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "method": string;
            set(property:"method", value: string): void;
            get(property:"method"): string;
            watch(property:"method", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "name": string;
            set(property:"name", value: string): void;
            get(property:"name"): string;
            watch(property:"name", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "observer": string;
            set(property:"observer", value: string): void;
            get(property:"observer"): string;
            watch(property:"observer", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * The document this widget belongs to.  If not specified to constructor, will default to
             * srcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global
             *
             */
            "ownerDocument": Object;
            set(property:"ownerDocument", value: Object): void;
            get(property:"ownerDocument"): Object;
            watch(property:"ownerDocument", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             *
             */
            "searchContainerNode": boolean;
            set(property:"searchContainerNode", value: boolean): void;
            get(property:"searchContainerNode"): boolean;
            watch(property:"searchContainerNode", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * pointer to original DOM node
             *
             */
            "srcNodeRef": HTMLElement;
            set(property:"srcNodeRef", value: HTMLElement): void;
            get(property:"srcNodeRef"): HTMLElement;
            watch(property:"srcNodeRef", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * HTML style attributes as cssText string or name/value hash
             *
             */
            "style": string;
            set(property:"style", value: string): void;
            get(property:"style"): string;
            watch(property:"style", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "target": string;
            set(property:"target", value: string): void;
            get(property:"target"): string;
            watch(property:"target", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * HTML title attribute.
             *
             * For form widgets this specifies a tooltip to display when hovering over
             * the widget (just like the native HTML title attribute).
             *
             * For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,
             * etc., it's used to specify the tab label, accordion pane title, etc.  In this case it's
             * interpreted as HTML.
             *
             */
            "title": string;
            set(property:"title", value: string): void;
            get(property:"title"): string;
            watch(property:"title", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * When this widget's title attribute is used to for a tab label, accordion pane title, etc.,
             * this specifies the tooltip to appear when the mouse is hovered over that text.
             *
             */
            "tooltip": string;
            set(property:"tooltip", value: string): void;
            get(property:"tooltip"): string;
            watch(property:"tooltip", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "watching": boolean;
            set(property:"watching", value: boolean): void;
            get(property:"watching"): boolean;
            watch(property:"watching", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Should we parse the template to find widgets that might be
             * declared in markup inside it?  (Remove for 2.0 and assume true)
             *
             */
            "widgetsInTemplate": boolean;
            set(property:"widgetsInTemplate", value: boolean): void;
            get(property:"widgetsInTemplate"): boolean;
            watch(property:"widgetsInTemplate", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Add a class to nodes according to the supplied set of names
             *
             * @param className Class name to add.
             * @param names               OptionalIf it is an array, it is a list of names to be processed.If it is an object, dictionary keys are names to be processed.If it is omitted, all known form elements are to be processed.
             */
            addClass(className: String, names: Object): Function;
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: String, value: Object): any;
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: Object, value: Object): any;
            /**
             *
             */
            buildRendering(): void;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: Function): any;
            /**
             * Wrapper to setTimeout to avoid deferred functions executing
             * after the originating widget has been destroyed.
             * Returns an object handle with a remove method (that returns null) (replaces clearTimeout).
             *
             * @param fcn Function reference.
             * @param delay               OptionalDelay, defaults to 0.
             */
            defer(fcn: Function, delay: number): Object;
            /**
             * Destroy this widget, but not its descendants.  Descendants means widgets inside of
             * this.containerNode.   Will also destroy any resources (including widgets) registered via this.own().
             *
             * This method will also destroy internal widgets such as those created from a template,
             * assuming those widgets exist inside of this.domNode but outside of this.containerNode.
             *
             * For 2.0 it's planned that this method will also destroy descendant widgets, so apps should not
             * depend on the current ability to destroy a widget without destroying its descendants.   Generally
             * they should use destroyRecursive() for widgets with children.
             *
             * @param preserveDom If true, this method will leave the original DOM structure alone.Note: This will not yet work with _TemplatedMixin widgets
             */
            destroy(preserveDom?: boolean): void;
            /**
             * Recursively destroy the children of this widget and their
             * descendants.
             *
             * @param preserveDom               OptionalIf true, the preserveDom attribute is passed to all descendantwidget's .destroy() method. Not for use with _Templatedwidgets.
             */
            destroyDescendants(preserveDom: boolean): void;
            /**
             * Destroy this widget and its descendants
             * This is the generic "destructor" function that all widget users
             * should call to cleanly discard with a widget. Once a widget is
             * destroyed, it is removed from the manager object.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structurealone of descendant Widgets. Note: This will NOT work withdijit._TemplatedMixin widgets.
             */
            destroyRecursive(preserveDom: boolean): void;
            /**
             * Destroys the DOM nodes associated with this widget.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structure aloneduring tear-down. Note: this will not work with _Templatedwidgets yet.
             */
            destroyRendering(preserveDom?: boolean): void;
            /**
             * Disable form controls according to the supplied state object
             * returning the previous state.
             *
             * @param state               OptionalOptional. If a name-value dictionary, the value is trueto enable and false to disable. If an array, all names in thearray will be disabled. If omitted, disables all.
             */
            disable(state: Object): any;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Disconnects handle created by connect.
             *
             * @param handle
             */
            disconnect(handle: any): void;
            /**
             * Set or get a form widget/element or an attached point node by name.
             *
             * @param name The name.
             * @param value               OptionalOptional. The value to set.
             */
            elementValue(name: String, value: Object): any;
            /**
             * Used by widgets to signal that a synthetic event occurred, ex:
             *
             * myWidget.emit("attrmodified-selectedChildWidget", {}).
             * Emits an event on this.domNode named type.toLowerCase(), based on eventObj.
             * Also calls onType() method, if present, and returns value from that method.
             * By default passes eventObj to callback, but will pass callbackArgs instead, if specified.
             * Modifies eventObj by adding missing parameters (bubbles, cancelable, widget).
             *
             * @param type
             * @param eventObj               Optional
             * @param callbackArgs               Optional
             */
            emit(type: String, eventObj: Object, callbackArgs: any[]): any;
            /**
             * Enable form controls according to the supplied state object.
             *
             * @param state               OptionalOptional. If a name-value dictionary, the value is trueto enable and false to disable. If an array, all names in thearray will be set to defaultState. If omitted, all formelements will be set to defaultState.
             * @param defaultState The default state (true, if omitted).
             */
            enable(state: Object, defaultState: boolean): Function;
            /**
             * Set or get a form element by name.
             *
             * @param elem Form element's name, DOM node, or array or radio nodes.
             * @param value               OptionalOptional. The value to set.
             */
            formNodeValue(elem: String, value: Object): any;
            /**
             * Set or get a form element by name.
             *
             * @param elem Form element's name, DOM node, or array or radio nodes.
             * @param value               OptionalOptional. The value to set.
             */
            formNodeValue(elem: HTMLElement, value: Object): any;
            /**
             * Set or get a form element by name.
             *
             * @param elem Form element's name, DOM node, or array or radio nodes.
             * @param value               OptionalOptional. The value to set.
             */
            formNodeValue(elem: any[], value: Object): any;
            /**
             * Set or get a node context by name (using dojoAttachPoint).
             *
             * @param elem A node.
             * @param value               OptionalOptional. The value to set.
             */
            formPointValue(elem: String, value: Object): any;
            /**
             * Set or get a node context by name (using dojoAttachPoint).
             *
             * @param elem A node.
             * @param value               OptionalOptional. The value to set.
             */
            formPointValue(elem: Object, value: Object): any;
            /**
             * Set or get a node context by name (using dojoAttachPoint).
             *
             * @param elem A node.
             * @param value               OptionalOptional. The value to set.
             */
            formPointValue(elem: any[], value: Object): any;
            /**
             * Set or get a form widget by name.
             *
             * @param elem Form element's name, widget object, or array or radio widgets.
             * @param value               OptionalOptional. The value to set.
             */
            formWidgetValue(elem: String, value: Object): any;
            /**
             * Set or get a form widget by name.
             *
             * @param elem Form element's name, widget object, or array or radio widgets.
             * @param value               OptionalOptional. The value to set.
             */
            formWidgetValue(elem: Object, value: Object): any;
            /**
             * Set or get a form widget by name.
             *
             * @param elem Form element's name, widget object, or array or radio widgets.
             * @param value               OptionalOptional. The value to set.
             */
            formWidgetValue(elem: any[], value: Object): any;
            /**
             * Gather the presence of a certain class in all controlled elements.
             *
             * @param className The class name to test for.
             * @param names               OptionalIf it is an array, it is a list of names to be processed.If it is an object, dictionary keys are names to be processed.If it is omitted, all known form elements are to be processed.
             */
            gatherClassState(className: String, names: Object): any;
            /**
             * Gather display state of all attached elements and return as a dictionary.
             *
             * @param names               OptionalIf it is an array, it is a list of names to be processed.If it is an object, dictionary keys are names to be processed.If it is omitted, all known attach point nodes are to be processed.
             */
            gatherDisplayState(names: Object): any;
            /**
             * Gather enable state of all form elements and return as a dictionary.
             *
             * @param names               OptionalIf it is an array, it is a list of names to be processed.If it is an object, dictionary keys are names to be processed.If it is omitted, all known form elements are to be processed.
             */
            gatherEnableState(names: Object): any;
            /**
             * Collect form values.
             *
             * @param names               OptionalIf it is an array, it is a list of names of form elements to be collected.If it is an object, dictionary keys are names to be collected.If it is omitted, all known form elements are to be collected.
             */
            gatherFormValues(names: Object): any;
            /**
             * Get a property from a widget.
             * Get a named property from a widget. The property may
             * potentially be retrieved via a getter method. If no getter is defined, this
             * just retrieves the object's property.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _getFooAttr(), calling:
             * myWidget.get("foo") would be equivalent to calling
             * widget._getFooAttr() and myWidget.get("bar")
             * would be equivalent to the expression
             * widget.bar2
             *
             * @param name The property to get.
             */
            get(name: any): any;
            /**
             * Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent
             * is this widget.   Note that it does not return all descendants, but rather just direct children.
             * Analogous to Node.childNodes,
             * except containing widgets rather than DOMNodes.
             *
             * The result intentionally excludes internally created widgets (a.k.a. supporting widgets)
             * outside of this.containerNode.
             *
             * Note that the array returned is a simple array.  Application code should not assume
             * existence of methods like forEach().
             *
             */
            getChildren(): any[];
            /**
             * Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
             * This method should generally be avoided as it returns widgets declared in templates, which are
             * supposed to be internal/hidden, but it's left here for back-compat reasons.
             *
             */
            getDescendants(): any[];
            /**
             * Returns the parent widget of this widget.
             *
             */
            getParent(): any;
            /**
             * Hide attached nodes according to the supplied state object.
             *
             * @param state               OptionalOptional. If a name-value dictionary, the value is trueto show and false to hide. If an array, all names in thearray will be hidden. If omitted, all form elementswill be hidden.
             */
            hide(state: Object): any;
            /**
             * Run an inspector function on controlled elements returning a result object.
             *
             * @param inspector A function to be called on a widget, form element, and an attached node.Takes three arguments: a name, a node (domNode in the case of widget) oran array of such objects, and a supplied value. Runs in the context ofthe form manager. Returns a value that will be collected and returned as a state.
             * @param state               OptionalOptional. If a name-value dictionary --- only listed names will be processed.If an array, all names in the array will be processed with defaultValue.If omitted or null, all controlled elements will be processed with defaultValue.
             * @param defaultValue               OptionalOptional. The default state (true, if omitted).
             */
            inspect(inspector: Function, state: Object, defaultValue: Object): any;
            /**
             * Run an inspector function on "dojoAttachPoint" nodes returning a result object.
             *
             * @param inspector A function to be called on a node. Takes three arguments: a name, a node oran array of nodes, and a supplied value. Runs in the context of the form manager.Returns a value that will be collected and returned as a state.
             * @param state               OptionalOptional. If a name-value dictionary --- only listed names will be processed.If an array, all names in the array will be processed with defaultValue.If omitted or null, all attached point nodes will be processed with defaultValue.
             * @param defaultValue               OptionalOptional. The default state (true, if omitted).
             */
            inspectAttachedPoints(inspector: Function, state: Object, defaultValue: Object): Object;
            /**
             * Run an inspector function on controlled form elements returning a result object.
             *
             * @param inspector A function to be called on a form element. Takes three arguments: a name, a node oran array of nodes, and a supplied value. Runs in the context of the form manager.Returns a value that will be collected and returned as a state.
             * @param state               OptionalOptional. If a name-value dictionary --- only listed names will be processed.If an array, all names in the array will be processed with defaultValue.If omitted or null, all form elements will be processed with defaultValue.
             * @param defaultValue               OptionalOptional. The default state (true, if omitted).
             */
            inspectFormNodes(inspector: Function, state: Object, defaultValue: Object): Object;
            /**
             * Run an inspector function on controlled widgets returning a result object.
             *
             * @param inspector A function to be called on a widget. Takes three arguments: a name, a widget objector an array of widget objects, and a supplied value. Runs in the context ofthe form manager. Returns a value that will be collected and returned as a state.
             * @param state               OptionalOptional. If a name-value dictionary --- only listed names will be processed.If an array, all names in the array will be processed with defaultValue.If omitted or null, all widgets will be processed with defaultValue.
             * @param defaultValue               OptionalOptional. The default state (true, if omitted).
             */
            inspectFormWidgets(inspector: Function, state: Object, defaultValue: Object): Object;
            /**
             * Return true if this widget can currently be focused
             * and false if not
             *
             */
            isFocusable(): any;
            /**
             * Return this widget's explicit or implicit orientation (true for LTR, false for RTL)
             *
             */
            isLeftToRight(): any;
            /**
             * Make sure that every widget that has a validator function returns true.
             *
             */
            isValid: {(): boolean};
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: String, func: Function): any;
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: Function, func: Function): any;
            /**
             * Track specified handles and remove/destroy them when this instance is destroyed, unless they were
             * already removed/destroyed manually.
             *
             */
            own(): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: number): any;
            /**
             *
             */
            postCreate(): void;
            /**
             * Called after the parameters to the widget have been read-in,
             * but before the widget template is instantiated. Especially
             * useful to set properties that are referenced in the widget
             * template.
             *
             */
            postMixInProperties(): void;
            /**
             * Register a node with the form manager
             *
             * @param node A node, or its id
             */
            registerNode(node: String): any;
            /**
             * Register a node with the form manager
             *
             * @param node A node, or its id
             */
            registerNode(node: HTMLElement): any;
            /**
             * Register node's descendants (form nodes) with the form manager
             *
             * @param node A widget, or its widgetId, or its DOM node
             */
            registerNodeDescendants(node: String): any;
            /**
             * Register node's descendants (form nodes) with the form manager
             *
             * @param node A widget, or its widgetId, or its DOM node
             */
            registerNodeDescendants(node: HTMLElement): any;
            /**
             * Register a widget with the form manager
             *
             * @param widget A widget, or its widgetId, or its DOM node
             */
            registerWidget(widget: String): any;
            /**
             * Register a widget with the form manager
             *
             * @param widget A widget, or its widgetId, or its DOM node
             */
            registerWidget(widget: HTMLElement): any;
            /**
             * Register a widget with the form manager
             *
             * @param widget A widget, or its widgetId, or its DOM node
             */
            registerWidget(widget:  dijit.form._FormWidget): any;
            /**
             * Register widget's descendants with the form manager
             *
             * @param widget A widget, or its widgetId, or its DOM node
             */
            registerWidgetDescendants(widget: String): any;
            /**
             * Register widget's descendants with the form manager
             *
             * @param widget A widget, or its widgetId, or its DOM node
             */
            registerWidgetDescendants(widget: HTMLElement): any;
            /**
             * Register widget's descendants with the form manager
             *
             * @param widget A widget, or its widgetId, or its DOM node
             */
            registerWidgetDescendants(widget:  dijit._Widget): any;
            /**
             * Remove a class from nodes according to the supplied set of names
             *
             * @param className Class name to remove.
             * @param names               OptionalIf it is an array, it is a list of names to be processed.If it is an object, dictionary keys are names to be processed.If it is omitted, all known form elements are to be processed.
             */
            removeClass(className: String, names: Object): Function;
            /**
             * Resets form widget values.
             *
             */
            reset(): Function;
            /**
             * Set a property on a widget
             * Sets named properties on a widget which may potentially be handled by a
             * setter in the widget.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _setFooAttr(), calling
             * myWidget.set("foo", "Howdy!") would be equivalent to calling
             * widget._setFooAttr("Howdy!") and myWidget.set("bar", 3)
             * would be equivalent to the statement widget.bar = 3;
             *
             * set() may also be called with a hash of name/value pairs, ex:
             *
             * myWidget.set({
             *     foo: "Howdy",
             *     bar: 3
             * });
             * This is equivalent to calling set(foo, "Howdy") and set(bar, 3)
             *
             * @param name The property to set.
             * @param value The value to set in the property.
             */
            set(name: any, value: any): any;
            /**
             * Deprecated.  Use set() instead.
             *
             * @param attr
             * @param value
             */
            setAttribute(attr: String, value: any): void;
            /**
             * Set values to form elements
             *
             * @param values A dictionary of key-value pairs.
             */
            setFormValues(values: Object): Function;
            /**
             * Show attached nodes according to the supplied state object.
             *
             * @param state               OptionalOptional. If a name-value dictionary, the value is trueto show and false to hide. If an array, all names in thearray will be set to defaultState. If omitted, all formelements will be set to defaultState.
             * @param defaultState               OptionalThe default state (true, if omitted).
             */
            show(state: Object, defaultState: boolean): Function;
            /**
             * Processing after the DOM fragment is added to the document
             * Called after a widget and its children have been created and added to the page,
             * and all related widgets have finished their create() cycle, up through postCreate().
             *
             * Note that startup() may be called while the widget is still hidden, for example if the widget is
             * inside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.
             * For widgets that need to do layout, it's best to put that layout code inside resize(), and then
             * extend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.
             *
             */
            startup(): void;
            /**
             * programmatically submit form if and only if the onSubmit returns true
             *
             */
            submit(): void;
            /**
             * Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.
             *
             * Subscribes to the specified topic and calls the specified method
             * of this object and registers for unsubscribe() on widget destroy.
             *
             * Provide widget-specific analog to dojo.subscribe, except with the
             * implicit use of this widget as the target object.
             *
             * @param t The topic
             * @param method The callback
             */
            subscribe(t: String, method: Function): any;
            /**
             * Returns a string that represents the widget.
             * When a widget is cast to a string, this method will be used to generate the
             * output. Currently, it does not implement any sort of reversible
             * serialization.
             *
             */
            toString(): string;
            /**
             * Deprecated. Override destroy() instead to implement custom widget tear-down
             * behavior.
             *
             */
            uninitialize(): boolean;
            /**
             * Removes the node by name from internal tables unregistering
             * connected observers
             *
             * @param name Name of the to unregister
             */
            unregisterNode(name: String): any;
            /**
             * Unregister node's descendants (form nodes) with the form manager
             *
             * @param node A widget, or its widgetId, or its DOM node
             */
            unregisterNodeDescendants(node: String): any;
            /**
             * Unregister node's descendants (form nodes) with the form manager
             *
             * @param node A widget, or its widgetId, or its DOM node
             */
            unregisterNodeDescendants(node: HTMLElement): any;
            /**
             * Removes the widget by name from internal tables unregistering
             * connected observers
             *
             * @param name Name of the to unregister
             */
            unregisterWidget(name: string): any;
            /**
             * Unregister widget's descendants with the form manager
             *
             * @param widget A widget, or its widgetId, or its DOM node
             */
            unregisterWidgetDescendants(widget: String): any;
            /**
             * Unregister widget's descendants with the form manager
             *
             * @param widget A widget, or its widgetId, or its DOM node
             */
            unregisterWidgetDescendants(widget: HTMLElement): any;
            /**
             * Unregister widget's descendants with the form manager
             *
             * @param widget A widget, or its widgetId, or its DOM node
             */
            unregisterWidgetDescendants(widget:  dijit._Widget): any;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Unsubscribes handle created by this.subscribe.
             * Also removes handle from this widget's list of subscriptions
             *
             * @param handle
             */
            unsubscribe(handle: Object): void;
            /**
             * validate() returns if the form is valid - same as isValid -
             * but provides a few additional (ui-specific) features: it
             * will highlight any sub-widgets that are not valid it will
             * call focus() on the first invalid sub-widget
             *
             */
            validate(): boolean;
            /**
             * Watches a property for changes
             *
             * @param name               OptionalIndicates the property to watch. This is optional (the callback may be theonly parameter), and if omitted, all the properties will be watched
             * @param callback The function to execute when the property changes. This will be called afterthe property has been changed. The callback will be called with the |this|set to the instance, the first argument as the name of the property, thesecond argument as the old value and the third argument as the new value.
             */
            watch(property: string, callback:{(property?:string, oldValue?:any, newValue?: any):void}) :{unwatch():void};
            /**
             * Called when the widget stops being "active" because
             * focus moved to something outside of it, or the user
             * clicked somewhere outside of it, or the widget was
             * hidden.
             *
             */
            onBlur(): void;
            /**
             * Connect to this function to receive notifications of mouse click events.
             *
             * @param event mouse Event
             */
            onClick(event: any): void;
            /**
             * Called when this widget is being displayed as a popup (ex: a Calendar popped
             * up from a DateTextBox), and it is hidden.
             * This is called from the dijit.popup code, and should not be called directly.
             *
             * Also used as a parameter for children of dijit/layout/StackContainer or subclasses.
             * Callback if a user tries to close the child.   Child will be closed if this function returns true.
             *
             */
            onClose(): boolean;
            /**
             * Connect to this function to receive notifications of mouse double click events.
             *
             * @param event mouse Event
             */
            onDblClick(event: any): void;
            /**
             * Called when the widget becomes "active" because
             * it or a widget inside of it either has focus, or has recently
             * been clicked.
             *
             */
            onFocus(): void;
            /**
             * Called when another widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate hide of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onHide(): void;
            /**
             * Connect to this function to receive notifications of keys being pressed down.
             *
             * @param event key Event
             */
            onKeyDown(event: any): void;
            /**
             * Connect to this function to receive notifications of printable keys being typed.
             *
             * @param event key Event
             */
            onKeyPress(event: any): void;
            /**
             * Connect to this function to receive notifications of keys being released.
             *
             * @param event key Event
             */
            onKeyUp(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is pressed down.
             *
             * @param event mouse Event
             */
            onMouseDown(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto this widget.
             *
             * @param event mouse Event
             */
            onMouseEnter(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of this widget.
             *
             * @param event mouse Event
             */
            onMouseLeave(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseMove(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOut(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOver(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is released.
             *
             * @param event mouse Event
             */
            onMouseUp(event: any): void;
            /**
             * Callback when user resets the form. This method is intended
             * to be over-ridden. When the reset method is called
             * programmatically, the return value from onReset is used
             * to compute whether or not resetting should proceed
             *
             */
            onReset(): boolean;
            /**
             * Called when this widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate display of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onShow(): void;
            /**
             * Callback when user submits the form. This method is
             * intended to be over-ridden, but by default it checks and
             * returns the validity of form elements. When the submit
             * method is called programmatically, the return value from
             * onSubmit is used to compute whether or not submission
             * should proceed
             *
             */
            onSubmit(): any;
        }
        /**
         * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/RangeSlider.html
         *
         *
         */
        class RangeSlider {
            constructor();
            /**
             *
             */
            "value": any[];
            /**
             *
             */
            destroy(): void;
            /**
             *
             */
            postCreate(): void;
            /**
             *
             */
            postMixInProperties(): void;
        }
        /**
         * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/Rating.html
         *
         * A widget for rating using stars.
         *
         * @param params Hash of initialization parameters for widget, including scalar values (like title, duration etc.)and functions, typically callbacks like onClick.The hash can contain any of the widget's properties, excluding read-only properties.
         * @param srcNodeRef       OptionalIf a srcNodeRef (DOM node) is specified:use srcNodeRef.innerHTML as my contentsif this is a behavioral widget then apply behavior to that srcNodeRefotherwise, replace srcNodeRef with my generated DOM tree
         */
        class Rating extends dijit.form._FormWidget {
            constructor(params?: Object, srcNodeRef?: HTMLElement);
            /**
             * True if mouse was pressed while over this widget, and hasn't been released yet
             *
             */
            "active": boolean;
            set(property:"active", value: boolean): void;
            get(property:"active"): boolean;
            watch(property:"active", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "alt": string;
            set(property:"alt", value: string): void;
            get(property:"alt"): string;
            watch(property:"alt", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "aria-label": string;
            set(property:"aria-label", value: string): void;
            get(property:"aria-label"): string;
            watch(property:"aria-label", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Object to which attach points and events will be scoped.  Defaults
             * to 'this'.
             *
             */
            "attachScope": Object;
            set(property:"attachScope", value: Object): void;
            get(property:"attachScope"): Object;
            watch(property:"attachScope", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute
             * for each XXX attribute to be mapped to the DOM.
             *
             * attributeMap sets up a "binding" between attributes (aka properties)
             * of the widget and the widget's DOM.
             * Changes to widget attributes listed in attributeMap will be
             * reflected into the DOM.
             *
             * For example, calling set('title', 'hello')
             * on a TitlePane will automatically cause the TitlePane's DOM to update
             * with the new title.
             *
             * attributeMap is a hash where the key is an attribute of the widget,
             * and the value reflects a binding to a:
             *
             * DOM node attribute
             *   focus: {node: "focusNode", type: "attribute"}
             * Maps this.focus to this.focusNode.focus
             *
             * DOM node innerHTML
             *   title: { node: "titleNode", type: "innerHTML" }
             * Maps this.title to this.titleNode.innerHTML
             *
             * DOM node innerText
             *   title: { node: "titleNode", type: "innerText" }
             * Maps this.title to this.titleNode.innerText
             *
             * DOM node CSS class
             *   myClass: { node: "domNode", type: "class" }
             * Maps this.myClass to this.domNode.className
             *
             * If the value is an array, then each element in the array matches one of the
             * formats of the above list.
             *
             * There are also some shorthands for backwards compatibility:
             *
             * string --> { node: string, type: "attribute" }, for example:
             * "focusNode" ---> { node: "focusNode", type: "attribute" }
             * "" --> { node: "domNode", type: "attribute" }
             *
             */
            "attributeMap": Object;
            set(property:"attributeMap", value: Object): void;
            get(property:"attributeMap"): Object;
            watch(property:"attributeMap", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate
             * widget state.
             *
             */
            "baseClass": string;
            set(property:"baseClass", value: string): void;
            get(property:"baseClass"): string;
            watch(property:"baseClass", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "class": string;
            set(property:"class", value: string): void;
            get(property:"class"): string;
            watch(property:"class", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Designates where children of the source DOM node will be placed.
             * "Children" in this case refers to both DOM nodes and widgets.
             * For example, for myWidget:
             *
             * <div data-dojo-type=myWidget>
             *     <b> here's a plain DOM node
             *     <span data-dojo-type=subWidget>and a widget</span>
             *     <i> and another plain DOM node </i>
             * </div>
             * containerNode would point to:
             *
             * <b> here's a plain DOM node
             * <span data-dojo-type=subWidget>and a widget</span>
             * <i> and another plain DOM node </i>
             * In templated widgets, "containerNode" is set via a
             * data-dojo-attach-point assignment.
             *
             * containerNode must be defined for any widget that accepts innerHTML
             * (like ContentPane or BorderContainer or even Button), and conversely
             * is null for widgets that don't, like TextBox.
             *
             */
            "containerNode": HTMLElement;
            set(property:"containerNode", value: HTMLElement): void;
            get(property:"containerNode"): HTMLElement;
            watch(property:"containerNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * Subclasses may define a cssStateNodes property that lists sub-nodes within the widget that
             * need CSS classes applied on mouse hover/press and focus.
             *
             * Each entry in this optional hash is a an attach-point name (like "upArrowButton") mapped to a CSS class name
             * (like "dijitUpArrowButton"). Example:
             *
             * {
             *     "upArrowButton": "dijitUpArrowButton",
             *     "downArrowButton": "dijitDownArrowButton"
             * }
             * The above will set the CSS class dijitUpArrowButton to the this.upArrowButton DOMNode when it
             *
             * is hovered, etc.
             *
             */
            "cssStateNodes": Object;
            set(property:"cssStateNodes", value: Object): void;
            get(property:"cssStateNodes"): Object;
            watch(property:"cssStateNodes", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Bi-directional support, as defined by the HTML DIR
             * attribute. Either left-to-right "ltr" or right-to-left "rtl".  If undefined, widgets renders in page's
             * default direction.
             *
             */
            "dir": string;
            set(property:"dir", value: string): void;
            get(property:"dir"): string;
            watch(property:"dir", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Should this widget respond to user input?
             * In markup, this is specified as "disabled='disabled'", or just "disabled".
             *
             */
            "disabled": boolean;
            set(property:"disabled", value: boolean): void;
            get(property:"disabled"): boolean;
            watch(property:"disabled", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * This is our visible representation of the widget! Other DOM
             * Nodes may by assigned to other properties, usually through the
             * template system's data-dojo-attach-point syntax, but the domNode
             * property is the canonical "top level" node in widget UI.
             *
             */
            "domNode": HTMLElement;
            set(property:"domNode", value: HTMLElement): void;
            get(property:"domNode"): HTMLElement;
            watch(property:"domNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * This widget or a widget it contains has focus, or is "active" because
             * it was recently clicked.
             *
             */
            "focused": boolean;
            set(property:"focused", value: boolean): void;
            get(property:"focused"): boolean;
            watch(property:"focused", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * True if cursor is over this widget
             *
             */
            "hovering": boolean;
            set(property:"hovering", value: boolean): void;
            get(property:"hovering"): boolean;
            watch(property:"hovering", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * A unique, opaque ID string that can be assigned by users or by the
             * system. If the developer passes an ID which is known not to be
             * unique, the specified ID is ignored and the system-generated ID is
             * used instead.
             *
             */
            "id": string;
            set(property:"id", value: string): void;
            get(property:"id"): string;
            watch(property:"id", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Fires onChange for each value change or only on demand
             *
             */
            "intermediateChanges": boolean;
            set(property:"intermediateChanges", value: boolean): void;
            get(property:"intermediateChanges"): boolean;
            watch(property:"intermediateChanges", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Rarely used.  Overrides the default Dojo locale used to render this widget,
             * as defined by the HTML LANG attribute.
             * Value must be among the list of locales specified during by the Dojo bootstrap,
             * formatted according to RFC 3066 (like en-us).
             *
             */
            "lang": string;
            set(property:"lang", value: string): void;
            get(property:"lang"): string;
            watch(property:"lang", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Name used when submitting form; same as "name" attribute or plain HTML elements
             *
             */
            "name": string;
            set(property:"name", value: string): void;
            get(property:"name"): string;
            watch(property:"name", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * The number of stars to show, default is 3.
             *
             */
            "numStars": number;
            set(property:"numStars", value: number): void;
            get(property:"numStars"): number;
            watch(property:"numStars", callback:{(property?:string, oldValue?:number, newValue?: number):void}) :{unwatch():void}
            /**
             * The document this widget belongs to.  If not specified to constructor, will default to
             * srcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global
             *
             */
            "ownerDocument": Object;
            set(property:"ownerDocument", value: Object): void;
            get(property:"ownerDocument"): Object;
            watch(property:"ownerDocument", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * TODO: Can be true or false, default is false.
             *
             */
            "required": boolean;
            set(property:"required", value: boolean): void;
            get(property:"required"): boolean;
            watch(property:"required", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * On focus, should this widget scroll into view?
             *
             */
            "scrollOnFocus": boolean;
            set(property:"scrollOnFocus", value: boolean): void;
            get(property:"scrollOnFocus"): boolean;
            watch(property:"scrollOnFocus", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             *
             */
            "searchContainerNode": boolean;
            set(property:"searchContainerNode", value: boolean): void;
            get(property:"searchContainerNode"): boolean;
            watch(property:"searchContainerNode", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * pointer to original DOM node
             *
             */
            "srcNodeRef": HTMLElement;
            set(property:"srcNodeRef", value: HTMLElement): void;
            get(property:"srcNodeRef"): HTMLElement;
            watch(property:"srcNodeRef", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * HTML style attributes as cssText string or name/value hash
             *
             */
            "style": string;
            set(property:"style", value: string): void;
            get(property:"style"): string;
            watch(property:"style", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Order fields are traversed when user hits the tab key
             *
             */
            "tabIndex": string;
            set(property:"tabIndex", value: string): void;
            get(property:"tabIndex"): string;
            watch(property:"tabIndex", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Path to template (HTML file) for this widget relative to dojo.baseUrl.
             * Deprecated: use templateString with require([... "dojo/text!..."], ...) instead
             *
             */
            "templatePath": string;
            set(property:"templatePath", value: string): void;
            get(property:"templatePath"): string;
            watch(property:"templatePath", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "templateString": string;
            set(property:"templateString", value: string): void;
            get(property:"templateString"): string;
            watch(property:"templateString", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * HTML title attribute.
             *
             * For form widgets this specifies a tooltip to display when hovering over
             * the widget (just like the native HTML title attribute).
             *
             * For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,
             * etc., it's used to specify the tab label, accordion pane title, etc.  In this case it's
             * interpreted as HTML.
             *
             */
            "title": string;
            set(property:"title", value: string): void;
            get(property:"title"): string;
            watch(property:"title", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * When this widget's title attribute is used to for a tab label, accordion pane title, etc.,
             * this specifies the tooltip to appear when the mouse is hovered over that text.
             *
             */
            "tooltip": string;
            set(property:"tooltip", value: string): void;
            get(property:"tooltip"): string;
            watch(property:"tooltip", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "type": string;
            set(property:"type", value: string): void;
            get(property:"type"): string;
            watch(property:"type", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * The current value of the Rating
             *
             */
            "value": number;
            set(property:"value", value: number): void;
            get(property:"value"): number;
            watch(property:"value", callback:{(property?:string, oldValue?:number, newValue?: number):void}) :{unwatch():void}
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: String, value: Object): any;
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: Object, value: Object): any;
            /**
             * Build the templateString. The number of stars is given by this.numStars,
             * which is normally an attribute to the widget node.
             *
             * @param params
             */
            buildRendering(params?: Object): void;
            /**
             * Compare 2 values (as returned by get('value') for this widget).
             *
             * @param val1
             * @param val2
             */
            compare(val1: any, val2: any): number;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: Function): any;
            /**
             * Wrapper to setTimeout to avoid deferred functions executing
             * after the originating widget has been destroyed.
             * Returns an object handle with a remove method (that returns null) (replaces clearTimeout).
             *
             * @param fcn Function reference.
             * @param delay               OptionalDelay, defaults to 0.
             */
            defer(fcn: Function, delay: number): Object;
            /**
             * Destroy this widget, but not its descendants.  Descendants means widgets inside of
             * this.containerNode.   Will also destroy any resources (including widgets) registered via this.own().
             *
             * This method will also destroy internal widgets such as those created from a template,
             * assuming those widgets exist inside of this.domNode but outside of this.containerNode.
             *
             * For 2.0 it's planned that this method will also destroy descendant widgets, so apps should not
             * depend on the current ability to destroy a widget without destroying its descendants.   Generally
             * they should use destroyRecursive() for widgets with children.
             *
             * @param preserveDom If true, this method will leave the original DOM structure alone.Note: This will not yet work with _TemplatedMixin widgets
             */
            destroy(preserveDom?: boolean): void;
            /**
             * Recursively destroy the children of this widget and their
             * descendants.
             *
             * @param preserveDom               OptionalIf true, the preserveDom attribute is passed to all descendantwidget's .destroy() method. Not for use with _Templatedwidgets.
             */
            destroyDescendants(preserveDom: boolean): void;
            /**
             * Destroy this widget and its descendants
             * This is the generic "destructor" function that all widget users
             * should call to cleanly discard with a widget. Once a widget is
             * destroyed, it is removed from the manager object.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structurealone of descendant Widgets. Note: This will NOT work withdijit._TemplatedMixin widgets.
             */
            destroyRecursive(preserveDom: boolean): void;
            /**
             * Destroys the DOM nodes associated with this widget.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structure aloneduring tear-down. Note: this will not work with _Templatedwidgets yet.
             */
            destroyRendering(preserveDom?: boolean): void;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Disconnects handle created by connect.
             *
             * @param handle
             */
            disconnect(handle: any): void;
            /**
             * Used by widgets to signal that a synthetic event occurred, ex:
             *
             * myWidget.emit("attrmodified-selectedChildWidget", {}).
             * Emits an event on this.domNode named type.toLowerCase(), based on eventObj.
             * Also calls onType() method, if present, and returns value from that method.
             * By default passes eventObj to callback, but will pass callbackArgs instead, if specified.
             * Modifies eventObj by adding missing parameters (bubbles, cancelable, widget).
             *
             * @param type
             * @param eventObj               Optional
             * @param callbackArgs               Optional
             */
            emit(type: String, eventObj: Object, callbackArgs: any[]): any;
            /**
             * Put focus on this widget
             *
             */
            focus(): void;
            /**
             * Get a property from a widget.
             * Get a named property from a widget. The property may
             * potentially be retrieved via a getter method. If no getter is defined, this
             * just retrieves the object's property.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _getFooAttr(), calling:
             * myWidget.get("foo") would be equivalent to calling
             * widget._getFooAttr() and myWidget.get("bar")
             * would be equivalent to the expression
             * widget.bar2
             *
             * @param name The property to get.
             */
            get(name: any): any;
            /**
             * Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent
             * is this widget.   Note that it does not return all descendants, but rather just direct children.
             * Analogous to Node.childNodes,
             * except containing widgets rather than DOMNodes.
             *
             * The result intentionally excludes internally created widgets (a.k.a. supporting widgets)
             * outside of this.containerNode.
             *
             * Note that the array returned is a simple array.  Application code should not assume
             * existence of methods like forEach().
             *
             */
            getChildren(): any[];
            /**
             * Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
             * This method should generally be avoided as it returns widgets declared in templates, which are
             * supposed to be internal/hidden, but it's left here for back-compat reasons.
             *
             */
            getDescendants(): any[];
            /**
             * Returns the parent widget of this widget.
             *
             */
            getParent(): any;
            /**
             * Deprecated.  Use get('value') instead.
             *
             */
            getValue(): any;
            /**
             * Return true if this widget can currently be focused
             * and false if not
             *
             */
            isFocusable(): any;
            /**
             * Return this widget's explicit or implicit orientation (true for LTR, false for RTL)
             *
             */
            isLeftToRight(): any;
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: String, func: Function): any;
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: Function, func: Function): any;
            /**
             * Track specified handles and remove/destroy them when this instance is destroyed, unless they were
             * already removed/destroyed manually.
             *
             */
            own(): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: number): any;
            /**
             *
             */
            postCreate(): void;
            /**
             *
             */
            postMixInProperties(): void;
            /**
             * Set a property on a widget
             * Sets named properties on a widget which may potentially be handled by a
             * setter in the widget.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _setFooAttr(), calling
             * myWidget.set("foo", "Howdy!") would be equivalent to calling
             * widget._setFooAttr("Howdy!") and myWidget.set("bar", 3)
             * would be equivalent to the statement widget.bar = 3;
             *
             * set() may also be called with a hash of name/value pairs, ex:
             *
             * myWidget.set({
             *     foo: "Howdy",
             *     bar: 3
             * });
             * This is equivalent to calling set(foo, "Howdy") and set(bar, 3)
             *
             * @param name The property to set.
             * @param value The value to set in the property.
             */
            set(name: any, value: any): any;
            /**
             * Deprecated.   Use set("value", ...) instead.
             *
             * @param key
             * @param value
             */
            setAttribute(key: String, value: number): void;
            /**
             * Deprecated.  Use set('disabled', ...) instead.
             *
             * @param disabled
             */
            setDisabled(disabled: boolean): void;
            /**
             * Deprecated.  Use set('value', ...) instead.
             *
             * @param value
             */
            setValue(value: String): void;
            /**
             * Processing after the DOM fragment is added to the document
             * Called after a widget and its children have been created and added to the page,
             * and all related widgets have finished their create() cycle, up through postCreate().
             *
             * Note that startup() may be called while the widget is still hidden, for example if the widget is
             * inside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.
             * For widgets that need to do layout, it's best to put that layout code inside resize(), and then
             * extend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.
             *
             */
            startup(): void;
            /**
             * Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.
             *
             * Subscribes to the specified topic and calls the specified method
             * of this object and registers for unsubscribe() on widget destroy.
             *
             * Provide widget-specific analog to dojo.subscribe, except with the
             * implicit use of this widget as the target object.
             *
             * @param t The topic
             * @param method The callback
             */
            subscribe(t: String, method: Function): any;
            /**
             * Returns a string that represents the widget.
             * When a widget is cast to a string, this method will be used to generate the
             * output. Currently, it does not implement any sort of reversible
             * serialization.
             *
             */
            toString(): string;
            /**
             * Deprecated. Override destroy() instead to implement custom widget tear-down
             * behavior.
             *
             */
            uninitialize(): boolean;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Unsubscribes handle created by this.subscribe.
             * Also removes handle from this widget's list of subscriptions
             *
             * @param handle
             */
            unsubscribe(handle: Object): void;
            /**
             * Watches a property for changes
             *
             * @param name               OptionalIndicates the property to watch. This is optional (the callback may be theonly parameter), and if omitted, all the properties will be watched
             * @param callback The function to execute when the property changes. This will be called afterthe property has been changed. The callback will be called with the |this|set to the instance, the first argument as the name of the property, thesecond argument as the old value and the third argument as the new value.
             */
            watch(property: string, callback:{(property?:string, oldValue?:any, newValue?: any):void}) :{unwatch():void};
            /**
             * Static method to get a template based on the templatePath or
             * templateString key
             */
            getCachedTemplate(): any;
            /**
             * Called when the widget stops being "active" because
             * focus moved to something outside of it, or the user
             * clicked somewhere outside of it, or the widget was
             * hidden.
             *
             */
            onBlur(): void;
            /**
             * Callback when this widget's value is changed.
             *
             * @param newValue
             */
            onChange(newValue: any): void;
            /**
             * Connect to this function to receive notifications of mouse click events.
             *
             * @param event mouse Event
             */
            onClick(event: any): void;
            /**
             * Called when this widget is being displayed as a popup (ex: a Calendar popped
             * up from a DateTextBox), and it is hidden.
             * This is called from the dijit.popup code, and should not be called directly.
             *
             * Also used as a parameter for children of dijit/layout/StackContainer or subclasses.
             * Callback if a user tries to close the child.   Child will be closed if this function returns true.
             *
             */
            onClose(): boolean;
            /**
             * Connect to this function to receive notifications of mouse double click events.
             *
             * @param event mouse Event
             */
            onDblClick(event: any): void;
            /**
             * Called when the widget becomes "active" because
             * it or a widget inside of it either has focus, or has recently
             * been clicked.
             *
             */
            onFocus(): void;
            /**
             * Called when another widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate hide of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onHide(): void;
            /**
             * Connect to this function to receive notifications of keys being pressed down.
             *
             * @param event key Event
             */
            onKeyDown(event: any): void;
            /**
             * Connect to this function to receive notifications of printable keys being typed.
             *
             * @param event key Event
             */
            onKeyPress(event: any): void;
            /**
             * Connect to this function to receive notifications of keys being released.
             *
             * @param event key Event
             */
            onKeyUp(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is pressed down.
             *
             * @param event mouse Event
             */
            onMouseDown(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto this widget.
             *
             * @param event mouse Event
             */
            onMouseEnter(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of this widget.
             *
             * @param event mouse Event
             */
            onMouseLeave(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseMove(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOut(event: any): void;
            /**
             * Connect here, the value is passed to this function as the second parameter!
             *
             * @param evt
             * @param value
             */
            onMouseOver(evt: any, value?: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is released.
             *
             * @param event mouse Event
             */
            onMouseUp(event: any): void;
            /**
             * Called when this widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate display of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onShow(): void;
            /**
             * Connect on this method to get noticed when a star was clicked.
             *
             * @param evt
             */
            onStarClick(evt: Event): void;
        }
        /**
         * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/TriStateCheckBox.html
         *
         * Checkbox with three states
         *
         */
        class TriStateCheckBox extends dijit.form.Button implements dijit.form._ToggleButtonMixin {
            constructor();
            /**
             * True if mouse was pressed while over this widget, and hasn't been released yet
             *
             */
            "active": boolean;
            set(property:"active", value: boolean): void;
            get(property:"active"): boolean;
            watch(property:"active", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "alt": string;
            set(property:"alt", value: string): void;
            get(property:"alt"): string;
            watch(property:"alt", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "aria-label": string;
            set(property:"aria-label", value: string): void;
            get(property:"aria-label"): string;
            watch(property:"aria-label", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Object to which attach points and events will be scoped.  Defaults
             * to 'this'.
             *
             */
            "attachScope": Object;
            set(property:"attachScope", value: Object): void;
            get(property:"attachScope"): Object;
            watch(property:"attachScope", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute
             * for each XXX attribute to be mapped to the DOM.
             *
             * attributeMap sets up a "binding" between attributes (aka properties)
             * of the widget and the widget's DOM.
             * Changes to widget attributes listed in attributeMap will be
             * reflected into the DOM.
             *
             * For example, calling set('title', 'hello')
             * on a TitlePane will automatically cause the TitlePane's DOM to update
             * with the new title.
             *
             * attributeMap is a hash where the key is an attribute of the widget,
             * and the value reflects a binding to a:
             *
             * DOM node attribute
             *   focus: {node: "focusNode", type: "attribute"}
             * Maps this.focus to this.focusNode.focus
             *
             * DOM node innerHTML
             *   title: { node: "titleNode", type: "innerHTML" }
             * Maps this.title to this.titleNode.innerHTML
             *
             * DOM node innerText
             *   title: { node: "titleNode", type: "innerText" }
             * Maps this.title to this.titleNode.innerText
             *
             * DOM node CSS class
             *   myClass: { node: "domNode", type: "class" }
             * Maps this.myClass to this.domNode.className
             *
             * If the value is an array, then each element in the array matches one of the
             * formats of the above list.
             *
             * There are also some shorthands for backwards compatibility:
             *
             * string --> { node: string, type: "attribute" }, for example:
             * "focusNode" ---> { node: "focusNode", type: "attribute" }
             * "" --> { node: "domNode", type: "attribute" }
             *
             */
            "attributeMap": Object;
            set(property:"attributeMap", value: Object): void;
            get(property:"attributeMap"): Object;
            watch(property:"attributeMap", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             *
             */
            "baseClass": string;
            set(property:"baseClass", value: string): void;
            get(property:"baseClass"): string;
            watch(property:"baseClass", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Current check state of the check box.
             *
             */
            "checked": boolean;
            set(property:"checked", value: boolean): void;
            get(property:"checked"): boolean;
            watch(property:"checked", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             *
             */
            "class": string;
            set(property:"class", value: string): void;
            get(property:"class"): string;
            watch(property:"class", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Designates where children of the source DOM node will be placed.
             * "Children" in this case refers to both DOM nodes and widgets.
             * For example, for myWidget:
             *
             * <div data-dojo-type=myWidget>
             *     <b> here's a plain DOM node
             *     <span data-dojo-type=subWidget>and a widget</span>
             *     <i> and another plain DOM node </i>
             * </div>
             * containerNode would point to:
             *
             * <b> here's a plain DOM node
             * <span data-dojo-type=subWidget>and a widget</span>
             * <i> and another plain DOM node </i>
             * In templated widgets, "containerNode" is set via a
             * data-dojo-attach-point assignment.
             *
             * containerNode must be defined for any widget that accepts innerHTML
             * (like ContentPane or BorderContainer or even Button), and conversely
             * is null for widgets that don't, like TextBox.
             *
             */
            "containerNode": HTMLElement;
            set(property:"containerNode", value: HTMLElement): void;
            get(property:"containerNode"): HTMLElement;
            watch(property:"containerNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * Subclasses may define a cssStateNodes property that lists sub-nodes within the widget that
             * need CSS classes applied on mouse hover/press and focus.
             *
             * Each entry in this optional hash is a an attach-point name (like "upArrowButton") mapped to a CSS class name
             * (like "dijitUpArrowButton"). Example:
             *
             * {
             *     "upArrowButton": "dijitUpArrowButton",
             *     "downArrowButton": "dijitDownArrowButton"
             * }
             * The above will set the CSS class dijitUpArrowButton to the this.upArrowButton DOMNode when it
             *
             * is hovered, etc.
             *
             */
            "cssStateNodes": Object;
            set(property:"cssStateNodes", value: Object): void;
            get(property:"cssStateNodes"): Object;
            watch(property:"cssStateNodes", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Bi-directional support, as defined by the HTML DIR
             * attribute. Either left-to-right "ltr" or right-to-left "rtl".  If undefined, widgets renders in page's
             * default direction.
             *
             */
            "dir": string;
            set(property:"dir", value: string): void;
            get(property:"dir"): string;
            watch(property:"dir", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Should this widget respond to user input?
             * In markup, this is specified as "disabled='disabled'", or just "disabled".
             *
             */
            "disabled": boolean;
            set(property:"disabled", value: boolean): void;
            get(property:"disabled"): boolean;
            watch(property:"disabled", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * This is our visible representation of the widget! Other DOM
             * Nodes may by assigned to other properties, usually through the
             * template system's data-dojo-attach-point syntax, but the domNode
             * property is the canonical "top level" node in widget UI.
             *
             */
            "domNode": HTMLElement;
            set(property:"domNode", value: HTMLElement): void;
            get(property:"domNode"): HTMLElement;
            watch(property:"domNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * This widget or a widget it contains has focus, or is "active" because
             * it was recently clicked.
             *
             */
            "focused": boolean;
            set(property:"focused", value: boolean): void;
            get(property:"focused"): boolean;
            watch(property:"focused", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * True if cursor is over this widget
             *
             */
            "hovering": boolean;
            set(property:"hovering", value: boolean): void;
            get(property:"hovering"): boolean;
            watch(property:"hovering", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Class to apply to DOMNode in button to make it display an icon
             *
             */
            "iconClass": string;
            set(property:"iconClass", value: string): void;
            get(property:"iconClass"): string;
            watch(property:"iconClass", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * A unique, opaque ID string that can be assigned by users or by the
             * system. If the developer passes an ID which is known not to be
             * unique, the specified ID is ignored and the system-generated ID is
             * used instead.
             *
             */
            "id": string;
            set(property:"id", value: string): void;
            get(property:"id"): string;
            watch(property:"id", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Fires onChange for each value change or only on demand
             *
             */
            "intermediateChanges": boolean;
            set(property:"intermediateChanges", value: boolean): void;
            get(property:"intermediateChanges"): boolean;
            watch(property:"intermediateChanges", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Content to display in button.
             *
             */
            "label": string;
            set(property:"label", value: string): void;
            get(property:"label"): string;
            watch(property:"label", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Rarely used.  Overrides the default Dojo locale used to render this widget,
             * as defined by the HTML LANG attribute.
             * Value must be among the list of locales specified during by the Dojo bootstrap,
             * formatted according to RFC 3066 (like en-us).
             *
             */
            "lang": string;
            set(property:"lang", value: string): void;
            get(property:"lang"): string;
            watch(property:"lang", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Name used when submitting form; same as "name" attribute or plain HTML elements
             *
             */
            "name": string;
            set(property:"name", value: string): void;
            get(property:"name"): string;
            watch(property:"name", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * The document this widget belongs to.  If not specified to constructor, will default to
             * srcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global
             *
             */
            "ownerDocument": Object;
            set(property:"ownerDocument", value: Object): void;
            get(property:"ownerDocument"): Object;
            watch(property:"ownerDocument", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Should this widget respond to user input?
             * In markup, this is specified as "readOnly".
             * Similar to disabled except readOnly form values are submitted.
             *
             */
            "readOnly": boolean;
            set(property:"readOnly", value: boolean): void;
            get(property:"readOnly"): boolean;
            watch(property:"readOnly", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * On focus, should this widget scroll into view?
             *
             */
            "scrollOnFocus": boolean;
            set(property:"scrollOnFocus", value: boolean): void;
            get(property:"scrollOnFocus"): boolean;
            watch(property:"scrollOnFocus", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             *
             */
            "searchContainerNode": boolean;
            set(property:"searchContainerNode", value: boolean): void;
            get(property:"searchContainerNode"): boolean;
            watch(property:"searchContainerNode", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Set this to true to hide the label text and display only the icon.
             * (If showLabel=false then iconClass must be specified.)
             * Especially useful for toolbars.
             * If showLabel=true, the label will become the title (a.k.a. tooltip/hint) of the icon.
             *
             * The exception case is for computers in high-contrast mode, where the label
             * will still be displayed, since the icon doesn't appear.
             *
             */
            "showLabel": boolean;
            set(property:"showLabel", value: boolean): void;
            get(property:"showLabel"): boolean;
            watch(property:"showLabel", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * pointer to original DOM node
             *
             */
            "srcNodeRef": HTMLElement;
            set(property:"srcNodeRef", value: HTMLElement): void;
            get(property:"srcNodeRef"): HTMLElement;
            watch(property:"srcNodeRef", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * States of TriStateCheckBox.
             * The value of This.checked should be one of these three states:
             * [false, true, "mixed"]
             *
             */
            "states": any[];
            set(property:"states", value: any[]): void;
            get(property:"states"): any[];
            watch(property:"states", callback:{(property?:string, oldValue?:any[], newValue?: any[]):void}) :{unwatch():void}
            /**
             *
             */
            "stateValue": Object;
            set(property:"stateValue", value: Object): void;
            get(property:"stateValue"): Object;
            watch(property:"stateValue", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * HTML style attributes as cssText string or name/value hash
             *
             */
            "style": string;
            set(property:"style", value: string): void;
            get(property:"style"): string;
            watch(property:"style", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Order fields are traversed when user hits the tab key
             *
             */
            "tabIndex": string;
            set(property:"tabIndex", value: string): void;
            get(property:"tabIndex"): string;
            watch(property:"tabIndex", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Path to template (HTML file) for this widget relative to dojo.baseUrl.
             * Deprecated: use templateString with require([... "dojo/text!..."], ...) instead
             *
             */
            "templatePath": string;
            set(property:"templatePath", value: string): void;
            get(property:"templatePath"): string;
            watch(property:"templatePath", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "templateString": string;
            set(property:"templateString", value: string): void;
            get(property:"templateString"): string;
            watch(property:"templateString", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * HTML title attribute.
             *
             * For form widgets this specifies a tooltip to display when hovering over
             * the widget (just like the native HTML title attribute).
             *
             * For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,
             * etc., it's used to specify the tab label, accordion pane title, etc.  In this case it's
             * interpreted as HTML.
             *
             */
            "title": string;
            set(property:"title", value: string): void;
            get(property:"title"): string;
            watch(property:"title", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * When this widget's title attribute is used to for a tab label, accordion pane title, etc.,
             * this specifies the tooltip to appear when the mouse is hovered over that text.
             *
             */
            "tooltip": string;
            set(property:"tooltip", value: string): void;
            get(property:"tooltip"): string;
            watch(property:"tooltip", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "value": string;
            set(property:"value", value: string): void;
            get(property:"value"): string;
            watch(property:"value", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: String, value: Object): any;
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: Object, value: Object): any;
            /**
             * Construct the UI for this widget, setting this.domNode.
             * Most widgets will mixin dijit._TemplatedMixin, which implements this method.
             *
             */
            buildRendering(): void;
            /**
             * Emulate a click on the check box, but will not trigger the
             * onClick method.
             *
             */
            click(): void;
            /**
             * Compare 2 values (as returned by get('value') for this widget).
             *
             * @param val1
             * @param val2
             */
            compare(val1: any, val2: any): number;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: Function): any;
            /**
             * Wrapper to setTimeout to avoid deferred functions executing
             * after the originating widget has been destroyed.
             * Returns an object handle with a remove method (that returns null) (replaces clearTimeout).
             *
             * @param fcn Function reference.
             * @param delay               OptionalDelay, defaults to 0.
             */
            defer(fcn: Function, delay: number): Object;
            /**
             * Destroy this widget, but not its descendants.  Descendants means widgets inside of
             * this.containerNode.   Will also destroy any resources (including widgets) registered via this.own().
             *
             * This method will also destroy internal widgets such as those created from a template,
             * assuming those widgets exist inside of this.domNode but outside of this.containerNode.
             *
             * For 2.0 it's planned that this method will also destroy descendant widgets, so apps should not
             * depend on the current ability to destroy a widget without destroying its descendants.   Generally
             * they should use destroyRecursive() for widgets with children.
             *
             * @param preserveDom If true, this method will leave the original DOM structure alone.Note: This will not yet work with _TemplatedMixin widgets
             */
            destroy(preserveDom?: boolean): void;
            /**
             * Recursively destroy the children of this widget and their
             * descendants.
             *
             * @param preserveDom               OptionalIf true, the preserveDom attribute is passed to all descendantwidget's .destroy() method. Not for use with _Templatedwidgets.
             */
            destroyDescendants(preserveDom: boolean): void;
            /**
             * Destroy this widget and its descendants
             * This is the generic "destructor" function that all widget users
             * should call to cleanly discard with a widget. Once a widget is
             * destroyed, it is removed from the manager object.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structurealone of descendant Widgets. Note: This will NOT work withdijit._TemplatedMixin widgets.
             */
            destroyRecursive(preserveDom: boolean): void;
            /**
             * Destroys the DOM nodes associated with this widget.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structure aloneduring tear-down. Note: this will not work with _Templatedwidgets yet.
             */
            destroyRendering(preserveDom?: boolean): void;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Disconnects handle created by connect.
             *
             * @param handle
             */
            disconnect(handle: any): void;
            /**
             * Used by widgets to signal that a synthetic event occurred, ex:
             *
             * myWidget.emit("attrmodified-selectedChildWidget", {}).
             * Emits an event on this.domNode named type.toLowerCase(), based on eventObj.
             * Also calls onType() method, if present, and returns value from that method.
             * By default passes eventObj to callback, but will pass callbackArgs instead, if specified.
             * Modifies eventObj by adding missing parameters (bubbles, cancelable, widget).
             *
             * @param type
             * @param eventObj               Optional
             * @param callbackArgs               Optional
             */
            emit(type: String, eventObj: Object, callbackArgs: any[]): any;
            /**
             * Fix _currentState property if it's out of bound.
             *
             */
            fixState(): void;
            /**
             * Put focus on this widget
             *
             */
            focus(): void;
            /**
             * Get a property from a widget.
             * Get a named property from a widget. The property may
             * potentially be retrieved via a getter method. If no getter is defined, this
             * just retrieves the object's property.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _getFooAttr(), calling:
             * myWidget.get("foo") would be equivalent to calling
             * widget._getFooAttr() and myWidget.get("bar")
             * would be equivalent to the expression
             * widget.bar2
             *
             * @param name The property to get.
             */
            get(name: any): any;
            /**
             * Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent
             * is this widget.   Note that it does not return all descendants, but rather just direct children.
             * Analogous to Node.childNodes,
             * except containing widgets rather than DOMNodes.
             *
             * The result intentionally excludes internally created widgets (a.k.a. supporting widgets)
             * outside of this.containerNode.
             *
             * Note that the array returned is a simple array.  Application code should not assume
             * existence of methods like forEach().
             *
             */
            getChildren(): any[];
            /**
             * Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
             * This method should generally be avoided as it returns widgets declared in templates, which are
             * supposed to be internal/hidden, but it's left here for back-compat reasons.
             *
             */
            getDescendants(): any[];
            /**
             * Returns the parent widget of this widget.
             *
             */
            getParent(): any;
            /**
             * Deprecated.  Use get('value') instead.
             *
             */
            getValue(): any;
            /**
             * Return true if this widget can currently be focused
             * and false if not
             *
             */
            isFocusable(): any;
            /**
             * Return this widget's explicit or implicit orientation (true for LTR, false for RTL)
             *
             */
            isLeftToRight(): any;
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: String, func: Function): any;
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: Function, func: Function): any;
            /**
             * Track specified handles and remove/destroy them when this instance is destroyed, unless they were
             * already removed/destroyed manually.
             *
             */
            own(): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: number): any;
            /**
             *
             */
            postCreate(): void;
            /**
             *
             */
            postMixInProperties(): void;
            /**
             *
             */
            reset(): void;
            /**
             * Set a property on a widget
             * Sets named properties on a widget which may potentially be handled by a
             * setter in the widget.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _setFooAttr(), calling
             * myWidget.set("foo", "Howdy!") would be equivalent to calling
             * widget._setFooAttr("Howdy!") and myWidget.set("bar", 3)
             * would be equivalent to the statement widget.bar = 3;
             *
             * set() may also be called with a hash of name/value pairs, ex:
             *
             * myWidget.set({
             *     foo: "Howdy",
             *     bar: 3
             * });
             * This is equivalent to calling set(foo, "Howdy") and set(bar, 3)
             *
             * @param name The property to set.
             * @param value The value to set in the property.
             */
            set(name: any, value: any): any;
            /**
             * Deprecated.  Use set() instead.
             *
             * @param attr
             * @param value
             */
            setAttribute(attr: String, value: any): void;
            /**
             * Deprecated.  Use set('checked', true/false) instead.
             *
             * @param checked
             */
            setChecked(checked: String): void;
            /**
             * Deprecated.  Use set('checked', true/false) instead.
             *
             * @param checked
             */
            setChecked(checked: boolean): void;
            /**
             * Deprecated.  Use set('disabled', ...) instead.
             *
             * @param disabled
             */
            setDisabled(disabled: boolean): void;
            /**
             * Deprecated.  Use set('label', ...) instead.
             *
             * @param content
             */
            setLabel(content: String): void;
            /**
             * Deprecated.  Use set('value', ...) instead.
             *
             * @param value
             */
            setValue(value: String): void;
            /**
             *
             */
            startup(): void;
            /**
             * Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.
             *
             * Subscribes to the specified topic and calls the specified method
             * of this object and registers for unsubscribe() on widget destroy.
             *
             * Provide widget-specific analog to dojo.subscribe, except with the
             * implicit use of this widget as the target object.
             *
             * @param t The topic
             * @param method The callback
             */
            subscribe(t: String, method: Function): any;
            /**
             * Returns a string that represents the widget.
             * When a widget is cast to a string, this method will be used to generate the
             * output. Currently, it does not implement any sort of reversible
             * serialization.
             *
             */
            toString(): string;
            /**
             * Deprecated. Override destroy() instead to implement custom widget tear-down
             * behavior.
             *
             */
            uninitialize(): boolean;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Unsubscribes handle created by this.subscribe.
             * Also removes handle from this widget's list of subscriptions
             *
             * @param handle
             */
            unsubscribe(handle: Object): void;
            /**
             * Watches a property for changes
             *
             * @param name               OptionalIndicates the property to watch. This is optional (the callback may be theonly parameter), and if omitted, all the properties will be watched
             * @param callback The function to execute when the property changes. This will be called afterthe property has been changed. The callback will be called with the |this|set to the instance, the first argument as the name of the property, thesecond argument as the old value and the third argument as the new value.
             */
            watch(property: string, callback:{(property?:string, oldValue?:any, newValue?: any):void}) :{unwatch():void};
            /**
             * Static method to get a template based on the templatePath or
             * templateString key
             */
            getCachedTemplate(): any;
            /**
             * Called when the widget stops being "active" because
             * focus moved to something outside of it, or the user
             * clicked somewhere outside of it, or the widget was
             * hidden.
             *
             */
            onBlur(): void;
            /**
             * Callback when this widget's value is changed.
             *
             * @param newValue
             */
            onChange(newValue: any): void;
            /**
             * Connect to this function to receive notifications of mouse click events.
             *
             * @param event mouse Event
             */
            onClick(event: Event): boolean;
            /**
             * Called when this widget is being displayed as a popup (ex: a Calendar popped
             * up from a DateTextBox), and it is hidden.
             * This is called from the dijit.popup code, and should not be called directly.
             *
             * Also used as a parameter for children of dijit/layout/StackContainer or subclasses.
             * Callback if a user tries to close the child.   Child will be closed if this function returns true.
             *
             */
            onClose(): boolean;
            /**
             * Connect to this function to receive notifications of mouse double click events.
             *
             * @param event mouse Event
             */
            onDblClick(event: any): void;
            /**
             * Called when the widget becomes "active" because
             * it or a widget inside of it either has focus, or has recently
             * been clicked.
             *
             */
            onFocus(): void;
            /**
             * Called when another widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate hide of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onHide(): void;
            /**
             * Connect to this function to receive notifications of keys being pressed down.
             *
             * @param event key Event
             */
            onKeyDown(event: any): void;
            /**
             * Connect to this function to receive notifications of printable keys being typed.
             *
             * @param event key Event
             */
            onKeyPress(event: any): void;
            /**
             * Connect to this function to receive notifications of keys being released.
             *
             * @param event key Event
             */
            onKeyUp(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is pressed down.
             *
             * @param event mouse Event
             */
            onMouseDown(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto this widget.
             *
             * @param event mouse Event
             */
            onMouseEnter(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of this widget.
             *
             * @param event mouse Event
             */
            onMouseLeave(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseMove(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOut(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOver(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is released.
             *
             * @param event mouse Event
             */
            onMouseUp(event: any): void;
            /**
             * Called when this widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate display of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onShow(): void;
        }
        /**
         * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/MonthTextBox.html
         *
         * A validating, serializable, range-bound date text box with a popup calendar that contains only months
         *
         * @param params Hash of initialization parameters for widget, including scalar values (like title, duration etc.)and functions, typically callbacks like onClick.The hash can contain any of the widget's properties, excluding read-only properties.
         * @param srcNodeRef       OptionalIf a srcNodeRef (DOM node) is specified, replace srcNodeRef with my generated DOM tree
         */
        class MonthTextBox extends dojox.form.DateTextBox {
            constructor(params?: Object, srcNodeRef?: HTMLElement);
            /**
             * True if mouse was pressed while over this widget, and hasn't been released yet
             *
             */
            "active": boolean;
            set(property:"active", value: boolean): void;
            get(property:"active"): boolean;
            watch(property:"active", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "alt": string;
            set(property:"alt", value: string): void;
            get(property:"alt"): string;
            watch(property:"alt", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "aria-label": string;
            set(property:"aria-label", value: string): void;
            get(property:"aria-label"): string;
            watch(property:"aria-label", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Object to which attach points and events will be scoped.  Defaults
             * to 'this'.
             *
             */
            "attachScope": Object;
            set(property:"attachScope", value: Object): void;
            get(property:"attachScope"): Object;
            watch(property:"attachScope", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute
             * for each XXX attribute to be mapped to the DOM.
             *
             * attributeMap sets up a "binding" between attributes (aka properties)
             * of the widget and the widget's DOM.
             * Changes to widget attributes listed in attributeMap will be
             * reflected into the DOM.
             *
             * For example, calling set('title', 'hello')
             * on a TitlePane will automatically cause the TitlePane's DOM to update
             * with the new title.
             *
             * attributeMap is a hash where the key is an attribute of the widget,
             * and the value reflects a binding to a:
             *
             * DOM node attribute
             *   focus: {node: "focusNode", type: "attribute"}
             * Maps this.focus to this.focusNode.focus
             *
             * DOM node innerHTML
             *   title: { node: "titleNode", type: "innerHTML" }
             * Maps this.title to this.titleNode.innerHTML
             *
             * DOM node innerText
             *   title: { node: "titleNode", type: "innerText" }
             * Maps this.title to this.titleNode.innerText
             *
             * DOM node CSS class
             *   myClass: { node: "domNode", type: "class" }
             * Maps this.myClass to this.domNode.className
             *
             * If the value is an array, then each element in the array matches one of the
             * formats of the above list.
             *
             * There are also some shorthands for backwards compatibility:
             *
             * string --> { node: string, type: "attribute" }, for example:
             * "focusNode" ---> { node: "focusNode", type: "attribute" }
             * "" --> { node: "domNode", type: "attribute" }
             *
             */
            "attributeMap": Object;
            set(property:"attributeMap", value: Object): void;
            get(property:"attributeMap"): Object;
            watch(property:"attributeMap", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             *
             */
            "autoWidth": boolean;
            set(property:"autoWidth", value: boolean): void;
            get(property:"autoWidth"): boolean;
            watch(property:"autoWidth", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             *
             */
            "baseClass": string;
            set(property:"baseClass", value: string): void;
            get(property:"baseClass"): string;
            watch(property:"baseClass", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "class": string;
            set(property:"class", value: string): void;
            get(property:"class"): string;
            watch(property:"class", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Despite the name, this parameter specifies both constraints on the input
             * (including starting/ending dates/times allowed) as well as
             * formatting options like whether the date is displayed in long (ex: December 25, 2005)
             * or short (ex: 12/25/2005) format.  See dijit/form/_DateTimeTextBox.__Constraints for details.
             *
             */
            "constraints": Object;
            set(property:"constraints", value: Object): void;
            get(property:"constraints"): Object;
            watch(property:"constraints", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Designates where children of the source DOM node will be placed.
             * "Children" in this case refers to both DOM nodes and widgets.
             * For example, for myWidget:
             *
             * <div data-dojo-type=myWidget>
             *     <b> here's a plain DOM node
             *     <span data-dojo-type=subWidget>and a widget</span>
             *     <i> and another plain DOM node </i>
             * </div>
             * containerNode would point to:
             *
             * <b> here's a plain DOM node
             * <span data-dojo-type=subWidget>and a widget</span>
             * <i> and another plain DOM node </i>
             * In templated widgets, "containerNode" is set via a
             * data-dojo-attach-point assignment.
             *
             * containerNode must be defined for any widget that accepts innerHTML
             * (like ContentPane or BorderContainer or even Button), and conversely
             * is null for widgets that don't, like TextBox.
             *
             */
            "containerNode": HTMLElement;
            set(property:"containerNode", value: HTMLElement): void;
            get(property:"containerNode"): HTMLElement;
            watch(property:"containerNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             *
             */
            "cssStateNodes": Object;
            set(property:"cssStateNodes", value: Object): void;
            get(property:"cssStateNodes"): Object;
            watch(property:"cssStateNodes", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * JavaScript namespace to find calendar routines.  If unspecified, uses Gregorian calendar routines
             * at dojo/date and dojo/date/locale.
             *
             */
            "datePackage": string;
            set(property:"datePackage", value: string): void;
            get(property:"datePackage"): string;
            watch(property:"datePackage", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Bi-directional support, as defined by the HTML DIR
             * attribute. Either left-to-right "ltr" or right-to-left "rtl".  If undefined, widgets renders in page's
             * default direction.
             *
             */
            "dir": string;
            set(property:"dir", value: string): void;
            get(property:"dir"): string;
            watch(property:"dir", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Should this widget respond to user input?
             * In markup, this is specified as "disabled='disabled'", or just "disabled".
             *
             */
            "disabled": boolean;
            set(property:"disabled", value: boolean): void;
            get(property:"disabled"): boolean;
            watch(property:"disabled", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * For subclasses like ComboBox where the displayed value
             * (ex: Kentucky) and the serialized value (ex: KY) are different,
             * this represents the displayed value.
             *
             * Setting 'displayedValue' through set('displayedValue', ...)
             * updates 'value', and vice-versa.  Otherwise 'value' is updated
             * from 'displayedValue' periodically, like onBlur etc.
             *
             * TODO: move declaration to MappedTextBox?
             * Problem is that ComboBox references displayedValue,
             * for benefit of FilteringSelect.
             *
             */
            "displayedValue": string;
            set(property:"displayedValue", value: string): void;
            get(property:"displayedValue"): string;
            watch(property:"displayedValue", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * This is our visible representation of the widget! Other DOM
             * Nodes may by assigned to other properties, usually through the
             * template system's data-dojo-attach-point syntax, but the domNode
             * property is the canonical "top level" node in widget UI.
             *
             */
            "domNode": HTMLElement;
            set(property:"domNode", value: HTMLElement): void;
            get(property:"domNode"): HTMLElement;
            watch(property:"domNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * The widget to display as a popup.  This widget must be
             * defined before the startup function is called.
             *
             */
            "dropDown": Object;
            set(property:"dropDown", value: Object): void;
            get(property:"dropDown"): Object;
            watch(property:"dropDown", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * The default value to focus in the popupClass widget when the textbox value is empty.
             *
             */
            "dropDownDefaultValue": Date;
            set(property:"dropDownDefaultValue", value: Date): void;
            get(property:"dropDownDefaultValue"): Date;
            watch(property:"dropDownDefaultValue", callback:{(property?:string, oldValue?:Date, newValue?: Date):void}) :{unwatch():void}
            /**
             * This variable controls the position of the drop down.
             * It's an array of strings with the following values:
             *
             * before: places drop down to the left of the target node/widget, or to the right in
             * the case of RTL scripts like Hebrew and Arabic
             * after: places drop down to the right of the target node/widget, or to the left in
             * the case of RTL scripts like Hebrew and Arabic
             * above: drop down goes above target node
             * below: drop down goes below target node
             * The list is positions is tried, in order, until a position is found where the drop down fits
             * within the viewport.
             *
             */
            "dropDownPosition": Object;
            set(property:"dropDownPosition", value: Object): void;
            get(property:"dropDownPosition"): Object;
            watch(property:"dropDownPosition", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * This widget or a widget it contains has focus, or is "active" because
             * it was recently clicked.
             *
             */
            "focused": boolean;
            set(property:"focused", value: boolean): void;
            get(property:"focused"): boolean;
            watch(property:"focused", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Set to true to make the drop down exactly as wide as this
             * widget.  Overrides autoWidth.
             *
             */
            "forceWidth": boolean;
            set(property:"forceWidth", value: boolean): void;
            get(property:"forceWidth"): boolean;
            watch(property:"forceWidth", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Set this textbox to display a down arrow button, to open the drop down list.
             *
             */
            "hasDownArrow": boolean;
            set(property:"hasDownArrow", value: boolean): void;
            get(property:"hasDownArrow"): boolean;
            watch(property:"hasDownArrow", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * True if cursor is over this widget
             *
             */
            "hovering": boolean;
            set(property:"hovering", value: boolean): void;
            get(property:"hovering"): boolean;
            watch(property:"hovering", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * A unique, opaque ID string that can be assigned by users or by the
             * system. If the developer passes an ID which is known not to be
             * unique, the specified ID is ignored and the system-generated ID is
             * used instead.
             *
             */
            "id": string;
            set(property:"id", value: string): void;
            get(property:"id"): string;
            watch(property:"id", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Fires onChange for each value change or only on demand
             *
             */
            "intermediateChanges": boolean;
            set(property:"intermediateChanges", value: boolean): void;
            get(property:"intermediateChanges"): boolean;
            watch(property:"intermediateChanges", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * The message to display if value is invalid.
             * The translated string value is read from the message file by default.
             * Set to "" to use the promptMessage instead.
             *
             */
            "invalidMessage": string;
            set(property:"invalidMessage", value: string): void;
            get(property:"invalidMessage"): string;
            watch(property:"invalidMessage", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Rarely used.  Overrides the default Dojo locale used to render this widget,
             * as defined by the HTML LANG attribute.
             * Value must be among the list of locales specified during by the Dojo bootstrap,
             * formatted according to RFC 3066 (like en-us).
             *
             */
            "lang": string;
            set(property:"lang", value: string): void;
            get(property:"lang"): string;
            watch(property:"lang", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Converts all characters to lowercase if true.  Default is false.
             *
             */
            "lowercase": boolean;
            set(property:"lowercase", value: boolean): void;
            get(property:"lowercase"): boolean;
            watch(property:"lowercase", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * The max height for our dropdown.
             * Any dropdown taller than this will have scrollbars.
             * Set to 0 for no max height, or -1 to limit height to available space in viewport
             *
             */
            "maxHeight": number;
            set(property:"maxHeight", value: number): void;
            get(property:"maxHeight"): number;
            watch(property:"maxHeight", callback:{(property?:string, oldValue?:number, newValue?: number):void}) :{unwatch():void}
            /**
             * HTML INPUT tag maxLength declaration.
             *
             */
            "maxLength": string;
            set(property:"maxLength", value: string): void;
            get(property:"maxLength"): string;
            watch(property:"maxLength", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Currently error/prompt message.
             * When using the default tooltip implementation, this will only be
             * displayed when the field is focused.
             *
             */
            "message": string;
            set(property:"message", value: string): void;
            get(property:"message"): string;
            watch(property:"message", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * The message to display if value is empty and the field is required.
             * The translated string value is read from the message file by default.
             * Set to "" to use the invalidMessage instead.
             *
             */
            "missingMessage": string;
            set(property:"missingMessage", value: string): void;
            get(property:"missingMessage"): string;
            watch(property:"missingMessage", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Name used when submitting form; same as "name" attribute or plain HTML elements
             *
             */
            "name": string;
            set(property:"name", value: string): void;
            get(property:"name"): string;
            watch(property:"name", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * The document this widget belongs to.  If not specified to constructor, will default to
             * srcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global
             *
             */
            "ownerDocument": Object;
            set(property:"ownerDocument", value: Object): void;
            get(property:"ownerDocument"): Object;
            watch(property:"ownerDocument", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Defines a hint to help users fill out the input field (as defined in HTML 5).
             * This should only contain plain text (no html markup).
             *
             */
            "placeHolder": string;
            set(property:"placeHolder", value: string): void;
            get(property:"placeHolder"): string;
            watch(property:"placeHolder", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * If defined, display this hint string immediately on focus to the textbox, if empty.
             * Also displays if the textbox value is Incomplete (not yet valid but will be with additional input).
             * Think of this like a tooltip that tells the user what to do, not an error message
             * that tells the user what they've done wrong.
             *
             * Message disappears when user starts typing.
             *
             */
            "promptMessage": string;
            set(property:"promptMessage", value: string): void;
            get(property:"promptMessage"): string;
            watch(property:"promptMessage", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Converts the first character of each word to uppercase if true.
             *
             */
            "propercase": boolean;
            set(property:"propercase", value: boolean): void;
            get(property:"propercase"): boolean;
            watch(property:"propercase", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * The message to display if value is out-of-range
             *
             */
            "rangeMessage": string;
            set(property:"rangeMessage", value: string): void;
            get(property:"rangeMessage"): string;
            watch(property:"rangeMessage", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Should this widget respond to user input?
             * In markup, this is specified as "readOnly".
             * Similar to disabled except readOnly form values are submitted.
             *
             */
            "readOnly": boolean;
            set(property:"readOnly", value: boolean): void;
            get(property:"readOnly"): boolean;
            watch(property:"readOnly", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             *
             */
            "regExp": string;
            set(property:"regExp", value: string): void;
            get(property:"regExp"): string;
            watch(property:"regExp", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * User is required to enter data into this field.
             *
             */
            "required": boolean;
            set(property:"required", value: boolean): void;
            get(property:"required"): boolean;
            watch(property:"required", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * On focus, should this widget scroll into view?
             *
             */
            "scrollOnFocus": boolean;
            set(property:"scrollOnFocus", value: boolean): void;
            get(property:"scrollOnFocus"): boolean;
            watch(property:"scrollOnFocus", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             *
             */
            "searchContainerNode": boolean;
            set(property:"searchContainerNode", value: boolean): void;
            get(property:"searchContainerNode"): boolean;
            watch(property:"searchContainerNode", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * If true, all text will be selected when focused with mouse
             *
             */
            "selectOnClick": boolean;
            set(property:"selectOnClick", value: boolean): void;
            get(property:"selectOnClick"): boolean;
            watch(property:"selectOnClick", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             *
             */
            "selector": string;
            set(property:"selector", value: string): void;
            get(property:"selector"): string;
            watch(property:"selector", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * pointer to original DOM node
             *
             */
            "srcNodeRef": HTMLElement;
            set(property:"srcNodeRef", value: HTMLElement): void;
            get(property:"srcNodeRef"): HTMLElement;
            watch(property:"srcNodeRef", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * Shows current state (ie, validation result) of input (""=Normal, Incomplete, or Error)
             *
             */
            "state": string;
            set(property:"state", value: string): void;
            get(property:"state"): string;
            watch(property:"state", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * HTML style attributes as cssText string or name/value hash
             *
             */
            "style": string;
            set(property:"style", value: string): void;
            get(property:"style"): string;
            watch(property:"style", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Order fields are traversed when user hits the tab key
             *
             */
            "tabIndex": string;
            set(property:"tabIndex", value: string): void;
            get(property:"tabIndex"): string;
            watch(property:"tabIndex", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Path to template (HTML file) for this widget relative to dojo.baseUrl.
             * Deprecated: use templateString with require([... "dojo/text!..."], ...) instead
             *
             */
            "templatePath": string;
            set(property:"templatePath", value: string): void;
            get(property:"templatePath"): string;
            watch(property:"templatePath", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "templateString": string;
            set(property:"templateString", value: string): void;
            get(property:"templateString"): string;
            watch(property:"templateString", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * HTML title attribute.
             *
             * For form widgets this specifies a tooltip to display when hovering over
             * the widget (just like the native HTML title attribute).
             *
             * For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,
             * etc., it's used to specify the tab label, accordion pane title, etc.  In this case it's
             * interpreted as HTML.
             *
             */
            "title": string;
            set(property:"title", value: string): void;
            get(property:"title"): string;
            watch(property:"title", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * When this widget's title attribute is used to for a tab label, accordion pane title, etc.,
             * this specifies the tooltip to appear when the mouse is hovered over that text.
             *
             */
            "tooltip": string;
            set(property:"tooltip", value: string): void;
            get(property:"tooltip"): string;
            watch(property:"tooltip", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * See description of dijit/Tooltip.defaultPosition for details on this parameter.
             *
             */
            "tooltipPosition": Object;
            set(property:"tooltipPosition", value: Object): void;
            get(property:"tooltipPosition"): Object;
            watch(property:"tooltipPosition", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Removes leading and trailing whitespace if true.  Default is false.
             *
             */
            "trim": boolean;
            set(property:"trim", value: boolean): void;
            get(property:"trim"): boolean;
            watch(property:"trim", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "type": string;
            set(property:"type", value: string): void;
            get(property:"type"): string;
            watch(property:"type", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Converts all characters to uppercase if true.  Default is false.
             *
             */
            "uppercase": boolean;
            set(property:"uppercase", value: boolean): void;
            get(property:"uppercase"): boolean;
            watch(property:"uppercase", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * The value of this widget as a JavaScript Date object.  Use get("value") / set("value", val) to manipulate.
             * When passed to the parser in markup, must be specified according to dojo/date/stamp.fromISOString()
             *
             */
            "value": Date;
            set(property:"value", value: Date): void;
            get(property:"value"): Date;
            watch(property:"value", callback:{(property?:string, oldValue?:Date, newValue?: Date):void}) :{unwatch():void}
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: String, value: Object): any;
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: Object, value: Object): any;
            /**
             *
             */
            buildRendering(): void;
            /**
             * Closes the drop down on this widget
             *
             * @param focus If true, refocuses the button widget
             */
            closeDropDown(focus: boolean): void;
            /**
             *
             * @param val1
             * @param val2
             */
            compare(val1: Date, val2: Date): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: Function): any;
            /**
             * Wrapper to setTimeout to avoid deferred functions executing
             * after the originating widget has been destroyed.
             * Returns an object handle with a remove method (that returns null) (replaces clearTimeout).
             *
             * @param fcn Function reference.
             * @param delay               OptionalDelay, defaults to 0.
             */
            defer(fcn: Function, delay: number): Object;
            /**
             * Destroy this widget, but not its descendants.  Descendants means widgets inside of
             * this.containerNode.   Will also destroy any resources (including widgets) registered via this.own().
             *
             * This method will also destroy internal widgets such as those created from a template,
             * assuming those widgets exist inside of this.domNode but outside of this.containerNode.
             *
             * For 2.0 it's planned that this method will also destroy descendant widgets, so apps should not
             * depend on the current ability to destroy a widget without destroying its descendants.   Generally
             * they should use destroyRecursive() for widgets with children.
             *
             * @param preserveDom If true, this method will leave the original DOM structure alone.Note: This will not yet work with _TemplatedMixin widgets
             */
            destroy(preserveDom?: boolean): void;
            /**
             * Recursively destroy the children of this widget and their
             * descendants.
             *
             * @param preserveDom               OptionalIf true, the preserveDom attribute is passed to all descendantwidget's .destroy() method. Not for use with _Templatedwidgets.
             */
            destroyDescendants(preserveDom: boolean): void;
            /**
             * Destroy this widget and its descendants
             * This is the generic "destructor" function that all widget users
             * should call to cleanly discard with a widget. Once a widget is
             * destroyed, it is removed from the manager object.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structurealone of descendant Widgets. Note: This will NOT work withdijit._TemplatedMixin widgets.
             */
            destroyRecursive(preserveDom: boolean): void;
            /**
             * Destroys the DOM nodes associated with this widget.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structure aloneduring tear-down. Note: this will not work with _Templatedwidgets yet.
             */
            destroyRendering(preserveDom?: boolean): void;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Disconnects handle created by connect.
             *
             * @param handle
             */
            disconnect(handle: any): void;
            /**
             * Overridable method to display validation errors/hints.
             * By default uses a tooltip.
             *
             * @param message
             */
            displayMessage(message: String): void;
            /**
             * Used by widgets to signal that a synthetic event occurred, ex:
             *
             * myWidget.emit("attrmodified-selectedChildWidget", {}).
             * Emits an event on this.domNode named type.toLowerCase(), based on eventObj.
             * Also calls onType() method, if present, and returns value from that method.
             * By default passes eventObj to callback, but will pass callbackArgs instead, if specified.
             * Modifies eventObj by adding missing parameters (bubbles, cancelable, widget).
             *
             * @param type
             * @param eventObj               Optional
             * @param callbackArgs               Optional
             */
            emit(type: String, eventObj: Object, callbackArgs: any[]): any;
            /**
             * Auto-corrections (such as trimming) that are applied to textbox
             * value on blur or form submit.
             * For MappedTextBox subclasses, this is called twice
             *
             * once with the display value
             * once the value as set/returned by set('value', ...)
             * and get('value'), ex: a Number for NumberTextBox.
             *
             * In the latter case it does corrections like converting null to NaN.  In
             * the former case the NumberTextBox.filter() method calls this.inherited()
             * to execute standard trimming code in TextBox.filter().
             *
             * TODO: break this into two methods in 2.0
             *
             * @param val
             */
            filter(val: any): any;
            /**
             * Put focus on this widget
             *
             */
            focus(): void;
            /**
             *
             * @param value
             */
            format(value: any): number;
            /**
             * Get a property from a widget.
             * Get a named property from a widget. The property may
             * potentially be retrieved via a getter method. If no getter is defined, this
             * just retrieves the object's property.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _getFooAttr(), calling:
             * myWidget.get("foo") would be equivalent to calling
             * widget._getFooAttr() and myWidget.get("bar")
             * would be equivalent to the expression
             * widget.bar2
             *
             * @param name The property to get.
             */
            get(name: any): any;
            /**
             * Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent
             * is this widget.   Note that it does not return all descendants, but rather just direct children.
             * Analogous to Node.childNodes,
             * except containing widgets rather than DOMNodes.
             *
             * The result intentionally excludes internally created widgets (a.k.a. supporting widgets)
             * outside of this.containerNode.
             *
             * Note that the array returned is a simple array.  Application code should not assume
             * existence of methods like forEach().
             *
             */
            getChildren(): any[];
            /**
             * Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
             * This method should generally be avoided as it returns widgets declared in templates, which are
             * supposed to be internal/hidden, but it's left here for back-compat reasons.
             *
             */
            getDescendants(): any[];
            /**
             * Deprecated.  Use get('displayedValue') instead.
             *
             */
            getDisplayedValue(): any;
            /**
             *
             * @param isFocused
             */
            getErrorMessage(isFocused: boolean): any;
            /**
             * Returns the parent widget of this widget.
             *
             */
            getParent(): any;
            /**
             * Return a hint message to show when widget is first focused
             *
             * @param isFocused
             */
            getPromptMessage(isFocused: boolean): any;
            /**
             * Deprecated.  Use get('value') instead.
             *
             */
            getValue(): any;
            /**
             * Return true if this widget can currently be focused
             * and false if not
             *
             */
            isFocusable(): any;
            /**
             * Tests if the value is in the min/max range specified in constraints
             *
             * @param isFocused
             */
            isInRange(isFocused: boolean): any;
            /**
             * Return this widget's explicit or implicit orientation (true for LTR, false for RTL)
             *
             */
            isLeftToRight(): any;
            /**
             * Returns true if the dropdown exists and it's data is loaded.  This can
             * be overridden in order to force a call to loadDropDown().
             *
             */
            isLoaded(): boolean;
            /**
             *
             * @param isFocused
             */
            isValid: {(isFocused: boolean): any};
            /**
             * Creates the drop down if it doesn't exist, loads the data
             * if there's an href and it hasn't been loaded yet, and
             * then opens the drop down.  This is basically a callback when the
             * user presses the down arrow button to open the drop down.
             *
             */
            loadAndOpenDropDown(): any;
            /**
             * Creates the drop down if it doesn't exist, loads the data
             * if there's an href and it hasn't been loaded yet, and then calls
             * the given callback.
             *
             * @param loadCallback
             */
            loadDropDown(loadCallback: Function): void;
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: String, func: Function): any;
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: Function, func: Function): any;
            /**
             *
             */
            openDropDown(): void;
            /**
             * Track specified handles and remove/destroy them when this instance is destroyed, unless they were
             * already removed/destroyed manually.
             *
             */
            own(): any;
            /**
             *
             * @param value
             * @param constraints
             */
            parse(value: any, constraints: any): number;
            /**
             * Builds the regular needed to parse a localized date
             *
             * @param options               OptionalAn object with the following properties:selector (String): choice of 'time','date' (default: date and time)formatLength (String): choice of long, short, medium or full (plus any custom additions).  Defaults to 'short'datePattern (String): override pattern with this stringtimePattern (String): override pattern with this stringam (String): override strings for am in timespm (String): override strings for pm in timeslocale (String): override the locale used to determine formatting rulesfullYear (Boolean): (format only) use 4 digit years whenever 2 digit years are called forstrict (Boolean): (parse only) strict parsing, off by default
             */
            pattern: { (options: Object): any };
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: number): any;
            /**
             * The popup widget to use. In this case, a calendar with just a Month view.
             *
             */
            popupClass: {(): void};
            /**
             *
             */
            postCreate(): void;
            /**
             *
             */
            postMixInProperties(): void;
            /**
             * Overridable function used to validate the range of the numeric input value.
             *
             * @param primitive
             * @param constraints
             */
            rangeCheck(primitive: number, constraints: dijit.form.RangeBoundTextBox.__Constraints): boolean;
            /**
             * Deprecated.  Use set('pattern', Function) instead.
             *
             * @param constraints An object with the following properties:locale (String): locale used for validation, picks up value from this widget's lang attribute_flags_ (anything): various flags passed to pattern function
             */
            regExpGen(constraints: Object): void;
            /**
             *
             */
            reset(): void;
            /**
             *
             * @param value
             * @param constraints
             */
            serialize(value: any, constraints: any): any;
            /**
             * Set a property on a widget
             * Sets named properties on a widget which may potentially be handled by a
             * setter in the widget.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _setFooAttr(), calling
             * myWidget.set("foo", "Howdy!") would be equivalent to calling
             * widget._setFooAttr("Howdy!") and myWidget.set("bar", 3)
             * would be equivalent to the statement widget.bar = 3;
             *
             * set() may also be called with a hash of name/value pairs, ex:
             *
             * myWidget.set({
             *     foo: "Howdy",
             *     bar: 3
             * });
             * This is equivalent to calling set(foo, "Howdy") and set(bar, 3)
             *
             * @param name The property to set.
             * @param value The value to set in the property.
             */
            set(name: any, value: any): any;
            /**
             * Deprecated.  Use set() instead.
             *
             * @param attr
             * @param value
             */
            setAttribute(attr: String, value: any): void;
            /**
             * Deprecated.  Use set('disabled', ...) instead.
             *
             * @param disabled
             */
            setDisabled(disabled: boolean): void;
            /**
             * Deprecated.  Use set('displayedValue', ...) instead.
             *
             * @param value
             */
            setDisplayedValue(value: String): void;
            /**
             * Deprecated.  Use set('value', ...) instead.
             *
             * @param value
             */
            setValue(value: String): void;
            /**
             *
             */
            startup(): void;
            /**
             * Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.
             *
             * Subscribes to the specified topic and calls the specified method
             * of this object and registers for unsubscribe() on widget destroy.
             *
             * Provide widget-specific analog to dojo.subscribe, except with the
             * implicit use of this widget as the target object.
             *
             * @param t The topic
             * @param method The callback
             */
            subscribe(t: String, method: Function): any;
            /**
             * Callback when the user presses the down arrow button or presses
             * the down arrow key to open/close the drop down.
             * Toggle the drop-down widget; if it is up, close it, if not, open it
             *
             */
            toggleDropDown(): void;
            /**
             * Returns widget as a printable string using the widget's value
             *
             */
            toString(): string;
            /**
             * Restore the value to the last value passed to onChange
             *
             */
            undo(): void;
            /**
             * Deprecated. Override destroy() instead to implement custom widget tear-down
             * behavior.
             *
             */
            uninitialize(): boolean;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Unsubscribes handle created by this.subscribe.
             * Also removes handle from this widget's list of subscriptions
             *
             * @param handle
             */
            unsubscribe(handle: Object): void;
            /**
             *
             */
            validate(): any;
            /**
             *
             * @param value
             */
            validator(value: any): boolean;
            /**
             * Watches a property for changes
             *
             * @param name               OptionalIndicates the property to watch. This is optional (the callback may be theonly parameter), and if omitted, all the properties will be watched
             * @param callback The function to execute when the property changes. This will be called afterthe property has been changed. The callback will be called with the |this|set to the instance, the first argument as the name of the property, thesecond argument as the old value and the third argument as the new value.
             */
            watch(property: string, callback:{(property?:string, oldValue?:any, newValue?: any):void}) :{unwatch():void};
            /**
             * Static method to get a template based on the templatePath or
             * templateString key
             */
            getCachedTemplate(): any;
            /**
             * Called when the widget stops being "active" because
             * focus moved to something outside of it, or the user
             * clicked somewhere outside of it, or the widget was
             * hidden.
             *
             */
            onBlur(): void;
            /**
             * Callback when this widget's value is changed.
             *
             * @param newValue
             */
            onChange(newValue: any): void;
            /**
             * Connect to this function to receive notifications of mouse click events.
             *
             * @param event mouse Event
             */
            onClick(event: any): void;
            /**
             * Called when this widget is being displayed as a popup (ex: a Calendar popped
             * up from a DateTextBox), and it is hidden.
             * This is called from the dijit.popup code, and should not be called directly.
             *
             * Also used as a parameter for children of dijit/layout/StackContainer or subclasses.
             * Callback if a user tries to close the child.   Child will be closed if this function returns true.
             *
             */
            onClose(): boolean;
            /**
             * Connect to this function to receive notifications of mouse double click events.
             *
             * @param event mouse Event
             */
            onDblClick(event: any): void;
            /**
             * Called when the widget becomes "active" because
             * it or a widget inside of it either has focus, or has recently
             * been clicked.
             *
             */
            onFocus(): void;
            /**
             * Called when another widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate hide of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onHide(): void;
            /**
             * Connect to this function to receive notifications of various user data-input events.
             * Return false to cancel the event and prevent it from being processed.
             *
             * @param event keydown | keypress | cut | paste | input
             */
            onInput(event: any): void;
            /**
             * Connect to this function to receive notifications of keys being pressed down.
             *
             * @param event key Event
             */
            onKeyDown(event: any): void;
            /**
             * Connect to this function to receive notifications of printable keys being typed.
             *
             * @param event key Event
             */
            onKeyPress(event: any): void;
            /**
             * Connect to this function to receive notifications of keys being released.
             *
             * @param event key Event
             */
            onKeyUp(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is pressed down.
             *
             * @param event mouse Event
             */
            onMouseDown(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto this widget.
             *
             * @param event mouse Event
             */
            onMouseEnter(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of this widget.
             *
             * @param event mouse Event
             */
            onMouseLeave(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseMove(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOut(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOver(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is released.
             *
             * @param event mouse Event
             */
            onMouseUp(event: any): void;
            /**
             * Called when this widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate display of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onShow(): void;
        }
        /**
         * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/PasswordValidator.html
         *
         * A password validation widget that simplifies the "old/new/verify"
         * style of requesting passwords.  You will probably want to override
         * this class and implement your own pwCheck function.
         *
         * @param params Hash of initialization parameters for widget, including scalar values (like title, duration etc.)and functions, typically callbacks like onClick.The hash can contain any of the widget's properties, excluding read-only properties.
         * @param srcNodeRef       OptionalIf a srcNodeRef (DOM node) is specified:use srcNodeRef.innerHTML as my contentsif this is a behavioral widget then apply behavior to that srcNodeRefotherwise, replace srcNodeRef with my generated DOM tree
         */
        class PasswordValidator extends dijit.form._FormValueWidget {
            constructor(params?: Object, srcNodeRef?: HTMLElement);
            /**
             * True if mouse was pressed while over this widget, and hasn't been released yet
             *
             */
            "active": boolean;
            set(property:"active", value: boolean): void;
            get(property:"active"): boolean;
            watch(property:"active", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "alt": string;
            set(property:"alt", value: string): void;
            get(property:"alt"): string;
            watch(property:"alt", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "aria-label": string;
            set(property:"aria-label", value: string): void;
            get(property:"aria-label"): string;
            watch(property:"aria-label", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Object to which attach points and events will be scoped.  Defaults
             * to 'this'.
             *
             */
            "attachScope": Object;
            set(property:"attachScope", value: Object): void;
            get(property:"attachScope"): Object;
            watch(property:"attachScope", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute
             * for each XXX attribute to be mapped to the DOM.
             *
             * attributeMap sets up a "binding" between attributes (aka properties)
             * of the widget and the widget's DOM.
             * Changes to widget attributes listed in attributeMap will be
             * reflected into the DOM.
             *
             * For example, calling set('title', 'hello')
             * on a TitlePane will automatically cause the TitlePane's DOM to update
             * with the new title.
             *
             * attributeMap is a hash where the key is an attribute of the widget,
             * and the value reflects a binding to a:
             *
             * DOM node attribute
             *   focus: {node: "focusNode", type: "attribute"}
             * Maps this.focus to this.focusNode.focus
             *
             * DOM node innerHTML
             *   title: { node: "titleNode", type: "innerHTML" }
             * Maps this.title to this.titleNode.innerHTML
             *
             * DOM node innerText
             *   title: { node: "titleNode", type: "innerText" }
             * Maps this.title to this.titleNode.innerText
             *
             * DOM node CSS class
             *   myClass: { node: "domNode", type: "class" }
             * Maps this.myClass to this.domNode.className
             *
             * If the value is an array, then each element in the array matches one of the
             * formats of the above list.
             *
             * There are also some shorthands for backwards compatibility:
             *
             * string --> { node: string, type: "attribute" }, for example:
             * "focusNode" ---> { node: "focusNode", type: "attribute" }
             * "" --> { node: "domNode", type: "attribute" }
             *
             */
            "attributeMap": Object;
            set(property:"attributeMap", value: Object): void;
            get(property:"attributeMap"): Object;
            watch(property:"attributeMap", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate
             * widget state.
             *
             */
            "baseClass": string;
            set(property:"baseClass", value: string): void;
            get(property:"baseClass"): string;
            watch(property:"baseClass", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "class": string;
            set(property:"class", value: string): void;
            get(property:"class"): string;
            watch(property:"class", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Designates where children of the source DOM node will be placed.
             * "Children" in this case refers to both DOM nodes and widgets.
             * For example, for myWidget:
             *
             * <div data-dojo-type=myWidget>
             *     <b> here's a plain DOM node
             *     <span data-dojo-type=subWidget>and a widget</span>
             *     <i> and another plain DOM node </i>
             * </div>
             * containerNode would point to:
             *
             * <b> here's a plain DOM node
             * <span data-dojo-type=subWidget>and a widget</span>
             * <i> and another plain DOM node </i>
             * In templated widgets, "containerNode" is set via a
             * data-dojo-attach-point assignment.
             *
             * containerNode must be defined for any widget that accepts innerHTML
             * (like ContentPane or BorderContainer or even Button), and conversely
             * is null for widgets that don't, like TextBox.
             *
             */
            "containerNode": HTMLElement;
            set(property:"containerNode", value: HTMLElement): void;
            get(property:"containerNode"): HTMLElement;
            watch(property:"containerNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * Subclasses may define a cssStateNodes property that lists sub-nodes within the widget that
             * need CSS classes applied on mouse hover/press and focus.
             *
             * Each entry in this optional hash is a an attach-point name (like "upArrowButton") mapped to a CSS class name
             * (like "dijitUpArrowButton"). Example:
             *
             * {
             *     "upArrowButton": "dijitUpArrowButton",
             *     "downArrowButton": "dijitDownArrowButton"
             * }
             * The above will set the CSS class dijitUpArrowButton to the this.upArrowButton DOMNode when it
             *
             * is hovered, etc.
             *
             */
            "cssStateNodes": Object;
            set(property:"cssStateNodes", value: Object): void;
            get(property:"cssStateNodes"): Object;
            watch(property:"cssStateNodes", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Bi-directional support, as defined by the HTML DIR
             * attribute. Either left-to-right "ltr" or right-to-left "rtl".  If undefined, widgets renders in page's
             * default direction.
             *
             */
            "dir": string;
            set(property:"dir", value: string): void;
            get(property:"dir"): string;
            watch(property:"dir", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Should this widget respond to user input?
             * In markup, this is specified as "disabled='disabled'", or just "disabled".
             *
             */
            "disabled": boolean;
            set(property:"disabled", value: boolean): void;
            get(property:"disabled"): boolean;
            watch(property:"disabled", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * This is our visible representation of the widget! Other DOM
             * Nodes may by assigned to other properties, usually through the
             * template system's data-dojo-attach-point syntax, but the domNode
             * property is the canonical "top level" node in widget UI.
             *
             */
            "domNode": HTMLElement;
            set(property:"domNode", value: HTMLElement): void;
            get(property:"domNode"): HTMLElement;
            watch(property:"domNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * This widget or a widget it contains has focus, or is "active" because
             * it was recently clicked.
             *
             */
            "focused": boolean;
            set(property:"focused", value: boolean): void;
            get(property:"focused"): boolean;
            watch(property:"focused", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * True if cursor is over this widget
             *
             */
            "hovering": boolean;
            set(property:"hovering", value: boolean): void;
            get(property:"hovering"): boolean;
            watch(property:"hovering", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * A unique, opaque ID string that can be assigned by users or by the
             * system. If the developer passes an ID which is known not to be
             * unique, the specified ID is ignored and the system-generated ID is
             * used instead.
             *
             */
            "id": string;
            set(property:"id", value: string): void;
            get(property:"id"): string;
            watch(property:"id", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Fires onChange for each value change or only on demand
             *
             */
            "intermediateChanges": boolean;
            set(property:"intermediateChanges", value: boolean): void;
            get(property:"intermediateChanges"): boolean;
            watch(property:"intermediateChanges", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Rarely used.  Overrides the default Dojo locale used to render this widget,
             * as defined by the HTML LANG attribute.
             * Value must be among the list of locales specified during by the Dojo bootstrap,
             * formatted according to RFC 3066 (like en-us).
             *
             */
            "lang": string;
            set(property:"lang", value: string): void;
            get(property:"lang"): string;
            watch(property:"lang", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Name used when submitting form; same as "name" attribute or plain HTML elements
             *
             */
            "name": string;
            set(property:"name", value: string): void;
            get(property:"name"): string;
            watch(property:"name", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * The name to send our old password as (when form is posted)
             *
             */
            "oldName": Object;
            set(property:"oldName", value: Object): void;
            get(property:"oldName"): Object;
            watch(property:"oldName", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * The document this widget belongs to.  If not specified to constructor, will default to
             * srcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global
             *
             */
            "ownerDocument": Object;
            set(property:"ownerDocument", value: Object): void;
            get(property:"ownerDocument"): Object;
            watch(property:"ownerDocument", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Should this widget respond to user input?
             * In markup, this is specified as "readOnly".
             * Similar to disabled except readOnly form values are submitted.
             *
             */
            "readOnly": boolean;
            set(property:"readOnly", value: boolean): void;
            get(property:"readOnly"): boolean;
            watch(property:"readOnly", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Whether or not it is required for form submission
             *
             */
            "required": boolean;
            set(property:"required", value: boolean): void;
            get(property:"required"): boolean;
            watch(property:"required", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * On focus, should this widget scroll into view?
             *
             */
            "scrollOnFocus": boolean;
            set(property:"scrollOnFocus", value: boolean): void;
            get(property:"scrollOnFocus"): boolean;
            watch(property:"scrollOnFocus", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             *
             */
            "searchContainerNode": boolean;
            set(property:"searchContainerNode", value: boolean): void;
            get(property:"searchContainerNode"): boolean;
            watch(property:"searchContainerNode", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * pointer to original DOM node
             *
             */
            "srcNodeRef": HTMLElement;
            set(property:"srcNodeRef", value: HTMLElement): void;
            get(property:"srcNodeRef"): HTMLElement;
            watch(property:"srcNodeRef", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * HTML style attributes as cssText string or name/value hash
             *
             */
            "style": string;
            set(property:"style", value: string): void;
            get(property:"style"): string;
            watch(property:"style", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Order fields are traversed when user hits the tab key
             *
             */
            "tabIndex": string;
            set(property:"tabIndex", value: string): void;
            get(property:"tabIndex"): string;
            watch(property:"tabIndex", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Path to template (HTML file) for this widget relative to dojo.baseUrl.
             * Deprecated: use templateString with require([... "dojo/text!..."], ...) instead
             *
             */
            "templatePath": string;
            set(property:"templatePath", value: string): void;
            get(property:"templatePath"): string;
            watch(property:"templatePath", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "templateString": string;
            set(property:"templateString", value: string): void;
            get(property:"templateString"): string;
            watch(property:"templateString", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * HTML title attribute.
             *
             * For form widgets this specifies a tooltip to display when hovering over
             * the widget (just like the native HTML title attribute).
             *
             * For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,
             * etc., it's used to specify the tab label, accordion pane title, etc.  In this case it's
             * interpreted as HTML.
             *
             */
            "title": string;
            set(property:"title", value: string): void;
            get(property:"title"): string;
            watch(property:"title", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * When this widget's title attribute is used to for a tab label, accordion pane title, etc.,
             * this specifies the tooltip to appear when the mouse is hovered over that text.
             *
             */
            "tooltip": string;
            set(property:"tooltip", value: string): void;
            get(property:"tooltip"): string;
            watch(property:"tooltip", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "type": string;
            set(property:"type", value: string): void;
            get(property:"type"): string;
            watch(property:"type", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "value": string;
            set(property:"value", value: string): void;
            get(property:"value"): string;
            watch(property:"value", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: String, value: Object): any;
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: Object, value: Object): any;
            /**
             * Construct the UI for this widget, setting this.domNode.
             * Most widgets will mixin dijit._TemplatedMixin, which implements this method.
             *
             */
            buildRendering(): void;
            /**
             * Compare 2 values (as returned by get('value') for this widget).
             *
             * @param val1
             * @param val2
             */
            compare(val1: any, val2: any): number;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: Function): any;
            /**
             * Wrapper to setTimeout to avoid deferred functions executing
             * after the originating widget has been destroyed.
             * Returns an object handle with a remove method (that returns null) (replaces clearTimeout).
             *
             * @param fcn Function reference.
             * @param delay               OptionalDelay, defaults to 0.
             */
            defer(fcn: Function, delay: number): Object;
            /**
             * Destroy this widget, but not its descendants.  Descendants means widgets inside of
             * this.containerNode.   Will also destroy any resources (including widgets) registered via this.own().
             *
             * This method will also destroy internal widgets such as those created from a template,
             * assuming those widgets exist inside of this.domNode but outside of this.containerNode.
             *
             * For 2.0 it's planned that this method will also destroy descendant widgets, so apps should not
             * depend on the current ability to destroy a widget without destroying its descendants.   Generally
             * they should use destroyRecursive() for widgets with children.
             *
             * @param preserveDom If true, this method will leave the original DOM structure alone.Note: This will not yet work with _TemplatedMixin widgets
             */
            destroy(preserveDom?: boolean): void;
            /**
             * Recursively destroy the children of this widget and their
             * descendants.
             *
             * @param preserveDom               OptionalIf true, the preserveDom attribute is passed to all descendantwidget's .destroy() method. Not for use with _Templatedwidgets.
             */
            destroyDescendants(preserveDom: boolean): void;
            /**
             * Destroy this widget and its descendants
             * This is the generic "destructor" function that all widget users
             * should call to cleanly discard with a widget. Once a widget is
             * destroyed, it is removed from the manager object.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structurealone of descendant Widgets. Note: This will NOT work withdijit._TemplatedMixin widgets.
             */
            destroyRecursive(preserveDom: boolean): void;
            /**
             * Destroys the DOM nodes associated with this widget.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structure aloneduring tear-down. Note: this will not work with _Templatedwidgets yet.
             */
            destroyRendering(preserveDom?: boolean): void;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Disconnects handle created by connect.
             *
             * @param handle
             */
            disconnect(handle: any): void;
            /**
             * Used by widgets to signal that a synthetic event occurred, ex:
             *
             * myWidget.emit("attrmodified-selectedChildWidget", {}).
             * Emits an event on this.domNode named type.toLowerCase(), based on eventObj.
             * Also calls onType() method, if present, and returns value from that method.
             * By default passes eventObj to callback, but will pass callbackArgs instead, if specified.
             * Modifies eventObj by adding missing parameters (bubbles, cancelable, widget).
             *
             * @param type
             * @param eventObj               Optional
             * @param callbackArgs               Optional
             */
            emit(type: String, eventObj: Object, callbackArgs: any[]): any;
            /**
             * places focus on the first invalid input widget - if all
             * input widgets are valid, the first widget is focused.
             *
             */
            focus(): void;
            /**
             * Get a property from a widget.
             * Get a named property from a widget. The property may
             * potentially be retrieved via a getter method. If no getter is defined, this
             * just retrieves the object's property.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _getFooAttr(), calling:
             * myWidget.get("foo") would be equivalent to calling
             * widget._getFooAttr() and myWidget.get("bar")
             * would be equivalent to the expression
             * widget.bar2
             *
             * @param name The property to get.
             */
            get(name: any): any;
            /**
             * Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent
             * is this widget.   Note that it does not return all descendants, but rather just direct children.
             * Analogous to Node.childNodes,
             * except containing widgets rather than DOMNodes.
             *
             * The result intentionally excludes internally created widgets (a.k.a. supporting widgets)
             * outside of this.containerNode.
             *
             * Note that the array returned is a simple array.  Application code should not assume
             * existence of methods like forEach().
             *
             */
            getChildren(): any[];
            /**
             * Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
             * This method should generally be avoided as it returns widgets declared in templates, which are
             * supposed to be internal/hidden, but it's left here for back-compat reasons.
             *
             */
            getDescendants(): any[];
            /**
             * Returns the parent widget of this widget.
             *
             */
            getParent(): any;
            /**
             * Deprecated.  Use get('value') instead.
             *
             */
            getValue(): any;
            /**
             * Return true if this widget can currently be focused
             * and false if not
             *
             */
            isFocusable(): any;
            /**
             * Return this widget's explicit or implicit orientation (true for LTR, false for RTL)
             *
             */
            isLeftToRight(): any;
            /**
             * we are valid if ALL our children are valid
             *
             * @param isFocused
             */
            isValid: {(isFocused: boolean): any};
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: String, func: Function): any;
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: Function, func: Function): any;
            /**
             * Track specified handles and remove/destroy them when this instance is destroyed, unless they were
             * already removed/destroyed manually.
             *
             */
            own(): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: number): any;
            /**
             * Sets up the correct widgets.  You MUST specify one child
             * text box (a simple HTML <input> element) with pwType="new"
             * and one child text box with pwType="verify".  You MAY
             * specify a third child text box with pwType="old" in order to
             * prompt the user to enter in their old password before the
             * widget returns that it is valid.
             *
             */
            postCreate(): void;
            /**
             *
             */
            postMixInProperties(): void;
            /**
             * Overridable function for validation of the old password box.
             *
             * This function is called and passed the old password.  Return
             * true if it's OK to continue, and false if it is not.
             *
             * IMPORTANT SECURITY NOTE:  Do NOT EVER EVER EVER check this in
             * HTML or JavaScript!!!
             *
             * You will probably want to override this function to callback
             * to a server to verify the password (the callback will need to
             * be synchronous) - and it's probably a good idea to validate
             * it again on form submission before actually doing
             * anything destructive - that's why the "oldName" value
             * is available.
             *
             * And don't just fetch the password from the server
             * either :)  Send the test password (probably hashed, for
             * security) and return from the server a status instead.
             *
             * Again - DON'T BE INSECURE!!!  Security is left as an exercise
             * for the reader :)
             *
             * @param password
             */
            pwCheck(password: String): boolean;
            /**
             * Resetting this widget resets all our children
             *
             */
            reset(): void;
            /**
             * Set a property on a widget
             * Sets named properties on a widget which may potentially be handled by a
             * setter in the widget.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _setFooAttr(), calling
             * myWidget.set("foo", "Howdy!") would be equivalent to calling
             * widget._setFooAttr("Howdy!") and myWidget.set("bar", 3)
             * would be equivalent to the statement widget.bar = 3;
             *
             * set() may also be called with a hash of name/value pairs, ex:
             *
             * myWidget.set({
             *     foo: "Howdy",
             *     bar: 3
             * });
             * This is equivalent to calling set(foo, "Howdy") and set(bar, 3)
             *
             * @param name The property to set.
             * @param value The value to set in the property.
             */
            set(name: any, value: any): any;
            /**
             * Deprecated.  Use set() instead.
             *
             * @param attr
             * @param value
             */
            setAttribute(attr: String, value: any): void;
            /**
             * Deprecated.  Use set('disabled', ...) instead.
             *
             * @param disabled
             */
            setDisabled(disabled: boolean): void;
            /**
             * Deprecated.  Use set('value', ...) instead.
             *
             * @param value
             */
            setValue(value: String): void;
            /**
             * Processing after the DOM fragment is added to the document
             * Called after a widget and its children have been created and added to the page,
             * and all related widgets have finished their create() cycle, up through postCreate().
             *
             * Note that startup() may be called while the widget is still hidden, for example if the widget is
             * inside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.
             * For widgets that need to do layout, it's best to put that layout code inside resize(), and then
             * extend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.
             *
             */
            startup(): void;
            /**
             * Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.
             *
             * Subscribes to the specified topic and calls the specified method
             * of this object and registers for unsubscribe() on widget destroy.
             *
             * Provide widget-specific analog to dojo.subscribe, except with the
             * implicit use of this widget as the target object.
             *
             * @param t The topic
             * @param method The callback
             */
            subscribe(t: String, method: Function): any;
            /**
             * Returns a string that represents the widget.
             * When a widget is cast to a string, this method will be used to generate the
             * output. Currently, it does not implement any sort of reversible
             * serialization.
             *
             */
            toString(): string;
            /**
             * Restore the value to the last value passed to onChange
             *
             */
            undo(): void;
            /**
             * Deprecated. Override destroy() instead to implement custom widget tear-down
             * behavior.
             *
             */
            uninitialize(): boolean;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Unsubscribes handle created by this.subscribe.
             * Also removes handle from this widget's list of subscriptions
             *
             * @param handle
             */
            unsubscribe(handle: Object): void;
            /**
             * Validating this widget validates all our children
             *
             * @param isFocused
             */
            validate(isFocused: boolean): any;
            /**
             * Watches a property for changes
             *
             * @param name               OptionalIndicates the property to watch. This is optional (the callback may be theonly parameter), and if omitted, all the properties will be watched
             * @param callback The function to execute when the property changes. This will be called afterthe property has been changed. The callback will be called with the |this|set to the instance, the first argument as the name of the property, thesecond argument as the old value and the third argument as the new value.
             */
            watch(property: string, callback:{(property?:string, oldValue?:any, newValue?: any):void}) :{unwatch():void};
            /**
             * Static method to get a template based on the templatePath or
             * templateString key
             */
            getCachedTemplate(): any;
            /**
             * Called when the widget stops being "active" because
             * focus moved to something outside of it, or the user
             * clicked somewhere outside of it, or the widget was
             * hidden.
             *
             */
            onBlur(): void;
            /**
             * Callback when this widget's value is changed.
             *
             * @param newValue
             */
            onChange(newValue: any): void;
            /**
             * Connect to this function to receive notifications of mouse click events.
             *
             * @param event mouse Event
             */
            onClick(event: any): void;
            /**
             * Called when this widget is being displayed as a popup (ex: a Calendar popped
             * up from a DateTextBox), and it is hidden.
             * This is called from the dijit.popup code, and should not be called directly.
             *
             * Also used as a parameter for children of dijit/layout/StackContainer or subclasses.
             * Callback if a user tries to close the child.   Child will be closed if this function returns true.
             *
             */
            onClose(): boolean;
            /**
             * Connect to this function to receive notifications of mouse double click events.
             *
             * @param event mouse Event
             */
            onDblClick(event: any): void;
            /**
             * Called when the widget becomes "active" because
             * it or a widget inside of it either has focus, or has recently
             * been clicked.
             *
             */
            onFocus(): void;
            /**
             * Called when another widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate hide of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onHide(): void;
            /**
             * Connect to this function to receive notifications of keys being pressed down.
             *
             * @param event key Event
             */
            onKeyDown(event: any): void;
            /**
             * Connect to this function to receive notifications of printable keys being typed.
             *
             * @param event key Event
             */
            onKeyPress(event: any): void;
            /**
             * Connect to this function to receive notifications of keys being released.
             *
             * @param event key Event
             */
            onKeyUp(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is pressed down.
             *
             * @param event mouse Event
             */
            onMouseDown(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto this widget.
             *
             * @param event mouse Event
             */
            onMouseEnter(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of this widget.
             *
             * @param event mouse Event
             */
            onMouseLeave(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseMove(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOut(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOver(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is released.
             *
             * @param event mouse Event
             */
            onMouseUp(event: any): void;
            /**
             * Called when this widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate display of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onShow(): void;
        }
        /**
         * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/TimeSpinner.html
         *
         * Time Spinner
         * This widget is the same as a normal NumberSpinner, but for the time component of a date object instead
         *
         * @param params Hash of initialization parameters for widget, including scalar values (like title, duration etc.)and functions, typically callbacks like onClick.The hash can contain any of the widget's properties, excluding read-only properties.
         * @param srcNodeRef       OptionalIf a srcNodeRef (DOM node) is specified, replace srcNodeRef with my generated DOM tree.
         */
        class TimeSpinner extends dijit.form._Spinner {
            constructor(params?: Object, srcNodeRef?: HTMLElement);
            /**
             * True if mouse was pressed while over this widget, and hasn't been released yet
             *
             */
            "active": boolean;
            set(property:"active", value: boolean): void;
            get(property:"active"): boolean;
            watch(property:"active", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "alt": string;
            set(property:"alt", value: string): void;
            get(property:"alt"): string;
            watch(property:"alt", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "aria-label": string;
            set(property:"aria-label", value: string): void;
            get(property:"aria-label"): string;
            watch(property:"aria-label", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Object to which attach points and events will be scoped.  Defaults
             * to 'this'.
             *
             */
            "attachScope": Object;
            set(property:"attachScope", value: Object): void;
            get(property:"attachScope"): Object;
            watch(property:"attachScope", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute
             * for each XXX attribute to be mapped to the DOM.
             *
             * attributeMap sets up a "binding" between attributes (aka properties)
             * of the widget and the widget's DOM.
             * Changes to widget attributes listed in attributeMap will be
             * reflected into the DOM.
             *
             * For example, calling set('title', 'hello')
             * on a TitlePane will automatically cause the TitlePane's DOM to update
             * with the new title.
             *
             * attributeMap is a hash where the key is an attribute of the widget,
             * and the value reflects a binding to a:
             *
             * DOM node attribute
             *   focus: {node: "focusNode", type: "attribute"}
             * Maps this.focus to this.focusNode.focus
             *
             * DOM node innerHTML
             *   title: { node: "titleNode", type: "innerHTML" }
             * Maps this.title to this.titleNode.innerHTML
             *
             * DOM node innerText
             *   title: { node: "titleNode", type: "innerText" }
             * Maps this.title to this.titleNode.innerText
             *
             * DOM node CSS class
             *   myClass: { node: "domNode", type: "class" }
             * Maps this.myClass to this.domNode.className
             *
             * If the value is an array, then each element in the array matches one of the
             * formats of the above list.
             *
             * There are also some shorthands for backwards compatibility:
             *
             * string --> { node: string, type: "attribute" }, for example:
             * "focusNode" ---> { node: "focusNode", type: "attribute" }
             * "" --> { node: "domNode", type: "attribute" }
             *
             */
            "attributeMap": Object;
            set(property:"attributeMap", value: Object): void;
            get(property:"attributeMap"): Object;
            watch(property:"attributeMap", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             *
             */
            "baseClass": string;
            set(property:"baseClass", value: string): void;
            get(property:"baseClass"): string;
            watch(property:"baseClass", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "class": string;
            set(property:"class", value: string): void;
            get(property:"class"): string;
            watch(property:"class", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "constraints": Object;
            set(property:"constraints", value: Object): void;
            get(property:"constraints"): Object;
            watch(property:"constraints", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Designates where children of the source DOM node will be placed.
             * "Children" in this case refers to both DOM nodes and widgets.
             * For example, for myWidget:
             *
             * <div data-dojo-type=myWidget>
             *     <b> here's a plain DOM node
             *     <span data-dojo-type=subWidget>and a widget</span>
             *     <i> and another plain DOM node </i>
             * </div>
             * containerNode would point to:
             *
             * <b> here's a plain DOM node
             * <span data-dojo-type=subWidget>and a widget</span>
             * <i> and another plain DOM node </i>
             * In templated widgets, "containerNode" is set via a
             * data-dojo-attach-point assignment.
             *
             * containerNode must be defined for any widget that accepts innerHTML
             * (like ContentPane or BorderContainer or even Button), and conversely
             * is null for widgets that don't, like TextBox.
             *
             */
            "containerNode": HTMLElement;
            set(property:"containerNode", value: HTMLElement): void;
            get(property:"containerNode"): HTMLElement;
            watch(property:"containerNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             *
             */
            "cssStateNodes": Object;
            set(property:"cssStateNodes", value: Object): void;
            get(property:"cssStateNodes"): Object;
            watch(property:"cssStateNodes", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Number of milliseconds before a held arrow key or up/down button becomes typematic
             *
             */
            "defaultTimeout": number;
            set(property:"defaultTimeout", value: number): void;
            get(property:"defaultTimeout"): number;
            watch(property:"defaultTimeout", callback:{(property?:string, oldValue?:number, newValue?: number):void}) :{unwatch():void}
            /**
             * Bi-directional support, as defined by the HTML DIR
             * attribute. Either left-to-right "ltr" or right-to-left "rtl".  If undefined, widgets renders in page's
             * default direction.
             *
             */
            "dir": string;
            set(property:"dir", value: string): void;
            get(property:"dir"): string;
            watch(property:"dir", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Should this widget respond to user input?
             * In markup, this is specified as "disabled='disabled'", or just "disabled".
             *
             */
            "disabled": boolean;
            set(property:"disabled", value: boolean): void;
            get(property:"disabled"): boolean;
            watch(property:"disabled", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * For subclasses like ComboBox where the displayed value
             * (ex: Kentucky) and the serialized value (ex: KY) are different,
             * this represents the displayed value.
             *
             * Setting 'displayedValue' through set('displayedValue', ...)
             * updates 'value', and vice-versa.  Otherwise 'value' is updated
             * from 'displayedValue' periodically, like onBlur etc.
             *
             * TODO: move declaration to MappedTextBox?
             * Problem is that ComboBox references displayedValue,
             * for benefit of FilteringSelect.
             *
             */
            "displayedValue": string;
            set(property:"displayedValue", value: string): void;
            get(property:"displayedValue"): string;
            watch(property:"displayedValue", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * This is our visible representation of the widget! Other DOM
             * Nodes may by assigned to other properties, usually through the
             * template system's data-dojo-attach-point syntax, but the domNode
             * property is the canonical "top level" node in widget UI.
             *
             */
            "domNode": HTMLElement;
            set(property:"domNode", value: HTMLElement): void;
            get(property:"domNode"): HTMLElement;
            watch(property:"domNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * This widget or a widget it contains has focus, or is "active" because
             * it was recently clicked.
             *
             */
            "focused": boolean;
            set(property:"focused", value: boolean): void;
            get(property:"focused"): boolean;
            watch(property:"focused", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * True if cursor is over this widget
             *
             */
            "hovering": boolean;
            set(property:"hovering", value: boolean): void;
            get(property:"hovering"): boolean;
            watch(property:"hovering", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * A unique, opaque ID string that can be assigned by users or by the
             * system. If the developer passes an ID which is known not to be
             * unique, the specified ID is ignored and the system-generated ID is
             * used instead.
             *
             */
            "id": string;
            set(property:"id", value: string): void;
            get(property:"id"): string;
            watch(property:"id", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Fires onChange for each value change or only on demand
             *
             */
            "intermediateChanges": boolean;
            set(property:"intermediateChanges", value: boolean): void;
            get(property:"intermediateChanges"): boolean;
            watch(property:"intermediateChanges", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * The message to display if value is invalid.
             * The translated string value is read from the message file by default.
             * Set to "" to use the promptMessage instead.
             *
             */
            "invalidMessage": string;
            set(property:"invalidMessage", value: string): void;
            get(property:"invalidMessage"): string;
            watch(property:"invalidMessage", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Rarely used.  Overrides the default Dojo locale used to render this widget,
             * as defined by the HTML LANG attribute.
             * Value must be among the list of locales specified during by the Dojo bootstrap,
             * formatted according to RFC 3066 (like en-us).
             *
             */
            "lang": string;
            set(property:"lang", value: string): void;
            get(property:"lang"): string;
            watch(property:"lang", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "largeDelta": number;
            set(property:"largeDelta", value: number): void;
            get(property:"largeDelta"): number;
            watch(property:"largeDelta", callback:{(property?:string, oldValue?:number, newValue?: number):void}) :{unwatch():void}
            /**
             * Converts all characters to lowercase if true.  Default is false.
             *
             */
            "lowercase": boolean;
            set(property:"lowercase", value: boolean): void;
            get(property:"lowercase"): boolean;
            watch(property:"lowercase", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * HTML INPUT tag maxLength declaration.
             *
             */
            "maxLength": string;
            set(property:"maxLength", value: string): void;
            get(property:"maxLength"): string;
            watch(property:"maxLength", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Currently error/prompt message.
             * When using the default tooltip implementation, this will only be
             * displayed when the field is focused.
             *
             */
            "message": string;
            set(property:"message", value: string): void;
            get(property:"message"): string;
            watch(property:"message", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * minimum number of milliseconds that typematic event fires when held key or button is held
             *
             */
            "minimumTimeout": number;
            set(property:"minimumTimeout", value: number): void;
            get(property:"minimumTimeout"): number;
            watch(property:"minimumTimeout", callback:{(property?:string, oldValue?:number, newValue?: number):void}) :{unwatch():void}
            /**
             * The message to display if value is empty and the field is required.
             * The translated string value is read from the message file by default.
             * Set to "" to use the invalidMessage instead.
             *
             */
            "missingMessage": string;
            set(property:"missingMessage", value: string): void;
            get(property:"missingMessage"): string;
            watch(property:"missingMessage", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Name used when submitting form; same as "name" attribute or plain HTML elements
             *
             */
            "name": string;
            set(property:"name", value: string): void;
            get(property:"name"): string;
            watch(property:"name", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * The document this widget belongs to.  If not specified to constructor, will default to
             * srcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global
             *
             */
            "ownerDocument": Object;
            set(property:"ownerDocument", value: Object): void;
            get(property:"ownerDocument"): Object;
            watch(property:"ownerDocument", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * This defines the regular expression used to validate the input.
             * Do not add leading ^ or $ characters since the widget adds these.
             * A function may be used to generate a valid pattern when dependent on constraints or other runtime factors.
             * set('pattern', String|Function).
             *
             */
            "pattern": string;
            set(property:"pattern", value: string): void;
            get(property:"pattern"): string;
            watch(property:"pattern", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Defines a hint to help users fill out the input field (as defined in HTML 5).
             * This should only contain plain text (no html markup).
             *
             */
            "placeHolder": string;
            set(property:"placeHolder", value: string): void;
            get(property:"placeHolder"): string;
            watch(property:"placeHolder", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * If defined, display this hint string immediately on focus to the textbox, if empty.
             * Also displays if the textbox value is Incomplete (not yet valid but will be with additional input).
             * Think of this like a tooltip that tells the user what to do, not an error message
             * that tells the user what they've done wrong.
             *
             * Message disappears when user starts typing.
             *
             */
            "promptMessage": string;
            set(property:"promptMessage", value: string): void;
            get(property:"promptMessage"): string;
            watch(property:"promptMessage", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Converts the first character of each word to uppercase if true.
             *
             */
            "propercase": boolean;
            set(property:"propercase", value: boolean): void;
            get(property:"propercase"): boolean;
            watch(property:"propercase", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * The message to display if value is out-of-range
             *
             */
            "rangeMessage": string;
            set(property:"rangeMessage", value: string): void;
            get(property:"rangeMessage"): string;
            watch(property:"rangeMessage", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Should this widget respond to user input?
             * In markup, this is specified as "readOnly".
             * Similar to disabled except readOnly form values are submitted.
             *
             */
            "readOnly": boolean;
            set(property:"readOnly", value: boolean): void;
            get(property:"readOnly"): boolean;
            watch(property:"readOnly", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             *
             */
            "regExp": string;
            set(property:"regExp", value: string): void;
            get(property:"regExp"): string;
            watch(property:"regExp", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "required": boolean;
            set(property:"required", value: boolean): void;
            get(property:"required"): boolean;
            watch(property:"required", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * On focus, should this widget scroll into view?
             *
             */
            "scrollOnFocus": boolean;
            set(property:"scrollOnFocus", value: boolean): void;
            get(property:"scrollOnFocus"): boolean;
            watch(property:"scrollOnFocus", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             *
             */
            "searchContainerNode": boolean;
            set(property:"searchContainerNode", value: boolean): void;
            get(property:"searchContainerNode"): boolean;
            watch(property:"searchContainerNode", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * If true, all text will be selected when focused with mouse
             *
             */
            "selectOnClick": boolean;
            set(property:"selectOnClick", value: boolean): void;
            get(property:"selectOnClick"): boolean;
            watch(property:"selectOnClick", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             *
             */
            "smallDelta": number;
            set(property:"smallDelta", value: number): void;
            get(property:"smallDelta"): number;
            watch(property:"smallDelta", callback:{(property?:string, oldValue?:number, newValue?: number):void}) :{unwatch():void}
            /**
             * pointer to original DOM node
             *
             */
            "srcNodeRef": HTMLElement;
            set(property:"srcNodeRef", value: HTMLElement): void;
            get(property:"srcNodeRef"): HTMLElement;
            watch(property:"srcNodeRef", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * Shows current state (ie, validation result) of input (""=Normal, Incomplete, or Error)
             *
             */
            "state": string;
            set(property:"state", value: string): void;
            get(property:"state"): string;
            watch(property:"state", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * HTML style attributes as cssText string or name/value hash
             *
             */
            "style": string;
            set(property:"style", value: string): void;
            get(property:"style"): string;
            watch(property:"style", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Order fields are traversed when user hits the tab key
             *
             */
            "tabIndex": string;
            set(property:"tabIndex", value: string): void;
            get(property:"tabIndex"): string;
            watch(property:"tabIndex", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Path to template (HTML file) for this widget relative to dojo.baseUrl.
             * Deprecated: use templateString with require([... "dojo/text!..."], ...) instead
             *
             */
            "templatePath": string;
            set(property:"templatePath", value: string): void;
            get(property:"templatePath"): string;
            watch(property:"templatePath", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "templateString": string;
            set(property:"templateString", value: string): void;
            get(property:"templateString"): string;
            watch(property:"templateString", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "timeoutChangeRate": number;
            set(property:"timeoutChangeRate", value: number): void;
            get(property:"timeoutChangeRate"): number;
            watch(property:"timeoutChangeRate", callback:{(property?:string, oldValue?:number, newValue?: number):void}) :{unwatch():void}
            /**
             * HTML title attribute.
             *
             * For form widgets this specifies a tooltip to display when hovering over
             * the widget (just like the native HTML title attribute).
             *
             * For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,
             * etc., it's used to specify the tab label, accordion pane title, etc.  In this case it's
             * interpreted as HTML.
             *
             */
            "title": string;
            set(property:"title", value: string): void;
            get(property:"title"): string;
            watch(property:"title", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * When this widget's title attribute is used to for a tab label, accordion pane title, etc.,
             * this specifies the tooltip to appear when the mouse is hovered over that text.
             *
             */
            "tooltip": string;
            set(property:"tooltip", value: string): void;
            get(property:"tooltip"): string;
            watch(property:"tooltip", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * See description of dijit/Tooltip.defaultPosition for details on this parameter.
             *
             */
            "tooltipPosition": Object;
            set(property:"tooltipPosition", value: Object): void;
            get(property:"tooltipPosition"): Object;
            watch(property:"tooltipPosition", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Removes leading and trailing whitespace if true.  Default is false.
             *
             */
            "trim": boolean;
            set(property:"trim", value: boolean): void;
            get(property:"trim"): boolean;
            watch(property:"trim", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "type": string;
            set(property:"type", value: string): void;
            get(property:"type"): string;
            watch(property:"type", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Converts all characters to uppercase if true.  Default is false.
             *
             */
            "uppercase": boolean;
            set(property:"uppercase", value: boolean): void;
            get(property:"uppercase"): boolean;
            watch(property:"uppercase", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             *
             */
            "value": string;
            set(property:"value", value: string): void;
            get(property:"value"): string;
            watch(property:"value", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             * @param val
             * @param delta
             */
            adjust(val: Object, delta: number): any;
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: String, value: Object): any;
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: Object, value: Object): any;
            /**
             *
             */
            buildRendering(): void;
            /**
             * Compare 2 values (as returned by get('value') for this widget).
             *
             * @param val1
             * @param val2
             */
            compare(val1: any, val2: any): number;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: Function): any;
            /**
             * Wrapper to setTimeout to avoid deferred functions executing
             * after the originating widget has been destroyed.
             * Returns an object handle with a remove method (that returns null) (replaces clearTimeout).
             *
             * @param fcn Function reference.
             * @param delay               OptionalDelay, defaults to 0.
             */
            defer(fcn: Function, delay: number): Object;
            /**
             * Destroy this widget, but not its descendants.  Descendants means widgets inside of
             * this.containerNode.   Will also destroy any resources (including widgets) registered via this.own().
             *
             * This method will also destroy internal widgets such as those created from a template,
             * assuming those widgets exist inside of this.domNode but outside of this.containerNode.
             *
             * For 2.0 it's planned that this method will also destroy descendant widgets, so apps should not
             * depend on the current ability to destroy a widget without destroying its descendants.   Generally
             * they should use destroyRecursive() for widgets with children.
             *
             * @param preserveDom If true, this method will leave the original DOM structure alone.Note: This will not yet work with _TemplatedMixin widgets
             */
            destroy(preserveDom?: boolean): void;
            /**
             * Recursively destroy the children of this widget and their
             * descendants.
             *
             * @param preserveDom               OptionalIf true, the preserveDom attribute is passed to all descendantwidget's .destroy() method. Not for use with _Templatedwidgets.
             */
            destroyDescendants(preserveDom: boolean): void;
            /**
             * Destroy this widget and its descendants
             * This is the generic "destructor" function that all widget users
             * should call to cleanly discard with a widget. Once a widget is
             * destroyed, it is removed from the manager object.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structurealone of descendant Widgets. Note: This will NOT work withdijit._TemplatedMixin widgets.
             */
            destroyRecursive(preserveDom: boolean): void;
            /**
             * Destroys the DOM nodes associated with this widget.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structure aloneduring tear-down. Note: this will not work with _Templatedwidgets yet.
             */
            destroyRendering(preserveDom?: boolean): void;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Disconnects handle created by connect.
             *
             * @param handle
             */
            disconnect(handle: any): void;
            /**
             * Overridable method to display validation errors/hints.
             * By default uses a tooltip.
             *
             * @param message
             */
            displayMessage(message: String): void;
            /**
             * Used by widgets to signal that a synthetic event occurred, ex:
             *
             * myWidget.emit("attrmodified-selectedChildWidget", {}).
             * Emits an event on this.domNode named type.toLowerCase(), based on eventObj.
             * Also calls onType() method, if present, and returns value from that method.
             * By default passes eventObj to callback, but will pass callbackArgs instead, if specified.
             * Modifies eventObj by adding missing parameters (bubbles, cancelable, widget).
             *
             * @param type
             * @param eventObj               Optional
             * @param callbackArgs               Optional
             */
            emit(type: String, eventObj: Object, callbackArgs: any[]): any;
            /**
             * Auto-corrections (such as trimming) that are applied to textbox
             * value on blur or form submit.
             * For MappedTextBox subclasses, this is called twice
             *
             * once with the display value
             * once the value as set/returned by set('value', ...)
             * and get('value'), ex: a Number for NumberTextBox.
             *
             * In the latter case it does corrections like converting null to NaN.  In
             * the former case the NumberTextBox.filter() method calls this.inherited()
             * to execute standard trimming code in TextBox.filter().
             *
             * TODO: break this into two methods in 2.0
             *
             * @param val
             */
            filter(val: any): any;
            /**
             * Put focus on this widget
             *
             */
            focus(): void;
            /**
             *
             * @param time
             * @param locale
             */
            format(time: any, locale: any): any;
            /**
             * Get a property from a widget.
             * Get a named property from a widget. The property may
             * potentially be retrieved via a getter method. If no getter is defined, this
             * just retrieves the object's property.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _getFooAttr(), calling:
             * myWidget.get("foo") would be equivalent to calling
             * widget._getFooAttr() and myWidget.get("bar")
             * would be equivalent to the expression
             * widget.bar2
             *
             * @param name The property to get.
             */
            get(name: any): any;
            /**
             * Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent
             * is this widget.   Note that it does not return all descendants, but rather just direct children.
             * Analogous to Node.childNodes,
             * except containing widgets rather than DOMNodes.
             *
             * The result intentionally excludes internally created widgets (a.k.a. supporting widgets)
             * outside of this.containerNode.
             *
             * Note that the array returned is a simple array.  Application code should not assume
             * existence of methods like forEach().
             *
             */
            getChildren(): any[];
            /**
             * Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
             * This method should generally be avoided as it returns widgets declared in templates, which are
             * supposed to be internal/hidden, but it's left here for back-compat reasons.
             *
             */
            getDescendants(): any[];
            /**
             * Deprecated.  Use get('displayedValue') instead.
             *
             */
            getDisplayedValue(): any;
            /**
             *
             * @param isFocused
             */
            getErrorMessage(isFocused: boolean): any;
            /**
             * Returns the parent widget of this widget.
             *
             */
            getParent(): any;
            /**
             * Return a hint message to show when widget is first focused
             *
             * @param isFocused
             */
            getPromptMessage(isFocused: boolean): any;
            /**
             * Deprecated.  Use get('value') instead.
             *
             */
            getValue(): any;
            /**
             * Return true if this widget can currently be focused
             * and false if not
             *
             */
            isFocusable(): any;
            /**
             * Tests if the value is in the min/max range specified in constraints
             *
             * @param isFocused
             */
            isInRange(isFocused: boolean): any;
            /**
             * Return this widget's explicit or implicit orientation (true for LTR, false for RTL)
             *
             */
            isLeftToRight(): any;
            /**
             *
             */
            isValid: {(): boolean};
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: String, func: Function): any;
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: Function, func: Function): any;
            /**
             * Track specified handles and remove/destroy them when this instance is destroyed, unless they were
             * already removed/destroyed manually.
             *
             */
            own(): any;
            /**
             *
             * @param time
             * @param locale
             */
            parse(time: any, locale: any): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: number): any;
            /**
             *
             */
            postCreate(): void;
            /**
             *
             */
            postMixInProperties(): void;
            /**
             * Overridable function used to validate the range of the numeric input value.
             *
             * @param primitive
             * @param constraints
             */
            rangeCheck(primitive: number, constraints: dijit.form.RangeBoundTextBox.__Constraints): boolean;
            /**
             * Deprecated.  Use set('pattern', Function) instead.
             *
             * @param constraints An object with the following properties:locale (String): locale used for validation, picks up value from this widget's lang attribute_flags_ (anything): various flags passed to pattern function
             */
            regExpGen(constraints: Object): void;
            /**
             *
             */
            reset(): void;
            /**
             * Format a Date object as a string according a subset of the ISO-8601 standard
             * When options.selector is omitted, output follows RFC3339
             * The local time zone is included as an offset from GMT, except when selector=='time' (time without a date)
             * Does not check bounds.  Only years between 100 and 9999 are supported.
             *
             * @param dateObject A Date object
             * @param options               OptionalAn object with the following properties:selector (String): "date" or "time" for partial formatting of the Date object.Both date and time will be formatted by default.zulu (Boolean): if true, UTC/GMT is used for a timezonemilliseconds (Boolean): if true, output milliseconds
             */
            serialize(dateObject: Date, options: Object): any;
            /**
             * Set a property on a widget
             * Sets named properties on a widget which may potentially be handled by a
             * setter in the widget.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _setFooAttr(), calling
             * myWidget.set("foo", "Howdy!") would be equivalent to calling
             * widget._setFooAttr("Howdy!") and myWidget.set("bar", 3)
             * would be equivalent to the statement widget.bar = 3;
             *
             * set() may also be called with a hash of name/value pairs, ex:
             *
             * myWidget.set({
             *     foo: "Howdy",
             *     bar: 3
             * });
             * This is equivalent to calling set(foo, "Howdy") and set(bar, 3)
             *
             * @param name The property to set.
             * @param value The value to set in the property.
             */
            set(name: any, value: any): any;
            /**
             * Deprecated.  Use set() instead.
             *
             * @param attr
             * @param value
             */
            setAttribute(attr: String, value: any): void;
            /**
             * Deprecated.  Use set('disabled', ...) instead.
             *
             * @param disabled
             */
            setDisabled(disabled: boolean): void;
            /**
             * Deprecated.  Use set('displayedValue', ...) instead.
             *
             * @param value
             */
            setDisplayedValue(value: String): void;
            /**
             * Deprecated.  Use set('value', ...) instead.
             *
             * @param value
             */
            setValue(value: String): void;
            /**
             *
             */
            startup(): void;
            /**
             * Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.
             *
             * Subscribes to the specified topic and calls the specified method
             * of this object and registers for unsubscribe() on widget destroy.
             *
             * Provide widget-specific analog to dojo.subscribe, except with the
             * implicit use of this widget as the target object.
             *
             * @param t The topic
             * @param method The callback
             */
            subscribe(t: String, method: Function): any;
            /**
             * Returns widget as a printable string using the widget's value
             *
             */
            toString(): string;
            /**
             * Restore the value to the last value passed to onChange
             *
             */
            undo(): void;
            /**
             * Deprecated. Override destroy() instead to implement custom widget tear-down
             * behavior.
             *
             */
            uninitialize(): boolean;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Unsubscribes handle created by this.subscribe.
             * Also removes handle from this widget's list of subscriptions
             *
             * @param handle
             */
            unsubscribe(handle: Object): void;
            /**
             *
             */
            validate(): any;
            /**
             * Overridable function used to validate the text input against the regular expression.
             *
             * @param value
             * @param constraints An object with the following properties:locale (String): locale used for validation, picks up value from this widget's lang attribute_flags_ (anything): various flags passed to pattern function
             */
            validator(value: any, constraints: Object): any;
            /**
             * Watches a property for changes
             *
             * @param name               OptionalIndicates the property to watch. This is optional (the callback may be theonly parameter), and if omitted, all the properties will be watched
             * @param callback The function to execute when the property changes. This will be called afterthe property has been changed. The callback will be called with the |this|set to the instance, the first argument as the name of the property, thesecond argument as the old value and the third argument as the new value.
             */
            watch(property: string, callback:{(property?:string, oldValue?:any, newValue?: any):void}) :{unwatch():void};
            /**
             * Static method to get a template based on the templatePath or
             * templateString key
             */
            getCachedTemplate(): any;
            /**
             * Called when the widget stops being "active" because
             * focus moved to something outside of it, or the user
             * clicked somewhere outside of it, or the widget was
             * hidden.
             *
             */
            onBlur(): void;
            /**
             * Callback when this widget's value is changed.
             *
             * @param newValue
             */
            onChange(newValue: any): void;
            /**
             * Connect to this function to receive notifications of mouse click events.
             *
             * @param event mouse Event
             */
            onClick(event: any): void;
            /**
             * Called when this widget is being displayed as a popup (ex: a Calendar popped
             * up from a DateTextBox), and it is hidden.
             * This is called from the dijit.popup code, and should not be called directly.
             *
             * Also used as a parameter for children of dijit/layout/StackContainer or subclasses.
             * Callback if a user tries to close the child.   Child will be closed if this function returns true.
             *
             */
            onClose(): boolean;
            /**
             * Connect to this function to receive notifications of mouse double click events.
             *
             * @param event mouse Event
             */
            onDblClick(event: any): void;
            /**
             * Called when the widget becomes "active" because
             * it or a widget inside of it either has focus, or has recently
             * been clicked.
             *
             */
            onFocus(): void;
            /**
             * Called when another widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate hide of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onHide(): void;
            /**
             * Connect to this function to receive notifications of various user data-input events.
             * Return false to cancel the event and prevent it from being processed.
             *
             * @param event keydown | keypress | cut | paste | input
             */
            onInput(event: any): void;
            /**
             * Connect to this function to receive notifications of keys being pressed down.
             *
             * @param event key Event
             */
            onKeyDown(event: any): void;
            /**
             * Connect to this function to receive notifications of printable keys being typed.
             *
             * @param event key Event
             */
            onKeyPress(event: any): void;
            /**
             * Connect to this function to receive notifications of keys being released.
             *
             * @param event key Event
             */
            onKeyUp(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is pressed down.
             *
             * @param event mouse Event
             */
            onMouseDown(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto this widget.
             *
             * @param event mouse Event
             */
            onMouseEnter(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of this widget.
             *
             * @param event mouse Event
             */
            onMouseLeave(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseMove(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOut(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOver(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is released.
             *
             * @param event mouse Event
             */
            onMouseUp(event: any): void;
            /**
             * Called when this widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate display of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onShow(): void;
        }
        /**
         * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/MultiComboBox.html
         *
         * A ComboBox that accepts multiple inputs on a single line
         *
         * @param params Hash of initialization parameters for widget, including scalar values (like title, duration etc.)and functions, typically callbacks like onClick.The hash can contain any of the widget's properties, excluding read-only properties.
         * @param srcNodeRef       OptionalIf a srcNodeRef (DOM node) is specified, replace srcNodeRef with my generated DOM tree.
         */
        class MultiComboBox extends dijit.form.ValidationTextBox implements dijit.form.ComboBoxMixin {
            constructor(params?: Object, srcNodeRef?: HTMLElement);
            /**
             * True if mouse was pressed while over this widget, and hasn't been released yet
             *
             */
            "active": boolean;
            set(property:"active", value: boolean): void;
            get(property:"active"): boolean;
            watch(property:"active", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "alt": string;
            set(property:"alt", value: string): void;
            get(property:"alt"): string;
            watch(property:"alt", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "aria-label": string;
            set(property:"aria-label", value: string): void;
            get(property:"aria-label"): string;
            watch(property:"aria-label", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Object to which attach points and events will be scoped.  Defaults
             * to 'this'.
             *
             */
            "attachScope": Object;
            set(property:"attachScope", value: Object): void;
            get(property:"attachScope"): Object;
            watch(property:"attachScope", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute
             * for each XXX attribute to be mapped to the DOM.
             *
             * attributeMap sets up a "binding" between attributes (aka properties)
             * of the widget and the widget's DOM.
             * Changes to widget attributes listed in attributeMap will be
             * reflected into the DOM.
             *
             * For example, calling set('title', 'hello')
             * on a TitlePane will automatically cause the TitlePane's DOM to update
             * with the new title.
             *
             * attributeMap is a hash where the key is an attribute of the widget,
             * and the value reflects a binding to a:
             *
             * DOM node attribute
             *   focus: {node: "focusNode", type: "attribute"}
             * Maps this.focus to this.focusNode.focus
             *
             * DOM node innerHTML
             *   title: { node: "titleNode", type: "innerHTML" }
             * Maps this.title to this.titleNode.innerHTML
             *
             * DOM node innerText
             *   title: { node: "titleNode", type: "innerText" }
             * Maps this.title to this.titleNode.innerText
             *
             * DOM node CSS class
             *   myClass: { node: "domNode", type: "class" }
             * Maps this.myClass to this.domNode.className
             *
             * If the value is an array, then each element in the array matches one of the
             * formats of the above list.
             *
             * There are also some shorthands for backwards compatibility:
             *
             * string --> { node: string, type: "attribute" }, for example:
             * "focusNode" ---> { node: "focusNode", type: "attribute" }
             * "" --> { node: "domNode", type: "attribute" }
             *
             */
            "attributeMap": Object;
            set(property:"attributeMap", value: Object): void;
            get(property:"attributeMap"): Object;
            watch(property:"attributeMap", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * If user types in a partial string, and then tab out of the <input> box,
             * automatically copy the first entry displayed in the drop down list to
             * the <input> field
             *
             */
            "autoComplete": boolean;
            set(property:"autoComplete", value: boolean): void;
            get(property:"autoComplete"): boolean;
            watch(property:"autoComplete", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Set to true to make the drop down at least as wide as this
             * widget.  Set to false if the drop down should just be its
             * default width.
             *
             */
            "autoWidth": boolean;
            set(property:"autoWidth", value: boolean): void;
            get(property:"autoWidth"): boolean;
            watch(property:"autoWidth", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             *
             */
            "baseClass": string;
            set(property:"baseClass", value: string): void;
            get(property:"baseClass"): string;
            watch(property:"baseClass", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "class": string;
            set(property:"class", value: string): void;
            get(property:"class"): string;
            watch(property:"class", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * user-defined object needed to pass parameters to the validator functions
             *
             */
            "constraints": Object;
            set(property:"constraints", value: Object): void;
            get(property:"constraints"): Object;
            watch(property:"constraints", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Designates where children of the source DOM node will be placed.
             * "Children" in this case refers to both DOM nodes and widgets.
             * For example, for myWidget:
             *
             * <div data-dojo-type=myWidget>
             *     <b> here's a plain DOM node
             *     <span data-dojo-type=subWidget>and a widget</span>
             *     <i> and another plain DOM node </i>
             * </div>
             * containerNode would point to:
             *
             * <b> here's a plain DOM node
             * <span data-dojo-type=subWidget>and a widget</span>
             * <i> and another plain DOM node </i>
             * In templated widgets, "containerNode" is set via a
             * data-dojo-attach-point assignment.
             *
             * containerNode must be defined for any widget that accepts innerHTML
             * (like ContentPane or BorderContainer or even Button), and conversely
             * is null for widgets that don't, like TextBox.
             *
             */
            "containerNode": HTMLElement;
            set(property:"containerNode", value: HTMLElement): void;
            get(property:"containerNode"): HTMLElement;
            watch(property:"containerNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * Subclasses may define a cssStateNodes property that lists sub-nodes within the widget that
             * need CSS classes applied on mouse hover/press and focus.
             *
             * Each entry in this optional hash is a an attach-point name (like "upArrowButton") mapped to a CSS class name
             * (like "dijitUpArrowButton"). Example:
             *
             * {
             *     "upArrowButton": "dijitUpArrowButton",
             *     "downArrowButton": "dijitDownArrowButton"
             * }
             * The above will set the CSS class dijitUpArrowButton to the this.upArrowButton DOMNode when it
             *
             * is hovered, etc.
             *
             */
            "cssStateNodes": Object;
            set(property:"cssStateNodes", value: Object): void;
            get(property:"cssStateNodes"): Object;
            watch(property:"cssStateNodes", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * The character to use to separate items in the ComboBox input
             *
             */
            "delimiter": string;
            set(property:"delimiter", value: string): void;
            get(property:"delimiter"): string;
            watch(property:"delimiter", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Bi-directional support, as defined by the HTML DIR
             * attribute. Either left-to-right "ltr" or right-to-left "rtl".  If undefined, widgets renders in page's
             * default direction.
             *
             */
            "dir": string;
            set(property:"dir", value: string): void;
            get(property:"dir"): string;
            watch(property:"dir", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Should this widget respond to user input?
             * In markup, this is specified as "disabled='disabled'", or just "disabled".
             *
             */
            "disabled": boolean;
            set(property:"disabled", value: boolean): void;
            get(property:"disabled"): boolean;
            watch(property:"disabled", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * For subclasses like ComboBox where the displayed value
             * (ex: Kentucky) and the serialized value (ex: KY) are different,
             * this represents the displayed value.
             *
             * Setting 'displayedValue' through set('displayedValue', ...)
             * updates 'value', and vice-versa.  Otherwise 'value' is updated
             * from 'displayedValue' periodically, like onBlur etc.
             *
             * TODO: move declaration to MappedTextBox?
             * Problem is that ComboBox references displayedValue,
             * for benefit of FilteringSelect.
             *
             */
            "displayedValue": string;
            set(property:"displayedValue", value: string): void;
            get(property:"displayedValue"): string;
            watch(property:"displayedValue", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * This is our visible representation of the widget! Other DOM
             * Nodes may by assigned to other properties, usually through the
             * template system's data-dojo-attach-point syntax, but the domNode
             * property is the canonical "top level" node in widget UI.
             *
             */
            "domNode": HTMLElement;
            set(property:"domNode", value: HTMLElement): void;
            get(property:"domNode"): HTMLElement;
            watch(property:"domNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * The widget to display as a popup.  This widget must be
             * defined before the startup function is called.
             *
             */
            "dropDown": Object;
            set(property:"dropDown", value: Object): void;
            get(property:"dropDown"): Object;
            watch(property:"dropDown", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * This variable controls the position of the drop down.
             * It's an array of strings with the following values:
             *
             * before: places drop down to the left of the target node/widget, or to the right in
             * the case of RTL scripts like Hebrew and Arabic
             * after: places drop down to the right of the target node/widget, or to the left in
             * the case of RTL scripts like Hebrew and Arabic
             * above: drop down goes above target node
             * below: drop down goes below target node
             * The list is positions is tried, in order, until a position is found where the drop down fits
             * within the viewport.
             *
             */
            "dropDownPosition": Object;
            set(property:"dropDownPosition", value: Object): void;
            get(property:"dropDownPosition"): Object;
            watch(property:"dropDownPosition", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Mixin to the store's fetch.
             * For example, to set the sort order of the ComboBox menu, pass:
             *
             * { sort: [{attribute:"name",descending: true}] }
             * To override the default queryOptions so that deep=false, do:
             *
             * { queryOptions: {ignoreCase: true, deep: false} }
             *
             */
            "fetchProperties": Object;
            set(property:"fetchProperties", value: Object): void;
            get(property:"fetchProperties"): Object;
            watch(property:"fetchProperties", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * This widget or a widget it contains has focus, or is "active" because
             * it was recently clicked.
             *
             */
            "focused": boolean;
            set(property:"focused", value: boolean): void;
            get(property:"focused"): boolean;
            watch(property:"focused", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Set to true to make the drop down exactly as wide as this
             * widget.  Overrides autoWidth.
             *
             */
            "forceWidth": boolean;
            set(property:"forceWidth", value: boolean): void;
            get(property:"forceWidth"): boolean;
            watch(property:"forceWidth", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Set this textbox to have a down arrow button, to display the drop down list.
             * Defaults to true.
             *
             */
            "hasDownArrow": boolean;
            set(property:"hasDownArrow", value: boolean): void;
            get(property:"hasDownArrow"): boolean;
            watch(property:"hasDownArrow", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * One of: "first", "all" or "none".
             *
             * If the ComboBox/FilteringSelect opens with the search results and the searched
             * string can be found, it will be highlighted.  If set to "all"
             * then will probably want to change queryExpr parameter to '${0}'
             *
             * Highlighting is only performed when labelType is "text", so as to not
             * interfere with any HTML markup an HTML label might contain.
             *
             */
            "highlightMatch": string;
            set(property:"highlightMatch", value: string): void;
            get(property:"highlightMatch"): string;
            watch(property:"highlightMatch", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * True if cursor is over this widget
             *
             */
            "hovering": boolean;
            set(property:"hovering", value: boolean): void;
            get(property:"hovering"): boolean;
            watch(property:"hovering", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * A unique, opaque ID string that can be assigned by users or by the
             * system. If the developer passes an ID which is known not to be
             * unique, the specified ID is ignored and the system-generated ID is
             * used instead.
             *
             */
            "id": string;
            set(property:"id", value: string): void;
            get(property:"id"): string;
            watch(property:"id", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Set true if the query should ignore case when matching possible items
             *
             */
            "ignoreCase": boolean;
            set(property:"ignoreCase", value: boolean): void;
            get(property:"ignoreCase"): boolean;
            watch(property:"ignoreCase", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Fires onChange for each value change or only on demand
             *
             */
            "intermediateChanges": boolean;
            set(property:"intermediateChanges", value: boolean): void;
            get(property:"intermediateChanges"): boolean;
            watch(property:"intermediateChanges", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * The message to display if value is invalid.
             * The translated string value is read from the message file by default.
             * Set to "" to use the promptMessage instead.
             *
             */
            "invalidMessage": string;
            set(property:"invalidMessage", value: string): void;
            get(property:"invalidMessage"): string;
            watch(property:"invalidMessage", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * This is the item returned by the dojo/store/api/Store implementation that
             * provides the data for this ComboBox, it's the currently selected item.
             *
             */
            "item": Object;
            set(property:"item", value: Object): void;
            get(property:"item"): Object;
            watch(property:"item", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * The entries in the drop down list come from this attribute in the
             * dojo.data items.
             * If not specified, the searchAttr attribute is used instead.
             *
             */
            "labelAttr": Object;
            set(property:"labelAttr", value: Object): void;
            get(property:"labelAttr"): Object;
            watch(property:"labelAttr", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Specifies how to interpret the labelAttr in the data store items.
             * Can be "html" or "text".
             *
             */
            "labelType": string;
            set(property:"labelType", value: string): void;
            get(property:"labelType"): string;
            watch(property:"labelType", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Rarely used.  Overrides the default Dojo locale used to render this widget,
             * as defined by the HTML LANG attribute.
             * Value must be among the list of locales specified during by the Dojo bootstrap,
             * formatted according to RFC 3066 (like en-us).
             *
             */
            "lang": string;
            set(property:"lang", value: string): void;
            get(property:"lang"): string;
            watch(property:"lang", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Converts all characters to lowercase if true.  Default is false.
             *
             */
            "lowercase": boolean;
            set(property:"lowercase", value: boolean): void;
            get(property:"lowercase"): boolean;
            watch(property:"lowercase", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * The max height for our dropdown.
             * Any dropdown taller than this will have scrollbars.
             * Set to 0 for no max height, or -1 to limit height to available space in viewport
             *
             */
            "maxHeight": number;
            set(property:"maxHeight", value: number): void;
            get(property:"maxHeight"): number;
            watch(property:"maxHeight", callback:{(property?:string, oldValue?:number, newValue?: number):void}) :{unwatch():void}
            /**
             * HTML INPUT tag maxLength declaration.
             *
             */
            "maxLength": string;
            set(property:"maxLength", value: string): void;
            get(property:"maxLength"): string;
            watch(property:"maxLength", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Currently error/prompt message.
             * When using the default tooltip implementation, this will only be
             * displayed when the field is focused.
             *
             */
            "message": string;
            set(property:"message", value: string): void;
            get(property:"message"): string;
            watch(property:"message", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * The message to display if value is empty and the field is required.
             * The translated string value is read from the message file by default.
             * Set to "" to use the invalidMessage instead.
             *
             */
            "missingMessage": string;
            set(property:"missingMessage", value: string): void;
            get(property:"missingMessage"): string;
            watch(property:"missingMessage", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Name used when submitting form; same as "name" attribute or plain HTML elements
             *
             */
            "name": string;
            set(property:"name", value: string): void;
            get(property:"name"): string;
            watch(property:"name", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * The document this widget belongs to.  If not specified to constructor, will default to
             * srcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global
             *
             */
            "ownerDocument": Object;
            set(property:"ownerDocument", value: Object): void;
            get(property:"ownerDocument"): Object;
            watch(property:"ownerDocument", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Argument to data provider.
             * Specifies maximum number of search results to return per query
             *
             */
            "pageSize": number;
            set(property:"pageSize", value: number): void;
            get(property:"pageSize"): number;
            watch(property:"pageSize", callback:{(property?:string, oldValue?:number, newValue?: number):void}) :{unwatch():void}
            /**
             * This defines the regular expression used to validate the input.
             * Do not add leading ^ or $ characters since the widget adds these.
             * A function may be used to generate a valid pattern when dependent on constraints or other runtime factors.
             * set('pattern', String|Function).
             *
             */
            "pattern": string;
            set(property:"pattern", value: string): void;
            get(property:"pattern"): string;
            watch(property:"pattern", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Defines a hint to help users fill out the input field (as defined in HTML 5).
             * This should only contain plain text (no html markup).
             *
             */
            "placeHolder": string;
            set(property:"placeHolder", value: string): void;
            get(property:"placeHolder"): string;
            watch(property:"placeHolder", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * If defined, display this hint string immediately on focus to the textbox, if empty.
             * Also displays if the textbox value is Incomplete (not yet valid but will be with additional input).
             * Think of this like a tooltip that tells the user what to do, not an error message
             * that tells the user what they've done wrong.
             *
             * Message disappears when user starts typing.
             *
             */
            "promptMessage": string;
            set(property:"promptMessage", value: string): void;
            get(property:"promptMessage"): string;
            watch(property:"promptMessage", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Converts the first character of each word to uppercase if true.
             *
             */
            "propercase": boolean;
            set(property:"propercase", value: boolean): void;
            get(property:"propercase"): boolean;
            watch(property:"propercase", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * A query that can be passed to store to initially filter the items.
             * ComboBox overwrites any reference to the searchAttr and sets it to the queryExpr with the user's input substituted.
             *
             */
            "query": Object;
            set(property:"query", value: Object): void;
            get(property:"query"): Object;
            watch(property:"query", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * This specifies what query is sent to the data store,
             * based on what the user has typed.  Changing this expression will modify
             * whether the results are only exact matches, a "starting with" match,
             * etc.
             * ${0} will be substituted for the user text.
             * * is used for wildcards.
             * ${0}* means "starts with", *${0}* means "contains", ${0} means "is"
             *
             */
            "queryExpr": string;
            set(property:"queryExpr", value: string): void;
            get(property:"queryExpr"): string;
            watch(property:"queryExpr", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Should this widget respond to user input?
             * In markup, this is specified as "readOnly".
             * Similar to disabled except readOnly form values are submitted.
             *
             */
            "readOnly": boolean;
            set(property:"readOnly", value: boolean): void;
            get(property:"readOnly"): boolean;
            watch(property:"readOnly", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             *
             */
            "regExp": string;
            set(property:"regExp", value: string): void;
            get(property:"regExp"): string;
            watch(property:"regExp", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * User is required to enter data into this field.
             *
             */
            "required": boolean;
            set(property:"required", value: boolean): void;
            get(property:"required"): boolean;
            watch(property:"required", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * On focus, should this widget scroll into view?
             *
             */
            "scrollOnFocus": boolean;
            set(property:"scrollOnFocus", value: boolean): void;
            get(property:"scrollOnFocus"): boolean;
            watch(property:"scrollOnFocus", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Search for items in the data store where this attribute (in the item)
             * matches what the user typed
             *
             */
            "searchAttr": string;
            set(property:"searchAttr", value: string): void;
            get(property:"searchAttr"): string;
            watch(property:"searchAttr", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "searchContainerNode": boolean;
            set(property:"searchContainerNode", value: boolean): void;
            get(property:"searchContainerNode"): boolean;
            watch(property:"searchContainerNode", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Delay in milliseconds between when user types something and we start
             * searching based on that value
             *
             */
            "searchDelay": number;
            set(property:"searchDelay", value: number): void;
            get(property:"searchDelay"): number;
            watch(property:"searchDelay", callback:{(property?:string, oldValue?:number, newValue?: number):void}) :{unwatch():void}
            /**
             * If true, all text will be selected when focused with mouse
             *
             */
            "selectOnClick": boolean;
            set(property:"selectOnClick", value: boolean): void;
            get(property:"selectOnClick"): boolean;
            watch(property:"selectOnClick", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * pointer to original DOM node
             *
             */
            "srcNodeRef": HTMLElement;
            set(property:"srcNodeRef", value: HTMLElement): void;
            get(property:"srcNodeRef"): HTMLElement;
            watch(property:"srcNodeRef", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * Shows current state (ie, validation result) of input (""=Normal, Incomplete, or Error)
             *
             */
            "state": string;
            set(property:"state", value: string): void;
            get(property:"state"): string;
            watch(property:"state", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Reference to data provider object used by this ComboBox.
             *
             * Should be dojo/store/api/Store, but dojo/data/api/Read supported
             * for backwards compatibility.
             *
             */
            "store": Object;
            set(property:"store", value: Object): void;
            get(property:"store"): Object;
            watch(property:"store", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * HTML style attributes as cssText string or name/value hash
             *
             */
            "style": string;
            set(property:"style", value: string): void;
            get(property:"style"): string;
            watch(property:"style", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Order fields are traversed when user hits the tab key
             *
             */
            "tabIndex": string;
            set(property:"tabIndex", value: string): void;
            get(property:"tabIndex"): string;
            watch(property:"tabIndex", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Path to template (HTML file) for this widget relative to dojo.baseUrl.
             * Deprecated: use templateString with require([... "dojo/text!..."], ...) instead
             *
             */
            "templatePath": string;
            set(property:"templatePath", value: string): void;
            get(property:"templatePath"): string;
            watch(property:"templatePath", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "templateString": string;
            set(property:"templateString", value: string): void;
            get(property:"templateString"): string;
            watch(property:"templateString", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * HTML title attribute.
             *
             * For form widgets this specifies a tooltip to display when hovering over
             * the widget (just like the native HTML title attribute).
             *
             * For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,
             * etc., it's used to specify the tab label, accordion pane title, etc.  In this case it's
             * interpreted as HTML.
             *
             */
            "title": string;
            set(property:"title", value: string): void;
            get(property:"title"): string;
            watch(property:"title", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * When this widget's title attribute is used to for a tab label, accordion pane title, etc.,
             * this specifies the tooltip to appear when the mouse is hovered over that text.
             *
             */
            "tooltip": string;
            set(property:"tooltip", value: string): void;
            get(property:"tooltip"): string;
            watch(property:"tooltip", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * See description of dijit/Tooltip.defaultPosition for details on this parameter.
             *
             */
            "tooltipPosition": Object;
            set(property:"tooltipPosition", value: Object): void;
            get(property:"tooltipPosition"): Object;
            watch(property:"tooltipPosition", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Removes leading and trailing whitespace if true.  Default is false.
             *
             */
            "trim": boolean;
            set(property:"trim", value: boolean): void;
            get(property:"trim"): boolean;
            watch(property:"trim", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "type": string;
            set(property:"type", value: string): void;
            get(property:"type"): string;
            watch(property:"type", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Converts all characters to uppercase if true.  Default is false.
             *
             */
            "uppercase": boolean;
            set(property:"uppercase", value: boolean): void;
            get(property:"uppercase"): boolean;
            watch(property:"uppercase", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "value": string;
            set(property:"value", value: string): void;
            get(property:"value"): string;
            watch(property:"value", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: String, value: Object): any;
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: Object, value: Object): any;
            /**
             * Construct the UI for this widget, setting this.domNode.
             * Most widgets will mixin dijit._TemplatedMixin, which implements this method.
             *
             */
            buildRendering(): void;
            /**
             * Closes the drop down on this widget
             *
             * @param focus If true, refocuses the button widget
             */
            closeDropDown(focus: boolean): void;
            /**
             * Compare 2 values (as returned by get('value') for this widget).
             *
             * @param val1
             * @param val2
             */
            compare(val1: any, val2: any): number;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: Function): any;
            /**
             * Wrapper to setTimeout to avoid deferred functions executing
             * after the originating widget has been destroyed.
             * Returns an object handle with a remove method (that returns null) (replaces clearTimeout).
             *
             * @param fcn Function reference.
             * @param delay               OptionalDelay, defaults to 0.
             */
            defer(fcn: Function, delay: number): Object;
            /**
             * Destroy this widget, but not its descendants.  Descendants means widgets inside of
             * this.containerNode.   Will also destroy any resources (including widgets) registered via this.own().
             *
             * This method will also destroy internal widgets such as those created from a template,
             * assuming those widgets exist inside of this.domNode but outside of this.containerNode.
             *
             * For 2.0 it's planned that this method will also destroy descendant widgets, so apps should not
             * depend on the current ability to destroy a widget without destroying its descendants.   Generally
             * they should use destroyRecursive() for widgets with children.
             *
             * @param preserveDom If true, this method will leave the original DOM structure alone.Note: This will not yet work with _TemplatedMixin widgets
             */
            destroy(preserveDom?: boolean): void;
            /**
             * Recursively destroy the children of this widget and their
             * descendants.
             *
             * @param preserveDom               OptionalIf true, the preserveDom attribute is passed to all descendantwidget's .destroy() method. Not for use with _Templatedwidgets.
             */
            destroyDescendants(preserveDom: boolean): void;
            /**
             * Destroy this widget and its descendants
             * This is the generic "destructor" function that all widget users
             * should call to cleanly discard with a widget. Once a widget is
             * destroyed, it is removed from the manager object.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structurealone of descendant Widgets. Note: This will NOT work withdijit._TemplatedMixin widgets.
             */
            destroyRecursive(preserveDom: boolean): void;
            /**
             * Destroys the DOM nodes associated with this widget.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structure aloneduring tear-down. Note: this will not work with _Templatedwidgets yet.
             */
            destroyRendering(preserveDom?: boolean): void;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Disconnects handle created by connect.
             *
             * @param handle
             */
            disconnect(handle: any): void;
            /**
             * Overridable method to display validation errors/hints.
             * By default uses a tooltip.
             *
             * @param message
             */
            displayMessage(message: String): void;
            /**
             * Highlights the string entered by the user in the menu.  By default this
             * highlights the first occurrence found. Override this method
             * to implement your custom highlighting.
             *
             * @param label
             * @param find
             */
            doHighlight(label: String, find: String): any;
            /**
             * Dropdown widget class used to select a date/time.
             * Subclasses should specify this.
             *
             */
            dropDownClass(): void;
            /**
             * Used by widgets to signal that a synthetic event occurred, ex:
             *
             * myWidget.emit("attrmodified-selectedChildWidget", {}).
             * Emits an event on this.domNode named type.toLowerCase(), based on eventObj.
             * Also calls onType() method, if present, and returns value from that method.
             * By default passes eventObj to callback, but will pass callbackArgs instead, if specified.
             * Modifies eventObj by adding missing parameters (bubbles, cancelable, widget).
             *
             * @param type
             * @param eventObj               Optional
             * @param callbackArgs               Optional
             */
            emit(type: String, eventObj: Object, callbackArgs: any[]): any;
            /**
             * Auto-corrections (such as trimming) that are applied to textbox
             * value on blur or form submit.
             * For MappedTextBox subclasses, this is called twice
             *
             * once with the display value
             * once the value as set/returned by set('value', ...)
             * and get('value'), ex: a Number for NumberTextBox.
             *
             * In the latter case it does corrections like converting null to NaN.  In
             * the former case the NumberTextBox.filter() method calls this.inherited()
             * to execute standard trimming code in TextBox.filter().
             *
             * TODO: break this into two methods in 2.0
             *
             * @param val
             */
            filter(val: any): any;
            /**
             * Put focus on this widget
             *
             */
            focus(): void;
            /**
             * Replaceable function to convert a value to a properly formatted string.
             *
             * @param value
             * @param constraints
             */
            format(value: String, constraints: Object): String;
            /**
             * Get a property from a widget.
             * Get a named property from a widget. The property may
             * potentially be retrieved via a getter method. If no getter is defined, this
             * just retrieves the object's property.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _getFooAttr(), calling:
             * myWidget.get("foo") would be equivalent to calling
             * widget._getFooAttr() and myWidget.get("bar")
             * would be equivalent to the expression
             * widget.bar2
             *
             * @param name The property to get.
             */
            get(name: any): any;
            /**
             * Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent
             * is this widget.   Note that it does not return all descendants, but rather just direct children.
             * Analogous to Node.childNodes,
             * except containing widgets rather than DOMNodes.
             *
             * The result intentionally excludes internally created widgets (a.k.a. supporting widgets)
             * outside of this.containerNode.
             *
             * Note that the array returned is a simple array.  Application code should not assume
             * existence of methods like forEach().
             *
             */
            getChildren(): any[];
            /**
             * Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
             * This method should generally be avoided as it returns widgets declared in templates, which are
             * supposed to be internal/hidden, but it's left here for back-compat reasons.
             *
             */
            getDescendants(): any[];
            /**
             * Deprecated.  Use get('displayedValue') instead.
             *
             */
            getDisplayedValue(): any;
            /**
             * Return an error message to show if appropriate
             *
             * @param isFocused
             */
            getErrorMessage(isFocused: boolean): any;
            /**
             * Returns the parent widget of this widget.
             *
             */
            getParent(): any;
            /**
             * Return a hint message to show when widget is first focused
             *
             * @param isFocused
             */
            getPromptMessage(isFocused: boolean): any;
            /**
             * Deprecated.  Use get('value') instead.
             *
             */
            getValue(): any;
            /**
             * Return true if this widget can currently be focused
             * and false if not
             *
             */
            isFocusable(): any;
            /**
             * Return this widget's explicit or implicit orientation (true for LTR, false for RTL)
             *
             */
            isLeftToRight(): any;
            /**
             * Returns true if the dropdown exists and it's data is loaded.  This can
             * be overridden in order to force a call to loadDropDown().
             *
             */
            isLoaded(): boolean;
            /**
             * Tests if value is valid.
             * Can override with your own routine in a subclass.
             *
             * @param isFocused
             */
            isValid: {(isFocused: boolean): any};
            /**
             * Creates the drop down if it doesn't exist, loads the data
             * if there's an href and it hasn't been loaded yet, and
             * then opens the drop down.  This is basically a callback when the
             * user presses the down arrow button to open the drop down.
             *
             */
            loadAndOpenDropDown(): any;
            /**
             * Creates the drop down if it doesn't exist, loads the data
             * if there's an href and it hasn't been loaded yet, and then calls
             * the given callback.
             *
             * @param loadCallback
             */
            loadDropDown(loadCallback: Function): void;
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: String, func: Function): any;
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: Function, func: Function): any;
            /**
             * Opens the dropdown for this widget.   To be called only when this.dropDown
             * has been created and is ready to display (ie, it's data is loaded).
             *
             */
            openDropDown(): any;
            /**
             * Track specified handles and remove/destroy them when this instance is destroyed, unless they were
             * already removed/destroyed manually.
             *
             */
            own(): any;
            /**
             * Replaceable function to convert a formatted string to a value
             *
             * @param value
             * @param constraints
             */
            parse(value: String, constraints: Object): String;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: number): any;
            /**
             *
             */
            postCreate(): void;
            /**
             *
             */
            postMixInProperties(): void;
            /**
             * Deprecated.  Use set('pattern', Function) instead.
             *
             * @param constraints An object with the following properties:locale (String): locale used for validation, picks up value from this widget's lang attribute_flags_ (anything): various flags passed to pattern function
             */
            regExpGen(constraints: Object): void;
            /**
             *
             */
            reset(): void;
            /**
             * Set a property on a widget
             * Sets named properties on a widget which may potentially be handled by a
             * setter in the widget.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _setFooAttr(), calling
             * myWidget.set("foo", "Howdy!") would be equivalent to calling
             * widget._setFooAttr("Howdy!") and myWidget.set("bar", 3)
             * would be equivalent to the statement widget.bar = 3;
             *
             * set() may also be called with a hash of name/value pairs, ex:
             *
             * myWidget.set({
             *     foo: "Howdy",
             *     bar: 3
             * });
             * This is equivalent to calling set(foo, "Howdy") and set(bar, 3)
             *
             * @param name The property to set.
             * @param value The value to set in the property.
             */
            set(name: any, value: any): any;
            /**
             * Deprecated.  Use set() instead.
             *
             * @param attr
             * @param value
             */
            setAttribute(attr: String, value: any): void;
            /**
             * Deprecated.  Use set('disabled', ...) instead.
             *
             * @param disabled
             */
            setDisabled(disabled: boolean): void;
            /**
             * Deprecated.  Use set('displayedValue', ...) instead.
             *
             * @param value
             */
            setDisplayedValue(value: String): void;
            /**
             * Deprecated.  Use set('value', ...) instead.
             *
             * @param value
             */
            setValue(value: String): void;
            /**
             *
             */
            startup(): void;
            /**
             * Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.
             *
             * Subscribes to the specified topic and calls the specified method
             * of this object and registers for unsubscribe() on widget destroy.
             *
             * Provide widget-specific analog to dojo.subscribe, except with the
             * implicit use of this widget as the target object.
             *
             * @param t The topic
             * @param method The callback
             */
            subscribe(t: String, method: Function): any;
            /**
             * Callback when the user presses the down arrow button or presses
             * the down arrow key to open/close the drop down.
             * Toggle the drop-down widget; if it is up, close it, if not, open it
             *
             */
            toggleDropDown(): void;
            /**
             * Returns a string that represents the widget.
             * When a widget is cast to a string, this method will be used to generate the
             * output. Currently, it does not implement any sort of reversible
             * serialization.
             *
             */
            toString(): string;
            /**
             * Restore the value to the last value passed to onChange
             *
             */
            undo(): void;
            /**
             * Deprecated. Override destroy() instead to implement custom widget tear-down
             * behavior.
             *
             */
            uninitialize(): boolean;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Unsubscribes handle created by this.subscribe.
             * Also removes handle from this widget's list of subscriptions
             *
             * @param handle
             */
            unsubscribe(handle: Object): void;
            /**
             * Called by oninit, onblur, and onkeypress.
             * Show missing or invalid messages if appropriate, and highlight textbox field.
             *
             * @param isFocused
             */
            validate(isFocused: boolean): any;
            /**
             * Overridable function used to validate the text input against the regular expression.
             *
             * @param value
             * @param constraints An object with the following properties:locale (String): locale used for validation, picks up value from this widget's lang attribute_flags_ (anything): various flags passed to pattern function
             */
            validator(value: any, constraints: Object): any;
            /**
             * Watches a property for changes
             *
             * @param name               OptionalIndicates the property to watch. This is optional (the callback may be theonly parameter), and if omitted, all the properties will be watched
             * @param callback The function to execute when the property changes. This will be called afterthe property has been changed. The callback will be called with the |this|set to the instance, the first argument as the name of the property, thesecond argument as the old value and the third argument as the new value.
             */
            watch(property: string, callback:{(property?:string, oldValue?:any, newValue?: any):void}) :{unwatch():void};
            /**
             * Static method to get a template based on the templatePath or
             * templateString key
             */
            getCachedTemplate(): any;
            /**
             * Called when the widget stops being "active" because
             * focus moved to something outside of it, or the user
             * clicked somewhere outside of it, or the widget was
             * hidden.
             *
             */
            onBlur(): void;
            /**
             * Callback when this widget's value is changed.
             *
             * @param newValue
             */
            onChange(newValue: any): void;
            /**
             * Connect to this function to receive notifications of mouse click events.
             *
             * @param event mouse Event
             */
            onClick(event: any): void;
            /**
             * Called when this widget is being displayed as a popup (ex: a Calendar popped
             * up from a DateTextBox), and it is hidden.
             * This is called from the dijit.popup code, and should not be called directly.
             *
             * Also used as a parameter for children of dijit/layout/StackContainer or subclasses.
             * Callback if a user tries to close the child.   Child will be closed if this function returns true.
             *
             */
            onClose(): boolean;
            /**
             * Connect to this function to receive notifications of mouse double click events.
             *
             * @param event mouse Event
             */
            onDblClick(event: any): void;
            /**
             * Called when the widget becomes "active" because
             * it or a widget inside of it either has focus, or has recently
             * been clicked.
             *
             */
            onFocus(): void;
            /**
             * Called when another widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate hide of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onHide(): void;
            /**
             * Connect to this function to receive notifications of various user data-input events.
             * Return false to cancel the event and prevent it from being processed.
             *
             * @param event keydown | keypress | cut | paste | input
             */
            onInput(event: any): void;
            /**
             * Connect to this function to receive notifications of keys being pressed down.
             *
             * @param event key Event
             */
            onKeyDown(event: any): void;
            /**
             * Connect to this function to receive notifications of printable keys being typed.
             *
             * @param event key Event
             */
            onKeyPress(event: any): void;
            /**
             * Connect to this function to receive notifications of keys being released.
             *
             * @param event key Event
             */
            onKeyUp(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is pressed down.
             *
             * @param event mouse Event
             */
            onMouseDown(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto this widget.
             *
             * @param event mouse Event
             */
            onMouseEnter(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of this widget.
             *
             * @param event mouse Event
             */
            onMouseLeave(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseMove(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOut(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOver(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is released.
             *
             * @param event mouse Event
             */
            onMouseUp(event: any): void;
            /**
             * Callback when a search completes.
             *
             * @param results An array of items from the originating _SearchMixin's store.
             * @param query A copy of the originating _SearchMixin's query property.
             * @param options The additional parameters sent to the originating _SearchMixin's store, including: start, count, queryOptions.
             */
            onSearch(results: Object, query: Object, options: Object): void;
            /**
             * Called when this widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate display of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onShow(): void;
        }
        /**
         * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/Uploader.html
         *
         * A widget that creates a stylable file-input button, with optional multi-file selection,
         * using only HTML elements. Non-HTML5 browsers have fallback options of Flash or an iframe.
         * A bare-bones, stylable file-input button, with optional multi-file selection. The list
         * of files is not displayed, that is for you to handle by connecting to the onChange
         * event, or use the dojox.form.uploader.FileList.
         *
         * Uploader without plugins does not have any ability to upload - it is for use in forms
         * where you handle the upload either by a standard POST or with Ajax using an iFrame. This
         * class is for convenience of multiple files only. No progress events are available.
         *
         * If the browser supports a file-input with the "multiple" attribute, that will be used.
         * If the browser does not support "multiple" (ergo, IE) multiple inputs are used,
         * one for each selection.
         *
         * Version: 1.6
         *
         * @param params Hash of initialization parameters for widget, including scalar values (like title, duration etc.)and functions, typically callbacks like onClick.The hash can contain any of the widget's properties, excluding read-only properties.
         * @param srcNodeRef       OptionalIf a srcNodeRef (DOM node) is specified:use srcNodeRef.innerHTML as my contentsif this is a behavioral widget then apply behavior to that srcNodeRefotherwise, replace srcNodeRef with my generated DOM tree
         */
        class Uploader extends dojox.form.uploader._Base implements dijit.form.Button, dojox.form.uploader._HTML5, dojox.form.uploader._IFrame, dojox.form.uploader._Flash {
            constructor(params?: Object, srcNodeRef?: HTMLElement);
            /**
             * True if mouse was pressed while over this widget, and hasn't been released yet
             *
             */
            "active": boolean;
            set(property:"active", value: boolean): void;
            get(property:"active"): boolean;
            watch(property:"active", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "alt": string;
            set(property:"alt", value: string): void;
            get(property:"alt"): string;
            watch(property:"alt", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "aria-label": string;
            set(property:"aria-label", value: string): void;
            get(property:"aria-label"): string;
            watch(property:"aria-label", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Object to which attach points and events will be scoped.  Defaults
             * to 'this'.
             *
             */
            "attachScope": Object;
            set(property:"attachScope", value: Object): void;
            get(property:"attachScope"): Object;
            watch(property:"attachScope", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute
             * for each XXX attribute to be mapped to the DOM.
             *
             * attributeMap sets up a "binding" between attributes (aka properties)
             * of the widget and the widget's DOM.
             * Changes to widget attributes listed in attributeMap will be
             * reflected into the DOM.
             *
             * For example, calling set('title', 'hello')
             * on a TitlePane will automatically cause the TitlePane's DOM to update
             * with the new title.
             *
             * attributeMap is a hash where the key is an attribute of the widget,
             * and the value reflects a binding to a:
             *
             * DOM node attribute
             *   focus: {node: "focusNode", type: "attribute"}
             * Maps this.focus to this.focusNode.focus
             *
             * DOM node innerHTML
             *   title: { node: "titleNode", type: "innerHTML" }
             * Maps this.title to this.titleNode.innerHTML
             *
             * DOM node innerText
             *   title: { node: "titleNode", type: "innerText" }
             * Maps this.title to this.titleNode.innerText
             *
             * DOM node CSS class
             *   myClass: { node: "domNode", type: "class" }
             * Maps this.myClass to this.domNode.className
             *
             * If the value is an array, then each element in the array matches one of the
             * formats of the above list.
             *
             * There are also some shorthands for backwards compatibility:
             *
             * string --> { node: string, type: "attribute" }, for example:
             * "focusNode" ---> { node: "focusNode", type: "attribute" }
             * "" --> { node: "domNode", type: "attribute" }
             *
             */
            "attributeMap": Object;
            set(property:"attributeMap", value: Object): void;
            get(property:"attributeMap"): Object;
            watch(property:"attributeMap", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             *
             */
            "baseClass": string;
            set(property:"baseClass", value: string): void;
            get(property:"baseClass"): string;
            watch(property:"baseClass", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "class": string;
            set(property:"class", value: string): void;
            get(property:"class"): string;
            watch(property:"class", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Designates where children of the source DOM node will be placed.
             * "Children" in this case refers to both DOM nodes and widgets.
             * For example, for myWidget:
             *
             * <div data-dojo-type=myWidget>
             *     <b> here's a plain DOM node
             *     <span data-dojo-type=subWidget>and a widget</span>
             *     <i> and another plain DOM node </i>
             * </div>
             * containerNode would point to:
             *
             * <b> here's a plain DOM node
             * <span data-dojo-type=subWidget>and a widget</span>
             * <i> and another plain DOM node </i>
             * In templated widgets, "containerNode" is set via a
             * data-dojo-attach-point assignment.
             *
             * containerNode must be defined for any widget that accepts innerHTML
             * (like ContentPane or BorderContainer or even Button), and conversely
             * is null for widgets that don't, like TextBox.
             *
             */
            "containerNode": HTMLElement;
            set(property:"containerNode", value: HTMLElement): void;
            get(property:"containerNode"): HTMLElement;
            watch(property:"containerNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * Used to provide a context require to the dojo/parser in order to be
             * able to use relative MIDs (e.g. ./Widget) in the widget's template.
             *
             */
            "contextRequire": Function;
            set(property:"contextRequire", value: Function): void;
            get(property:"contextRequire"): Function;
            watch(property:"contextRequire", callback:{(property?:string, oldValue?:Function, newValue?: Function):void}) :{unwatch():void}
            /**
             * Subclasses may define a cssStateNodes property that lists sub-nodes within the widget that
             * need CSS classes applied on mouse hover/press and focus.
             *
             * Each entry in this optional hash is a an attach-point name (like "upArrowButton") mapped to a CSS class name
             * (like "dijitUpArrowButton"). Example:
             *
             * {
             *     "upArrowButton": "dijitUpArrowButton",
             *     "downArrowButton": "dijitDownArrowButton"
             * }
             * The above will set the CSS class dijitUpArrowButton to the this.upArrowButton DOMNode when it
             *
             * is hovered, etc.
             *
             */
            "cssStateNodes": Object;
            set(property:"cssStateNodes", value: Object): void;
            get(property:"cssStateNodes"): Object;
            watch(property:"cssStateNodes", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * (Flash only) throttles the upload to a certain amount of files at a time.
             * By default, Flash uploads file one at a time to the server, but in parallel.
             * Firefox will try to queue all files at once, leading to problems. Set this
             * to the amount to upload in parallel at a time.
             * Generally, 1 should work fine, but you can experiment with queuing more than
             * one at a time.
             * This is of course ignored if selectMultipleFiles equals false.
             *
             */
            "deferredUploading": number;
            set(property:"deferredUploading", value: number): void;
            get(property:"deferredUploading"): number;
            watch(property:"deferredUploading", callback:{(property?:string, oldValue?:number, newValue?: number):void}) :{unwatch():void}
            /**
             * Re-implemented. devMode increases the logging, adding style tracing from the SWF.
             *
             */
            "devMode": Object;
            set(property:"devMode", value: Object): void;
            get(property:"devMode"): Object;
            watch(property:"devMode", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Bi-directional support, as defined by the HTML DIR
             * attribute. Either left-to-right "ltr" or right-to-left "rtl".  If undefined, widgets renders in page's
             * default direction.
             *
             */
            "dir": string;
            set(property:"dir", value: string): void;
            get(property:"dir"): string;
            watch(property:"dir", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Should this widget respond to user input?
             * In markup, this is specified as "disabled='disabled'", or just "disabled".
             *
             */
            "disabled": boolean;
            set(property:"disabled", value: boolean): void;
            get(property:"disabled"): boolean;
            watch(property:"disabled", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * This is our visible representation of the widget! Other DOM
             * Nodes may by assigned to other properties, usually through the
             * template system's data-dojo-attach-point syntax, but the domNode
             * property is the canonical "top level" node in widget UI.
             *
             */
            "domNode": HTMLElement;
            set(property:"domNode", value: HTMLElement): void;
            get(property:"domNode"): HTMLElement;
            watch(property:"domNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             *
             */
            "errMsg": string;
            set(property:"errMsg", value: string): void;
            get(property:"errMsg"): string;
            watch(property:"errMsg", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * If set, this will be the name of the field of the flash uploaded files that the server
             * is expecting. If not set, "Flash" is appended to the "name" property.
             *
             */
            "flashFieldName": string;
            set(property:"flashFieldName", value: string): void;
            get(property:"flashFieldName"): string;
            watch(property:"flashFieldName", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * This widget or a widget it contains has focus, or is "active" because
             * it was recently clicked.
             *
             */
            "focused": boolean;
            set(property:"focused", value: boolean): void;
            get(property:"focused"): boolean;
            watch(property:"focused", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * The class applied to the button when it is focused (via TAB key)
             *
             */
            "focusedClass": string;
            set(property:"focusedClass", value: string): void;
            get(property:"focusedClass"): string;
            watch(property:"focusedClass", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * options: form, html5, iframe, flash
             * Empty string defaults to html5 if available, and iframe if not.
             * Use "flash" to always use Flash (and hopefully force the user to download the plugin
             * if they don't have it).
             * Use "iframe" to always use an iframe, and never flash nor html5. Sometimes preferred
             * for consistent results.
             * Use "form" to not use ajax and post to a page.
             *
             */
            "force": string;
            set(property:"force", value: string): void;
            get(property:"force"): string;
            watch(property:"force", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * True if cursor is over this widget
             *
             */
            "hovering": boolean;
            set(property:"hovering", value: boolean): void;
            get(property:"hovering"): boolean;
            watch(property:"hovering", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Class to apply to DOMNode in button to make it display an icon
             *
             */
            "iconClass": string;
            set(property:"iconClass", value: string): void;
            get(property:"iconClass"): string;
            watch(property:"iconClass", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * A unique, opaque ID string that can be assigned by users or by the
             * system. If the developer passes an ID which is known not to be
             * unique, the specified ID is ignored and the system-generated ID is
             * used instead.
             *
             */
            "id": string;
            set(property:"id", value: string): void;
            get(property:"id"): string;
            watch(property:"id", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Fires onChange for each value change or only on demand
             *
             */
            "intermediateChanges": boolean;
            set(property:"intermediateChanges", value: boolean): void;
            get(property:"intermediateChanges"): boolean;
            watch(property:"intermediateChanges", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * If true, outputs traces from the SWF to console. What exactly gets passed
             * is very relative, and depends upon what traces have been left in the DEFT SWF.
             *
             */
            "isDebug": boolean;
            set(property:"isDebug", value: boolean): void;
            get(property:"isDebug"): boolean;
            watch(property:"isDebug", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * The text used in the button that when clicked, opens a system Browse Dialog.
             *
             */
            "label": string;
            set(property:"label", value: string): void;
            get(property:"label"): string;
            watch(property:"label", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Rarely used.  Overrides the default Dojo locale used to render this widget,
             * as defined by the HTML LANG attribute.
             * Value must be among the list of locales specified during by the Dojo bootstrap,
             * formatted according to RFC 3066 (like en-us).
             *
             */
            "lang": string;
            set(property:"lang", value: string): void;
            get(property:"lang"): string;
            watch(property:"lang", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * If true and flash mode, multiple files may be selected from the dialog.
             *
             */
            "multiple": boolean;
            set(property:"multiple", value: boolean): void;
            get(property:"multiple"): boolean;
            watch(property:"multiple", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * The name attribute needs to end with square brackets: [] as this is the standard way
             * of handling an attribute "array". This requires a slightly different technique on the
             * server.
             *
             */
            "name": string;
            set(property:"name", value: string): void;
            get(property:"name"): string;
            watch(property:"name", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "observer": string;
            set(property:"observer", value: string): void;
            get(property:"observer"): string;
            watch(property:"observer", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * The document this widget belongs to.  If not specified to constructor, will default to
             * srcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global
             *
             */
            "ownerDocument": Object;
            set(property:"ownerDocument", value: Object): void;
            get(property:"ownerDocument"): Object;
            watch(property:"ownerDocument", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * If true, then flash request is sent with a value that changes with each request (timestamp)
             *
             */
            "preventCache": boolean;
            set(property:"preventCache", value: boolean): void;
            get(property:"preventCache"): boolean;
            watch(property:"preventCache", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * On focus, should this widget scroll into view?
             *
             */
            "scrollOnFocus": boolean;
            set(property:"scrollOnFocus", value: boolean): void;
            get(property:"scrollOnFocus"): boolean;
            watch(property:"scrollOnFocus", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             *
             */
            "searchContainerNode": boolean;
            set(property:"searchContainerNode", value: boolean): void;
            get(property:"searchContainerNode"): boolean;
            watch(property:"searchContainerNode", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * The amount of time given to the uploaded file
             * to wait for a server response. After this amount
             * of time, the onComplete is fired but with a 'server timeout'
             * error in the returned item.
             *
             */
            "serverTimeout": number;
            set(property:"serverTimeout", value: number): void;
            get(property:"serverTimeout"): number;
            watch(property:"serverTimeout", callback:{(property?:string, oldValue?:number, newValue?: number):void}) :{unwatch():void}
            /**
             * Position to show an input which shows selected filename(s). Possible
             * values are "before", "after", which specifies where the input should
             * be placed with reference to the containerNode which contains the
             * label). By default, this is empty string (no such input will be
             * shown). Specify showInput="before" to mimic the look&feel of a
             * native file input element.
             *
             */
            "showInput": string;
            set(property:"showInput", value: string): void;
            get(property:"showInput"): string;
            watch(property:"showInput", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Set this to true to hide the label text and display only the icon.
             * (If showLabel=false then iconClass must be specified.)
             * Especially useful for toolbars.
             * If showLabel=true, the label will become the title (a.k.a. tooltip/hint) of the icon.
             *
             * The exception case is for computers in high-contrast mode, where the label
             * will still be displayed, since the icon doesn't appear.
             *
             */
            "showLabel": boolean;
            set(property:"showLabel", value: boolean): void;
            get(property:"showLabel"): boolean;
            watch(property:"showLabel", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * If true, will not verify that the server was sent the correct format.
             * This can be safely set to true. The purpose of the server side check
             * is mainly to show the dev if they've implemented the different returns
             * correctly.
             *
             */
            "skipServerCheck": boolean;
            set(property:"skipServerCheck", value: boolean): void;
            get(property:"skipServerCheck"): boolean;
            watch(property:"skipServerCheck", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * pointer to original DOM node
             *
             */
            "srcNodeRef": HTMLElement;
            set(property:"srcNodeRef", value: HTMLElement): void;
            get(property:"srcNodeRef"): HTMLElement;
            watch(property:"srcNodeRef", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * HTML style attributes as cssText string or name/value hash
             *
             */
            "style": string;
            set(property:"style", value: string): void;
            get(property:"style"): string;
            watch(property:"style", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Path to SWF. Can be overwritten or provided in djConfig.
             *
             */
            "swfPath": string;
            set(property:"swfPath", value: string): void;
            get(property:"swfPath"): string;
            watch(property:"swfPath", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * The tab order in the DOM.
             *
             */
            "tabIndex": string;
            set(property: "tabIndex", value: string): void;
            get(property: "tabIndex"): string;
            watch(property: "tabIndex", callback: { (property?: string, oldValue?: string, newValue?: string):void}) :{unwatch():void}
            /**
             * Path to template (HTML file) for this widget relative to dojo.baseUrl.
             * Deprecated: use templateString with require([... "dojo/text!..."], ...) instead
             *
             */
            "templatePath": string;
            set(property:"templatePath", value: string): void;
            get(property:"templatePath"): string;
            watch(property:"templatePath", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "templateString": string;
            set(property:"templateString", value: string): void;
            get(property:"templateString"): string;
            watch(property:"templateString", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * HTML title attribute.
             *
             * For form widgets this specifies a tooltip to display when hovering over
             * the widget (just like the native HTML title attribute).
             *
             * For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,
             * etc., it's used to specify the tab label, accordion pane title, etc.  In this case it's
             * interpreted as HTML.
             *
             */
            "title": string;
            set(property:"title", value: string): void;
            get(property:"title"): string;
            watch(property:"title", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * When this widget's title attribute is used to for a tab label, accordion pane title, etc.,
             * this specifies the tooltip to appear when the mouse is hovered over that text.
             *
             */
            "tooltip": string;
            set(property:"tooltip", value: string): void;
            get(property:"tooltip"): string;
            watch(property:"tooltip", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "type": string;
            set(property:"type", value: string): void;
            get(property:"type"): string;
            watch(property:"type", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * If true, uploads immediately after a file has been selected. If false,
             * waits for upload() to be called.
             *
             */
            "uploadOnSelect": boolean;
            set(property:"uploadOnSelect", value: boolean): void;
            get(property:"uploadOnSelect"): boolean;
            watch(property:"uploadOnSelect", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * The type of uploader being used. As an alternative to determining the upload type on the
             * server based on the fieldName, this property could be sent to the server to help
             * determine what type of parsing should be used.
             * This is set based on the force property and what features are available in the browser.
             *
             */
            "uploadType": string;
            set(property:"uploadType", value: string): void;
            get(property:"uploadType"): string;
            watch(property:"uploadType", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * The url targeted for upload. An absolute URL is preferred. Relative URLs are
             * changed to absolute.
             *
             */
            "url": string;
            set(property:"url", value: string): void;
            get(property:"url"): string;
            watch(property:"url", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "value": string;
            set(property:"value", value: string): void;
            get(property:"value"): string;
            watch(property:"value", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Should we parse the template to find widgets that might be
             * declared in markup inside it?  (Remove for 2.0 and assume true)
             *
             */
            "widgetsInTemplate": boolean;
            set(property:"widgetsInTemplate", value: boolean): void;
            get(property:"widgetsInTemplate"): boolean;
            watch(property:"widgetsInTemplate", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Add a dom node which will act as the drop target area so user
             * can drop files to this node.
             * If onlyConnectDrop is true, dragenter/dragover/dragleave events
             * won't be connected to dojo.stopEvent, and they need to be
             * canceled by user code to allow DnD files to happen.
             * This API is only available in HTML5 plugin (only HTML5 allows
             * DnD files).
             *
             * @param node
             * @param onlyConnectDrop               Optional
             */
            addDropTarget(node: any, onlyConnectDrop: boolean): void;
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: String, value: Object): any;
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: Object, value: Object): any;
            /**
             *
             */
            buildRendering(): void;
            /**
             * Compare 2 values (as returned by get('value') for this widget).
             *
             * @param val1
             * @param val2
             */
            compare(val1: any, val2: any): number;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: Function): any;
            /**
             * Internal. Connects to form if there is one.
             *
             */
            connectForm(): void;
            /**
             * Converts bytes. Returns an object with all conversions. The "value" property is
             * considered the most likely desired result.
             *
             * @param bytes
             */
            convertBytes(bytes: any): Object;
            /**
             *
             */
            create(): void;
            /**
             *
             */
            createXhr(): any;
            /**
             * Wrapper to setTimeout to avoid deferred functions executing
             * after the originating widget has been destroyed.
             * Returns an object handle with a remove method (that returns null) (replaces clearTimeout).
             *
             * @param fcn Function reference.
             * @param delay               OptionalDelay, defaults to 0.
             */
            defer(fcn: Function, delay: number): Object;
            /**
             * Destroy this widget, but not its descendants.  Descendants means widgets inside of
             * this.containerNode.   Will also destroy any resources (including widgets) registered via this.own().
             *
             * This method will also destroy internal widgets such as those created from a template,
             * assuming those widgets exist inside of this.domNode but outside of this.containerNode.
             *
             * For 2.0 it's planned that this method will also destroy descendant widgets, so apps should not
             * depend on the current ability to destroy a widget without destroying its descendants.   Generally
             * they should use destroyRecursive() for widgets with children.
             *
             * @param preserveDom If true, this method will leave the original DOM structure alone.Note: This will not yet work with _TemplatedMixin widgets
             */
            destroy(preserveDom?: boolean): void;
            /**
             * Recursively destroy the children of this widget and their
             * descendants.
             *
             * @param preserveDom               OptionalIf true, the preserveDom attribute is passed to all descendantwidget's .destroy() method. Not for use with _Templatedwidgets.
             */
            destroyDescendants(preserveDom: boolean): void;
            /**
             * Destroy this widget and its descendants
             * This is the generic "destructor" function that all widget users
             * should call to cleanly discard with a widget. Once a widget is
             * destroyed, it is removed from the manager object.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structurealone of descendant Widgets. Note: This will NOT work withdijit._TemplatedMixin widgets.
             */
            destroyRecursive(preserveDom: boolean): void;
            /**
             * Destroys the DOM nodes associated with this widget.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structure aloneduring tear-down. Note: this will not work with _Templatedwidgets yet.
             */
            destroyRendering(preserveDom?: boolean): void;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Disconnects handle created by connect.
             *
             * @param handle
             */
            disconnect(handle: any): void;
            /**
             * Used by widgets to signal that a synthetic event occurred, ex:
             *
             * myWidget.emit("attrmodified-selectedChildWidget", {}).
             * Emits an event on this.domNode named type.toLowerCase(), based on eventObj.
             * Also calls onType() method, if present, and returns value from that method.
             * By default passes eventObj to callback, but will pass callbackArgs instead, if specified.
             * Modifies eventObj by adding missing parameters (bubbles, cancelable, widget).
             *
             * @param type
             * @param eventObj               Optional
             * @param callbackArgs               Optional
             */
            emit(type: String, eventObj: Object, callbackArgs: any[]): any;
            /**
             *
             */
            flashReset(): void;
            /**
             * Put focus on this widget
             *
             */
            focus(): void;
            /**
             * Get a property from a widget.
             * Get a named property from a widget. The property may
             * potentially be retrieved via a getter method. If no getter is defined, this
             * just retrieves the object's property.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _getFooAttr(), calling:
             * myWidget.get("foo") would be equivalent to calling
             * widget._getFooAttr() and myWidget.get("bar")
             * would be equivalent to the expression
             * widget.bar2
             *
             * @param name The property to get.
             */
            get(name: any): any;
            /**
             * Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent
             * is this widget.   Note that it does not return all descendants, but rather just direct children.
             * Analogous to Node.childNodes,
             * except containing widgets rather than DOMNodes.
             *
             * The result intentionally excludes internally created widgets (a.k.a. supporting widgets)
             * outside of this.containerNode.
             *
             * Note that the array returned is a simple array.  Application code should not assume
             * existence of methods like forEach().
             *
             */
            getChildren(): any[];
            /**
             * Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
             * This method should generally be avoided as it returns widgets declared in templates, which are
             * supposed to be internal/hidden, but it's left here for back-compat reasons.
             *
             */
            getDescendants(): any[];
            /**
             * Returns a list of selected files.
             *
             */
            getFileList(): any[];
            /**
             * Gets the extension of a file
             *
             * @param name
             */
            getFileType(name: String): any;
            /**
             * Returns list of currently selected files
             *
             */
            getFlashFileList(): any;
            /**
             * Finds the parent form of the Uploader, if it exists.
             *
             */
            getForm(): HTMLElement;
            /**
             * Returns the mime type that should be used in an HTML5 upload form. Return result
             * may change as the current use is very generic.
             *
             */
            getMimeType(): String;
            /**
             * Returns the parent widget of this widget.
             *
             */
            getParent(): any;
            /**
             * Finds the URL to upload to, whether it be the action in the parent form, this.url or
             * this.uploadUrl
             *
             */
            getUrl(): any;
            /**
             * Deprecated.  Use get('value') instead.
             *
             */
            getValue(): any;
            /**
             * Return true if this widget can currently be focused
             * and false if not
             *
             */
            isFocusable(): any;
            /**
             * Return this widget's explicit or implicit orientation (true for LTR, false for RTL)
             *
             */
            isLeftToRight(): any;
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: String, func: Function): any;
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: Function, func: Function): any;
            /**
             * Track specified handles and remove/destroy them when this instance is destroyed, unless they were
             * already removed/destroyed manually.
             *
             */
            own(): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: number): any;
            /**
             *
             */
            postCreate(): void;
            /**
             *
             */
            postMixInProperties(): void;
            /**
             * Resets entire input, clearing all files.
             * NOTE:
             * Removing individual files is not yet supported, because the HTML5 uploaders can't
             * be edited.
             * TODO:
             * Add this ability by effectively, not uploading them
             *
             */
            reset(): void;
            /**
             * Set a property on a widget
             * Sets named properties on a widget which may potentially be handled by a
             * setter in the widget.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _setFooAttr(), calling
             * myWidget.set("foo", "Howdy!") would be equivalent to calling
             * widget._setFooAttr("Howdy!") and myWidget.set("bar", 3)
             * would be equivalent to the statement widget.bar = 3;
             *
             * set() may also be called with a hash of name/value pairs, ex:
             *
             * myWidget.set({
             *     foo: "Howdy",
             *     bar: 3
             * });
             * This is equivalent to calling set(foo, "Howdy") and set(bar, 3)
             *
             * @param name The property to set.
             * @param value The value to set in the property.
             */
            set(name: any, value: any): any;
            /**
             * Deprecated.  Use set() instead.
             *
             * @param attr
             * @param value
             */
            setAttribute(attr: String, value: any): void;
            /**
             * Deprecated.  Use set('disabled', ...) instead.
             *
             * @param disabled
             */
            setDisabled(disabled: boolean): void;
            /**
             * Deprecated.  Use set('label', ...) instead.
             *
             * @param content
             */
            setLabel(content: String): void;
            /**
             * Deprecated.  Use set('value', ...) instead.
             *
             * @param value
             */
            setValue(value: String): void;
            /**
             *
             */
            startup(): void;
            /**
             * If Uploader is in a form, and other data should be sent along with the files, use
             * this instead of form submit.
             *
             * @param form               Optional
             */
            submit(form: HTMLFormElement): void;
            /**
             * Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.
             *
             * Subscribes to the specified topic and calls the specified method
             * of this object and registers for unsubscribe() on widget destroy.
             *
             * Provide widget-specific analog to dojo.subscribe, except with the
             * implicit use of this widget as the target object.
             *
             * @param t The topic
             * @param method The callback
             */
            subscribe(t: String, method: Function): any;
            /**
             * Does feature testing for uploader capabilities. (No browser sniffing - yay)
             *
             * @param what
             */
            supports(what: any): any;
            /**
             * Returns a string that represents the widget.
             * When a widget is cast to a string, this method will be used to generate the
             * output. Currently, it does not implement any sort of reversible
             * serialization.
             *
             */
            toString(): string;
            /**
             * Deprecated. Override destroy() instead to implement custom widget tear-down
             * behavior.
             *
             */
            uninitialize(): boolean;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Unsubscribes handle created by this.subscribe.
             * Also removes handle from this widget's list of subscriptions
             *
             * @param handle
             */
            unsubscribe(handle: Object): void;
            /**
             * When called, begins file upload. Only supported with plugins.
             *
             * @param formData               Optional
             */
            upload(formData: Object): void;
            /**
             * Internal. You could use this, but you should use upload() or submit();
             * which can also handle the post data.
             *
             * @param data
             */
            uploadIFrame(data: any): void;
            /**
             * Watches a property for changes
             *
             * @param name               OptionalIndicates the property to watch. This is optional (the callback may be theonly parameter), and if omitted, all the properties will be watched
             * @param callback The function to execute when the property changes. This will be called afterthe property has been changed. The callback will be called with the |this|set to the instance, the first argument as the name of the property, thesecond argument as the old value and the third argument as the new value.
             */
            watch(property: string, callback:{(property?:string, oldValue?:any, newValue?: any):void}) :{unwatch():void};
            /**
             * Static method to get a template based on the templatePath or
             * templateString key
             */
            getCachedTemplate(): any;
            /**
             * Stub to connect
             * Fires when upload in progress was canceled
             *
             */
            onAbort(): void;
            /**
             * Fires when upload begins
             *
             * @param dataArray
             */
            onBegin(dataArray: any[]): void;
            /**
             * Called when the widget stops being "active" because
             * focus moved to something outside of it, or the user
             * clicked somewhere outside of it, or the widget was
             * hidden.
             *
             */
            onBlur(): void;
            /**
             * Stub to connect
             * Fires when dialog box has been closed
             * without a file selection
             *
             */
            onCancel(): void;
            /**
             * stub to connect
             * Fires when files are selected
             * Event is an array of last files selected
             *
             * @param fileArray
             */
            onChange(fileArray: any[]): void;
            /**
             * Connect to this function to receive notifications of mouse click events.
             *
             * @param event mouse Event
             */
            onClick(event: Event): boolean;
            /**
             * Called when this widget is being displayed as a popup (ex: a Calendar popped
             * up from a DateTextBox), and it is hidden.
             * This is called from the dijit.popup code, and should not be called directly.
             *
             * Also used as a parameter for children of dijit/layout/StackContainer or subclasses.
             * Callback if a user tries to close the child.   Child will be closed if this function returns true.
             *
             */
            onClose(): boolean;
            /**
             * stub to connect
             * Fires when all files have uploaded
             * Event is an array of all files
             *
             * @param customEvent
             */
            onComplete(customEvent: Object): void;
            /**
             * Connect to this function to receive notifications of mouse double click events.
             *
             * @param event mouse Event
             */
            onDblClick(event: any): void;
            /**
             * Fires on errors
             *
             * @param evtObject
             */
            onError(evtObject: Object): void;
            /**
             * Fires on errors
             *
             * @param evtObject
             */
            onError(evtObject: String): void;
            /**
             * Stub - Flash-specific event. Fires on each selection of files
             * and only provides the files selected on that event - not all files
             * selected, as with HTML5
             *
             * @param fileArray
             */
            onFileChange(fileArray: any): void;
            /**
             * Stub - Flash-specific event. Fires on progress of upload
             * and only provides a file-specific event
             *
             * @param fileArray
             */
            onFileProgress(fileArray: any): void;
            /**
             * Called when the widget becomes "active" because
             * it or a widget inside of it either has focus, or has recently
             * been clicked.
             *
             */
            onFocus(): void;
            /**
             * Called when another widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate hide of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onHide(): void;
            /**
             * Connect to this function to receive notifications of keys being pressed down.
             *
             * @param event key Event
             */
            onKeyDown(event: any): void;
            /**
             * Connect to this function to receive notifications of printable keys being typed.
             *
             * @param event key Event
             */
            onKeyPress(event: any): void;
            /**
             * Connect to this function to receive notifications of keys being released.
             *
             * @param event key Event
             */
            onKeyUp(event: any): void;
            /**
             * Stub - SWF has been downloaded 100%.
             *
             * @param uploader
             */
            onLoad(uploader: dojox.form.FileUploader): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is pressed down.
             *
             * @param event mouse Event
             */
            onMouseDown(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto this widget.
             *
             * @param event mouse Event
             */
            onMouseEnter(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of this widget.
             *
             * @param event mouse Event
             */
            onMouseLeave(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseMove(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOut(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOver(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is released.
             *
             * @param event mouse Event
             */
            onMouseUp(event: any): void;
            /**
             * Stub to connect
             * Fires on upload progress. Event is a normalized object of common properties
             * from HTML5 uploaders and the Flash uploader. Will not fire for IFrame.
             *
             * @param customEvent bytesLoaded: Number:  Amount of bytes uploaded so far of entire payload (all files)bytesTotal: Number:  Amount of bytes of entire payload (all files)type: String:  Type of event (progress or load)timeStamp: Number:  Timestamp of when event occurred
             */
            onProgress(customEvent: Object): void;
            /**
             * Stub - Fired when embedFlash has created the
             * Flash object, but it has not necessarilly finished
             * downloading, and is ready to be communicated with.
             *
             * @param uploader
             */
            onReady(uploader: dojox.form.FileUploader): void;
            /**
             * Called when this widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate display of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onShow(): void;
        }
        /**
         * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/YearTextBox.html
         *
         * A validating, serializable, range-bound date text box with a popup calendar that contains only years
         *
         * @param params Hash of initialization parameters for widget, including scalar values (like title, duration etc.)and functions, typically callbacks like onClick.The hash can contain any of the widget's properties, excluding read-only properties.
         * @param srcNodeRef       OptionalIf a srcNodeRef (DOM node) is specified, replace srcNodeRef with my generated DOM tree
         */
        class YearTextBox extends dojox.form.DateTextBox {
            constructor(params?: Object, srcNodeRef?: HTMLElement);
            /**
             * True if mouse was pressed while over this widget, and hasn't been released yet
             *
             */
            "active": boolean;
            set(property:"active", value: boolean): void;
            get(property:"active"): boolean;
            watch(property:"active", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "alt": string;
            set(property:"alt", value: string): void;
            get(property:"alt"): string;
            watch(property:"alt", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "aria-label": string;
            set(property:"aria-label", value: string): void;
            get(property:"aria-label"): string;
            watch(property:"aria-label", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Object to which attach points and events will be scoped.  Defaults
             * to 'this'.
             *
             */
            "attachScope": Object;
            set(property:"attachScope", value: Object): void;
            get(property:"attachScope"): Object;
            watch(property:"attachScope", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute
             * for each XXX attribute to be mapped to the DOM.
             *
             * attributeMap sets up a "binding" between attributes (aka properties)
             * of the widget and the widget's DOM.
             * Changes to widget attributes listed in attributeMap will be
             * reflected into the DOM.
             *
             * For example, calling set('title', 'hello')
             * on a TitlePane will automatically cause the TitlePane's DOM to update
             * with the new title.
             *
             * attributeMap is a hash where the key is an attribute of the widget,
             * and the value reflects a binding to a:
             *
             * DOM node attribute
             *   focus: {node: "focusNode", type: "attribute"}
             * Maps this.focus to this.focusNode.focus
             *
             * DOM node innerHTML
             *   title: { node: "titleNode", type: "innerHTML" }
             * Maps this.title to this.titleNode.innerHTML
             *
             * DOM node innerText
             *   title: { node: "titleNode", type: "innerText" }
             * Maps this.title to this.titleNode.innerText
             *
             * DOM node CSS class
             *   myClass: { node: "domNode", type: "class" }
             * Maps this.myClass to this.domNode.className
             *
             * If the value is an array, then each element in the array matches one of the
             * formats of the above list.
             *
             * There are also some shorthands for backwards compatibility:
             *
             * string --> { node: string, type: "attribute" }, for example:
             * "focusNode" ---> { node: "focusNode", type: "attribute" }
             * "" --> { node: "domNode", type: "attribute" }
             *
             */
            "attributeMap": Object;
            set(property:"attributeMap", value: Object): void;
            get(property:"attributeMap"): Object;
            watch(property:"attributeMap", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             *
             */
            "autoWidth": boolean;
            set(property:"autoWidth", value: boolean): void;
            get(property:"autoWidth"): boolean;
            watch(property:"autoWidth", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             *
             */
            "baseClass": string;
            set(property:"baseClass", value: string): void;
            get(property:"baseClass"): string;
            watch(property:"baseClass", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "class": string;
            set(property:"class", value: string): void;
            get(property:"class"): string;
            watch(property:"class", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Despite the name, this parameter specifies both constraints on the input
             * (including starting/ending dates/times allowed) as well as
             * formatting options like whether the date is displayed in long (ex: December 25, 2005)
             * or short (ex: 12/25/2005) format.  See dijit/form/_DateTimeTextBox.__Constraints for details.
             *
             */
            "constraints": Object;
            set(property:"constraints", value: Object): void;
            get(property:"constraints"): Object;
            watch(property:"constraints", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Designates where children of the source DOM node will be placed.
             * "Children" in this case refers to both DOM nodes and widgets.
             * For example, for myWidget:
             *
             * <div data-dojo-type=myWidget>
             *     <b> here's a plain DOM node
             *     <span data-dojo-type=subWidget>and a widget</span>
             *     <i> and another plain DOM node </i>
             * </div>
             * containerNode would point to:
             *
             * <b> here's a plain DOM node
             * <span data-dojo-type=subWidget>and a widget</span>
             * <i> and another plain DOM node </i>
             * In templated widgets, "containerNode" is set via a
             * data-dojo-attach-point assignment.
             *
             * containerNode must be defined for any widget that accepts innerHTML
             * (like ContentPane or BorderContainer or even Button), and conversely
             * is null for widgets that don't, like TextBox.
             *
             */
            "containerNode": HTMLElement;
            set(property:"containerNode", value: HTMLElement): void;
            get(property:"containerNode"): HTMLElement;
            watch(property:"containerNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             *
             */
            "cssStateNodes": Object;
            set(property:"cssStateNodes", value: Object): void;
            get(property:"cssStateNodes"): Object;
            watch(property:"cssStateNodes", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * JavaScript namespace to find calendar routines.  If unspecified, uses Gregorian calendar routines
             * at dojo/date and dojo/date/locale.
             *
             */
            "datePackage": string;
            set(property:"datePackage", value: string): void;
            get(property:"datePackage"): string;
            watch(property:"datePackage", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Bi-directional support, as defined by the HTML DIR
             * attribute. Either left-to-right "ltr" or right-to-left "rtl".  If undefined, widgets renders in page's
             * default direction.
             *
             */
            "dir": string;
            set(property:"dir", value: string): void;
            get(property:"dir"): string;
            watch(property:"dir", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Should this widget respond to user input?
             * In markup, this is specified as "disabled='disabled'", or just "disabled".
             *
             */
            "disabled": boolean;
            set(property:"disabled", value: boolean): void;
            get(property:"disabled"): boolean;
            watch(property:"disabled", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * For subclasses like ComboBox where the displayed value
             * (ex: Kentucky) and the serialized value (ex: KY) are different,
             * this represents the displayed value.
             *
             * Setting 'displayedValue' through set('displayedValue', ...)
             * updates 'value', and vice-versa.  Otherwise 'value' is updated
             * from 'displayedValue' periodically, like onBlur etc.
             *
             * TODO: move declaration to MappedTextBox?
             * Problem is that ComboBox references displayedValue,
             * for benefit of FilteringSelect.
             *
             */
            "displayedValue": string;
            set(property:"displayedValue", value: string): void;
            get(property:"displayedValue"): string;
            watch(property:"displayedValue", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * This is our visible representation of the widget! Other DOM
             * Nodes may by assigned to other properties, usually through the
             * template system's data-dojo-attach-point syntax, but the domNode
             * property is the canonical "top level" node in widget UI.
             *
             */
            "domNode": HTMLElement;
            set(property:"domNode", value: HTMLElement): void;
            get(property:"domNode"): HTMLElement;
            watch(property:"domNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * The widget to display as a popup.  This widget must be
             * defined before the startup function is called.
             *
             */
            "dropDown": Object;
            set(property:"dropDown", value: Object): void;
            get(property:"dropDown"): Object;
            watch(property:"dropDown", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * The default value to focus in the popupClass widget when the textbox value is empty.
             *
             */
            "dropDownDefaultValue": Date;
            set(property:"dropDownDefaultValue", value: Date): void;
            get(property:"dropDownDefaultValue"): Date;
            watch(property:"dropDownDefaultValue", callback:{(property?:string, oldValue?:Date, newValue?: Date):void}) :{unwatch():void}
            /**
             * This variable controls the position of the drop down.
             * It's an array of strings with the following values:
             *
             * before: places drop down to the left of the target node/widget, or to the right in
             * the case of RTL scripts like Hebrew and Arabic
             * after: places drop down to the right of the target node/widget, or to the left in
             * the case of RTL scripts like Hebrew and Arabic
             * above: drop down goes above target node
             * below: drop down goes below target node
             * The list is positions is tried, in order, until a position is found where the drop down fits
             * within the viewport.
             *
             */
            "dropDownPosition": Object;
            set(property:"dropDownPosition", value: Object): void;
            get(property:"dropDownPosition"): Object;
            watch(property:"dropDownPosition", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * This widget or a widget it contains has focus, or is "active" because
             * it was recently clicked.
             *
             */
            "focused": boolean;
            set(property:"focused", value: boolean): void;
            get(property:"focused"): boolean;
            watch(property:"focused", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Set to true to make the drop down exactly as wide as this
             * widget.  Overrides autoWidth.
             *
             */
            "forceWidth": boolean;
            set(property:"forceWidth", value: boolean): void;
            get(property:"forceWidth"): boolean;
            watch(property:"forceWidth", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Set this textbox to display a down arrow button, to open the drop down list.
             *
             */
            "hasDownArrow": boolean;
            set(property:"hasDownArrow", value: boolean): void;
            get(property:"hasDownArrow"): boolean;
            watch(property:"hasDownArrow", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * True if cursor is over this widget
             *
             */
            "hovering": boolean;
            set(property:"hovering", value: boolean): void;
            get(property:"hovering"): boolean;
            watch(property:"hovering", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * A unique, opaque ID string that can be assigned by users or by the
             * system. If the developer passes an ID which is known not to be
             * unique, the specified ID is ignored and the system-generated ID is
             * used instead.
             *
             */
            "id": string;
            set(property:"id", value: string): void;
            get(property:"id"): string;
            watch(property:"id", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Fires onChange for each value change or only on demand
             *
             */
            "intermediateChanges": boolean;
            set(property:"intermediateChanges", value: boolean): void;
            get(property:"intermediateChanges"): boolean;
            watch(property:"intermediateChanges", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * The message to display if value is invalid.
             * The translated string value is read from the message file by default.
             * Set to "" to use the promptMessage instead.
             *
             */
            "invalidMessage": string;
            set(property:"invalidMessage", value: string): void;
            get(property:"invalidMessage"): string;
            watch(property:"invalidMessage", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Rarely used.  Overrides the default Dojo locale used to render this widget,
             * as defined by the HTML LANG attribute.
             * Value must be among the list of locales specified during by the Dojo bootstrap,
             * formatted according to RFC 3066 (like en-us).
             *
             */
            "lang": string;
            set(property:"lang", value: string): void;
            get(property:"lang"): string;
            watch(property:"lang", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Converts all characters to lowercase if true.  Default is false.
             *
             */
            "lowercase": boolean;
            set(property:"lowercase", value: boolean): void;
            get(property:"lowercase"): boolean;
            watch(property:"lowercase", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * The max height for our dropdown.
             * Any dropdown taller than this will have scrollbars.
             * Set to 0 for no max height, or -1 to limit height to available space in viewport
             *
             */
            "maxHeight": number;
            set(property:"maxHeight", value: number): void;
            get(property:"maxHeight"): number;
            watch(property:"maxHeight", callback:{(property?:string, oldValue?:number, newValue?: number):void}) :{unwatch():void}
            /**
             * HTML INPUT tag maxLength declaration.
             *
             */
            "maxLength": string;
            set(property:"maxLength", value: string): void;
            get(property:"maxLength"): string;
            watch(property:"maxLength", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Currently error/prompt message.
             * When using the default tooltip implementation, this will only be
             * displayed when the field is focused.
             *
             */
            "message": string;
            set(property:"message", value: string): void;
            get(property:"message"): string;
            watch(property:"message", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * The message to display if value is empty and the field is required.
             * The translated string value is read from the message file by default.
             * Set to "" to use the invalidMessage instead.
             *
             */
            "missingMessage": string;
            set(property:"missingMessage", value: string): void;
            get(property:"missingMessage"): string;
            watch(property:"missingMessage", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Name used when submitting form; same as "name" attribute or plain HTML elements
             *
             */
            "name": string;
            set(property:"name", value: string): void;
            get(property:"name"): string;
            watch(property:"name", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * The document this widget belongs to.  If not specified to constructor, will default to
             * srcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global
             *
             */
            "ownerDocument": Object;
            set(property:"ownerDocument", value: Object): void;
            get(property:"ownerDocument"): Object;
            watch(property:"ownerDocument", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Defines a hint to help users fill out the input field (as defined in HTML 5).
             * This should only contain plain text (no html markup).
             *
             */
            "placeHolder": string;
            set(property:"placeHolder", value: string): void;
            get(property:"placeHolder"): string;
            watch(property:"placeHolder", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * If defined, display this hint string immediately on focus to the textbox, if empty.
             * Also displays if the textbox value is Incomplete (not yet valid but will be with additional input).
             * Think of this like a tooltip that tells the user what to do, not an error message
             * that tells the user what they've done wrong.
             *
             * Message disappears when user starts typing.
             *
             */
            "promptMessage": string;
            set(property:"promptMessage", value: string): void;
            get(property:"promptMessage"): string;
            watch(property:"promptMessage", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Converts the first character of each word to uppercase if true.
             *
             */
            "propercase": boolean;
            set(property:"propercase", value: boolean): void;
            get(property:"propercase"): boolean;
            watch(property:"propercase", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * The message to display if value is out-of-range
             *
             */
            "rangeMessage": string;
            set(property:"rangeMessage", value: string): void;
            get(property:"rangeMessage"): string;
            watch(property:"rangeMessage", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Should this widget respond to user input?
             * In markup, this is specified as "readOnly".
             * Similar to disabled except readOnly form values are submitted.
             *
             */
            "readOnly": boolean;
            set(property:"readOnly", value: boolean): void;
            get(property:"readOnly"): boolean;
            watch(property:"readOnly", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             *
             */
            "regExp": string;
            set(property:"regExp", value: string): void;
            get(property:"regExp"): string;
            watch(property:"regExp", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * User is required to enter data into this field.
             *
             */
            "required": boolean;
            set(property:"required", value: boolean): void;
            get(property:"required"): boolean;
            watch(property:"required", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * On focus, should this widget scroll into view?
             *
             */
            "scrollOnFocus": boolean;
            set(property:"scrollOnFocus", value: boolean): void;
            get(property:"scrollOnFocus"): boolean;
            watch(property:"scrollOnFocus", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             *
             */
            "searchContainerNode": boolean;
            set(property:"searchContainerNode", value: boolean): void;
            get(property:"searchContainerNode"): boolean;
            watch(property:"searchContainerNode", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * If true, all text will be selected when focused with mouse
             *
             */
            "selectOnClick": boolean;
            set(property:"selectOnClick", value: boolean): void;
            get(property:"selectOnClick"): boolean;
            watch(property:"selectOnClick", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * pointer to original DOM node
             *
             */
            "srcNodeRef": HTMLElement;
            set(property:"srcNodeRef", value: HTMLElement): void;
            get(property:"srcNodeRef"): HTMLElement;
            watch(property:"srcNodeRef", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
            /**
             * Shows current state (ie, validation result) of input (""=Normal, Incomplete, or Error)
             *
             */
            "state": string;
            set(property:"state", value: string): void;
            get(property:"state"): string;
            watch(property:"state", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * HTML style attributes as cssText string or name/value hash
             *
             */
            "style": string;
            set(property:"style", value: string): void;
            get(property:"style"): string;
            watch(property:"style", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Order fields are traversed when user hits the tab key
             *
             */
            "tabIndex": string;
            set(property:"tabIndex", value: string): void;
            get(property:"tabIndex"): string;
            watch(property:"tabIndex", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Path to template (HTML file) for this widget relative to dojo.baseUrl.
             * Deprecated: use templateString with require([... "dojo/text!..."], ...) instead
             *
             */
            "templatePath": string;
            set(property:"templatePath", value: string): void;
            get(property:"templatePath"): string;
            watch(property:"templatePath", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             *
             */
            "templateString": string;
            set(property:"templateString", value: string): void;
            get(property:"templateString"): string;
            watch(property:"templateString", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * HTML title attribute.
             *
             * For form widgets this specifies a tooltip to display when hovering over
             * the widget (just like the native HTML title attribute).
             *
             * For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,
             * etc., it's used to specify the tab label, accordion pane title, etc.  In this case it's
             * interpreted as HTML.
             *
             */
            "title": string;
            set(property:"title", value: string): void;
            get(property:"title"): string;
            watch(property:"title", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * When this widget's title attribute is used to for a tab label, accordion pane title, etc.,
             * this specifies the tooltip to appear when the mouse is hovered over that text.
             *
             */
            "tooltip": string;
            set(property:"tooltip", value: string): void;
            get(property:"tooltip"): string;
            watch(property:"tooltip", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * See description of dijit/Tooltip.defaultPosition for details on this parameter.
             *
             */
            "tooltipPosition": Object;
            set(property:"tooltipPosition", value: Object): void;
            get(property:"tooltipPosition"): Object;
            watch(property:"tooltipPosition", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
            /**
             * Removes leading and trailing whitespace if true.  Default is false.
             *
             */
            "trim": boolean;
            set(property:"trim", value: boolean): void;
            get(property:"trim"): boolean;
            watch(property:"trim", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * Corresponds to the native HTML <input> element's attribute.
             *
             */
            "type": string;
            set(property:"type", value: string): void;
            get(property:"type"): string;
            watch(property:"type", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
            /**
             * Converts all characters to uppercase if true.  Default is false.
             *
             */
            "uppercase": boolean;
            set(property:"uppercase", value: boolean): void;
            get(property:"uppercase"): boolean;
            watch(property:"uppercase", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
            /**
             * The value of this widget as a JavaScript Date object.  Use get("value") / set("value", val) to manipulate.
             * When passed to the parser in markup, must be specified according to dojo/date/stamp.fromISOString()
             *
             */
            "value": Date;
            set(property:"value", value: Date): void;
            get(property:"value"): Date;
            watch(property:"value", callback:{(property?:string, oldValue?:Date, newValue?: Date):void}) :{unwatch():void}
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: String, value: Object): any;
            /**
             * This method is deprecated, use get() or set() directly.
             *
             * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
             * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
             */
            attr(name: Object, value: Object): any;
            /**
             *
             */
            buildRendering(): void;
            /**
             * Closes the drop down on this widget
             *
             * @param focus If true, refocuses the button widget
             */
            closeDropDown(focus: boolean): void;
            /**
             *
             * @param val1
             * @param val2
             */
            compare(val1: Date, val2: Date): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: String): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: String, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: Object, event: Function, method: Function): any;
            /**
             * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
             *
             * Connects specified obj/event to specified method of this object
             * and registers for disconnect() on widget destroy.
             *
             * Provide widget-specific analog to dojo.connect, except with the
             * implicit use of this widget as the target object.
             * Events connected with this.connect are disconnected upon
             * destruction.
             *
             * @param obj
             * @param event
             * @param method
             */
            connect(obj: any, event: Function, method: Function): any;
            /**
             * Wrapper to setTimeout to avoid deferred functions executing
             * after the originating widget has been destroyed.
             * Returns an object handle with a remove method (that returns null) (replaces clearTimeout).
             *
             * @param fcn Function reference.
             * @param delay               OptionalDelay, defaults to 0.
             */
            defer(fcn: Function, delay: number): Object;
            /**
             * Destroy this widget, but not its descendants.  Descendants means widgets inside of
             * this.containerNode.   Will also destroy any resources (including widgets) registered via this.own().
             *
             * This method will also destroy internal widgets such as those created from a template,
             * assuming those widgets exist inside of this.domNode but outside of this.containerNode.
             *
             * For 2.0 it's planned that this method will also destroy descendant widgets, so apps should not
             * depend on the current ability to destroy a widget without destroying its descendants.   Generally
             * they should use destroyRecursive() for widgets with children.
             *
             * @param preserveDom If true, this method will leave the original DOM structure alone.Note: This will not yet work with _TemplatedMixin widgets
             */
            destroy(preserveDom?: boolean): void;
            /**
             * Recursively destroy the children of this widget and their
             * descendants.
             *
             * @param preserveDom               OptionalIf true, the preserveDom attribute is passed to all descendantwidget's .destroy() method. Not for use with _Templatedwidgets.
             */
            destroyDescendants(preserveDom: boolean): void;
            /**
             * Destroy this widget and its descendants
             * This is the generic "destructor" function that all widget users
             * should call to cleanly discard with a widget. Once a widget is
             * destroyed, it is removed from the manager object.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structurealone of descendant Widgets. Note: This will NOT work withdijit._TemplatedMixin widgets.
             */
            destroyRecursive(preserveDom: boolean): void;
            /**
             * Destroys the DOM nodes associated with this widget.
             *
             * @param preserveDom               OptionalIf true, this method will leave the original DOM structure aloneduring tear-down. Note: this will not work with _Templatedwidgets yet.
             */
            destroyRendering(preserveDom?: boolean): void;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Disconnects handle created by connect.
             *
             * @param handle
             */
            disconnect(handle: any): void;
            /**
             * Overridable method to display validation errors/hints.
             * By default uses a tooltip.
             *
             * @param message
             */
            displayMessage(message: String): void;
            /**
             * Used by widgets to signal that a synthetic event occurred, ex:
             *
             * myWidget.emit("attrmodified-selectedChildWidget", {}).
             * Emits an event on this.domNode named type.toLowerCase(), based on eventObj.
             * Also calls onType() method, if present, and returns value from that method.
             * By default passes eventObj to callback, but will pass callbackArgs instead, if specified.
             * Modifies eventObj by adding missing parameters (bubbles, cancelable, widget).
             *
             * @param type
             * @param eventObj               Optional
             * @param callbackArgs               Optional
             */
            emit(type: String, eventObj: Object, callbackArgs: any[]): any;
            /**
             *
             * @param val
             */
            filter(val: any): any;
            /**
             * Put focus on this widget
             *
             */
            focus(): void;
            /**
             *
             * @param value
             */
            format(value: any): any;
            /**
             * Get a property from a widget.
             * Get a named property from a widget. The property may
             * potentially be retrieved via a getter method. If no getter is defined, this
             * just retrieves the object's property.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _getFooAttr(), calling:
             * myWidget.get("foo") would be equivalent to calling
             * widget._getFooAttr() and myWidget.get("bar")
             * would be equivalent to the expression
             * widget.bar2
             *
             * @param name The property to get.
             */
            get(name: any): any;
            /**
             * Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent
             * is this widget.   Note that it does not return all descendants, but rather just direct children.
             * Analogous to Node.childNodes,
             * except containing widgets rather than DOMNodes.
             *
             * The result intentionally excludes internally created widgets (a.k.a. supporting widgets)
             * outside of this.containerNode.
             *
             * Note that the array returned is a simple array.  Application code should not assume
             * existence of methods like forEach().
             *
             */
            getChildren(): any[];
            /**
             * Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
             * This method should generally be avoided as it returns widgets declared in templates, which are
             * supposed to be internal/hidden, but it's left here for back-compat reasons.
             *
             */
            getDescendants(): any[];
            /**
             * Deprecated.  Use get('displayedValue') instead.
             *
             */
            getDisplayedValue(): any;
            /**
             *
             * @param isFocused
             */
            getErrorMessage(isFocused: boolean): any;
            /**
             * Returns the parent widget of this widget.
             *
             */
            getParent(): any;
            /**
             * Return a hint message to show when widget is first focused
             *
             * @param isFocused
             */
            getPromptMessage(isFocused: boolean): any;
            /**
             * Deprecated.  Use get('value') instead.
             *
             */
            getValue(): any;
            /**
             * Return true if this widget can currently be focused
             * and false if not
             *
             */
            isFocusable(): any;
            /**
             * Tests if the value is in the min/max range specified in constraints
             *
             * @param isFocused
             */
            isInRange(isFocused: boolean): any;
            /**
             * Return this widget's explicit or implicit orientation (true for LTR, false for RTL)
             *
             */
            isLeftToRight(): any;
            /**
             * Returns true if the dropdown exists and it's data is loaded.  This can
             * be overridden in order to force a call to loadDropDown().
             *
             */
            isLoaded(): boolean;
            /**
             *
             * @param isFocused
             */
            isValid: {(isFocused: boolean): any};
            /**
             * Creates the drop down if it doesn't exist, loads the data
             * if there's an href and it hasn't been loaded yet, and
             * then opens the drop down.  This is basically a callback when the
             * user presses the down arrow button to open the drop down.
             *
             */
            loadAndOpenDropDown(): any;
            /**
             * Creates the drop down if it doesn't exist, loads the data
             * if there's an href and it hasn't been loaded yet, and then calls
             * the given callback.
             *
             * @param loadCallback
             */
            loadDropDown(loadCallback: Function): void;
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: String, func: Function): any;
            /**
             *
             * @param type protected
             * @param func
             */
            on(type: Function, func: Function): any;
            /**
             *
             */
            openDropDown(): void;
            /**
             * Track specified handles and remove/destroy them when this instance is destroyed, unless they were
             * already removed/destroyed manually.
             *
             */
            own(): any;
            /**
             *
             * @param value
             * @param constraints
             */
            parse(value: String, constraints: dojo.date.locale.__FormatOptions): String;
            /**
             * Builds the regular needed to parse a localized date
             *
             * @param options               OptionalAn object with the following properties:selector (String): choice of 'time','date' (default: date and time)formatLength (String): choice of long, short, medium or full (plus any custom additions).  Defaults to 'short'datePattern (String): override pattern with this stringtimePattern (String): override pattern with this stringam (String): override strings for am in timespm (String): override strings for pm in timeslocale (String): override the locale used to determine formatting rulesfullYear (Boolean): (format only) use 4 digit years whenever 2 digit years are called forstrict (Boolean): (parse only) strict parsing, off by default
             */
            pattern: { (options: Object): any };
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: String): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: String, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: HTMLElement, position: number): any;
            /**
             * Place this widget somewhere in the DOM based
             * on standard domConstruct.place() conventions.
             * A convenience function provided in all _Widgets, providing a simple
             * shorthand mechanism to put an existing (or newly created) Widget
             * somewhere in the dom, and allow chaining.
             *
             * @param reference Widget, DOMNode, or id of widget or DOMNode
             * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
             */
            placeAt(reference: dijit._WidgetBase, position: number): any;
            /**
             *
             */
            popupClass: {(): void};
            /**
             *
             */
            postCreate(): void;
            /**
             *
             */
            postMixInProperties(): void;
            /**
             * Overridable function used to validate the range of the numeric input value.
             *
             * @param primitive
             * @param constraints
             */
            rangeCheck(primitive: number, constraints: dijit.form.RangeBoundTextBox.__Constraints): boolean;
            /**
             * Deprecated.  Use set('pattern', Function) instead.
             *
             * @param constraints An object with the following properties:locale (String): locale used for validation, picks up value from this widget's lang attribute_flags_ (anything): various flags passed to pattern function
             */
            regExpGen(constraints: Object): void;
            /**
             *
             */
            reset(): void;
            /**
             *
             * @param val
             * @param options               Optional
             */
            serialize(val: any, options: Object): any;
            /**
             * Set a property on a widget
             * Sets named properties on a widget which may potentially be handled by a
             * setter in the widget.
             *
             * For example, if the widget has properties foo and bar
             * and a method named _setFooAttr(), calling
             * myWidget.set("foo", "Howdy!") would be equivalent to calling
             * widget._setFooAttr("Howdy!") and myWidget.set("bar", 3)
             * would be equivalent to the statement widget.bar = 3;
             *
             * set() may also be called with a hash of name/value pairs, ex:
             *
             * myWidget.set({
             *     foo: "Howdy",
             *     bar: 3
             * });
             * This is equivalent to calling set(foo, "Howdy") and set(bar, 3)
             *
             * @param name The property to set.
             * @param value The value to set in the property.
             */
            set(name: any, value: any): any;
            /**
             * Deprecated.  Use set() instead.
             *
             * @param attr
             * @param value
             */
            setAttribute(attr: String, value: any): void;
            /**
             * Deprecated.  Use set('disabled', ...) instead.
             *
             * @param disabled
             */
            setDisabled(disabled: boolean): void;
            /**
             * Deprecated.  Use set('displayedValue', ...) instead.
             *
             * @param value
             */
            setDisplayedValue(value: String): void;
            /**
             * Deprecated.  Use set('value', ...) instead.
             *
             * @param value
             */
            setValue(value: String): void;
            /**
             *
             */
            startup(): void;
            /**
             * Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.
             *
             * Subscribes to the specified topic and calls the specified method
             * of this object and registers for unsubscribe() on widget destroy.
             *
             * Provide widget-specific analog to dojo.subscribe, except with the
             * implicit use of this widget as the target object.
             *
             * @param t The topic
             * @param method The callback
             */
            subscribe(t: String, method: Function): any;
            /**
             * Callback when the user presses the down arrow button or presses
             * the down arrow key to open/close the drop down.
             * Toggle the drop-down widget; if it is up, close it, if not, open it
             *
             */
            toggleDropDown(): void;
            /**
             * Returns widget as a printable string using the widget's value
             *
             */
            toString(): string;
            /**
             * Restore the value to the last value passed to onChange
             *
             */
            undo(): void;
            /**
             * Deprecated. Override destroy() instead to implement custom widget tear-down
             * behavior.
             *
             */
            uninitialize(): boolean;
            /**
             * Deprecated, will be removed in 2.0, use handle.remove() instead.
             *
             * Unsubscribes handle created by this.subscribe.
             * Also removes handle from this widget's list of subscriptions
             *
             * @param handle
             */
            unsubscribe(handle: Object): void;
            /**
             *
             */
            validate(): any;
            /**
             *
             * @param value
             */
            validator(value: any): boolean;
            /**
             * Watches a property for changes
             *
             * @param name               OptionalIndicates the property to watch. This is optional (the callback may be theonly parameter), and if omitted, all the properties will be watched
             * @param callback The function to execute when the property changes. This will be called afterthe property has been changed. The callback will be called with the |this|set to the instance, the first argument as the name of the property, thesecond argument as the old value and the third argument as the new value.
             */
            watch(property: string, callback:{(property?:string, oldValue?:any, newValue?: any):void}) :{unwatch():void};
            /**
             * Static method to get a template based on the templatePath or
             * templateString key
             */
            getCachedTemplate(): any;
            /**
             * Called when the widget stops being "active" because
             * focus moved to something outside of it, or the user
             * clicked somewhere outside of it, or the widget was
             * hidden.
             *
             */
            onBlur(): void;
            /**
             * Callback when this widget's value is changed.
             *
             * @param newValue
             */
            onChange(newValue: any): void;
            /**
             * Connect to this function to receive notifications of mouse click events.
             *
             * @param event mouse Event
             */
            onClick(event: any): void;
            /**
             * Called when this widget is being displayed as a popup (ex: a Calendar popped
             * up from a DateTextBox), and it is hidden.
             * This is called from the dijit.popup code, and should not be called directly.
             *
             * Also used as a parameter for children of dijit/layout/StackContainer or subclasses.
             * Callback if a user tries to close the child.   Child will be closed if this function returns true.
             *
             */
            onClose(): boolean;
            /**
             * Connect to this function to receive notifications of mouse double click events.
             *
             * @param event mouse Event
             */
            onDblClick(event: any): void;
            /**
             * Called when the widget becomes "active" because
             * it or a widget inside of it either has focus, or has recently
             * been clicked.
             *
             */
            onFocus(): void;
            /**
             * Called when another widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate hide of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onHide(): void;
            /**
             * Connect to this function to receive notifications of various user data-input events.
             * Return false to cancel the event and prevent it from being processed.
             *
             * @param event keydown | keypress | cut | paste | input
             */
            onInput(event: any): void;
            /**
             * Connect to this function to receive notifications of keys being pressed down.
             *
             * @param event key Event
             */
            onKeyDown(event: any): void;
            /**
             * Connect to this function to receive notifications of printable keys being typed.
             *
             * @param event key Event
             */
            onKeyPress(event: any): void;
            /**
             * Connect to this function to receive notifications of keys being released.
             *
             * @param event key Event
             */
            onKeyUp(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is pressed down.
             *
             * @param event mouse Event
             */
            onMouseDown(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto this widget.
             *
             * @param event mouse Event
             */
            onMouseEnter(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of this widget.
             *
             * @param event mouse Event
             */
            onMouseLeave(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseMove(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOut(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse moves onto nodes contained within this widget.
             *
             * @param event mouse Event
             */
            onMouseOver(event: any): void;
            /**
             * Connect to this function to receive notifications of when the mouse button is released.
             *
             * @param event mouse Event
             */
            onMouseUp(event: any): void;
            /**
             * Called when this widget becomes the selected pane in a
             * dijit/layout/TabContainer, dijit/layout/StackContainer,
             * dijit/layout/AccordionContainer, etc.
             *
             * Also called to indicate display of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
             *
             */
            onShow(): void;
        }
        namespace manager {
            /**
             * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/manager/_ClassMixin.html
             *
             * Form manager's mixin for testing/assigning/removing
             * classes of controlled elements.
             * This mixin provides unified way to check/add/remove a class
             * of controlled elements.
             * It should be used together with dojox.form.manager.Mixin.
             *
             */
            class _ClassMixin {
                constructor();
                /**
                 * Add a class to nodes according to the supplied set of names
                 *
                 * @param className Class name to add.
                 * @param names               OptionalIf it is an array, it is a list of names to be processed.If it is an object, dictionary keys are names to be processed.If it is omitted, all known form elements are to be processed.
                 */
                addClass(className: String, names: Object): Function;
                /**
                 * Gather the presence of a certain class in all controlled elements.
                 *
                 * @param className The class name to test for.
                 * @param names               OptionalIf it is an array, it is a list of names to be processed.If it is an object, dictionary keys are names to be processed.If it is omitted, all known form elements are to be processed.
                 */
                gatherClassState(className: String, names: Object): any;
                /**
                 * Remove a class from nodes according to the supplied set of names
                 *
                 * @param className Class name to remove.
                 * @param names               OptionalIf it is an array, it is a list of names to be processed.If it is an object, dictionary keys are names to be processed.If it is omitted, all known form elements are to be processed.
                 */
                removeClass(className: String, names: Object): Function;
            }
            /**
             * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/manager/_EnableMixin.html
             *
             * Form manager's mixin for controlling enable/disable state of
             * form elements.
             * This mixin provides unified enable/disable functionality for
             * form widgets and form elements. It should be used together
             * with dojox.form.manager.Mixin.
             *
             */
            class _EnableMixin {
                constructor();
                /**
                 * Disable form controls according to the supplied state object
                 * returning the previous state.
                 *
                 * @param state               OptionalOptional. If a name-value dictionary, the value is trueto enable and false to disable. If an array, all names in thearray will be disabled. If omitted, disables all.
                 */
                disable(state: Object): any;
                /**
                 * Enable form controls according to the supplied state object.
                 *
                 * @param state               OptionalOptional. If a name-value dictionary, the value is trueto enable and false to disable. If an array, all names in thearray will be set to defaultState. If omitted, all formelements will be set to defaultState.
                 * @param defaultState The default state (true, if omitted).
                 */
                enable(state: Object, defaultState: boolean): Function;
                /**
                 * Gather enable state of all form elements and return as a dictionary.
                 *
                 * @param names               OptionalIf it is an array, it is a list of names to be processed.If it is an object, dictionary keys are names to be processed.If it is omitted, all known form elements are to be processed.
                 */
                gatherEnableState(names: Object): any;
            }
            /**
             * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/manager/_DisplayMixin.html
             *
             * Form manager's mixin for controlling show/hide state of
             * controlled elements (defined by dojoAttachPoint attributes).
             * This mixin provides unified show/hide functionality for
             * controlled elements (indicated by dojoAttachPoint attribute).
             * Essentially it provides a way to change "style.display"
             * parameter of controlled nodes.
             * It should be used together with dojox.form.manager.Mixin.
             *
             */
            class _DisplayMixin {
                constructor();
                /**
                 * Gather display state of all attached elements and return as a dictionary.
                 *
                 * @param names               OptionalIf it is an array, it is a list of names to be processed.If it is an object, dictionary keys are names to be processed.If it is omitted, all known attach point nodes are to be processed.
                 */
                gatherDisplayState(names: Object): any;
                /**
                 * Hide attached nodes according to the supplied state object.
                 *
                 * @param state               OptionalOptional. If a name-value dictionary, the value is trueto show and false to hide. If an array, all names in thearray will be hidden. If omitted, all form elementswill be hidden.
                 */
                hide(state: Object): any;
                /**
                 * Show attached nodes according to the supplied state object.
                 *
                 * @param state               OptionalOptional. If a name-value dictionary, the value is trueto show and false to hide. If an array, all names in thearray will be set to defaultState. If omitted, all formelements will be set to defaultState.
                 * @param defaultState               OptionalThe default state (true, if omitted).
                 */
                show(state: Object, defaultState: boolean): Function;
            }
            /**
             * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/manager/_FormMixin.html
             *
             * Form manager's mixin for form-specific functionality.
             * This mixin adds automated "onreset", and "onsubmit" event processing
             * if we are based on a form node, defines onReset(), onSubmit(),
             * reset(), submit(), and isValid() methods like dijit.form.Form.
             * It should be used together with dojox.form.manager.Mixin.
             *
             */
            class _FormMixin {
                constructor();
                /**
                 *
                 */
                "accept": string;
                /**
                 *
                 */
                "accept-charset": string;
                /**
                 *
                 */
                "action": string;
                /**
                 *
                 */
                "encType": string;
                /**
                 *
                 */
                "method": string;
                /**
                 *
                 */
                "name": string;
                /**
                 *
                 */
                "target": string;
                /**
                 * Make sure that every widget that has a validator function returns true.
                 *
                 */
                isValid: {(): boolean};
                /**
                 * Resets form widget values.
                 *
                 */
                reset(): Function;
                /**
                 *
                 */
                startup(): void;
                /**
                 * programmatically submit form if and only if the onSubmit returns true
                 *
                 */
                submit(): void;
                /**
                 * validate() returns if the form is valid - same as isValid -
                 * but provides a few additional (ui-specific) features: it
                 * will highlight any sub-widgets that are not valid it will
                 * call focus() on the first invalid sub-widget
                 *
                 */
                validate(): boolean;
                /**
                 * Callback when user resets the form. This method is intended
                 * to be over-ridden. When the reset method is called
                 * programmatically, the return value from onReset is used
                 * to compute whether or not resetting should proceed
                 *
                 */
                onReset(): boolean;
                /**
                 * Callback when user submits the form. This method is
                 * intended to be over-ridden, but by default it checks and
                 * returns the validity of form elements. When the submit
                 * method is called programmatically, the return value from
                 * onSubmit is used to compute whether or not submission
                 * should proceed
                 *
                 */
                onSubmit(): any;
            }
            /**
             * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/manager/_NodeMixin.html
             *
             * Mixin to orchestrate dynamic forms (works with DOM nodes).
             * This mixin provides a foundation for an enhanced form
             * functionality: unified access to individual form elements,
             * unified "change" event processing, and general event
             * processing. It complements dojox/form/manager/_Mixin
             * extending the functionality to DOM nodes.
             *
             */
            class _NodeMixin {
                constructor();
                /**
                 * Called when the widget is being destroyed
                 *
                 */
                destroy(): void;
                /**
                 * Set or get a form element by name.
                 *
                 * @param elem Form element's name, DOM node, or array or radio nodes.
                 * @param value               OptionalOptional. The value to set.
                 */
                formNodeValue(elem: String, value: Object): any;
                /**
                 * Set or get a form element by name.
                 *
                 * @param elem Form element's name, DOM node, or array or radio nodes.
                 * @param value               OptionalOptional. The value to set.
                 */
                formNodeValue(elem: HTMLElement, value: Object): any;
                /**
                 * Set or get a form element by name.
                 *
                 * @param elem Form element's name, DOM node, or array or radio nodes.
                 * @param value               OptionalOptional. The value to set.
                 */
                formNodeValue(elem: any[], value: Object): any;
                /**
                 * Run an inspector function on controlled form elements returning a result object.
                 *
                 * @param inspector A function to be called on a form element. Takes three arguments: a name, a node oran array of nodes, and a supplied value. Runs in the context of the form manager.Returns a value that will be collected and returned as a state.
                 * @param state               OptionalOptional. If a name-value dictionary --- only listed names will be processed.If an array, all names in the array will be processed with defaultValue.If omitted or null, all form elements will be processed with defaultValue.
                 * @param defaultValue               OptionalOptional. The default state (true, if omitted).
                 */
                inspectFormNodes(inspector: Function, state: Object, defaultValue: Object): Object;
                /**
                 * Register a node with the form manager
                 *
                 * @param node A node, or its id
                 */
                registerNode(node: String): any;
                /**
                 * Register a node with the form manager
                 *
                 * @param node A node, or its id
                 */
                registerNode(node: HTMLElement): any;
                /**
                 * Register node's descendants (form nodes) with the form manager
                 *
                 * @param node A widget, or its widgetId, or its DOM node
                 */
                registerNodeDescendants(node: String): any;
                /**
                 * Register node's descendants (form nodes) with the form manager
                 *
                 * @param node A widget, or its widgetId, or its DOM node
                 */
                registerNodeDescendants(node: HTMLElement): any;
                /**
                 * Removes the node by name from internal tables unregistering
                 * connected observers
                 *
                 * @param name Name of the to unregister
                 */
                unregisterNode(name: String): any;
                /**
                 * Unregister node's descendants (form nodes) with the form manager
                 *
                 * @param node A widget, or its widgetId, or its DOM node
                 */
                unregisterNodeDescendants(node: String): any;
                /**
                 * Unregister node's descendants (form nodes) with the form manager
                 *
                 * @param node A widget, or its widgetId, or its DOM node
                 */
                unregisterNodeDescendants(node: HTMLElement): any;
            }
            /**
             * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/manager/_Mixin.html
             *
             * Mixin to orchestrate dynamic forms.
             * This mixin provides a foundation for an enhanced form
             * functionality: unified access to individual form elements,
             * unified "onchange" event processing, general event
             * processing, I/O orchestration, and common form-related
             * functionality. See additional mixins in dojox.form.manager
             * namespace.
             *
             */
            class _Mixin {
                constructor();
                /**
                 *
                 */
                "watching": boolean;
                /**
                 * Called when the widget is being destroyed
                 *
                 */
                destroy(): void;
                /**
                 * Set or get a node context by name (using dojoAttachPoint).
                 *
                 * @param elem A node.
                 * @param value               OptionalOptional. The value to set.
                 */
                formPointValue(elem: String, value: Object): any;
                /**
                 * Set or get a node context by name (using dojoAttachPoint).
                 *
                 * @param elem A node.
                 * @param value               OptionalOptional. The value to set.
                 */
                formPointValue(elem: Object, value: Object): any;
                /**
                 * Set or get a node context by name (using dojoAttachPoint).
                 *
                 * @param elem A node.
                 * @param value               OptionalOptional. The value to set.
                 */
                formPointValue(elem: any[], value: Object): any;
                /**
                 * Set or get a form widget by name.
                 *
                 * @param elem Form element's name, widget object, or array or radio widgets.
                 * @param value               OptionalOptional. The value to set.
                 */
                formWidgetValue(elem: String, value: Object): any;
                /**
                 * Set or get a form widget by name.
                 *
                 * @param elem Form element's name, widget object, or array or radio widgets.
                 * @param value               OptionalOptional. The value to set.
                 */
                formWidgetValue(elem: Object, value: Object): any;
                /**
                 * Set or get a form widget by name.
                 *
                 * @param elem Form element's name, widget object, or array or radio widgets.
                 * @param value               OptionalOptional. The value to set.
                 */
                formWidgetValue(elem: any[], value: Object): any;
                /**
                 * Run an inspector function on controlled elements returning a result object.
                 *
                 * @param inspector A function to be called on a widget, form element, and an attached node.Takes three arguments: a name, a node (domNode in the case of widget) oran array of such objects, and a supplied value. Runs in the context ofthe form manager. Returns a value that will be collected and returned as a state.
                 * @param state               OptionalOptional. If a name-value dictionary --- only listed names will be processed.If an array, all names in the array will be processed with defaultValue.If omitted or null, all controlled elements will be processed with defaultValue.
                 * @param defaultValue               OptionalOptional. The default state (true, if omitted).
                 */
                inspect(inspector: Function, state: Object, defaultValue: Object): any;
                /**
                 * Run an inspector function on "dojoAttachPoint" nodes returning a result object.
                 *
                 * @param inspector A function to be called on a node. Takes three arguments: a name, a node oran array of nodes, and a supplied value. Runs in the context of the form manager.Returns a value that will be collected and returned as a state.
                 * @param state               OptionalOptional. If a name-value dictionary --- only listed names will be processed.If an array, all names in the array will be processed with defaultValue.If omitted or null, all attached point nodes will be processed with defaultValue.
                 * @param defaultValue               OptionalOptional. The default state (true, if omitted).
                 */
                inspectAttachedPoints(inspector: Function, state: Object, defaultValue: Object): Object;
                /**
                 * Run an inspector function on controlled widgets returning a result object.
                 *
                 * @param inspector A function to be called on a widget. Takes three arguments: a name, a widget objector an array of widget objects, and a supplied value. Runs in the context ofthe form manager. Returns a value that will be collected and returned as a state.
                 * @param state               OptionalOptional. If a name-value dictionary --- only listed names will be processed.If an array, all names in the array will be processed with defaultValue.If omitted or null, all widgets will be processed with defaultValue.
                 * @param defaultValue               OptionalOptional. The default state (true, if omitted).
                 */
                inspectFormWidgets(inspector: Function, state: Object, defaultValue: Object): Object;
                /**
                 * Register a widget with the form manager
                 *
                 * @param widget A widget, or its widgetId, or its DOM node
                 */
                registerWidget(widget: String): any;
                /**
                 * Register a widget with the form manager
                 *
                 * @param widget A widget, or its widgetId, or its DOM node
                 */
                registerWidget(widget: HTMLElement): any;
                /**
                 * Register a widget with the form manager
                 *
                 * @param widget A widget, or its widgetId, or its DOM node
                 */
                registerWidget(widget:  dijit.form._FormWidget): any;
                /**
                 * Register widget's descendants with the form manager
                 *
                 * @param widget A widget, or its widgetId, or its DOM node
                 */
                registerWidgetDescendants(widget: String): any;
                /**
                 * Register widget's descendants with the form manager
                 *
                 * @param widget A widget, or its widgetId, or its DOM node
                 */
                registerWidgetDescendants(widget: HTMLElement): any;
                /**
                 * Register widget's descendants with the form manager
                 *
                 * @param widget A widget, or its widgetId, or its DOM node
                 */
                registerWidgetDescendants(widget:  dijit._Widget): any;
                /**
                 * Called after all the widgets have been instantiated and their
                 * dom nodes have been inserted somewhere under win.doc.body.
                 *
                 */
                startup(): void;
                /**
                 * Removes the widget by name from internal tables unregistering
                 * connected observers
                 *
                 * @param name Name of the to unregister
                 */
                unregisterWidget(name: string): any;
                /**
                 * Unregister widget's descendants with the form manager
                 *
                 * @param widget A widget, or its widgetId, or its DOM node
                 */
                unregisterWidgetDescendants(widget: String): any;
                /**
                 * Unregister widget's descendants with the form manager
                 *
                 * @param widget A widget, or its widgetId, or its DOM node
                 */
                unregisterWidgetDescendants(widget: HTMLElement): any;
                /**
                 * Unregister widget's descendants with the form manager
                 *
                 * @param widget A widget, or its widgetId, or its DOM node
                 */
                unregisterWidgetDescendants(widget:  dijit._Widget): any;
            }
            /**
             * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/manager/_ValueMixin.html
             *
             * Form manager's mixin for getting/setting form values in the unified manner.
             * This mixin adds unified access to form widgets and form elements
             * in terms of name-value regardless of the underlying type of
             * an element. It should be used together with dojox.form.manager.Mixin.
             *
             */
            class _ValueMixin {
                constructor();
                /**
                 * Set or get a form widget/element or an attached point node by name.
                 *
                 * @param name The name.
                 * @param value               OptionalOptional. The value to set.
                 */
                elementValue(name: String, value: Object): any;
                /**
                 * Collect form values.
                 *
                 * @param names               OptionalIf it is an array, it is a list of names of form elements to be collected.If it is an object, dictionary keys are names to be collected.If it is omitted, all known form elements are to be collected.
                 */
                gatherFormValues(names: Object): any;
                /**
                 * Set values to form elements
                 *
                 * @param values A dictionary of key-value pairs.
                 */
                setFormValues(values: Object): Function;
            }
        }

        namespace uploader {
            /**
             * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/uploader/_Flash.html
             *
             * A mixin for dojox/form/Uploader that utilizes a Flash SWF for handling to upload in IE.
             * All other browsers will use the HTML5 plugin, unless force="flash" is used, then Flash
             * will be used in all browsers. force="flash" is provided because Flash has some features
             * that HTML5 does not yet have. But it is still not recommended because of the many problems
             * that Firefox and Webkit have with the Flash plugin.
             * All properties and methods listed here are specific to the Flash version only.
             *
             *
             */
            class _Flash {
                constructor();
                /**
                 * (Flash only) throttles the upload to a certain amount of files at a time.
                 * By default, Flash uploads file one at a time to the server, but in parallel.
                 * Firefox will try to queue all files at once, leading to problems. Set this
                 * to the amount to upload in parallel at a time.
                 * Generally, 1 should work fine, but you can experiment with queuing more than
                 * one at a time.
                 * This is of course ignored if selectMultipleFiles equals false.
                 *
                 */
                "deferredUploading": number;
                /**
                 * Re-implemented. devMode increases the logging, adding style tracing from the SWF.
                 *
                 */
                "devMode": Object;
                /**
                 * If true, outputs traces from the SWF to console. What exactly gets passed
                 * is very relative, and depends upon what traces have been left in the DEFT SWF.
                 *
                 */
                "isDebug": boolean;
                /**
                 * If true, then flash request is sent with a value that changes with each request (timestamp)
                 *
                 */
                "preventCache": boolean;
                /**
                 * The amount of time given to the uploaded file
                 * to wait for a server response. After this amount
                 * of time, the onComplete is fired but with a 'server timeout'
                 * error in the returned item.
                 *
                 */
                "serverTimeout": number;
                /**
                 * If true, will not verify that the server was sent the correct format.
                 * This can be safely set to true. The purpose of the server side check
                 * is mainly to show the dev if they've implemented the different returns
                 * correctly.
                 *
                 */
                "skipServerCheck": boolean;
                /**
                 * Path to SWF. Can be overwritten or provided in djConfig.
                 *
                 */
                "swfPath": string;
                /**
                 *
                 */
                flashReset(): void;
                /**
                 * Returns list of currently selected files
                 *
                 */
                getFlashFileList(): any;
                /**
                 *
                 */
                postMixInProperties(): void;
                /**
                 * Stub - Flash-specific event. Fires on each selection of files
                 * and only provides the files selected on that event - not all files
                 * selected, as with HTML5
                 *
                 * @param fileArray
                 */
                onFileChange(fileArray: any): void;
                /**
                 * Stub - Flash-specific event. Fires on progress of upload
                 * and only provides a file-specific event
                 *
                 * @param fileArray
                 */
                onFileProgress(fileArray: any): void;
                /**
                 * Stub - SWF has been downloaded 100%.
                 *
                 * @param uploader
                 */
                onLoad(uploader: dojox.form.FileUploader): void;
                /**
                 * Stub - Fired when embedFlash has created the
                 * Flash object, but it has not necessarilly finished
                 * downloading, and is ready to be communicated with.
                 *
                 * @param uploader
                 */
                onReady(uploader: dojox.form.FileUploader): void;
            }
            /**
             * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/uploader/_IFrame.html
             *
             * A mixin for dojox/form/Uploader that adds Ajax upload capabilities via an iframe.
             * Only supported by IE, due to the specific iFrame hack used.  Progress events are not
             * supported.
             *
             *
             */
            class _IFrame {
                constructor();
                /**
                 *
                 */
                postMixInProperties(): void;
                /**
                 * Internal. You could use this, but you should use upload() or submit();
                 * which can also handle the post data.
                 *
                 * @param data
                 */
                uploadIFrame(data: any): void;
            }
            /**
             * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/uploader/_HTML5.html
             *
             * A mixin for dojox/form/Uploader that adds HTML5 multiple-file upload capabilities and
             * progress events.
             * Note that this does not add these capabilities to browsers that don't support them.
             * For IE8 or older browsers, _IFrame or _Flash mixins will be used.
             *
             */
            class _HTML5 {
                constructor();
                /**
                 *
                 */
                "errMsg": string;
                /**
                 *
                 */
                "uploadType": string;
                /**
                 * Add a dom node which will act as the drop target area so user
                 * can drop files to this node.
                 * If onlyConnectDrop is true, dragenter/dragover/dragleave events
                 * won't be connected to dojo.stopEvent, and they need to be
                 * canceled by user code to allow DnD files to happen.
                 * This API is only available in HTML5 plugin (only HTML5 allows
                 * DnD files).
                 *
                 * @param node
                 * @param onlyConnectDrop               Optional
                 */
                addDropTarget(node: any, onlyConnectDrop: boolean): void;
                /**
                 *
                 */
                createXhr(): any;
                /**
                 *
                 */
                postCreate(): void;
                /**
                 *
                 */
                postMixInProperties(): void;
                /**
                 * See: dojox.form.Uploader.upload
                 *
                 * @param formData               Optional
                 */
                upload(formData: Object): void;
            }
            /**
             * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/uploader/_Base.html
             *
             * The Base class used for dojox/form/Uploader and dojox/form/uploader/FileList.
             *
             * Should not be used as a standalone. To be mixed in with other classes.
             *
             * @param params Hash of initialization parameters for widget, including scalar values (like title, duration etc.)and functions, typically callbacks like onClick.The hash can contain any of the widget's properties, excluding read-only properties.
             * @param srcNodeRef       OptionalIf a srcNodeRef (DOM node) is specified:use srcNodeRef.innerHTML as my contentsif this is a behavioral widget then apply behavior to that srcNodeRefotherwise, replace srcNodeRef with my generated DOM tree
             */
            class _Base extends dijit._Widget implements dijit._TemplatedMixin, dijit._WidgetsInTemplateMixin {
                constructor(params?: Object, srcNodeRef?: HTMLElement);
                /**
                 * Object to which attach points and events will be scoped.  Defaults
                 * to 'this'.
                 *
                 */
                "attachScope": Object;
                set(property:"attachScope", value: Object): void;
                get(property:"attachScope"): Object;
                watch(property:"attachScope", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
                /**
                 * Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute
                 * for each XXX attribute to be mapped to the DOM.
                 *
                 * attributeMap sets up a "binding" between attributes (aka properties)
                 * of the widget and the widget's DOM.
                 * Changes to widget attributes listed in attributeMap will be
                 * reflected into the DOM.
                 *
                 * For example, calling set('title', 'hello')
                 * on a TitlePane will automatically cause the TitlePane's DOM to update
                 * with the new title.
                 *
                 * attributeMap is a hash where the key is an attribute of the widget,
                 * and the value reflects a binding to a:
                 *
                 * DOM node attribute
                 *   focus: {node: "focusNode", type: "attribute"}
                 * Maps this.focus to this.focusNode.focus
                 *
                 * DOM node innerHTML
                 *   title: { node: "titleNode", type: "innerHTML" }
                 * Maps this.title to this.titleNode.innerHTML
                 *
                 * DOM node innerText
                 *   title: { node: "titleNode", type: "innerText" }
                 * Maps this.title to this.titleNode.innerText
                 *
                 * DOM node CSS class
                 *   myClass: { node: "domNode", type: "class" }
                 * Maps this.myClass to this.domNode.className
                 *
                 * If the value is an array, then each element in the array matches one of the
                 * formats of the above list.
                 *
                 * There are also some shorthands for backwards compatibility:
                 *
                 * string --> { node: string, type: "attribute" }, for example:
                 * "focusNode" ---> { node: "focusNode", type: "attribute" }
                 * "" --> { node: "domNode", type: "attribute" }
                 *
                 */
                "attributeMap": Object;
                set(property:"attributeMap", value: Object): void;
                get(property:"attributeMap"): Object;
                watch(property:"attributeMap", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
                /**
                 * Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate
                 * widget state.
                 *
                 */
                "baseClass": string;
                set(property:"baseClass", value: string): void;
                get(property:"baseClass"): string;
                watch(property:"baseClass", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
                /**
                 *
                 */
                "class": string;
                set(property:"class", value: string): void;
                get(property:"class"): string;
                watch(property:"class", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
                /**
                 * Designates where children of the source DOM node will be placed.
                 * "Children" in this case refers to both DOM nodes and widgets.
                 * For example, for myWidget:
                 *
                 * <div data-dojo-type=myWidget>
                 *     <b> here's a plain DOM node
                 *     <span data-dojo-type=subWidget>and a widget</span>
                 *     <i> and another plain DOM node </i>
                 * </div>
                 * containerNode would point to:
                 *
                 * <b> here's a plain DOM node
                 * <span data-dojo-type=subWidget>and a widget</span>
                 * <i> and another plain DOM node </i>
                 * In templated widgets, "containerNode" is set via a
                 * data-dojo-attach-point assignment.
                 *
                 * containerNode must be defined for any widget that accepts innerHTML
                 * (like ContentPane or BorderContainer or even Button), and conversely
                 * is null for widgets that don't, like TextBox.
                 *
                 */
                "containerNode": HTMLElement;
                set(property:"containerNode", value: HTMLElement): void;
                get(property:"containerNode"): HTMLElement;
                watch(property:"containerNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
                /**
                 * Used to provide a context require to the dojo/parser in order to be
                 * able to use relative MIDs (e.g. ./Widget) in the widget's template.
                 *
                 */
                "contextRequire": Function;
                set(property:"contextRequire", value: Function): void;
                get(property:"contextRequire"): Function;
                watch(property:"contextRequire", callback:{(property?:string, oldValue?:Function, newValue?: Function):void}) :{unwatch():void}
                /**
                 * Bi-directional support, as defined by the HTML DIR
                 * attribute. Either left-to-right "ltr" or right-to-left "rtl".  If undefined, widgets renders in page's
                 * default direction.
                 *
                 */
                "dir": string;
                set(property:"dir", value: string): void;
                get(property:"dir"): string;
                watch(property:"dir", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
                /**
                 * This is our visible representation of the widget! Other DOM
                 * Nodes may by assigned to other properties, usually through the
                 * template system's data-dojo-attach-point syntax, but the domNode
                 * property is the canonical "top level" node in widget UI.
                 *
                 */
                "domNode": HTMLElement;
                set(property:"domNode", value: HTMLElement): void;
                get(property:"domNode"): HTMLElement;
                watch(property:"domNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
                /**
                 * This widget or a widget it contains has focus, or is "active" because
                 * it was recently clicked.
                 *
                 */
                "focused": boolean;
                set(property:"focused", value: boolean): void;
                get(property:"focused"): boolean;
                watch(property:"focused", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
                /**
                 * A unique, opaque ID string that can be assigned by users or by the
                 * system. If the developer passes an ID which is known not to be
                 * unique, the specified ID is ignored and the system-generated ID is
                 * used instead.
                 *
                 */
                "id": string;
                set(property:"id", value: string): void;
                get(property:"id"): string;
                watch(property:"id", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
                /**
                 * Rarely used.  Overrides the default Dojo locale used to render this widget,
                 * as defined by the HTML LANG attribute.
                 * Value must be among the list of locales specified during by the Dojo bootstrap,
                 * formatted according to RFC 3066 (like en-us).
                 *
                 */
                "lang": string;
                set(property:"lang", value: string): void;
                get(property:"lang"): string;
                watch(property:"lang", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
                /**
                 *
                 */
                "observer": string;
                set(property:"observer", value: string): void;
                get(property:"observer"): string;
                watch(property:"observer", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
                /**
                 * The document this widget belongs to.  If not specified to constructor, will default to
                 * srcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global
                 *
                 */
                "ownerDocument": Object;
                set(property:"ownerDocument", value: Object): void;
                get(property:"ownerDocument"): Object;
                watch(property:"ownerDocument", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
                /**
                 *
                 */
                "searchContainerNode": boolean;
                set(property:"searchContainerNode", value: boolean): void;
                get(property:"searchContainerNode"): boolean;
                watch(property:"searchContainerNode", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
                /**
                 * pointer to original DOM node
                 *
                 */
                "srcNodeRef": HTMLElement;
                set(property:"srcNodeRef", value: HTMLElement): void;
                get(property:"srcNodeRef"): HTMLElement;
                watch(property:"srcNodeRef", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
                /**
                 * HTML style attributes as cssText string or name/value hash
                 *
                 */
                "style": string;
                set(property:"style", value: string): void;
                get(property:"style"): string;
                watch(property:"style", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
                /**
                 * Path to template (HTML file) for this widget relative to dojo.baseUrl.
                 * Deprecated: use templateString with require([... "dojo/text!..."], ...) instead
                 *
                 */
                "templatePath": string;
                set(property:"templatePath", value: string): void;
                get(property:"templatePath"): string;
                watch(property:"templatePath", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
                /**
                 * A string that represents the widget template.
                 * Use in conjunction with dojo.cache() to load from a file.
                 *
                 */
                "templateString": string;
                set(property:"templateString", value: string): void;
                get(property:"templateString"): string;
                watch(property:"templateString", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
                /**
                 * HTML title attribute.
                 *
                 * For form widgets this specifies a tooltip to display when hovering over
                 * the widget (just like the native HTML title attribute).
                 *
                 * For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,
                 * etc., it's used to specify the tab label, accordion pane title, etc.  In this case it's
                 * interpreted as HTML.
                 *
                 */
                "title": string;
                set(property:"title", value: string): void;
                get(property:"title"): string;
                watch(property:"title", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
                /**
                 * When this widget's title attribute is used to for a tab label, accordion pane title, etc.,
                 * this specifies the tooltip to appear when the mouse is hovered over that text.
                 *
                 */
                "tooltip": string;
                set(property:"tooltip", value: string): void;
                get(property:"tooltip"): string;
                watch(property:"tooltip", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
                /**
                 * Should we parse the template to find widgets that might be
                 * declared in markup inside it?  (Remove for 2.0 and assume true)
                 *
                 */
                "widgetsInTemplate": boolean;
                set(property:"widgetsInTemplate", value: boolean): void;
                get(property:"widgetsInTemplate"): boolean;
                watch(property:"widgetsInTemplate", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
                /**
                 * This method is deprecated, use get() or set() directly.
                 *
                 * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
                 * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
                 */
                attr(name: String, value: Object): any;
                /**
                 * This method is deprecated, use get() or set() directly.
                 *
                 * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
                 * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
                 */
                attr(name: Object, value: Object): any;
                /**
                 * Construct the UI for this widget, setting this.domNode.
                 * Most widgets will mixin dijit._TemplatedMixin, which implements this method.
                 *
                 */
                buildRendering(): void;
                /**
                 * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
                 *
                 * Connects specified obj/event to specified method of this object
                 * and registers for disconnect() on widget destroy.
                 *
                 * Provide widget-specific analog to dojo.connect, except with the
                 * implicit use of this widget as the target object.
                 * Events connected with this.connect are disconnected upon
                 * destruction.
                 *
                 * @param obj
                 * @param event
                 * @param method
                 */
                connect(obj: Object, event: String, method: String): any;
                /**
                 * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
                 *
                 * Connects specified obj/event to specified method of this object
                 * and registers for disconnect() on widget destroy.
                 *
                 * Provide widget-specific analog to dojo.connect, except with the
                 * implicit use of this widget as the target object.
                 * Events connected with this.connect are disconnected upon
                 * destruction.
                 *
                 * @param obj
                 * @param event
                 * @param method
                 */
                connect(obj: any, event: String, method: String): any;
                /**
                 * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
                 *
                 * Connects specified obj/event to specified method of this object
                 * and registers for disconnect() on widget destroy.
                 *
                 * Provide widget-specific analog to dojo.connect, except with the
                 * implicit use of this widget as the target object.
                 * Events connected with this.connect are disconnected upon
                 * destruction.
                 *
                 * @param obj
                 * @param event
                 * @param method
                 */
                connect(obj: Object, event: Function, method: String): any;
                /**
                 * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
                 *
                 * Connects specified obj/event to specified method of this object
                 * and registers for disconnect() on widget destroy.
                 *
                 * Provide widget-specific analog to dojo.connect, except with the
                 * implicit use of this widget as the target object.
                 * Events connected with this.connect are disconnected upon
                 * destruction.
                 *
                 * @param obj
                 * @param event
                 * @param method
                 */
                connect(obj: any, event: Function, method: String): any;
                /**
                 * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
                 *
                 * Connects specified obj/event to specified method of this object
                 * and registers for disconnect() on widget destroy.
                 *
                 * Provide widget-specific analog to dojo.connect, except with the
                 * implicit use of this widget as the target object.
                 * Events connected with this.connect are disconnected upon
                 * destruction.
                 *
                 * @param obj
                 * @param event
                 * @param method
                 */
                connect(obj: Object, event: String, method: Function): any;
                /**
                 * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
                 *
                 * Connects specified obj/event to specified method of this object
                 * and registers for disconnect() on widget destroy.
                 *
                 * Provide widget-specific analog to dojo.connect, except with the
                 * implicit use of this widget as the target object.
                 * Events connected with this.connect are disconnected upon
                 * destruction.
                 *
                 * @param obj
                 * @param event
                 * @param method
                 */
                connect(obj: any, event: String, method: Function): any;
                /**
                 * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
                 *
                 * Connects specified obj/event to specified method of this object
                 * and registers for disconnect() on widget destroy.
                 *
                 * Provide widget-specific analog to dojo.connect, except with the
                 * implicit use of this widget as the target object.
                 * Events connected with this.connect are disconnected upon
                 * destruction.
                 *
                 * @param obj
                 * @param event
                 * @param method
                 */
                connect(obj: Object, event: Function, method: Function): any;
                /**
                 * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
                 *
                 * Connects specified obj/event to specified method of this object
                 * and registers for disconnect() on widget destroy.
                 *
                 * Provide widget-specific analog to dojo.connect, except with the
                 * implicit use of this widget as the target object.
                 * Events connected with this.connect are disconnected upon
                 * destruction.
                 *
                 * @param obj
                 * @param event
                 * @param method
                 */
                connect(obj: any, event: Function, method: Function): any;
                /**
                 * Internal. Connects to form if there is one.
                 *
                 */
                connectForm(): void;
                /**
                 * Converts bytes. Returns an object with all conversions. The "value" property is
                 * considered the most likely desired result.
                 *
                 * @param bytes
                 */
                convertBytes(bytes: any): Object;
                /**
                 * Wrapper to setTimeout to avoid deferred functions executing
                 * after the originating widget has been destroyed.
                 * Returns an object handle with a remove method (that returns null) (replaces clearTimeout).
                 *
                 * @param fcn Function reference.
                 * @param delay               OptionalDelay, defaults to 0.
                 */
                defer(fcn: Function, delay: number): Object;
                /**
                 * Destroy this widget, but not its descendants.  Descendants means widgets inside of
                 * this.containerNode.   Will also destroy any resources (including widgets) registered via this.own().
                 *
                 * This method will also destroy internal widgets such as those created from a template,
                 * assuming those widgets exist inside of this.domNode but outside of this.containerNode.
                 *
                 * For 2.0 it's planned that this method will also destroy descendant widgets, so apps should not
                 * depend on the current ability to destroy a widget without destroying its descendants.   Generally
                 * they should use destroyRecursive() for widgets with children.
                 *
                 * @param preserveDom If true, this method will leave the original DOM structure alone.Note: This will not yet work with _TemplatedMixin widgets
                 */
                destroy(preserveDom?: boolean): void;
                /**
                 * Recursively destroy the children of this widget and their
                 * descendants.
                 *
                 * @param preserveDom               OptionalIf true, the preserveDom attribute is passed to all descendantwidget's .destroy() method. Not for use with _Templatedwidgets.
                 */
                destroyDescendants(preserveDom: boolean): void;
                /**
                 * Destroy this widget and its descendants
                 * This is the generic "destructor" function that all widget users
                 * should call to cleanly discard with a widget. Once a widget is
                 * destroyed, it is removed from the manager object.
                 *
                 * @param preserveDom               OptionalIf true, this method will leave the original DOM structurealone of descendant Widgets. Note: This will NOT work withdijit._TemplatedMixin widgets.
                 */
                destroyRecursive(preserveDom: boolean): void;
                /**
                 * Destroys the DOM nodes associated with this widget.
                 *
                 * @param preserveDom               OptionalIf true, this method will leave the original DOM structure aloneduring tear-down. Note: this will not work with _Templatedwidgets yet.
                 */
                destroyRendering(preserveDom?: boolean): void;
                /**
                 * Deprecated, will be removed in 2.0, use handle.remove() instead.
                 *
                 * Disconnects handle created by connect.
                 *
                 * @param handle
                 */
                disconnect(handle: any): void;
                /**
                 * Used by widgets to signal that a synthetic event occurred, ex:
                 *
                 * myWidget.emit("attrmodified-selectedChildWidget", {}).
                 * Emits an event on this.domNode named type.toLowerCase(), based on eventObj.
                 * Also calls onType() method, if present, and returns value from that method.
                 * By default passes eventObj to callback, but will pass callbackArgs instead, if specified.
                 * Modifies eventObj by adding missing parameters (bubbles, cancelable, widget).
                 *
                 * @param type
                 * @param eventObj               Optional
                 * @param callbackArgs               Optional
                 */
                emit(type: String, eventObj: Object, callbackArgs: any[]): any;
                /**
                 * Get a property from a widget.
                 * Get a named property from a widget. The property may
                 * potentially be retrieved via a getter method. If no getter is defined, this
                 * just retrieves the object's property.
                 *
                 * For example, if the widget has properties foo and bar
                 * and a method named _getFooAttr(), calling:
                 * myWidget.get("foo") would be equivalent to calling
                 * widget._getFooAttr() and myWidget.get("bar")
                 * would be equivalent to the expression
                 * widget.bar2
                 *
                 * @param name The property to get.
                 */
                get(name: any): any;
                /**
                 * Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent
                 * is this widget.   Note that it does not return all descendants, but rather just direct children.
                 * Analogous to Node.childNodes,
                 * except containing widgets rather than DOMNodes.
                 *
                 * The result intentionally excludes internally created widgets (a.k.a. supporting widgets)
                 * outside of this.containerNode.
                 *
                 * Note that the array returned is a simple array.  Application code should not assume
                 * existence of methods like forEach().
                 *
                 */
                getChildren(): any[];
                /**
                 * Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
                 * This method should generally be avoided as it returns widgets declared in templates, which are
                 * supposed to be internal/hidden, but it's left here for back-compat reasons.
                 *
                 */
                getDescendants(): any[];
                /**
                 * Gets the extension of a file
                 *
                 * @param name
                 */
                getFileType(name: String): any;
                /**
                 * Finds the parent form of the Uploader, if it exists.
                 *
                 */
                getForm(): HTMLElement;
                /**
                 * Returns the mime type that should be used in an HTML5 upload form. Return result
                 * may change as the current use is very generic.
                 *
                 */
                getMimeType(): String;
                /**
                 * Returns the parent widget of this widget.
                 *
                 */
                getParent(): any;
                /**
                 * Finds the URL to upload to, whether it be the action in the parent form, this.url or
                 * this.uploadUrl
                 *
                 */
                getUrl(): any;
                /**
                 * Return true if this widget can currently be focused
                 * and false if not
                 *
                 */
                isFocusable(): any;
                /**
                 * Return this widget's explicit or implicit orientation (true for LTR, false for RTL)
                 *
                 */
                isLeftToRight(): any;
                /**
                 *
                 * @param type protected
                 * @param func
                 */
                on(type: String, func: Function): any;
                /**
                 *
                 * @param type protected
                 * @param func
                 */
                on(type: Function, func: Function): any;
                /**
                 * Track specified handles and remove/destroy them when this instance is destroyed, unless they were
                 * already removed/destroyed manually.
                 *
                 */
                own(): any;
                /**
                 * Place this widget somewhere in the DOM based
                 * on standard domConstruct.place() conventions.
                 * A convenience function provided in all _Widgets, providing a simple
                 * shorthand mechanism to put an existing (or newly created) Widget
                 * somewhere in the dom, and allow chaining.
                 *
                 * @param reference Widget, DOMNode, or id of widget or DOMNode
                 * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
                 */
                placeAt(reference: String, position: String): any;
                /**
                 * Place this widget somewhere in the DOM based
                 * on standard domConstruct.place() conventions.
                 * A convenience function provided in all _Widgets, providing a simple
                 * shorthand mechanism to put an existing (or newly created) Widget
                 * somewhere in the dom, and allow chaining.
                 *
                 * @param reference Widget, DOMNode, or id of widget or DOMNode
                 * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
                 */
                placeAt(reference: HTMLElement, position: String): any;
                /**
                 * Place this widget somewhere in the DOM based
                 * on standard domConstruct.place() conventions.
                 * A convenience function provided in all _Widgets, providing a simple
                 * shorthand mechanism to put an existing (or newly created) Widget
                 * somewhere in the dom, and allow chaining.
                 *
                 * @param reference Widget, DOMNode, or id of widget or DOMNode
                 * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
                 */
                placeAt(reference: dijit._WidgetBase, position: String): any;
                /**
                 * Place this widget somewhere in the DOM based
                 * on standard domConstruct.place() conventions.
                 * A convenience function provided in all _Widgets, providing a simple
                 * shorthand mechanism to put an existing (or newly created) Widget
                 * somewhere in the dom, and allow chaining.
                 *
                 * @param reference Widget, DOMNode, or id of widget or DOMNode
                 * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
                 */
                placeAt(reference: String, position: number): any;
                /**
                 * Place this widget somewhere in the DOM based
                 * on standard domConstruct.place() conventions.
                 * A convenience function provided in all _Widgets, providing a simple
                 * shorthand mechanism to put an existing (or newly created) Widget
                 * somewhere in the dom, and allow chaining.
                 *
                 * @param reference Widget, DOMNode, or id of widget or DOMNode
                 * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
                 */
                placeAt(reference: HTMLElement, position: number): any;
                /**
                 * Place this widget somewhere in the DOM based
                 * on standard domConstruct.place() conventions.
                 * A convenience function provided in all _Widgets, providing a simple
                 * shorthand mechanism to put an existing (or newly created) Widget
                 * somewhere in the dom, and allow chaining.
                 *
                 * @param reference Widget, DOMNode, or id of widget or DOMNode
                 * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
                 */
                placeAt(reference: dijit._WidgetBase, position: number): any;
                /**
                 *
                 */
                postCreate(): void;
                /**
                 * Called after the parameters to the widget have been read-in,
                 * but before the widget template is instantiated. Especially
                 * useful to set properties that are referenced in the widget
                 * template.
                 *
                 */
                postMixInProperties(): void;
                /**
                 * Set a property on a widget
                 * Sets named properties on a widget which may potentially be handled by a
                 * setter in the widget.
                 *
                 * For example, if the widget has properties foo and bar
                 * and a method named _setFooAttr(), calling
                 * myWidget.set("foo", "Howdy!") would be equivalent to calling
                 * widget._setFooAttr("Howdy!") and myWidget.set("bar", 3)
                 * would be equivalent to the statement widget.bar = 3;
                 *
                 * set() may also be called with a hash of name/value pairs, ex:
                 *
                 * myWidget.set({
                 *     foo: "Howdy",
                 *     bar: 3
                 * });
                 * This is equivalent to calling set(foo, "Howdy") and set(bar, 3)
                 *
                 * @param name The property to set.
                 * @param value The value to set in the property.
                 */
                set(name: any, value: any): any;
                /**
                 * Deprecated.  Use set() instead.
                 *
                 * @param attr
                 * @param value
                 */
                setAttribute(attr: String, value: any): void;
                /**
                 * Processing after the DOM fragment is added to the document
                 * Called after a widget and its children have been created and added to the page,
                 * and all related widgets have finished their create() cycle, up through postCreate().
                 *
                 * Note that startup() may be called while the widget is still hidden, for example if the widget is
                 * inside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.
                 * For widgets that need to do layout, it's best to put that layout code inside resize(), and then
                 * extend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.
                 *
                 */
                startup(): void;
                /**
                 * Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.
                 *
                 * Subscribes to the specified topic and calls the specified method
                 * of this object and registers for unsubscribe() on widget destroy.
                 *
                 * Provide widget-specific analog to dojo.subscribe, except with the
                 * implicit use of this widget as the target object.
                 *
                 * @param t The topic
                 * @param method The callback
                 */
                subscribe(t: String, method: Function): any;
                /**
                 * Does feature testing for uploader capabilities. (No browser sniffing - yay)
                 *
                 * @param what
                 */
                supports(what: any): any;
                /**
                 * Returns a string that represents the widget.
                 * When a widget is cast to a string, this method will be used to generate the
                 * output. Currently, it does not implement any sort of reversible
                 * serialization.
                 *
                 */
                toString(): string;
                /**
                 * Deprecated. Override destroy() instead to implement custom widget tear-down
                 * behavior.
                 *
                 */
                uninitialize(): boolean;
                /**
                 * Deprecated, will be removed in 2.0, use handle.remove() instead.
                 *
                 * Unsubscribes handle created by this.subscribe.
                 * Also removes handle from this widget's list of subscriptions
                 *
                 * @param handle
                 */
                unsubscribe(handle: Object): void;
                /**
                 * Watches a property for changes
                 *
                 * @param name               OptionalIndicates the property to watch. This is optional (the callback may be theonly parameter), and if omitted, all the properties will be watched
                 * @param callback The function to execute when the property changes. This will be called afterthe property has been changed. The callback will be called with the |this|set to the instance, the first argument as the name of the property, thesecond argument as the old value and the third argument as the new value.
                 */
                watch(property: string, callback:{(property?:string, oldValue?:any, newValue?: any):void}) :{unwatch():void};
                /**
                 * Static method to get a template based on the templatePath or
                 * templateString key
                 */
                getCachedTemplate(): any;
                /**
                 * Called when the widget stops being "active" because
                 * focus moved to something outside of it, or the user
                 * clicked somewhere outside of it, or the widget was
                 * hidden.
                 *
                 */
                onBlur(): void;
                /**
                 * Connect to this function to receive notifications of mouse click events.
                 *
                 * @param event mouse Event
                 */
                onClick(event: any): void;
                /**
                 * Called when this widget is being displayed as a popup (ex: a Calendar popped
                 * up from a DateTextBox), and it is hidden.
                 * This is called from the dijit.popup code, and should not be called directly.
                 *
                 * Also used as a parameter for children of dijit/layout/StackContainer or subclasses.
                 * Callback if a user tries to close the child.   Child will be closed if this function returns true.
                 *
                 */
                onClose(): boolean;
                /**
                 * Connect to this function to receive notifications of mouse double click events.
                 *
                 * @param event mouse Event
                 */
                onDblClick(event: any): void;
                /**
                 * Called when the widget becomes "active" because
                 * it or a widget inside of it either has focus, or has recently
                 * been clicked.
                 *
                 */
                onFocus(): void;
                /**
                 * Called when another widget becomes the selected pane in a
                 * dijit/layout/TabContainer, dijit/layout/StackContainer,
                 * dijit/layout/AccordionContainer, etc.
                 *
                 * Also called to indicate hide of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
                 *
                 */
                onHide(): void;
                /**
                 * Connect to this function to receive notifications of keys being pressed down.
                 *
                 * @param event key Event
                 */
                onKeyDown(event: any): void;
                /**
                 * Connect to this function to receive notifications of printable keys being typed.
                 *
                 * @param event key Event
                 */
                onKeyPress(event: any): void;
                /**
                 * Connect to this function to receive notifications of keys being released.
                 *
                 * @param event key Event
                 */
                onKeyUp(event: any): void;
                /**
                 * Connect to this function to receive notifications of when the mouse button is pressed down.
                 *
                 * @param event mouse Event
                 */
                onMouseDown(event: any): void;
                /**
                 * Connect to this function to receive notifications of when the mouse moves onto this widget.
                 *
                 * @param event mouse Event
                 */
                onMouseEnter(event: any): void;
                /**
                 * Connect to this function to receive notifications of when the mouse moves off of this widget.
                 *
                 * @param event mouse Event
                 */
                onMouseLeave(event: any): void;
                /**
                 * Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.
                 *
                 * @param event mouse Event
                 */
                onMouseMove(event: any): void;
                /**
                 * Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.
                 *
                 * @param event mouse Event
                 */
                onMouseOut(event: any): void;
                /**
                 * Connect to this function to receive notifications of when the mouse moves onto nodes contained within this widget.
                 *
                 * @param event mouse Event
                 */
                onMouseOver(event: any): void;
                /**
                 * Connect to this function to receive notifications of when the mouse button is released.
                 *
                 * @param event mouse Event
                 */
                onMouseUp(event: any): void;
                /**
                 * Called when this widget becomes the selected pane in a
                 * dijit/layout/TabContainer, dijit/layout/StackContainer,
                 * dijit/layout/AccordionContainer, etc.
                 *
                 * Also called to indicate display of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
                 *
                 */
                onShow(): void;
            }
            /**
             * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/uploader/FileList.html
             *
             * A simple widget that provides a list of the files currently selected by
             * dojox/form/Uploader
             * There is a required CSS file: resources/UploaderFileList.css.
             * This is a very simple widget, and not beautifully styled. It is here mainly for test
             * cases, but could very easily be used, extended, modified, or copied.
             *
             * @param params Hash of initialization parameters for widget, including scalar values (like title, duration etc.)and functions, typically callbacks like onClick.The hash can contain any of the widget's properties, excluding read-only properties.
             * @param srcNodeRef       OptionalIf a srcNodeRef (DOM node) is specified:use srcNodeRef.innerHTML as my contentsif this is a behavioral widget then apply behavior to that srcNodeRefotherwise, replace srcNodeRef with my generated DOM tree
             */
            class FileList extends dojox.form.uploader._Base {
                constructor(params?: Object, srcNodeRef?: HTMLElement);
                /**
                 * Object to which attach points and events will be scoped.  Defaults
                 * to 'this'.
                 *
                 */
                "attachScope": Object;
                set(property:"attachScope", value: Object): void;
                get(property:"attachScope"): Object;
                watch(property:"attachScope", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
                /**
                 * Deprecated. Instead of attributeMap, widget should have a _setXXXAttr attribute
                 * for each XXX attribute to be mapped to the DOM.
                 *
                 * attributeMap sets up a "binding" between attributes (aka properties)
                 * of the widget and the widget's DOM.
                 * Changes to widget attributes listed in attributeMap will be
                 * reflected into the DOM.
                 *
                 * For example, calling set('title', 'hello')
                 * on a TitlePane will automatically cause the TitlePane's DOM to update
                 * with the new title.
                 *
                 * attributeMap is a hash where the key is an attribute of the widget,
                 * and the value reflects a binding to a:
                 *
                 * DOM node attribute
                 *   focus: {node: "focusNode", type: "attribute"}
                 * Maps this.focus to this.focusNode.focus
                 *
                 * DOM node innerHTML
                 *   title: { node: "titleNode", type: "innerHTML" }
                 * Maps this.title to this.titleNode.innerHTML
                 *
                 * DOM node innerText
                 *   title: { node: "titleNode", type: "innerText" }
                 * Maps this.title to this.titleNode.innerText
                 *
                 * DOM node CSS class
                 *   myClass: { node: "domNode", type: "class" }
                 * Maps this.myClass to this.domNode.className
                 *
                 * If the value is an array, then each element in the array matches one of the
                 * formats of the above list.
                 *
                 * There are also some shorthands for backwards compatibility:
                 *
                 * string --> { node: string, type: "attribute" }, for example:
                 * "focusNode" ---> { node: "focusNode", type: "attribute" }
                 * "" --> { node: "domNode", type: "attribute" }
                 *
                 */
                "attributeMap": Object;
                set(property:"attributeMap", value: Object): void;
                get(property:"attributeMap"): Object;
                watch(property:"attributeMap", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
                /**
                 * Root CSS class of the widget (ex: dijitTextBox), used to construct CSS classes to indicate
                 * widget state.
                 *
                 */
                "baseClass": string;
                set(property:"baseClass", value: string): void;
                get(property:"baseClass"): string;
                watch(property:"baseClass", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
                /**
                 *
                 */
                "class": string;
                set(property:"class", value: string): void;
                get(property:"class"): string;
                watch(property:"class", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
                /**
                 * Designates where children of the source DOM node will be placed.
                 * "Children" in this case refers to both DOM nodes and widgets.
                 * For example, for myWidget:
                 *
                 * <div data-dojo-type=myWidget>
                 *     <b> here's a plain DOM node
                 *     <span data-dojo-type=subWidget>and a widget</span>
                 *     <i> and another plain DOM node </i>
                 * </div>
                 * containerNode would point to:
                 *
                 * <b> here's a plain DOM node
                 * <span data-dojo-type=subWidget>and a widget</span>
                 * <i> and another plain DOM node </i>
                 * In templated widgets, "containerNode" is set via a
                 * data-dojo-attach-point assignment.
                 *
                 * containerNode must be defined for any widget that accepts innerHTML
                 * (like ContentPane or BorderContainer or even Button), and conversely
                 * is null for widgets that don't, like TextBox.
                 *
                 */
                "containerNode": HTMLElement;
                set(property:"containerNode", value: HTMLElement): void;
                get(property:"containerNode"): HTMLElement;
                watch(property:"containerNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
                /**
                 * Used to provide a context require to the dojo/parser in order to be
                 * able to use relative MIDs (e.g. ./Widget) in the widget's template.
                 *
                 */
                "contextRequire": Function;
                set(property:"contextRequire", value: Function): void;
                get(property:"contextRequire"): Function;
                watch(property:"contextRequire", callback:{(property?:string, oldValue?:Function, newValue?: Function):void}) :{unwatch():void}
                /**
                 * Bi-directional support, as defined by the HTML DIR
                 * attribute. Either left-to-right "ltr" or right-to-left "rtl".  If undefined, widgets renders in page's
                 * default direction.
                 *
                 */
                "dir": string;
                set(property:"dir", value: string): void;
                get(property:"dir"): string;
                watch(property:"dir", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
                /**
                 * This is our visible representation of the widget! Other DOM
                 * Nodes may by assigned to other properties, usually through the
                 * template system's data-dojo-attach-point syntax, but the domNode
                 * property is the canonical "top level" node in widget UI.
                 *
                 */
                "domNode": HTMLElement;
                set(property:"domNode", value: HTMLElement): void;
                get(property:"domNode"): HTMLElement;
                watch(property:"domNode", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
                /**
                 * This widget or a widget it contains has focus, or is "active" because
                 * it was recently clicked.
                 *
                 */
                "focused": boolean;
                set(property:"focused", value: boolean): void;
                get(property:"focused"): boolean;
                watch(property:"focused", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
                /**
                 * The label for the file name column.
                 *
                 */
                "headerFilename": string;
                set(property:"headerFilename", value: string): void;
                get(property:"headerFilename"): string;
                watch(property:"headerFilename", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
                /**
                 * The label for the file size column.
                 *
                 */
                "headerFilesize": string;
                set(property:"headerFilesize", value: string): void;
                get(property:"headerFilesize"): string;
                watch(property:"headerFilesize", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
                /**
                 * The label for the index column.
                 *
                 */
                "headerIndex": string;
                set(property:"headerIndex", value: string): void;
                get(property:"headerIndex"): string;
                watch(property:"headerIndex", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
                /**
                 * The label for the file type column.
                 *
                 */
                "headerType": string;
                set(property:"headerType", value: string): void;
                get(property:"headerType"): string;
                watch(property:"headerType", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
                /**
                 * A unique, opaque ID string that can be assigned by users or by the
                 * system. If the developer passes an ID which is known not to be
                 * unique, the specified ID is ignored and the system-generated ID is
                 * used instead.
                 *
                 */
                "id": string;
                set(property:"id", value: string): void;
                get(property:"id"): string;
                watch(property:"id", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
                /**
                 * Rarely used.  Overrides the default Dojo locale used to render this widget,
                 * as defined by the HTML LANG attribute.
                 * Value must be among the list of locales specified during by the Dojo bootstrap,
                 * formatted according to RFC 3066 (like en-us).
                 *
                 */
                "lang": string;
                set(property:"lang", value: string): void;
                get(property:"lang"): string;
                watch(property:"lang", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
                /**
                 *
                 */
                "observer": string;
                set(property:"observer", value: string): void;
                get(property:"observer"): string;
                watch(property:"observer", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
                /**
                 * The document this widget belongs to.  If not specified to constructor, will default to
                 * srcNodeRef.ownerDocument, or if no sourceRef specified, then to the document global
                 *
                 */
                "ownerDocument": Object;
                set(property:"ownerDocument", value: Object): void;
                get(property:"ownerDocument"): Object;
                watch(property:"ownerDocument", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
                /**
                 *
                 */
                "rowAmt": number;
                set(property:"rowAmt", value: number): void;
                get(property:"rowAmt"): number;
                watch(property:"rowAmt", callback:{(property?:string, oldValue?:number, newValue?: number):void}) :{unwatch():void}
                /**
                 *
                 */
                "searchContainerNode": boolean;
                set(property:"searchContainerNode", value: boolean): void;
                get(property:"searchContainerNode"): boolean;
                watch(property:"searchContainerNode", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
                /**
                 * pointer to original DOM node
                 *
                 */
                "srcNodeRef": HTMLElement;
                set(property:"srcNodeRef", value: HTMLElement): void;
                get(property:"srcNodeRef"): HTMLElement;
                watch(property:"srcNodeRef", callback:{(property?:string, oldValue?:HTMLElement, newValue?: HTMLElement):void}) :{unwatch():void}
                /**
                 * HTML style attributes as cssText string or name/value hash
                 *
                 */
                "style": string;
                set(property:"style", value: string): void;
                get(property:"style"): string;
                watch(property:"style", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
                /**
                 * Path to template (HTML file) for this widget relative to dojo.baseUrl.
                 * Deprecated: use templateString with require([... "dojo/text!..."], ...) instead
                 *
                 */
                "templatePath": string;
                set(property:"templatePath", value: string): void;
                get(property:"templatePath"): string;
                watch(property:"templatePath", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
                /**
                 *
                 */
                "templateString": string;
                set(property:"templateString", value: string): void;
                get(property:"templateString"): string;
                watch(property:"templateString", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
                /**
                 * HTML title attribute.
                 *
                 * For form widgets this specifies a tooltip to display when hovering over
                 * the widget (just like the native HTML title attribute).
                 *
                 * For TitlePane or for when this widget is a child of a TabContainer, AccordionContainer,
                 * etc., it's used to specify the tab label, accordion pane title, etc.  In this case it's
                 * interpreted as HTML.
                 *
                 */
                "title": string;
                set(property:"title", value: string): void;
                get(property:"title"): string;
                watch(property:"title", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
                /**
                 * When this widget's title attribute is used to for a tab label, accordion pane title, etc.,
                 * this specifies the tooltip to appear when the mouse is hovered over that text.
                 *
                 */
                "tooltip": string;
                set(property:"tooltip", value: string): void;
                get(property:"tooltip"): string;
                watch(property:"tooltip", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
                /**
                 * The dojox.form.Uploader to connect to. Use either this property of unploaderId. This
                 * property is populated if uploaderId is used.
                 *
                 */
                "uploader": Object;
                set(property:"uploader", value: Object): void;
                get(property:"uploader"): Object;
                watch(property:"uploader", callback:{(property?:string, oldValue?:Object, newValue?: Object):void}) :{unwatch():void}
                /**
                 * The id of the dojox.form.Uploader to connect to.
                 *
                 */
                "uploaderId": string;
                set(property:"uploaderId", value: string): void;
                get(property:"uploaderId"): string;
                watch(property:"uploaderId", callback:{(property?:string, oldValue?:string, newValue?: string):void}) :{unwatch():void}
                /**
                 * Should we parse the template to find widgets that might be
                 * declared in markup inside it?  (Remove for 2.0 and assume true)
                 *
                 */
                "widgetsInTemplate": boolean;
                set(property:"widgetsInTemplate", value: boolean): void;
                get(property:"widgetsInTemplate"): boolean;
                watch(property:"widgetsInTemplate", callback:{(property?:string, oldValue?:boolean, newValue?: boolean):void}) :{unwatch():void}
                /**
                 * This method is deprecated, use get() or set() directly.
                 *
                 * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
                 * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
                 */
                attr(name: String, value: Object): any;
                /**
                 * This method is deprecated, use get() or set() directly.
                 *
                 * @param name The property to get or set. If an object is passed here and nota string, its keys are used as names of attributes to be setand the value of the object as values to set in the widget.
                 * @param value               OptionalOptional. If provided, attr() operates as a setter. If omitted,the current value of the named property is returned.
                 */
                attr(name: Object, value: Object): any;
                /**
                 * Construct the UI for this widget, setting this.domNode.
                 * Most widgets will mixin dijit._TemplatedMixin, which implements this method.
                 *
                 */
                buildRendering(): void;
                /**
                 * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
                 *
                 * Connects specified obj/event to specified method of this object
                 * and registers for disconnect() on widget destroy.
                 *
                 * Provide widget-specific analog to dojo.connect, except with the
                 * implicit use of this widget as the target object.
                 * Events connected with this.connect are disconnected upon
                 * destruction.
                 *
                 * @param obj
                 * @param event
                 * @param method
                 */
                connect(obj: Object, event: String, method: String): any;
                /**
                 * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
                 *
                 * Connects specified obj/event to specified method of this object
                 * and registers for disconnect() on widget destroy.
                 *
                 * Provide widget-specific analog to dojo.connect, except with the
                 * implicit use of this widget as the target object.
                 * Events connected with this.connect are disconnected upon
                 * destruction.
                 *
                 * @param obj
                 * @param event
                 * @param method
                 */
                connect(obj: any, event: String, method: String): any;
                /**
                 * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
                 *
                 * Connects specified obj/event to specified method of this object
                 * and registers for disconnect() on widget destroy.
                 *
                 * Provide widget-specific analog to dojo.connect, except with the
                 * implicit use of this widget as the target object.
                 * Events connected with this.connect are disconnected upon
                 * destruction.
                 *
                 * @param obj
                 * @param event
                 * @param method
                 */
                connect(obj: Object, event: Function, method: String): any;
                /**
                 * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
                 *
                 * Connects specified obj/event to specified method of this object
                 * and registers for disconnect() on widget destroy.
                 *
                 * Provide widget-specific analog to dojo.connect, except with the
                 * implicit use of this widget as the target object.
                 * Events connected with this.connect are disconnected upon
                 * destruction.
                 *
                 * @param obj
                 * @param event
                 * @param method
                 */
                connect(obj: any, event: Function, method: String): any;
                /**
                 * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
                 *
                 * Connects specified obj/event to specified method of this object
                 * and registers for disconnect() on widget destroy.
                 *
                 * Provide widget-specific analog to dojo.connect, except with the
                 * implicit use of this widget as the target object.
                 * Events connected with this.connect are disconnected upon
                 * destruction.
                 *
                 * @param obj
                 * @param event
                 * @param method
                 */
                connect(obj: Object, event: String, method: Function): any;
                /**
                 * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
                 *
                 * Connects specified obj/event to specified method of this object
                 * and registers for disconnect() on widget destroy.
                 *
                 * Provide widget-specific analog to dojo.connect, except with the
                 * implicit use of this widget as the target object.
                 * Events connected with this.connect are disconnected upon
                 * destruction.
                 *
                 * @param obj
                 * @param event
                 * @param method
                 */
                connect(obj: any, event: String, method: Function): any;
                /**
                 * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
                 *
                 * Connects specified obj/event to specified method of this object
                 * and registers for disconnect() on widget destroy.
                 *
                 * Provide widget-specific analog to dojo.connect, except with the
                 * implicit use of this widget as the target object.
                 * Events connected with this.connect are disconnected upon
                 * destruction.
                 *
                 * @param obj
                 * @param event
                 * @param method
                 */
                connect(obj: Object, event: Function, method: Function): any;
                /**
                 * Deprecated, will be removed in 2.0, use this.own(on(...)) or this.own(aspect.after(...)) instead.
                 *
                 * Connects specified obj/event to specified method of this object
                 * and registers for disconnect() on widget destroy.
                 *
                 * Provide widget-specific analog to dojo.connect, except with the
                 * implicit use of this widget as the target object.
                 * Events connected with this.connect are disconnected upon
                 * destruction.
                 *
                 * @param obj
                 * @param event
                 * @param method
                 */
                connect(obj: any, event: Function, method: Function): any;
                /**
                 * Internal. Connects to form if there is one.
                 *
                 */
                connectForm(): void;
                /**
                 * Converts bytes. Returns an object with all conversions. The "value" property is
                 * considered the most likely desired result.
                 *
                 * @param bytes
                 */
                convertBytes(bytes: any): Object;
                /**
                 * Wrapper to setTimeout to avoid deferred functions executing
                 * after the originating widget has been destroyed.
                 * Returns an object handle with a remove method (that returns null) (replaces clearTimeout).
                 *
                 * @param fcn Function reference.
                 * @param delay               OptionalDelay, defaults to 0.
                 */
                defer(fcn: Function, delay: number): Object;
                /**
                 * Destroy this widget, but not its descendants.  Descendants means widgets inside of
                 * this.containerNode.   Will also destroy any resources (including widgets) registered via this.own().
                 *
                 * This method will also destroy internal widgets such as those created from a template,
                 * assuming those widgets exist inside of this.domNode but outside of this.containerNode.
                 *
                 * For 2.0 it's planned that this method will also destroy descendant widgets, so apps should not
                 * depend on the current ability to destroy a widget without destroying its descendants.   Generally
                 * they should use destroyRecursive() for widgets with children.
                 *
                 * @param preserveDom If true, this method will leave the original DOM structure alone.Note: This will not yet work with _TemplatedMixin widgets
                 */
                destroy(preserveDom?: boolean): void;
                /**
                 * Recursively destroy the children of this widget and their
                 * descendants.
                 *
                 * @param preserveDom               OptionalIf true, the preserveDom attribute is passed to all descendantwidget's .destroy() method. Not for use with _Templatedwidgets.
                 */
                destroyDescendants(preserveDom: boolean): void;
                /**
                 * Destroy this widget and its descendants
                 * This is the generic "destructor" function that all widget users
                 * should call to cleanly discard with a widget. Once a widget is
                 * destroyed, it is removed from the manager object.
                 *
                 * @param preserveDom               OptionalIf true, this method will leave the original DOM structurealone of descendant Widgets. Note: This will NOT work withdijit._TemplatedMixin widgets.
                 */
                destroyRecursive(preserveDom: boolean): void;
                /**
                 * Destroys the DOM nodes associated with this widget.
                 *
                 * @param preserveDom               OptionalIf true, this method will leave the original DOM structure aloneduring tear-down. Note: this will not work with _Templatedwidgets yet.
                 */
                destroyRendering(preserveDom?: boolean): void;
                /**
                 * Deprecated, will be removed in 2.0, use handle.remove() instead.
                 *
                 * Disconnects handle created by connect.
                 *
                 * @param handle
                 */
                disconnect(handle: any): void;
                /**
                 * Used by widgets to signal that a synthetic event occurred, ex:
                 *
                 * myWidget.emit("attrmodified-selectedChildWidget", {}).
                 * Emits an event on this.domNode named type.toLowerCase(), based on eventObj.
                 * Also calls onType() method, if present, and returns value from that method.
                 * By default passes eventObj to callback, but will pass callbackArgs instead, if specified.
                 * Modifies eventObj by adding missing parameters (bubbles, cancelable, widget).
                 *
                 * @param type
                 * @param eventObj               Optional
                 * @param callbackArgs               Optional
                 */
                emit(type: String, eventObj: Object, callbackArgs: any[]): any;
                /**
                 * Get a property from a widget.
                 * Get a named property from a widget. The property may
                 * potentially be retrieved via a getter method. If no getter is defined, this
                 * just retrieves the object's property.
                 *
                 * For example, if the widget has properties foo and bar
                 * and a method named _getFooAttr(), calling:
                 * myWidget.get("foo") would be equivalent to calling
                 * widget._getFooAttr() and myWidget.get("bar")
                 * would be equivalent to the expression
                 * widget.bar2
                 *
                 * @param name The property to get.
                 */
                get(name: any): any;
                /**
                 * Returns all direct children of this widget, i.e. all widgets underneath this.containerNode whose parent
                 * is this widget.   Note that it does not return all descendants, but rather just direct children.
                 * Analogous to Node.childNodes,
                 * except containing widgets rather than DOMNodes.
                 *
                 * The result intentionally excludes internally created widgets (a.k.a. supporting widgets)
                 * outside of this.containerNode.
                 *
                 * Note that the array returned is a simple array.  Application code should not assume
                 * existence of methods like forEach().
                 *
                 */
                getChildren(): any[];
                /**
                 * Returns all the widgets contained by this, i.e., all widgets underneath this.containerNode.
                 * This method should generally be avoided as it returns widgets declared in templates, which are
                 * supposed to be internal/hidden, but it's left here for back-compat reasons.
                 *
                 */
                getDescendants(): any[];
                /**
                 * Gets the extension of a file
                 *
                 * @param name
                 */
                getFileType(name: String): any;
                /**
                 * Finds the parent form of the Uploader, if it exists.
                 *
                 */
                getForm(): HTMLElement;
                /**
                 * Returns the mime type that should be used in an HTML5 upload form. Return result
                 * may change as the current use is very generic.
                 *
                 */
                getMimeType(): String;
                /**
                 * Returns the parent widget of this widget.
                 *
                 */
                getParent(): any;
                /**
                 * Finds the URL to upload to, whether it be the action in the parent form, this.url or
                 * this.uploadUrl
                 *
                 */
                getUrl(): any;
                /**
                 *
                 * @param animate
                 */
                hideProgress(animate: boolean): void;
                /**
                 * Return true if this widget can currently be focused
                 * and false if not
                 *
                 */
                isFocusable(): any;
                /**
                 * Return this widget's explicit or implicit orientation (true for LTR, false for RTL)
                 *
                 */
                isLeftToRight(): any;
                /**
                 *
                 * @param type protected
                 * @param func
                 */
                on(type: String, func: Function): any;
                /**
                 *
                 * @param type protected
                 * @param func
                 */
                on(type: Function, func: Function): any;
                /**
                 * Track specified handles and remove/destroy them when this instance is destroyed, unless they were
                 * already removed/destroyed manually.
                 *
                 */
                own(): any;
                /**
                 * Place this widget somewhere in the DOM based
                 * on standard domConstruct.place() conventions.
                 * A convenience function provided in all _Widgets, providing a simple
                 * shorthand mechanism to put an existing (or newly created) Widget
                 * somewhere in the dom, and allow chaining.
                 *
                 * @param reference Widget, DOMNode, or id of widget or DOMNode
                 * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
                 */
                placeAt(reference: String, position: String): any;
                /**
                 * Place this widget somewhere in the DOM based
                 * on standard domConstruct.place() conventions.
                 * A convenience function provided in all _Widgets, providing a simple
                 * shorthand mechanism to put an existing (or newly created) Widget
                 * somewhere in the dom, and allow chaining.
                 *
                 * @param reference Widget, DOMNode, or id of widget or DOMNode
                 * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
                 */
                placeAt(reference: HTMLElement, position: String): any;
                /**
                 * Place this widget somewhere in the DOM based
                 * on standard domConstruct.place() conventions.
                 * A convenience function provided in all _Widgets, providing a simple
                 * shorthand mechanism to put an existing (or newly created) Widget
                 * somewhere in the dom, and allow chaining.
                 *
                 * @param reference Widget, DOMNode, or id of widget or DOMNode
                 * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
                 */
                placeAt(reference: dijit._WidgetBase, position: String): any;
                /**
                 * Place this widget somewhere in the DOM based
                 * on standard domConstruct.place() conventions.
                 * A convenience function provided in all _Widgets, providing a simple
                 * shorthand mechanism to put an existing (or newly created) Widget
                 * somewhere in the dom, and allow chaining.
                 *
                 * @param reference Widget, DOMNode, or id of widget or DOMNode
                 * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
                 */
                placeAt(reference: String, position: number): any;
                /**
                 * Place this widget somewhere in the DOM based
                 * on standard domConstruct.place() conventions.
                 * A convenience function provided in all _Widgets, providing a simple
                 * shorthand mechanism to put an existing (or newly created) Widget
                 * somewhere in the dom, and allow chaining.
                 *
                 * @param reference Widget, DOMNode, or id of widget or DOMNode
                 * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
                 */
                placeAt(reference: HTMLElement, position: number): any;
                /**
                 * Place this widget somewhere in the DOM based
                 * on standard domConstruct.place() conventions.
                 * A convenience function provided in all _Widgets, providing a simple
                 * shorthand mechanism to put an existing (or newly created) Widget
                 * somewhere in the dom, and allow chaining.
                 *
                 * @param reference Widget, DOMNode, or id of widget or DOMNode
                 * @param position               OptionalIf reference is a widget (or id of widget), and that widget has an ".addChild" method,it will be called passing this widget instance into that method, supplying the optionalposition index passed.  In this case position (if specified) should be an integer.If reference is a DOMNode (or id matching a DOMNode but not a widget),the position argument can be a numeric index or a string"first", "last", "before", or "after", same as dojo/dom-construct::place().
                 */
                placeAt(reference: dijit._WidgetBase, position: number): any;
                /**
                 *
                 */
                postCreate(): void;
                /**
                 * Called after the parameters to the widget have been read-in,
                 * but before the widget template is instantiated. Especially
                 * useful to set properties that are referenced in the widget
                 * template.
                 *
                 */
                postMixInProperties(): void;
                /**
                 * Clears all rows of items. Happens automatically if Uploader is reset, but you
                 * could call this directly.
                 *
                 */
                reset(): void;
                /**
                 * Set a property on a widget
                 * Sets named properties on a widget which may potentially be handled by a
                 * setter in the widget.
                 *
                 * For example, if the widget has properties foo and bar
                 * and a method named _setFooAttr(), calling
                 * myWidget.set("foo", "Howdy!") would be equivalent to calling
                 * widget._setFooAttr("Howdy!") and myWidget.set("bar", 3)
                 * would be equivalent to the statement widget.bar = 3;
                 *
                 * set() may also be called with a hash of name/value pairs, ex:
                 *
                 * myWidget.set({
                 *     foo: "Howdy",
                 *     bar: 3
                 * });
                 * This is equivalent to calling set(foo, "Howdy") and set(bar, 3)
                 *
                 * @param name The property to set.
                 * @param value The value to set in the property.
                 */
                set(name: any, value: any): any;
                /**
                 * Deprecated.  Use set() instead.
                 *
                 * @param attr
                 * @param value
                 */
                setAttribute(attr: String, value: any): void;
                /**
                 * Connects to the Uploader based on the uploader or the uploaderId properties.
                 *
                 */
                setUploader(): void;
                /**
                 *
                 * @param animate
                 */
                showProgress(animate: boolean): void;
                /**
                 * Processing after the DOM fragment is added to the document
                 * Called after a widget and its children have been created and added to the page,
                 * and all related widgets have finished their create() cycle, up through postCreate().
                 *
                 * Note that startup() may be called while the widget is still hidden, for example if the widget is
                 * inside a hidden dijit/Dialog or an unselected tab of a dijit/layout/TabContainer.
                 * For widgets that need to do layout, it's best to put that layout code inside resize(), and then
                 * extend dijit/layout/_LayoutWidget so that resize() is called when the widget is visible.
                 *
                 */
                startup(): void;
                /**
                 * Deprecated, will be removed in 2.0, use this.own(topic.subscribe()) instead.
                 *
                 * Subscribes to the specified topic and calls the specified method
                 * of this object and registers for unsubscribe() on widget destroy.
                 *
                 * Provide widget-specific analog to dojo.subscribe, except with the
                 * implicit use of this widget as the target object.
                 *
                 * @param t The topic
                 * @param method The callback
                 */
                subscribe(t: String, method: Function): any;
                /**
                 * Does feature testing for uploader capabilities. (No browser sniffing - yay)
                 *
                 * @param what
                 */
                supports(what: any): any;
                /**
                 * Returns a string that represents the widget.
                 * When a widget is cast to a string, this method will be used to generate the
                 * output. Currently, it does not implement any sort of reversible
                 * serialization.
                 *
                 */
                toString(): string;
                /**
                 * Deprecated. Override destroy() instead to implement custom widget tear-down
                 * behavior.
                 *
                 */
                uninitialize(): boolean;
                /**
                 * Deprecated, will be removed in 2.0, use handle.remove() instead.
                 *
                 * Unsubscribes handle created by this.subscribe.
                 * Also removes handle from this widget's list of subscriptions
                 *
                 * @param handle
                 */
                unsubscribe(handle: Object): void;
                /**
                 * Watches a property for changes
                 *
                 * @param name               OptionalIndicates the property to watch. This is optional (the callback may be theonly parameter), and if omitted, all the properties will be watched
                 * @param callback The function to execute when the property changes. This will be called afterthe property has been changed. The callback will be called with the |this|set to the instance, the first argument as the name of the property, thesecond argument as the old value and the third argument as the new value.
                 */
                watch(property: string, callback:{(property?:string, oldValue?:any, newValue?: any):void}) :{unwatch():void};
                /**
                 * Static method to get a template based on the templatePath or
                 * templateString key
                 */
                getCachedTemplate(): any;
                /**
                 * Called when the widget stops being "active" because
                 * focus moved to something outside of it, or the user
                 * clicked somewhere outside of it, or the widget was
                 * hidden.
                 *
                 */
                onBlur(): void;
                /**
                 * Connect to this function to receive notifications of mouse click events.
                 *
                 * @param event mouse Event
                 */
                onClick(event: any): void;
                /**
                 * Called when this widget is being displayed as a popup (ex: a Calendar popped
                 * up from a DateTextBox), and it is hidden.
                 * This is called from the dijit.popup code, and should not be called directly.
                 *
                 * Also used as a parameter for children of dijit/layout/StackContainer or subclasses.
                 * Callback if a user tries to close the child.   Child will be closed if this function returns true.
                 *
                 */
                onClose(): boolean;
                /**
                 * Connect to this function to receive notifications of mouse double click events.
                 *
                 * @param event mouse Event
                 */
                onDblClick(event: any): void;
                /**
                 * Called when the widget becomes "active" because
                 * it or a widget inside of it either has focus, or has recently
                 * been clicked.
                 *
                 */
                onFocus(): void;
                /**
                 * Called when another widget becomes the selected pane in a
                 * dijit/layout/TabContainer, dijit/layout/StackContainer,
                 * dijit/layout/AccordionContainer, etc.
                 *
                 * Also called to indicate hide of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
                 *
                 */
                onHide(): void;
                /**
                 * Connect to this function to receive notifications of keys being pressed down.
                 *
                 * @param event key Event
                 */
                onKeyDown(event: any): void;
                /**
                 * Connect to this function to receive notifications of printable keys being typed.
                 *
                 * @param event key Event
                 */
                onKeyPress(event: any): void;
                /**
                 * Connect to this function to receive notifications of keys being released.
                 *
                 * @param event key Event
                 */
                onKeyUp(event: any): void;
                /**
                 * Connect to this function to receive notifications of when the mouse button is pressed down.
                 *
                 * @param event mouse Event
                 */
                onMouseDown(event: any): void;
                /**
                 * Connect to this function to receive notifications of when the mouse moves onto this widget.
                 *
                 * @param event mouse Event
                 */
                onMouseEnter(event: any): void;
                /**
                 * Connect to this function to receive notifications of when the mouse moves off of this widget.
                 *
                 * @param event mouse Event
                 */
                onMouseLeave(event: any): void;
                /**
                 * Connect to this function to receive notifications of when the mouse moves over nodes contained within this widget.
                 *
                 * @param event mouse Event
                 */
                onMouseMove(event: any): void;
                /**
                 * Connect to this function to receive notifications of when the mouse moves off of nodes contained within this widget.
                 *
                 * @param event mouse Event
                 */
                onMouseOut(event: any): void;
                /**
                 * Connect to this function to receive notifications of when the mouse moves onto nodes contained within this widget.
                 *
                 * @param event mouse Event
                 */
                onMouseOver(event: any): void;
                /**
                 * Connect to this function to receive notifications of when the mouse button is released.
                 *
                 * @param event mouse Event
                 */
                onMouseUp(event: any): void;
                /**
                 * Called when this widget becomes the selected pane in a
                 * dijit/layout/TabContainer, dijit/layout/StackContainer,
                 * dijit/layout/AccordionContainer, etc.
                 *
                 * Also called to indicate display of a dijit.Dialog, dijit.TooltipDialog, or dijit.TitlePane.
                 *
                 */
                onShow(): void;
            }
            namespace plugins {
                /**
                 * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/uploader/plugins/Flash.html
                 *
                 *
                 */
                interface Flash {
                }
                /**
                 * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/uploader/plugins/HTML5.html
                 *
                 *
                 */
                interface HTML5 {
                }
                /**
                 * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/uploader/plugins/IFrame.html
                 *
                 *
                 */
                interface IFrame {
                }
            }

        }

        /**
         * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/_HasDropDown.html
         *
         * This module defines Javascript language extensions.
         *
         */
        interface _HasDropDown {
            /**
             * Clones objects (including DOM nodes) and all children.
             * Warning: do not clone cyclic structures.
             *
             * @param src The object to clone
             */
            clone(src: any): any;
            /**
             * Returns a new object which "looks" to obj for properties which it
             * does not have a value for. Optionally takes a bag of properties to
             * seed the returned object with initially.
             * This is a small implementation of the Boodman/Crockford delegation
             * pattern in JavaScript. An intermediate object constructor mediates
             * the prototype chain for the returned object, using it to delegate
             * down to obj for property lookup when object-local lookup fails.
             * This can be thought of similarly to ES4's "wrap", save that it does
             * not act on types but rather on pure objects.
             *
             * @param obj The object to delegate to for properties not found directly on thereturn object or in props.
             * @param props an object containing properties to assign to the returned object
             */
            delegate(obj: Object, props: Object[]): any;
            /**
             * determine if an object supports a given method
             * useful for longer api chains where you have to test each object in
             * the chain. Useful for object and method detection.
             *
             * @param name Path to an object, in the form "A.B.C".
             * @param obj               OptionalObject to use as root of path. Defaults to'dojo.global'. Null may be passed.
             */
            exists(name: String, obj: Object): boolean;
            /**
             * Adds all properties and methods of props to constructor's
             * prototype, making them available to all instances created with
             * constructor.
             *
             * @param ctor Target constructor to extend.
             * @param props One or more objects to mix into ctor.prototype
             */
            extend(ctor: Object, props: Object): Object;
            /**
             * Get a property from a dot-separated string, such as "A.B.C"
             * Useful for longer api chains where you have to test each object in
             * the chain, or when you have an object reference in string format.
             *
             * @param name Path to an property, in the form "A.B.C".
             * @param create               OptionalOptional. Defaults to false. If true, Objects will becreated at any point along the 'path' that is undefined.
             * @param context               OptionalOptional. Object to use as root of path. Defaults to'dojo.global'. Null may be passed.
             */
            getObject(name: String, create: boolean, context: Object): any;
            /**
             * Returns a function that will only ever execute in the a given scope.
             * This allows for easy use of object member functions
             * in callbacks and other places in which the "this" keyword may
             * otherwise not reference the expected scope.
             * Any number of default positional arguments may be passed as parameters
             * beyond "method".
             * Each of these values will be used to "placehold" (similar to curry)
             * for the hitched function.
             *
             * @param scope The scope to use when method executes. If method is a string,scope is also the object containing method.
             * @param method A function to be hitched to scope, or the name of the method inscope to be hitched.
             */
            hitch(scope: Object, method: Function): any;
            /**
             * Returns a function that will only ever execute in the a given scope.
             * This allows for easy use of object member functions
             * in callbacks and other places in which the "this" keyword may
             * otherwise not reference the expected scope.
             * Any number of default positional arguments may be passed as parameters
             * beyond "method".
             * Each of these values will be used to "placehold" (similar to curry)
             * for the hitched function.
             *
             * @param scope The scope to use when method executes. If method is a string,scope is also the object containing method.
             * @param method A function to be hitched to scope, or the name of the method inscope to be hitched.
             */
            hitch(scope: Object, method: String[]): any;
            /**
             * Returns true if it is a built-in function or some other kind of
             * oddball that should report as a function but doesn't
             *
             * @param it
             */
            isAlien(it: any): any;
            /**
             * Return true if it is an Array.
             * Does not work on Arrays created in other windows.
             *
             * @param it Item to test.
             */
            isArray(it: any): any;
            /**
             * similar to isArray() but more permissive
             * Doesn't strongly test for "arrayness".  Instead, settles for "isn't
             * a string or number and has a length property". Arguments objects
             * and DOM collections will return true when passed to
             * isArrayLike(), but will return false when passed to
             * isArray().
             *
             * @param it Item to test.
             */
            isArrayLike(it: any): any;
            /**
             * Return true if it is a Function
             *
             * @param it Item to test.
             */
            isFunction(it: any): boolean;
            /**
             * Returns true if it is a JavaScript object (or an Array, a Function
             * or null)
             *
             * @param it Item to test.
             */
            isObject(it: any): boolean;
            /**
             * Return true if it is a String
             *
             * @param it Item to test.
             */
            isString(it: any): boolean;
            /**
             * Copies/adds all properties of one or more sources to dest; returns dest.
             * All properties, including functions (sometimes termed "methods"), excluding any non-standard extensions
             * found in Object.prototype, are copied/added from sources to dest. sources are processed left to right.
             * The Javascript assignment operator is used to copy/add each property; therefore, by default, mixin
             * executes a so-called "shallow copy" and aggregate types are copied/added by reference.
             *
             * @param dest The object to which to copy/add all properties contained in source. If dest is falsy, thena new object is manufactured before copying/adding properties begins.
             * @param sources One of more objects from which to draw all properties to copy into dest. sources are processedleft-to-right and if more than one of these objects contain the same property name, the right-mostvalue "wins".
             */
            mixin(dest: Object, sources: Object[]): Object;
            /**
             * similar to hitch() except that the scope object is left to be
             * whatever the execution context eventually becomes.
             * Calling lang.partial is the functional equivalent of calling:
             *
             * lang.hitch(null, funcName, ...);
             *
             * @param method The function to "wrap"
             */
            partial(method: Function): any;
            /**
             * similar to hitch() except that the scope object is left to be
             * whatever the execution context eventually becomes.
             * Calling lang.partial is the functional equivalent of calling:
             *
             * lang.hitch(null, funcName, ...);
             *
             * @param method The function to "wrap"
             */
            partial(method: String): any;
            /**
             * Performs parameterized substitutions on a string. Throws an
             * exception if any parameter is unmatched.
             *
             * @param tmpl String to be used as a template.
             * @param map If an object, it is used as a dictionary to look up substitutions.If a function, it is called for every substitution with following parameters:a whole match, a name, an offset, and the whole templatestring (see https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/String/replacefor more details).
             * @param pattern               OptionalOptional regular expression objects that overrides the default pattern.Must be global and match one item. The default is: /{([^}]+)}/g,which matches patterns like that: "{xxx}", where "xxx" is any sequenceof characters, which doesn't include "}".
             */
            replace(tmpl: String, map: Object, pattern: RegExp): String;
            /**
             * Performs parameterized substitutions on a string. Throws an
             * exception if any parameter is unmatched.
             *
             * @param tmpl String to be used as a template.
             * @param map If an object, it is used as a dictionary to look up substitutions.If a function, it is called for every substitution with following parameters:a whole match, a name, an offset, and the whole templatestring (see https://developer.mozilla.org/en/Core_JavaScript_1.5_Reference/Global_Objects/String/replacefor more details).
             * @param pattern               OptionalOptional regular expression objects that overrides the default pattern.Must be global and match one item. The default is: /{([^}]+)}/g,which matches patterns like that: "{xxx}", where "xxx" is any sequenceof characters, which doesn't include "}".
             */
            replace(tmpl: String, map: Function, pattern: RegExp): String;
            /**
             * Set a property from a dot-separated string, such as "A.B.C"
             * Useful for longer api chains where you have to test each object in
             * the chain, or when you have an object reference in string format.
             * Objects are created as needed along path. Returns the passed
             * value if setting is successful or undefined if not.
             *
             * @param name Path to a property, in the form "A.B.C".
             * @param value value or object to place at location given by name
             * @param context               OptionalOptional. Object to use as root of path. Defaults todojo.global.
             */
            setObject(name: String, value: any, context: Object): any;
            /**
             * Trims whitespace from both sides of the string
             * This version of trim() was selected for inclusion into the base due
             * to its compact size and relatively good performance
             * (see Steven Levithan's blog
             * Uses String.prototype.trim instead, if available.
             * The fastest but longest version of this function is located at
             * lang.string.trim()
             *
             * @param str String to be trimmed
             */
            trim(str: String): String;
        }
        /**
         * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/DropDownStack.html
         *
         * A dropdown-based select stack.
         *
         */
        interface DropDownStack {
        }
        /**
         * Permalink: http://dojotoolkit.org/api/1.9/dojox/form/RadioStack.html
         *
         * A radio-based select stack.
         *
         */
        interface RadioStack {
        }
    }

}

declare module "dojox/form/_HasDropDown" {
    var exp: dojox.form._HasDropDown
    export=exp;
}
declare module "dojox/form/DropDownStack" {
    var exp: dojox.form.DropDownStack
    export=exp;
}
declare module "dojox/form/RadioStack" {
    var exp: dojox.form.RadioStack
    export=exp;
}
declare module "dojox/form/_SelectStackMixin" {
    var exp: dojox.form._SelectStackMixin
    export=exp;
}
declare module "dojox/form/BusyButton" {
    var exp: dojox.form.BusyButton
    export=exp;
}
declare module "dojox/form/_FormSelectWidget" {
    var exp: dojox.form._FormSelectWidget
    export=exp;
}
declare module "dojox/form/_FormSelectWidget.__SelectOption" {
    var exp: dojox.form._FormSelectWidget.__SelectOption
    export=exp;
}
declare module "dojox/form/CheckedMultiSelect" {
    var exp: dojox.form.CheckedMultiSelect
    export=exp;
}
declare module "dojox/form/DayTextBox" {
    var exp: dojox.form.DayTextBox
    export=exp;
}
declare module "dojox/form/DropDownSelect" {
    var exp: dojox.form.DropDownSelect
    export=exp;
}
declare module "dojox/form/DropDownSelect._Menu" {
    var exp: dojox.form.DropDownSelect._Menu
    export=exp;
}
declare module "dojox/form/FileInput" {
    var exp: dojox.form.FileInput
    export=exp;
}
declare module "dojox/form/DateTextBox" {
    var exp: dojox.form.DateTextBox
    export=exp;
}
declare module "dojox/form/FileInputBlind" {
    var exp: dojox.form.FileInputBlind
    export=exp;
}
declare module "dojox/form/FileInputAuto" {
    var exp: dojox.form.FileInputAuto
    export=exp;
}
declare module "dojox/form/FileUploader" {
    var exp: dojox.form.FileUploader
    export=exp;
}
declare module "dojox/form/Manager" {
    var exp: dojox.form.Manager
    export=exp;
}
declare module "dojox/form/FilePickerTextBox" {
    var exp: dojox.form.FilePickerTextBox
    export=exp;
}
declare module "dojox/form/RangeSlider" {
    var exp: dojox.form.RangeSlider
    export=exp;
}
declare module "dojox/form/ListInput" {
    var exp: dojox.form.ListInput
    export=exp;
}
declare module "dojox/form/PasswordValidator" {
    var exp: dojox.form.PasswordValidator
    export=exp;
}
declare module "dojox/form/Rating" {
    var exp: dojox.form.Rating
    export=exp;
}
declare module "dojox/form/MonthTextBox" {
    var exp: dojox.form.MonthTextBox
    export=exp;
}
declare module "dojox/form/MultiComboBox" {
    var exp: dojox.form.MultiComboBox
    export=exp;
}
declare module "dojox/form/TimeSpinner" {
    var exp: dojox.form.TimeSpinner
    export=exp;
}
declare module "dojox/form/TriStateCheckBox" {
    var exp: dojox.form.TriStateCheckBox
    export=exp;
}
declare module "dojox/form/Uploader" {
    var exp: dojox.form.Uploader
    export=exp;
}
declare module "dojox/form/YearTextBox" {
    var exp: dojox.form.YearTextBox
    export=exp;
}
declare module "dojox/form/manager/_ClassMixin" {
    var exp: dojox.form.manager._ClassMixin
    export=exp;
}
declare module "dojox/form/manager/_DisplayMixin" {
    var exp: dojox.form.manager._DisplayMixin
    export=exp;
}
declare module "dojox/form/manager/_EnableMixin" {
    var exp: dojox.form.manager._EnableMixin
    export=exp;
}
declare module "dojox/form/manager/_FormMixin" {
    var exp: dojox.form.manager._FormMixin
    export=exp;
}
declare module "dojox/form/manager/_Mixin" {
    var exp: dojox.form.manager._Mixin
    export=exp;
}
declare module "dojox/form/manager/_NodeMixin" {
    var exp: dojox.form.manager._NodeMixin
    export=exp;
}
declare module "dojox/form/manager/_ValueMixin" {
    var exp: dojox.form.manager._ValueMixin
    export=exp;
}
declare module "dojox/form/uploader/_HTML5" {
    var exp: dojox.form.uploader._HTML5
    export=exp;
}
declare module "dojox/form/uploader/_Flash" {
    var exp: dojox.form.uploader._Flash
    export=exp;
}
declare module "dojox/form/uploader/_IFrame" {
    var exp: dojox.form.uploader._IFrame
    export=exp;
}
declare module "dojox/form/uploader/_Base" {
    var exp: dojox.form.uploader._Base
    export=exp;
}
declare module "dojox/form/uploader/FileList" {
    var exp: dojox.form.uploader.FileList
    export=exp;
}
declare module "dojox/form/uploader/plugins/Flash" {
    var exp: dojox.form.uploader.plugins.Flash
    export=exp;
}
declare module "dojox/form/uploader/plugins/HTML5" {
    var exp: dojox.form.uploader.plugins.HTML5
    export=exp;
}
declare module "dojox/form/uploader/plugins/IFrame" {
    var exp: dojox.form.uploader.plugins.IFrame
    export=exp;
}
