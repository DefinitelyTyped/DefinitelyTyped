import { Emitter as DomEmitter } from '@ckeditor/ckeditor5-utils/src/dom/emittermixin';
import { Emitter, EmitterMixinDelegateChain } from '@ckeditor/ckeditor5-utils/src/emittermixin';
import EventInfo from '@ckeditor/ckeditor5-utils/src/eventinfo';
import { PriorityString } from '@ckeditor/ckeditor5-utils/src/priorities';
import ViewDocument from '../document';
import View from '../view';

export default abstract class Observer<V extends View = View> implements DomEmitter {
    /**
     * Creates an instance of the observer.
     */
    constructor(view: V);
    /**
     * An instance of the view controller.
     */
    readonly view: V;
    /**
     * A reference to the {@link module:engine/view/document~Document} object.
     */
    readonly document: ViewDocument;
    /**
     * The state of the observer. If it is disabled, no events will be fired.
     */
    get isEnabled(): boolean;
    protected set isEnabled(value: boolean);
    /**
     * Enables the observer. This method is called when the observer is registered to the
     * {@link module:engine/view/view~View} and after {@link module:engine/view/view~View#forceRender rendering}
     * (all observers are {@link #disable disabled} before rendering).
     *
     * A typical use case for disabling observers is that mutation observers need to be disabled for the rendering.
     * However, a child class may not need to be disabled, so it can implement an empty method.
     *
     * @see module:engine/view/observer/observer~Observer#disable
     */
    enable(): void;
    /**
     * Disables the observer. This method is called before
     * {@link module:engine/view/view~View#forceRender rendering} to prevent firing events during rendering.
     *
     * @see module:engine/view/observer/observer~Observer#enable
     */
    disable(): void;
    /**
     * Disables and destroys the observer, among others removes event listeners created by the observer.
     */
    destroy(): void;
    /**
     * Checks whether a given DOM event should be ignored (should not be turned into a synthetic view document event).
     *
     * Currently, an event will be ignored only if its target or any of its ancestors has the `data-cke-ignore-events` attribute.
     * This attribute can be used inside the structures generated by
     * {@link module:engine/view/downcastwriter~DowncastWriter#createUIElement `DowncastWriter#createUIElement()`} to ignore events
     * fired within a UI that should be excluded from CKEditor 5's realms.
     */
    checkShouldIgnoreEventFromTarget(domTarget: Node): boolean;
    /**
     * Starts observing the given root element.
     */
    abstract observe(domElement: HTMLElement, name?: string): void;
    on<K extends keyof HTMLElementEventMap>(
        event: K,
        callback: (this: this, info: EventInfo<this, K>, event: HTMLElementEventMap[K]) => void,
        options?: {
            priority?: number | PriorityString | undefined;
            useCapture?: boolean | undefined;
            usePassive?: boolean | undefined;
        },
    ): void;
    on<K extends string>(
        event: K,
        callback: (this: this, info: EventInfo<this, K>, ...args: any[]) => void,
        options?: {
            priority?: number | PriorityString | undefined;
            useCapture?: boolean | undefined;
            usePassive?: boolean | undefined;
        },
    ): void;
    once<K extends keyof HTMLElementEventMap>(
        event: K,
        callback: (this: this, info: EventInfo<this, K>, event: HTMLElementEventMap[K]) => void,
        options?: {
            priority?: number | PriorityString | undefined;
            useCapture?: boolean | undefined;
            usePassive?: boolean | undefined;
        },
    ): void;
    once<K extends string>(
        event: K,
        callback: (this: this, info: EventInfo<this, K>, ...args: any[]) => void,
        options?: {
            priority?: number | PriorityString | undefined;
            useCapture?: boolean | undefined;
            usePassive?: boolean | undefined;
        },
    ): void;
    off<K extends keyof HTMLElementEventMap>(
        event: K,
        callback: (this: this, info: EventInfo<this, K>, event: HTMLElementEventMap[K]) => void,
    ): void;
    off<K extends string>(event: K, callback?: (this: this, info: EventInfo<this, K>, ...args: any[]) => void): void;
    fire<K extends keyof HTMLElementEventMap>(name: K, event: HTMLElementEventMap[K]): unknown;
    fire(event: string | EventInfo, ...args: any[]): unknown;
    delegate(...events: string[]): EmitterMixinDelegateChain;
    stopDelegating(...events: string[]): void;
    stopDelegating(event?: string, emitter?: DomEmitter): void;
    listenTo<K extends keyof HTMLElementEventMap, E extends Emitter | Node | Window | ViewDocument >(
        emitter: E,
        event: K,
        callback: (this: this, info: EventInfo<E, K>, event: HTMLElementEventMap[K]) => void,
        options?: {
            priority?: number | PriorityString | undefined;
            useCapture?: boolean | undefined;
            usePassive?: boolean | undefined;
        },
    ): void;
    listenTo<P extends string, E extends Emitter>(
        emitter: E,
        event: P,
        callback: (this: this, info: EventInfo<E, P>, ...args: any[]) => void,
        options?: {
            priority?: number | PriorityString | undefined;
            useCapture?: boolean | undefined;
            usePassive?: boolean | undefined;
        },
    ): void;
    stopListening<K extends keyof HTMLElementEventMap, E extends Emitter | Node | Window | ViewDocument>(
        emitter?: E,
        event?: K,
        callback?: (this: this, info: EventInfo<E, K>, event: HTMLElementEventMap[K]) => void,
    ): void;
    stopListening<P extends string, E extends Emitter>(
        emitter?: E,
        event?: P,
        callback?: (this: this, info: EventInfo<E, P>, ...args: any[]) => void,
    ): void;
}
