
/**
 * Enum containing WebGL Constant values by name.
 * for use without an active WebGL context, or in cases where certain constants are unavailable using the WebGL context
 * (For example, in [Safari 9]{@link https://github.com/CesiumGS/cesium/issues/2989}).
 *
 * These match the constants from the [WebGL 1.0]{@link https://www.khronos.org/registry/webgl/specs/latest/1.0/}
 * and [WebGL 2.0]{@link https://www.khronos.org/registry/webgl/specs/latest/2.0/}
 * specifications.
 */
export enum WebGLConstants {
    DEPTH_BUFFER_BIT = 256,
    STENCIL_BUFFER_BIT = 1024,
    COLOR_BUFFER_BIT = 16384,
    POINTS = 0,
    LINES = 1,
    LINE_LOOP = 2,
    LINE_STRIP = 3,
    TRIANGLES = 4,
    TRIANGLE_STRIP = 5,
    TRIANGLE_FAN = 6,
    ZERO = 0,
    ONE = 1,
    SRC_COLOR = 768,
    ONE_MINUS_SRC_COLOR = 769,
    SRC_ALPHA = 770,
    ONE_MINUS_SRC_ALPHA = 771,
    DST_ALPHA = 772,
    ONE_MINUS_DST_ALPHA = 773,
    DST_COLOR = 774,
    ONE_MINUS_DST_COLOR = 775,
    SRC_ALPHA_SATURATE = 776,
    FUNC_ADD = 32774,
    BLEND_EQUATION = 32777,
    BLEND_EQUATION_RGB = 32777,
    BLEND_EQUATION_ALPHA = 34877,
    FUNC_SUBTRACT = 32778,
    FUNC_REVERSE_SUBTRACT = 32779,
    BLEND_DST_RGB = 32968,
    BLEND_SRC_RGB = 32969,
    BLEND_DST_ALPHA = 32970,
    BLEND_SRC_ALPHA = 32971,
    CONSTANT_COLOR = 32769,
    ONE_MINUS_CONSTANT_COLOR = 32770,
    CONSTANT_ALPHA = 32771,
    ONE_MINUS_CONSTANT_ALPHA = 32772,
    BLEND_COLOR = 32773,
    ARRAY_BUFFER = 34962,
    ELEMENT_ARRAY_BUFFER = 34963,
    ARRAY_BUFFER_BINDING = 34964,
    ELEMENT_ARRAY_BUFFER_BINDING = 34965,
    STREAM_DRAW = 35040,
    STATIC_DRAW = 35044,
    DYNAMIC_DRAW = 35048,
    BUFFER_SIZE = 34660,
    BUFFER_USAGE = 34661,
    CURRENT_VERTEX_ATTRIB = 34342,
    FRONT = 1028,
    BACK = 1029,
    FRONT_AND_BACK = 1032,
    CULL_FACE = 2884,
    BLEND = 3042,
    DITHER = 3024,
    STENCIL_TEST = 2960,
    DEPTH_TEST = 2929,
    SCISSOR_TEST = 3089,
    POLYGON_OFFSET_FILL = 32823,
    SAMPLE_ALPHA_TO_COVERAGE = 32926,
    SAMPLE_COVERAGE = 32928,
    NO_ERROR = 0,
    INVALID_ENUM = 1280,
    INVALID_VALUE = 1281,
    INVALID_OPERATION = 1282,
    OUT_OF_MEMORY = 1285,
    CW = 2304,
    CCW = 2305,
    LINE_WIDTH = 2849,
    ALIASED_POINT_SIZE_RANGE = 33901,
    ALIASED_LINE_WIDTH_RANGE = 33902,
    CULL_FACE_MODE = 2885,
    FRONT_FACE = 2886,
    DEPTH_RANGE = 2928,
    DEPTH_WRITEMASK = 2930,
    DEPTH_CLEAR_VALUE = 2931,
    DEPTH_FUNC = 2932,
    STENCIL_CLEAR_VALUE = 2961,
    STENCIL_FUNC = 2962,
    STENCIL_FAIL = 2964,
    STENCIL_PASS_DEPTH_FAIL = 2965,
    STENCIL_PASS_DEPTH_PASS = 2966,
    STENCIL_REF = 2967,
    STENCIL_VALUE_MASK = 2963,
    STENCIL_WRITEMASK = 2968,
    STENCIL_BACK_FUNC = 34816,
    STENCIL_BACK_FAIL = 34817,
    STENCIL_BACK_PASS_DEPTH_FAIL = 34818,
    STENCIL_BACK_PASS_DEPTH_PASS = 34819,
    STENCIL_BACK_REF = 36003,
    STENCIL_BACK_VALUE_MASK = 36004,
    STENCIL_BACK_WRITEMASK = 36005,
    VIEWPORT = 2978,
    SCISSOR_BOX = 3088,
    COLOR_CLEAR_VALUE = 3106,
    COLOR_WRITEMASK = 3107,
    UNPACK_ALIGNMENT = 3317,
    PACK_ALIGNMENT = 3333,
    MAX_TEXTURE_SIZE = 3379,
    MAX_VIEWPORT_DIMS = 3386,
    SUBPIXEL_BITS = 3408,
    RED_BITS = 3410,
    GREEN_BITS = 3411,
    BLUE_BITS = 3412,
    ALPHA_BITS = 3413,
    DEPTH_BITS = 3414,
    STENCIL_BITS = 3415,
    POLYGON_OFFSET_UNITS = 10752,
    POLYGON_OFFSET_FACTOR = 32824,
    TEXTURE_BINDING_2D = 32873,
    SAMPLE_BUFFERS = 32936,
    SAMPLES = 32937,
    SAMPLE_COVERAGE_VALUE = 32938,
    SAMPLE_COVERAGE_INVERT = 32939,
    COMPRESSED_TEXTURE_FORMATS = 34467,
    DONT_CARE = 4352,
    FASTEST = 4353,
    NICEST = 4354,
    GENERATE_MIPMAP_HINT = 33170,
    BYTE = 5120,
    UNSIGNED_BYTE = 5121,
    SHORT = 5122,
    UNSIGNED_SHORT = 5123,
    INT = 5124,
    UNSIGNED_INT = 5125,
    FLOAT = 5126,
    DEPTH_COMPONENT = 6402,
    ALPHA = 6406,
    RGB = 6407,
    RGBA = 6408,
    LUMINANCE = 6409,
    LUMINANCE_ALPHA = 6410,
    UNSIGNED_SHORT_4_4_4_4 = 32819,
    UNSIGNED_SHORT_5_5_5_1 = 32820,
    UNSIGNED_SHORT_5_6_5 = 33635,
    FRAGMENT_SHADER = 35632,
    VERTEX_SHADER = 35633,
    MAX_VERTEX_ATTRIBS = 34921,
    MAX_VERTEX_UNIFORM_VECTORS = 36347,
    MAX_VARYING_VECTORS = 36348,
    MAX_COMBINED_TEXTURE_IMAGE_UNITS = 35661,
    MAX_VERTEX_TEXTURE_IMAGE_UNITS = 35660,
    MAX_TEXTURE_IMAGE_UNITS = 34930,
    MAX_FRAGMENT_UNIFORM_VECTORS = 36349,
    SHADER_TYPE = 35663,
    DELETE_STATUS = 35712,
    LINK_STATUS = 35714,
    VALIDATE_STATUS = 35715,
    ATTACHED_SHADERS = 35717,
    ACTIVE_UNIFORMS = 35718,
    ACTIVE_ATTRIBUTES = 35721,
    SHADING_LANGUAGE_VERSION = 35724,
    CURRENT_PROGRAM = 35725,
    NEVER = 512,
    LESS = 513,
    EQUAL = 514,
    LEQUAL = 515,
    GREATER = 516,
    NOTEQUAL = 517,
    GEQUAL = 518,
    ALWAYS = 519,
    KEEP = 7680,
    REPLACE = 7681,
    INCR = 7682,
    DECR = 7683,
    INVERT = 5386,
    INCR_WRAP = 34055,
    DECR_WRAP = 34056,
    VENDOR = 7936,
    RENDERER = 7937,
    VERSION = 7938,
    NEAREST = 9728,
    LINEAR = 9729,
    NEAREST_MIPMAP_NEAREST = 9984,
    LINEAR_MIPMAP_NEAREST = 9985,
    NEAREST_MIPMAP_LINEAR = 9986,
    LINEAR_MIPMAP_LINEAR = 9987,
    TEXTURE_MAG_FILTER = 10240,
    TEXTURE_MIN_FILTER = 10241,
    TEXTURE_WRAP_S = 10242,
    TEXTURE_WRAP_T = 10243,
    TEXTURE_2D = 3553,
    TEXTURE = 5890,
    TEXTURE_CUBE_MAP = 34067,
    TEXTURE_BINDING_CUBE_MAP = 34068,
    TEXTURE_CUBE_MAP_POSITIVE_X = 34069,
    TEXTURE_CUBE_MAP_NEGATIVE_X = 34070,
    TEXTURE_CUBE_MAP_POSITIVE_Y = 34071,
    TEXTURE_CUBE_MAP_NEGATIVE_Y = 34072,
    TEXTURE_CUBE_MAP_POSITIVE_Z = 34073,
    TEXTURE_CUBE_MAP_NEGATIVE_Z = 34074,
    MAX_CUBE_MAP_TEXTURE_SIZE = 34076,
    TEXTURE0 = 33984,
    TEXTURE1 = 33985,
    TEXTURE2 = 33986,
    TEXTURE3 = 33987,
    TEXTURE4 = 33988,
    TEXTURE5 = 33989,
    TEXTURE6 = 33990,
    TEXTURE7 = 33991,
    TEXTURE8 = 33992,
    TEXTURE9 = 33993,
    TEXTURE10 = 33994,
    TEXTURE11 = 33995,
    TEXTURE12 = 33996,
    TEXTURE13 = 33997,
    TEXTURE14 = 33998,
    TEXTURE15 = 33999,
    TEXTURE16 = 34000,
    TEXTURE17 = 34001,
    TEXTURE18 = 34002,
    TEXTURE19 = 34003,
    TEXTURE20 = 34004,
    TEXTURE21 = 34005,
    TEXTURE22 = 34006,
    TEXTURE23 = 34007,
    TEXTURE24 = 34008,
    TEXTURE25 = 34009,
    TEXTURE26 = 34010,
    TEXTURE27 = 34011,
    TEXTURE28 = 34012,
    TEXTURE29 = 34013,
    TEXTURE30 = 34014,
    TEXTURE31 = 34015,
    ACTIVE_TEXTURE = 34016,
    REPEAT = 10497,
    CLAMP_TO_EDGE = 33071,
    MIRRORED_REPEAT = 33648,
    FLOAT_VEC2 = 35664,
    FLOAT_VEC3 = 35665,
    FLOAT_VEC4 = 35666,
    INT_VEC2 = 35667,
    INT_VEC3 = 35668,
    INT_VEC4 = 35669,
    BOOL = 35670,
    BOOL_VEC2 = 35671,
    BOOL_VEC3 = 35672,
    BOOL_VEC4 = 35673,
    FLOAT_MAT2 = 35674,
    FLOAT_MAT3 = 35675,
    FLOAT_MAT4 = 35676,
    SAMPLER_2D = 35678,
    SAMPLER_CUBE = 35680,
    VERTEX_ATTRIB_ARRAY_ENABLED = 34338,
    VERTEX_ATTRIB_ARRAY_SIZE = 34339,
    VERTEX_ATTRIB_ARRAY_STRIDE = 34340,
    VERTEX_ATTRIB_ARRAY_TYPE = 34341,
    VERTEX_ATTRIB_ARRAY_NORMALIZED = 34922,
    VERTEX_ATTRIB_ARRAY_POINTER = 34373,
    VERTEX_ATTRIB_ARRAY_BUFFER_BINDING = 34975,
    IMPLEMENTATION_COLOR_READ_TYPE = 35738,
    IMPLEMENTATION_COLOR_READ_FORMAT = 35739,
    COMPILE_STATUS = 35713,
    LOW_FLOAT = 36336,
    MEDIUM_FLOAT = 36337,
    HIGH_FLOAT = 36338,
    LOW_INT = 36339,
    MEDIUM_INT = 36340,
    HIGH_INT = 36341,
    FRAMEBUFFER = 36160,
    RENDERBUFFER = 36161,
    RGBA4 = 32854,
    RGB5_A1 = 32855,
    RGB565 = 36194,
    DEPTH_COMPONENT16 = 33189,
    STENCIL_INDEX = 6401,
    STENCIL_INDEX8 = 36168,
    DEPTH_STENCIL = 34041,
    RENDERBUFFER_WIDTH = 36162,
    RENDERBUFFER_HEIGHT = 36163,
    RENDERBUFFER_INTERNAL_FORMAT = 36164,
    RENDERBUFFER_RED_SIZE = 36176,
    RENDERBUFFER_GREEN_SIZE = 36177,
    RENDERBUFFER_BLUE_SIZE = 36178,
    RENDERBUFFER_ALPHA_SIZE = 36179,
    RENDERBUFFER_DEPTH_SIZE = 36180,
    RENDERBUFFER_STENCIL_SIZE = 36181,
    FRAMEBUFFER_ATTACHMENT_OBJECT_TYPE = 36048,
    FRAMEBUFFER_ATTACHMENT_OBJECT_NAME = 36049,
    FRAMEBUFFER_ATTACHMENT_TEXTURE_LEVEL = 36050,
    FRAMEBUFFER_ATTACHMENT_TEXTURE_CUBE_MAP_FACE = 36051,
    COLOR_ATTACHMENT0 = 36064,
    DEPTH_ATTACHMENT = 36096,
    STENCIL_ATTACHMENT = 36128,
    DEPTH_STENCIL_ATTACHMENT = 33306,
    NONE = 0,
    FRAMEBUFFER_COMPLETE = 36053,
    FRAMEBUFFER_INCOMPLETE_ATTACHMENT = 36054,
    FRAMEBUFFER_INCOMPLETE_MISSING_ATTACHMENT = 36055,
    FRAMEBUFFER_INCOMPLETE_DIMENSIONS = 36057,
    FRAMEBUFFER_UNSUPPORTED = 36061,
    FRAMEBUFFER_BINDING = 36006,
    RENDERBUFFER_BINDING = 36007,
    MAX_RENDERBUFFER_SIZE = 34024,
    INVALID_FRAMEBUFFER_OPERATION = 1286,
    UNPACK_FLIP_Y_WEBGL = 37440,
    UNPACK_PREMULTIPLY_ALPHA_WEBGL = 37441,
    CONTEXT_LOST_WEBGL = 37442,
    UNPACK_COLORSPACE_CONVERSION_WEBGL = 37443,
    BROWSER_DEFAULT_WEBGL = 37444,
    COMPRESSED_RGB_S3TC_DXT1_EXT = 33776,
    COMPRESSED_RGBA_S3TC_DXT1_EXT = 33777,
    COMPRESSED_RGBA_S3TC_DXT3_EXT = 33778,
    COMPRESSED_RGBA_S3TC_DXT5_EXT = 33779,
    COMPRESSED_RGB_PVRTC_4BPPV1_IMG = 35840,
    COMPRESSED_RGB_PVRTC_2BPPV1_IMG = 35841,
    COMPRESSED_RGBA_PVRTC_4BPPV1_IMG = 35842,
    COMPRESSED_RGBA_PVRTC_2BPPV1_IMG = 35843,
    COMPRESSED_RGBA_ASTC_4x4_WEBGL = 37808,
    COMPRESSED_RGB_ETC1_WEBGL = 36196,
    COMPRESSED_RGBA_BPTC_UNORM = 36492,
    HALF_FLOAT_OES = 36193,
    DOUBLE = 5130,
    READ_BUFFER = 3074,
    UNPACK_ROW_LENGTH = 3314,
    UNPACK_SKIP_ROWS = 3315,
    UNPACK_SKIP_PIXELS = 3316,
    PACK_ROW_LENGTH = 3330,
    PACK_SKIP_ROWS = 3331,
    PACK_SKIP_PIXELS = 3332,
    COLOR = 6144,
    DEPTH = 6145,
    STENCIL = 6146,
    RED = 6403,
    RGB8 = 32849,
    RGBA8 = 32856,
    RGB10_A2 = 32857,
    TEXTURE_BINDING_3D = 32874,
    UNPACK_SKIP_IMAGES = 32877,
    UNPACK_IMAGE_HEIGHT = 32878,
    TEXTURE_3D = 32879,
    TEXTURE_WRAP_R = 32882,
    MAX_3D_TEXTURE_SIZE = 32883,
    UNSIGNED_INT_2_10_10_10_REV = 33640,
    MAX_ELEMENTS_VERTICES = 33000,
    MAX_ELEMENTS_INDICES = 33001,
    TEXTURE_MIN_LOD = 33082,
    TEXTURE_MAX_LOD = 33083,
    TEXTURE_BASE_LEVEL = 33084,
    TEXTURE_MAX_LEVEL = 33085,
    MIN = 32775,
    MAX = 32776,
    DEPTH_COMPONENT24 = 33190,
    MAX_TEXTURE_LOD_BIAS = 34045,
    TEXTURE_COMPARE_MODE = 34892,
    TEXTURE_COMPARE_FUNC = 34893,
    CURRENT_QUERY = 34917,
    QUERY_RESULT = 34918,
    QUERY_RESULT_AVAILABLE = 34919,
    STREAM_READ = 35041,
    STREAM_COPY = 35042,
    STATIC_READ = 35045,
    STATIC_COPY = 35046,
    DYNAMIC_READ = 35049,
    DYNAMIC_COPY = 35050,
    MAX_DRAW_BUFFERS = 34852,
    DRAW_BUFFER0 = 34853,
    DRAW_BUFFER1 = 34854,
    DRAW_BUFFER2 = 34855,
    DRAW_BUFFER3 = 34856,
    DRAW_BUFFER4 = 34857,
    DRAW_BUFFER5 = 34858,
    DRAW_BUFFER6 = 34859,
    DRAW_BUFFER7 = 34860,
    DRAW_BUFFER8 = 34861,
    DRAW_BUFFER9 = 34862,
    DRAW_BUFFER10 = 34863,
    DRAW_BUFFER11 = 34864,
    DRAW_BUFFER12 = 34865,
    DRAW_BUFFER13 = 34866,
    DRAW_BUFFER14 = 34867,
    DRAW_BUFFER15 = 34868,
    MAX_FRAGMENT_UNIFORM_COMPONENTS = 35657,
    MAX_VERTEX_UNIFORM_COMPONENTS = 35658,
    SAMPLER_3D = 35679,
    SAMPLER_2D_SHADOW = 35682,
    FRAGMENT_SHADER_DERIVATIVE_HINT = 35723,
    PIXEL_PACK_BUFFER = 35051,
    PIXEL_UNPACK_BUFFER = 35052,
    PIXEL_PACK_BUFFER_BINDING = 35053,
    PIXEL_UNPACK_BUFFER_BINDING = 35055,
    FLOAT_MAT2x3 = 35685,
    FLOAT_MAT2x4 = 35686,
    FLOAT_MAT3x2 = 35687,
    FLOAT_MAT3x4 = 35688,
    FLOAT_MAT4x2 = 35689,
    FLOAT_MAT4x3 = 35690,
    SRGB = 35904,
    SRGB8 = 35905,
    SRGB8_ALPHA8 = 35907,
    COMPARE_REF_TO_TEXTURE = 34894,
    RGBA32F = 34836,
    RGB32F = 34837,
    RGBA16F = 34842,
    RGB16F = 34843,
    VERTEX_ATTRIB_ARRAY_INTEGER = 35069,
    MAX_ARRAY_TEXTURE_LAYERS = 35071,
    MIN_PROGRAM_TEXEL_OFFSET = 35076,
    MAX_PROGRAM_TEXEL_OFFSET = 35077,
    MAX_VARYING_COMPONENTS = 35659,
    TEXTURE_2D_ARRAY = 35866,
    TEXTURE_BINDING_2D_ARRAY = 35869,
    R11F_G11F_B10F = 35898,
    UNSIGNED_INT_10F_11F_11F_REV = 35899,
    RGB9_E5 = 35901,
    UNSIGNED_INT_5_9_9_9_REV = 35902,
    TRANSFORM_FEEDBACK_BUFFER_MODE = 35967,
    MAX_TRANSFORM_FEEDBACK_SEPARATE_COMPONENTS = 35968,
    TRANSFORM_FEEDBACK_VARYINGS = 35971,
    TRANSFORM_FEEDBACK_BUFFER_START = 35972,
    TRANSFORM_FEEDBACK_BUFFER_SIZE = 35973,
    TRANSFORM_FEEDBACK_PRIMITIVES_WRITTEN = 35976,
    RASTERIZER_DISCARD = 35977,
    MAX_TRANSFORM_FEEDBACK_INTERLEAVED_COMPONENTS = 35978,
    MAX_TRANSFORM_FEEDBACK_SEPARATE_ATTRIBS = 35979,
    INTERLEAVED_ATTRIBS = 35980,
    SEPARATE_ATTRIBS = 35981,
    TRANSFORM_FEEDBACK_BUFFER = 35982,
    TRANSFORM_FEEDBACK_BUFFER_BINDING = 35983,
    RGBA32UI = 36208,
    RGB32UI = 36209,
    RGBA16UI = 36214,
    RGB16UI = 36215,
    RGBA8UI = 36220,
    RGB8UI = 36221,
    RGBA32I = 36226,
    RGB32I = 36227,
    RGBA16I = 36232,
    RGB16I = 36233,
    RGBA8I = 36238,
    RGB8I = 36239,
    RED_INTEGER = 36244,
    RGB_INTEGER = 36248,
    RGBA_INTEGER = 36249,
    SAMPLER_2D_ARRAY = 36289,
    SAMPLER_2D_ARRAY_SHADOW = 36292,
    SAMPLER_CUBE_SHADOW = 36293,
    UNSIGNED_INT_VEC2 = 36294,
    UNSIGNED_INT_VEC3 = 36295,
    UNSIGNED_INT_VEC4 = 36296,
    INT_SAMPLER_2D = 36298,
    INT_SAMPLER_3D = 36299,
    INT_SAMPLER_CUBE = 36300,
    INT_SAMPLER_2D_ARRAY = 36303,
    UNSIGNED_INT_SAMPLER_2D = 36306,
    UNSIGNED_INT_SAMPLER_3D = 36307,
    UNSIGNED_INT_SAMPLER_CUBE = 36308,
    UNSIGNED_INT_SAMPLER_2D_ARRAY = 36311,
    DEPTH_COMPONENT32F = 36012,
    DEPTH32F_STENCIL8 = 36013,
    FLOAT_32_UNSIGNED_INT_24_8_REV = 36269,
    FRAMEBUFFER_ATTACHMENT_COLOR_ENCODING = 33296,
    FRAMEBUFFER_ATTACHMENT_COMPONENT_TYPE = 33297,
    FRAMEBUFFER_ATTACHMENT_RED_SIZE = 33298,
    FRAMEBUFFER_ATTACHMENT_GREEN_SIZE = 33299,
    FRAMEBUFFER_ATTACHMENT_BLUE_SIZE = 33300,
    FRAMEBUFFER_ATTACHMENT_ALPHA_SIZE = 33301,
    FRAMEBUFFER_ATTACHMENT_DEPTH_SIZE = 33302,
    FRAMEBUFFER_ATTACHMENT_STENCIL_SIZE = 33303,
    FRAMEBUFFER_DEFAULT = 33304,
    UNSIGNED_INT_24_8 = 34042,
    DEPTH24_STENCIL8 = 35056,
    UNSIGNED_NORMALIZED = 35863,
    DRAW_FRAMEBUFFER_BINDING = 36006,
    READ_FRAMEBUFFER = 36008,
    DRAW_FRAMEBUFFER = 36009,
    READ_FRAMEBUFFER_BINDING = 36010,
    RENDERBUFFER_SAMPLES = 36011,
    FRAMEBUFFER_ATTACHMENT_TEXTURE_LAYER = 36052,
    MAX_COLOR_ATTACHMENTS = 36063,
    COLOR_ATTACHMENT1 = 36065,
    COLOR_ATTACHMENT2 = 36066,
    COLOR_ATTACHMENT3 = 36067,
    COLOR_ATTACHMENT4 = 36068,
    COLOR_ATTACHMENT5 = 36069,
    COLOR_ATTACHMENT6 = 36070,
    COLOR_ATTACHMENT7 = 36071,
    COLOR_ATTACHMENT8 = 36072,
    COLOR_ATTACHMENT9 = 36073,
    COLOR_ATTACHMENT10 = 36074,
    COLOR_ATTACHMENT11 = 36075,
    COLOR_ATTACHMENT12 = 36076,
    COLOR_ATTACHMENT13 = 36077,
    COLOR_ATTACHMENT14 = 36078,
    COLOR_ATTACHMENT15 = 36079,
    FRAMEBUFFER_INCOMPLETE_MULTISAMPLE = 36182,
    MAX_SAMPLES = 36183,
    HALF_FLOAT = 5131,
    RG = 33319,
    RG_INTEGER = 33320,
    R8 = 33321,
    RG8 = 33323,
    R16F = 33325,
    R32F = 33326,
    RG16F = 33327,
    RG32F = 33328,
    R8I = 33329,
    R8UI = 33330,
    R16I = 33331,
    R16UI = 33332,
    R32I = 33333,
    R32UI = 33334,
    RG8I = 33335,
    RG8UI = 33336,
    RG16I = 33337,
    RG16UI = 33338,
    RG32I = 33339,
    RG32UI = 33340,
    VERTEX_ARRAY_BINDING = 34229,
    R8_SNORM = 36756,
    RG8_SNORM = 36757,
    RGB8_SNORM = 36758,
    RGBA8_SNORM = 36759,
    SIGNED_NORMALIZED = 36764,
    COPY_READ_BUFFER = 36662,
    COPY_WRITE_BUFFER = 36663,
    COPY_READ_BUFFER_BINDING = 36662,
    COPY_WRITE_BUFFER_BINDING = 36663,
    UNIFORM_BUFFER = 35345,
    UNIFORM_BUFFER_BINDING = 35368,
    UNIFORM_BUFFER_START = 35369,
    UNIFORM_BUFFER_SIZE = 35370,
    MAX_VERTEX_UNIFORM_BLOCKS = 35371,
    MAX_FRAGMENT_UNIFORM_BLOCKS = 35373,
    MAX_COMBINED_UNIFORM_BLOCKS = 35374,
    MAX_UNIFORM_BUFFER_BINDINGS = 35375,
    MAX_UNIFORM_BLOCK_SIZE = 35376,
    MAX_COMBINED_VERTEX_UNIFORM_COMPONENTS = 35377,
    MAX_COMBINED_FRAGMENT_UNIFORM_COMPONENTS = 35379,
    UNIFORM_BUFFER_OFFSET_ALIGNMENT = 35380,
    ACTIVE_UNIFORM_BLOCKS = 35382,
    UNIFORM_TYPE = 35383,
    UNIFORM_SIZE = 35384,
    UNIFORM_BLOCK_INDEX = 35386,
    UNIFORM_OFFSET = 35387,
    UNIFORM_ARRAY_STRIDE = 35388,
    UNIFORM_MATRIX_STRIDE = 35389,
    UNIFORM_IS_ROW_MAJOR = 35390,
    UNIFORM_BLOCK_BINDING = 35391,
    UNIFORM_BLOCK_DATA_SIZE = 35392,
    UNIFORM_BLOCK_ACTIVE_UNIFORMS = 35394,
    UNIFORM_BLOCK_ACTIVE_UNIFORM_INDICES = 35395,
    UNIFORM_BLOCK_REFERENCED_BY_VERTEX_SHADER = 35396,
    UNIFORM_BLOCK_REFERENCED_BY_FRAGMENT_SHADER = 35398,
    INVALID_INDEX = 4294967295,
    MAX_VERTEX_OUTPUT_COMPONENTS = 37154,
    MAX_FRAGMENT_INPUT_COMPONENTS = 37157,
    MAX_SERVER_WAIT_TIMEOUT = 37137,
    OBJECT_TYPE = 37138,
    SYNC_CONDITION = 37139,
    SYNC_STATUS = 37140,
    SYNC_FLAGS = 37141,
    SYNC_FENCE = 37142,
    SYNC_GPU_COMMANDS_COMPLETE = 37143,
    UNSIGNALED = 37144,
    SIGNALED = 37145,
    ALREADY_SIGNALED = 37146,
    TIMEOUT_EXPIRED = 37147,
    CONDITION_SATISFIED = 37148,
    WAIT_FAILED = 37149,
    SYNC_FLUSH_COMMANDS_BIT = 1,
    VERTEX_ATTRIB_ARRAY_DIVISOR = 35070,
    ANY_SAMPLES_PASSED = 35887,
    ANY_SAMPLES_PASSED_CONSERVATIVE = 36202,
    SAMPLER_BINDING = 35097,
    RGB10_A2UI = 36975,
    INT_2_10_10_10_REV = 36255,
    TRANSFORM_FEEDBACK = 36386,
    TRANSFORM_FEEDBACK_PAUSED = 36387,
    TRANSFORM_FEEDBACK_ACTIVE = 36388,
    TRANSFORM_FEEDBACK_BINDING = 36389,
    COMPRESSED_R11_EAC = 37488,
    COMPRESSED_SIGNED_R11_EAC = 37489,
    COMPRESSED_RG11_EAC = 37490,
    COMPRESSED_SIGNED_RG11_EAC = 37491,
    COMPRESSED_RGB8_ETC2 = 37492,
    COMPRESSED_SRGB8_ETC2 = 37493,
    COMPRESSED_RGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37494,
    COMPRESSED_SRGB8_PUNCHTHROUGH_ALPHA1_ETC2 = 37495,
    COMPRESSED_RGBA8_ETC2_EAC = 37496,
    COMPRESSED_SRGB8_ALPHA8_ETC2_EAC = 37497,
    TEXTURE_IMMUTABLE_FORMAT = 37167,
    MAX_ELEMENT_INDEX = 36203,
    TEXTURE_IMMUTABLE_LEVELS = 33503,
    MAX_TEXTURE_MAX_ANISOTROPY_EXT = 34047
}

export namespace ArcGISTiledElevationTerrainProvider {
    /**
     * Initialization options for the ArcGISTiledElevationTerrainProvider constructor
     * [token] - The authorization token to use to connect to the service.
     * [ellipsoid] - The ellipsoid.  If the tilingScheme is specified,
     *                    this parameter is ignored and the tiling scheme's ellipsoid is used instead.
     *                    If neither parameter is specified, the WGS84 ellipsoid is used.
     */
    type ConstructorOptions = {
        token?: string;
        ellipsoid?: Ellipsoid;
    };
}

/**
 * <div class="notice">
 * To construct a CesiumTerrainProvider, call {@link ArcGISTiledElevationTerrainProvider.fromUrl}. Do not call the constructor directly.
 * </div>
 *
 * A {@link TerrainProvider} that produces terrain geometry by tessellating height maps
 * retrieved from Elevation Tiles of an an ArcGIS ImageService.
 * @example
 * const terrainProvider = await Cesium.ArcGISTiledElevationTerrainProvider.fromUrl("https://elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer", {
 *   token: "KED1aF_I4UzXOHy3BnhwyBHU4l5oY6rO6walkmHoYqGp4XyIWUd5YZUC1ZrLAzvV40pR6gBXQayh0eFA8m6vPg.."
 * });
 * viewer.terrainProvider = terrainProvider;
 * @param [options] - A url or an object describing initialization options
 */
export class ArcGISTiledElevationTerrainProvider {
    constructor(options?: CesiumTerrainProvider.ConstructorOptions);
    /**
     * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing
     * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
     * are passed an instance of {@link TileProviderError}.
     */
    readonly errorEvent: Event;
    /**
     * Gets the credit to display when this terrain provider is active.  Typically this is used to credit
     * the source of the terrain.
     */
    readonly credit: Credit;
    /**
     * Gets the tiling scheme used by this provider.
     */
    readonly tilingScheme: GeographicTilingScheme;
    /**
     * Gets a value indicating whether or not the provider includes a water mask.  The water mask
     * indicates which areas of the globe are water rather than land, so they can be rendered
     * as a reflective surface with animated waves.
     */
    readonly hasWaterMask: boolean;
    /**
     * Gets a value indicating whether or not the requested tiles include vertex normals.
     */
    readonly hasVertexNormals: boolean;
    /**
     * Gets an object that can be used to determine availability of terrain from this provider, such as
     * at points and in rectangles. This property may be undefined if availability
     * information is not available.
     */
    readonly availability: TileAvailability;
    /**
     * Creates a {@link TerrainProvider} that produces terrain geometry by tessellating height maps
     * retrieved from Elevation Tiles of an an ArcGIS ImageService.
     * @example
     * const terrainProvider = await Cesium.ArcGISTiledElevationTerrainProvider.fromUrl("https://elevation3d.arcgis.com/arcgis/rest/services/WorldElevation3D/Terrain3D/ImageServer", {
     *   token: "KED1aF_I4UzXOHy3BnhwyBHU4l5oY6rO6walkmHoYqGp4XyIWUd5YZUC1ZrLAzvV40pR6gBXQayh0eFA8m6vPg.."
     * });
     * viewer.terrainProvider = terrainProvider;
     * @param url - The URL of the ArcGIS ImageServer service.
     * @param [options] - A url or an object describing initialization options.
     */
    static fromUrl(url: Resource | string | Promise<Resource> | Promise<string>, options?: ArcGISTiledElevationTerrainProvider.ConstructorOptions): Promise<ArcGISTiledElevationTerrainProvider>;
    /**
     * Requests the geometry for a given tile. The result includes terrain
     * data and indicates that all child tiles are available.
     * @param x - The X coordinate of the tile for which to request geometry.
     * @param y - The Y coordinate of the tile for which to request geometry.
     * @param level - The level of the tile for which to request geometry.
     * @param [request] - The request object. Intended for internal use only.
     * @returns A promise for the requested geometry.  If this method
     *          returns undefined instead of a promise, it is an indication that too many requests are already
     *          pending and the request will be retried later.
     */
    requestTileGeometry(x: number, y: number, level: number, request?: Request): Promise<TerrainData> | undefined;
    /**
     * Gets the maximum geometric error allowed in a tile at a given level.
     * @param level - The tile level for which to get the maximum geometric error.
     * @returns The maximum geometric error.
     */
    getLevelMaximumGeometricError(level: number): number;
    /**
     * Determines whether data for a tile is available to be loaded.
     * @param x - The X coordinate of the tile for which to request geometry.
     * @param y - The Y coordinate of the tile for which to request geometry.
     * @param level - The level of the tile for which to request geometry.
     * @returns Undefined if not supported, otherwise true or false.
     */
    getTileDataAvailable(x: number, y: number, level: number): boolean | undefined;
    /**
     * Makes sure we load availability data for a tile
     * @param x - The X coordinate of the tile for which to request geometry.
     * @param y - The Y coordinate of the tile for which to request geometry.
     * @param level - The level of the tile for which to request geometry.
     * @returns This provider does not support loading availability.
     */
    loadTileDataAvailability(x: number, y: number, level: number): undefined;
}

/**
 * ArcType defines the path that should be taken connecting vertices.
 */
export enum ArcType {
    /**
     * Straight line that does not conform to the surface of the ellipsoid.
     */
    NONE = 0,
    /**
     * Follow geodesic path.
     */
    GEODESIC = 1,
    /**
     * Follow rhumb or loxodrome path.
     */
    RHUMB = 2
}

/**
 * A collection of key-value pairs that is stored as a hash for easy
 * lookup but also provides an array for fast iteration.
 */
export class AssociativeArray {
    constructor();
    /**
     * Gets the number of items in the collection.
     */
    length: number;
    /**
     * Gets an unordered array of all values in the collection.
     * This is a live array that will automatically reflect the values in the collection,
     * it should not be modified directly.
     */
    values: any[];
    /**
     * Determines if the provided key is in the array.
     * @param key - The key to check.
     * @returns <code>true</code> if the key is in the array, <code>false</code> otherwise.
     */
    contains(key: string | number): boolean;
    /**
     * Associates the provided key with the provided value.  If the key already
     * exists, it is overwritten with the new value.
     * @param key - A unique identifier.
     * @param value - The value to associate with the provided key.
     */
    set(key: string | number, value: any): void;
    /**
     * Retrieves the value associated with the provided key.
     * @param key - The key whose value is to be retrieved.
     * @returns The associated value, or undefined if the key does not exist in the collection.
     */
    get(key: string | number): any;
    /**
     * Removes a key-value pair from the collection.
     * @param key - The key to be removed.
     * @returns True if it was removed, false if the key was not in the collection.
     */
    remove(key: string | number): boolean;
    /**
     * Clears the collection.
     */
    removeAll(): void;
}

/**
 * Creates an instance of an AxisAlignedBoundingBox from the minimum and maximum points along the x, y, and z axes.
 * @param [minimum = Cartesian3.ZERO] - The minimum point along the x, y, and z axes.
 * @param [maximum = Cartesian3.ZERO] - The maximum point along the x, y, and z axes.
 * @param [center] - The center of the box; automatically computed if not supplied.
 */
export class AxisAlignedBoundingBox {
    constructor(minimum?: Cartesian3, maximum?: Cartesian3, center?: Cartesian3);
    /**
     * The minimum point defining the bounding box.
     */
    minimum: Cartesian3;
    /**
     * The maximum point defining the bounding box.
     */
    maximum: Cartesian3;
    /**
     * The center point of the bounding box.
     */
    center: Cartesian3;
    /**
     * Creates an instance of an AxisAlignedBoundingBox from its corners.
     * @example
     * // Compute an axis aligned bounding box from the two corners.
     * const box = Cesium.AxisAlignedBoundingBox.fromCorners(new Cesium.Cartesian3(-1, -1, -1), new Cesium.Cartesian3(1, 1, 1));
     * @param minimum - The minimum point along the x, y, and z axes.
     * @param maximum - The maximum point along the x, y, and z axes.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.
     */
    static fromCorners(minimum: Cartesian3, maximum: Cartesian3, result?: AxisAlignedBoundingBox): AxisAlignedBoundingBox;
    /**
     * Computes an instance of an AxisAlignedBoundingBox. The box is determined by
     * finding the points spaced the farthest apart on the x, y, and z axes.
     * @example
     * // Compute an axis aligned bounding box enclosing two points.
     * const box = Cesium.AxisAlignedBoundingBox.fromPoints([new Cesium.Cartesian3(2, 0, 0), new Cesium.Cartesian3(-2, 0, 0)]);
     * @param positions - List of points that the bounding box will enclose.  Each point must have a <code>x</code>, <code>y</code>, and <code>z</code> properties.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.
     */
    static fromPoints(positions: Cartesian3[], result?: AxisAlignedBoundingBox): AxisAlignedBoundingBox;
    /**
     * Duplicates a AxisAlignedBoundingBox instance.
     * @param box - The bounding box to duplicate.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new AxisAlignedBoundingBox instance if none was provided. (Returns undefined if box is undefined)
     */
    static clone(box: AxisAlignedBoundingBox, result?: AxisAlignedBoundingBox): AxisAlignedBoundingBox;
    /**
     * Compares the provided AxisAlignedBoundingBox componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [left] - The first AxisAlignedBoundingBox.
     * @param [right] - The second AxisAlignedBoundingBox.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    static equals(left?: AxisAlignedBoundingBox, right?: AxisAlignedBoundingBox): boolean;
    /**
     * Determines which side of a plane a box is located.
     * @param box - The bounding box to test.
     * @param plane - The plane to test against.
     * @returns {@link Intersect.INSIDE} if the entire box is on the side of the plane
     *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is
     *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box
     *                      intersects the plane.
     */
    static intersectPlane(box: AxisAlignedBoundingBox, plane: Plane): Intersect;
    /**
     * Duplicates this AxisAlignedBoundingBox instance.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new AxisAlignedBoundingBox instance if one was not provided.
     */
    clone(result?: AxisAlignedBoundingBox): AxisAlignedBoundingBox;
    /**
     * Determines which side of a plane this box is located.
     * @param plane - The plane to test against.
     * @returns {@link Intersect.INSIDE} if the entire box is on the side of the plane
     *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is
     *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box
     *                      intersects the plane.
     */
    intersectPlane(plane: Plane): Intersect;
    /**
     * Compares this AxisAlignedBoundingBox against the provided AxisAlignedBoundingBox componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [right] - The right hand side AxisAlignedBoundingBox.
     * @returns <code>true</code> if they are equal, <code>false</code> otherwise.
     */
    equals(right?: AxisAlignedBoundingBox): boolean;
}

/**
 * Provides geocoding through Bing Maps.
 * @param options - Object with the following properties:
 * @param options.key - A key to use with the Bing Maps geocoding service
 * @param [options.culture] - A Bing Maps {@link https://docs.microsoft.com/en-us/bingmaps/rest-services/common-parameters-and-types/supported-culture-codes|Culture Code} to return results in a specific culture and language.
 */
export class BingMapsGeocoderService {
    constructor(options: {
        key: string;
        culture?: string;
    });
    /**
     * The URL endpoint for the Bing geocoder service
     */
    readonly url: string;
    /**
     * The key for the Bing geocoder service
     */
    readonly key: string;
    /**
     * Gets the credit to display after a geocode is performed. Typically this is used to credit
     * the geocoder service.
     */
    readonly credit: Credit | undefined;
    /**
     * @param query - The query to be sent to the geocoder service
     */
    geocode(query: string): Promise<GeocoderService.Result[]>;
}

/**
 * A bounding rectangle given by a corner, width and height.
 * @param [x = 0.0] - The x coordinate of the rectangle.
 * @param [y = 0.0] - The y coordinate of the rectangle.
 * @param [width = 0.0] - The width of the rectangle.
 * @param [height = 0.0] - The height of the rectangle.
 */
export class BoundingRectangle {
    constructor(x?: number, y?: number, width?: number, height?: number);
    /**
     * The x coordinate of the rectangle.
     */
    x: number;
    /**
     * The y coordinate of the rectangle.
     */
    y: number;
    /**
     * The width of the rectangle.
     */
    width: number;
    /**
     * The height of the rectangle.
     */
    height: number;
    /**
     * The number of elements used to pack the object into an array.
     */
    static packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: BoundingRectangle, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new BoundingRectangle instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: BoundingRectangle): BoundingRectangle;
    /**
     * Computes a bounding rectangle enclosing the list of 2D points.
     * The rectangle is oriented with the corner at the bottom left.
     * @param positions - List of points that the bounding rectangle will enclose.  Each point must have <code>x</code> and <code>y</code> properties.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new BoundingRectangle instance if one was not provided.
     */
    static fromPoints(positions: Cartesian2[], result?: BoundingRectangle): BoundingRectangle;
    /**
     * Computes a bounding rectangle from a rectangle.
     * @param rectangle - The valid rectangle used to create a bounding rectangle.
     * @param [projection = GeographicProjection] - The projection used to project the rectangle into 2D.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new BoundingRectangle instance if one was not provided.
     */
    static fromRectangle(rectangle: Rectangle, projection?: any, result?: BoundingRectangle): BoundingRectangle;
    /**
     * Duplicates a BoundingRectangle instance.
     * @param rectangle - The bounding rectangle to duplicate.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new BoundingRectangle instance if one was not provided. (Returns undefined if rectangle is undefined)
     */
    static clone(rectangle: BoundingRectangle, result?: BoundingRectangle): BoundingRectangle;
    /**
     * Computes a bounding rectangle that is the union of the left and right bounding rectangles.
     * @param left - A rectangle to enclose in bounding rectangle.
     * @param right - A rectangle to enclose in a bounding rectangle.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new BoundingRectangle instance if one was not provided.
     */
    static union(left: BoundingRectangle, right: BoundingRectangle, result?: BoundingRectangle): BoundingRectangle;
    /**
     * Computes a bounding rectangle by enlarging the provided rectangle until it contains the provided point.
     * @param rectangle - A rectangle to expand.
     * @param point - A point to enclose in a bounding rectangle.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new BoundingRectangle instance if one was not provided.
     */
    static expand(rectangle: BoundingRectangle, point: Cartesian2, result?: BoundingRectangle): BoundingRectangle;
    /**
     * Determines if two rectangles intersect.
     * @param left - A rectangle to check for intersection.
     * @param right - The other rectangle to check for intersection.
     * @returns <code>Intersect.INTERSECTING</code> if the rectangles intersect, <code>Intersect.OUTSIDE</code> otherwise.
     */
    static intersect(left: BoundingRectangle, right: BoundingRectangle): Intersect;
    /**
     * Compares the provided BoundingRectangles componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [left] - The first BoundingRectangle.
     * @param [right] - The second BoundingRectangle.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    static equals(left?: BoundingRectangle, right?: BoundingRectangle): boolean;
    /**
     * Duplicates this BoundingRectangle instance.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new BoundingRectangle instance if one was not provided.
     */
    clone(result?: BoundingRectangle): BoundingRectangle;
    /**
     * Determines if this rectangle intersects with another.
     * @param right - A rectangle to check for intersection.
     * @returns <code>Intersect.INTERSECTING</code> if the rectangles intersect, <code>Intersect.OUTSIDE</code> otherwise.
     */
    intersect(right: BoundingRectangle): Intersect;
    /**
     * Compares this BoundingRectangle against the provided BoundingRectangle componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [right] - The right hand side BoundingRectangle.
     * @returns <code>true</code> if they are equal, <code>false</code> otherwise.
     */
    equals(right?: BoundingRectangle): boolean;
}

/**
 * A bounding sphere with a center and a radius.
 * @param [center = Cartesian3.ZERO] - The center of the bounding sphere.
 * @param [radius = 0.0] - The radius of the bounding sphere.
 */
export class BoundingSphere {
    constructor(center?: Cartesian3, radius?: number);
    /**
     * The center point of the sphere.
     */
    center: Cartesian3;
    /**
     * The radius of the sphere.
     */
    radius: number;
    /**
     * Computes a tight-fitting bounding sphere enclosing a list of 3D Cartesian points.
     * The bounding sphere is computed by running two algorithms, a naive algorithm and
     * Ritter's algorithm. The smaller of the two spheres is used to ensure a tight fit.
     * @param [positions] - An array of points that the bounding sphere will enclose.  Each point must have <code>x</code>, <code>y</code>, and <code>z</code> properties.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new BoundingSphere instance if one was not provided.
     */
    static fromPoints(positions?: Cartesian3[], result?: BoundingSphere): BoundingSphere;
    /**
     * Computes a bounding sphere from a rectangle projected in 2D.
     * @param [rectangle] - The rectangle around which to create a bounding sphere.
     * @param [projection = GeographicProjection] - The projection used to project the rectangle into 2D.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new BoundingSphere instance if none was provided.
     */
    static fromRectangle2D(rectangle?: Rectangle, projection?: any, result?: BoundingSphere): BoundingSphere;
    /**
     * Computes a bounding sphere from a rectangle projected in 2D.  The bounding sphere accounts for the
     * object's minimum and maximum heights over the rectangle.
     * @param [rectangle] - The rectangle around which to create a bounding sphere.
     * @param [projection = GeographicProjection] - The projection used to project the rectangle into 2D.
     * @param [minimumHeight = 0.0] - The minimum height over the rectangle.
     * @param [maximumHeight = 0.0] - The maximum height over the rectangle.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new BoundingSphere instance if none was provided.
     */
    static fromRectangleWithHeights2D(rectangle?: Rectangle, projection?: any, minimumHeight?: number, maximumHeight?: number, result?: BoundingSphere): BoundingSphere;
    /**
     * Computes a bounding sphere from a rectangle in 3D. The bounding sphere is created using a subsample of points
     * on the ellipsoid and contained in the rectangle. It may not be accurate for all rectangles on all types of ellipsoids.
     * @param [rectangle] - The valid rectangle used to create a bounding sphere.
     * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid used to determine positions of the rectangle.
     * @param [surfaceHeight = 0.0] - The height above the surface of the ellipsoid.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new BoundingSphere instance if none was provided.
     */
    static fromRectangle3D(rectangle?: Rectangle, ellipsoid?: Ellipsoid, surfaceHeight?: number, result?: BoundingSphere): BoundingSphere;
    /**
     * Computes a tight-fitting bounding sphere enclosing a list of 3D points, where the points are
     * stored in a flat array in X, Y, Z, order.  The bounding sphere is computed by running two
     * algorithms, a naive algorithm and Ritter's algorithm. The smaller of the two spheres is used to
     * ensure a tight fit.
     * @example
     * // Compute the bounding sphere from 3 positions, each specified relative to a center.
     * // In addition to the X, Y, and Z coordinates, the points array contains two additional
     * // elements per point which are ignored for the purpose of computing the bounding sphere.
     * const center = new Cesium.Cartesian3(1.0, 2.0, 3.0);
     * const points = [1.0, 2.0, 3.0, 0.1, 0.2,
     *               4.0, 5.0, 6.0, 0.1, 0.2,
     *               7.0, 8.0, 9.0, 0.1, 0.2];
     * const sphere = Cesium.BoundingSphere.fromVertices(points, center, 5);
     * @param [positions] - An array of points that the bounding sphere will enclose.  Each point
     *        is formed from three elements in the array in the order X, Y, Z.
     * @param [center = Cartesian3.ZERO] - The position to which the positions are relative, which need not be the
     *        origin of the coordinate system.  This is useful when the positions are to be used for
     *        relative-to-center (RTC) rendering.
     * @param [stride = 3] - The number of array elements per vertex.  It must be at least 3, but it may
     *        be higher.  Regardless of the value of this parameter, the X coordinate of the first position
     *        is at array index 0, the Y coordinate is at array index 1, and the Z coordinate is at array index
     *        2.  When stride is 3, the X coordinate of the next position then begins at array index 3.  If
     *        the stride is 5, however, two array elements are skipped and the next position begins at array
     *        index 5.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new BoundingSphere instance if one was not provided.
     */
    static fromVertices(positions?: number[], center?: Cartesian3, stride?: number, result?: BoundingSphere): BoundingSphere;
    /**
     * Computes a tight-fitting bounding sphere enclosing a list of EncodedCartesian3s, where the points are
     * stored in parallel flat arrays in X, Y, Z, order.  The bounding sphere is computed by running two
     * algorithms, a naive algorithm and Ritter's algorithm. The smaller of the two spheres is used to
     * ensure a tight fit.
     * @param [positionsHigh] - An array of high bits of the encoded cartesians that the bounding sphere will enclose.  Each point
     *        is formed from three elements in the array in the order X, Y, Z.
     * @param [positionsLow] - An array of low bits of the encoded cartesians that the bounding sphere will enclose.  Each point
     *        is formed from three elements in the array in the order X, Y, Z.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new BoundingSphere instance if one was not provided.
     */
    static fromEncodedCartesianVertices(positionsHigh?: number[], positionsLow?: number[], result?: BoundingSphere): BoundingSphere;
    /**
     * Computes a bounding sphere from the corner points of an axis-aligned bounding box.  The sphere
     * tightly and fully encompasses the box.
     * @example
     * // Create a bounding sphere around the unit cube
     * const sphere = Cesium.BoundingSphere.fromCornerPoints(new Cesium.Cartesian3(-0.5, -0.5, -0.5), new Cesium.Cartesian3(0.5, 0.5, 0.5));
     * @param [corner] - The minimum height over the rectangle.
     * @param [oppositeCorner] - The maximum height over the rectangle.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new BoundingSphere instance if none was provided.
     */
    static fromCornerPoints(corner?: Cartesian3, oppositeCorner?: Cartesian3, result?: BoundingSphere): BoundingSphere;
    /**
     * Creates a bounding sphere encompassing an ellipsoid.
     * @example
     * const boundingSphere = Cesium.BoundingSphere.fromEllipsoid(ellipsoid);
     * @param ellipsoid - The ellipsoid around which to create a bounding sphere.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new BoundingSphere instance if none was provided.
     */
    static fromEllipsoid(ellipsoid: Ellipsoid, result?: BoundingSphere): BoundingSphere;
    /**
     * Computes a tight-fitting bounding sphere enclosing the provided array of bounding spheres.
     * @param [boundingSpheres] - The array of bounding spheres.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new BoundingSphere instance if none was provided.
     */
    static fromBoundingSpheres(boundingSpheres?: BoundingSphere[], result?: BoundingSphere): BoundingSphere;
    /**
     * Computes a tight-fitting bounding sphere enclosing the provided oriented bounding box.
     * @param orientedBoundingBox - The oriented bounding box.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new BoundingSphere instance if none was provided.
     */
    static fromOrientedBoundingBox(orientedBoundingBox: OrientedBoundingBox, result?: BoundingSphere): BoundingSphere;
    /**
     * Computes a tight-fitting bounding sphere enclosing the provided affine transformation.
     * @param transformation - The affine transformation.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new BoundingSphere instance if none was provided.
     */
    static fromTransformation(transformation: Matrix4, result?: BoundingSphere): BoundingSphere;
    /**
     * Duplicates a BoundingSphere instance.
     * @param sphere - The bounding sphere to duplicate.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new BoundingSphere instance if none was provided. (Returns undefined if sphere is undefined)
     */
    static clone(sphere: BoundingSphere, result?: BoundingSphere): BoundingSphere;
    /**
     * The number of elements used to pack the object into an array.
     */
    static packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: BoundingSphere, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new BoundingSphere instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: BoundingSphere): BoundingSphere;
    /**
     * Computes a bounding sphere that contains both the left and right bounding spheres.
     * @param left - A sphere to enclose in a bounding sphere.
     * @param right - A sphere to enclose in a bounding sphere.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new BoundingSphere instance if none was provided.
     */
    static union(left: BoundingSphere, right: BoundingSphere, result?: BoundingSphere): BoundingSphere;
    /**
     * Computes a bounding sphere by enlarging the provided sphere to contain the provided point.
     * @param sphere - A sphere to expand.
     * @param point - A point to enclose in a bounding sphere.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new BoundingSphere instance if none was provided.
     */
    static expand(sphere: BoundingSphere, point: Cartesian3, result?: BoundingSphere): BoundingSphere;
    /**
     * Determines which side of a plane a sphere is located.
     * @param sphere - The bounding sphere to test.
     * @param plane - The plane to test against.
     * @returns {@link Intersect.INSIDE} if the entire sphere is on the side of the plane
     *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire sphere is
     *                      on the opposite side, and {@link Intersect.INTERSECTING} if the sphere
     *                      intersects the plane.
     */
    static intersectPlane(sphere: BoundingSphere, plane: Plane): Intersect;
    /**
     * Applies a 4x4 affine transformation matrix to a bounding sphere.
     * @param sphere - The bounding sphere to apply the transformation to.
     * @param transform - The transformation matrix to apply to the bounding sphere.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new BoundingSphere instance if none was provided.
     */
    static transform(sphere: BoundingSphere, transform: Matrix4, result?: BoundingSphere): BoundingSphere;
    /**
     * Computes the estimated distance squared from the closest point on a bounding sphere to a point.
     * @example
     * // Sort bounding spheres from back to front
     * spheres.sort(function(a, b) {
     *     return Cesium.BoundingSphere.distanceSquaredTo(b, camera.positionWC) - Cesium.BoundingSphere.distanceSquaredTo(a, camera.positionWC);
     * });
     * @param sphere - The sphere.
     * @param cartesian - The point
     * @returns The distance squared from the bounding sphere to the point. Returns 0 if the point is inside the sphere.
     */
    static distanceSquaredTo(sphere: BoundingSphere, cartesian: Cartesian3): number;
    /**
     * Applies a 4x4 affine transformation matrix to a bounding sphere where there is no scale
     * The transformation matrix is not verified to have a uniform scale of 1.
     * This method is faster than computing the general bounding sphere transform using {@link BoundingSphere.transform}.
     * @example
     * const modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(positionOnEllipsoid);
     * const boundingSphere = new Cesium.BoundingSphere();
     * const newBoundingSphere = Cesium.BoundingSphere.transformWithoutScale(boundingSphere, modelMatrix);
     * @param sphere - The bounding sphere to apply the transformation to.
     * @param transform - The transformation matrix to apply to the bounding sphere.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new BoundingSphere instance if none was provided.
     */
    static transformWithoutScale(sphere: BoundingSphere, transform: Matrix4, result?: BoundingSphere): BoundingSphere;
    /**
     * The distances calculated by the vector from the center of the bounding sphere to position projected onto direction
     * plus/minus the radius of the bounding sphere.
     * <br>
     * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the
     * closest and farthest planes from position that intersect the bounding sphere.
     * @param sphere - The bounding sphere to calculate the distance to.
     * @param position - The position to calculate the distance from.
     * @param direction - The direction from position.
     * @param [result] - A Interval to store the nearest and farthest distances.
     * @returns The nearest and farthest distances on the bounding sphere from position in direction.
     */
    static computePlaneDistances(sphere: BoundingSphere, position: Cartesian3, direction: Cartesian3, result?: Interval): Interval;
    /**
     * Creates a bounding sphere in 2D from a bounding sphere in 3D world coordinates.
     * @param sphere - The bounding sphere to transform to 2D.
     * @param [projection = GeographicProjection] - The projection to 2D.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new BoundingSphere instance if none was provided.
     */
    static projectTo2D(sphere: BoundingSphere, projection?: any, result?: BoundingSphere): BoundingSphere;
    /**
     * Determines whether or not a sphere is hidden from view by the occluder.
     * @param sphere - The bounding sphere surrounding the occludee object.
     * @param occluder - The occluder.
     * @returns <code>true</code> if the sphere is not visible; otherwise <code>false</code>.
     */
    static isOccluded(sphere: BoundingSphere, occluder: Occluder): boolean;
    /**
     * Compares the provided BoundingSphere componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [left] - The first BoundingSphere.
     * @param [right] - The second BoundingSphere.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    static equals(left?: BoundingSphere, right?: BoundingSphere): boolean;
    /**
     * Determines which side of a plane the sphere is located.
     * @param plane - The plane to test against.
     * @returns {@link Intersect.INSIDE} if the entire sphere is on the side of the plane
     *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire sphere is
     *                      on the opposite side, and {@link Intersect.INTERSECTING} if the sphere
     *                      intersects the plane.
     */
    intersectPlane(plane: Plane): Intersect;
    /**
     * Computes the estimated distance squared from the closest point on a bounding sphere to a point.
     * @example
     * // Sort bounding spheres from back to front
     * spheres.sort(function(a, b) {
     *     return b.distanceSquaredTo(camera.positionWC) - a.distanceSquaredTo(camera.positionWC);
     * });
     * @param cartesian - The point
     * @returns The estimated distance squared from the bounding sphere to the point.
     */
    distanceSquaredTo(cartesian: Cartesian3): number;
    /**
     * The distances calculated by the vector from the center of the bounding sphere to position projected onto direction
     * plus/minus the radius of the bounding sphere.
     * <br>
     * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the
     * closest and farthest planes from position that intersect the bounding sphere.
     * @param position - The position to calculate the distance from.
     * @param direction - The direction from position.
     * @param [result] - A Interval to store the nearest and farthest distances.
     * @returns The nearest and farthest distances on the bounding sphere from position in direction.
     */
    computePlaneDistances(position: Cartesian3, direction: Cartesian3, result?: Interval): Interval;
    /**
     * Determines whether or not a sphere is hidden from view by the occluder.
     * @param occluder - The occluder.
     * @returns <code>true</code> if the sphere is not visible; otherwise <code>false</code>.
     */
    isOccluded(occluder: Occluder): boolean;
    /**
     * Compares this BoundingSphere against the provided BoundingSphere componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [right] - The right hand side BoundingSphere.
     * @returns <code>true</code> if they are equal, <code>false</code> otherwise.
     */
    equals(right?: BoundingSphere): boolean;
    /**
     * Duplicates this BoundingSphere instance.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new BoundingSphere instance if none was provided.
     */
    clone(result?: BoundingSphere): BoundingSphere;
    /**
     * Computes the radius of the BoundingSphere.
     * @returns The radius of the BoundingSphere.
     */
    volume(): number;
}

/**
 * Describes a cube centered at the origin.
 * @example
 * const box = new Cesium.BoxGeometry({
 *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,
 *   maximum : new Cesium.Cartesian3(250000.0, 250000.0, 250000.0),
 *   minimum : new Cesium.Cartesian3(-250000.0, -250000.0, -250000.0)
 * });
 * const geometry = Cesium.BoxGeometry.createGeometry(box);
 * @param options - Object with the following properties:
 * @param options.minimum - The minimum x, y, and z coordinates of the box.
 * @param options.maximum - The maximum x, y, and z coordinates of the box.
 * @param [options.vertexFormat = VertexFormat.DEFAULT] - The vertex attributes to be computed.
 */
export class BoxGeometry {
    constructor(options: {
        minimum: Cartesian3;
        maximum: Cartesian3;
        vertexFormat?: VertexFormat;
    });
    /**
     * Creates a cube centered at the origin given its dimensions.
     * @example
     * const box = Cesium.BoxGeometry.fromDimensions({
     *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,
     *   dimensions : new Cesium.Cartesian3(500000.0, 500000.0, 500000.0)
     * });
     * const geometry = Cesium.BoxGeometry.createGeometry(box);
     * @param options - Object with the following properties:
     * @param options.dimensions - The width, depth, and height of the box stored in the x, y, and z coordinates of the <code>Cartesian3</code>, respectively.
     * @param [options.vertexFormat = VertexFormat.DEFAULT] - The vertex attributes to be computed.
     */
    static fromDimensions(options: {
        dimensions: Cartesian3;
        vertexFormat?: VertexFormat;
    }): BoxGeometry;
    /**
     * Creates a cube from the dimensions of an AxisAlignedBoundingBox.
     * @example
     * const aabb = Cesium.AxisAlignedBoundingBox.fromPoints(Cesium.Cartesian3.fromDegreesArray([
     *      -72.0, 40.0,
     *      -70.0, 35.0,
     *      -75.0, 30.0,
     *      -70.0, 30.0,
     *      -68.0, 40.0
     * ]));
     * const box = Cesium.BoxGeometry.fromAxisAlignedBoundingBox(aabb);
     * @param boundingBox - A description of the AxisAlignedBoundingBox.
     */
    static fromAxisAlignedBoundingBox(boundingBox: AxisAlignedBoundingBox): BoxGeometry;
    /**
     * The number of elements used to pack the object into an array.
     */
    static packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: BoxGeometry, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new BoxGeometry instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: BoxGeometry): BoxGeometry;
    /**
     * Computes the geometric representation of a box, including its vertices, indices, and a bounding sphere.
     * @param boxGeometry - A description of the box.
     * @returns The computed vertices and indices.
     */
    static createGeometry(boxGeometry: BoxGeometry): Geometry | undefined;
}

/**
 * A description of the outline of a cube centered at the origin.
 * @example
 * const box = new Cesium.BoxOutlineGeometry({
 *   maximum : new Cesium.Cartesian3(250000.0, 250000.0, 250000.0),
 *   minimum : new Cesium.Cartesian3(-250000.0, -250000.0, -250000.0)
 * });
 * const geometry = Cesium.BoxOutlineGeometry.createGeometry(box);
 * @param options - Object with the following properties:
 * @param options.minimum - The minimum x, y, and z coordinates of the box.
 * @param options.maximum - The maximum x, y, and z coordinates of the box.
 */
export class BoxOutlineGeometry {
    constructor(options: {
        minimum: Cartesian3;
        maximum: Cartesian3;
    });
    /**
     * Creates an outline of a cube centered at the origin given its dimensions.
     * @example
     * const box = Cesium.BoxOutlineGeometry.fromDimensions({
     *   dimensions : new Cesium.Cartesian3(500000.0, 500000.0, 500000.0)
     * });
     * const geometry = Cesium.BoxOutlineGeometry.createGeometry(box);
     * @param options - Object with the following properties:
     * @param options.dimensions - The width, depth, and height of the box stored in the x, y, and z coordinates of the <code>Cartesian3</code>, respectively.
     */
    static fromDimensions(options: {
        dimensions: Cartesian3;
    }): BoxOutlineGeometry;
    /**
     * Creates an outline of a cube from the dimensions of an AxisAlignedBoundingBox.
     * @example
     * const aabb = Cesium.AxisAlignedBoundingBox.fromPoints(Cesium.Cartesian3.fromDegreesArray([
     *      -72.0, 40.0,
     *      -70.0, 35.0,
     *      -75.0, 30.0,
     *      -70.0, 30.0,
     *      -68.0, 40.0
     * ]));
     * const box = Cesium.BoxOutlineGeometry.fromAxisAlignedBoundingBox(aabb);
     *
     *
     * @param boundingBox - A description of the AxisAlignedBoundingBox.
     */
    static fromAxisAlignedBoundingBox(boundingBox: AxisAlignedBoundingBox): BoxOutlineGeometry;
    /**
     * The number of elements used to pack the object into an array.
     */
    static packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: BoxOutlineGeometry, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new BoxOutlineGeometry instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: BoxOutlineGeometry): BoxOutlineGeometry;
    /**
     * Computes the geometric representation of an outline of a box, including its vertices, indices, and a bounding sphere.
     * @param boxGeometry - A description of the box outline.
     * @returns The computed vertices and indices.
     */
    static createGeometry(boxGeometry: BoxOutlineGeometry): Geometry | undefined;
}

/**
 * A 2D Cartesian point.
 * @param [x = 0.0] - The X component.
 * @param [y = 0.0] - The Y component.
 */
export class Cartesian2 {
    constructor(x?: number, y?: number);
    /**
     * The X component.
     */
    x: number;
    /**
     * The Y component.
     */
    y: number;
    /**
     * Creates a Cartesian2 instance from x and y coordinates.
     * @param x - The x coordinate.
     * @param y - The y coordinate.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Cartesian2 instance if one was not provided.
     */
    static fromElements(x: number, y: number, result?: Cartesian2): Cartesian2;
    /**
     * Duplicates a Cartesian2 instance.
     * @param cartesian - The Cartesian to duplicate.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Cartesian2 instance if one was not provided. (Returns undefined if cartesian is undefined)
     */
    static clone(cartesian: Cartesian2, result?: Cartesian2): Cartesian2;
    /**
     * Creates a Cartesian2 instance from an existing Cartesian3.  This simply takes the
     * x and y properties of the Cartesian3 and drops z.
     * @param cartesian - The Cartesian3 instance to create a Cartesian2 instance from.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Cartesian2 instance if one was not provided.
     */
    static fromCartesian3(cartesian: Cartesian3, result?: Cartesian2): Cartesian2;
    /**
     * Creates a Cartesian2 instance from an existing Cartesian4.  This simply takes the
     * x and y properties of the Cartesian4 and drops z and w.
     * @param cartesian - The Cartesian4 instance to create a Cartesian2 instance from.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Cartesian2 instance if one was not provided.
     */
    static fromCartesian4(cartesian: Cartesian4, result?: Cartesian2): Cartesian2;
    /**
     * The number of elements used to pack the object into an array.
     */
    static packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: Cartesian2, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new Cartesian2 instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: Cartesian2): Cartesian2;
    /**
     * Flattens an array of Cartesian2s into an array of components.
     * @param array - The array of cartesians to pack.
     * @param [result] - The array onto which to store the result. If this is a typed array, it must have array.length * 2 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 2) elements.
     * @returns The packed array.
     */
    static packArray(array: Cartesian2[], result?: number[]): number[];
    /**
     * Unpacks an array of cartesian components into an array of Cartesian2s.
     * @param array - The array of components to unpack.
     * @param [result] - The array onto which to store the result.
     * @returns The unpacked array.
     */
    static unpackArray(array: number[], result?: Cartesian2[]): Cartesian2[];
    /**
     * Creates a Cartesian2 from two consecutive elements in an array.
     * @example
     * // Create a Cartesian2 with (1.0, 2.0)
     * const v = [1.0, 2.0];
     * const p = Cesium.Cartesian2.fromArray(v);
     *
     * // Create a Cartesian2 with (1.0, 2.0) using an offset into an array
     * const v2 = [0.0, 0.0, 1.0, 2.0];
     * const p2 = Cesium.Cartesian2.fromArray(v2, 2);
     * @param array - The array whose two consecutive elements correspond to the x and y components, respectively.
     * @param [startingIndex = 0] - The offset into the array of the first element, which corresponds to the x component.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Cartesian2 instance if one was not provided.
     */
    static fromArray(array: number[], startingIndex?: number, result?: Cartesian2): Cartesian2;
    /**
     * Computes the value of the maximum component for the supplied Cartesian.
     * @param cartesian - The cartesian to use.
     * @returns The value of the maximum component.
     */
    static maximumComponent(cartesian: Cartesian2): number;
    /**
     * Computes the value of the minimum component for the supplied Cartesian.
     * @param cartesian - The cartesian to use.
     * @returns The value of the minimum component.
     */
    static minimumComponent(cartesian: Cartesian2): number;
    /**
     * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.
     * @param first - A cartesian to compare.
     * @param second - A cartesian to compare.
     * @param result - The object into which to store the result.
     * @returns A cartesian with the minimum components.
     */
    static minimumByComponent(first: Cartesian2, second: Cartesian2, result: Cartesian2): Cartesian2;
    /**
     * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.
     * @param first - A cartesian to compare.
     * @param second - A cartesian to compare.
     * @param result - The object into which to store the result.
     * @returns A cartesian with the maximum components.
     */
    static maximumByComponent(first: Cartesian2, second: Cartesian2, result: Cartesian2): Cartesian2;
    /**
     * Constrain a value to lie between two values.
     * @param value - The value to clamp.
     * @param min - The minimum bound.
     * @param max - The maximum bound.
     * @param result - The object into which to store the result.
     * @returns The clamped value such that min <= result <= max.
     */
    static clamp(value: Cartesian2, min: Cartesian2, max: Cartesian2, result: Cartesian2): Cartesian2;
    /**
     * Computes the provided Cartesian's squared magnitude.
     * @param cartesian - The Cartesian instance whose squared magnitude is to be computed.
     * @returns The squared magnitude.
     */
    static magnitudeSquared(cartesian: Cartesian2): number;
    /**
     * Computes the Cartesian's magnitude (length).
     * @param cartesian - The Cartesian instance whose magnitude is to be computed.
     * @returns The magnitude.
     */
    static magnitude(cartesian: Cartesian2): number;
    /**
     * Computes the distance between two points.
     * @example
     * // Returns 1.0
     * const d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(2.0, 0.0));
     * @param left - The first point to compute the distance from.
     * @param right - The second point to compute the distance to.
     * @returns The distance between two points.
     */
    static distance(left: Cartesian2, right: Cartesian2): number;
    /**
     * Computes the squared distance between two points.  Comparing squared distances
     * using this function is more efficient than comparing distances using {@link Cartesian2#distance}.
     * @example
     * // Returns 4.0, not 2.0
     * const d = Cesium.Cartesian2.distance(new Cesium.Cartesian2(1.0, 0.0), new Cesium.Cartesian2(3.0, 0.0));
     * @param left - The first point to compute the distance from.
     * @param right - The second point to compute the distance to.
     * @returns The distance between two points.
     */
    static distanceSquared(left: Cartesian2, right: Cartesian2): number;
    /**
     * Computes the normalized form of the supplied Cartesian.
     * @param cartesian - The Cartesian to be normalized.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static normalize(cartesian: Cartesian2, result: Cartesian2): Cartesian2;
    /**
     * Computes the dot (scalar) product of two Cartesians.
     * @param left - The first Cartesian.
     * @param right - The second Cartesian.
     * @returns The dot product.
     */
    static dot(left: Cartesian2, right: Cartesian2): number;
    /**
     * Computes the magnitude of the cross product that would result from implicitly setting the Z coordinate of the input vectors to 0
     * @param left - The first Cartesian.
     * @param right - The second Cartesian.
     * @returns The cross product.
     */
    static cross(left: Cartesian2, right: Cartesian2): number;
    /**
     * Computes the componentwise product of two Cartesians.
     * @param left - The first Cartesian.
     * @param right - The second Cartesian.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static multiplyComponents(left: Cartesian2, right: Cartesian2, result: Cartesian2): Cartesian2;
    /**
     * Computes the componentwise quotient of two Cartesians.
     * @param left - The first Cartesian.
     * @param right - The second Cartesian.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static divideComponents(left: Cartesian2, right: Cartesian2, result: Cartesian2): Cartesian2;
    /**
     * Computes the componentwise sum of two Cartesians.
     * @param left - The first Cartesian.
     * @param right - The second Cartesian.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static add(left: Cartesian2, right: Cartesian2, result: Cartesian2): Cartesian2;
    /**
     * Computes the componentwise difference of two Cartesians.
     * @param left - The first Cartesian.
     * @param right - The second Cartesian.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static subtract(left: Cartesian2, right: Cartesian2, result: Cartesian2): Cartesian2;
    /**
     * Multiplies the provided Cartesian componentwise by the provided scalar.
     * @param cartesian - The Cartesian to be scaled.
     * @param scalar - The scalar to multiply with.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static multiplyByScalar(cartesian: Cartesian2, scalar: number, result: Cartesian2): Cartesian2;
    /**
     * Divides the provided Cartesian componentwise by the provided scalar.
     * @param cartesian - The Cartesian to be divided.
     * @param scalar - The scalar to divide by.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static divideByScalar(cartesian: Cartesian2, scalar: number, result: Cartesian2): Cartesian2;
    /**
     * Negates the provided Cartesian.
     * @param cartesian - The Cartesian to be negated.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static negate(cartesian: Cartesian2, result: Cartesian2): Cartesian2;
    /**
     * Computes the absolute value of the provided Cartesian.
     * @param cartesian - The Cartesian whose absolute value is to be computed.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static abs(cartesian: Cartesian2, result: Cartesian2): Cartesian2;
    /**
     * Computes the linear interpolation or extrapolation at t using the provided cartesians.
     * @param start - The value corresponding to t at 0.0.
     * @param end - The value corresponding to t at 1.0.
     * @param t - The point along t at which to interpolate.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static lerp(start: Cartesian2, end: Cartesian2, t: number, result: Cartesian2): Cartesian2;
    /**
     * Returns the angle, in radians, between the provided Cartesians.
     * @param left - The first Cartesian.
     * @param right - The second Cartesian.
     * @returns The angle between the Cartesians.
     */
    static angleBetween(left: Cartesian2, right: Cartesian2): number;
    /**
     * Returns the axis that is most orthogonal to the provided Cartesian.
     * @param cartesian - The Cartesian on which to find the most orthogonal axis.
     * @param result - The object onto which to store the result.
     * @returns The most orthogonal axis.
     */
    static mostOrthogonalAxis(cartesian: Cartesian2, result: Cartesian2): Cartesian2;
    /**
     * Compares the provided Cartesians componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [left] - The first Cartesian.
     * @param [right] - The second Cartesian.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    static equals(left?: Cartesian2, right?: Cartesian2): boolean;
    /**
     * Compares the provided Cartesians componentwise and returns
     * <code>true</code> if they pass an absolute or relative tolerance test,
     * <code>false</code> otherwise.
     * @param [left] - The first Cartesian.
     * @param [right] - The second Cartesian.
     * @param [relativeEpsilon = 0] - The relative epsilon tolerance to use for equality testing.
     * @param [absoluteEpsilon = relativeEpsilon] - The absolute epsilon tolerance to use for equality testing.
     * @returns <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
     */
    static equalsEpsilon(left?: Cartesian2, right?: Cartesian2, relativeEpsilon?: number, absoluteEpsilon?: number): boolean;
    /**
     * An immutable Cartesian2 instance initialized to (0.0, 0.0).
     */
    static readonly ZERO: Cartesian2;
    /**
     * An immutable Cartesian2 instance initialized to (1.0, 1.0).
     */
    static readonly ONE: Cartesian2;
    /**
     * An immutable Cartesian2 instance initialized to (1.0, 0.0).
     */
    static readonly UNIT_X: Cartesian2;
    /**
     * An immutable Cartesian2 instance initialized to (0.0, 1.0).
     */
    static readonly UNIT_Y: Cartesian2;
    /**
     * Duplicates this Cartesian2 instance.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Cartesian2 instance if one was not provided.
     */
    clone(result?: Cartesian2): Cartesian2;
    /**
     * Compares this Cartesian against the provided Cartesian componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [right] - The right hand side Cartesian.
     * @returns <code>true</code> if they are equal, <code>false</code> otherwise.
     */
    equals(right?: Cartesian2): boolean;
    /**
     * Compares this Cartesian against the provided Cartesian componentwise and returns
     * <code>true</code> if they pass an absolute or relative tolerance test,
     * <code>false</code> otherwise.
     * @param [right] - The right hand side Cartesian.
     * @param [relativeEpsilon = 0] - The relative epsilon tolerance to use for equality testing.
     * @param [absoluteEpsilon = relativeEpsilon] - The absolute epsilon tolerance to use for equality testing.
     * @returns <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
     */
    equalsEpsilon(right?: Cartesian2, relativeEpsilon?: number, absoluteEpsilon?: number): boolean;
    /**
     * Creates a string representing this Cartesian in the format '(x, y)'.
     * @returns A string representing the provided Cartesian in the format '(x, y)'.
     */
    toString(): string;
}

/**
 * A 3D Cartesian point.
 * @param [x = 0.0] - The X component.
 * @param [y = 0.0] - The Y component.
 * @param [z = 0.0] - The Z component.
 */
export class Cartesian3 {
    constructor(x?: number, y?: number, z?: number);
    /**
     * The X component.
     */
    x: number;
    /**
     * The Y component.
     */
    y: number;
    /**
     * The Z component.
     */
    z: number;
    /**
     * Converts the provided Spherical into Cartesian3 coordinates.
     * @param spherical - The Spherical to be converted to Cartesian3.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Cartesian3 instance if one was not provided.
     */
    static fromSpherical(spherical: Spherical, result?: Cartesian3): Cartesian3;
    /**
     * Creates a Cartesian3 instance from x, y and z coordinates.
     * @param x - The x coordinate.
     * @param y - The y coordinate.
     * @param z - The z coordinate.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Cartesian3 instance if one was not provided.
     */
    static fromElements(x: number, y: number, z: number, result?: Cartesian3): Cartesian3;
    /**
     * Duplicates a Cartesian3 instance.
     * @param cartesian - The Cartesian to duplicate.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Cartesian3 instance if one was not provided. (Returns undefined if cartesian is undefined)
     */
    static clone(cartesian: Cartesian3, result?: Cartesian3): Cartesian3;
    /**
     * Creates a Cartesian3 instance from an existing Cartesian4.  This simply takes the
     * x, y, and z properties of the Cartesian4 and drops w.
     * @param cartesian - The Cartesian4 instance to create a Cartesian3 instance from.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Cartesian3 instance if one was not provided.
     */
    static fromCartesian4(cartesian: Cartesian4, result?: Cartesian3): Cartesian3;
    /**
     * The number of elements used to pack the object into an array.
     */
    static packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: Cartesian3, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new Cartesian3 instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: Cartesian3): Cartesian3;
    /**
     * Flattens an array of Cartesian3s into an array of components.
     * @param array - The array of cartesians to pack.
     * @param [result] - The array onto which to store the result. If this is a typed array, it must have array.length * 3 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 3) elements.
     * @returns The packed array.
     */
    static packArray(array: Cartesian3[], result?: number[]): number[];
    /**
     * Unpacks an array of cartesian components into an array of Cartesian3s.
     * @param array - The array of components to unpack.
     * @param [result] - The array onto which to store the result.
     * @returns The unpacked array.
     */
    static unpackArray(array: number[], result?: Cartesian3[]): Cartesian3[];
    /**
     * Creates a Cartesian3 from three consecutive elements in an array.
     * @example
     * // Create a Cartesian3 with (1.0, 2.0, 3.0)
     * const v = [1.0, 2.0, 3.0];
     * const p = Cesium.Cartesian3.fromArray(v);
     *
     * // Create a Cartesian3 with (1.0, 2.0, 3.0) using an offset into an array
     * const v2 = [0.0, 0.0, 1.0, 2.0, 3.0];
     * const p2 = Cesium.Cartesian3.fromArray(v2, 2);
     * @param array - The array whose three consecutive elements correspond to the x, y, and z components, respectively.
     * @param [startingIndex = 0] - The offset into the array of the first element, which corresponds to the x component.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Cartesian3 instance if one was not provided.
     */
    static fromArray(array: number[], startingIndex?: number, result?: Cartesian3): Cartesian3;
    /**
     * Computes the value of the maximum component for the supplied Cartesian.
     * @param cartesian - The cartesian to use.
     * @returns The value of the maximum component.
     */
    static maximumComponent(cartesian: Cartesian3): number;
    /**
     * Computes the value of the minimum component for the supplied Cartesian.
     * @param cartesian - The cartesian to use.
     * @returns The value of the minimum component.
     */
    static minimumComponent(cartesian: Cartesian3): number;
    /**
     * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.
     * @param first - A cartesian to compare.
     * @param second - A cartesian to compare.
     * @param result - The object into which to store the result.
     * @returns A cartesian with the minimum components.
     */
    static minimumByComponent(first: Cartesian3, second: Cartesian3, result: Cartesian3): Cartesian3;
    /**
     * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.
     * @param first - A cartesian to compare.
     * @param second - A cartesian to compare.
     * @param result - The object into which to store the result.
     * @returns A cartesian with the maximum components.
     */
    static maximumByComponent(first: Cartesian3, second: Cartesian3, result: Cartesian3): Cartesian3;
    /**
     * Constrain a value to lie between two values.
     * @param cartesian - The value to clamp.
     * @param min - The minimum bound.
     * @param max - The maximum bound.
     * @param result - The object into which to store the result.
     * @returns The clamped value such that min <= value <= max.
     */
    static clamp(cartesian: Cartesian3, min: Cartesian3, max: Cartesian3, result: Cartesian3): Cartesian3;
    /**
     * Computes the provided Cartesian's squared magnitude.
     * @param cartesian - The Cartesian instance whose squared magnitude is to be computed.
     * @returns The squared magnitude.
     */
    static magnitudeSquared(cartesian: Cartesian3): number;
    /**
     * Computes the Cartesian's magnitude (length).
     * @param cartesian - The Cartesian instance whose magnitude is to be computed.
     * @returns The magnitude.
     */
    static magnitude(cartesian: Cartesian3): number;
    /**
     * Computes the distance between two points.
     * @example
     * // Returns 1.0
     * const d = Cesium.Cartesian3.distance(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(2.0, 0.0, 0.0));
     * @param left - The first point to compute the distance from.
     * @param right - The second point to compute the distance to.
     * @returns The distance between two points.
     */
    static distance(left: Cartesian3, right: Cartesian3): number;
    /**
     * Computes the squared distance between two points.  Comparing squared distances
     * using this function is more efficient than comparing distances using {@link Cartesian3#distance}.
     * @example
     * // Returns 4.0, not 2.0
     * const d = Cesium.Cartesian3.distanceSquared(new Cesium.Cartesian3(1.0, 0.0, 0.0), new Cesium.Cartesian3(3.0, 0.0, 0.0));
     * @param left - The first point to compute the distance from.
     * @param right - The second point to compute the distance to.
     * @returns The distance between two points.
     */
    static distanceSquared(left: Cartesian3, right: Cartesian3): number;
    /**
     * Computes the normalized form of the supplied Cartesian.
     * @param cartesian - The Cartesian to be normalized.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static normalize(cartesian: Cartesian3, result: Cartesian3): Cartesian3;
    /**
     * Computes the dot (scalar) product of two Cartesians.
     * @param left - The first Cartesian.
     * @param right - The second Cartesian.
     * @returns The dot product.
     */
    static dot(left: Cartesian3, right: Cartesian3): number;
    /**
     * Computes the componentwise product of two Cartesians.
     * @param left - The first Cartesian.
     * @param right - The second Cartesian.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static multiplyComponents(left: Cartesian3, right: Cartesian3, result: Cartesian3): Cartesian3;
    /**
     * Computes the componentwise quotient of two Cartesians.
     * @param left - The first Cartesian.
     * @param right - The second Cartesian.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static divideComponents(left: Cartesian3, right: Cartesian3, result: Cartesian3): Cartesian3;
    /**
     * Computes the componentwise sum of two Cartesians.
     * @param left - The first Cartesian.
     * @param right - The second Cartesian.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static add(left: Cartesian3, right: Cartesian3, result: Cartesian3): Cartesian3;
    /**
     * Computes the componentwise difference of two Cartesians.
     * @param left - The first Cartesian.
     * @param right - The second Cartesian.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static subtract(left: Cartesian3, right: Cartesian3, result: Cartesian3): Cartesian3;
    /**
     * Multiplies the provided Cartesian componentwise by the provided scalar.
     * @param cartesian - The Cartesian to be scaled.
     * @param scalar - The scalar to multiply with.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static multiplyByScalar(cartesian: Cartesian3, scalar: number, result: Cartesian3): Cartesian3;
    /**
     * Divides the provided Cartesian componentwise by the provided scalar.
     * @param cartesian - The Cartesian to be divided.
     * @param scalar - The scalar to divide by.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static divideByScalar(cartesian: Cartesian3, scalar: number, result: Cartesian3): Cartesian3;
    /**
     * Negates the provided Cartesian.
     * @param cartesian - The Cartesian to be negated.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static negate(cartesian: Cartesian3, result: Cartesian3): Cartesian3;
    /**
     * Computes the absolute value of the provided Cartesian.
     * @param cartesian - The Cartesian whose absolute value is to be computed.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static abs(cartesian: Cartesian3, result: Cartesian3): Cartesian3;
    /**
     * Computes the linear interpolation or extrapolation at t using the provided cartesians.
     * @param start - The value corresponding to t at 0.0.
     * @param end - The value corresponding to t at 1.0.
     * @param t - The point along t at which to interpolate.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static lerp(start: Cartesian3, end: Cartesian3, t: number, result: Cartesian3): Cartesian3;
    /**
     * Returns the angle, in radians, between the provided Cartesians.
     * @param left - The first Cartesian.
     * @param right - The second Cartesian.
     * @returns The angle between the Cartesians.
     */
    static angleBetween(left: Cartesian3, right: Cartesian3): number;
    /**
     * Returns the axis that is most orthogonal to the provided Cartesian.
     * @param cartesian - The Cartesian on which to find the most orthogonal axis.
     * @param result - The object onto which to store the result.
     * @returns The most orthogonal axis.
     */
    static mostOrthogonalAxis(cartesian: Cartesian3, result: Cartesian3): Cartesian3;
    /**
     * Projects vector a onto vector b
     * @param a - The vector that needs projecting
     * @param b - The vector to project onto
     * @param result - The result cartesian
     * @returns The modified result parameter
     */
    static projectVector(a: Cartesian3, b: Cartesian3, result: Cartesian3): Cartesian3;
    /**
     * Compares the provided Cartesians componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [left] - The first Cartesian.
     * @param [right] - The second Cartesian.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    static equals(left?: Cartesian3, right?: Cartesian3): boolean;
    /**
     * Compares the provided Cartesians componentwise and returns
     * <code>true</code> if they pass an absolute or relative tolerance test,
     * <code>false</code> otherwise.
     * @param [left] - The first Cartesian.
     * @param [right] - The second Cartesian.
     * @param [relativeEpsilon = 0] - The relative epsilon tolerance to use for equality testing.
     * @param [absoluteEpsilon = relativeEpsilon] - The absolute epsilon tolerance to use for equality testing.
     * @returns <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
     */
    static equalsEpsilon(left?: Cartesian3, right?: Cartesian3, relativeEpsilon?: number, absoluteEpsilon?: number): boolean;
    /**
     * Computes the cross (outer) product of two Cartesians.
     * @param left - The first Cartesian.
     * @param right - The second Cartesian.
     * @param result - The object onto which to store the result.
     * @returns The cross product.
     */
    static cross(left: Cartesian3, right: Cartesian3, result: Cartesian3): Cartesian3;
    /**
     * Computes the midpoint between the right and left Cartesian.
     * @param left - The first Cartesian.
     * @param right - The second Cartesian.
     * @param result - The object onto which to store the result.
     * @returns The midpoint.
     */
    static midpoint(left: Cartesian3, right: Cartesian3, result: Cartesian3): Cartesian3;
    /**
     * Returns a Cartesian3 position from longitude and latitude values given in degrees.
     * @example
     * const position = Cesium.Cartesian3.fromDegrees(-115.0, 37.0);
     * @param longitude - The longitude, in degrees
     * @param latitude - The latitude, in degrees
     * @param [height = 0.0] - The height, in meters, above the ellipsoid.
     * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid on which the position lies.
     * @param [result] - The object onto which to store the result.
     * @returns The position
     */
    static fromDegrees(longitude: number, latitude: number, height?: number, ellipsoid?: Ellipsoid, result?: Cartesian3): Cartesian3;
    /**
     * Returns a Cartesian3 position from longitude and latitude values given in radians.
     * @example
     * const position = Cesium.Cartesian3.fromRadians(-2.007, 0.645);
     * @param longitude - The longitude, in radians
     * @param latitude - The latitude, in radians
     * @param [height = 0.0] - The height, in meters, above the ellipsoid.
     * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid on which the position lies.
     * @param [result] - The object onto which to store the result.
     * @returns The position
     */
    static fromRadians(longitude: number, latitude: number, height?: number, ellipsoid?: Ellipsoid, result?: Cartesian3): Cartesian3;
    /**
     * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in degrees.
     * @example
     * const positions = Cesium.Cartesian3.fromDegreesArray([-115.0, 37.0, -107.0, 33.0]);
     * @param coordinates - A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].
     * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid on which the coordinates lie.
     * @param [result] - An array of Cartesian3 objects to store the result.
     * @returns The array of positions.
     */
    static fromDegreesArray(coordinates: number[], ellipsoid?: Ellipsoid, result?: Cartesian3[]): Cartesian3[];
    /**
     * Returns an array of Cartesian3 positions given an array of longitude and latitude values given in radians.
     * @example
     * const positions = Cesium.Cartesian3.fromRadiansArray([-2.007, 0.645, -1.867, .575]);
     * @param coordinates - A list of longitude and latitude values. Values alternate [longitude, latitude, longitude, latitude...].
     * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid on which the coordinates lie.
     * @param [result] - An array of Cartesian3 objects to store the result.
     * @returns The array of positions.
     */
    static fromRadiansArray(coordinates: number[], ellipsoid?: Ellipsoid, result?: Cartesian3[]): Cartesian3[];
    /**
     * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in degrees.
     * @example
     * const positions = Cesium.Cartesian3.fromDegreesArrayHeights([-115.0, 37.0, 100000.0, -107.0, 33.0, 150000.0]);
     * @param coordinates - A list of longitude, latitude and height values. Values alternate [longitude, latitude, height, longitude, latitude, height...].
     * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid on which the position lies.
     * @param [result] - An array of Cartesian3 objects to store the result.
     * @returns The array of positions.
     */
    static fromDegreesArrayHeights(coordinates: number[], ellipsoid?: Ellipsoid, result?: Cartesian3[]): Cartesian3[];
    /**
     * Returns an array of Cartesian3 positions given an array of longitude, latitude and height values where longitude and latitude are given in radians.
     * @example
     * const positions = Cesium.Cartesian3.fromRadiansArrayHeights([-2.007, 0.645, 100000.0, -1.867, .575, 150000.0]);
     * @param coordinates - A list of longitude, latitude and height values. Values alternate [longitude, latitude, height, longitude, latitude, height...].
     * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid on which the position lies.
     * @param [result] - An array of Cartesian3 objects to store the result.
     * @returns The array of positions.
     */
    static fromRadiansArrayHeights(coordinates: number[], ellipsoid?: Ellipsoid, result?: Cartesian3[]): Cartesian3[];
    /**
     * An immutable Cartesian3 instance initialized to (0.0, 0.0, 0.0).
     */
    static readonly ZERO: Cartesian3;
    /**
     * An immutable Cartesian3 instance initialized to (1.0, 1.0, 1.0).
     */
    static readonly ONE: Cartesian3;
    /**
     * An immutable Cartesian3 instance initialized to (1.0, 0.0, 0.0).
     */
    static readonly UNIT_X: Cartesian3;
    /**
     * An immutable Cartesian3 instance initialized to (0.0, 1.0, 0.0).
     */
    static readonly UNIT_Y: Cartesian3;
    /**
     * An immutable Cartesian3 instance initialized to (0.0, 0.0, 1.0).
     */
    static readonly UNIT_Z: Cartesian3;
    /**
     * Duplicates this Cartesian3 instance.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Cartesian3 instance if one was not provided.
     */
    clone(result?: Cartesian3): Cartesian3;
    /**
     * Compares this Cartesian against the provided Cartesian componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [right] - The right hand side Cartesian.
     * @returns <code>true</code> if they are equal, <code>false</code> otherwise.
     */
    equals(right?: Cartesian3): boolean;
    /**
     * Compares this Cartesian against the provided Cartesian componentwise and returns
     * <code>true</code> if they pass an absolute or relative tolerance test,
     * <code>false</code> otherwise.
     * @param [right] - The right hand side Cartesian.
     * @param [relativeEpsilon = 0] - The relative epsilon tolerance to use for equality testing.
     * @param [absoluteEpsilon = relativeEpsilon] - The absolute epsilon tolerance to use for equality testing.
     * @returns <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
     */
    equalsEpsilon(right?: Cartesian3, relativeEpsilon?: number, absoluteEpsilon?: number): boolean;
    /**
     * Creates a string representing this Cartesian in the format '(x, y, z)'.
     * @returns A string representing this Cartesian in the format '(x, y, z)'.
     */
    toString(): string;
}

/**
 * A 4D Cartesian point.
 * @param [x = 0.0] - The X component.
 * @param [y = 0.0] - The Y component.
 * @param [z = 0.0] - The Z component.
 * @param [w = 0.0] - The W component.
 */
export class Cartesian4 {
    constructor(x?: number, y?: number, z?: number, w?: number);
    /**
     * The X component.
     */
    x: number;
    /**
     * The Y component.
     */
    y: number;
    /**
     * The Z component.
     */
    z: number;
    /**
     * The W component.
     */
    w: number;
    /**
     * Creates a Cartesian4 instance from x, y, z and w coordinates.
     * @param x - The x coordinate.
     * @param y - The y coordinate.
     * @param z - The z coordinate.
     * @param w - The w coordinate.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Cartesian4 instance if one was not provided.
     */
    static fromElements(x: number, y: number, z: number, w: number, result?: Cartesian4): Cartesian4;
    /**
     * Creates a Cartesian4 instance from a {@link Color}. <code>red</code>, <code>green</code>, <code>blue</code>,
     * and <code>alpha</code> map to <code>x</code>, <code>y</code>, <code>z</code>, and <code>w</code>, respectively.
     * @param color - The source color.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Cartesian4 instance if one was not provided.
     */
    static fromColor(color: Color, result?: Cartesian4): Cartesian4;
    /**
     * Duplicates a Cartesian4 instance.
     * @param cartesian - The Cartesian to duplicate.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Cartesian4 instance if one was not provided. (Returns undefined if cartesian is undefined)
     */
    static clone(cartesian: Cartesian4, result?: Cartesian4): Cartesian4;
    /**
     * The number of elements used to pack the object into an array.
     */
    static packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: Cartesian4, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new Cartesian4 instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: Cartesian4): Cartesian4;
    /**
     * Flattens an array of Cartesian4s into an array of components.
     * @param array - The array of cartesians to pack.
     * @param [result] - The array onto which to store the result. If this is a typed array, it must have array.length * 4 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 4) elements.
     * @returns The packed array.
     */
    static packArray(array: Cartesian4[], result?: number[]): number[];
    /**
     * Unpacks an array of cartesian components into an array of Cartesian4s.
     * @param array - The array of components to unpack.
     * @param [result] - The array onto which to store the result.
     * @returns The unpacked array.
     */
    static unpackArray(array: number[], result?: Cartesian4[]): Cartesian4[];
    /**
     * Creates a Cartesian4 from four consecutive elements in an array.
     * @example
     * // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0)
     * const v = [1.0, 2.0, 3.0, 4.0];
     * const p = Cesium.Cartesian4.fromArray(v);
     *
     * // Create a Cartesian4 with (1.0, 2.0, 3.0, 4.0) using an offset into an array
     * const v2 = [0.0, 0.0, 1.0, 2.0, 3.0, 4.0];
     * const p2 = Cesium.Cartesian4.fromArray(v2, 2);
     * @param array - The array whose four consecutive elements correspond to the x, y, z, and w components, respectively.
     * @param [startingIndex = 0] - The offset into the array of the first element, which corresponds to the x component.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Cartesian4 instance if one was not provided.
     */
    static fromArray(array: number[], startingIndex?: number, result?: Cartesian4): Cartesian4;
    /**
     * Computes the value of the maximum component for the supplied Cartesian.
     * @param cartesian - The cartesian to use.
     * @returns The value of the maximum component.
     */
    static maximumComponent(cartesian: Cartesian4): number;
    /**
     * Computes the value of the minimum component for the supplied Cartesian.
     * @param cartesian - The cartesian to use.
     * @returns The value of the minimum component.
     */
    static minimumComponent(cartesian: Cartesian4): number;
    /**
     * Compares two Cartesians and computes a Cartesian which contains the minimum components of the supplied Cartesians.
     * @param first - A cartesian to compare.
     * @param second - A cartesian to compare.
     * @param result - The object into which to store the result.
     * @returns A cartesian with the minimum components.
     */
    static minimumByComponent(first: Cartesian4, second: Cartesian4, result: Cartesian4): Cartesian4;
    /**
     * Compares two Cartesians and computes a Cartesian which contains the maximum components of the supplied Cartesians.
     * @param first - A cartesian to compare.
     * @param second - A cartesian to compare.
     * @param result - The object into which to store the result.
     * @returns A cartesian with the maximum components.
     */
    static maximumByComponent(first: Cartesian4, second: Cartesian4, result: Cartesian4): Cartesian4;
    /**
     * Constrain a value to lie between two values.
     * @param value - The value to clamp.
     * @param min - The minimum bound.
     * @param max - The maximum bound.
     * @param result - The object into which to store the result.
     * @returns The clamped value such that min <= result <= max.
     */
    static clamp(value: Cartesian4, min: Cartesian4, max: Cartesian4, result: Cartesian4): Cartesian4;
    /**
     * Computes the provided Cartesian's squared magnitude.
     * @param cartesian - The Cartesian instance whose squared magnitude is to be computed.
     * @returns The squared magnitude.
     */
    static magnitudeSquared(cartesian: Cartesian4): number;
    /**
     * Computes the Cartesian's magnitude (length).
     * @param cartesian - The Cartesian instance whose magnitude is to be computed.
     * @returns The magnitude.
     */
    static magnitude(cartesian: Cartesian4): number;
    /**
     * Computes the 4-space distance between two points.
     * @example
     * // Returns 1.0
     * const d = Cesium.Cartesian4.distance(
     *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),
     *   new Cesium.Cartesian4(2.0, 0.0, 0.0, 0.0));
     * @param left - The first point to compute the distance from.
     * @param right - The second point to compute the distance to.
     * @returns The distance between two points.
     */
    static distance(left: Cartesian4, right: Cartesian4): number;
    /**
     * Computes the squared distance between two points.  Comparing squared distances
     * using this function is more efficient than comparing distances using {@link Cartesian4#distance}.
     * @example
     * // Returns 4.0, not 2.0
     * const d = Cesium.Cartesian4.distance(
     *   new Cesium.Cartesian4(1.0, 0.0, 0.0, 0.0),
     *   new Cesium.Cartesian4(3.0, 0.0, 0.0, 0.0));
     * @param left - The first point to compute the distance from.
     * @param right - The second point to compute the distance to.
     * @returns The distance between two points.
     */
    static distanceSquared(left: Cartesian4, right: Cartesian4): number;
    /**
     * Computes the normalized form of the supplied Cartesian.
     * @param cartesian - The Cartesian to be normalized.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static normalize(cartesian: Cartesian4, result: Cartesian4): Cartesian4;
    /**
     * Computes the dot (scalar) product of two Cartesians.
     * @param left - The first Cartesian.
     * @param right - The second Cartesian.
     * @returns The dot product.
     */
    static dot(left: Cartesian4, right: Cartesian4): number;
    /**
     * Computes the componentwise product of two Cartesians.
     * @param left - The first Cartesian.
     * @param right - The second Cartesian.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static multiplyComponents(left: Cartesian4, right: Cartesian4, result: Cartesian4): Cartesian4;
    /**
     * Computes the componentwise quotient of two Cartesians.
     * @param left - The first Cartesian.
     * @param right - The second Cartesian.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static divideComponents(left: Cartesian4, right: Cartesian4, result: Cartesian4): Cartesian4;
    /**
     * Computes the componentwise sum of two Cartesians.
     * @param left - The first Cartesian.
     * @param right - The second Cartesian.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static add(left: Cartesian4, right: Cartesian4, result: Cartesian4): Cartesian4;
    /**
     * Computes the componentwise difference of two Cartesians.
     * @param left - The first Cartesian.
     * @param right - The second Cartesian.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static subtract(left: Cartesian4, right: Cartesian4, result: Cartesian4): Cartesian4;
    /**
     * Multiplies the provided Cartesian componentwise by the provided scalar.
     * @param cartesian - The Cartesian to be scaled.
     * @param scalar - The scalar to multiply with.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static multiplyByScalar(cartesian: Cartesian4, scalar: number, result: Cartesian4): Cartesian4;
    /**
     * Divides the provided Cartesian componentwise by the provided scalar.
     * @param cartesian - The Cartesian to be divided.
     * @param scalar - The scalar to divide by.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static divideByScalar(cartesian: Cartesian4, scalar: number, result: Cartesian4): Cartesian4;
    /**
     * Negates the provided Cartesian.
     * @param cartesian - The Cartesian to be negated.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static negate(cartesian: Cartesian4, result: Cartesian4): Cartesian4;
    /**
     * Computes the absolute value of the provided Cartesian.
     * @param cartesian - The Cartesian whose absolute value is to be computed.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static abs(cartesian: Cartesian4, result: Cartesian4): Cartesian4;
    /**
     * Computes the linear interpolation or extrapolation at t using the provided cartesians.
     * @param start - The value corresponding to t at 0.0.
     * @param end - The value corresponding to t at 1.0.
     * @param t - The point along t at which to interpolate.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static lerp(start: Cartesian4, end: Cartesian4, t: number, result: Cartesian4): Cartesian4;
    /**
     * Returns the axis that is most orthogonal to the provided Cartesian.
     * @param cartesian - The Cartesian on which to find the most orthogonal axis.
     * @param result - The object onto which to store the result.
     * @returns The most orthogonal axis.
     */
    static mostOrthogonalAxis(cartesian: Cartesian4, result: Cartesian4): Cartesian4;
    /**
     * Compares the provided Cartesians componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [left] - The first Cartesian.
     * @param [right] - The second Cartesian.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    static equals(left?: Cartesian4, right?: Cartesian4): boolean;
    /**
     * Compares the provided Cartesians componentwise and returns
     * <code>true</code> if they pass an absolute or relative tolerance test,
     * <code>false</code> otherwise.
     * @param [left] - The first Cartesian.
     * @param [right] - The second Cartesian.
     * @param [relativeEpsilon = 0] - The relative epsilon tolerance to use for equality testing.
     * @param [absoluteEpsilon = relativeEpsilon] - The absolute epsilon tolerance to use for equality testing.
     * @returns <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
     */
    static equalsEpsilon(left?: Cartesian4, right?: Cartesian4, relativeEpsilon?: number, absoluteEpsilon?: number): boolean;
    /**
     * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 0.0).
     */
    static readonly ZERO: Cartesian4;
    /**
     * An immutable Cartesian4 instance initialized to (1.0, 1.0, 1.0, 1.0).
     */
    static readonly ONE: Cartesian4;
    /**
     * An immutable Cartesian4 instance initialized to (1.0, 0.0, 0.0, 0.0).
     */
    static readonly UNIT_X: Cartesian4;
    /**
     * An immutable Cartesian4 instance initialized to (0.0, 1.0, 0.0, 0.0).
     */
    static readonly UNIT_Y: Cartesian4;
    /**
     * An immutable Cartesian4 instance initialized to (0.0, 0.0, 1.0, 0.0).
     */
    static readonly UNIT_Z: Cartesian4;
    /**
     * An immutable Cartesian4 instance initialized to (0.0, 0.0, 0.0, 1.0).
     */
    static readonly UNIT_W: Cartesian4;
    /**
     * Duplicates this Cartesian4 instance.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Cartesian4 instance if one was not provided.
     */
    clone(result?: Cartesian4): Cartesian4;
    /**
     * Compares this Cartesian against the provided Cartesian componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [right] - The right hand side Cartesian.
     * @returns <code>true</code> if they are equal, <code>false</code> otherwise.
     */
    equals(right?: Cartesian4): boolean;
    /**
     * Compares this Cartesian against the provided Cartesian componentwise and returns
     * <code>true</code> if they pass an absolute or relative tolerance test,
     * <code>false</code> otherwise.
     * @param [right] - The right hand side Cartesian.
     * @param [relativeEpsilon = 0] - The relative epsilon tolerance to use for equality testing.
     * @param [absoluteEpsilon = relativeEpsilon] - The absolute epsilon tolerance to use for equality testing.
     * @returns <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
     */
    equalsEpsilon(right?: Cartesian4, relativeEpsilon?: number, absoluteEpsilon?: number): boolean;
    /**
     * Creates a string representing this Cartesian in the format '(x, y, z, w)'.
     * @returns A string representing the provided Cartesian in the format '(x, y, z, w)'.
     */
    toString(): string;
    /**
     * Packs an arbitrary floating point value to 4 values representable using uint8.
     * @param value - A floating point number.
     * @param [result] - The Cartesian4 that will contain the packed float.
     * @returns A Cartesian4 representing the float packed to values in x, y, z, and w.
     */
    static packFloat(value: number, result?: Cartesian4): Cartesian4;
}

/**
 * A position defined by longitude, latitude, and height.
 * @param [longitude = 0.0] - The longitude, in radians.
 * @param [latitude = 0.0] - The latitude, in radians.
 * @param [height = 0.0] - The height, in meters, above the ellipsoid.
 */
export class Cartographic {
    constructor(longitude?: number, latitude?: number, height?: number);
    /**
     * The longitude, in radians.
     */
    longitude: number;
    /**
     * The latitude, in radians.
     */
    latitude: number;
    /**
     * The height, in meters, above the ellipsoid.
     */
    height: number;
    /**
     * Creates a new Cartographic instance from longitude and latitude
     * specified in radians.
     * @param longitude - The longitude, in radians.
     * @param latitude - The latitude, in radians.
     * @param [height = 0.0] - The height, in meters, above the ellipsoid.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Cartographic instance if one was not provided.
     */
    static fromRadians(longitude: number, latitude: number, height?: number, result?: Cartographic): Cartographic;
    /**
     * Creates a new Cartographic instance from longitude and latitude
     * specified in degrees.  The values in the resulting object will
     * be in radians.
     * @param longitude - The longitude, in degrees.
     * @param latitude - The latitude, in degrees.
     * @param [height = 0.0] - The height, in meters, above the ellipsoid.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Cartographic instance if one was not provided.
     */
    static fromDegrees(longitude: number, latitude: number, height?: number, result?: Cartographic): Cartographic;
    /**
     * Creates a new Cartographic instance from a Cartesian position. The values in the
     * resulting object will be in radians.
     * @param cartesian - The Cartesian position to convert to cartographic representation.
     * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid on which the position lies.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.
     */
    static fromCartesian(cartesian: Cartesian3, ellipsoid?: Ellipsoid, result?: Cartographic): Cartographic;
    /**
     * Creates a new Cartesian3 instance from a Cartographic input. The values in the inputted
     * object should be in radians.
     * @param cartographic - Input to be converted into a Cartesian3 output.
     * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid on which the position lies.
     * @param [result] - The object onto which to store the result.
     * @returns The position
     */
    static toCartesian(cartographic: Cartographic, ellipsoid?: Ellipsoid, result?: Cartesian3): Cartesian3;
    /**
     * Duplicates a Cartographic instance.
     * @param cartographic - The cartographic to duplicate.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Cartographic instance if one was not provided. (Returns undefined if cartographic is undefined)
     */
    static clone(cartographic: Cartographic, result?: Cartographic): Cartographic;
    /**
     * Compares the provided cartographics componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [left] - The first cartographic.
     * @param [right] - The second cartographic.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    static equals(left?: Cartographic, right?: Cartographic): boolean;
    /**
     * Compares the provided cartographics componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @param [left] - The first cartographic.
     * @param [right] - The second cartographic.
     * @param [epsilon = 0] - The epsilon to use for equality testing.
     * @returns <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
     */
    static equalsEpsilon(left?: Cartographic, right?: Cartographic, epsilon?: number): boolean;
    /**
     * An immutable Cartographic instance initialized to (0.0, 0.0, 0.0).
     */
    static readonly ZERO: Cartographic;
    /**
     * Duplicates this instance.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Cartographic instance if one was not provided.
     */
    clone(result?: Cartographic): Cartographic;
    /**
     * Compares the provided against this cartographic componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [right] - The second cartographic.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    equals(right?: Cartographic): boolean;
    /**
     * Compares the provided against this cartographic componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @param [right] - The second cartographic.
     * @param [epsilon = 0] - The epsilon to use for equality testing.
     * @returns <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
     */
    equalsEpsilon(right?: Cartographic, epsilon?: number): boolean;
    /**
     * Creates a string representing this cartographic in the format '(longitude, latitude, height)'.
     * @returns A string representing the provided cartographic in the format '(longitude, latitude, height)'.
     */
    toString(): string;
}

/**
 * Geocodes queries containing longitude and latitude coordinates and an optional height.
 * Query format: `longitude latitude (height)` with longitude/latitude in degrees and height in meters.
 */
export class CartographicGeocoderService {
    constructor();
    /**
     * Gets the credit to display after a geocode is performed. Typically this is used to credit
     * the geocoder service.
     */
    readonly credit: Credit | undefined;
    /**
     * @param query - The query to be sent to the geocoder service
     */
    geocode(query: string): Promise<GeocoderService.Result[]>;
}

/**
 * A Catmull-Rom spline is a cubic spline where the tangent at control points,
 * except the first and last, are computed using the previous and next control points.
 * Catmull-Rom splines are in the class C<sup>1</sup>.
 * @example
 * // spline above the earth from Philadelphia to Los Angeles
 * const spline = new Cesium.CatmullRomSpline({
 *     times : [ 0.0, 1.5, 3.0, 4.5, 6.0 ],
 *     points : [
 *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),
 *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),
 *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),
 *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),
 *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)
 *     ]
 * });
 *
 * const p0 = spline.evaluate(times[i]);         // equal to positions[i]
 * const p1 = spline.evaluate(times[i] + delta); // interpolated value when delta < times[i + 1] - times[i]
 * @param options - Object with the following properties:
 * @param options.times - An array of strictly increasing, unit-less, floating-point times at each point.
 *                The values are in no way connected to the clock time. They are the parameterization for the curve.
 * @param options.points - The array of {@link Cartesian3} control points.
 * @param [options.firstTangent] - The tangent of the curve at the first control point.
 *                     If the tangent is not given, it will be estimated.
 * @param [options.lastTangent] - The tangent of the curve at the last control point.
 *                     If the tangent is not given, it will be estimated.
 */
export class CatmullRomSpline {
    constructor(options: {
        times: number[];
        points: Cartesian3[];
        firstTangent?: Cartesian3;
        lastTangent?: Cartesian3;
    });
    /**
     * An array of times for the control points.
     */
    readonly times: number[];
    /**
     * An array of {@link Cartesian3} control points.
     */
    readonly points: Cartesian3[];
    /**
     * The tangent at the first control point.
     */
    readonly firstTangent: Cartesian3;
    /**
     * The tangent at the last control point.
     */
    readonly lastTangent: Cartesian3;
    /**
     * Finds an index <code>i</code> in <code>times</code> such that the parameter
     * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.
     * @param time - The time.
     * @returns The index for the element at the start of the interval.
     */
    findTimeInterval(time: number): number;
    /**
     * Wraps the given time to the period covered by the spline.
     * @param time - The time.
     * @returns The time, wrapped around to the updated animation.
     */
    wrapTime(time: number): number;
    /**
     * Clamps the given time to the period covered by the spline.
     * @param time - The time.
     * @returns The time, clamped to the animation period.
     */
    clampTime(time: number): number;
    /**
     * Evaluates the curve at a given time.
     * @param time - The time at which to evaluate the curve.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new instance of the point on the curve at the given time.
     */
    evaluate(time: number, result?: Cartesian3): Cartesian3;
}

export namespace CesiumTerrainProvider {
    /**
     * Initialization options for the CesiumTerrainProvider constructor
     * [requestVertexNormals = false] - Flag that indicates if the client should request additional lighting information from the server, in the form of per vertex normals if available.
     * [requestWaterMask = false] - Flag that indicates if the client should request per tile water masks from the server, if available.
     * [requestMetadata = true] - Flag that indicates if the client should request per tile metadata from the server, if available.
     * [ellipsoid] - The ellipsoid.  If not specified, the WGS84 ellipsoid is used.
     * [credit] - A credit for the data source, which is displayed on the canvas.
     */
    type ConstructorOptions = {
        requestVertexNormals?: boolean;
        requestWaterMask?: boolean;
        requestMetadata?: boolean;
        ellipsoid?: Ellipsoid;
        credit?: Credit | string;
    };
}

/**
 * <div class="notice">
 * To construct a CesiumTerrainProvider, call {@link CesiumTerrainProvider.fromIonAssetId} or {@link CesiumTerrainProvider.fromUrl}. Do not call the constructor directly.
 * </div>
 *
 * A {@link TerrainProvider} that accesses terrain data in a Cesium terrain format.
 * Terrain formats can be one of the following:
 * <ul>
 * <li> {@link https://github.com/AnalyticalGraphicsInc/quantized-mesh Quantized Mesh} </li>
 * <li> {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/heightmap-1.0 Height Map} </li>
 * </ul>
 * @example
 * // Create Arctic DEM terrain with normals.
 * try {
 *   const viewer = new Cesium.Viewer("cesiumContainer", {
 *     terrainProvider: await Cesium.CesiumTerrainProvider.fromIonAssetId(3956, {
 *       requestVertexNormals: true
 *     })
 *   });
 * } catch (error) {
 *   console.log(error);
 * }
 * @param [options] - An object describing initialization options
 */
export class CesiumTerrainProvider {
    constructor(options?: CesiumTerrainProvider.ConstructorOptions);
    /**
     * Requests the geometry for a given tile. The result must include terrain data and
     * may optionally include a water mask and an indication of which child tiles are available.
     * @param x - The X coordinate of the tile for which to request geometry.
     * @param y - The Y coordinate of the tile for which to request geometry.
     * @param level - The level of the tile for which to request geometry.
     * @param [request] - The request object. Intended for internal use only.
     * @returns A promise for the requested geometry.  If this method
     *          returns undefined instead of a promise, it is an indication that too many requests are already
     *          pending and the request will be retried later.
     */
    requestTileGeometry(x: number, y: number, level: number, request?: Request): Promise<TerrainData> | undefined;
    /**
     * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing
     * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
     * are passed an instance of {@link TileProviderError}.
     */
    readonly errorEvent: Event;
    /**
     * Gets the credit to display when this terrain provider is active.  Typically this is used to credit
     * the source of the terrain.
     */
    readonly credit: Credit;
    /**
     * Gets the tiling scheme used by this provider.
     */
    readonly tilingScheme: GeographicTilingScheme;
    /**
     * Gets a value indicating whether or not the provider includes a water mask.  The water mask
     * indicates which areas of the globe are water rather than land, so they can be rendered
     * as a reflective surface with animated waves.
     */
    readonly hasWaterMask: boolean;
    /**
     * Gets a value indicating whether or not the requested tiles include vertex normals.
     */
    readonly hasVertexNormals: boolean;
    /**
     * Gets a value indicating whether or not the requested tiles include metadata.
     */
    readonly hasMetadata: boolean;
    /**
     * Boolean flag that indicates if the client should request vertex normals from the server.
     * Vertex normals data is appended to the standard tile mesh data only if the client requests the vertex normals and
     * if the server provides vertex normals.
     */
    readonly requestVertexNormals: boolean;
    /**
     * Boolean flag that indicates if the client should request a watermask from the server.
     * Watermask data is appended to the standard tile mesh data only if the client requests the watermask and
     * if the server provides a watermask.
     */
    readonly requestWaterMask: boolean;
    /**
     * Boolean flag that indicates if the client should request metadata from the server.
     * Metadata is appended to the standard tile mesh data only if the client requests the metadata and
     * if the server provides a metadata.
     */
    readonly requestMetadata: boolean;
    /**
     * Gets an object that can be used to determine availability of terrain from this provider, such as
     * at points and in rectangles. This property may be undefined if availability
     * information is not available. Note that this reflects tiles that are known to be available currently.
     * Additional tiles may be discovered to be available in the future, e.g. if availability information
     * exists deeper in the tree rather than it all being discoverable at the root. However, a tile that
     * is available now will not become unavailable in the future.
     */
    readonly availability: TileAvailability;
    /**
     * Gets the maximum geometric error allowed in a tile at a given level.
     * @param level - The tile level for which to get the maximum geometric error.
     * @returns The maximum geometric error.
     */
    getLevelMaximumGeometricError(level: number): number;
    /**
     * Creates a {@link TerrainProvider} from a Cesium ion asset ID that accesses terrain data in a Cesium terrain format
     * Terrain formats can be one of the following:
     * <ul>
     * <li> {@link https://github.com/AnalyticalGraphicsInc/quantized-mesh Quantized Mesh} </li>
     * <li> {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/heightmap-1.0 Height Map} </li>
     * </ul>
     * @example
     * // Create Arctic DEM terrain with normals.
     * try {
     *   const viewer = new Cesium.Viewer("cesiumContainer", {
     *     terrainProvider: await Cesium.CesiumTerrainProvider.fromIonAssetId(3956, {
     *         requestVertexNormals: true
     *     })
     *   });
     * } catch (error) {
     *   console.log(error);
     * }
     * @param assetId - The Cesium ion asset id.
     * @param [options] - An object describing initialization options.
     */
    static fromIonAssetId(assetId: number, options?: CesiumTerrainProvider.ConstructorOptions): Promise<CesiumTerrainProvider>;
    /**
     * Creates a {@link TerrainProvider} that accesses terrain data in a Cesium terrain format.
     * Terrain formats can be one of the following:
     * <ul>
     * <li> {@link https://github.com/AnalyticalGraphicsInc/quantized-mesh Quantized Mesh} </li>
     * <li> {@link https://github.com/AnalyticalGraphicsInc/cesium/wiki/heightmap-1.0 Height Map} </li>
     * </ul>
     * @example
     * // Create Arctic DEM terrain with normals.
     * try {
     *   const viewer = new Cesium.Viewer("cesiumContainer", {
     *     terrainProvider: await Cesium.CesiumTerrainProvider.fromUrl(
     *       Cesium.IonResource.fromAssetId(3956), {
     *         requestVertexNormals: true
     *     })
     *   });
     * } catch (error) {
     *   console.log(error);
     * }
     * @param url - The URL of the Cesium terrain server.
     * @param [options] - An object describing initialization options.
     */
    static fromUrl(url: Resource | string | Promise<Resource> | Promise<string>, options?: CesiumTerrainProvider.ConstructorOptions): Promise<CesiumTerrainProvider>;
    /**
     * Determines whether data for a tile is available to be loaded.
     * @param x - The X coordinate of the tile for which to request geometry.
     * @param y - The Y coordinate of the tile for which to request geometry.
     * @param level - The level of the tile for which to request geometry.
     * @returns Undefined if not supported or availability is unknown, otherwise true or false.
     */
    getTileDataAvailable(x: number, y: number, level: number): boolean | undefined;
    /**
     * Makes sure we load availability data for a tile
     * @param x - The X coordinate of the tile for which to request geometry.
     * @param y - The Y coordinate of the tile for which to request geometry.
     * @param level - The level of the tile for which to request geometry.
     * @returns Undefined if nothing need to be loaded or a Promise that resolves when all required tiles are loaded
     */
    loadTileDataAvailability(x: number, y: number, level: number): undefined | Promise<void>;
}

/**
 * A description of a circle on the ellipsoid. Circle geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.
 * @example
 * // Create a circle.
 * const circle = new Cesium.CircleGeometry({
 *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),
 *   radius : 100000.0
 * });
 * const geometry = Cesium.CircleGeometry.createGeometry(circle);
 * @param options - Object with the following properties:
 * @param options.center - The circle's center point in the fixed frame.
 * @param options.radius - The radius in meters.
 * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid the circle will be on.
 * @param [options.height = 0.0] - The distance in meters between the circle and the ellipsoid surface.
 * @param [options.granularity = 0.02] - The angular distance between points on the circle in radians.
 * @param [options.vertexFormat = VertexFormat.DEFAULT] - The vertex attributes to be computed.
 * @param [options.extrudedHeight = 0.0] - The distance in meters between the circle's extruded face and the ellipsoid surface.
 * @param [options.stRotation = 0.0] - The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.
 */
export class CircleGeometry {
    constructor(options: {
        center: Cartesian3;
        radius: number;
        ellipsoid?: Ellipsoid;
        height?: number;
        granularity?: number;
        vertexFormat?: VertexFormat;
        extrudedHeight?: number;
        stRotation?: number;
    });
    /**
     * The number of elements used to pack the object into an array.
     */
    static packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: CircleGeometry, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new CircleGeometry instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: CircleGeometry): CircleGeometry;
    /**
     * Computes the geometric representation of a circle on an ellipsoid, including its vertices, indices, and a bounding sphere.
     * @param circleGeometry - A description of the circle.
     * @returns The computed vertices and indices.
     */
    static createGeometry(circleGeometry: CircleGeometry): Geometry | undefined;
}

/**
 * A description of the outline of a circle on the ellipsoid.
 * @example
 * // Create a circle.
 * const circle = new Cesium.CircleOutlineGeometry({
 *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),
 *   radius : 100000.0
 * });
 * const geometry = Cesium.CircleOutlineGeometry.createGeometry(circle);
 * @param options - Object with the following properties:
 * @param options.center - The circle's center point in the fixed frame.
 * @param options.radius - The radius in meters.
 * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid the circle will be on.
 * @param [options.height = 0.0] - The distance in meters between the circle and the ellipsoid surface.
 * @param [options.granularity = 0.02] - The angular distance between points on the circle in radians.
 * @param [options.extrudedHeight = 0.0] - The distance in meters between the circle's extruded face and the ellipsoid surface.
 * @param [options.numberOfVerticalLines = 16] - Number of lines to draw between the top and bottom of an extruded circle.
 */
export class CircleOutlineGeometry {
    constructor(options: {
        center: Cartesian3;
        radius: number;
        ellipsoid?: Ellipsoid;
        height?: number;
        granularity?: number;
        extrudedHeight?: number;
        numberOfVerticalLines?: number;
    });
    /**
     * The number of elements used to pack the object into an array.
     */
    static packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: CircleOutlineGeometry, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new CircleOutlineGeometry instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: CircleOutlineGeometry): CircleOutlineGeometry;
    /**
     * Computes the geometric representation of an outline of a circle on an ellipsoid, including its vertices, indices, and a bounding sphere.
     * @param circleGeometry - A description of the circle.
     * @returns The computed vertices and indices.
     */
    static createGeometry(circleGeometry: CircleOutlineGeometry): Geometry | undefined;
}

/**
 * A simple clock for keeping track of simulated time.
 * @example
 * // Create a clock that loops on Christmas day 2013 and runs in real-time.
 * const clock = new Cesium.Clock({
 *    startTime : Cesium.JulianDate.fromIso8601("2013-12-25"),
 *    currentTime : Cesium.JulianDate.fromIso8601("2013-12-25"),
 *    stopTime : Cesium.JulianDate.fromIso8601("2013-12-26"),
 *    clockRange : Cesium.ClockRange.LOOP_STOP,
 *    clockStep : Cesium.ClockStep.SYSTEM_CLOCK_MULTIPLIER
 * });
 * @param [options] - Object with the following properties:
 * @param [options.startTime] - The start time of the clock.
 * @param [options.stopTime] - The stop time of the clock.
 * @param [options.currentTime] - The current time.
 * @param [options.multiplier = 1.0] - Determines how much time advances when {@link Clock#tick} is called, negative values allow for advancing backwards.
 * @param [options.clockStep = ClockStep.SYSTEM_CLOCK_MULTIPLIER] - Determines if calls to {@link Clock#tick} are frame dependent or system clock dependent.
 * @param [options.clockRange = ClockRange.UNBOUNDED] - Determines how the clock should behave when {@link Clock#startTime} or {@link Clock#stopTime} is reached.
 * @param [options.canAnimate = true] - Indicates whether {@link Clock#tick} can advance time.  This could be false if data is being buffered, for example.  The clock will only tick when both {@link Clock#canAnimate} and {@link Clock#shouldAnimate} are true.
 * @param [options.shouldAnimate = false] - Indicates whether {@link Clock#tick} should attempt to advance time.  The clock will only tick when both {@link Clock#canAnimate} and {@link Clock#shouldAnimate} are true.
 */
export class Clock {
    constructor(options?: {
        startTime?: JulianDate;
        stopTime?: JulianDate;
        currentTime?: JulianDate;
        multiplier?: number;
        clockStep?: ClockStep;
        clockRange?: ClockRange;
        canAnimate?: boolean;
        shouldAnimate?: boolean;
    });
    /**
     * The start time of the clock.
     */
    startTime: JulianDate;
    /**
     * The stop time of the clock.
     */
    stopTime: JulianDate;
    /**
     * Determines how the clock should behave when
     * {@link Clock#startTime} or {@link Clock#stopTime}
     * is reached.
     */
    clockRange: ClockRange;
    /**
     * Indicates whether {@link Clock#tick} can advance time.  This could be false if data is being buffered,
     * for example.  The clock will only advance time when both
     * {@link Clock#canAnimate} and {@link Clock#shouldAnimate} are true.
     */
    canAnimate: boolean;
    /**
     * An {@link Event} that is fired whenever {@link Clock#tick} is called.
     */
    onTick: Event;
    /**
     * An {@link Event} that is fired whenever {@link Clock#stopTime} is reached.
     */
    onStop: Event;
    /**
     * The current time.
     * Changing this property will change
     * {@link Clock#clockStep} from {@link ClockStep.SYSTEM_CLOCK} to
     * {@link ClockStep.SYSTEM_CLOCK_MULTIPLIER}.
     */
    currentTime: JulianDate;
    /**
     * Gets or sets how much time advances when {@link Clock#tick} is called. Negative values allow for advancing backwards.
     * If {@link Clock#clockStep} is set to {@link ClockStep.TICK_DEPENDENT}, this is the number of seconds to advance.
     * If {@link Clock#clockStep} is set to {@link ClockStep.SYSTEM_CLOCK_MULTIPLIER}, this value is multiplied by the
     * elapsed system time since the last call to {@link Clock#tick}.
     * Changing this property will change
     * {@link Clock#clockStep} from {@link ClockStep.SYSTEM_CLOCK} to
     * {@link ClockStep.SYSTEM_CLOCK_MULTIPLIER}.
     */
    multiplier: number;
    /**
     * Determines if calls to {@link Clock#tick} are frame dependent or system clock dependent.
     * Changing this property to {@link ClockStep.SYSTEM_CLOCK} will set
     * {@link Clock#multiplier} to 1.0, {@link Clock#shouldAnimate} to true, and
     * {@link Clock#currentTime} to the current system clock time.
     */
    clockStep: ClockStep;
    /**
     * Indicates whether {@link Clock#tick} should attempt to advance time.
     * The clock will only advance time when both
     * {@link Clock#canAnimate} and {@link Clock#shouldAnimate} are true.
     * Changing this property will change
     * {@link Clock#clockStep} from {@link ClockStep.SYSTEM_CLOCK} to
     * {@link ClockStep.SYSTEM_CLOCK_MULTIPLIER}.
     */
    shouldAnimate: boolean;
    /**
     * Advances the clock from the current time based on the current configuration options.
     * tick should be called every frame, regardless of whether animation is taking place
     * or not.  To control animation, use the {@link Clock#shouldAnimate} property.
     * @returns The new value of the {@link Clock#currentTime} property.
     */
    tick(): JulianDate;
}

/**
 * Constants used by {@link Clock#tick} to determine behavior
 * when {@link Clock#startTime} or {@link Clock#stopTime} is reached.
 */
export enum ClockRange {
    /**
     * {@link Clock#tick} will always advances the clock in its current direction.
     */
    UNBOUNDED = 0,
    /**
     * When {@link Clock#startTime} or {@link Clock#stopTime} is reached,
     * {@link Clock#tick} will not advance {@link Clock#currentTime} any further.
     */
    CLAMPED = 1,
    /**
     * When {@link Clock#stopTime} is reached, {@link Clock#tick} will advance
     * {@link Clock#currentTime} to the opposite end of the interval.  When
     * time is moving backwards, {@link Clock#tick} will not advance past
     * {@link Clock#startTime}
     */
    LOOP_STOP = 2
}

/**
 * Constants to determine how much time advances with each call
 * to {@link Clock#tick}.
 */
export enum ClockStep {
    /**
     * {@link Clock#tick} advances the current time by a fixed step,
     * which is the number of seconds specified by {@link Clock#multiplier}.
     */
    TICK_DEPENDENT = 0,
    /**
     * {@link Clock#tick} advances the current time by the amount of system
     * time elapsed since the previous call multiplied by {@link Clock#multiplier}.
     */
    SYSTEM_CLOCK_MULTIPLIER = 1,
    /**
     * {@link Clock#tick} sets the clock to the current system time;
     * ignoring all other settings.
     */
    SYSTEM_CLOCK = 2
}

/**
 * A color, specified using red, green, blue, and alpha values,
 * which range from <code>0</code> (no intensity) to <code>1.0</code> (full intensity).
 * @param [red = 1.0] - The red component.
 * @param [green = 1.0] - The green component.
 * @param [blue = 1.0] - The blue component.
 * @param [alpha = 1.0] - The alpha component.
 */
export class Color {
    constructor(red?: number, green?: number, blue?: number, alpha?: number);
    /**
     * The red component.
     */
    red: number;
    /**
     * The green component.
     */
    green: number;
    /**
     * The blue component.
     */
    blue: number;
    /**
     * The alpha component.
     */
    alpha: number;
    /**
     * Creates a Color instance from a {@link Cartesian4}. <code>x</code>, <code>y</code>, <code>z</code>,
     * and <code>w</code> map to <code>red</code>, <code>green</code>, <code>blue</code>, and <code>alpha</code>, respectively.
     * @param cartesian - The source cartesian.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Color instance if one was not provided.
     */
    static fromCartesian4(cartesian: Cartesian4, result?: Color): Color;
    /**
     * Creates a new Color specified using red, green, blue, and alpha values
     * that are in the range of 0 to 255, converting them internally to a range of 0.0 to 1.0.
     * @param [red = 255] - The red component.
     * @param [green = 255] - The green component.
     * @param [blue = 255] - The blue component.
     * @param [alpha = 255] - The alpha component.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Color instance if one was not provided.
     */
    static fromBytes(red?: number, green?: number, blue?: number, alpha?: number, result?: Color): Color;
    /**
     * Creates a new Color that has the same red, green, and blue components
     * of the specified color, but with the specified alpha value.
     * @example
     * const translucentRed = Cesium.Color.fromAlpha(Cesium.Color.RED, 0.9);
     * @param color - The base color
     * @param alpha - The new alpha component.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Color instance if one was not provided.
     */
    static fromAlpha(color: Color, alpha: number, result?: Color): Color;
    /**
     * Creates a new Color from a single numeric unsigned 32-bit RGBA value, using the endianness
     * of the system.
     * @example
     * const color = Cesium.Color.fromRgba(0x67ADDFFF);
     * @param rgba - A single numeric unsigned 32-bit RGBA value.
     * @param [result] - The object to store the result in, if undefined a new instance will be created.
     * @returns The color object.
     */
    static fromRgba(rgba: number, result?: Color): Color;
    /**
     * Creates a Color instance from hue, saturation, and lightness.
     * @param [hue = 0] - The hue angle 0...1
     * @param [saturation = 0] - The saturation value 0...1
     * @param [lightness = 0] - The lightness value 0...1
     * @param [alpha = 1.0] - The alpha component 0...1
     * @param [result] - The object to store the result in, if undefined a new instance will be created.
     * @returns The color object.
     */
    static fromHsl(hue?: number, saturation?: number, lightness?: number, alpha?: number, result?: Color): Color;
    /**
     * Creates a random color using the provided options. For reproducible random colors, you should
     * call {@link Math#setRandomNumberSeed} once at the beginning of your application.
     * @example
     * //Create a completely random color
     * const color = Cesium.Color.fromRandom();
     *
     * //Create a random shade of yellow.
     * const color1 = Cesium.Color.fromRandom({
     *     red : 1.0,
     *     green : 1.0,
     *     alpha : 1.0
     * });
     *
     * //Create a random bright color.
     * const color2 = Cesium.Color.fromRandom({
     *     minimumRed : 0.75,
     *     minimumGreen : 0.75,
     *     minimumBlue : 0.75,
     *     alpha : 1.0
     * });
     * @param [options] - Object with the following properties:
     * @param [options.red] - If specified, the red component to use instead of a randomized value.
     * @param [options.minimumRed = 0.0] - The maximum red value to generate if none was specified.
     * @param [options.maximumRed = 1.0] - The minimum red value to generate if none was specified.
     * @param [options.green] - If specified, the green component to use instead of a randomized value.
     * @param [options.minimumGreen = 0.0] - The maximum green value to generate if none was specified.
     * @param [options.maximumGreen = 1.0] - The minimum green value to generate if none was specified.
     * @param [options.blue] - If specified, the blue component to use instead of a randomized value.
     * @param [options.minimumBlue = 0.0] - The maximum blue value to generate if none was specified.
     * @param [options.maximumBlue = 1.0] - The minimum blue value to generate if none was specified.
     * @param [options.alpha] - If specified, the alpha component to use instead of a randomized value.
     * @param [options.minimumAlpha = 0.0] - The maximum alpha value to generate if none was specified.
     * @param [options.maximumAlpha = 1.0] - The minimum alpha value to generate if none was specified.
     * @param [result] - The object to store the result in, if undefined a new instance will be created.
     * @returns The modified result parameter or a new instance if result was undefined.
     */
    static fromRandom(options?: {
        red?: number;
        minimumRed?: number;
        maximumRed?: number;
        green?: number;
        minimumGreen?: number;
        maximumGreen?: number;
        blue?: number;
        minimumBlue?: number;
        maximumBlue?: number;
        alpha?: number;
        minimumAlpha?: number;
        maximumAlpha?: number;
    }, result?: Color): Color;
    /**
     * Creates a Color instance from a CSS color value.
     * @example
     * const cesiumBlue = Cesium.Color.fromCssColorString('#67ADDF');
     * const green = Cesium.Color.fromCssColorString('green');
     * @param color - The CSS color value in #rgb, #rgba, #rrggbb, #rrggbbaa, rgb(), rgba(), hsl(), or hsla() format.
     * @param [result] - The object to store the result in, if undefined a new instance will be created.
     * @returns The color object, or undefined if the string was not a valid CSS color.
     */
    static fromCssColorString(color: string, result?: Color): Color;
    /**
     * The number of elements used to pack the object into an array.
     */
    static packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: Color, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new Color instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: Color): Color;
    /**
     * Converts a 'byte' color component in the range of 0 to 255 into
     * a 'float' color component in the range of 0 to 1.0.
     * @param number - The number to be converted.
     * @returns The converted number.
     */
    static byteToFloat(number: number): number;
    /**
     * Converts a 'float' color component in the range of 0 to 1.0 into
     * a 'byte' color component in the range of 0 to 255.
     * @param number - The number to be converted.
     * @returns The converted number.
     */
    static floatToByte(number: number): number;
    /**
     * Duplicates a Color.
     * @param color - The Color to duplicate.
     * @param [result] - The object to store the result in, if undefined a new instance will be created.
     * @returns The modified result parameter or a new instance if result was undefined. (Returns undefined if color is undefined)
     */
    static clone(color: Color, result?: Color): Color;
    /**
     * Returns true if the first Color equals the second color.
     * @param left - The first Color to compare for equality.
     * @param right - The second Color to compare for equality.
     * @returns <code>true</code> if the Colors are equal; otherwise, <code>false</code>.
     */
    static equals(left: Color, right: Color): boolean;
    /**
     * Returns a duplicate of a Color instance.
     * @param [result] - The object to store the result in, if undefined a new instance will be created.
     * @returns The modified result parameter or a new instance if result was undefined.
     */
    clone(result?: Color): Color;
    /**
     * Returns true if this Color equals other.
     * @param other - The Color to compare for equality.
     * @returns <code>true</code> if the Colors are equal; otherwise, <code>false</code>.
     */
    equals(other: Color): boolean;
    /**
     * Returns <code>true</code> if this Color equals other componentwise within the specified epsilon.
     * @param other - The Color to compare for equality.
     * @param [epsilon = 0.0] - The epsilon to use for equality testing.
     * @returns <code>true</code> if the Colors are equal within the specified epsilon; otherwise, <code>false</code>.
     */
    equalsEpsilon(other: Color, epsilon?: number): boolean;
    /**
     * Creates a string representing this Color in the format '(red, green, blue, alpha)'.
     * @returns A string representing this Color in the format '(red, green, blue, alpha)'.
     */
    toString(): string;
    /**
     * Creates a string containing the CSS color value for this color.
     * @returns The CSS equivalent of this color.
     */
    toCssColorString(): string;
    /**
     * Creates a string containing CSS hex string color value for this color.
     * @returns The CSS hex string equivalent of this color.
     */
    toCssHexString(): string;
    /**
     * Converts this color to an array of red, green, blue, and alpha values
     * that are in the range of 0 to 255.
     * @param [result] - The array to store the result in, if undefined a new instance will be created.
     * @returns The modified result parameter or a new instance if result was undefined.
     */
    toBytes(result?: number[]): number[];
    /**
     * Converts this color to a single numeric unsigned 32-bit RGBA value, using the endianness
     * of the system.
     * @example
     * const rgba = Cesium.Color.BLUE.toRgba();
     * @returns A single numeric unsigned 32-bit RGBA value.
     */
    toRgba(): number;
    /**
     * Brightens this color by the provided magnitude.
     * @example
     * const brightBlue = Cesium.Color.BLUE.brighten(0.5, new Cesium.Color());
     * @param magnitude - A positive number indicating the amount to brighten.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    brighten(magnitude: number, result: Color): Color;
    /**
     * Darkens this color by the provided magnitude.
     * @example
     * const darkBlue = Cesium.Color.BLUE.darken(0.5, new Cesium.Color());
     * @param magnitude - A positive number indicating the amount to darken.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    darken(magnitude: number, result: Color): Color;
    /**
     * Creates a new Color that has the same red, green, and blue components
     * as this Color, but with the specified alpha value.
     * @example
     * const translucentRed = Cesium.Color.RED.withAlpha(0.9);
     * @param alpha - The new alpha component.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Color instance if one was not provided.
     */
    withAlpha(alpha: number, result?: Color): Color;
    /**
     * Computes the componentwise sum of two Colors.
     * @param left - The first Color.
     * @param right - The second Color.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static add(left: Color, right: Color, result: Color): Color;
    /**
     * Computes the componentwise difference of two Colors.
     * @param left - The first Color.
     * @param right - The second Color.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static subtract(left: Color, right: Color, result: Color): Color;
    /**
     * Computes the componentwise product of two Colors.
     * @param left - The first Color.
     * @param right - The second Color.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static multiply(left: Color, right: Color, result: Color): Color;
    /**
     * Computes the componentwise quotient of two Colors.
     * @param left - The first Color.
     * @param right - The second Color.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static divide(left: Color, right: Color, result: Color): Color;
    /**
     * Computes the componentwise modulus of two Colors.
     * @param left - The first Color.
     * @param right - The second Color.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static mod(left: Color, right: Color, result: Color): Color;
    /**
     * Computes the linear interpolation or extrapolation at t between the provided colors.
     * @param start - The color corresponding to t at 0.0.
     * @param end - The color corresponding to t at 1.0.
     * @param t - The point along t at which to interpolate.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static lerp(start: Color, end: Color, t: number, result: Color): Color;
    /**
     * Multiplies the provided Color componentwise by the provided scalar.
     * @param color - The Color to be scaled.
     * @param scalar - The scalar to multiply with.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static multiplyByScalar(color: Color, scalar: number, result: Color): Color;
    /**
     * Divides the provided Color componentwise by the provided scalar.
     * @param color - The Color to be divided.
     * @param scalar - The scalar to divide with.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static divideByScalar(color: Color, scalar: number, result: Color): Color;
    /**
     * An immutable Color instance initialized to CSS color #F0F8FF
     * <span class="colorSwath" style="background: #F0F8FF;"></span>
     */
    static readonly ALICEBLUE: Color;
    /**
     * An immutable Color instance initialized to CSS color #FAEBD7
     * <span class="colorSwath" style="background: #FAEBD7;"></span>
     */
    static readonly ANTIQUEWHITE: Color;
    /**
     * An immutable Color instance initialized to CSS color #00FFFF
     * <span class="colorSwath" style="background: #00FFFF;"></span>
     */
    static readonly AQUA: Color;
    /**
     * An immutable Color instance initialized to CSS color #7FFFD4
     * <span class="colorSwath" style="background: #7FFFD4;"></span>
     */
    static readonly AQUAMARINE: Color;
    /**
     * An immutable Color instance initialized to CSS color #F0FFFF
     * <span class="colorSwath" style="background: #F0FFFF;"></span>
     */
    static readonly AZURE: Color;
    /**
     * An immutable Color instance initialized to CSS color #F5F5DC
     * <span class="colorSwath" style="background: #F5F5DC;"></span>
     */
    static readonly BEIGE: Color;
    /**
     * An immutable Color instance initialized to CSS color #FFE4C4
     * <span class="colorSwath" style="background: #FFE4C4;"></span>
     */
    static readonly BISQUE: Color;
    /**
     * An immutable Color instance initialized to CSS color #000000
     * <span class="colorSwath" style="background: #000000;"></span>
     */
    static readonly BLACK: Color;
    /**
     * An immutable Color instance initialized to CSS color #FFEBCD
     * <span class="colorSwath" style="background: #FFEBCD;"></span>
     */
    static readonly BLANCHEDALMOND: Color;
    /**
     * An immutable Color instance initialized to CSS color #0000FF
     * <span class="colorSwath" style="background: #0000FF;"></span>
     */
    static readonly BLUE: Color;
    /**
     * An immutable Color instance initialized to CSS color #8A2BE2
     * <span class="colorSwath" style="background: #8A2BE2;"></span>
     */
    static readonly BLUEVIOLET: Color;
    /**
     * An immutable Color instance initialized to CSS color #A52A2A
     * <span class="colorSwath" style="background: #A52A2A;"></span>
     */
    static readonly BROWN: Color;
    /**
     * An immutable Color instance initialized to CSS color #DEB887
     * <span class="colorSwath" style="background: #DEB887;"></span>
     */
    static readonly BURLYWOOD: Color;
    /**
     * An immutable Color instance initialized to CSS color #5F9EA0
     * <span class="colorSwath" style="background: #5F9EA0;"></span>
     */
    static readonly CADETBLUE: Color;
    /**
     * An immutable Color instance initialized to CSS color #7FFF00
     * <span class="colorSwath" style="background: #7FFF00;"></span>
     */
    static readonly CHARTREUSE: Color;
    /**
     * An immutable Color instance initialized to CSS color #D2691E
     * <span class="colorSwath" style="background: #D2691E;"></span>
     */
    static readonly CHOCOLATE: Color;
    /**
     * An immutable Color instance initialized to CSS color #FF7F50
     * <span class="colorSwath" style="background: #FF7F50;"></span>
     */
    static readonly CORAL: Color;
    /**
     * An immutable Color instance initialized to CSS color #6495ED
     * <span class="colorSwath" style="background: #6495ED;"></span>
     */
    static readonly CORNFLOWERBLUE: Color;
    /**
     * An immutable Color instance initialized to CSS color #FFF8DC
     * <span class="colorSwath" style="background: #FFF8DC;"></span>
     */
    static readonly CORNSILK: Color;
    /**
     * An immutable Color instance initialized to CSS color #DC143C
     * <span class="colorSwath" style="background: #DC143C;"></span>
     */
    static readonly CRIMSON: Color;
    /**
     * An immutable Color instance initialized to CSS color #00FFFF
     * <span class="colorSwath" style="background: #00FFFF;"></span>
     */
    static readonly CYAN: Color;
    /**
     * An immutable Color instance initialized to CSS color #00008B
     * <span class="colorSwath" style="background: #00008B;"></span>
     */
    static readonly DARKBLUE: Color;
    /**
     * An immutable Color instance initialized to CSS color #008B8B
     * <span class="colorSwath" style="background: #008B8B;"></span>
     */
    static readonly DARKCYAN: Color;
    /**
     * An immutable Color instance initialized to CSS color #B8860B
     * <span class="colorSwath" style="background: #B8860B;"></span>
     */
    static readonly DARKGOLDENROD: Color;
    /**
     * An immutable Color instance initialized to CSS color #A9A9A9
     * <span class="colorSwath" style="background: #A9A9A9;"></span>
     */
    static readonly DARKGRAY: Color;
    /**
     * An immutable Color instance initialized to CSS color #006400
     * <span class="colorSwath" style="background: #006400;"></span>
     */
    static readonly DARKGREEN: Color;
    /**
     * An immutable Color instance initialized to CSS color #A9A9A9
     * <span class="colorSwath" style="background: #A9A9A9;"></span>
     */
    static readonly DARKGREY: Color;
    /**
     * An immutable Color instance initialized to CSS color #BDB76B
     * <span class="colorSwath" style="background: #BDB76B;"></span>
     */
    static readonly DARKKHAKI: Color;
    /**
     * An immutable Color instance initialized to CSS color #8B008B
     * <span class="colorSwath" style="background: #8B008B;"></span>
     */
    static readonly DARKMAGENTA: Color;
    /**
     * An immutable Color instance initialized to CSS color #556B2F
     * <span class="colorSwath" style="background: #556B2F;"></span>
     */
    static readonly DARKOLIVEGREEN: Color;
    /**
     * An immutable Color instance initialized to CSS color #FF8C00
     * <span class="colorSwath" style="background: #FF8C00;"></span>
     */
    static readonly DARKORANGE: Color;
    /**
     * An immutable Color instance initialized to CSS color #9932CC
     * <span class="colorSwath" style="background: #9932CC;"></span>
     */
    static readonly DARKORCHID: Color;
    /**
     * An immutable Color instance initialized to CSS color #8B0000
     * <span class="colorSwath" style="background: #8B0000;"></span>
     */
    static readonly DARKRED: Color;
    /**
     * An immutable Color instance initialized to CSS color #E9967A
     * <span class="colorSwath" style="background: #E9967A;"></span>
     */
    static readonly DARKSALMON: Color;
    /**
     * An immutable Color instance initialized to CSS color #8FBC8F
     * <span class="colorSwath" style="background: #8FBC8F;"></span>
     */
    static readonly DARKSEAGREEN: Color;
    /**
     * An immutable Color instance initialized to CSS color #483D8B
     * <span class="colorSwath" style="background: #483D8B;"></span>
     */
    static readonly DARKSLATEBLUE: Color;
    /**
     * An immutable Color instance initialized to CSS color #2F4F4F
     * <span class="colorSwath" style="background: #2F4F4F;"></span>
     */
    static readonly DARKSLATEGRAY: Color;
    /**
     * An immutable Color instance initialized to CSS color #2F4F4F
     * <span class="colorSwath" style="background: #2F4F4F;"></span>
     */
    static readonly DARKSLATEGREY: Color;
    /**
     * An immutable Color instance initialized to CSS color #00CED1
     * <span class="colorSwath" style="background: #00CED1;"></span>
     */
    static readonly DARKTURQUOISE: Color;
    /**
     * An immutable Color instance initialized to CSS color #9400D3
     * <span class="colorSwath" style="background: #9400D3;"></span>
     */
    static readonly DARKVIOLET: Color;
    /**
     * An immutable Color instance initialized to CSS color #FF1493
     * <span class="colorSwath" style="background: #FF1493;"></span>
     */
    static readonly DEEPPINK: Color;
    /**
     * An immutable Color instance initialized to CSS color #00BFFF
     * <span class="colorSwath" style="background: #00BFFF;"></span>
     */
    static readonly DEEPSKYBLUE: Color;
    /**
     * An immutable Color instance initialized to CSS color #696969
     * <span class="colorSwath" style="background: #696969;"></span>
     */
    static readonly DIMGRAY: Color;
    /**
     * An immutable Color instance initialized to CSS color #696969
     * <span class="colorSwath" style="background: #696969;"></span>
     */
    static readonly DIMGREY: Color;
    /**
     * An immutable Color instance initialized to CSS color #1E90FF
     * <span class="colorSwath" style="background: #1E90FF;"></span>
     */
    static readonly DODGERBLUE: Color;
    /**
     * An immutable Color instance initialized to CSS color #B22222
     * <span class="colorSwath" style="background: #B22222;"></span>
     */
    static readonly FIREBRICK: Color;
    /**
     * An immutable Color instance initialized to CSS color #FFFAF0
     * <span class="colorSwath" style="background: #FFFAF0;"></span>
     */
    static readonly FLORALWHITE: Color;
    /**
     * An immutable Color instance initialized to CSS color #228B22
     * <span class="colorSwath" style="background: #228B22;"></span>
     */
    static readonly FORESTGREEN: Color;
    /**
     * An immutable Color instance initialized to CSS color #FF00FF
     * <span class="colorSwath" style="background: #FF00FF;"></span>
     */
    static readonly FUCHSIA: Color;
    /**
     * An immutable Color instance initialized to CSS color #DCDCDC
     * <span class="colorSwath" style="background: #DCDCDC;"></span>
     */
    static readonly GAINSBORO: Color;
    /**
     * An immutable Color instance initialized to CSS color #F8F8FF
     * <span class="colorSwath" style="background: #F8F8FF;"></span>
     */
    static readonly GHOSTWHITE: Color;
    /**
     * An immutable Color instance initialized to CSS color #FFD700
     * <span class="colorSwath" style="background: #FFD700;"></span>
     */
    static readonly GOLD: Color;
    /**
     * An immutable Color instance initialized to CSS color #DAA520
     * <span class="colorSwath" style="background: #DAA520;"></span>
     */
    static readonly GOLDENROD: Color;
    /**
     * An immutable Color instance initialized to CSS color #808080
     * <span class="colorSwath" style="background: #808080;"></span>
     */
    static readonly GRAY: Color;
    /**
     * An immutable Color instance initialized to CSS color #008000
     * <span class="colorSwath" style="background: #008000;"></span>
     */
    static readonly GREEN: Color;
    /**
     * An immutable Color instance initialized to CSS color #ADFF2F
     * <span class="colorSwath" style="background: #ADFF2F;"></span>
     */
    static readonly GREENYELLOW: Color;
    /**
     * An immutable Color instance initialized to CSS color #808080
     * <span class="colorSwath" style="background: #808080;"></span>
     */
    static readonly GREY: Color;
    /**
     * An immutable Color instance initialized to CSS color #F0FFF0
     * <span class="colorSwath" style="background: #F0FFF0;"></span>
     */
    static readonly HONEYDEW: Color;
    /**
     * An immutable Color instance initialized to CSS color #FF69B4
     * <span class="colorSwath" style="background: #FF69B4;"></span>
     */
    static readonly HOTPINK: Color;
    /**
     * An immutable Color instance initialized to CSS color #CD5C5C
     * <span class="colorSwath" style="background: #CD5C5C;"></span>
     */
    static readonly INDIANRED: Color;
    /**
     * An immutable Color instance initialized to CSS color #4B0082
     * <span class="colorSwath" style="background: #4B0082;"></span>
     */
    static readonly INDIGO: Color;
    /**
     * An immutable Color instance initialized to CSS color #FFFFF0
     * <span class="colorSwath" style="background: #FFFFF0;"></span>
     */
    static readonly IVORY: Color;
    /**
     * An immutable Color instance initialized to CSS color #F0E68C
     * <span class="colorSwath" style="background: #F0E68C;"></span>
     */
    static readonly KHAKI: Color;
    /**
     * An immutable Color instance initialized to CSS color #E6E6FA
     * <span class="colorSwath" style="background: #E6E6FA;"></span>
     */
    static readonly LAVENDER: Color;
    /**
     * An immutable Color instance initialized to CSS color #FFF0F5
     * <span class="colorSwath" style="background: #FFF0F5;"></span>
     */
    static readonly LAVENDAR_BLUSH: Color;
    /**
     * An immutable Color instance initialized to CSS color #7CFC00
     * <span class="colorSwath" style="background: #7CFC00;"></span>
     */
    static readonly LAWNGREEN: Color;
    /**
     * An immutable Color instance initialized to CSS color #FFFACD
     * <span class="colorSwath" style="background: #FFFACD;"></span>
     */
    static readonly LEMONCHIFFON: Color;
    /**
     * An immutable Color instance initialized to CSS color #ADD8E6
     * <span class="colorSwath" style="background: #ADD8E6;"></span>
     */
    static readonly LIGHTBLUE: Color;
    /**
     * An immutable Color instance initialized to CSS color #F08080
     * <span class="colorSwath" style="background: #F08080;"></span>
     */
    static readonly LIGHTCORAL: Color;
    /**
     * An immutable Color instance initialized to CSS color #E0FFFF
     * <span class="colorSwath" style="background: #E0FFFF;"></span>
     */
    static readonly LIGHTCYAN: Color;
    /**
     * An immutable Color instance initialized to CSS color #FAFAD2
     * <span class="colorSwath" style="background: #FAFAD2;"></span>
     */
    static readonly LIGHTGOLDENRODYELLOW: Color;
    /**
     * An immutable Color instance initialized to CSS color #D3D3D3
     * <span class="colorSwath" style="background: #D3D3D3;"></span>
     */
    static readonly LIGHTGRAY: Color;
    /**
     * An immutable Color instance initialized to CSS color #90EE90
     * <span class="colorSwath" style="background: #90EE90;"></span>
     */
    static readonly LIGHTGREEN: Color;
    /**
     * An immutable Color instance initialized to CSS color #D3D3D3
     * <span class="colorSwath" style="background: #D3D3D3;"></span>
     */
    static readonly LIGHTGREY: Color;
    /**
     * An immutable Color instance initialized to CSS color #FFB6C1
     * <span class="colorSwath" style="background: #FFB6C1;"></span>
     */
    static readonly LIGHTPINK: Color;
    /**
     * An immutable Color instance initialized to CSS color #20B2AA
     * <span class="colorSwath" style="background: #20B2AA;"></span>
     */
    static readonly LIGHTSEAGREEN: Color;
    /**
     * An immutable Color instance initialized to CSS color #87CEFA
     * <span class="colorSwath" style="background: #87CEFA;"></span>
     */
    static readonly LIGHTSKYBLUE: Color;
    /**
     * An immutable Color instance initialized to CSS color #778899
     * <span class="colorSwath" style="background: #778899;"></span>
     */
    static readonly LIGHTSLATEGRAY: Color;
    /**
     * An immutable Color instance initialized to CSS color #778899
     * <span class="colorSwath" style="background: #778899;"></span>
     */
    static readonly LIGHTSLATEGREY: Color;
    /**
     * An immutable Color instance initialized to CSS color #B0C4DE
     * <span class="colorSwath" style="background: #B0C4DE;"></span>
     */
    static readonly LIGHTSTEELBLUE: Color;
    /**
     * An immutable Color instance initialized to CSS color #FFFFE0
     * <span class="colorSwath" style="background: #FFFFE0;"></span>
     */
    static readonly LIGHTYELLOW: Color;
    /**
     * An immutable Color instance initialized to CSS color #00FF00
     * <span class="colorSwath" style="background: #00FF00;"></span>
     */
    static readonly LIME: Color;
    /**
     * An immutable Color instance initialized to CSS color #32CD32
     * <span class="colorSwath" style="background: #32CD32;"></span>
     */
    static readonly LIMEGREEN: Color;
    /**
     * An immutable Color instance initialized to CSS color #FAF0E6
     * <span class="colorSwath" style="background: #FAF0E6;"></span>
     */
    static readonly LINEN: Color;
    /**
     * An immutable Color instance initialized to CSS color #FF00FF
     * <span class="colorSwath" style="background: #FF00FF;"></span>
     */
    static readonly MAGENTA: Color;
    /**
     * An immutable Color instance initialized to CSS color #800000
     * <span class="colorSwath" style="background: #800000;"></span>
     */
    static readonly MAROON: Color;
    /**
     * An immutable Color instance initialized to CSS color #66CDAA
     * <span class="colorSwath" style="background: #66CDAA;"></span>
     */
    static readonly MEDIUMAQUAMARINE: Color;
    /**
     * An immutable Color instance initialized to CSS color #0000CD
     * <span class="colorSwath" style="background: #0000CD;"></span>
     */
    static readonly MEDIUMBLUE: Color;
    /**
     * An immutable Color instance initialized to CSS color #BA55D3
     * <span class="colorSwath" style="background: #BA55D3;"></span>
     */
    static readonly MEDIUMORCHID: Color;
    /**
     * An immutable Color instance initialized to CSS color #9370DB
     * <span class="colorSwath" style="background: #9370DB;"></span>
     */
    static readonly MEDIUMPURPLE: Color;
    /**
     * An immutable Color instance initialized to CSS color #3CB371
     * <span class="colorSwath" style="background: #3CB371;"></span>
     */
    static readonly MEDIUMSEAGREEN: Color;
    /**
     * An immutable Color instance initialized to CSS color #7B68EE
     * <span class="colorSwath" style="background: #7B68EE;"></span>
     */
    static readonly MEDIUMSLATEBLUE: Color;
    /**
     * An immutable Color instance initialized to CSS color #00FA9A
     * <span class="colorSwath" style="background: #00FA9A;"></span>
     */
    static readonly MEDIUMSPRINGGREEN: Color;
    /**
     * An immutable Color instance initialized to CSS color #48D1CC
     * <span class="colorSwath" style="background: #48D1CC;"></span>
     */
    static readonly MEDIUMTURQUOISE: Color;
    /**
     * An immutable Color instance initialized to CSS color #C71585
     * <span class="colorSwath" style="background: #C71585;"></span>
     */
    static readonly MEDIUMVIOLETRED: Color;
    /**
     * An immutable Color instance initialized to CSS color #191970
     * <span class="colorSwath" style="background: #191970;"></span>
     */
    static readonly MIDNIGHTBLUE: Color;
    /**
     * An immutable Color instance initialized to CSS color #F5FFFA
     * <span class="colorSwath" style="background: #F5FFFA;"></span>
     */
    static readonly MINTCREAM: Color;
    /**
     * An immutable Color instance initialized to CSS color #FFE4E1
     * <span class="colorSwath" style="background: #FFE4E1;"></span>
     */
    static readonly MISTYROSE: Color;
    /**
     * An immutable Color instance initialized to CSS color #FFE4B5
     * <span class="colorSwath" style="background: #FFE4B5;"></span>
     */
    static readonly MOCCASIN: Color;
    /**
     * An immutable Color instance initialized to CSS color #FFDEAD
     * <span class="colorSwath" style="background: #FFDEAD;"></span>
     */
    static readonly NAVAJOWHITE: Color;
    /**
     * An immutable Color instance initialized to CSS color #000080
     * <span class="colorSwath" style="background: #000080;"></span>
     */
    static readonly NAVY: Color;
    /**
     * An immutable Color instance initialized to CSS color #FDF5E6
     * <span class="colorSwath" style="background: #FDF5E6;"></span>
     */
    static readonly OLDLACE: Color;
    /**
     * An immutable Color instance initialized to CSS color #808000
     * <span class="colorSwath" style="background: #808000;"></span>
     */
    static readonly OLIVE: Color;
    /**
     * An immutable Color instance initialized to CSS color #6B8E23
     * <span class="colorSwath" style="background: #6B8E23;"></span>
     */
    static readonly OLIVEDRAB: Color;
    /**
     * An immutable Color instance initialized to CSS color #FFA500
     * <span class="colorSwath" style="background: #FFA500;"></span>
     */
    static readonly ORANGE: Color;
    /**
     * An immutable Color instance initialized to CSS color #FF4500
     * <span class="colorSwath" style="background: #FF4500;"></span>
     */
    static readonly ORANGERED: Color;
    /**
     * An immutable Color instance initialized to CSS color #DA70D6
     * <span class="colorSwath" style="background: #DA70D6;"></span>
     */
    static readonly ORCHID: Color;
    /**
     * An immutable Color instance initialized to CSS color #EEE8AA
     * <span class="colorSwath" style="background: #EEE8AA;"></span>
     */
    static readonly PALEGOLDENROD: Color;
    /**
     * An immutable Color instance initialized to CSS color #98FB98
     * <span class="colorSwath" style="background: #98FB98;"></span>
     */
    static readonly PALEGREEN: Color;
    /**
     * An immutable Color instance initialized to CSS color #AFEEEE
     * <span class="colorSwath" style="background: #AFEEEE;"></span>
     */
    static readonly PALETURQUOISE: Color;
    /**
     * An immutable Color instance initialized to CSS color #DB7093
     * <span class="colorSwath" style="background: #DB7093;"></span>
     */
    static readonly PALEVIOLETRED: Color;
    /**
     * An immutable Color instance initialized to CSS color #FFEFD5
     * <span class="colorSwath" style="background: #FFEFD5;"></span>
     */
    static readonly PAPAYAWHIP: Color;
    /**
     * An immutable Color instance initialized to CSS color #FFDAB9
     * <span class="colorSwath" style="background: #FFDAB9;"></span>
     */
    static readonly PEACHPUFF: Color;
    /**
     * An immutable Color instance initialized to CSS color #CD853F
     * <span class="colorSwath" style="background: #CD853F;"></span>
     */
    static readonly PERU: Color;
    /**
     * An immutable Color instance initialized to CSS color #FFC0CB
     * <span class="colorSwath" style="background: #FFC0CB;"></span>
     */
    static readonly PINK: Color;
    /**
     * An immutable Color instance initialized to CSS color #DDA0DD
     * <span class="colorSwath" style="background: #DDA0DD;"></span>
     */
    static readonly PLUM: Color;
    /**
     * An immutable Color instance initialized to CSS color #B0E0E6
     * <span class="colorSwath" style="background: #B0E0E6;"></span>
     */
    static readonly POWDERBLUE: Color;
    /**
     * An immutable Color instance initialized to CSS color #800080
     * <span class="colorSwath" style="background: #800080;"></span>
     */
    static readonly PURPLE: Color;
    /**
     * An immutable Color instance initialized to CSS color #FF0000
     * <span class="colorSwath" style="background: #FF0000;"></span>
     */
    static readonly RED: Color;
    /**
     * An immutable Color instance initialized to CSS color #BC8F8F
     * <span class="colorSwath" style="background: #BC8F8F;"></span>
     */
    static readonly ROSYBROWN: Color;
    /**
     * An immutable Color instance initialized to CSS color #4169E1
     * <span class="colorSwath" style="background: #4169E1;"></span>
     */
    static readonly ROYALBLUE: Color;
    /**
     * An immutable Color instance initialized to CSS color #8B4513
     * <span class="colorSwath" style="background: #8B4513;"></span>
     */
    static readonly SADDLEBROWN: Color;
    /**
     * An immutable Color instance initialized to CSS color #FA8072
     * <span class="colorSwath" style="background: #FA8072;"></span>
     */
    static readonly SALMON: Color;
    /**
     * An immutable Color instance initialized to CSS color #F4A460
     * <span class="colorSwath" style="background: #F4A460;"></span>
     */
    static readonly SANDYBROWN: Color;
    /**
     * An immutable Color instance initialized to CSS color #2E8B57
     * <span class="colorSwath" style="background: #2E8B57;"></span>
     */
    static readonly SEAGREEN: Color;
    /**
     * An immutable Color instance initialized to CSS color #FFF5EE
     * <span class="colorSwath" style="background: #FFF5EE;"></span>
     */
    static readonly SEASHELL: Color;
    /**
     * An immutable Color instance initialized to CSS color #A0522D
     * <span class="colorSwath" style="background: #A0522D;"></span>
     */
    static readonly SIENNA: Color;
    /**
     * An immutable Color instance initialized to CSS color #C0C0C0
     * <span class="colorSwath" style="background: #C0C0C0;"></span>
     */
    static readonly SILVER: Color;
    /**
     * An immutable Color instance initialized to CSS color #87CEEB
     * <span class="colorSwath" style="background: #87CEEB;"></span>
     */
    static readonly SKYBLUE: Color;
    /**
     * An immutable Color instance initialized to CSS color #6A5ACD
     * <span class="colorSwath" style="background: #6A5ACD;"></span>
     */
    static readonly SLATEBLUE: Color;
    /**
     * An immutable Color instance initialized to CSS color #708090
     * <span class="colorSwath" style="background: #708090;"></span>
     */
    static readonly SLATEGRAY: Color;
    /**
     * An immutable Color instance initialized to CSS color #708090
     * <span class="colorSwath" style="background: #708090;"></span>
     */
    static readonly SLATEGREY: Color;
    /**
     * An immutable Color instance initialized to CSS color #FFFAFA
     * <span class="colorSwath" style="background: #FFFAFA;"></span>
     */
    static readonly SNOW: Color;
    /**
     * An immutable Color instance initialized to CSS color #00FF7F
     * <span class="colorSwath" style="background: #00FF7F;"></span>
     */
    static readonly SPRINGGREEN: Color;
    /**
     * An immutable Color instance initialized to CSS color #4682B4
     * <span class="colorSwath" style="background: #4682B4;"></span>
     */
    static readonly STEELBLUE: Color;
    /**
     * An immutable Color instance initialized to CSS color #D2B48C
     * <span class="colorSwath" style="background: #D2B48C;"></span>
     */
    static readonly TAN: Color;
    /**
     * An immutable Color instance initialized to CSS color #008080
     * <span class="colorSwath" style="background: #008080;"></span>
     */
    static readonly TEAL: Color;
    /**
     * An immutable Color instance initialized to CSS color #D8BFD8
     * <span class="colorSwath" style="background: #D8BFD8;"></span>
     */
    static readonly THISTLE: Color;
    /**
     * An immutable Color instance initialized to CSS color #FF6347
     * <span class="colorSwath" style="background: #FF6347;"></span>
     */
    static readonly TOMATO: Color;
    /**
     * An immutable Color instance initialized to CSS color #40E0D0
     * <span class="colorSwath" style="background: #40E0D0;"></span>
     */
    static readonly TURQUOISE: Color;
    /**
     * An immutable Color instance initialized to CSS color #EE82EE
     * <span class="colorSwath" style="background: #EE82EE;"></span>
     */
    static readonly VIOLET: Color;
    /**
     * An immutable Color instance initialized to CSS color #F5DEB3
     * <span class="colorSwath" style="background: #F5DEB3;"></span>
     */
    static readonly WHEAT: Color;
    /**
     * An immutable Color instance initialized to CSS color #FFFFFF
     * <span class="colorSwath" style="background: #FFFFFF;"></span>
     */
    static readonly WHITE: Color;
    /**
     * An immutable Color instance initialized to CSS color #F5F5F5
     * <span class="colorSwath" style="background: #F5F5F5;"></span>
     */
    static readonly WHITESMOKE: Color;
    /**
     * An immutable Color instance initialized to CSS color #FFFF00
     * <span class="colorSwath" style="background: #FFFF00;"></span>
     */
    static readonly YELLOW: Color;
    /**
     * An immutable Color instance initialized to CSS color #9ACD32
     * <span class="colorSwath" style="background: #9ACD32;"></span>
     */
    static readonly YELLOWGREEN: Color;
    /**
     * An immutable Color instance initialized to CSS transparent.
     * <span class="colorSwath" style="background: transparent;"></span>
     */
    static readonly TRANSPARENT: Color;
}

/**
 * Value and type information for per-instance geometry color.
 * @example
 * const instance = new Cesium.GeometryInstance({
 *   geometry : Cesium.BoxGeometry.fromDimensions({
 *     dimensions : new Cesium.Cartesian3(1000000.0, 1000000.0, 500000.0)
 *   }),
 *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(
 *     Cesium.Cartesian3.fromDegrees(0.0, 0.0)), new Cesium.Cartesian3(0.0, 0.0, 1000000.0), new Cesium.Matrix4()),
 *   id : 'box',
 *   attributes : {
 *     color : new Cesium.ColorGeometryInstanceAttribute(red, green, blue, alpha)
 *   }
 * });
 * @param [red = 1.0] - The red component.
 * @param [green = 1.0] - The green component.
 * @param [blue = 1.0] - The blue component.
 * @param [alpha = 1.0] - The alpha component.
 */
export class ColorGeometryInstanceAttribute {
    constructor(red?: number, green?: number, blue?: number, alpha?: number);
    /**
     * The values for the attributes stored in a typed array.
     */
    value: Uint8Array;
    /**
     * The datatype of each component in the attribute, e.g., individual elements in
     * {@link ColorGeometryInstanceAttribute#value}.
     */
    readonly componentDatatype: ComponentDatatype;
    /**
     * The number of components in the attributes, i.e., {@link ColorGeometryInstanceAttribute#value}.
     */
    readonly componentsPerAttribute: number;
    /**
     * When <code>true</code> and <code>componentDatatype</code> is an integer format,
     * indicate that the components should be mapped to the range [0, 1] (unsigned)
     * or [-1, 1] (signed) when they are accessed as floating-point for rendering.
     */
    readonly normalize: boolean;
    /**
     * Creates a new {@link ColorGeometryInstanceAttribute} instance given the provided {@link Color}.
     * @example
     * const instance = new Cesium.GeometryInstance({
     *   geometry : geometry,
     *   attributes : {
     *     color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.CORNFLOWERBLUE),
     *   }
     * });
     * @param color - The color.
     * @returns The new {@link ColorGeometryInstanceAttribute} instance.
     */
    static fromColor(color: Color): ColorGeometryInstanceAttribute;
    /**
     * Converts a color to a typed array that can be used to assign a color attribute.
     * @example
     * const attributes = primitive.getGeometryInstanceAttributes('an id');
     * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA, attributes.color);
     * @param color - The color.
     * @param [result] - The array to store the result in, if undefined a new instance will be created.
     * @returns The modified result parameter or a new instance if result was undefined.
     */
    static toValue(color: Color, result?: Uint8Array): Uint8Array;
    /**
     * Compares the provided ColorGeometryInstanceAttributes and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [left] - The first ColorGeometryInstanceAttribute.
     * @param [right] - The second ColorGeometryInstanceAttribute.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    static equals(left?: ColorGeometryInstanceAttribute, right?: ColorGeometryInstanceAttribute): boolean;
}

/**
 * WebGL component datatypes.  Components are intrinsics,
 * which form attributes, which form vertices.
 */
export enum ComponentDatatype {
    /**
     * 8-bit signed byte corresponding to <code>gl.BYTE</code> and the type
     * of an element in <code>Int8Array</code>.
     */
    BYTE = WebGLConstants.BYTE,
    /**
     * 8-bit unsigned byte corresponding to <code>UNSIGNED_BYTE</code> and the type
     * of an element in <code>Uint8Array</code>.
     */
    UNSIGNED_BYTE = WebGLConstants.UNSIGNED_BYTE,
    /**
     * 16-bit signed short corresponding to <code>SHORT</code> and the type
     * of an element in <code>Int16Array</code>.
     */
    SHORT = WebGLConstants.SHORT,
    /**
     * 16-bit unsigned short corresponding to <code>UNSIGNED_SHORT</code> and the type
     * of an element in <code>Uint16Array</code>.
     */
    UNSIGNED_SHORT = WebGLConstants.UNSIGNED_SHORT,
    /**
     * 32-bit signed int corresponding to <code>INT</code> and the type
     * of an element in <code>Int32Array</code>.
     */
    INT = WebGLConstants.INT,
    /**
     * 32-bit unsigned int corresponding to <code>UNSIGNED_INT</code> and the type
     * of an element in <code>Uint32Array</code>.
     */
    UNSIGNED_INT = WebGLConstants.UNSIGNED_INT,
    /**
     * 32-bit floating-point corresponding to <code>FLOAT</code> and the type
     * of an element in <code>Float32Array</code>.
     */
    FLOAT = WebGLConstants.FLOAT,
    /**
     * 64-bit floating-point corresponding to <code>gl.DOUBLE</code> (in Desktop OpenGL;
     * this is not supported in WebGL, and is emulated in Cesium via {@link GeometryPipeline.encodeAttribute})
     * and the type of an element in <code>Float64Array</code>.
     */
    DOUBLE = WebGLConstants.DOUBLE
}

/**
 * Describes a compressed texture and contains a compressed texture buffer.
 * @param internalFormat - The pixel format of the compressed texture.
 * @param pixelDatatype - The pixel datatype of the compressed texture.
 * @param width - The width of the texture.
 * @param height - The height of the texture.
 * @param buffer - The compressed texture buffer.
 */
export class CompressedTextureBuffer {
    constructor(internalFormat: PixelFormat, pixelDatatype: PixelDatatype, width: number, height: number, buffer: Uint8Array);
    /**
     * The format of the compressed texture.
     */
    readonly internalFormat: PixelFormat;
    /**
     * The datatype of the compressed texture.
     */
    readonly pixelDatatype: PixelDatatype;
    /**
     * The width of the texture.
     */
    readonly width: number;
    /**
     * The height of the texture.
     */
    readonly height: number;
    /**
     * The compressed texture buffer.
     */
    readonly bufferView: Uint8Array;
    /**
     * Creates a shallow clone of a compressed texture buffer.
     * @param object - The compressed texture buffer to be cloned.
     * @returns A shallow clone of the compressed texture buffer.
     */
    static clone(object: CompressedTextureBuffer): CompressedTextureBuffer;
    /**
     * Creates a shallow clone of this compressed texture buffer.
     * @returns A shallow clone of the compressed texture buffer.
     */
    clone(): CompressedTextureBuffer;
}

/**
 * A spline that evaluates to a constant value. Although this follows the {@link Spline} interface,
 * it does not maintain an internal array of times since its value never changes.
 * @example
 * const position = new Cesium.Cartesian3(1.0, 2.0, 3.0);
 * const spline = new Cesium.ConstantSpline(position);
 *
 * const p0 = spline.evaluate(0.0);
 * @param value - The constant value that the spline evaluates to.
 */
export class ConstantSpline {
    constructor(value: number | Cartesian3 | Quaternion);
    /**
     * The constant value that the spline evaluates to.
     */
    readonly value: number | Cartesian3 | Quaternion;
    /**
     * Finds an index <code>i</code> in <code>times</code> such that the parameter
     * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.
     *
     * Since a constant spline has no internal times array, this will throw an error.
     * @param time - The time.
     */
    findTimeInterval(time: number): void;
    /**
     * Wraps the given time to the period covered by the spline.
     * @param time - The time.
     * @returns The time, wrapped around to the updated animation.
     */
    wrapTime(time: number): number;
    /**
     * Clamps the given time to the period covered by the spline.
     * @param time - The time.
     * @returns The time, clamped to the animation period.
     */
    clampTime(time: number): number;
    /**
     * Evaluates the curve at a given time.
     * @param time - The time at which to evaluate the curve.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or the value that the constant spline represents.
     */
    evaluate(time: number, result?: Cartesian3 | Quaternion): number | Cartesian3 | Quaternion;
}

/**
 * A description of a polygon composed of arbitrary coplanar positions.
 * @example
 * const polygonGeometry = new Cesium.CoplanarPolygonGeometry({
 *  polygonHierarchy: new Cesium.PolygonHierarchy(
 *     Cesium.Cartesian3.fromDegreesArrayHeights([
 *      -90.0, 30.0, 0.0,
 *      -90.0, 30.0, 300000.0,
 *      -80.0, 30.0, 300000.0,
 *      -80.0, 30.0, 0.0
 *   ]))
 * });
 * @param options - Object with the following properties:
 * @param options.polygonHierarchy - A polygon hierarchy that can include holes.
 * @param [options.stRotation = 0.0] - The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.
 * @param [options.vertexFormat = VertexFormat.DEFAULT] - The vertex attributes to be computed.
 * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid to be used as a reference.
 * @param [options.textureCoordinates] - Texture coordinates as a {@link PolygonHierarchy} of {@link Cartesian2} points.
 */
export class CoplanarPolygonGeometry {
    constructor(options: {
        polygonHierarchy: PolygonHierarchy;
        stRotation?: number;
        vertexFormat?: VertexFormat;
        ellipsoid?: Ellipsoid;
        textureCoordinates?: PolygonHierarchy;
    });
    /**
     * The number of elements used to pack the object into an array.
     */
    packedLength: number;
    /**
     * A description of a coplanar polygon from an array of positions.
     * @example
     * // create a polygon from points
     * const polygon = Cesium.CoplanarPolygonGeometry.fromPositions({
     *   positions : Cesium.Cartesian3.fromDegreesArray([
     *     -72.0, 40.0,
     *     -70.0, 35.0,
     *     -75.0, 30.0,
     *     -70.0, 30.0,
     *     -68.0, 40.0
     *   ])
     * });
     * const geometry = Cesium.PolygonGeometry.createGeometry(polygon);
     * @param options - Object with the following properties:
     * @param options.positions - An array of positions that defined the corner points of the polygon.
     * @param [options.vertexFormat = VertexFormat.DEFAULT] - The vertex attributes to be computed.
     * @param [options.stRotation = 0.0] - The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.
     * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid to be used as a reference.
     * @param [options.textureCoordinates] - Texture coordinates as a {@link PolygonHierarchy} of {@link Cartesian2} points.
     */
    static fromPositions(options: {
        positions: Cartesian3[];
        vertexFormat?: VertexFormat;
        stRotation?: number;
        ellipsoid?: Ellipsoid;
        textureCoordinates?: PolygonHierarchy;
    }): CoplanarPolygonGeometry;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: CoplanarPolygonGeometry, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new CoplanarPolygonGeometry instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: CoplanarPolygonGeometry): CoplanarPolygonGeometry;
    /**
     * Computes the geometric representation of an arbitrary coplanar polygon, including its vertices, indices, and a bounding sphere.
     * @param polygonGeometry - A description of the polygon.
     * @returns The computed vertices and indices.
     */
    static createGeometry(polygonGeometry: CoplanarPolygonGeometry): Geometry | undefined;
}

/**
 * A description of the outline of a polygon composed of arbitrary coplanar positions.
 * @example
 * const polygonOutline = new Cesium.CoplanarPolygonOutlineGeometry({
 *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([
 *      -90.0, 30.0, 0.0,
 *      -90.0, 30.0, 1000.0,
 *      -80.0, 30.0, 1000.0,
 *      -80.0, 30.0, 0.0
 *   ])
 * });
 * const geometry = Cesium.CoplanarPolygonOutlineGeometry.createGeometry(polygonOutline);
 * @param options - Object with the following properties:
 * @param options.polygonHierarchy - A polygon hierarchy that can include holes.
 */
export class CoplanarPolygonOutlineGeometry {
    constructor(options: {
        polygonHierarchy: PolygonHierarchy;
    });
    /**
     * The number of elements used to pack the object into an array.
     */
    packedLength: number;
    /**
     * A description of a coplanar polygon outline from an array of positions.
     * @param options - Object with the following properties:
     * @param options.positions - An array of positions that defined the corner points of the polygon.
     */
    static fromPositions(options: {
        positions: Cartesian3[];
    }): CoplanarPolygonOutlineGeometry;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: CoplanarPolygonOutlineGeometry, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new CoplanarPolygonOutlineGeometry instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: CoplanarPolygonOutlineGeometry): CoplanarPolygonOutlineGeometry;
    /**
     * Computes the geometric representation of an arbitrary coplanar polygon, including its vertices, indices, and a bounding sphere.
     * @param polygonGeometry - A description of the polygon.
     * @returns The computed vertices and indices.
     */
    static createGeometry(polygonGeometry: CoplanarPolygonOutlineGeometry): Geometry | undefined;
}

/**
 * Style options for corners.
 */
export enum CornerType {
    /**
     * <img src="Images/CornerTypeRounded.png" style="vertical-align: middle;" width="186" height="189" />
     *
     * Corner has a smooth edge.
     */
    ROUNDED = 0,
    /**
     * <img src="Images/CornerTypeMitered.png" style="vertical-align: middle;" width="186" height="189" />
     *
     * Corner point is the intersection of adjacent edges.
     */
    MITERED = 1,
    /**
     * <img src="Images/CornerTypeBeveled.png" style="vertical-align: middle;" width="186" height="189" />
     *
     * Corner is clipped.
     */
    BEVELED = 2
}

/**
 * A description of a corridor. Corridor geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.
 * @example
 * const corridor = new Cesium.CorridorGeometry({
 *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,
 *   positions : Cesium.Cartesian3.fromDegreesArray([-72.0, 40.0, -70.0, 35.0]),
 *   width : 100000
 * });
 * @param options - Object with the following properties:
 * @param options.positions - An array of positions that define the center of the corridor.
 * @param options.width - The distance between the edges of the corridor in meters.
 * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid to be used as a reference.
 * @param [options.granularity = Math.RADIANS_PER_DEGREE] - The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
 * @param [options.height = 0] - The distance in meters between the ellipsoid surface and the positions.
 * @param [options.extrudedHeight] - The distance in meters between the ellipsoid surface and the extruded face.
 * @param [options.vertexFormat = VertexFormat.DEFAULT] - The vertex attributes to be computed.
 * @param [options.cornerType = CornerType.ROUNDED] - Determines the style of the corners.
 */
export class CorridorGeometry {
    constructor(options: {
        positions: Cartesian3[];
        width: number;
        ellipsoid?: Ellipsoid;
        granularity?: number;
        height?: number;
        extrudedHeight?: number;
        vertexFormat?: VertexFormat;
        cornerType?: CornerType;
    });
    /**
     * The number of elements used to pack the object into an array.
     */
    packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: CorridorGeometry, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new CorridorGeometry instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: CorridorGeometry): CorridorGeometry;
    /**
     * Computes the bounding rectangle given the provided options
     * @param options - Object with the following properties:
     * @param options.positions - An array of positions that define the center of the corridor.
     * @param options.width - The distance between the edges of the corridor in meters.
     * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid to be used as a reference.
     * @param [options.cornerType = CornerType.ROUNDED] - Determines the style of the corners.
     * @param [result] - An object in which to store the result.
     * @returns The result rectangle.
     */
    static computeRectangle(options: {
        positions: Cartesian3[];
        width: number;
        ellipsoid?: Ellipsoid;
        cornerType?: CornerType;
    }, result?: Rectangle): Rectangle;
    /**
     * Computes the geometric representation of a corridor, including its vertices, indices, and a bounding sphere.
     * @param corridorGeometry - A description of the corridor.
     * @returns The computed vertices and indices.
     */
    static createGeometry(corridorGeometry: CorridorGeometry): Geometry | undefined;
}

/**
 * A description of a corridor outline.
 * @example
 * const corridor = new Cesium.CorridorOutlineGeometry({
 *   positions : Cesium.Cartesian3.fromDegreesArray([-72.0, 40.0, -70.0, 35.0]),
 *   width : 100000
 * });
 * @param options - Object with the following properties:
 * @param options.positions - An array of positions that define the center of the corridor outline.
 * @param options.width - The distance between the edges of the corridor outline.
 * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid to be used as a reference.
 * @param [options.granularity = Math.RADIANS_PER_DEGREE] - The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
 * @param [options.height = 0] - The distance in meters between the positions and the ellipsoid surface.
 * @param [options.extrudedHeight] - The distance in meters between the extruded face and the ellipsoid surface.
 * @param [options.cornerType = CornerType.ROUNDED] - Determines the style of the corners.
 */
export class CorridorOutlineGeometry {
    constructor(options: {
        positions: Cartesian3[];
        width: number;
        ellipsoid?: Ellipsoid;
        granularity?: number;
        height?: number;
        extrudedHeight?: number;
        cornerType?: CornerType;
    });
    /**
     * The number of elements used to pack the object into an array.
     */
    packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: CorridorOutlineGeometry, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new CorridorOutlineGeometry instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: CorridorOutlineGeometry): CorridorOutlineGeometry;
    /**
     * Computes the geometric representation of a corridor, including its vertices, indices, and a bounding sphere.
     * @param corridorOutlineGeometry - A description of the corridor.
     * @returns The computed vertices and indices.
     */
    static createGeometry(corridorOutlineGeometry: CorridorOutlineGeometry): Geometry | undefined;
}

/**
 * A credit contains data pertaining to how to display attributions/credits for certain content on the screen.
 * @example
 * // Create a credit with a tooltip, image and link
 * const credit = new Cesium.Credit('<a href="https://cesium.com/" target="_blank"><img src="/images/cesium_logo.png" title="Cesium"/></a>');
 * @param html - An string representing an html code snippet
 * @param [showOnScreen = false] - If true, the credit will be visible in the main credit container.  Otherwise, it will appear in a popover
 */
export class Credit {
    constructor(html: string, showOnScreen?: boolean);
    /**
     * The credit content
     */
    readonly html: string;
    /**
     * Whether the credit should be displayed on screen or in a lightbox
     */
    showOnScreen: boolean;
    /**
     * Gets the credit element
     */
    readonly element: HTMLElement;
    /**
     * Returns true if the credits are equal
     * @param left - The first credit
     * @param right - The second credit
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    static equals(left: Credit, right: Credit): boolean;
    /**
     * Returns true if the credits are equal
     * @param credit - The credit to compare to.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    equals(credit: Credit): boolean;
    /**
     * Duplicates a Credit instance.
     * @param [credit] - The Credit to duplicate.
     * @returns A new Credit instance that is a duplicate of the one provided. (Returns undefined if the credit is undefined)
     */
    static clone(credit?: Credit): Credit;
}

/**
 * Defines functions for 3rd order polynomial functions of one variable with only real coefficients.
 */
export namespace CubicRealPolynomial {
    /**
     * Provides the discriminant of the cubic equation from the supplied coefficients.
     * @param a - The coefficient of the 3rd order monomial.
     * @param b - The coefficient of the 2nd order monomial.
     * @param c - The coefficient of the 1st order monomial.
     * @param d - The coefficient of the 0th order monomial.
     * @returns The value of the discriminant.
     */
    function computeDiscriminant(a: number, b: number, c: number, d: number): number;
    /**
     * Provides the real valued roots of the cubic polynomial with the provided coefficients.
     * @param a - The coefficient of the 3rd order monomial.
     * @param b - The coefficient of the 2nd order monomial.
     * @param c - The coefficient of the 1st order monomial.
     * @param d - The coefficient of the 0th order monomial.
     * @returns The real valued roots.
     */
    function computeRealRoots(a: number, b: number, c: number, d: number): number[];
}

/**
 * The culling volume defined by planes.
 * @param [planes] - An array of clipping planes.
 */
export class CullingVolume {
    constructor(planes?: Cartesian4[]);
    /**
     * Each plane is represented by a Cartesian4 object, where the x, y, and z components
     * define the unit vector normal to the plane, and the w component is the distance of the
     * plane from the origin.
     */
    planes: Cartesian4[];
    /**
     * Constructs a culling volume from a bounding sphere. Creates six planes that create a box containing the sphere.
     * The planes are aligned to the x, y, and z axes in world coordinates.
     * @param boundingSphere - The bounding sphere used to create the culling volume.
     * @param [result] - The object onto which to store the result.
     * @returns The culling volume created from the bounding sphere.
     */
    static fromBoundingSphere(boundingSphere: BoundingSphere, result?: CullingVolume): CullingVolume;
    /**
     * Determines whether a bounding volume intersects the culling volume.
     * @param boundingVolume - The bounding volume whose intersection with the culling volume is to be tested.
     * @returns Intersect.OUTSIDE, Intersect.INTERSECTING, or Intersect.INSIDE.
     */
    computeVisibility(boundingVolume: any): Intersect;
}

export namespace CustomHeightmapTerrainProvider {
    /**
     * @param x - The X coordinate of the tile for which to request geometry.
     * @param y - The Y coordinate of the tile for which to request geometry.
     * @param level - The level of the tile for which to request geometry.
     */
    type GeometryCallback = (x: number, y: number, level: number) => Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array | number[] | Promise<Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array | number[]> | undefined;
}

/**
 * A simple {@link TerrainProvider} that gets height values from a callback function.
 * It can be used for procedurally generated terrain or as a way to load custom
 * heightmap data without creating a subclass of {@link TerrainProvider}.
 *
 * There are some limitations such as no water mask, no vertex normals, and no
 * availability, so a full-fledged {@link TerrainProvider} subclass is better suited
 * for these more sophisticated use cases.
 * @example
 * const viewer = new Cesium.Viewer("cesiumContainer", {
 *   terrainProvider: new Cesium.CustomHeightmapTerrainProvider({
 *     width: 32,
 *     height: 32,
 *     callback: function (x, y, level) {
 *       return new Float32Array(32 * 32); // all zeros
 *     },
 *   }),
 * });
 * @param options - Object with the following properties:
 * @param options.callback - The callback function for requesting tile geometry.
 * @param options.width - The number of columns per heightmap tile.
 * @param options.height - The number of rows per heightmap tile.
 * @param [options.tilingScheme] - The tiling scheme specifying how the ellipsoidal
 * surface is broken into tiles. If this parameter is not provided, a {@link GeographicTilingScheme}
 * is used.
 * @param [options.ellipsoid] - The ellipsoid.  If the tilingScheme is specified,
 * this parameter is ignored and the tiling scheme's ellipsoid is used instead. If neither
 * parameter is specified, the WGS84 ellipsoid is used.
 * @param [options.credit] - A credit for the data source, which is displayed on the canvas.
 */
export class CustomHeightmapTerrainProvider {
    constructor(options: {
        callback: CustomHeightmapTerrainProvider.GeometryCallback;
        width: number;
        height: number;
        tilingScheme?: TilingScheme;
        ellipsoid?: Ellipsoid;
        credit?: Credit | string;
    });
    /**
     * Gets an event that is raised when the terrain provider encounters an asynchronous error. By subscribing
     * to the event, you will be notified of the error and can potentially recover from it. Event listeners
     * are passed an instance of {@link TileProviderError}.
     */
    readonly errorEvent: Event;
    /**
     * Gets the credit to display when this terrain provider is active. Typically this is used to credit
     * the source of the terrain.
     */
    readonly credit: Credit;
    /**
     * Gets the tiling scheme used by this provider.
     */
    readonly tilingScheme: TilingScheme;
    /**
     * Gets a value indicating whether or not the provider includes a water mask. The water mask
     * indicates which areas of the globe are water rather than land, so they can be rendered
     * as a reflective surface with animated waves.
     * Water mask is not supported by {@link CustomHeightmapTerrainProvider}, so the return
     * value will always be false.
     */
    readonly hasWaterMask: boolean;
    /**
     * Gets a value indicating whether or not the requested tiles include vertex normals.
     * Vertex normals are not supported by {@link CustomHeightmapTerrainProvider}, so the return
     * value will always be false.
     */
    readonly hasVertexNormals: boolean;
    /**
     * Gets the number of columns per heightmap tile.
     */
    readonly width: boolean;
    /**
     * Gets the number of rows per heightmap tile.
     */
    readonly height: boolean;
    /**
     * Requests the geometry for a given tile. The result includes terrain
     * data and indicates that all child tiles are available.
     * @param x - The X coordinate of the tile for which to request geometry.
     * @param y - The Y coordinate of the tile for which to request geometry.
     * @param level - The level of the tile for which to request geometry.
     * @param [request] - The request object. Intended for internal use only.
     * @returns A promise for the requested geometry. If this method
     *          returns undefined instead of a promise, it is an indication that too many requests are already
     *          pending and the request will be retried later.
     */
    requestTileGeometry(x: number, y: number, level: number, request?: Request): Promise<TerrainData> | undefined;
    /**
     * Gets the maximum geometric error allowed in a tile at a given level.
     * @param level - The tile level for which to get the maximum geometric error.
     * @returns The maximum geometric error.
     */
    getLevelMaximumGeometricError(level: number): number;
    /**
     * Determines whether data for a tile is available to be loaded.
     * @param x - The X coordinate of the tile for which to request geometry.
     * @param y - The Y coordinate of the tile for which to request geometry.
     * @param level - The level of the tile for which to request geometry.
     * @returns Undefined if not supported, otherwise true or false.
     */
    getTileDataAvailable(x: number, y: number, level: number): boolean | undefined;
    /**
     * Makes sure we load availability data for a tile
     * @param x - The X coordinate of the tile for which to request geometry.
     * @param y - The Y coordinate of the tile for which to request geometry.
     * @param level - The level of the tile for which to request geometry.
     * @returns Undefined if nothing need to be loaded or a Promise that resolves when all required tiles are loaded
     */
    loadTileDataAvailability(x: number, y: number, level: number): undefined | Promise<void>;
}

/**
 * A description of a cylinder.
 * @example
 * // create cylinder geometry
 * const cylinder = new Cesium.CylinderGeometry({
 *     length: 200000,
 *     topRadius: 80000,
 *     bottomRadius: 200000,
 * });
 * const geometry = Cesium.CylinderGeometry.createGeometry(cylinder);
 * @param options - Object with the following properties:
 * @param options.length - The length of the cylinder.
 * @param options.topRadius - The radius of the top of the cylinder.
 * @param options.bottomRadius - The radius of the bottom of the cylinder.
 * @param [options.slices = 128] - The number of edges around the perimeter of the cylinder.
 * @param [options.vertexFormat = VertexFormat.DEFAULT] - The vertex attributes to be computed.
 */
export class CylinderGeometry {
    constructor(options: {
        length: number;
        topRadius: number;
        bottomRadius: number;
        slices?: number;
        vertexFormat?: VertexFormat;
    });
    /**
     * The number of elements used to pack the object into an array.
     */
    static packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: CylinderGeometry, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new CylinderGeometry instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: CylinderGeometry): CylinderGeometry;
    /**
     * Computes the geometric representation of a cylinder, including its vertices, indices, and a bounding sphere.
     * @param cylinderGeometry - A description of the cylinder.
     * @returns The computed vertices and indices.
     */
    static createGeometry(cylinderGeometry: CylinderGeometry): Geometry | undefined;
}

/**
 * A description of the outline of a cylinder.
 * @example
 * // create cylinder geometry
 * const cylinder = new Cesium.CylinderOutlineGeometry({
 *     length: 200000,
 *     topRadius: 80000,
 *     bottomRadius: 200000,
 * });
 * const geometry = Cesium.CylinderOutlineGeometry.createGeometry(cylinder);
 * @param options - Object with the following properties:
 * @param options.length - The length of the cylinder.
 * @param options.topRadius - The radius of the top of the cylinder.
 * @param options.bottomRadius - The radius of the bottom of the cylinder.
 * @param [options.slices = 128] - The number of edges around the perimeter of the cylinder.
 * @param [options.numberOfVerticalLines = 16] - Number of lines to draw between the top and bottom surfaces of the cylinder.
 */
export class CylinderOutlineGeometry {
    constructor(options: {
        length: number;
        topRadius: number;
        bottomRadius: number;
        slices?: number;
        numberOfVerticalLines?: number;
    });
    /**
     * The number of elements used to pack the object into an array.
     */
    static packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: CylinderOutlineGeometry, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new CylinderOutlineGeometry instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: CylinderOutlineGeometry): CylinderOutlineGeometry;
    /**
     * Computes the geometric representation of an outline of a cylinder, including its vertices, indices, and a bounding sphere.
     * @param cylinderGeometry - A description of the cylinder outline.
     * @returns The computed vertices and indices.
     */
    static createGeometry(cylinderGeometry: CylinderOutlineGeometry): Geometry | undefined;
}

/**
 * A simple proxy that appends the desired resource as the sole query parameter
 * to the given proxy URL.
 * @param proxy - The proxy URL that will be used to requests all resources.
 */
export class DefaultProxy extends Proxy {
    constructor(proxy: string);
    /**
     * Get the final URL to use to request a given resource.
     * @param resource - The resource to request.
     * @returns proxied resource
     */
    getURL(resource: string): string;
}

/**
 * Constructs an exception object that is thrown due to a developer error, e.g., invalid argument,
 * argument out of range, etc.  This exception should only be thrown during development;
 * it usually indicates a bug in the calling code.  This exception should never be
 * caught; instead the calling code should strive not to generate it.
 * <br /><br />
 * On the other hand, a {@link RuntimeError} indicates an exception that may
 * be thrown at runtime, e.g., out of memory, that the calling code should be prepared
 * to catch.
 * @param [message] - The error message for this exception.
 */
export class DeveloperError extends Error {
    constructor(message?: string);
    /**
     * 'DeveloperError' indicating that this exception was thrown due to a developer error.
     */
    readonly name: string;
    /**
     * The explanation for why this exception was thrown.
     */
    readonly message: string;
    /**
     * The stack trace of this exception, if available.
     */
    readonly stack: string;
}

/**
 * Determines visibility based on the distance to the camera.
 * @example
 * // Make a billboard that is only visible when the distance to the camera is between 10 and 20 meters.
 * billboard.distanceDisplayCondition = new Cesium.DistanceDisplayCondition(10.0, 20.0);
 * @param [near = 0.0] - The smallest distance in the interval where the object is visible.
 * @param [far = Number.MAX_VALUE] - The largest distance in the interval where the object is visible.
 */
export class DistanceDisplayCondition {
    constructor(near?: number, far?: number);
    /**
     * The smallest distance in the interval where the object is visible.
     */
    near: number;
    /**
     * The largest distance in the interval where the object is visible.
     */
    far: number;
    /**
     * The number of elements used to pack the object into an array.
     */
    static packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: DistanceDisplayCondition, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new DistanceDisplayCondition instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: DistanceDisplayCondition): DistanceDisplayCondition;
    /**
     * Determines if two distance display conditions are equal.
     * @param left - A distance display condition.
     * @param right - Another distance display condition.
     * @returns Whether the two distance display conditions are equal.
     */
    static equals(left: DistanceDisplayCondition, right: DistanceDisplayCondition): boolean;
    /**
     * Duplicates a distance display condition instance.
     * @param [value] - The distance display condition to duplicate.
     * @param [result] - The result onto which to store the result.
     * @returns The duplicated instance.
     */
    static clone(value?: DistanceDisplayCondition, result?: DistanceDisplayCondition): DistanceDisplayCondition;
    /**
     * Duplicates this instance.
     * @param [result] - The result onto which to store the result.
     * @returns The duplicated instance.
     */
    clone(result?: DistanceDisplayCondition): DistanceDisplayCondition;
    /**
     * Determines if this distance display condition is equal to another.
     * @param other - Another distance display condition.
     * @returns Whether this distance display condition is equal to the other.
     */
    equals(other: DistanceDisplayCondition): boolean;
}

/**
 * Value and type information for per-instance geometry attribute that determines if the geometry instance has a distance display condition.
 * @example
 * const instance = new Cesium.GeometryInstance({
 *   geometry : new Cesium.BoxGeometry({
 *     vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL,
 *     minimum : new Cesium.Cartesian3(-250000.0, -250000.0, -250000.0),
 *     maximum : new Cesium.Cartesian3(250000.0, 250000.0, 250000.0)
 *   }),
 *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(
 *     Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 1000000.0), new Cesium.Matrix4()),
 *   id : 'box',
 *   attributes : {
 *     distanceDisplayCondition : new Cesium.DistanceDisplayConditionGeometryInstanceAttribute(100.0, 10000.0)
 *   }
 * });
 * @param [near = 0.0] - The near distance.
 * @param [far = Number.MAX_VALUE] - The far distance.
 */
export class DistanceDisplayConditionGeometryInstanceAttribute {
    constructor(near?: number, far?: number);
    /**
     * The values for the attributes stored in a typed array.
     */
    value: Float32Array;
    /**
     * The datatype of each component in the attribute, e.g., individual elements in
     * {@link DistanceDisplayConditionGeometryInstanceAttribute#value}.
     */
    readonly componentDatatype: ComponentDatatype;
    /**
     * The number of components in the attributes, i.e., {@link DistanceDisplayConditionGeometryInstanceAttribute#value}.
     */
    readonly componentsPerAttribute: number;
    /**
     * When <code>true</code> and <code>componentDatatype</code> is an integer format,
     * indicate that the components should be mapped to the range [0, 1] (unsigned)
     * or [-1, 1] (signed) when they are accessed as floating-point for rendering.
     */
    readonly normalize: boolean;
    /**
     * Creates a new {@link DistanceDisplayConditionGeometryInstanceAttribute} instance given the provided an enabled flag and {@link DistanceDisplayCondition}.
     * @example
     * const distanceDisplayCondition = new Cesium.DistanceDisplayCondition(100.0, 10000.0);
     * const instance = new Cesium.GeometryInstance({
     *   geometry : geometry,
     *   attributes : {
     *     distanceDisplayCondition : Cesium.DistanceDisplayConditionGeometryInstanceAttribute.fromDistanceDisplayCondition(distanceDisplayCondition)
     *   }
     * });
     * @param distanceDisplayCondition - The distance display condition.
     * @returns The new {@link DistanceDisplayConditionGeometryInstanceAttribute} instance.
     */
    static fromDistanceDisplayCondition(distanceDisplayCondition: DistanceDisplayCondition): DistanceDisplayConditionGeometryInstanceAttribute;
    /**
     * Converts a distance display condition to a typed array that can be used to assign a distance display condition attribute.
     * @example
     * const attributes = primitive.getGeometryInstanceAttributes('an id');
     * attributes.distanceDisplayCondition = Cesium.DistanceDisplayConditionGeometryInstanceAttribute.toValue(distanceDisplayCondition, attributes.distanceDisplayCondition);
     * @param distanceDisplayCondition - The distance display condition value.
     * @param [result] - The array to store the result in, if undefined a new instance will be created.
     * @returns The modified result parameter or a new instance if result was undefined.
     */
    static toValue(distanceDisplayCondition: DistanceDisplayCondition, result?: Float32Array): Float32Array;
}

/**
 * Easing functions for use with TweenCollection.  These function are from
 * {@link https://github.com/sole/tween.js/|Tween.js} and Robert Penner.  See the
 * {@link http://sole.github.io/tween.js/examples/03_graphs.html|Tween.js graphs for each function}.
 */
export namespace EasingFunction {
    /**
     * Linear easing.
     */
    const LINEAR_NONE: EasingFunction.Callback;
    /**
     * Quadratic in.
     */
    const QUADRATIC_IN: EasingFunction.Callback;
    /**
     * Quadratic out.
     */
    const QUADRATIC_OUT: EasingFunction.Callback;
    /**
     * Quadratic in then out.
     */
    const QUADRATIC_IN_OUT: EasingFunction.Callback;
    /**
     * Cubic in.
     */
    const CUBIC_IN: EasingFunction.Callback;
    /**
     * Cubic out.
     */
    const CUBIC_OUT: EasingFunction.Callback;
    /**
     * Cubic in then out.
     */
    const CUBIC_IN_OUT: EasingFunction.Callback;
    /**
     * Quartic in.
     */
    const QUARTIC_IN: EasingFunction.Callback;
    /**
     * Quartic out.
     */
    const QUARTIC_OUT: EasingFunction.Callback;
    /**
     * Quartic in then out.
     */
    const QUARTIC_IN_OUT: EasingFunction.Callback;
    /**
     * Quintic in.
     */
    const QUINTIC_IN: EasingFunction.Callback;
    /**
     * Quintic out.
     */
    const QUINTIC_OUT: EasingFunction.Callback;
    /**
     * Quintic in then out.
     */
    const QUINTIC_IN_OUT: EasingFunction.Callback;
    /**
     * Sinusoidal in.
     */
    const SINUSOIDAL_IN: EasingFunction.Callback;
    /**
     * Sinusoidal out.
     */
    const SINUSOIDAL_OUT: EasingFunction.Callback;
    /**
     * Sinusoidal in then out.
     */
    const SINUSOIDAL_IN_OUT: EasingFunction.Callback;
    /**
     * Exponential in.
     */
    const EXPONENTIAL_IN: EasingFunction.Callback;
    /**
     * Exponential out.
     */
    const EXPONENTIAL_OUT: EasingFunction.Callback;
    /**
     * Exponential in then out.
     */
    const EXPONENTIAL_IN_OUT: EasingFunction.Callback;
    /**
     * Circular in.
     */
    const CIRCULAR_IN: EasingFunction.Callback;
    /**
     * Circular out.
     */
    const CIRCULAR_OUT: EasingFunction.Callback;
    /**
     * Circular in then out.
     */
    const CIRCULAR_IN_OUT: EasingFunction.Callback;
    /**
     * Elastic in.
     */
    const ELASTIC_IN: EasingFunction.Callback;
    /**
     * Elastic out.
     */
    const ELASTIC_OUT: EasingFunction.Callback;
    /**
     * Elastic in then out.
     */
    const ELASTIC_IN_OUT: EasingFunction.Callback;
    /**
     * Back in.
     */
    const BACK_IN: EasingFunction.Callback;
    /**
     * Back out.
     */
    const BACK_OUT: EasingFunction.Callback;
    /**
     * Back in then out.
     */
    const BACK_IN_OUT: EasingFunction.Callback;
    /**
     * Bounce in.
     */
    const BOUNCE_IN: EasingFunction.Callback;
    /**
     * Bounce out.
     */
    const BOUNCE_OUT: EasingFunction.Callback;
    /**
     * Bounce in then out.
     */
    const BOUNCE_IN_OUT: EasingFunction.Callback;
    /**
     * Function interface for implementing a custom easing function.
     * @example
     * function quadraticIn(time) {
     *     return time * time;
     * }
     * @example
     * function quadraticOut(time) {
     *     return time * (2.0 - time);
     * }
     * @param time - The time in the range <code>[0, 1]</code>.
     */
    type Callback = (time: number) => number;
}

/**
 * A description of an ellipse on an ellipsoid. Ellipse geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.
 * @example
 * // Create an ellipse.
 * const ellipse = new Cesium.EllipseGeometry({
 *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),
 *   semiMajorAxis : 500000.0,
 *   semiMinorAxis : 300000.0,
 *   rotation : Cesium.Math.toRadians(60.0)
 * });
 * const geometry = Cesium.EllipseGeometry.createGeometry(ellipse);
 * @param options - Object with the following properties:
 * @param options.center - The ellipse's center point in the fixed frame.
 * @param options.semiMajorAxis - The length of the ellipse's semi-major axis in meters.
 * @param options.semiMinorAxis - The length of the ellipse's semi-minor axis in meters.
 * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid the ellipse will be on.
 * @param [options.height = 0.0] - The distance in meters between the ellipse and the ellipsoid surface.
 * @param [options.extrudedHeight] - The distance in meters between the ellipse's extruded face and the ellipsoid surface.
 * @param [options.rotation = 0.0] - The angle of rotation counter-clockwise from north.
 * @param [options.stRotation = 0.0] - The rotation of the texture coordinates counter-clockwise from north.
 * @param [options.granularity = Math.RADIANS_PER_DEGREE] - The angular distance between points on the ellipse in radians.
 * @param [options.vertexFormat = VertexFormat.DEFAULT] - The vertex attributes to be computed.
 */
export class EllipseGeometry {
    constructor(options: {
        center: Cartesian3;
        semiMajorAxis: number;
        semiMinorAxis: number;
        ellipsoid?: Ellipsoid;
        height?: number;
        extrudedHeight?: number;
        rotation?: number;
        stRotation?: number;
        granularity?: number;
        vertexFormat?: VertexFormat;
    });
    /**
     * The number of elements used to pack the object into an array.
     */
    static packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: EllipseGeometry, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new EllipseGeometry instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: EllipseGeometry): EllipseGeometry;
    /**
     * Computes the bounding rectangle based on the provided options
     * @param options - Object with the following properties:
     * @param options.center - The ellipse's center point in the fixed frame.
     * @param options.semiMajorAxis - The length of the ellipse's semi-major axis in meters.
     * @param options.semiMinorAxis - The length of the ellipse's semi-minor axis in meters.
     * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid the ellipse will be on.
     * @param [options.rotation = 0.0] - The angle of rotation counter-clockwise from north.
     * @param [options.granularity = Math.RADIANS_PER_DEGREE] - The angular distance between points on the ellipse in radians.
     * @param [result] - An object in which to store the result
     * @returns The result rectangle
     */
    static computeRectangle(options: {
        center: Cartesian3;
        semiMajorAxis: number;
        semiMinorAxis: number;
        ellipsoid?: Ellipsoid;
        rotation?: number;
        granularity?: number;
    }, result?: Rectangle): Rectangle;
    /**
     * Computes the geometric representation of a ellipse on an ellipsoid, including its vertices, indices, and a bounding sphere.
     * @param ellipseGeometry - A description of the ellipse.
     * @returns The computed vertices and indices.
     */
    static createGeometry(ellipseGeometry: EllipseGeometry): Geometry | undefined;
}

/**
 * A description of the outline of an ellipse on an ellipsoid.
 * @example
 * const ellipse = new Cesium.EllipseOutlineGeometry({
 *   center : Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883),
 *   semiMajorAxis : 500000.0,
 *   semiMinorAxis : 300000.0,
 *   rotation : Cesium.Math.toRadians(60.0)
 * });
 * const geometry = Cesium.EllipseOutlineGeometry.createGeometry(ellipse);
 * @param options - Object with the following properties:
 * @param options.center - The ellipse's center point in the fixed frame.
 * @param options.semiMajorAxis - The length of the ellipse's semi-major axis in meters.
 * @param options.semiMinorAxis - The length of the ellipse's semi-minor axis in meters.
 * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid the ellipse will be on.
 * @param [options.height = 0.0] - The distance in meters between the ellipse and the ellipsoid surface.
 * @param [options.extrudedHeight] - The distance in meters between the ellipse's extruded face and the ellipsoid surface.
 * @param [options.rotation = 0.0] - The angle from north (counter-clockwise) in radians.
 * @param [options.granularity = 0.02] - The angular distance between points on the ellipse in radians.
 * @param [options.numberOfVerticalLines = 16] - Number of lines to draw between the top and bottom surface of an extruded ellipse.
 */
export class EllipseOutlineGeometry {
    constructor(options: {
        center: Cartesian3;
        semiMajorAxis: number;
        semiMinorAxis: number;
        ellipsoid?: Ellipsoid;
        height?: number;
        extrudedHeight?: number;
        rotation?: number;
        granularity?: number;
        numberOfVerticalLines?: number;
    });
    /**
     * The number of elements used to pack the object into an array.
     */
    static packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: EllipseOutlineGeometry, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new EllipseOutlineGeometry instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: EllipseOutlineGeometry): EllipseOutlineGeometry;
    /**
     * Computes the geometric representation of an outline of an ellipse on an ellipsoid, including its vertices, indices, and a bounding sphere.
     * @param ellipseGeometry - A description of the ellipse.
     * @returns The computed vertices and indices.
     */
    static createGeometry(ellipseGeometry: EllipseOutlineGeometry): Geometry | undefined;
}

/**
 * A quadratic surface defined in Cartesian coordinates by the equation
 * <code>(x / a)^2 + (y / b)^2 + (z / c)^2 = 1</code>.  Primarily used
 * by Cesium to represent the shape of planetary bodies.
 *
 * Rather than constructing this object directly, one of the provided
 * constants is normally used.
 * @param [x = 0] - The radius in the x direction.
 * @param [y = 0] - The radius in the y direction.
 * @param [z = 0] - The radius in the z direction.
 */
export class Ellipsoid {
    constructor(x?: number, y?: number, z?: number);
    /**
     * Gets the radii of the ellipsoid.
     */
    readonly radii: Cartesian3;
    /**
     * Gets the squared radii of the ellipsoid.
     */
    readonly radiiSquared: Cartesian3;
    /**
     * Gets the radii of the ellipsoid raise to the fourth power.
     */
    readonly radiiToTheFourth: Cartesian3;
    /**
     * Gets one over the radii of the ellipsoid.
     */
    readonly oneOverRadii: Cartesian3;
    /**
     * Gets one over the squared radii of the ellipsoid.
     */
    readonly oneOverRadiiSquared: Cartesian3;
    /**
     * Gets the minimum radius of the ellipsoid.
     */
    readonly minimumRadius: number;
    /**
     * Gets the maximum radius of the ellipsoid.
     */
    readonly maximumRadius: number;
    /**
     * Duplicates an Ellipsoid instance.
     * @param ellipsoid - The ellipsoid to duplicate.
     * @param [result] - The object onto which to store the result, or undefined if a new
     *                    instance should be created.
     * @returns The cloned Ellipsoid. (Returns undefined if ellipsoid is undefined)
     */
    static clone(ellipsoid: Ellipsoid, result?: Ellipsoid): Ellipsoid;
    /**
     * Computes an Ellipsoid from a Cartesian specifying the radii in x, y, and z directions.
     * @param [cartesian = Cartesian3.ZERO] - The ellipsoid's radius in the x, y, and z directions.
     * @param [result] - The object onto which to store the result, or undefined if a new
     *                    instance should be created.
     * @returns A new Ellipsoid instance.
     */
    static fromCartesian3(cartesian?: Cartesian3, result?: Ellipsoid): Ellipsoid;
    /**
     * An Ellipsoid instance initialized to the WGS84 standard.
     */
    static readonly WGS84: Ellipsoid;
    /**
     * An Ellipsoid instance initialized to radii of (1.0, 1.0, 1.0).
     */
    static readonly UNIT_SPHERE: Ellipsoid;
    /**
     * An Ellipsoid instance initialized to a sphere with the lunar radius.
     */
    static readonly MOON: Ellipsoid;
    /**
     * Duplicates an Ellipsoid instance.
     * @param [result] - The object onto which to store the result, or undefined if a new
     *                    instance should be created.
     * @returns The cloned Ellipsoid.
     */
    clone(result?: Ellipsoid): Ellipsoid;
    /**
     * The number of elements used to pack the object into an array.
     */
    static packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: Ellipsoid, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new Ellipsoid instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: Ellipsoid): Ellipsoid;
    /**
     * Computes the unit vector directed from the center of this ellipsoid toward the provided Cartesian position.
     * @param cartesian - The Cartesian for which to to determine the geocentric normal.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Cartesian3 instance if none was provided.
     */
    geocentricSurfaceNormal(cartesian: Cartesian3, result?: Cartesian3): Cartesian3;
    /**
     * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.
     * @param cartographic - The cartographic position for which to to determine the geodetic normal.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Cartesian3 instance if none was provided.
     */
    geodeticSurfaceNormalCartographic(cartographic: Cartographic, result?: Cartesian3): Cartesian3;
    /**
     * Computes the normal of the plane tangent to the surface of the ellipsoid at the provided position.
     * @param cartesian - The Cartesian position for which to to determine the surface normal.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Cartesian3 instance if none was provided, or undefined if a normal cannot be found.
     */
    geodeticSurfaceNormal(cartesian: Cartesian3, result?: Cartesian3): Cartesian3;
    /**
     * Converts the provided cartographic to Cartesian representation.
     * @example
     * //Create a Cartographic and determine it's Cartesian representation on a WGS84 ellipsoid.
     * const position = new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 5000);
     * const cartesianPosition = Cesium.Ellipsoid.WGS84.cartographicToCartesian(position);
     * @param cartographic - The cartographic position.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Cartesian3 instance if none was provided.
     */
    cartographicToCartesian(cartographic: Cartographic, result?: Cartesian3): Cartesian3;
    /**
     * Converts the provided array of cartographics to an array of Cartesians.
     * @example
     * //Convert an array of Cartographics and determine their Cartesian representation on a WGS84 ellipsoid.
     * const positions = [new Cesium.Cartographic(Cesium.Math.toRadians(21), Cesium.Math.toRadians(78), 0),
     *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.321), Cesium.Math.toRadians(78.123), 100),
     *                  new Cesium.Cartographic(Cesium.Math.toRadians(21.645), Cesium.Math.toRadians(78.456), 250)];
     * const cartesianPositions = Cesium.Ellipsoid.WGS84.cartographicArrayToCartesianArray(positions);
     * @param cartographics - An array of cartographic positions.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Array instance if none was provided.
     */
    cartographicArrayToCartesianArray(cartographics: Cartographic[], result?: Cartesian3[]): Cartesian3[];
    /**
     * Converts the provided cartesian to cartographic representation.
     * The cartesian is undefined at the center of the ellipsoid.
     * @example
     * //Create a Cartesian and determine it's Cartographic representation on a WGS84 ellipsoid.
     * const position = new Cesium.Cartesian3(17832.12, 83234.52, 952313.73);
     * const cartographicPosition = Cesium.Ellipsoid.WGS84.cartesianToCartographic(position);
     * @param cartesian - The Cartesian position to convert to cartographic representation.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter, new Cartographic instance if none was provided, or undefined if the cartesian is at the center of the ellipsoid.
     */
    cartesianToCartographic(cartesian: Cartesian3, result?: Cartographic): Cartographic;
    /**
     * Converts the provided array of cartesians to an array of cartographics.
     * @example
     * //Create an array of Cartesians and determine their Cartographic representation on a WGS84 ellipsoid.
     * const positions = [new Cesium.Cartesian3(17832.12, 83234.52, 952313.73),
     *                  new Cesium.Cartesian3(17832.13, 83234.53, 952313.73),
     *                  new Cesium.Cartesian3(17832.14, 83234.54, 952313.73)]
     * const cartographicPositions = Cesium.Ellipsoid.WGS84.cartesianArrayToCartographicArray(positions);
     * @param cartesians - An array of Cartesian positions.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Array instance if none was provided.
     */
    cartesianArrayToCartographicArray(cartesians: Cartesian3[], result?: Cartographic[]): Cartographic[];
    /**
     * Scales the provided Cartesian position along the geodetic surface normal
     * so that it is on the surface of this ellipsoid.  If the position is
     * at the center of the ellipsoid, this function returns undefined.
     * @param cartesian - The Cartesian position to scale.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter, a new Cartesian3 instance if none was provided, or undefined if the position is at the center.
     */
    scaleToGeodeticSurface(cartesian: Cartesian3, result?: Cartesian3): Cartesian3;
    /**
     * Scales the provided Cartesian position along the geocentric surface normal
     * so that it is on the surface of this ellipsoid.
     * @param cartesian - The Cartesian position to scale.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Cartesian3 instance if none was provided.
     */
    scaleToGeocentricSurface(cartesian: Cartesian3, result?: Cartesian3): Cartesian3;
    /**
     * Transforms a Cartesian X, Y, Z position to the ellipsoid-scaled space by multiplying
     * its components by the result of {@link Ellipsoid#oneOverRadii}.
     * @param position - The position to transform.
     * @param [result] - The position to which to copy the result, or undefined to create and
     *        return a new instance.
     * @returns The position expressed in the scaled space.  The returned instance is the
     *          one passed as the result parameter if it is not undefined, or a new instance of it is.
     */
    transformPositionToScaledSpace(position: Cartesian3, result?: Cartesian3): Cartesian3;
    /**
     * Transforms a Cartesian X, Y, Z position from the ellipsoid-scaled space by multiplying
     * its components by the result of {@link Ellipsoid#radii}.
     * @param position - The position to transform.
     * @param [result] - The position to which to copy the result, or undefined to create and
     *        return a new instance.
     * @returns The position expressed in the unscaled space.  The returned instance is the
     *          one passed as the result parameter if it is not undefined, or a new instance of it is.
     */
    transformPositionFromScaledSpace(position: Cartesian3, result?: Cartesian3): Cartesian3;
    /**
     * Compares this Ellipsoid against the provided Ellipsoid componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [right] - The other Ellipsoid.
     * @returns <code>true</code> if they are equal, <code>false</code> otherwise.
     */
    equals(right?: Ellipsoid): boolean;
    /**
     * Creates a string representing this Ellipsoid in the format '(radii.x, radii.y, radii.z)'.
     * @returns A string representing this ellipsoid in the format '(radii.x, radii.y, radii.z)'.
     */
    toString(): string;
    /**
     * Computes a point which is the intersection of the surface normal with the z-axis.
     * @param position - the position. must be on the surface of the ellipsoid.
     * @param [buffer = 0.0] - A buffer to subtract from the ellipsoid size when checking if the point is inside the ellipsoid.
     *                                In earth case, with common earth datums, there is no need for this buffer since the intersection point is always (relatively) very close to the center.
     *                                In WGS84 datum, intersection point is at max z = +-42841.31151331382 (0.673% of z-axis).
     *                                Intersection point could be outside the ellipsoid if the ratio of MajorAxis / AxisOfRotation is bigger than the square root of 2
     * @param [result] - The cartesian to which to copy the result, or undefined to create and
     *        return a new instance.
     * @returns the intersection point if it's inside the ellipsoid, undefined otherwise
     */
    getSurfaceNormalIntersectionWithZAxis(position: Cartesian3, buffer?: number, result?: Cartesian3): Cartesian3 | undefined;
    /**
     * Computes an approximation of the surface area of a rectangle on the surface of an ellipsoid using
     * Gauss-Legendre 10th order quadrature.
     * @param rectangle - The rectangle used for computing the surface area.
     * @returns The approximate area of the rectangle on the surface of this ellipsoid.
     */
    surfaceArea(rectangle: Rectangle): number;
}

/**
 * Initializes a geodesic on the ellipsoid connecting the two provided planetodetic points.
 * @param [start] - The initial planetodetic point on the path.
 * @param [end] - The final planetodetic point on the path.
 * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid on which the geodesic lies.
 */
export class EllipsoidGeodesic {
    constructor(start?: Cartographic, end?: Cartographic, ellipsoid?: Ellipsoid);
    /**
     * Gets the ellipsoid.
     */
    readonly ellipsoid: Ellipsoid;
    /**
     * Gets the surface distance between the start and end point
     */
    readonly surfaceDistance: number;
    /**
     * Gets the initial planetodetic point on the path.
     */
    readonly start: Cartographic;
    /**
     * Gets the final planetodetic point on the path.
     */
    readonly end: Cartographic;
    /**
     * Gets the heading at the initial point.
     */
    readonly startHeading: number;
    /**
     * Gets the heading at the final point.
     */
    readonly endHeading: number;
    /**
     * Sets the start and end points of the geodesic
     * @param start - The initial planetodetic point on the path.
     * @param end - The final planetodetic point on the path.
     */
    setEndPoints(start: Cartographic, end: Cartographic): void;
    /**
     * Provides the location of a point at the indicated portion along the geodesic.
     * @param fraction - The portion of the distance between the initial and final points.
     * @param [result] - The object in which to store the result.
     * @returns The location of the point along the geodesic.
     */
    interpolateUsingFraction(fraction: number, result?: Cartographic): Cartographic;
    /**
     * Provides the location of a point at the indicated distance along the geodesic.
     * @param distance - The distance from the inital point to the point of interest along the geodesic
     * @param [result] - The object in which to store the result.
     * @returns The location of the point along the geodesic.
     */
    interpolateUsingSurfaceDistance(distance: number, result?: Cartographic): Cartographic;
}

/**
 * A description of an ellipsoid centered at the origin.
 * @example
 * const ellipsoid = new Cesium.EllipsoidGeometry({
 *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,
 *   radii : new Cesium.Cartesian3(1000000.0, 500000.0, 500000.0)
 * });
 * const geometry = Cesium.EllipsoidGeometry.createGeometry(ellipsoid);
 * @param [options] - Object with the following properties:
 * @param [options.radii = Cartesian3(1.0, 1.0, 1.0)] - The radii of the ellipsoid in the x, y, and z directions.
 * @param [options.innerRadii = options.radii] - The inner radii of the ellipsoid in the x, y, and z directions.
 * @param [options.minimumClock = 0.0] - The minimum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.
 * @param [options.maximumClock = 2*PI] - The maximum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.
 * @param [options.minimumCone = 0.0] - The minimum angle measured from the positive z-axis and toward the negative z-axis.
 * @param [options.maximumCone = PI] - The maximum angle measured from the positive z-axis and toward the negative z-axis.
 * @param [options.stackPartitions = 64] - The number of times to partition the ellipsoid into stacks.
 * @param [options.slicePartitions = 64] - The number of times to partition the ellipsoid into radial slices.
 * @param [options.vertexFormat = VertexFormat.DEFAULT] - The vertex attributes to be computed.
 */
export class EllipsoidGeometry {
    constructor(options?: {
        radii?: Cartesian3;
        innerRadii?: Cartesian3;
        minimumClock?: number;
        maximumClock?: number;
        minimumCone?: number;
        maximumCone?: number;
        stackPartitions?: number;
        slicePartitions?: number;
        vertexFormat?: VertexFormat;
    });
    /**
     * The number of elements used to pack the object into an array.
     */
    static packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: EllipsoidGeometry, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new EllipsoidGeometry instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: EllipsoidGeometry): EllipsoidGeometry;
    /**
     * Computes the geometric representation of an ellipsoid, including its vertices, indices, and a bounding sphere.
     * @param ellipsoidGeometry - A description of the ellipsoid.
     * @returns The computed vertices and indices.
     */
    static createGeometry(ellipsoidGeometry: EllipsoidGeometry): Geometry | undefined;
}

/**
 * A description of the outline of an ellipsoid centered at the origin.
 * @example
 * const ellipsoid = new Cesium.EllipsoidOutlineGeometry({
 *   radii : new Cesium.Cartesian3(1000000.0, 500000.0, 500000.0),
 *   stackPartitions: 6,
 *   slicePartitions: 5
 * });
 * const geometry = Cesium.EllipsoidOutlineGeometry.createGeometry(ellipsoid);
 * @param [options] - Object with the following properties:
 * @param [options.radii = Cartesian3(1.0, 1.0, 1.0)] - The radii of the ellipsoid in the x, y, and z directions.
 * @param [options.innerRadii = options.radii] - The inner radii of the ellipsoid in the x, y, and z directions.
 * @param [options.minimumClock = 0.0] - The minimum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.
 * @param [options.maximumClock = 2*PI] - The maximum angle lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.
 * @param [options.minimumCone = 0.0] - The minimum angle measured from the positive z-axis and toward the negative z-axis.
 * @param [options.maximumCone = PI] - The maximum angle measured from the positive z-axis and toward the negative z-axis.
 * @param [options.stackPartitions = 10] - The count of stacks for the ellipsoid (1 greater than the number of parallel lines).
 * @param [options.slicePartitions = 8] - The count of slices for the ellipsoid (Equal to the number of radial lines).
 * @param [options.subdivisions = 128] - The number of points per line, determining the granularity of the curvature.
 */
export class EllipsoidOutlineGeometry {
    constructor(options?: {
        radii?: Cartesian3;
        innerRadii?: Cartesian3;
        minimumClock?: number;
        maximumClock?: number;
        minimumCone?: number;
        maximumCone?: number;
        stackPartitions?: number;
        slicePartitions?: number;
        subdivisions?: number;
    });
    /**
     * The number of elements used to pack the object into an array.
     */
    static packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: EllipsoidOutlineGeometry, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new EllipsoidOutlineGeometry instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: EllipsoidOutlineGeometry): EllipsoidOutlineGeometry;
    /**
     * Computes the geometric representation of an outline of an ellipsoid, including its vertices, indices, and a bounding sphere.
     * @param ellipsoidGeometry - A description of the ellipsoid outline.
     * @returns The computed vertices and indices.
     */
    static createGeometry(ellipsoidGeometry: EllipsoidOutlineGeometry): Geometry | undefined;
}

/**
 * Initializes a rhumb line on the ellipsoid connecting the two provided planetodetic points.
 * @param [start] - The initial planetodetic point on the path.
 * @param [end] - The final planetodetic point on the path.
 * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid on which the rhumb line lies.
 */
export class EllipsoidRhumbLine {
    constructor(start?: Cartographic, end?: Cartographic, ellipsoid?: Ellipsoid);
    /**
     * Gets the ellipsoid.
     */
    readonly ellipsoid: Ellipsoid;
    /**
     * Gets the surface distance between the start and end point
     */
    readonly surfaceDistance: number;
    /**
     * Gets the initial planetodetic point on the path.
     */
    readonly start: Cartographic;
    /**
     * Gets the final planetodetic point on the path.
     */
    readonly end: Cartographic;
    /**
     * Gets the heading from the start point to the end point.
     */
    readonly heading: number;
    /**
     * Create a rhumb line using an initial position with a heading and distance.
     * @param start - The initial planetodetic point on the path.
     * @param heading - The heading in radians.
     * @param distance - The rhumb line distance between the start and end point.
     * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid on which the rhumb line lies.
     * @param [result] - The object in which to store the result.
     * @returns The EllipsoidRhumbLine object.
     */
    static fromStartHeadingDistance(start: Cartographic, heading: number, distance: number, ellipsoid?: Ellipsoid, result?: EllipsoidRhumbLine): EllipsoidRhumbLine;
    /**
     * Sets the start and end points of the rhumb line.
     * @param start - The initial planetodetic point on the path.
     * @param end - The final planetodetic point on the path.
     */
    setEndPoints(start: Cartographic, end: Cartographic): void;
    /**
     * Provides the location of a point at the indicated portion along the rhumb line.
     * @param fraction - The portion of the distance between the initial and final points.
     * @param [result] - The object in which to store the result.
     * @returns The location of the point along the rhumb line.
     */
    interpolateUsingFraction(fraction: number, result?: Cartographic): Cartographic;
    /**
     * Provides the location of a point at the indicated distance along the rhumb line.
     * @param distance - The distance from the inital point to the point of interest along the rhumbLine.
     * @param [result] - The object in which to store the result.
     * @returns The location of the point along the rhumb line.
     */
    interpolateUsingSurfaceDistance(distance: number, result?: Cartographic): Cartographic;
    /**
     * Provides the location of a point at the indicated longitude along the rhumb line.
     * If the longitude is outside the range of start and end points, the first intersection with the longitude from the start point in the direction of the heading is returned. This follows the spiral property of a rhumb line.
     * @param intersectionLongitude - The longitude, in radians, at which to find the intersection point from the starting point using the heading.
     * @param [result] - The object in which to store the result.
     * @returns The location of the intersection point along the rhumb line, undefined if there is no intersection or infinite intersections.
     */
    findIntersectionWithLongitude(intersectionLongitude: number, result?: Cartographic): Cartographic;
    /**
     * Provides the location of a point at the indicated latitude along the rhumb line.
     * If the latitude is outside the range of start and end points, the first intersection with the latitude from that start point in the direction of the heading is returned. This follows the spiral property of a rhumb line.
     * @param intersectionLatitude - The latitude, in radians, at which to find the intersection point from the starting point using the heading.
     * @param [result] - The object in which to store the result.
     * @returns The location of the intersection point along the rhumb line, undefined if there is no intersection or infinite intersections.
     */
    findIntersectionWithLatitude(intersectionLatitude: number, result?: Cartographic): Cartographic;
}

/**
 * A plane tangent to the provided ellipsoid at the provided origin.
 * If origin is not on the surface of the ellipsoid, it's surface projection will be used.
 * If origin is at the center of the ellipsoid, an exception will be thrown.
 * @param origin - The point on the surface of the ellipsoid where the tangent plane touches.
 * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid to use.
 */
export class EllipsoidTangentPlane {
    constructor(origin: Cartesian3, ellipsoid?: Ellipsoid);
    /**
     * Gets the ellipsoid.
     */
    ellipsoid: Ellipsoid;
    /**
     * Gets the origin.
     */
    origin: Cartesian3;
    /**
     * Gets the plane which is tangent to the ellipsoid.
     */
    readonly plane: Plane;
    /**
     * Gets the local X-axis (east) of the tangent plane.
     */
    readonly xAxis: Cartesian3;
    /**
     * Gets the local Y-axis (north) of the tangent plane.
     */
    readonly yAxis: Cartesian3;
    /**
     * Gets the local Z-axis (up) of the tangent plane.
     */
    readonly zAxis: Cartesian3;
    /**
     * Creates a new instance from the provided ellipsoid and the center
     * point of the provided Cartesians.
     * @param cartesians - The list of positions surrounding the center point.
     * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid to use.
     * @returns The new instance of EllipsoidTangentPlane.
     */
    static fromPoints(cartesians: Cartesian3[], ellipsoid?: Ellipsoid): EllipsoidTangentPlane;
    /**
     * Computes the projection of the provided 3D position onto the 2D plane, radially outward from the {@link EllipsoidTangentPlane.ellipsoid} coordinate system origin.
     * @param cartesian - The point to project.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Cartesian2 instance if none was provided. Undefined if there is no intersection point
     */
    projectPointOntoPlane(cartesian: Cartesian3, result?: Cartesian2): Cartesian2;
    /**
     * Computes the projection of the provided 3D positions onto the 2D plane (where possible), radially outward from the global origin.
     * The resulting array may be shorter than the input array - if a single projection is impossible it will not be included.
     * @param cartesians - The array of points to project.
     * @param [result] - The array of Cartesian2 instances onto which to store results.
     * @returns The modified result parameter or a new array of Cartesian2 instances if none was provided.
     */
    projectPointsOntoPlane(cartesians: Cartesian3[], result?: Cartesian2[]): Cartesian2[];
    /**
     * Computes the projection of the provided 3D position onto the 2D plane, along the plane normal.
     * @param cartesian - The point to project.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Cartesian2 instance if none was provided.
     */
    projectPointToNearestOnPlane(cartesian: Cartesian3, result?: Cartesian2): Cartesian2;
    /**
     * Computes the projection of the provided 3D positions onto the 2D plane, along the plane normal.
     * @param cartesians - The array of points to project.
     * @param [result] - The array of Cartesian2 instances onto which to store results.
     * @returns The modified result parameter or a new array of Cartesian2 instances if none was provided. This will have the same length as <code>cartesians</code>.
     */
    projectPointsToNearestOnPlane(cartesians: Cartesian3[], result?: Cartesian2[]): Cartesian2[];
    /**
     * Computes the projection of the provided 2D position onto the 3D ellipsoid.
     * @param cartesian - The points to project.
     * @param [result] - The Cartesian3 instance to store result.
     * @returns The modified result parameter or a new Cartesian3 instance if none was provided.
     */
    projectPointOntoEllipsoid(cartesian: Cartesian2, result?: Cartesian3): Cartesian3;
    /**
     * Computes the projection of the provided 2D positions onto the 3D ellipsoid.
     * @param cartesians - The array of points to project.
     * @param [result] - The array of Cartesian3 instances onto which to store results.
     * @returns The modified result parameter or a new array of Cartesian3 instances if none was provided.
     */
    projectPointsOntoEllipsoid(cartesians: Cartesian2[], result?: Cartesian3[]): Cartesian3[];
}

/**
 * A very simple {@link TerrainProvider} that produces geometry by tessellating an ellipsoidal
 * surface.
 * @param [options] - Object with the following properties:
 * @param [options.tilingScheme] - The tiling scheme specifying how the ellipsoidal
 * surface is broken into tiles.  If this parameter is not provided, a {@link GeographicTilingScheme}
 * is used.
 * @param [options.ellipsoid] - The ellipsoid.  If the tilingScheme is specified,
 * this parameter is ignored and the tiling scheme's ellipsoid is used instead. If neither
 * parameter is specified, the WGS84 ellipsoid is used.
 */
export class EllipsoidTerrainProvider {
    constructor(options?: {
        tilingScheme?: TilingScheme;
        ellipsoid?: Ellipsoid;
    });
    /**
     * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing
     * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
     * are passed an instance of {@link TileProviderError}.
     */
    readonly errorEvent: Event;
    /**
     * Gets the credit to display when this terrain provider is active.  Typically this is used to credit
     * the source of the terrain.
     */
    readonly credit: Credit;
    /**
     * Gets the tiling scheme used by this provider.
     */
    readonly tilingScheme: GeographicTilingScheme;
    /**
     * Gets a value indicating whether or not the provider includes a water mask.  The water mask
     * indicates which areas of the globe are water rather than land, so they can be rendered
     * as a reflective surface with animated waves.
     */
    readonly hasWaterMask: boolean;
    /**
     * Gets a value indicating whether or not the requested tiles include vertex normals.
     */
    readonly hasVertexNormals: boolean;
    /**
     * Gets an object that can be used to determine availability of terrain from this provider, such as
     * at points and in rectangles. This property may be undefined if availability
     * information is not available.
     */
    readonly availability: TileAvailability;
    /**
     * Requests the geometry for a given tile. The result includes terrain
     * data and indicates that all child tiles are available.
     * @param x - The X coordinate of the tile for which to request geometry.
     * @param y - The Y coordinate of the tile for which to request geometry.
     * @param level - The level of the tile for which to request geometry.
     * @param [request] - The request object. Intended for internal use only.
     * @returns A promise for the requested geometry.  If this method
     *          returns undefined instead of a promise, it is an indication that too many requests are already
     *          pending and the request will be retried later.
     */
    requestTileGeometry(x: number, y: number, level: number, request?: Request): Promise<TerrainData> | undefined;
    /**
     * Gets the maximum geometric error allowed in a tile at a given level.
     * @param level - The tile level for which to get the maximum geometric error.
     * @returns The maximum geometric error.
     */
    getLevelMaximumGeometricError(level: number): number;
    /**
     * Determines whether data for a tile is available to be loaded.
     * @param x - The X coordinate of the tile for which to request geometry.
     * @param y - The Y coordinate of the tile for which to request geometry.
     * @param level - The level of the tile for which to request geometry.
     * @returns Undefined if not supported, otherwise true or false.
     */
    getTileDataAvailable(x: number, y: number, level: number): boolean | undefined;
    /**
     * Makes sure we load availability data for a tile
     * @param x - The X coordinate of the tile for which to request geometry.
     * @param y - The Y coordinate of the tile for which to request geometry.
     * @param level - The level of the tile for which to request geometry.
     * @returns This provider does not support loading availability.
     */
    loadTileDataAvailability(x: number, y: number, level: number): undefined;
}

/**
 * A generic utility class for managing subscribers for a particular event.
 * This class is usually instantiated inside of a container class and
 * exposed as a property for others to subscribe to.
 * @example
 * MyObject.prototype.myListener = function(arg1, arg2) {
 *     this.myArg1Copy = arg1;
 *     this.myArg2Copy = arg2;
 * }
 *
 * const myObjectInstance = new MyObject();
 * const evt = new Cesium.Event();
 * evt.addEventListener(MyObject.prototype.myListener, myObjectInstance);
 * evt.raiseEvent('1', '2');
 * evt.removeEventListener(MyObject.prototype.myListener);
 */
export class Event<Listener extends (...args: any[]) => void = (...args: any[]) => void> {
    constructor();
    /**
     * The number of listeners currently subscribed to the event.
     */
    readonly numberOfListeners: number;
    /**
     * Registers a callback function to be executed whenever the event is raised.
     * An optional scope can be provided to serve as the <code>this</code> pointer
     * in which the function will execute.
     * @param listener - The function to be executed when the event is raised.
     * @param [scope] - An optional object scope to serve as the <code>this</code>
     *        pointer in which the listener function will execute.
     * @returns A function that will remove this event listener when invoked.
     */
    addEventListener(listener: Listener, scope?: any): Event.RemoveCallback;
    /**
     * Unregisters a previously registered callback.
     * @param listener - The function to be unregistered.
     * @param [scope] - The scope that was originally passed to addEventListener.
     * @returns <code>true</code> if the listener was removed; <code>false</code> if the listener and scope are not registered with the event.
     */
    removeEventListener(listener: Listener, scope?: any): boolean;
    /**
     * Raises the event by calling each registered listener with all supplied arguments.
     * @param arguments - This method takes any number of parameters and passes them through to the listener functions.
     */
    raiseEvent(...arguments: Parameters<Listener>[]): void;
}

export namespace Event {
    /**
     * A function that removes a listener.
     */
    type RemoveCallback = () => void;
}

/**
 * A convenience object that simplifies the common pattern of attaching event listeners
 * to several events, then removing all those listeners at once later, for example, in
 * a destroy method.
 * @example
 * const helper = new Cesium.EventHelper();
 *
 * helper.add(someObject.event, listener1, this);
 * helper.add(otherObject.event, listener2, this);
 *
 * // later...
 * helper.removeAll();
 */
export class EventHelper {
    constructor();
    /**
     * Adds a listener to an event, and records the registration to be cleaned up later.
     * @param event - The event to attach to.
     * @param listener - The function to be executed when the event is raised.
     * @param [scope] - An optional object scope to serve as the <code>this</code>
     *        pointer in which the listener function will execute.
     * @returns A function that will remove this event listener when invoked.
     */
    add(event: Event, listener: (...params: any[]) => any, scope?: any): EventHelper.RemoveCallback;
    /**
     * Unregisters all previously added listeners.
     */
    removeAll(): void;
}

export namespace EventHelper {
    /**
     * A function that removes a listener.
     */
    type RemoveCallback = () => void;
}

/**
 * Constants to determine how an interpolated value is extrapolated
 * when querying outside the bounds of available data.
 */
export enum ExtrapolationType {
    /**
     * No extrapolation occurs.
     */
    NONE = 0,
    /**
     * The first or last value is used when outside the range of sample data.
     */
    HOLD = 1,
    /**
     * The value is extrapolated.
     */
    EXTRAPOLATE = 2
}

/**
 * A set of functions to detect whether the current browser supports
 * various features.
 */
export namespace FeatureDetection {
    /**
     * Detects whether the current browser supports Basis Universal textures and the web assembly modules needed to transcode them.
     * @returns true if the browser supports web assembly modules and the scene supports Basis Universal textures, false if not.
     */
    function supportsBasis(scene: Scene): boolean;
    /**
     * Detects whether the current browser supports the full screen standard.
     * @returns true if the browser supports the full screen standard, false if not.
     */
    function supportsFullscreen(): boolean;
    /**
     * Detects whether the current browser supports typed arrays.
     * @returns true if the browser supports typed arrays, false if not.
     */
    function supportsTypedArrays(): boolean;
    /**
     * Detects whether the current browser supports BigInt64Array typed arrays.
     * @returns true if the browser supports BigInt64Array typed arrays, false if not.
     */
    function supportsBigInt64Array(): boolean;
    /**
     * Detects whether the current browser supports BigUint64Array typed arrays.
     * @returns true if the browser supports BigUint64Array typed arrays, false if not.
     */
    function supportsBigUint64Array(): boolean;
    /**
     * Detects whether the current browser supports BigInt.
     * @returns true if the browser supports BigInt, false if not.
     */
    function supportsBigInt(): boolean;
    /**
     * Detects whether the current browser supports Web Workers.
     * @returns true if the browsers supports Web Workers, false if not.
     */
    function supportsWebWorkers(): boolean;
    /**
     * Detects whether the current browser supports Web Assembly.
     * @returns true if the browsers supports Web Assembly, false if not.
     */
    function supportsWebAssembly(): boolean;
    /**
     * Detects whether the current browser supports a WebGL2 rendering context for the specified scene.
     * @param scene - the Cesium scene specifying the rendering context
     * @returns true if the browser supports a WebGL2 rendering context, false if not.
     */
    function supportsWebgl2(scene: Scene): boolean;
    /**
     * Detects whether the current browser supports ECMAScript modules in web workers.
     * @returns true if the browser supports ECMAScript modules in web workers.
     */
    function supportsEsmWebWorkers(): boolean;
}

/**
 * Describes a frustum at the given the origin and orientation.
 * @param options - Object with the following properties:
 * @param options.frustum - The frustum.
 * @param options.origin - The origin of the frustum.
 * @param options.orientation - The orientation of the frustum.
 * @param [options.vertexFormat = VertexFormat.DEFAULT] - The vertex attributes to be computed.
 */
export class FrustumGeometry {
    constructor(options: {
        frustum: PerspectiveFrustum | OrthographicFrustum;
        origin: Cartesian3;
        orientation: Quaternion;
        vertexFormat?: VertexFormat;
    });
    /**
     * The number of elements used to pack the object into an array.
     */
    packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: FrustumGeometry, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     */
    static unpack(array: number[], startingIndex?: number, result?: FrustumGeometry): void;
    /**
     * Computes the geometric representation of a frustum, including its vertices, indices, and a bounding sphere.
     * @param frustumGeometry - A description of the frustum.
     * @returns The computed vertices and indices.
     */
    static createGeometry(frustumGeometry: FrustumGeometry): Geometry | undefined;
}

/**
 * A description of the outline of a frustum with the given the origin and orientation.
 * @param options - Object with the following properties:
 * @param options.frustum - The frustum.
 * @param options.origin - The origin of the frustum.
 * @param options.orientation - The orientation of the frustum.
 */
export class FrustumOutlineGeometry {
    constructor(options: {
        frustum: PerspectiveFrustum | OrthographicFrustum;
        origin: Cartesian3;
        orientation: Quaternion;
    });
    /**
     * The number of elements used to pack the object into an array.
     */
    packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: FrustumOutlineGeometry, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     */
    static unpack(array: number[], startingIndex?: number, result?: FrustumOutlineGeometry): void;
    /**
     * Computes the geometric representation of a frustum outline, including its vertices, indices, and a bounding sphere.
     * @param frustumGeometry - A description of the frustum.
     * @returns The computed vertices and indices.
     */
    static createGeometry(frustumGeometry: FrustumOutlineGeometry): Geometry | undefined;
}

/**
 * Browser-independent functions for working with the standard fullscreen API.
 */
export namespace Fullscreen {
    /**
     * The element that is currently fullscreen, if any.  To simply check if the
     * browser is in fullscreen mode or not, use {@link Fullscreen#fullscreen}.
     */
    const element: any;
    /**
     * The name of the event on the document that is fired when fullscreen is
     * entered or exited.  This event name is intended for use with addEventListener.
     * In your event handler, to determine if the browser is in fullscreen mode or not,
     * use {@link Fullscreen#fullscreen}.
     */
    const changeEventName: string;
    /**
     * The name of the event that is fired when a fullscreen error
     * occurs.  This event name is intended for use with addEventListener.
     */
    const errorEventName: string;
    /**
     * Determine whether the browser will allow an element to be made fullscreen, or not.
     * For example, by default, iframes cannot go fullscreen unless the containing page
     * adds an "allowfullscreen" attribute (or prefixed equivalent).
     */
    const enabled: boolean;
    /**
     * Determines if the browser is currently in fullscreen mode.
     */
    const fullscreen: boolean;
    /**
     * Detects whether the browser supports the standard fullscreen API.
     * @returns <code>true</code> if the browser supports the standard fullscreen API,
     * <code>false</code> otherwise.
     */
    function supportsFullscreen(): boolean;
    /**
     * Asynchronously requests the browser to enter fullscreen mode on the given element.
     * If fullscreen mode is not supported by the browser, does nothing.
     * @example
     * // Put the entire page into fullscreen.
     * Cesium.Fullscreen.requestFullscreen(document.body)
     *
     * // Place only the Cesium canvas into fullscreen.
     * Cesium.Fullscreen.requestFullscreen(scene.canvas)
     * @param element - The HTML element which will be placed into fullscreen mode.
     * @param [vrDevice] - The HMDVRDevice device.
     */
    function requestFullscreen(element: any, vrDevice?: any): void;
    /**
     * Asynchronously exits fullscreen mode.  If the browser is not currently
     * in fullscreen, or if fullscreen mode is not supported by the browser, does nothing.
     */
    function exitFullscreen(): void;
}

/**
 * The type of geocoding to be performed by a {@link GeocoderService}.
 */
export enum GeocodeType {
    /**
     * Perform a search where the input is considered complete.
     */
    SEARCH = 0,
    /**
     * Perform an auto-complete using partial input, typically
     * reserved for providing possible results as a user is typing.
     */
    AUTOCOMPLETE = 1
}

export namespace GeocoderService {
    /**
     * displayName - The display name for a location
     * destination - The bounding box for a location
     */
    type Result = {
        displayName: string;
        destination: Rectangle | Cartesian3;
        attributions?: object[];
    };
}

/**
 * Provides geocoding through an external service. This type describes an interface and
 * is not intended to be used.
 */
export class GeocoderService {
    constructor();
    /**
     * Gets the credit to display after a geocode is performed. Typically this is used to credit
     * the geocoder service.
     */
    readonly credit: Credit | undefined;
    /**
     * Parses credits from the geocoder result attributions, if present.
     * @param geocoderResult - The geocoder result
     * @returns A list of credits if present in the result, otherwise undefined
     */
    static getCreditsFromResult(geocoderResult: GeocoderService.Result): Credit[] | undefined;
    /**
     * @param query - The query to be sent to the geocoder service
     * @param [type = GeocodeType.SEARCH] - The type of geocode to perform.
     */
    geocode(query: string, type?: GeocodeType): Promise<GeocoderService.Result[]>;
}

/**
 * A simple map projection where longitude and latitude are linearly mapped to X and Y by multiplying
 * them by the {@link Ellipsoid#maximumRadius}.  This projection
 * is commonly known as geographic, equirectangular, equidistant cylindrical, or plate carrée.  It
 * is also known as EPSG:4326.
 * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid.
 */
export class GeographicProjection {
    constructor(ellipsoid?: Ellipsoid);
    /**
     * Gets the {@link Ellipsoid}.
     */
    readonly ellipsoid: Ellipsoid;
    /**
     * Projects a set of {@link Cartographic} coordinates, in radians, to map coordinates, in meters.
     * X and Y are the longitude and latitude, respectively, multiplied by the maximum radius of the
     * ellipsoid.  Z is the unmodified height.
     * @param cartographic - The coordinates to project.
     * @param [result] - An instance into which to copy the result.  If this parameter is
     *        undefined, a new instance is created and returned.
     * @returns The projected coordinates.  If the result parameter is not undefined, the
     *          coordinates are copied there and that instance is returned.  Otherwise, a new instance is
     *          created and returned.
     */
    project(cartographic: Cartographic, result?: Cartesian3): Cartesian3;
    /**
     * Unprojects a set of projected {@link Cartesian3} coordinates, in meters, to {@link Cartographic}
     * coordinates, in radians.  Longitude and Latitude are the X and Y coordinates, respectively,
     * divided by the maximum radius of the ellipsoid.  Height is the unmodified Z coordinate.
     * @param cartesian - The Cartesian position to unproject with height (z) in meters.
     * @param [result] - An instance into which to copy the result.  If this parameter is
     *        undefined, a new instance is created and returned.
     * @returns The unprojected coordinates.  If the result parameter is not undefined, the
     *          coordinates are copied there and that instance is returned.  Otherwise, a new instance is
     *          created and returned.
     */
    unproject(cartesian: Cartesian3, result?: Cartographic): Cartographic;
}

/**
 * A tiling scheme for geometry referenced to a simple {@link GeographicProjection} where
 * longitude and latitude are directly mapped to X and Y.  This projection is commonly
 * known as geographic, equirectangular, equidistant cylindrical, or plate carrée.
 * @param [options] - Object with the following properties:
 * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid whose surface is being tiled. Defaults to
 * the WGS84 ellipsoid.
 * @param [options.rectangle = Rectangle.MAX_VALUE] - The rectangle, in radians, covered by the tiling scheme.
 * @param [options.numberOfLevelZeroTilesX = 2] - The number of tiles in the X direction at level zero of
 * the tile tree.
 * @param [options.numberOfLevelZeroTilesY = 1] - The number of tiles in the Y direction at level zero of
 * the tile tree.
 */
export class GeographicTilingScheme {
    constructor(options?: {
        ellipsoid?: Ellipsoid;
        rectangle?: Rectangle;
        numberOfLevelZeroTilesX?: number;
        numberOfLevelZeroTilesY?: number;
    });
    /**
     * Gets the ellipsoid that is tiled by this tiling scheme.
     */
    ellipsoid: Ellipsoid;
    /**
     * Gets the rectangle, in radians, covered by this tiling scheme.
     */
    rectangle: Rectangle;
    /**
     * Gets the map projection used by this tiling scheme.
     */
    projection: MapProjection;
    /**
     * Gets the total number of tiles in the X direction at a specified level-of-detail.
     * @param level - The level-of-detail.
     * @returns The number of tiles in the X direction at the given level.
     */
    getNumberOfXTilesAtLevel(level: number): number;
    /**
     * Gets the total number of tiles in the Y direction at a specified level-of-detail.
     * @param level - The level-of-detail.
     * @returns The number of tiles in the Y direction at the given level.
     */
    getNumberOfYTilesAtLevel(level: number): number;
    /**
     * Transforms a rectangle specified in geodetic radians to the native coordinate system
     * of this tiling scheme.
     * @param rectangle - The rectangle to transform.
     * @param [result] - The instance to which to copy the result, or undefined if a new instance
     *        should be created.
     * @returns The specified 'result', or a new object containing the native rectangle if 'result'
     *          is undefined.
     */
    rectangleToNativeRectangle(rectangle: Rectangle, result?: Rectangle): Rectangle;
    /**
     * Converts tile x, y coordinates and level to a rectangle expressed in the native coordinates
     * of the tiling scheme.
     * @param x - The integer x coordinate of the tile.
     * @param y - The integer y coordinate of the tile.
     * @param level - The tile level-of-detail.  Zero is the least detailed.
     * @param [result] - The instance to which to copy the result, or undefined if a new instance
     *        should be created.
     * @returns The specified 'result', or a new object containing the rectangle
     *          if 'result' is undefined.
     */
    tileXYToNativeRectangle(x: number, y: number, level: number, result?: any): Rectangle;
    /**
     * Converts tile x, y coordinates and level to a cartographic rectangle in radians.
     * @param x - The integer x coordinate of the tile.
     * @param y - The integer y coordinate of the tile.
     * @param level - The tile level-of-detail.  Zero is the least detailed.
     * @param [result] - The instance to which to copy the result, or undefined if a new instance
     *        should be created.
     * @returns The specified 'result', or a new object containing the rectangle
     *          if 'result' is undefined.
     */
    tileXYToRectangle(x: number, y: number, level: number, result?: any): Rectangle;
    /**
     * Calculates the tile x, y coordinates of the tile containing
     * a given cartographic position.
     * @param position - The position.
     * @param level - The tile level-of-detail.  Zero is the least detailed.
     * @param [result] - The instance to which to copy the result, or undefined if a new instance
     *        should be created.
     * @returns The specified 'result', or a new object containing the tile x, y coordinates
     *          if 'result' is undefined.
     */
    positionToTileXY(position: Cartographic, level: number, result?: Cartesian2): Cartesian2;
}

/**
 * A geometry representation with attributes forming vertices and optional index data
 * defining primitives.  Geometries and an {@link Appearance}, which describes the shading,
 * can be assigned to a {@link Primitive} for visualization.  A <code>Primitive</code> can
 * be created from many heterogeneous - in many cases - geometries for performance.
 * <p>
 * Geometries can be transformed and optimized using functions in {@link GeometryPipeline}.
 * </p>
 * @example
 * // Create geometry with a position attribute and indexed lines.
 * const positions = new Float64Array([
 *   0.0, 0.0, 0.0,
 *   7500000.0, 0.0, 0.0,
 *   0.0, 7500000.0, 0.0
 * ]);
 *
 * const geometry = new Cesium.Geometry({
 *   attributes : {
 *     position : new Cesium.GeometryAttribute({
 *       componentDatatype : Cesium.ComponentDatatype.DOUBLE,
 *       componentsPerAttribute : 3,
 *       values : positions
 *     })
 *   },
 *   indices : new Uint16Array([0, 1, 1, 2, 2, 0]),
 *   primitiveType : Cesium.PrimitiveType.LINES,
 *   boundingSphere : Cesium.BoundingSphere.fromVertices(positions)
 * });
 * @param options - Object with the following properties:
 * @param options.attributes - Attributes, which make up the geometry's vertices.
 * @param [options.primitiveType = PrimitiveType.TRIANGLES] - The type of primitives in the geometry.
 * @param [options.indices] - Optional index data that determines the primitives in the geometry.
 * @param [options.boundingSphere] - An optional bounding sphere that fully enclosed the geometry.
 */
export class Geometry {
    constructor(options: {
        attributes: GeometryAttributes;
        primitiveType?: PrimitiveType;
        indices?: Uint16Array | Uint32Array;
        boundingSphere?: BoundingSphere;
    });
    /**
     * Attributes, which make up the geometry's vertices.  Each property in this object corresponds to a
     * {@link GeometryAttribute} containing the attribute's data.
     * <p>
     * Attributes are always stored non-interleaved in a Geometry.
     * </p>
     * <p>
     * There are reserved attribute names with well-known semantics.  The following attributes
     * are created by a Geometry (depending on the provided {@link VertexFormat}.
     * <ul>
     *    <li><code>position</code> - 3D vertex position.  64-bit floating-point (for precision).  3 components per attribute.  See {@link VertexFormat#position}.</li>
     *    <li><code>normal</code> - Normal (normalized), commonly used for lighting.  32-bit floating-point.  3 components per attribute.  See {@link VertexFormat#normal}.</li>
     *    <li><code>st</code> - 2D texture coordinate.  32-bit floating-point.  2 components per attribute.  See {@link VertexFormat#st}.</li>
     *    <li><code>bitangent</code> - Bitangent (normalized), used for tangent-space effects like bump mapping.  32-bit floating-point.  3 components per attribute.  See {@link VertexFormat#bitangent}.</li>
     *    <li><code>tangent</code> - Tangent (normalized), used for tangent-space effects like bump mapping.  32-bit floating-point.  3 components per attribute.  See {@link VertexFormat#tangent}.</li>
     * </ul>
     * </p>
     * <p>
     * The following attribute names are generally not created by a Geometry, but are added
     * to a Geometry by a {@link Primitive} or {@link GeometryPipeline} functions to prepare
     * the geometry for rendering.
     * <ul>
     *    <li><code>position3DHigh</code> - High 32 bits for encoded 64-bit position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>
     *    <li><code>position3DLow</code> - Low 32 bits for encoded 64-bit position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>
     *    <li><code>position3DHigh</code> - High 32 bits for encoded 64-bit 2D (Columbus view) position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>
     *    <li><code>position2DLow</code> - Low 32 bits for encoded 64-bit 2D (Columbus view) position computed with {@link GeometryPipeline.encodeAttribute}.  32-bit floating-point.  4 components per attribute.</li>
     *    <li><code>color</code> - RGBA color (normalized) usually from {@link GeometryInstance#color}.  32-bit floating-point.  4 components per attribute.</li>
     *    <li><code>pickColor</code> - RGBA color used for picking.  32-bit floating-point.  4 components per attribute.</li>
     * </ul>
     * </p>
     * @example
     * geometry.attributes.position = new Cesium.GeometryAttribute({
     *   componentDatatype : Cesium.ComponentDatatype.FLOAT,
     *   componentsPerAttribute : 3,
     *   values : new Float32Array(0)
     * });
     */
    attributes: GeometryAttributes;
    /**
     * Optional index data that - along with {@link Geometry#primitiveType} -
     * determines the primitives in the geometry.
     */
    indices: any[];
    /**
     * The type of primitives in the geometry.  This is most often {@link PrimitiveType.TRIANGLES},
     * but can varying based on the specific geometry.
     */
    primitiveType: PrimitiveType;
    /**
     * An optional bounding sphere that fully encloses the geometry.  This is
     * commonly used for culling.
     */
    boundingSphere: BoundingSphere;
    /**
     * Computes the number of vertices in a geometry.  The runtime is linear with
     * respect to the number of attributes in a vertex, not the number of vertices.
     * @example
     * const numVertices = Cesium.Geometry.computeNumberOfVertices(geometry);
     * @param geometry - The geometry.
     * @returns The number of vertices in the geometry.
     */
    static computeNumberOfVertices(geometry: Geometry): number;
}

/**
 * Values and type information for geometry attributes.  A {@link Geometry}
 * generally contains one or more attributes.  All attributes together form
 * the geometry's vertices.
 * @example
 * const geometry = new Cesium.Geometry({
 *   attributes : {
 *     position : new Cesium.GeometryAttribute({
 *       componentDatatype : Cesium.ComponentDatatype.FLOAT,
 *       componentsPerAttribute : 3,
 *       values : new Float32Array([
 *         0.0, 0.0, 0.0,
 *         7500000.0, 0.0, 0.0,
 *         0.0, 7500000.0, 0.0
 *       ])
 *     })
 *   },
 *   primitiveType : Cesium.PrimitiveType.LINE_LOOP
 * });
 * @param [options] - Object with the following properties:
 * @param [options.componentDatatype] - The datatype of each component in the attribute, e.g., individual elements in values.
 * @param [options.componentsPerAttribute] - A number between 1 and 4 that defines the number of components in an attributes.
 * @param [options.normalize = false] - When <code>true</code> and <code>componentDatatype</code> is an integer format, indicate that the components should be mapped to the range [0, 1] (unsigned) or [-1, 1] (signed) when they are accessed as floating-point for rendering.
 * @param [options.values] - The values for the attributes stored in a typed array.
 */
export class GeometryAttribute {
    constructor(options?: {
        componentDatatype?: ComponentDatatype;
        componentsPerAttribute?: number;
        normalize?: boolean;
        values?: number[] | Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array;
    });
    /**
     * The datatype of each component in the attribute, e.g., individual elements in
     * {@link GeometryAttribute#values}.
     */
    componentDatatype: ComponentDatatype;
    /**
     * A number between 1 and 4 that defines the number of components in an attributes.
     * For example, a position attribute with x, y, and z components would have 3 as
     * shown in the code example.
     * @example
     * attribute.componentDatatype = Cesium.ComponentDatatype.FLOAT;
     * attribute.componentsPerAttribute = 3;
     * attribute.values = new Float32Array([
     *   0.0, 0.0, 0.0,
     *   7500000.0, 0.0, 0.0,
     *   0.0, 7500000.0, 0.0
     * ]);
     */
    componentsPerAttribute: number;
    /**
     * When <code>true</code> and <code>componentDatatype</code> is an integer format,
     * indicate that the components should be mapped to the range [0, 1] (unsigned)
     * or [-1, 1] (signed) when they are accessed as floating-point for rendering.
     * <p>
     * This is commonly used when storing colors using {@link ComponentDatatype.UNSIGNED_BYTE}.
     * </p>
     * @example
     * attribute.componentDatatype = Cesium.ComponentDatatype.UNSIGNED_BYTE;
     * attribute.componentsPerAttribute = 4;
     * attribute.normalize = true;
     * attribute.values = new Uint8Array([
     *   Cesium.Color.floatToByte(color.red),
     *   Cesium.Color.floatToByte(color.green),
     *   Cesium.Color.floatToByte(color.blue),
     *   Cesium.Color.floatToByte(color.alpha)
     * ]);
     */
    normalize: boolean;
    /**
     * The values for the attributes stored in a typed array.  In the code example,
     * every three elements in <code>values</code> defines one attributes since
     * <code>componentsPerAttribute</code> is 3.
     * @example
     * attribute.componentDatatype = Cesium.ComponentDatatype.FLOAT;
     * attribute.componentsPerAttribute = 3;
     * attribute.values = new Float32Array([
     *   0.0, 0.0, 0.0,
     *   7500000.0, 0.0, 0.0,
     *   0.0, 7500000.0, 0.0
     * ]);
     */
    values: number[] | Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array;
}

/**
 * Attributes, which make up a geometry's vertices.  Each property in this object corresponds to a
 * {@link GeometryAttribute} containing the attribute's data.
 * <p>
 * Attributes are always stored non-interleaved in a Geometry.
 * </p>
 */
export class GeometryAttributes {
    constructor();
    /**
     * The 3D position attribute.
     * <p>
     * 64-bit floating-point (for precision).  3 components per attribute.
     * </p>
     */
    position: GeometryAttribute;
    /**
     * The normal attribute (normalized), which is commonly used for lighting.
     * <p>
     * 32-bit floating-point.  3 components per attribute.
     * </p>
     */
    normal: GeometryAttribute;
    /**
     * The 2D texture coordinate attribute.
     * <p>
     * 32-bit floating-point.  2 components per attribute
     * </p>
     */
    st: GeometryAttribute;
    /**
     * The bitangent attribute (normalized), which is used for tangent-space effects like bump mapping.
     * <p>
     * 32-bit floating-point.  3 components per attribute.
     * </p>
     */
    bitangent: GeometryAttribute;
    /**
     * The tangent attribute (normalized), which is used for tangent-space effects like bump mapping.
     * <p>
     * 32-bit floating-point.  3 components per attribute.
     * </p>
     */
    tangent: GeometryAttribute;
    /**
     * The color attribute.
     * <p>
     * 8-bit unsigned integer. 4 components per attribute.
     * </p>
     */
    color: GeometryAttribute;
}

/**
 * Base class for all geometry creation utility classes that can be passed to {@link GeometryInstance}
 * for asynchronous geometry creation.
 */
export class GeometryFactory {
    constructor();
    /**
     * Returns a geometry.
     * @param geometryFactory - A description of the circle.
     * @returns The computed vertices and indices.
     */
    static createGeometry(geometryFactory: GeometryFactory): Geometry | undefined;
}

/**
 * Geometry instancing allows one {@link Geometry} object to be positions in several
 * different locations and colored uniquely.  For example, one {@link BoxGeometry} can
 * be instanced several times, each with a different <code>modelMatrix</code> to change
 * its position, rotation, and scale.
 * @example
 * // Create geometry for a box, and two instances that refer to it.
 * // One instance positions the box on the bottom and colored aqua.
 * // The other instance positions the box on the top and color white.
 * const geometry = Cesium.BoxGeometry.fromDimensions({
 *   vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL,
 *   dimensions : new Cesium.Cartesian3(1000000.0, 1000000.0, 500000.0)
 * });
 * const instanceBottom = new Cesium.GeometryInstance({
 *   geometry : geometry,
 *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(
 *     Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 1000000.0), new Cesium.Matrix4()),
 *   attributes : {
 *     color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA)
 *   },
 *   id : 'bottom'
 * });
 * const instanceTop = new Cesium.GeometryInstance({
 *   geometry : geometry,
 *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(
 *     Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 3000000.0), new Cesium.Matrix4()),
 *   attributes : {
 *     color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA)
 *   },
 *   id : 'top'
 * });
 * @param options - Object with the following properties:
 * @param options.geometry - The geometry to instance.
 * @param [options.modelMatrix = Matrix4.IDENTITY] - The model matrix that transforms to transform the geometry from model to world coordinates.
 * @param [options.id] - A user-defined object to return when the instance is picked with {@link Scene#pick} or get/set per-instance attributes with {@link Primitive#getGeometryInstanceAttributes}.
 * @param [options.attributes] - Per-instance attributes like a show or color attribute shown in the example below.
 */
export class GeometryInstance {
    constructor(options: {
        geometry: Geometry | GeometryFactory;
        modelMatrix?: Matrix4;
        id?: any;
        attributes?: any;
    });
    /**
     * The geometry being instanced.
     */
    geometry: Geometry;
    /**
     * The 4x4 transformation matrix that transforms the geometry from model to world coordinates.
     * When this is the identity matrix, the geometry is drawn in world coordinates, i.e., Earth's WGS84 coordinates.
     * Local reference frames can be used by providing a different transformation matrix, like that returned
     * by {@link Transforms.eastNorthUpToFixedFrame}.
     */
    modelMatrix: Matrix4;
    /**
     * User-defined object returned when the instance is picked or used to get/set per-instance attributes.
     */
    id: any;
    /**
     * Per-instance attributes like {@link ColorGeometryInstanceAttribute} or {@link ShowGeometryInstanceAttribute}.
     * {@link Geometry} attributes varying per vertex; these attributes are constant for the entire instance.
     */
    attributes: any;
}

/**
 * Values and type information for per-instance geometry attributes.
 * @example
 * const instance = new Cesium.GeometryInstance({
 *   geometry : Cesium.BoxGeometry.fromDimensions({
 *     dimensions : new Cesium.Cartesian3(1000000.0, 1000000.0, 500000.0)
 *   }),
 *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(
 *     Cesium.Cartesian3.fromDegrees(0.0, 0.0)), new Cesium.Cartesian3(0.0, 0.0, 1000000.0), new Cesium.Matrix4()),
 *   id : 'box',
 *   attributes : {
 *     color : new Cesium.GeometryInstanceAttribute({
 *       componentDatatype : Cesium.ComponentDatatype.UNSIGNED_BYTE,
 *       componentsPerAttribute : 4,
 *       normalize : true,
 *       value : [255, 255, 0, 255]
 *     })
 *   }
 * });
 * @param options - Object with the following properties:
 * @param options.componentDatatype - The datatype of each component in the attribute, e.g., individual elements in values.
 * @param options.componentsPerAttribute - A number between 1 and 4 that defines the number of components in an attributes.
 * @param [options.normalize = false] - When <code>true</code> and <code>componentDatatype</code> is an integer format, indicate that the components should be mapped to the range [0, 1] (unsigned) or [-1, 1] (signed) when they are accessed as floating-point for rendering.
 * @param options.value - The value for the attribute.
 */
export class GeometryInstanceAttribute {
    constructor(options: {
        componentDatatype: ComponentDatatype;
        componentsPerAttribute: number;
        normalize?: boolean;
        value: number[];
    });
    /**
     * The datatype of each component in the attribute, e.g., individual elements in
     * {@link GeometryInstanceAttribute#value}.
     */
    componentDatatype: ComponentDatatype;
    /**
     * A number between 1 and 4 that defines the number of components in an attributes.
     * For example, a position attribute with x, y, and z components would have 3 as
     * shown in the code example.
     * @example
     * show : new Cesium.GeometryInstanceAttribute({
     *   componentDatatype : Cesium.ComponentDatatype.UNSIGNED_BYTE,
     *   componentsPerAttribute : 1,
     *   normalize : true,
     *   value : [1.0]
     * })
     */
    componentsPerAttribute: number;
    /**
     * When <code>true</code> and <code>componentDatatype</code> is an integer format,
     * indicate that the components should be mapped to the range [0, 1] (unsigned)
     * or [-1, 1] (signed) when they are accessed as floating-point for rendering.
     * <p>
     * This is commonly used when storing colors using {@link ComponentDatatype.UNSIGNED_BYTE}.
     * </p>
     * @example
     * attribute.componentDatatype = Cesium.ComponentDatatype.UNSIGNED_BYTE;
     * attribute.componentsPerAttribute = 4;
     * attribute.normalize = true;
     * attribute.value = [
     *   Cesium.Color.floatToByte(color.red),
     *   Cesium.Color.floatToByte(color.green),
     *   Cesium.Color.floatToByte(color.blue),
     *   Cesium.Color.floatToByte(color.alpha)
     * ];
     */
    normalize: boolean;
    /**
     * The values for the attributes stored in a typed array.  In the code example,
     * every three elements in <code>values</code> defines one attributes since
     * <code>componentsPerAttribute</code> is 3.
     * @example
     * show : new Cesium.GeometryInstanceAttribute({
     *   componentDatatype : Cesium.ComponentDatatype.UNSIGNED_BYTE,
     *   componentsPerAttribute : 1,
     *   normalize : true,
     *   value : [1.0]
     * })
     */
    value: number[];
}

/**
 * Content pipeline functions for geometries.
 */
export namespace GeometryPipeline {
    /**
     * Converts a geometry's triangle indices to line indices.  If the geometry has an <code>indices</code>
     * and its <code>primitiveType</code> is <code>TRIANGLES</code>, <code>TRIANGLE_STRIP</code>,
     * <code>TRIANGLE_FAN</code>, it is converted to <code>LINES</code>; otherwise, the geometry is not changed.
     * <p>
     * This is commonly used to create a wireframe geometry for visual debugging.
     * </p>
     * @example
     * geometry = Cesium.GeometryPipeline.toWireframe(geometry);
     * @param geometry - The geometry to modify.
     * @returns The modified <code>geometry</code> argument, with its triangle indices converted to lines.
     */
    function toWireframe(geometry: Geometry): Geometry;
    /**
     * Creates a new {@link Geometry} with <code>LINES</code> representing the provided
     * attribute (<code>attributeName</code>) for the provided geometry.  This is used to
     * visualize vector attributes like normals, tangents, and bitangents.
     * @example
     * const geometry = Cesium.GeometryPipeline.createLineSegmentsForVectors(instance.geometry, 'bitangent', 100000.0);
     * @param geometry - The <code>Geometry</code> instance with the attribute.
     * @param [attributeName = 'normal'] - The name of the attribute.
     * @param [length = 10000.0] - The length of each line segment in meters.  This can be negative to point the vector in the opposite direction.
     * @returns A new <code>Geometry</code> instance with line segments for the vector.
     */
    function createLineSegmentsForVectors(geometry: Geometry, attributeName?: string, length?: number): Geometry;
    /**
     * Creates an object that maps attribute names to unique locations (indices)
     * for matching vertex attributes and shader programs.
     * @example
     * const attributeLocations = Cesium.GeometryPipeline.createAttributeLocations(geometry);
     * // Example output
     * // {
     * //   'position' : 0,
     * //   'normal' : 1
     * // }
     * @param geometry - The geometry, which is not modified, to create the object for.
     * @returns An object with attribute name / index pairs.
     */
    function createAttributeLocations(geometry: Geometry): any;
    /**
     * Reorders a geometry's attributes and <code>indices</code> to achieve better performance from the GPU's pre-vertex-shader cache.
     * @example
     * geometry = Cesium.GeometryPipeline.reorderForPreVertexCache(geometry);
     * @param geometry - The geometry to modify.
     * @returns The modified <code>geometry</code> argument, with its attributes and indices reordered for the GPU's pre-vertex-shader cache.
     */
    function reorderForPreVertexCache(geometry: Geometry): Geometry;
    /**
     * Reorders a geometry's <code>indices</code> to achieve better performance from the GPU's
     * post vertex-shader cache by using the Tipsify algorithm.  If the geometry <code>primitiveType</code>
     * is not <code>TRIANGLES</code> or the geometry does not have an <code>indices</code>, this function has no effect.
     * @example
     * geometry = Cesium.GeometryPipeline.reorderForPostVertexCache(geometry);
     * @param geometry - The geometry to modify.
     * @param [cacheCapacity = 24] - The number of vertices that can be held in the GPU's vertex cache.
     * @returns The modified <code>geometry</code> argument, with its indices reordered for the post-vertex-shader cache.
     */
    function reorderForPostVertexCache(geometry: Geometry, cacheCapacity?: number): Geometry;
    /**
     * Splits a geometry into multiple geometries, if necessary, to ensure that indices in the
     * <code>indices</code> fit into unsigned shorts.  This is used to meet the WebGL requirements
     * when unsigned int indices are not supported.
     * <p>
     * If the geometry does not have any <code>indices</code>, this function has no effect.
     * </p>
     * @example
     * const geometries = Cesium.GeometryPipeline.fitToUnsignedShortIndices(geometry);
     * @param geometry - The geometry to be split into multiple geometries.
     * @returns An array of geometries, each with indices that fit into unsigned shorts.
     */
    function fitToUnsignedShortIndices(geometry: Geometry): Geometry[];
    /**
     * Projects a geometry's 3D <code>position</code> attribute to 2D, replacing the <code>position</code>
     * attribute with separate <code>position3D</code> and <code>position2D</code> attributes.
     * <p>
     * If the geometry does not have a <code>position</code>, this function has no effect.
     * </p>
     * @example
     * geometry = Cesium.GeometryPipeline.projectTo2D(geometry, 'position', 'position3D', 'position2D');
     * @param geometry - The geometry to modify.
     * @param attributeName - The name of the attribute.
     * @param attributeName3D - The name of the attribute in 3D.
     * @param attributeName2D - The name of the attribute in 2D.
     * @param [projection = new GeographicProjection()] - The projection to use.
     * @returns The modified <code>geometry</code> argument with <code>position3D</code> and <code>position2D</code> attributes.
     */
    function projectTo2D(geometry: Geometry, attributeName: string, attributeName3D: string, attributeName2D: string, projection?: any): Geometry;
    /**
     * Encodes floating-point geometry attribute values as two separate attributes to improve
     * rendering precision.
     * <p>
     * This is commonly used to create high-precision position vertex attributes.
     * </p>
     * @example
     * geometry = Cesium.GeometryPipeline.encodeAttribute(geometry, 'position3D', 'position3DHigh', 'position3DLow');
     * @param geometry - The geometry to modify.
     * @param attributeName - The name of the attribute.
     * @param attributeHighName - The name of the attribute for the encoded high bits.
     * @param attributeLowName - The name of the attribute for the encoded low bits.
     * @returns The modified <code>geometry</code> argument, with its encoded attribute.
     */
    function encodeAttribute(geometry: Geometry, attributeName: string, attributeHighName: string, attributeLowName: string): Geometry;
    /**
     * Transforms a geometry instance to world coordinates.  This changes
     * the instance's <code>modelMatrix</code> to {@link Matrix4.IDENTITY} and transforms the
     * following attributes if they are present: <code>position</code>, <code>normal</code>,
     * <code>tangent</code>, and <code>bitangent</code>.
     * @example
     * Cesium.GeometryPipeline.transformToWorldCoordinates(instance);
     * @param instance - The geometry instance to modify.
     * @returns The modified <code>instance</code> argument, with its attributes transforms to world coordinates.
     */
    function transformToWorldCoordinates(instance: GeometryInstance): GeometryInstance;
    /**
     * Computes per-vertex normals for a geometry containing <code>TRIANGLES</code> by averaging the normals of
     * all triangles incident to the vertex.  The result is a new <code>normal</code> attribute added to the geometry.
     * This assumes a counter-clockwise winding order.
     * @example
     * Cesium.GeometryPipeline.computeNormal(geometry);
     * @param geometry - The geometry to modify.
     * @returns The modified <code>geometry</code> argument with the computed <code>normal</code> attribute.
     */
    function computeNormal(geometry: Geometry): Geometry;
    /**
     * Computes per-vertex tangents and bitangents for a geometry containing <code>TRIANGLES</code>.
     * The result is new <code>tangent</code> and <code>bitangent</code> attributes added to the geometry.
     * This assumes a counter-clockwise winding order.
     * <p>
     * Based on <a href="http://www.terathon.com/code/tangent.html">Computing Tangent Space Basis Vectors
     * for an Arbitrary Mesh</a> by Eric Lengyel.
     * </p>
     * @example
     * Cesium.GeometryPipeline.computeTangentAndBiTangent(geometry);
     * @param geometry - The geometry to modify.
     * @returns The modified <code>geometry</code> argument with the computed <code>tangent</code> and <code>bitangent</code> attributes.
     */
    function computeTangentAndBitangent(geometry: Geometry): Geometry;
    /**
     * Compresses and packs geometry normal attribute values to save memory.
     * @example
     * geometry = Cesium.GeometryPipeline.compressVertices(geometry);
     * @param geometry - The geometry to modify.
     * @returns The modified <code>geometry</code> argument, with its normals compressed and packed.
     */
    function compressVertices(geometry: Geometry): Geometry;
}

/**
 * <div class="notice">
 * To construct GoogleEarthEnterpriseMetadata, call {@link GoogleEarthEnterpriseMetadata.fromUrl}. Do not call the constructor directly.
 * </div>
 *
 * Provides metadata using the Google Earth Enterprise REST API. This is used by the GoogleEarthEnterpriseImageryProvider
 *  and GoogleEarthEnterpriseTerrainProvider to share metadata requests.
 */
export class GoogleEarthEnterpriseMetadata {
    constructor();
    /**
     * True if imagery is available.
     */
    imageryPresent: boolean;
    /**
     * True if imagery is sent as a protocol buffer, false if sent as plain images. If undefined we will try both.
     */
    protoImagery: boolean;
    /**
     * True if terrain is available.
     */
    terrainPresent: boolean;
    /**
     * Exponent used to compute constant to calculate negative height values.
     */
    negativeAltitudeExponentBias: number;
    /**
     * Threshold where any numbers smaller are actually negative values. They are multiplied by -2^negativeAltitudeExponentBias.
     */
    negativeAltitudeThreshold: number;
    /**
     * Dictionary of provider id to copyright strings.
     */
    providers: any;
    /**
     * Key used to decode packets
     */
    key: ArrayBuffer;
    /**
     * Gets the name of the Google Earth Enterprise server.
     */
    readonly url: string;
    /**
     * Gets the proxy used for metadata requests.
     */
    readonly proxy: Proxy;
    /**
     * Gets the resource used for metadata requests.
     */
    readonly resource: Resource;
    /**
     * Creates a metadata object using the Google Earth Enterprise REST API. This is used by the GoogleEarthEnterpriseImageryProvider
     * and GoogleEarthEnterpriseTerrainProvider to share metadata requests.
     * @param resourceOrUrl - The url of the Google Earth Enterprise server hosting the imagery.
     * @returns A promise which resolves to the created GoogleEarthEnterpriseMetadata instance/
     */
    static fromUrl(resourceOrUrl: Resource | string): Promise<GoogleEarthEnterpriseMetadata>;
    /**
     * Converts a tiles (x, y, level) position into a quadkey used to request an image
     * from a Google Earth Enterprise server.
     * @param x - The tile's x coordinate.
     * @param y - The tile's y coordinate.
     * @param level - The tile's zoom level.
     */
    static tileXYToQuadKey(x: number, y: number, level: number): void;
    /**
     * Converts a tile's quadkey used to request an image from a Google Earth Enterprise server into the
     * (x, y, level) position.
     * @param quadkey - The tile's quad key
     */
    static quadKeyToTileXY(quadkey: string): void;
}

/**
 * Terrain data for a single tile from a Google Earth Enterprise server.
 * @example
 * const buffer = ...
 * const childTileMask = ...
 * const terrainData = new Cesium.GoogleEarthEnterpriseTerrainData({
 *   buffer : heightBuffer,
 *   childTileMask : childTileMask
 * });
 * @param options - Object with the following properties:
 * @param options.buffer - The buffer containing terrain data.
 * @param options.negativeAltitudeExponentBias - Multiplier for negative terrain heights that are encoded as very small positive values.
 * @param options.negativeElevationThreshold - Threshold for negative values
 * @param [options.childTileMask = 15] - A bit mask indicating which of this tile's four children exist.
 *                 If a child's bit is set, geometry will be requested for that tile as well when it
 *                 is needed.  If the bit is cleared, the child tile is not requested and geometry is
 *                 instead upsampled from the parent.  The bit values are as follows:
 *                 <table>
 *                  <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>
 *                  <tr><td>0</td><td>1</td><td>Southwest</td></tr>
 *                  <tr><td>1</td><td>2</td><td>Southeast</td></tr>
 *                  <tr><td>2</td><td>4</td><td>Northeast</td></tr>
 *                  <tr><td>3</td><td>8</td><td>Northwest</td></tr>
 *                 </table>
 * @param [options.createdByUpsampling = false] - True if this instance was created by upsampling another instance;
 *                  otherwise, false.
 * @param [options.credits] - Array of credits for this tile.
 */
export class GoogleEarthEnterpriseTerrainData {
    constructor(options: {
        buffer: ArrayBuffer;
        negativeAltitudeExponentBias: number;
        negativeElevationThreshold: number;
        childTileMask?: number;
        createdByUpsampling?: boolean;
        credits?: Credit[];
    });
    /**
     * An array of credits for this tile
     */
    credits: Credit[];
    /**
     * The water mask included in this terrain data, if any.  A water mask is a rectangular
     * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.
     * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.
     */
    waterMask: Uint8Array | HTMLImageElement | HTMLCanvasElement;
    /**
     * Computes the terrain height at a specified longitude and latitude.
     * @param rectangle - The rectangle covered by this terrain data.
     * @param longitude - The longitude in radians.
     * @param latitude - The latitude in radians.
     * @returns The terrain height at the specified position.  If the position
     *          is outside the rectangle, this method will extrapolate the height, which is likely to be wildly
     *          incorrect for positions far outside the rectangle.
     */
    interpolateHeight(rectangle: Rectangle, longitude: number, latitude: number): number;
    /**
     * Upsamples this terrain data for use by a descendant tile.  The resulting instance will contain a subset of the
     * height samples in this instance, interpolated if necessary.
     * @param tilingScheme - The tiling scheme of this terrain data.
     * @param thisX - The X coordinate of this tile in the tiling scheme.
     * @param thisY - The Y coordinate of this tile in the tiling scheme.
     * @param thisLevel - The level of this tile in the tiling scheme.
     * @param descendantX - The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.
     * @param descendantY - The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.
     * @param descendantLevel - The level within the tiling scheme of the descendant tile for which we are upsampling.
     * @returns A promise for upsampled heightmap terrain data for the descendant tile,
     *          or undefined if too many asynchronous upsample operations are in progress and the request has been
     *          deferred.
     */
    upsample(tilingScheme: TilingScheme, thisX: number, thisY: number, thisLevel: number, descendantX: number, descendantY: number, descendantLevel: number): Promise<HeightmapTerrainData> | undefined;
    /**
     * Determines if a given child tile is available, based on the
     * {@link HeightmapTerrainData.childTileMask}.  The given child tile coordinates are assumed
     * to be one of the four children of this tile.  If non-child tile coordinates are
     * given, the availability of the southeast child tile is returned.
     * @param thisX - The tile X coordinate of this (the parent) tile.
     * @param thisY - The tile Y coordinate of this (the parent) tile.
     * @param childX - The tile X coordinate of the child tile to check for availability.
     * @param childY - The tile Y coordinate of the child tile to check for availability.
     * @returns True if the child tile is available; otherwise, false.
     */
    isChildAvailable(thisX: number, thisY: number, childX: number, childY: number): boolean;
    /**
     * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution
     * terrain data.  If this value is false, the data was obtained from some other source, such
     * as by downloading it from a remote server.  This method should return true for instances
     * returned from a call to {@link HeightmapTerrainData#upsample}.
     * @returns True if this instance was created by upsampling; otherwise, false.
     */
    wasCreatedByUpsampling(): boolean;
}

export namespace GoogleEarthEnterpriseTerrainProvider {
    /**
     * Initialization options for GoogleEarthEnterpriseTerrainProvider constructor
     * [ellipsoid] - The ellipsoid.  If not specified, the WGS84 ellipsoid is used.
     * [credit] - A credit for the data source, which is displayed on the canvas.
     */
    type ConstructorOptions = {
        ellipsoid?: Ellipsoid;
        credit?: Credit | string;
    };
}

/**
 * <div class="notice">
 * To construct a GoogleEarthEnterpriseTerrainProvider, call {@link  GoogleEarthEnterpriseTerrainProvider.fromMetadata}. Do not call the constructor directly.
 * </div>
 *
 * Provides tiled terrain using the Google Earth Enterprise REST API.
 * @example
 * const geeMetadata = await GoogleEarthEnterpriseMetadata.fromUrl("http://www.example.com");
 * const gee = Cesium.GoogleEarthEnterpriseTerrainProvider.fromMetadata(geeMetadata);
 * @param [options] - An object describing initialization options
 */
export class GoogleEarthEnterpriseTerrainProvider {
    constructor(options?: GoogleEarthEnterpriseTerrainProvider.ConstructorOptions);
    /**
     * Gets the name of the Google Earth Enterprise server url hosting the imagery.
     */
    readonly url: string;
    /**
     * Gets the proxy used by this provider.
     */
    readonly proxy: Proxy;
    /**
     * Gets the tiling scheme used by this provider.
     */
    readonly tilingScheme: TilingScheme;
    /**
     * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
     * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
     * are passed an instance of {@link TileProviderError}.
     */
    readonly errorEvent: Event;
    /**
     * Gets the credit to display when this terrain provider is active.  Typically this is used to credit
     * the source of the terrain.
     */
    readonly credit: Credit;
    /**
     * Gets a value indicating whether or not the provider includes a water mask.  The water mask
     * indicates which areas of the globe are water rather than land, so they can be rendered
     * as a reflective surface with animated waves.
     */
    readonly hasWaterMask: boolean;
    /**
     * Gets a value indicating whether or not the requested tiles include vertex normals.
     */
    readonly hasVertexNormals: boolean;
    /**
     * Gets an object that can be used to determine availability of terrain from this provider, such as
     * at points and in rectangles. This property may be undefined if availability
     * information is not available.
     */
    readonly availability: TileAvailability;
    /**
     * Creates a GoogleEarthTerrainProvider from GoogleEarthEnterpriseMetadata
     * @example
     * const geeMetadata = await GoogleEarthEnterpriseMetadata.fromUrl("http://www.example.com");
     * const gee = Cesium.GoogleEarthEnterpriseTerrainProvider.fromMetadata(geeMetadata);
     * @param metadata - A metadata object that can be used to share metadata requests with a GoogleEarthEnterpriseImageryProvider.
     * @param options - An object describing initialization options
     */
    static fromMetadata(metadata: GoogleEarthEnterpriseMetadata, options: GoogleEarthEnterpriseTerrainProvider.ConstructorOptions): GoogleEarthEnterpriseTerrainProvider;
    /**
     * Requests the geometry for a given tile.   The result must include terrain data and
     * may optionally include a water mask and an indication of which child tiles are available.
     * @param x - The X coordinate of the tile for which to request geometry.
     * @param y - The Y coordinate of the tile for which to request geometry.
     * @param level - The level of the tile for which to request geometry.
     * @param [request] - The request object. Intended for internal use only.
     * @returns A promise for the requested geometry.  If this method
     *          returns undefined instead of a promise, it is an indication that too many requests are already
     *          pending and the request will be retried later.
     */
    requestTileGeometry(x: number, y: number, level: number, request?: Request): Promise<TerrainData> | undefined;
    /**
     * Gets the maximum geometric error allowed in a tile at a given level.
     * @param level - The tile level for which to get the maximum geometric error.
     * @returns The maximum geometric error.
     */
    getLevelMaximumGeometricError(level: number): number;
    /**
     * Determines whether data for a tile is available to be loaded.
     * @param x - The X coordinate of the tile for which to request geometry.
     * @param y - The Y coordinate of the tile for which to request geometry.
     * @param level - The level of the tile for which to request geometry.
     * @returns Undefined if not supported, otherwise true or false.
     */
    getTileDataAvailable(x: number, y: number, level: number): boolean | undefined;
    /**
     * Makes sure we load availability data for a tile
     * @param x - The X coordinate of the tile for which to request geometry.
     * @param y - The Y coordinate of the tile for which to request geometry.
     * @param level - The level of the tile for which to request geometry.
     */
    loadTileDataAvailability(x: number, y: number, level: number): undefined;
}

/**
 * Default settings for accessing the Google Maps API.
 * <br/>
 * An API key is only required if you are using any Google Maps APIs, such as {@link createGooglePhotorealistic3DTileset}.
 * A default key is provided for evaluation purposes only.
 * Follow instructions for managing API keys for the Google Maps Platform at {@link https://developers.google.com/maps/documentation/embed/get-api-key}
 */
export namespace GoogleMaps {
    /**
     * Gets or sets the default Google Maps API key.
     */
    var defaultApiKey: string;
    /**
     * Gets or sets the default Google Map Tiles API endpoint.
     */
    var mapTilesApiEndpoint: string | Resource;
}

/**
 * Represents a Gregorian date in a more precise format than the JavaScript Date object.
 * In addition to submillisecond precision, this object can also represent leap seconds.
 * @param [year] - The year as a whole number.
 * @param [month] - The month as a whole number with range [1, 12].
 * @param [day] - The day of the month as a whole number starting at 1.
 * @param [hour] - The hour as a whole number with range [0, 23].
 * @param [minute] - The minute of the hour as a whole number with range [0, 59].
 * @param [second] - The second of the minute as a whole number with range [0, 60], with 60 representing a leap second.
 * @param [millisecond] - The millisecond of the second as a floating point number with range [0.0, 1000.0).
 * @param [isLeapSecond] - Whether this time is during a leap second.
 */
export class GregorianDate {
    constructor(year?: number, month?: number, day?: number, hour?: number, minute?: number, second?: number, millisecond?: number, isLeapSecond?: boolean);
    /**
     * Gets or sets the year as a whole number.
     */
    year: number;
    /**
     * Gets or sets the month as a whole number with range [1, 12].
     */
    month: number;
    /**
     * Gets or sets the day of the month as a whole number starting at 1.
     */
    day: number;
    /**
     * Gets or sets the hour as a whole number with range [0, 23].
     */
    hour: number;
    /**
     * Gets or sets the minute of the hour as a whole number with range [0, 59].
     */
    minute: number;
    /**
     * Gets or sets the second of the minute as a whole number with range [0, 60], with 60 representing a leap second.
     */
    second: number;
    /**
     * Gets or sets the millisecond of the second as a floating point number with range [0.0, 1000.0).
     */
    millisecond: number;
    /**
     * Gets or sets whether this time is during a leap second.
     */
    isLeapSecond: boolean;
}

/**
 * A description of a polyline on terrain or 3D Tiles. Only to be used with {@link GroundPolylinePrimitive}.
 * @example
 * const positions = Cesium.Cartesian3.fromDegreesArray([
 *   -112.1340164450331, 36.05494287836128,
 *   -112.08821010582645, 36.097804071380715,
 *   -112.13296079730024, 36.168769146801104
 * ]);
 *
 * const geometry = new Cesium.GroundPolylineGeometry({
 *   positions : positions
 * });
 * @param options - Options with the following properties:
 * @param options.positions - An array of {@link Cartesian3} defining the polyline's points. Heights above the ellipsoid will be ignored.
 * @param [options.width = 1.0] - The screen space width in pixels.
 * @param [options.granularity = 9999.0] - The distance interval in meters used for interpolating options.points. Defaults to 9999.0 meters. Zero indicates no interpolation.
 * @param [options.loop = false] - Whether during geometry creation a line segment will be added between the last and first line positions to make this Polyline a loop.
 * @param [options.arcType = ArcType.GEODESIC] - The type of line the polyline segments must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.
 */
export class GroundPolylineGeometry {
    constructor(options: {
        positions: Cartesian3[];
        width?: number;
        granularity?: number;
        loop?: boolean;
        arcType?: ArcType;
    });
    /**
     * The screen space width in pixels.
     */
    width: number;
    /**
     * The distance interval used for interpolating options.points. Zero indicates no interpolation.
     * Default of 9999.0 allows centimeter accuracy with 32 bit floating point.
     */
    granularity: boolean;
    /**
     * Whether during geometry creation a line segment will be added between the last and first line positions to make this Polyline a loop.
     * If the geometry has two positions this parameter will be ignored.
     */
    loop: boolean;
    /**
     * The type of path the polyline must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.
     */
    arcType: ArcType;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: PolygonGeometry, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     */
    static unpack(array: number[], startingIndex?: number, result?: PolygonGeometry): void;
}

/**
 * Defines a heading angle, pitch angle, and range in a local frame.
 * Heading is the rotation from the local north direction where a positive angle is increasing eastward.
 * Pitch is the rotation from the local xy-plane. Positive pitch angles are above the plane. Negative pitch
 * angles are below the plane. Range is the distance from the center of the frame.
 * @param [heading = 0.0] - The heading angle in radians.
 * @param [pitch = 0.0] - The pitch angle in radians.
 * @param [range = 0.0] - The distance from the center in meters.
 */
export class HeadingPitchRange {
    constructor(heading?: number, pitch?: number, range?: number);
    /**
     * Heading is the rotation from the local north direction where a positive angle is increasing eastward.
     */
    heading: number;
    /**
     * Pitch is the rotation from the local xy-plane. Positive pitch angles
     * are above the plane. Negative pitch angles are below the plane.
     */
    pitch: number;
    /**
     * Range is the distance from the center of the local frame.
     */
    range: number;
    /**
     * Duplicates a HeadingPitchRange instance.
     * @param hpr - The HeadingPitchRange to duplicate.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new HeadingPitchRange instance if one was not provided. (Returns undefined if hpr is undefined)
     */
    static clone(hpr: HeadingPitchRange, result?: HeadingPitchRange): HeadingPitchRange;
}

/**
 * A rotation expressed as a heading, pitch, and roll. Heading is the rotation about the
 * negative z axis. Pitch is the rotation about the negative y axis. Roll is the rotation about
 * the positive x axis.
 * @param [heading = 0.0] - The heading component in radians.
 * @param [pitch = 0.0] - The pitch component in radians.
 * @param [roll = 0.0] - The roll component in radians.
 */
export class HeadingPitchRoll {
    constructor(heading?: number, pitch?: number, roll?: number);
    /**
     * Gets or sets the heading.
     */
    heading: number;
    /**
     * Gets or sets the pitch.
     */
    pitch: number;
    /**
     * Gets or sets the roll.
     */
    roll: number;
    /**
     * Computes the heading, pitch and roll from a quaternion (see http://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles )
     * @param quaternion - The quaternion from which to retrieve heading, pitch, and roll, all expressed in radians.
     * @param [result] - The object in which to store the result. If not provided, a new instance is created and returned.
     * @returns The modified result parameter or a new HeadingPitchRoll instance if one was not provided.
     */
    static fromQuaternion(quaternion: Quaternion, result?: HeadingPitchRoll): HeadingPitchRoll;
    /**
     * Returns a new HeadingPitchRoll instance from angles given in degrees.
     * @param heading - the heading in degrees
     * @param pitch - the pitch in degrees
     * @param roll - the heading in degrees
     * @param [result] - The object in which to store the result. If not provided, a new instance is created and returned.
     * @returns A new HeadingPitchRoll instance
     */
    static fromDegrees(heading: number, pitch: number, roll: number, result?: HeadingPitchRoll): HeadingPitchRoll;
    /**
     * Duplicates a HeadingPitchRoll instance.
     * @param headingPitchRoll - The HeadingPitchRoll to duplicate.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new HeadingPitchRoll instance if one was not provided. (Returns undefined if headingPitchRoll is undefined)
     */
    static clone(headingPitchRoll: HeadingPitchRoll, result?: HeadingPitchRoll): HeadingPitchRoll;
    /**
     * Compares the provided HeadingPitchRolls componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [left] - The first HeadingPitchRoll.
     * @param [right] - The second HeadingPitchRoll.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    static equals(left?: HeadingPitchRoll, right?: HeadingPitchRoll): boolean;
    /**
     * Compares the provided HeadingPitchRolls componentwise and returns
     * <code>true</code> if they pass an absolute or relative tolerance test,
     * <code>false</code> otherwise.
     * @param [left] - The first HeadingPitchRoll.
     * @param [right] - The second HeadingPitchRoll.
     * @param [relativeEpsilon = 0] - The relative epsilon tolerance to use for equality testing.
     * @param [absoluteEpsilon = relativeEpsilon] - The absolute epsilon tolerance to use for equality testing.
     * @returns <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
     */
    static equalsEpsilon(left?: HeadingPitchRoll, right?: HeadingPitchRoll, relativeEpsilon?: number, absoluteEpsilon?: number): boolean;
    /**
     * Duplicates this HeadingPitchRoll instance.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new HeadingPitchRoll instance if one was not provided.
     */
    clone(result?: HeadingPitchRoll): HeadingPitchRoll;
    /**
     * Compares this HeadingPitchRoll against the provided HeadingPitchRoll componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [right] - The right hand side HeadingPitchRoll.
     * @returns <code>true</code> if they are equal, <code>false</code> otherwise.
     */
    equals(right?: HeadingPitchRoll): boolean;
    /**
     * Compares this HeadingPitchRoll against the provided HeadingPitchRoll componentwise and returns
     * <code>true</code> if they pass an absolute or relative tolerance test,
     * <code>false</code> otherwise.
     * @param [right] - The right hand side HeadingPitchRoll.
     * @param [relativeEpsilon = 0] - The relative epsilon tolerance to use for equality testing.
     * @param [absoluteEpsilon = relativeEpsilon] - The absolute epsilon tolerance to use for equality testing.
     * @returns <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
     */
    equalsEpsilon(right?: HeadingPitchRoll, relativeEpsilon?: number, absoluteEpsilon?: number): boolean;
    /**
     * Creates a string representing this HeadingPitchRoll in the format '(heading, pitch, roll)' in radians.
     * @returns A string representing the provided HeadingPitchRoll in the format '(heading, pitch, roll)'.
     */
    toString(): string;
}

/**
 * The encoding that is used for a heightmap
 */
export enum HeightmapEncoding {
    /**
     * No encoding
     */
    NONE = 0,
    /**
     * LERC encoding
     */
    LERC = 1
}

/**
 * Terrain data for a single tile where the terrain data is represented as a heightmap.  A heightmap
 * is a rectangular array of heights in row-major order from north to south and west to east.
 * @example
 * const buffer = ...
 * const heightBuffer = new Uint16Array(buffer, 0, that._heightmapWidth * that._heightmapWidth);
 * const childTileMask = new Uint8Array(buffer, heightBuffer.byteLength, 1)[0];
 * const waterMask = new Uint8Array(buffer, heightBuffer.byteLength + 1, buffer.byteLength - heightBuffer.byteLength - 1);
 * const terrainData = new Cesium.HeightmapTerrainData({
 *   buffer : heightBuffer,
 *   width : 65,
 *   height : 65,
 *   childTileMask : childTileMask,
 *   waterMask : waterMask
 * });
 * @param options - Object with the following properties:
 * @param options.buffer - The buffer containing height data.
 * @param options.width - The width (longitude direction) of the heightmap, in samples.
 * @param options.height - The height (latitude direction) of the heightmap, in samples.
 * @param [options.childTileMask = 15] - A bit mask indicating which of this tile's four children exist.
 *                 If a child's bit is set, geometry will be requested for that tile as well when it
 *                 is needed.  If the bit is cleared, the child tile is not requested and geometry is
 *                 instead upsampled from the parent.  The bit values are as follows:
 *                 <table>
 *                  <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>
 *                  <tr><td>0</td><td>1</td><td>Southwest</td></tr>
 *                  <tr><td>1</td><td>2</td><td>Southeast</td></tr>
 *                  <tr><td>2</td><td>4</td><td>Northwest</td></tr>
 *                  <tr><td>3</td><td>8</td><td>Northeast</td></tr>
 *                 </table>
 * @param [options.waterMask] - The water mask included in this terrain data, if any.  A water mask is a square
 *                     Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.
 *                     Values in between 0 and 255 are allowed as well to smoothly blend between land and water.
 * @param [options.structure] - An object describing the structure of the height data.
 * @param [options.structure.heightScale = 1.0] - The factor by which to multiply height samples in order to obtain
 *                 the height above the heightOffset, in meters.  The heightOffset is added to the resulting
 *                 height after multiplying by the scale.
 * @param [options.structure.heightOffset = 0.0] - The offset to add to the scaled height to obtain the final
 *                 height in meters.  The offset is added after the height sample is multiplied by the
 *                 heightScale.
 * @param [options.structure.elementsPerHeight = 1] - The number of elements in the buffer that make up a single height
 *                 sample.  This is usually 1, indicating that each element is a separate height sample.  If
 *                 it is greater than 1, that number of elements together form the height sample, which is
 *                 computed according to the structure.elementMultiplier and structure.isBigEndian properties.
 * @param [options.structure.stride = 1] - The number of elements to skip to get from the first element of
 *                 one height to the first element of the next height.
 * @param [options.structure.elementMultiplier = 256.0] - The multiplier used to compute the height value when the
 *                 stride property is greater than 1.  For example, if the stride is 4 and the strideMultiplier
 *                 is 256, the height is computed as follows:
 *                 `height = buffer[index] + buffer[index + 1] * 256 + buffer[index + 2] * 256 * 256 + buffer[index + 3] * 256 * 256 * 256`
 *                 This is assuming that the isBigEndian property is false.  If it is true, the order of the
 *                 elements is reversed.
 * @param [options.structure.isBigEndian = false] - Indicates endianness of the elements in the buffer when the
 *                  stride property is greater than 1.  If this property is false, the first element is the
 *                  low-order element.  If it is true, the first element is the high-order element.
 * @param [options.structure.lowestEncodedHeight] - The lowest value that can be stored in the height buffer.  Any heights that are lower
 *                 than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height
 *                 buffer is a `Uint16Array`, this value should be 0 because a `Uint16Array` cannot store negative numbers.  If this parameter is
 *                 not specified, no minimum value is enforced.
 * @param [options.structure.highestEncodedHeight] - The highest value that can be stored in the height buffer.  Any heights that are higher
 *                 than this value after encoding with the `heightScale` and `heightOffset` are clamped to this value.  For example, if the height
 *                 buffer is a `Uint16Array`, this value should be `256 * 256 - 1` or 65535 because a `Uint16Array` cannot store numbers larger
 *                 than 65535.  If this parameter is not specified, no maximum value is enforced.
 * @param [options.encoding = HeightmapEncoding.NONE] - The encoding that is used on the buffer.
 * @param [options.createdByUpsampling = false] - True if this instance was created by upsampling another instance;
 *                  otherwise, false.
 */
export class HeightmapTerrainData {
    constructor(options: {
        buffer: Int8Array | Uint8Array | Int16Array | Uint16Array | Int32Array | Uint32Array | Float32Array | Float64Array;
        width: number;
        height: number;
        childTileMask?: number;
        waterMask?: Uint8Array;
        structure?: {
            heightScale?: number;
            heightOffset?: number;
            elementsPerHeight?: number;
            stride?: number;
            elementMultiplier?: number;
            isBigEndian?: boolean;
            lowestEncodedHeight?: number;
            highestEncodedHeight?: number;
        };
        encoding?: HeightmapEncoding;
        createdByUpsampling?: boolean;
    });
    /**
     * An array of credits for this tile.
     */
    credits: Credit[];
    /**
     * The water mask included in this terrain data, if any.  A water mask is a square
     * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.
     * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.
     */
    waterMask: Uint8Array | HTMLImageElement | HTMLCanvasElement;
    /**
     * Computes the terrain height at a specified longitude and latitude.
     * @param rectangle - The rectangle covered by this terrain data.
     * @param longitude - The longitude in radians.
     * @param latitude - The latitude in radians.
     * @returns The terrain height at the specified position.  If the position
     *          is outside the rectangle, this method will extrapolate the height, which is likely to be wildly
     *          incorrect for positions far outside the rectangle.
     */
    interpolateHeight(rectangle: Rectangle, longitude: number, latitude: number): number;
    /**
     * Upsamples this terrain data for use by a descendant tile.  The resulting instance will contain a subset of the
     * height samples in this instance, interpolated if necessary.
     * @param tilingScheme - The tiling scheme of this terrain data.
     * @param thisX - The X coordinate of this tile in the tiling scheme.
     * @param thisY - The Y coordinate of this tile in the tiling scheme.
     * @param thisLevel - The level of this tile in the tiling scheme.
     * @param descendantX - The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.
     * @param descendantY - The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.
     * @param descendantLevel - The level within the tiling scheme of the descendant tile for which we are upsampling.
     * @returns A promise for upsampled heightmap terrain data for the descendant tile,
     *          or undefined if the mesh is unavailable.
     */
    upsample(tilingScheme: TilingScheme, thisX: number, thisY: number, thisLevel: number, descendantX: number, descendantY: number, descendantLevel: number): Promise<HeightmapTerrainData> | undefined;
    /**
     * Determines if a given child tile is available, based on the
     * {@link HeightmapTerrainData.childTileMask}.  The given child tile coordinates are assumed
     * to be one of the four children of this tile.  If non-child tile coordinates are
     * given, the availability of the southeast child tile is returned.
     * @param thisX - The tile X coordinate of this (the parent) tile.
     * @param thisY - The tile Y coordinate of this (the parent) tile.
     * @param childX - The tile X coordinate of the child tile to check for availability.
     * @param childY - The tile Y coordinate of the child tile to check for availability.
     * @returns True if the child tile is available; otherwise, false.
     */
    isChildAvailable(thisX: number, thisY: number, childX: number, childY: number): boolean;
    /**
     * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution
     * terrain data.  If this value is false, the data was obtained from some other source, such
     * as by downloading it from a remote server.  This method should return true for instances
     * returned from a call to {@link HeightmapTerrainData#upsample}.
     * @returns True if this instance was created by upsampling; otherwise, false.
     */
    wasCreatedByUpsampling(): boolean;
}

/**
 * An {@link InterpolationAlgorithm} for performing Hermite interpolation.
 */
export namespace HermitePolynomialApproximation {
    /**
     * Given the desired degree, returns the number of data points required for interpolation.
     * @param degree - The desired degree of interpolation.
     * @param [inputOrder = 0] - The order of the inputs (0 means just the data, 1 means the data and its derivative, etc).
     * @returns The number of required data points needed for the desired degree of interpolation.
     */
    function getRequiredDataPoints(degree: number, inputOrder?: number): number;
    /**
     * Interpolates values using Hermite Polynomial Approximation.
     * @param x - The independent variable for which the dependent variables will be interpolated.
     * @param xTable - The array of independent variables to use to interpolate.  The values
     * in this array must be in increasing order and the same value must not occur twice in the array.
     * @param yTable - The array of dependent variables to use to interpolate.  For a set of three
     * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.
     * @param yStride - The number of dependent variable values in yTable corresponding to
     * each independent variable value in xTable.
     * @param [result] - An existing array into which to store the result.
     * @returns The array of interpolated values, or the result parameter if one was provided.
     */
    function interpolateOrderZero(x: number, xTable: number[], yTable: number[], yStride: number, result?: number[]): number[];
    /**
     * Interpolates values using Hermite Polynomial Approximation.
     * @param x - The independent variable for which the dependent variables will be interpolated.
     * @param xTable - The array of independent variables to use to interpolate.  The values
     * in this array must be in increasing order and the same value must not occur twice in the array.
     * @param yTable - The array of dependent variables to use to interpolate.  For a set of three
     * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.
     * @param yStride - The number of dependent variable values in yTable corresponding to
     * each independent variable value in xTable.
     * @param inputOrder - The number of derivatives supplied for input.
     * @param outputOrder - The number of derivatives desired for output.
     * @param [result] - An existing array into which to store the result.
     * @returns The array of interpolated values, or the result parameter if one was provided.
     */
    function interpolate(x: number, xTable: number[], yTable: number[], yStride: number, inputOrder: number, outputOrder: number, result?: number[]): number[];
}

/**
 * A Hermite spline is a cubic interpolating spline. Points, incoming tangents, outgoing tangents, and times
 * must be defined for each control point. The outgoing tangents are defined for points [0, n - 2] and the incoming
 * tangents are defined for points [1, n - 1]. For example, when interpolating a segment of the curve between <code>points[i]</code> and
 * <code>points[i + 1]</code>, the tangents at the points will be <code>outTangents[i]</code> and <code>inTangents[i]</code>,
 * respectively.
 * @example
 * // Create a G<sup>1</sup> continuous Hermite spline
 * const times = [ 0.0, 1.5, 3.0, 4.5, 6.0 ];
 * const spline = new Cesium.HermiteSpline({
 *     times : times,
 *     points : [
 *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),
 *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),
 *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),
 *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),
 *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)
 *     ],
 *     outTangents : [
 *         new Cesium.Cartesian3(1125196, -161816, 270551),
 *         new Cesium.Cartesian3(-996690.5, -365906.5, 184028.5),
 *         new Cesium.Cartesian3(-2096917, 48379.5, -292683.5),
 *         new Cesium.Cartesian3(-890902.5, 408999.5, -447115)
 *     ],
 *     inTangents : [
 *         new Cesium.Cartesian3(-1993381, -731813, 368057),
 *         new Cesium.Cartesian3(-4193834, 96759, -585367),
 *         new Cesium.Cartesian3(-1781805, 817999, -894230),
 *         new Cesium.Cartesian3(1165345, 112641, 47281)
 *     ]
 * });
 *
 * const p0 = spline.evaluate(times[0]);
 * @param options - Object with the following properties:
 * @param options.times - An array of strictly increasing, unit-less, floating-point times at each point.
 *                The values are in no way connected to the clock time. They are the parameterization for the curve.
 * @param options.points - The array of control points.
 * @param options.inTangents - The array of incoming tangents at each control point.
 * @param options.outTangents - The array of outgoing tangents at each control point.
 */
export class HermiteSpline {
    constructor(options: {
        times: number[];
        points: Cartesian3[];
        inTangents: Cartesian3[];
        outTangents: Cartesian3[];
    });
    /**
     * An array of times for the control points.
     */
    readonly times: number[];
    /**
     * An array of control points.
     */
    readonly points: Cartesian3[];
    /**
     * An array of incoming tangents at each control point.
     */
    readonly inTangents: Cartesian3[];
    /**
     * An array of outgoing tangents at each control point.
     */
    readonly outTangents: Cartesian3[];
    /**
     * Creates a spline where the tangents at each control point are the same.
     * The curves are guaranteed to be at least in the class C<sup>1</sup>.
     * @example
     * const points = [
     *     new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),
     *     new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),
     *     new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),
     *     new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),
     *     new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)
     * ];
     *
     * // Add tangents
     * const tangents = new Array(points.length);
     * tangents[0] = new Cesium.Cartesian3(1125196, -161816, 270551);
     * const temp = new Cesium.Cartesian3();
     * for (let i = 1; i < tangents.length - 1; ++i) {
     *     tangents[i] = Cesium.Cartesian3.multiplyByScalar(Cesium.Cartesian3.subtract(points[i + 1], points[i - 1], temp), 0.5, new Cesium.Cartesian3());
     * }
     * tangents[tangents.length - 1] = new Cesium.Cartesian3(1165345, 112641, 47281);
     *
     * const spline = Cesium.HermiteSpline.createC1({
     *     times : times,
     *     points : points,
     *     tangents : tangents
     * });
     * @param options - Object with the following properties:
     * @param options.times - The array of control point times.
     * @param options.points - The array of control points.
     * @param options.tangents - The array of tangents at the control points.
     * @returns A hermite spline.
     */
    static createC1(options: {
        times: number[];
        points: Cartesian3[];
        tangents: Cartesian3[];
    }): HermiteSpline;
    /**
     * Creates a natural cubic spline. The tangents at the control points are generated
     * to create a curve in the class C<sup>2</sup>.
     * @example
     * // Create a natural cubic spline above the earth from Philadelphia to Los Angeles.
     * const spline = Cesium.HermiteSpline.createNaturalCubic({
     *     times : [ 0.0, 1.5, 3.0, 4.5, 6.0 ],
     *     points : [
     *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),
     *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),
     *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),
     *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),
     *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)
     *     ]
     * });
     * @param options - Object with the following properties:
     * @param options.times - The array of control point times.
     * @param options.points - The array of control points.
     * @returns A hermite spline, or a linear spline if less than 3 control points were given.
     */
    static createNaturalCubic(options: {
        times: number[];
        points: Cartesian3[];
    }): HermiteSpline | LinearSpline;
    /**
     * Creates a clamped cubic spline. The tangents at the interior control points are generated
     * to create a curve in the class C<sup>2</sup>.
     * @example
     * // Create a clamped cubic spline above the earth from Philadelphia to Los Angeles.
     * const spline = Cesium.HermiteSpline.createClampedCubic({
     *     times : [ 0.0, 1.5, 3.0, 4.5, 6.0 ],
     *     points : [
     *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),
     *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),
     *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),
     *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),
     *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)
     *     ],
     *     firstTangent : new Cesium.Cartesian3(1125196, -161816, 270551),
     *     lastTangent : new Cesium.Cartesian3(1165345, 112641, 47281)
     * });
     * @param options - Object with the following properties:
     * @param options.times - The array of control point times.
     * @param options.points - The array of control points.
     * @param options.firstTangent - The outgoing tangent of the first control point.
     * @param options.lastTangent - The incoming tangent of the last control point.
     * @returns A hermite spline, or a linear spline if less than 3 control points were given.
     */
    static createClampedCubic(options: {
        times: number[];
        points: number[] | Cartesian3[];
        firstTangent: Cartesian3;
        lastTangent: Cartesian3;
    }): HermiteSpline | LinearSpline;
    /**
     * Finds an index <code>i</code> in <code>times</code> such that the parameter
     * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.
     * @param time - The time.
     * @returns The index for the element at the start of the interval.
     */
    findTimeInterval(time: number): number;
    /**
     * Wraps the given time to the period covered by the spline.
     * @param time - The time.
     * @returns The time, wrapped around to the updated animation.
     */
    wrapTime(time: number): number;
    /**
     * Clamps the given time to the period covered by the spline.
     * @param time - The time.
     * @returns The time, clamped to the animation period.
     */
    clampTime(time: number): number;
    /**
     * Evaluates the curve at a given time.
     * @param time - The time at which to evaluate the curve.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new instance of the point on the curve at the given time.
     */
    evaluate(time: number, result?: Cartesian3): Cartesian3;
}

/**
 * Hilbert Order helper functions.
 */
export namespace HilbertOrder { }

/**
 * Constants for WebGL index datatypes.  These corresponds to the
 * <code>type</code> parameter of {@link http://www.khronos.org/opengles/sdk/docs/man/xhtml/glDrawElements.xml|drawElements}.
 */
export enum IndexDatatype {
    /**
     * 8-bit unsigned byte corresponding to <code>UNSIGNED_BYTE</code> and the type
     * of an element in <code>Uint8Array</code>.
     */
    UNSIGNED_BYTE = WebGLConstants.UNSIGNED_BYTE,
    /**
     * 16-bit unsigned short corresponding to <code>UNSIGNED_SHORT</code> and the type
     * of an element in <code>Uint16Array</code>.
     */
    UNSIGNED_SHORT = WebGLConstants.UNSIGNED_SHORT,
    /**
     * 32-bit unsigned int corresponding to <code>UNSIGNED_INT</code> and the type
     * of an element in <code>Uint32Array</code>.
     */
    UNSIGNED_INT = WebGLConstants.UNSIGNED_INT
}

export namespace InterpolationAlgorithm {
    /**
     * Gets the name of this interpolation algorithm.
     */
    var type: string;
    /**
     * Given the desired degree, returns the number of data points required for interpolation.
     * @param degree - The desired degree of interpolation.
     * @returns The number of required data points needed for the desired degree of interpolation.
     */
    function getRequiredDataPoints(degree: number): number;
    /**
     * Performs zero order interpolation.
     * @param x - The independent variable for which the dependent variables will be interpolated.
     * @param xTable - The array of independent variables to use to interpolate.  The values
     * in this array must be in increasing order and the same value must not occur twice in the array.
     * @param yTable - The array of dependent variables to use to interpolate.  For a set of three
     * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.
     * @param yStride - The number of dependent variable values in yTable corresponding to
     * each independent variable value in xTable.
     * @param [result] - An existing array into which to store the result.
     * @returns The array of interpolated values, or the result parameter if one was provided.
     */
    function interpolateOrderZero(x: number, xTable: number[], yTable: number[], yStride: number, result?: number[]): number[];
    /**
     * Performs higher order interpolation.  Not all interpolators need to support high-order interpolation,
     * if this function remains undefined on implementing objects, interpolateOrderZero will be used instead.
     * @param x - The independent variable for which the dependent variables will be interpolated.
     * @param xTable - The array of independent variables to use to interpolate.  The values
     * in this array must be in increasing order and the same value must not occur twice in the array.
     * @param yTable - The array of dependent variables to use to interpolate.  For a set of three
     * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.
     * @param yStride - The number of dependent variable values in yTable corresponding to
     * each independent variable value in xTable.
     * @param inputOrder - The number of derivatives supplied for input.
     * @param outputOrder - The number of derivatives desired for output.
     * @param [result] - An existing array into which to store the result.
     * @returns The array of interpolated values, or the result parameter if one was provided.
     */
    function interpolate(x: number, xTable: number[], yTable: number[], yStride: number, inputOrder: number, outputOrder: number, result?: number[]): number[];
}

/**
 * The interface for interpolation algorithms.
 */
export interface InterpolationAlgorithm {
}

/**
 * This enumerated type is used in determining where, relative to the frustum, an
 * object is located. The object can either be fully contained within the frustum (INSIDE),
 * partially inside the frustum and partially outside (INTERSECTING), or somewhere entirely
 * outside of the frustum's 6 planes (OUTSIDE).
 */
export enum Intersect {
    /**
     * Represents that an object is not contained within the frustum.
     */
    OUTSIDE = -1,
    /**
     * Represents that an object intersects one of the frustum's planes.
     */
    INTERSECTING = 0,
    /**
     * Represents that an object is fully within the frustum.
     */
    INSIDE = 1
}

/**
 * Functions for computing the intersection between geometries such as rays, planes, triangles, and ellipsoids.
 */
export namespace IntersectionTests {
    /**
     * Computes the intersection of a ray and a plane.
     * @param ray - The ray.
     * @param plane - The plane.
     * @param [result] - The object onto which to store the result.
     * @returns The intersection point or undefined if there is no intersections.
     */
    function rayPlane(ray: Ray, plane: Plane, result?: Cartesian3): Cartesian3;
    /**
     * Computes the intersection of a ray and a triangle as a parametric distance along the input ray. The result is negative when the triangle is behind the ray.
     *
     * Implements {@link https://cadxfem.org/inf/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf|
     * Fast Minimum Storage Ray/Triangle Intersection} by Tomas Moller and Ben Trumbore.
     * @param ray - The ray.
     * @param p0 - The first vertex of the triangle.
     * @param p1 - The second vertex of the triangle.
     * @param p2 - The third vertex of the triangle.
     * @param [cullBackFaces = false] - If <code>true</code>, will only compute an intersection with the front face of the triangle
     *                  and return undefined for intersections with the back face.
     * @returns The intersection as a parametric distance along the ray, or undefined if there is no intersection.
     */
    function rayTriangleParametric(ray: Ray, p0: Cartesian3, p1: Cartesian3, p2: Cartesian3, cullBackFaces?: boolean): number;
    /**
     * Computes the intersection of a ray and a triangle as a Cartesian3 coordinate.
     *
     * Implements {@link https://cadxfem.org/inf/Fast%20MinimumStorage%20RayTriangle%20Intersection.pdf|
     * Fast Minimum Storage Ray/Triangle Intersection} by Tomas Moller and Ben Trumbore.
     * @param ray - The ray.
     * @param p0 - The first vertex of the triangle.
     * @param p1 - The second vertex of the triangle.
     * @param p2 - The third vertex of the triangle.
     * @param [cullBackFaces = false] - If <code>true</code>, will only compute an intersection with the front face of the triangle
     *                  and return undefined for intersections with the back face.
     * @param [result] - The <code>Cartesian3</code> onto which to store the result.
     * @returns The intersection point or undefined if there is no intersections.
     */
    function rayTriangle(ray: Ray, p0: Cartesian3, p1: Cartesian3, p2: Cartesian3, cullBackFaces?: boolean, result?: Cartesian3): Cartesian3;
    /**
     * Computes the intersection of a line segment and a triangle.
     * @param v0 - The an end point of the line segment.
     * @param v1 - The other end point of the line segment.
     * @param p0 - The first vertex of the triangle.
     * @param p1 - The second vertex of the triangle.
     * @param p2 - The third vertex of the triangle.
     * @param [cullBackFaces = false] - If <code>true</code>, will only compute an intersection with the front face of the triangle
     *                  and return undefined for intersections with the back face.
     * @param [result] - The <code>Cartesian3</code> onto which to store the result.
     * @returns The intersection point or undefined if there is no intersections.
     */
    function lineSegmentTriangle(v0: Cartesian3, v1: Cartesian3, p0: Cartesian3, p1: Cartesian3, p2: Cartesian3, cullBackFaces?: boolean, result?: Cartesian3): Cartesian3;
    /**
     * Computes the intersection points of a ray with a sphere.
     * @param ray - The ray.
     * @param sphere - The sphere.
     * @param [result] - The result onto which to store the result.
     * @returns The interval containing scalar points along the ray or undefined if there are no intersections.
     */
    function raySphere(ray: Ray, sphere: BoundingSphere, result?: Interval): Interval;
    /**
     * Computes the intersection points of a line segment with a sphere.
     * @param p0 - An end point of the line segment.
     * @param p1 - The other end point of the line segment.
     * @param sphere - The sphere.
     * @param [result] - The result onto which to store the result.
     * @returns The interval containing scalar points along the ray or undefined if there are no intersections.
     */
    function lineSegmentSphere(p0: Cartesian3, p1: Cartesian3, sphere: BoundingSphere, result?: Interval): Interval;
    /**
     * Computes the intersection points of a ray with an ellipsoid.
     * @param ray - The ray.
     * @param ellipsoid - The ellipsoid.
     * @returns The interval containing scalar points along the ray or undefined if there are no intersections.
     */
    function rayEllipsoid(ray: Ray, ellipsoid: Ellipsoid): Interval;
    /**
     * Provides the point along the ray which is nearest to the ellipsoid.
     * @param ray - The ray.
     * @param ellipsoid - The ellipsoid.
     * @returns The nearest planetodetic point on the ray.
     */
    function grazingAltitudeLocation(ray: Ray, ellipsoid: Ellipsoid): Cartesian3;
    /**
     * Computes the intersection of a line segment and a plane.
     * @example
     * const origin = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);
     * const normal = ellipsoid.geodeticSurfaceNormal(origin);
     * const plane = Cesium.Plane.fromPointNormal(origin, normal);
     *
     * const p0 = new Cesium.Cartesian3(...);
     * const p1 = new Cesium.Cartesian3(...);
     *
     * // find the intersection of the line segment from p0 to p1 and the tangent plane at origin.
     * const intersection = Cesium.IntersectionTests.lineSegmentPlane(p0, p1, plane);
     * @param endPoint0 - An end point of the line segment.
     * @param endPoint1 - The other end point of the line segment.
     * @param plane - The plane.
     * @param [result] - The object onto which to store the result.
     * @returns The intersection point or undefined if there is no intersection.
     */
    function lineSegmentPlane(endPoint0: Cartesian3, endPoint1: Cartesian3, plane: Plane, result?: Cartesian3): Cartesian3;
    /**
     * Computes the intersection of a triangle and a plane
     * @example
     * const origin = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);
     * const normal = ellipsoid.geodeticSurfaceNormal(origin);
     * const plane = Cesium.Plane.fromPointNormal(origin, normal);
     *
     * const p0 = new Cesium.Cartesian3(...);
     * const p1 = new Cesium.Cartesian3(...);
     * const p2 = new Cesium.Cartesian3(...);
     *
     * // convert the triangle composed of points (p0, p1, p2) to three triangles that don't cross the plane
     * const triangles = Cesium.IntersectionTests.trianglePlaneIntersection(p0, p1, p2, plane);
     * @param p0 - First point of the triangle
     * @param p1 - Second point of the triangle
     * @param p2 - Third point of the triangle
     * @param plane - Intersection plane
     * @returns An object with properties <code>positions</code> and <code>indices</code>, which are arrays that represent three triangles that do not cross the plane. (Undefined if no intersection exists)
     */
    function trianglePlaneIntersection(p0: Cartesian3, p1: Cartesian3, p2: Cartesian3, plane: Plane): any;
}

/**
 * Contains functions for operating on 2D triangles.
 */
export namespace Intersections2D {
    /**
     * Splits a 2D triangle at given axis-aligned threshold value and returns the resulting
     * polygon on a given side of the threshold.  The resulting polygon may have 0, 1, 2,
     * 3, or 4 vertices.
     * @example
     * const result = Cesium.Intersections2D.clipTriangleAtAxisAlignedThreshold(0.5, false, 0.2, 0.6, 0.4);
     * // result === [2, 0, -1, 1, 0, 0.25, -1, 1, 2, 0.5]
     * @param threshold - The threshold coordinate value at which to clip the triangle.
     * @param keepAbove - true to keep the portion of the triangle above the threshold, or false
     *                            to keep the portion below.
     * @param u0 - The coordinate of the first vertex in the triangle, in counter-clockwise order.
     * @param u1 - The coordinate of the second vertex in the triangle, in counter-clockwise order.
     * @param u2 - The coordinate of the third vertex in the triangle, in counter-clockwise order.
     * @param [result] - The array into which to copy the result.  If this parameter is not supplied,
     *                            a new array is constructed and returned.
     * @returns The polygon that results after the clip, specified as a list of
     *                     vertices.  The vertices are specified in counter-clockwise order.
     *                     Each vertex is either an index from the existing list (identified as
     *                     a 0, 1, or 2) or -1 indicating a new vertex not in the original triangle.
     *                     For new vertices, the -1 is followed by three additional numbers: the
     *                     index of each of the two original vertices forming the line segment that
     *                     the new vertex lies on, and the fraction of the distance from the first
     *                     vertex to the second one.
     */
    function clipTriangleAtAxisAlignedThreshold(threshold: number, keepAbove: boolean, u0: number, u1: number, u2: number, result?: number[]): number[];
    /**
     * Compute the barycentric coordinates of a 2D position within a 2D triangle.
     * @example
     * const result = Cesium.Intersections2D.computeBarycentricCoordinates(0.0, 0.0, 0.0, 1.0, -1, -0.5, 1, -0.5);
     * // result === new Cesium.Cartesian3(1.0 / 3.0, 1.0 / 3.0, 1.0 / 3.0);
     * @param x - The x coordinate of the position for which to find the barycentric coordinates.
     * @param y - The y coordinate of the position for which to find the barycentric coordinates.
     * @param x1 - The x coordinate of the triangle's first vertex.
     * @param y1 - The y coordinate of the triangle's first vertex.
     * @param x2 - The x coordinate of the triangle's second vertex.
     * @param y2 - The y coordinate of the triangle's second vertex.
     * @param x3 - The x coordinate of the triangle's third vertex.
     * @param y3 - The y coordinate of the triangle's third vertex.
     * @param [result] - The instance into to which to copy the result.  If this parameter
     *                     is undefined, a new instance is created and returned.
     * @returns The barycentric coordinates of the position within the triangle.
     */
    function computeBarycentricCoordinates(x: number, y: number, x1: number, y1: number, x2: number, y2: number, x3: number, y3: number, result?: Cartesian3): Cartesian3;
    /**
     * Compute the intersection between 2 line segments
     * @example
     * const result = Cesium.Intersections2D.computeLineSegmentLineSegmentIntersection(0.0, 0.0, 0.0, 2.0, -1, 1, 1, 1);
     * // result === new Cesium.Cartesian2(0.0, 1.0);
     * @param x00 - The x coordinate of the first line's first vertex.
     * @param y00 - The y coordinate of the first line's first vertex.
     * @param x01 - The x coordinate of the first line's second vertex.
     * @param y01 - The y coordinate of the first line's second vertex.
     * @param x10 - The x coordinate of the second line's first vertex.
     * @param y10 - The y coordinate of the second line's first vertex.
     * @param x11 - The x coordinate of the second line's second vertex.
     * @param y11 - The y coordinate of the second line's second vertex.
     * @param [result] - The instance into to which to copy the result. If this parameter
     *                     is undefined, a new instance is created and returned.
     * @returns The intersection point, undefined if there is no intersection point or lines are coincident.
     */
    function computeLineSegmentLineSegmentIntersection(x00: number, y00: number, x01: number, y01: number, x10: number, y10: number, x11: number, y11: number, result?: Cartesian2): Cartesian2;
}

/**
 * Represents the closed interval [start, stop].
 * @param [start = 0.0] - The beginning of the interval.
 * @param [stop = 0.0] - The end of the interval.
 */
export class Interval {
    constructor(start?: number, stop?: number);
    /**
     * The beginning of the interval.
     */
    start: number;
    /**
     * The end of the interval.
     */
    stop: number;
}

/**
 * Default settings for accessing the Cesium ion API.
 *
 * An ion access token is only required if you are using any ion related APIs.
 * A default access token is provided for evaluation purposes only.
 * Sign up for a free ion account and get your own access token at {@link https://cesium.com}
 */
export namespace Ion {
    /**
     * Gets or sets the default Cesium ion access token.
     */
    var defaultAccessToken: string;
    /**
     * Gets or sets the default Cesium ion server.
     */
    var defaultServer: string | Resource;
}

/**
 * Provides geocoding through Cesium ion.
 * @param options - Object with the following properties:
 * @param options.scene - The scene
 * @param [options.accessToken = Ion.defaultAccessToken] - The access token to use.
 * @param [options.server = Ion.defaultServer] - The resource to the Cesium ion API server.
 */
export class IonGeocoderService {
    constructor(options: {
        scene: Scene;
        accessToken?: string;
        server?: string | Resource;
    });
    /**
     * Gets the credit to display after a geocode is performed. Typically this is used to credit
     * the geocoder service.
     */
    readonly credit: Credit | undefined;
    /**
     * @param query - The query to be sent to the geocoder service
     * @param [type = GeocodeType.SEARCH] - The type of geocode to perform.
     */
    geocode(query: string, type?: GeocodeType): Promise<GeocoderService.Result[]>;
}

/**
 * A {@link Resource} instance that encapsulates Cesium ion asset access.
 * This object is normally not instantiated directly, use {@link IonResource.fromAssetId}.
 * @param endpoint - The result of the Cesium ion asset endpoint service.
 * @param endpointResource - The resource used to retrieve the endpoint.
 */
export class IonResource extends Resource {
    constructor(endpoint: any, endpointResource: Resource);
    /**
     * Asynchronously creates an instance.
     * @example
     * // Load a Cesium3DTileset with asset ID of 124624234
     * try {
     *   const resource = await Cesium.IonResource.fromAssetId(124624234);
     *   const tileset = await Cesium.Cesium3DTileset.fromUrl(resource);
     *   scene.primitives.add(tileset);
     * } catch (error) {
     *   console.error(`Error creating tileset: ${error}`);
     * }
     * @example
     * //Load a CZML file with asset ID of 10890
     * Cesium.IonResource.fromAssetId(10890)
     *   .then(function (resource) {
     *     viewer.dataSources.add(Cesium.CzmlDataSource.load(resource));
     *   });
     * @param assetId - The Cesium ion asset id.
     * @param [options] - An object with the following properties:
     * @param [options.accessToken = Ion.defaultAccessToken] - The access token to use.
     * @param [options.server = Ion.defaultServer] - The resource to the Cesium ion API server.
     * @returns A Promise to am instance representing the Cesium ion Asset.
     */
    static fromAssetId(assetId: number, options?: {
        accessToken?: string;
        server?: string | Resource;
    }): Promise<IonResource>;
    /**
     * Gets the credits required for attribution of the asset.
     */
    readonly credits: Credit[];
    /**
     * Duplicates a Resource instance.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Resource instance if one was not provided.
     */
    clone(result?: Resource): Resource;
    /**
     * Asynchronously loads the given image resource.  Returns a promise that will resolve to
     * an {@link https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap|ImageBitmap} if <code>preferImageBitmap</code> is true and the browser supports <code>createImageBitmap</code> or otherwise an
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement|Image} once loaded, or reject if the image failed to load.
     * @example
     * // load a single image asynchronously
     * resource.fetchImage().then(function(image) {
     *     // use the loaded image
     * }).catch(function(error) {
     *     // an error occurred
     * });
     *
     * // load several images in parallel
     * Promise.all([resource1.fetchImage(), resource2.fetchImage()]).then(function(images) {
     *     // images is an array containing all the loaded images
     * });
     * @param [options] - An object with the following properties.
     * @param [options.preferBlob = false] - If true, we will load the image via a blob.
     * @param [options.preferImageBitmap = false] - If true, image will be decoded during fetch and an <code>ImageBitmap</code> is returned.
     * @param [options.flipY = false] - If true, image will be vertically flipped during decode. Only applies if the browser supports <code>createImageBitmap</code>.
     * @param [options.skipColorSpaceConversion = false] - If true, any custom gamma or color profiles in the image will be ignored. Only applies if the browser supports <code>createImageBitmap</code>.
     * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
     */
    fetchImage(options?: {
        preferBlob?: boolean;
        preferImageBitmap?: boolean;
        flipY?: boolean;
        skipColorSpaceConversion?: boolean;
    }): Promise<ImageBitmap | HTMLImageElement> | undefined;
}

/**
 * Constants related to ISO8601 support.
 */
export namespace Iso8601 {
    /**
     * A {@link JulianDate} representing the earliest time representable by an ISO8601 date.
     * This is equivalent to the date string '0000-01-01T00:00:00Z'
     */
    const MINIMUM_VALUE: JulianDate;
    /**
     * A {@link JulianDate} representing the latest time representable by an ISO8601 date.
     * This is equivalent to the date string '9999-12-31T24:00:00Z'
     */
    const MAXIMUM_VALUE: JulianDate;
    /**
     * A {@link TimeInterval} representing the largest interval representable by an ISO8601 interval.
     * This is equivalent to the interval string '0000-01-01T00:00:00Z/9999-12-31T24:00:00Z'
     */
    const MAXIMUM_INTERVAL: TimeInterval;
}

/**
 * Represents an astronomical Julian date, which is the number of days since noon on January 1, -4712 (4713 BC).
 * For increased precision, this class stores the whole number part of the date and the seconds
 * part of the date in separate components.  In order to be safe for arithmetic and represent
 * leap seconds, the date is always stored in the International Atomic Time standard
 * {@link TimeStandard.TAI}.
 * @param [julianDayNumber = 0.0] - The Julian Day Number representing the number of whole days.  Fractional days will also be handled correctly.
 * @param [secondsOfDay = 0.0] - The number of seconds into the current Julian Day Number.  Fractional seconds, negative seconds and seconds greater than a day will be handled correctly.
 * @param [timeStandard = TimeStandard.UTC] - The time standard in which the first two parameters are defined.
 */
export class JulianDate {
    constructor(julianDayNumber?: number, secondsOfDay?: number, timeStandard?: TimeStandard);
    /**
     * Gets or sets the number of whole days.
     */
    dayNumber: number;
    /**
     * Gets or sets the number of seconds into the current day.
     */
    secondsOfDay: number;
    /**
     * Creates a new instance from a GregorianDate.
     * @param date - A GregorianDate.
     * @param [result] - An existing instance to use for the result.
     * @returns The modified result parameter or a new instance if none was provided.
     */
    static fromGregorianDate(date: GregorianDate, result?: JulianDate): JulianDate;
    /**
     * Creates a new instance from a JavaScript Date.
     * @param date - A JavaScript Date.
     * @param [result] - An existing instance to use for the result.
     * @returns The modified result parameter or a new instance if none was provided.
     */
    static fromDate(date: Date, result?: JulianDate): JulianDate;
    /**
     * Creates a new instance from a from an {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} date.
     * This method is superior to <code>Date.parse</code> because it will handle all valid formats defined by the ISO 8601
     * specification, including leap seconds and sub-millisecond times, which discarded by most JavaScript implementations.
     * @param iso8601String - An ISO 8601 date.
     * @param [result] - An existing instance to use for the result.
     * @returns The modified result parameter or a new instance if none was provided.
     */
    static fromIso8601(iso8601String: string, result?: JulianDate): JulianDate;
    /**
     * Creates a new instance that represents the current system time.
     * This is equivalent to calling <code>JulianDate.fromDate(new Date());</code>.
     * @param [result] - An existing instance to use for the result.
     * @returns The modified result parameter or a new instance if none was provided.
     */
    static now(result?: JulianDate): JulianDate;
    /**
     * Creates a {@link GregorianDate} from the provided instance.
     * @param julianDate - The date to be converted.
     * @param [result] - An existing instance to use for the result.
     * @returns The modified result parameter or a new instance if none was provided.
     */
    static toGregorianDate(julianDate: JulianDate, result?: GregorianDate): GregorianDate;
    /**
     * Creates a JavaScript Date from the provided instance.
     * Since JavaScript dates are only accurate to the nearest millisecond and
     * cannot represent a leap second, consider using {@link JulianDate.toGregorianDate} instead.
     * If the provided JulianDate is during a leap second, the previous second is used.
     * @param julianDate - The date to be converted.
     * @returns A new instance representing the provided date.
     */
    static toDate(julianDate: JulianDate): Date;
    /**
     * Creates an ISO8601 representation of the provided date.
     * @param julianDate - The date to be converted.
     * @param [precision] - The number of fractional digits used to represent the seconds component.  By default, the most precise representation is used.
     * @returns The ISO8601 representation of the provided date.
     */
    static toIso8601(julianDate: JulianDate, precision?: number): string;
    /**
     * Duplicates a JulianDate instance.
     * @param julianDate - The date to duplicate.
     * @param [result] - An existing instance to use for the result.
     * @returns The modified result parameter or a new instance if none was provided. Returns undefined if julianDate is undefined.
     */
    static clone(julianDate: JulianDate, result?: JulianDate): JulianDate;
    /**
     * Compares two instances.
     * @param left - The first instance.
     * @param right - The second instance.
     * @returns A negative value if left is less than right, a positive value if left is greater than right, or zero if left and right are equal.
     */
    static compare(left: JulianDate, right: JulianDate): number;
    /**
     * Compares two instances and returns <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [left] - The first instance.
     * @param [right] - The second instance.
     * @returns <code>true</code> if the dates are equal; otherwise, <code>false</code>.
     */
    static equals(left?: JulianDate, right?: JulianDate): boolean;
    /**
     * Compares two instances and returns <code>true</code> if they are within <code>epsilon</code> seconds of
     * each other.  That is, in order for the dates to be considered equal (and for
     * this function to return <code>true</code>), the absolute value of the difference between them, in
     * seconds, must be less than <code>epsilon</code>.
     * @param [left] - The first instance.
     * @param [right] - The second instance.
     * @param [epsilon = 0] - The maximum number of seconds that should separate the two instances.
     * @returns <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.
     */
    static equalsEpsilon(left?: JulianDate, right?: JulianDate, epsilon?: number): boolean;
    /**
     * Computes the total number of whole and fractional days represented by the provided instance.
     * @param julianDate - The date.
     * @returns The Julian date as single floating point number.
     */
    static totalDays(julianDate: JulianDate): number;
    /**
     * Computes the difference in seconds between the provided instance.
     * @param left - The first instance.
     * @param right - The second instance.
     * @returns The difference, in seconds, when subtracting <code>right</code> from <code>left</code>.
     */
    static secondsDifference(left: JulianDate, right: JulianDate): number;
    /**
     * Computes the difference in days between the provided instance.
     * @param left - The first instance.
     * @param right - The second instance.
     * @returns The difference, in days, when subtracting <code>right</code> from <code>left</code>.
     */
    static daysDifference(left: JulianDate, right: JulianDate): number;
    /**
     * Computes the number of seconds the provided instance is ahead of UTC.
     * @param julianDate - The date.
     * @returns The number of seconds the provided instance is ahead of UTC
     */
    static computeTaiMinusUtc(julianDate: JulianDate): number;
    /**
     * Adds the provided number of seconds to the provided date instance.
     * @param julianDate - The date.
     * @param seconds - The number of seconds to add or subtract.
     * @param result - An existing instance to use for the result.
     * @returns The modified result parameter.
     */
    static addSeconds(julianDate: JulianDate, seconds: number, result: JulianDate): JulianDate;
    /**
     * Adds the provided number of minutes to the provided date instance.
     * @param julianDate - The date.
     * @param minutes - The number of minutes to add or subtract.
     * @param result - An existing instance to use for the result.
     * @returns The modified result parameter.
     */
    static addMinutes(julianDate: JulianDate, minutes: number, result: JulianDate): JulianDate;
    /**
     * Adds the provided number of hours to the provided date instance.
     * @param julianDate - The date.
     * @param hours - The number of hours to add or subtract.
     * @param result - An existing instance to use for the result.
     * @returns The modified result parameter.
     */
    static addHours(julianDate: JulianDate, hours: number, result: JulianDate): JulianDate;
    /**
     * Adds the provided number of days to the provided date instance.
     * @param julianDate - The date.
     * @param days - The number of days to add or subtract.
     * @param result - An existing instance to use for the result.
     * @returns The modified result parameter.
     */
    static addDays(julianDate: JulianDate, days: number, result: JulianDate): JulianDate;
    /**
     * Compares the provided instances and returns <code>true</code> if <code>left</code> is earlier than <code>right</code>, <code>false</code> otherwise.
     * @param left - The first instance.
     * @param right - The second instance.
     * @returns <code>true</code> if <code>left</code> is earlier than <code>right</code>, <code>false</code> otherwise.
     */
    static lessThan(left: JulianDate, right: JulianDate): boolean;
    /**
     * Compares the provided instances and returns <code>true</code> if <code>left</code> is earlier than or equal to <code>right</code>, <code>false</code> otherwise.
     * @param left - The first instance.
     * @param right - The second instance.
     * @returns <code>true</code> if <code>left</code> is earlier than or equal to <code>right</code>, <code>false</code> otherwise.
     */
    static lessThanOrEquals(left: JulianDate, right: JulianDate): boolean;
    /**
     * Compares the provided instances and returns <code>true</code> if <code>left</code> is later than <code>right</code>, <code>false</code> otherwise.
     * @param left - The first instance.
     * @param right - The second instance.
     * @returns <code>true</code> if <code>left</code> is later than <code>right</code>, <code>false</code> otherwise.
     */
    static greaterThan(left: JulianDate, right: JulianDate): boolean;
    /**
     * Compares the provided instances and returns <code>true</code> if <code>left</code> is later than or equal to <code>right</code>, <code>false</code> otherwise.
     * @param left - The first instance.
     * @param right - The second instance.
     * @returns <code>true</code> if <code>left</code> is later than or equal to <code>right</code>, <code>false</code> otherwise.
     */
    static greaterThanOrEquals(left: JulianDate, right: JulianDate): boolean;
    /**
     * Duplicates this instance.
     * @param [result] - An existing instance to use for the result.
     * @returns The modified result parameter or a new instance if none was provided.
     */
    clone(result?: JulianDate): JulianDate;
    /**
     * Compares this and the provided instance and returns <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [right] - The second instance.
     * @returns <code>true</code> if the dates are equal; otherwise, <code>false</code>.
     */
    equals(right?: JulianDate): boolean;
    /**
     * Compares this and the provided instance and returns <code>true</code> if they are within <code>epsilon</code> seconds of
     * each other.  That is, in order for the dates to be considered equal (and for
     * this function to return <code>true</code>), the absolute value of the difference between them, in
     * seconds, must be less than <code>epsilon</code>.
     * @param [right] - The second instance.
     * @param [epsilon = 0] - The maximum number of seconds that should separate the two instances.
     * @returns <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.
     */
    equalsEpsilon(right?: JulianDate, epsilon?: number): boolean;
    /**
     * Creates a string representing this date in ISO8601 format.
     * @returns A string representing this date in ISO8601 format.
     */
    toString(): string;
    /**
     * Gets or sets the list of leap seconds used throughout Cesium.
     */
    static leapSeconds: LeapSecond[];
}

/**
 * This enumerated type is for representing keyboard modifiers. These are keys
 * that are held down in addition to other event types.
 */
export enum KeyboardEventModifier {
    /**
     * Represents the shift key being held down.
     */
    SHIFT = 0,
    /**
     * Represents the control key being held down.
     */
    CTRL = 1,
    /**
     * Represents the alt key being held down.
     */
    ALT = 2
}

/**
 * An {@link InterpolationAlgorithm} for performing Lagrange interpolation.
 */
export namespace LagrangePolynomialApproximation {
    /**
     * Given the desired degree, returns the number of data points required for interpolation.
     * @param degree - The desired degree of interpolation.
     * @returns The number of required data points needed for the desired degree of interpolation.
     */
    function getRequiredDataPoints(degree: number): number;
    /**
     * Interpolates values using Lagrange Polynomial Approximation.
     * @param x - The independent variable for which the dependent variables will be interpolated.
     * @param xTable - The array of independent variables to use to interpolate.  The values
     * in this array must be in increasing order and the same value must not occur twice in the array.
     * @param yTable - The array of dependent variables to use to interpolate.  For a set of three
     * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.
     * @param yStride - The number of dependent variable values in yTable corresponding to
     * each independent variable value in xTable.
     * @param [result] - An existing array into which to store the result.
     * @returns The array of interpolated values, or the result parameter if one was provided.
     */
    function interpolateOrderZero(x: number, xTable: number[], yTable: number[], yStride: number, result?: number[]): number[];
}

/**
 * Describes a single leap second, which is constructed from a {@link JulianDate} and a
 * numerical offset representing the number of seconds TAI is ahead of the UTC time standard.
 * @param [date] - A Julian date representing the time of the leap second.
 * @param [offset] - The cumulative number of seconds that TAI is ahead of UTC at the provided date.
 */
export class LeapSecond {
    constructor(date?: JulianDate, offset?: number);
    /**
     * Gets or sets the date at which this leap second occurs.
     */
    julianDate: JulianDate;
    /**
     * Gets or sets the cumulative number of seconds between the UTC and TAI time standards at the time
     * of this leap second.
     */
    offset: number;
}

/**
 * An {@link InterpolationAlgorithm} for performing linear interpolation.
 */
export namespace LinearApproximation {
    /**
     * Given the desired degree, returns the number of data points required for interpolation.
     * Since linear interpolation can only generate a first degree polynomial, this function
     * always returns 2.
     * @param degree - The desired degree of interpolation.
     * @returns This function always returns 2.
     */
    function getRequiredDataPoints(degree: number): number;
    /**
     * Interpolates values using linear approximation.
     * @param x - The independent variable for which the dependent variables will be interpolated.
     * @param xTable - The array of independent variables to use to interpolate.  The values
     * in this array must be in increasing order and the same value must not occur twice in the array.
     * @param yTable - The array of dependent variables to use to interpolate.  For a set of three
     * dependent values (p,q,w) at time 1 and time 2 this should be as follows: {p1, q1, w1, p2, q2, w2}.
     * @param yStride - The number of dependent variable values in yTable corresponding to
     * each independent variable value in xTable.
     * @param [result] - An existing array into which to store the result.
     * @returns The array of interpolated values, or the result parameter if one was provided.
     */
    function interpolateOrderZero(x: number, xTable: number[], yTable: number[], yStride: number, result?: number[]): number[];
}

/**
 * A spline that uses piecewise linear interpolation to create a curve.
 * @example
 * const times = [ 0.0, 1.5, 3.0, 4.5, 6.0 ];
 * const spline = new Cesium.LinearSpline({
 *     times : times,
 *     points : [
 *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),
 *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),
 *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),
 *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),
 *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)
 *     ]
 * });
 *
 * const p0 = spline.evaluate(times[0]);
 * @param options - Object with the following properties:
 * @param options.times - An array of strictly increasing, unit-less, floating-point times at each point.
 *                The values are in no way connected to the clock time. They are the parameterization for the curve.
 * @param options.points - The array of control points.
 */
export class LinearSpline {
    constructor(options: {
        times: number[];
        points: number[] | Cartesian3[];
    });
    /**
     * An array of times for the control points.
     */
    readonly times: number[];
    /**
     * An array of {@link Cartesian3} control points.
     */
    readonly points: number[] | Cartesian3[];
    /**
     * Finds an index <code>i</code> in <code>times</code> such that the parameter
     * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.
     * @param time - The time.
     * @returns The index for the element at the start of the interval.
     */
    findTimeInterval(time: number): number;
    /**
     * Wraps the given time to the period covered by the spline.
     * @param time - The time.
     * @returns The time, wrapped around to the updated animation.
     */
    wrapTime(time: number): number;
    /**
     * Clamps the given time to the period covered by the spline.
     * @param time - The time.
     * @returns The time, clamped to the animation period.
     */
    clampTime(time: number): number;
    /**
     * Evaluates the curve at a given time.
     * @param time - The time at which to evaluate the curve.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new instance of the point on the curve at the given time.
     */
    evaluate(time: number, result?: Cartesian3): number | Cartesian3;
}

/**
 * Defines how geodetic ellipsoid coordinates ({@link Cartographic}) project to a
 * flat map like Cesium's 2D and Columbus View modes.
 */
export class MapProjection {
    constructor();
    /**
     * Gets the {@link Ellipsoid}.
     */
    readonly ellipsoid: Ellipsoid;
    /**
     * Projects {@link Cartographic} coordinates, in radians, to projection-specific map coordinates, in meters.
     * @param cartographic - The coordinates to project.
     * @param [result] - An instance into which to copy the result.  If this parameter is
     *        undefined, a new instance is created and returned.
     * @returns The projected coordinates.  If the result parameter is not undefined, the
     *          coordinates are copied there and that instance is returned.  Otherwise, a new instance is
     *          created and returned.
     */
    project(cartographic: Cartographic, result?: Cartesian3): Cartesian3;
    /**
     * Unprojects projection-specific map {@link Cartesian3} coordinates, in meters, to {@link Cartographic}
     * coordinates, in radians.
     * @param cartesian - The Cartesian position to unproject with height (z) in meters.
     * @param [result] - An instance into which to copy the result.  If this parameter is
     *        undefined, a new instance is created and returned.
     * @returns The unprojected coordinates.  If the result parameter is not undefined, the
     *          coordinates are copied there and that instance is returned.  Otherwise, a new instance is
     *          created and returned.
     */
    unproject(cartesian: Cartesian3, result?: Cartographic): Cartographic;
}

/**
 * Math functions.
 */
export namespace Math {
    /**
     * 0.1
     */
    const EPSILON1 = 0.1;
    /**
     * 0.01
     */
    const EPSILON2 = 0.01;
    /**
     * 0.001
     */
    const EPSILON3 = 0.001;
    /**
     * 0.0001
     */
    const EPSILON4 = 0.0001;
    /**
     * 0.00001
     */
    const EPSILON5 = 0.00001;
    /**
     * 0.000001
     */
    const EPSILON6 = 0.000001;
    /**
     * 0.0000001
     */
    const EPSILON7 = 1e-7;
    /**
     * 0.00000001
     */
    const EPSILON8 = 1e-8;
    /**
     * 0.000000001
     */
    const EPSILON9 = 1e-9;
    /**
     * 0.0000000001
     */
    const EPSILON10 = 1e-10;
    /**
     * 0.00000000001
     */
    const EPSILON11 = 1e-11;
    /**
     * 0.000000000001
     */
    const EPSILON12 = 1e-12;
    /**
     * 0.0000000000001
     */
    const EPSILON13 = 1e-13;
    /**
     * 0.00000000000001
     */
    const EPSILON14 = 1e-14;
    /**
     * 0.000000000000001
     */
    const EPSILON15 = 1e-15;
    /**
     * 0.0000000000000001
     */
    const EPSILON16 = 1e-16;
    /**
     * 0.00000000000000001
     */
    const EPSILON17 = 1e-17;
    /**
     * 0.000000000000000001
     */
    const EPSILON18 = 1e-18;
    /**
     * 0.0000000000000000001
     */
    const EPSILON19 = 1e-19;
    /**
     * 0.00000000000000000001
     */
    const EPSILON20 = 1e-20;
    /**
     * 0.000000000000000000001
     */
    const EPSILON21 = 1e-21;
    /**
     * The gravitational parameter of the Earth in meters cubed
     * per second squared as defined by the WGS84 model: 3.986004418e14
     */
    const GRAVITATIONALPARAMETER = 398600441800000;
    /**
     * Radius of the sun in meters: 6.955e8
     */
    const SOLAR_RADIUS = 695500000;
    /**
     * The mean radius of the moon, according to the "Report of the IAU/IAG Working Group on
     * Cartographic Coordinates and Rotational Elements of the Planets and satellites: 2000",
     * Celestial Mechanics 82: 83-110, 2002.
     */
    const LUNAR_RADIUS = 1737400;
    /**
     * 64 * 1024
     */
    const SIXTY_FOUR_KILOBYTES: number;
    /**
     * 4 * 1024 * 1024 * 1024
     */
    const FOUR_GIGABYTES: number;
    /**
     * Returns the sign of the value; 1 if the value is positive, -1 if the value is
     * negative, or 0 if the value is 0.
     * @param value - The value to return the sign of.
     * @returns The sign of value.
     */
    function sign(value: number): number;
    /**
     * Returns 1.0 if the given value is positive or zero, and -1.0 if it is negative.
     * This is similar to {@link Math#sign} except that returns 1.0 instead of
     * 0.0 when the input value is 0.0.
     * @param value - The value to return the sign of.
     * @returns The sign of value.
     */
    function signNotZero(value: number): number;
    /**
     * Converts a scalar value in the range [-1.0, 1.0] to a SNORM in the range [0, rangeMaximum]
     * @param value - The scalar value in the range [-1.0, 1.0]
     * @param [rangeMaximum = 255] - The maximum value in the mapped range, 255 by default.
     * @returns A SNORM value, where 0 maps to -1.0 and rangeMaximum maps to 1.0.
     */
    function toSNorm(value: number, rangeMaximum?: number): number;
    /**
     * Converts a SNORM value in the range [0, rangeMaximum] to a scalar in the range [-1.0, 1.0].
     * @param value - SNORM value in the range [0, rangeMaximum]
     * @param [rangeMaximum = 255] - The maximum value in the SNORM range, 255 by default.
     * @returns Scalar in the range [-1.0, 1.0].
     */
    function fromSNorm(value: number, rangeMaximum?: number): number;
    /**
     * Converts a scalar value in the range [rangeMinimum, rangeMaximum] to a scalar in the range [0.0, 1.0]
     * @param value - The scalar value in the range [rangeMinimum, rangeMaximum]
     * @param rangeMinimum - The minimum value in the mapped range.
     * @param rangeMaximum - The maximum value in the mapped range.
     * @returns A scalar value, where rangeMinimum maps to 0.0 and rangeMaximum maps to 1.0.
     */
    function normalize(value: number, rangeMinimum: number, rangeMaximum: number): number;
    /**
     * Returns the hyperbolic sine of a number.
     * The hyperbolic sine of <em>value</em> is defined to be
     * (<em>e<sup>x</sup>&nbsp;-&nbsp;e<sup>-x</sup></em>)/2.0
     * where <i>e</i> is Euler's number, approximately 2.71828183.
     *
     * <p>Special cases:
     *   <ul>
     *     <li>If the argument is NaN, then the result is NaN.</li>
     *
     *     <li>If the argument is infinite, then the result is an infinity
     *     with the same sign as the argument.</li>
     *
     *     <li>If the argument is zero, then the result is a zero with the
     *     same sign as the argument.</li>
     *   </ul>
     * </p>
     * @param value - The number whose hyperbolic sine is to be returned.
     * @returns The hyperbolic sine of <code>value</code>.
     */
    function sinh(value: number): number;
    /**
     * Returns the hyperbolic cosine of a number.
     * The hyperbolic cosine of <strong>value</strong> is defined to be
     * (<em>e<sup>x</sup>&nbsp;+&nbsp;e<sup>-x</sup></em>)/2.0
     * where <i>e</i> is Euler's number, approximately 2.71828183.
     *
     * <p>Special cases:
     *   <ul>
     *     <li>If the argument is NaN, then the result is NaN.</li>
     *
     *     <li>If the argument is infinite, then the result is positive infinity.</li>
     *
     *     <li>If the argument is zero, then the result is 1.0.</li>
     *   </ul>
     * </p>
     * @param value - The number whose hyperbolic cosine is to be returned.
     * @returns The hyperbolic cosine of <code>value</code>.
     */
    function cosh(value: number): number;
    /**
     * Computes the linear interpolation of two values.
     * @example
     * const n = Cesium.Math.lerp(0.0, 2.0, 0.5); // returns 1.0
     * @param p - The start value to interpolate.
     * @param q - The end value to interpolate.
     * @param time - The time of interpolation generally in the range <code>[0.0, 1.0]</code>.
     * @returns The linearly interpolated value.
     */
    function lerp(p: number, q: number, time: number): number;
    /**
     * pi
     */
    const PI: number;
    /**
     * 1/pi
     */
    const ONE_OVER_PI: number;
    /**
     * pi/2
     */
    const PI_OVER_TWO: number;
    /**
     * pi/3
     */
    const PI_OVER_THREE: number;
    /**
     * pi/4
     */
    const PI_OVER_FOUR: number;
    /**
     * pi/6
     */
    const PI_OVER_SIX: number;
    /**
     * 3pi/2
     */
    const THREE_PI_OVER_TWO: number;
    /**
     * 2pi
     */
    const TWO_PI: number;
    /**
     * 1/2pi
     */
    const ONE_OVER_TWO_PI: number;
    /**
     * The number of radians in a degree.
     */
    const RADIANS_PER_DEGREE: number;
    /**
     * The number of degrees in a radian.
     */
    const DEGREES_PER_RADIAN: number;
    /**
     * The number of radians in an arc second.
     */
    const RADIANS_PER_ARCSECOND: number;
    /**
     * Converts degrees to radians.
     * @param degrees - The angle to convert in degrees.
     * @returns The corresponding angle in radians.
     */
    function toRadians(degrees: number): number;
    /**
     * Converts radians to degrees.
     * @param radians - The angle to convert in radians.
     * @returns The corresponding angle in degrees.
     */
    function toDegrees(radians: number): number;
    /**
     * Converts a longitude value, in radians, to the range [<code>-Math.PI</code>, <code>Math.PI</code>).
     * @example
     * // Convert 270 degrees to -90 degrees longitude
     * const longitude = Cesium.Math.convertLongitudeRange(Cesium.Math.toRadians(270.0));
     * @param angle - The longitude value, in radians, to convert to the range [<code>-Math.PI</code>, <code>Math.PI</code>).
     * @returns The equivalent longitude value in the range [<code>-Math.PI</code>, <code>Math.PI</code>).
     */
    function convertLongitudeRange(angle: number): number;
    /**
     * Convenience function that clamps a latitude value, in radians, to the range [<code>-Math.PI/2</code>, <code>Math.PI/2</code>).
     * Useful for sanitizing data before use in objects requiring correct range.
     * @example
     * // Clamp 108 degrees latitude to 90 degrees latitude
     * const latitude = Cesium.Math.clampToLatitudeRange(Cesium.Math.toRadians(108.0));
     * @param angle - The latitude value, in radians, to clamp to the range [<code>-Math.PI/2</code>, <code>Math.PI/2</code>).
     * @returns The latitude value clamped to the range [<code>-Math.PI/2</code>, <code>Math.PI/2</code>).
     */
    function clampToLatitudeRange(angle: number): number;
    /**
     * Produces an angle in the range -Pi <= angle <= Pi which is equivalent to the provided angle.
     * @param angle - in radians
     * @returns The angle in the range [<code>-Math.PI</code>, <code>Math.PI</code>].
     */
    function negativePiToPi(angle: number): number;
    /**
     * Produces an angle in the range 0 <= angle <= 2Pi which is equivalent to the provided angle.
     * @param angle - in radians
     * @returns The angle in the range [0, <code>Math.TWO_PI</code>].
     */
    function zeroToTwoPi(angle: number): number;
    /**
     * The modulo operation that also works for negative dividends.
     * @param m - The dividend.
     * @param n - The divisor.
     * @returns The remainder.
     */
    function mod(m: number, n: number): number;
    /**
     * Determines if two values are equal using an absolute or relative tolerance test. This is useful
     * to avoid problems due to roundoff error when comparing floating-point values directly. The values are
     * first compared using an absolute tolerance test. If that fails, a relative tolerance test is performed.
     * Use this test if you are unsure of the magnitudes of left and right.
     * @example
     * const a = Cesium.Math.equalsEpsilon(0.0, 0.01, Cesium.Math.EPSILON2); // true
     * const b = Cesium.Math.equalsEpsilon(0.0, 0.1, Cesium.Math.EPSILON2);  // false
     * const c = Cesium.Math.equalsEpsilon(3699175.1634344, 3699175.2, Cesium.Math.EPSILON7); // true
     * const d = Cesium.Math.equalsEpsilon(3699175.1634344, 3699175.2, Cesium.Math.EPSILON9); // false
     * @param left - The first value to compare.
     * @param right - The other value to compare.
     * @param [relativeEpsilon = 0] - The maximum inclusive delta between <code>left</code> and <code>right</code> for the relative tolerance test.
     * @param [absoluteEpsilon = relativeEpsilon] - The maximum inclusive delta between <code>left</code> and <code>right</code> for the absolute tolerance test.
     * @returns <code>true</code> if the values are equal within the epsilon; otherwise, <code>false</code>.
     */
    function equalsEpsilon(left: number, right: number, relativeEpsilon?: number, absoluteEpsilon?: number): boolean;
    /**
     * Determines if the left value is less than the right value. If the two values are within
     * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns false.
     * @param left - The first number to compare.
     * @param right - The second number to compare.
     * @param absoluteEpsilon - The absolute epsilon to use in comparison.
     * @returns <code>true</code> if <code>left</code> is less than <code>right</code> by more than
     *          <code>absoluteEpsilon<code>. <code>false</code> if <code>left</code> is greater or if the two
     *          values are nearly equal.
     */
    function lessThan(left: number, right: number, absoluteEpsilon: number): boolean;
    /**
     * Determines if the left value is less than or equal to the right value. If the two values are within
     * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns true.
     * @param left - The first number to compare.
     * @param right - The second number to compare.
     * @param absoluteEpsilon - The absolute epsilon to use in comparison.
     * @returns <code>true</code> if <code>left</code> is less than <code>right</code> or if the
     *          the values are nearly equal.
     */
    function lessThanOrEquals(left: number, right: number, absoluteEpsilon: number): boolean;
    /**
     * Determines if the left value is greater the right value. If the two values are within
     * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns false.
     * @param left - The first number to compare.
     * @param right - The second number to compare.
     * @param absoluteEpsilon - The absolute epsilon to use in comparison.
     * @returns <code>true</code> if <code>left</code> is greater than <code>right</code> by more than
     *          <code>absoluteEpsilon<code>. <code>false</code> if <code>left</code> is less or if the two
     *          values are nearly equal.
     */
    function greaterThan(left: number, right: number, absoluteEpsilon: number): boolean;
    /**
     * Determines if the left value is greater than or equal to the right value. If the two values are within
     * <code>absoluteEpsilon</code> of each other, they are considered equal and this function returns true.
     * @param left - The first number to compare.
     * @param right - The second number to compare.
     * @param absoluteEpsilon - The absolute epsilon to use in comparison.
     * @returns <code>true</code> if <code>left</code> is greater than <code>right</code> or if the
     *          the values are nearly equal.
     */
    function greaterThanOrEquals(left: number, right: number, absoluteEpsilon: number): boolean;
    /**
     * Computes the factorial of the provided number.
     * @example
     * //Compute 7!, which is equal to 5040
     * const computedFactorial = Cesium.Math.factorial(7);
     * @param n - The number whose factorial is to be computed.
     * @returns The factorial of the provided number or undefined if the number is less than 0.
     */
    function factorial(n: number): number;
    /**
     * Increments a number with a wrapping to a minimum value if the number exceeds the maximum value.
     * @example
     * const n = Cesium.Math.incrementWrap(5, 10, 0); // returns 6
     * const m = Cesium.Math.incrementWrap(10, 10, 0); // returns 0
     * @param [n] - The number to be incremented.
     * @param [maximumValue] - The maximum incremented value before rolling over to the minimum value.
     * @param [minimumValue = 0.0] - The number reset to after the maximum value has been exceeded.
     * @returns The incremented number.
     */
    function incrementWrap(n?: number, maximumValue?: number, minimumValue?: number): number;
    /**
     * Determines if a non-negative integer is a power of two.
     * The maximum allowed input is (2^32)-1 due to 32-bit bitwise operator limitation in Javascript.
     * @example
     * const t = Cesium.Math.isPowerOfTwo(16); // true
     * const f = Cesium.Math.isPowerOfTwo(20); // false
     * @param n - The integer to test in the range [0, (2^32)-1].
     * @returns <code>true</code> if the number if a power of two; otherwise, <code>false</code>.
     */
    function isPowerOfTwo(n: number): boolean;
    /**
     * Computes the next power-of-two integer greater than or equal to the provided non-negative integer.
     * The maximum allowed input is 2^31 due to 32-bit bitwise operator limitation in Javascript.
     * @example
     * const n = Cesium.Math.nextPowerOfTwo(29); // 32
     * const m = Cesium.Math.nextPowerOfTwo(32); // 32
     * @param n - The integer to test in the range [0, 2^31].
     * @returns The next power-of-two integer.
     */
    function nextPowerOfTwo(n: number): number;
    /**
     * Computes the previous power-of-two integer less than or equal to the provided non-negative integer.
     * The maximum allowed input is (2^32)-1 due to 32-bit bitwise operator limitation in Javascript.
     * @example
     * const n = Cesium.Math.previousPowerOfTwo(29); // 16
     * const m = Cesium.Math.previousPowerOfTwo(32); // 32
     * @param n - The integer to test in the range [0, (2^32)-1].
     * @returns The previous power-of-two integer.
     */
    function previousPowerOfTwo(n: number): number;
    /**
     * Constraint a value to lie between two values.
     * @param value - The value to clamp.
     * @param min - The minimum value.
     * @param max - The maximum value.
     * @returns The clamped value such that min <= result <= max.
     */
    function clamp(value: number, min: number, max: number): number;
    /**
     * Sets the seed used by the random number generator
     * in {@link Math#nextRandomNumber}.
     * @param seed - An integer used as the seed.
     */
    function setRandomNumberSeed(seed: number): void;
    /**
     * Generates a random floating point number in the range of [0.0, 1.0)
     * using a Mersenne twister.
     * @returns A random number in the range of [0.0, 1.0).
     */
    function nextRandomNumber(): number;
    /**
     * Generates a random number between two numbers.
     * @param min - The minimum value.
     * @param max - The maximum value.
     * @returns A random number between the min and max.
     */
    function randomBetween(min: number, max: number): number;
    /**
     * Computes <code>Math.acos(value)</code>, but first clamps <code>value</code> to the range [-1.0, 1.0]
     * so that the function will never return NaN.
     * @param value - The value for which to compute acos.
     * @returns The acos of the value if the value is in the range [-1.0, 1.0], or the acos of -1.0 or 1.0,
     *          whichever is closer, if the value is outside the range.
     */
    function acosClamped(value: number): number;
    /**
     * Computes <code>Math.asin(value)</code>, but first clamps <code>value</code> to the range [-1.0, 1.0]
     * so that the function will never return NaN.
     * @param value - The value for which to compute asin.
     * @returns The asin of the value if the value is in the range [-1.0, 1.0], or the asin of -1.0 or 1.0,
     *          whichever is closer, if the value is outside the range.
     */
    function asinClamped(value: number): number;
    /**
     * Finds the chord length between two points given the circle's radius and the angle between the points.
     * @param angle - The angle between the two points.
     * @param radius - The radius of the circle.
     * @returns The chord length.
     */
    function chordLength(angle: number, radius: number): number;
    /**
     * Finds the logarithm of a number to a base.
     * @param number - The number.
     * @param base - The base.
     * @returns The result.
     */
    function logBase(number: number, base: number): number;
    /**
     * Finds the cube root of a number.
     * Returns NaN if <code>number</code> is not provided.
     * @param [number] - The number.
     * @returns The result.
     */
    function cbrt(number?: number): number;
    /**
     * Finds the base 2 logarithm of a number.
     * @param number - The number.
     * @returns The result.
     */
    function log2(number: number): number;
    /**
     * Computes a fast approximation of Atan for input in the range [-1, 1].
     *
     * Based on Michal Drobot's approximation from ShaderFastLibs,
     * which in turn is based on "Efficient approximations for the arctangent function,"
     * Rajan, S. Sichun Wang Inkol, R. Joyal, A., May 2006.
     * Adapted from ShaderFastLibs under MIT License.
     * @param x - An input number in the range [-1, 1]
     * @returns An approximation of atan(x)
     */
    function fastApproximateAtan(x: number): number;
    /**
     * Computes a fast approximation of Atan2(x, y) for arbitrary input scalars.
     *
     * Range reduction math based on nvidia's cg reference implementation: http://developer.download.nvidia.com/cg/atan2.html
     * @param x - An input number that isn't zero if y is zero.
     * @param y - An input number that isn't zero if x is zero.
     * @returns An approximation of atan2(x, y)
     */
    function fastApproximateAtan2(x: number, y: number): number;
}

export interface Matrix2 extends ArrayLike<number> {
}

/**
 * A 2x2 matrix, indexable as a column-major order array.
 * Constructor parameters are in row-major order for code readability.
 * @param [column0Row0 = 0.0] - The value for column 0, row 0.
 * @param [column1Row0 = 0.0] - The value for column 1, row 0.
 * @param [column0Row1 = 0.0] - The value for column 0, row 1.
 * @param [column1Row1 = 0.0] - The value for column 1, row 1.
 */
export class Matrix2 implements ArrayLike<number> {
    constructor(column0Row0?: number, column1Row0?: number, column0Row1?: number, column1Row1?: number);
    /**
     * The number of elements used to pack the object into an array.
     */
    static packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: Matrix2, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new Matrix2 instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: Matrix2): Matrix2;
    /**
     * Flattens an array of Matrix2s into an array of components. The components
     * are stored in column-major order.
     * @param array - The array of matrices to pack.
     * @param [result] - The array onto which to store the result. If this is a typed array, it must have array.length * 4 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 4) elements.
     * @returns The packed array.
     */
    static packArray(array: Matrix2[], result?: number[]): number[];
    /**
     * Unpacks an array of column-major matrix components into an array of Matrix2s.
     * @param array - The array of components to unpack.
     * @param [result] - The array onto which to store the result.
     * @returns The unpacked array.
     */
    static unpackArray(array: number[], result?: Matrix2[]): Matrix2[];
    /**
     * Duplicates a Matrix2 instance.
     * @param matrix - The matrix to duplicate.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Matrix2 instance if one was not provided. (Returns undefined if matrix is undefined)
     */
    static clone(matrix: Matrix2, result?: Matrix2): Matrix2;
    /**
     * Creates a Matrix2 from 4 consecutive elements in an array.
     * @example
     * // Create the Matrix2:
     * // [1.0, 2.0]
     * // [1.0, 2.0]
     *
     * const v = [1.0, 1.0, 2.0, 2.0];
     * const m = Cesium.Matrix2.fromArray(v);
     *
     * // Create same Matrix2 with using an offset into an array
     * const v2 = [0.0, 0.0, 1.0, 1.0, 2.0, 2.0];
     * const m2 = Cesium.Matrix2.fromArray(v2, 2);
     * @param array - The array whose 4 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.
     * @param [startingIndex = 0] - The offset into the array of the first element, which corresponds to first column first row position in the matrix.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Matrix2 instance if one was not provided.
     */
    static fromArray(array: number[], startingIndex?: number, result?: Matrix2): Matrix2;
    /**
     * Creates a Matrix2 instance from a column-major order array.
     * @param values - The column-major order array.
     * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix2 instance if one was not provided.
     */
    static fromColumnMajorArray(values: number[], result?: Matrix2): Matrix2;
    /**
     * Creates a Matrix2 instance from a row-major order array.
     * The resulting matrix will be in column-major order.
     * @param values - The row-major order array.
     * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix2 instance if one was not provided.
     */
    static fromRowMajorArray(values: number[], result?: Matrix2): Matrix2;
    /**
     * Computes a Matrix2 instance representing a non-uniform scale.
     * @example
     * // Creates
     * //   [7.0, 0.0]
     * //   [0.0, 8.0]
     * const m = Cesium.Matrix2.fromScale(new Cesium.Cartesian2(7.0, 8.0));
     * @param scale - The x and y scale factors.
     * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix2 instance if one was not provided.
     */
    static fromScale(scale: Cartesian2, result?: Matrix2): Matrix2;
    /**
     * Computes a Matrix2 instance representing a uniform scale.
     * @example
     * // Creates
     * //   [2.0, 0.0]
     * //   [0.0, 2.0]
     * const m = Cesium.Matrix2.fromUniformScale(2.0);
     * @param scale - The uniform scale factor.
     * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix2 instance if one was not provided.
     */
    static fromUniformScale(scale: number, result?: Matrix2): Matrix2;
    /**
     * Creates a rotation matrix.
     * @example
     * // Rotate a point 45 degrees counterclockwise.
     * const p = new Cesium.Cartesian2(5, 6);
     * const m = Cesium.Matrix2.fromRotation(Cesium.Math.toRadians(45.0));
     * const rotated = Cesium.Matrix2.multiplyByVector(m, p, new Cesium.Cartesian2());
     * @param angle - The angle, in radians, of the rotation.  Positive angles are counterclockwise.
     * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix2 instance if one was not provided.
     */
    static fromRotation(angle: number, result?: Matrix2): Matrix2;
    /**
     * Creates an Array from the provided Matrix2 instance.
     * The array will be in column-major order.
     * @param matrix - The matrix to use..
     * @param [result] - The Array onto which to store the result.
     * @returns The modified Array parameter or a new Array instance if one was not provided.
     */
    static toArray(matrix: Matrix2, result?: number[]): number[];
    /**
     * Computes the array index of the element at the provided row and column.
     * @example
     * const myMatrix = new Cesium.Matrix2();
     * const column1Row0Index = Cesium.Matrix2.getElementIndex(1, 0);
     * const column1Row0 = myMatrix[column1Row0Index]
     * myMatrix[column1Row0Index] = 10.0;
     * @param row - The zero-based index of the row.
     * @param column - The zero-based index of the column.
     * @returns The index of the element at the provided row and column.
     */
    static getElementIndex(row: number, column: number): number;
    /**
     * Retrieves a copy of the matrix column at the provided index as a Cartesian2 instance.
     * @param matrix - The matrix to use.
     * @param index - The zero-based index of the column to retrieve.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static getColumn(matrix: Matrix2, index: number, result: Cartesian2): Cartesian2;
    /**
     * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian2 instance.
     * @param matrix - The matrix to use.
     * @param index - The zero-based index of the column to set.
     * @param cartesian - The Cartesian whose values will be assigned to the specified column.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static setColumn(matrix: Matrix2, index: number, cartesian: Cartesian2, result: Cartesian2): Matrix2;
    /**
     * Retrieves a copy of the matrix row at the provided index as a Cartesian2 instance.
     * @param matrix - The matrix to use.
     * @param index - The zero-based index of the row to retrieve.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static getRow(matrix: Matrix2, index: number, result: Cartesian2): Cartesian2;
    /**
     * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian2 instance.
     * @param matrix - The matrix to use.
     * @param index - The zero-based index of the row to set.
     * @param cartesian - The Cartesian whose values will be assigned to the specified row.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static setRow(matrix: Matrix2, index: number, cartesian: Cartesian2, result: Matrix2): Matrix2;
    /**
     * Computes a new matrix that replaces the scale with the provided scale.
     * This assumes the matrix is an affine transformation.
     * @param matrix - The matrix to use.
     * @param scale - The scale that replaces the scale of the provided matrix.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static setScale(matrix: Matrix2, scale: Cartesian2, result: Matrix2): Matrix2;
    /**
     * Computes a new matrix that replaces the scale with the provided uniform scale.
     * This assumes the matrix is an affine transformation.
     * @param matrix - The matrix to use.
     * @param scale - The uniform scale that replaces the scale of the provided matrix.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static setUniformScale(matrix: Matrix2, scale: number, result: Matrix2): Matrix2;
    /**
     * Extracts the non-uniform scale assuming the matrix is an affine transformation.
     * @param matrix - The matrix.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static getScale(matrix: Matrix2, result: Cartesian2): Cartesian2;
    /**
     * Computes the maximum scale assuming the matrix is an affine transformation.
     * The maximum scale is the maximum length of the column vectors.
     * @param matrix - The matrix.
     * @returns The maximum scale.
     */
    static getMaximumScale(matrix: Matrix2): number;
    /**
     * Sets the rotation assuming the matrix is an affine transformation.
     * @param matrix - The matrix.
     * @param rotation - The rotation matrix.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static setRotation(matrix: Matrix2, rotation: Matrix2, result: Matrix2): Matrix2;
    /**
     * Extracts the rotation matrix assuming the matrix is an affine transformation.
     * @param matrix - The matrix.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static getRotation(matrix: Matrix2, result: Matrix2): Matrix2;
    /**
     * Computes the product of two matrices.
     * @param left - The first matrix.
     * @param right - The second matrix.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static multiply(left: Matrix2, right: Matrix2, result: Matrix2): Matrix2;
    /**
     * Computes the sum of two matrices.
     * @param left - The first matrix.
     * @param right - The second matrix.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static add(left: Matrix2, right: Matrix2, result: Matrix2): Matrix2;
    /**
     * Computes the difference of two matrices.
     * @param left - The first matrix.
     * @param right - The second matrix.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static subtract(left: Matrix2, right: Matrix2, result: Matrix2): Matrix2;
    /**
     * Computes the product of a matrix and a column vector.
     * @param matrix - The matrix.
     * @param cartesian - The column.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static multiplyByVector(matrix: Matrix2, cartesian: Cartesian2, result: Cartesian2): Cartesian2;
    /**
     * Computes the product of a matrix and a scalar.
     * @param matrix - The matrix.
     * @param scalar - The number to multiply by.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static multiplyByScalar(matrix: Matrix2, scalar: number, result: Matrix2): Matrix2;
    /**
     * Computes the product of a matrix times a (non-uniform) scale, as if the scale were a scale matrix.
     * @example
     * // Instead of Cesium.Matrix2.multiply(m, Cesium.Matrix2.fromScale(scale), m);
     * Cesium.Matrix2.multiplyByScale(m, scale, m);
     * @param matrix - The matrix on the left-hand side.
     * @param scale - The non-uniform scale on the right-hand side.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static multiplyByScale(matrix: Matrix2, scale: Cartesian2, result: Matrix2): Matrix2;
    /**
     * Computes the product of a matrix times a uniform scale, as if the scale were a scale matrix.
     * @example
     * // Instead of Cesium.Matrix2.multiply(m, Cesium.Matrix2.fromUniformScale(scale), m);
     * Cesium.Matrix2.multiplyByUniformScale(m, scale, m);
     * @param matrix - The matrix on the left-hand side.
     * @param scale - The uniform scale on the right-hand side.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static multiplyByUniformScale(matrix: Matrix2, scale: number, result: Matrix2): Matrix2;
    /**
     * Creates a negated copy of the provided matrix.
     * @param matrix - The matrix to negate.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static negate(matrix: Matrix2, result: Matrix2): Matrix2;
    /**
     * Computes the transpose of the provided matrix.
     * @param matrix - The matrix to transpose.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static transpose(matrix: Matrix2, result: Matrix2): Matrix2;
    /**
     * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.
     * @param matrix - The matrix with signed elements.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static abs(matrix: Matrix2, result: Matrix2): Matrix2;
    /**
     * Compares the provided matrices componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [left] - The first matrix.
     * @param [right] - The second matrix.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    static equals(left?: Matrix2, right?: Matrix2): boolean;
    /**
     * Compares the provided matrices componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @param [left] - The first matrix.
     * @param [right] - The second matrix.
     * @param [epsilon = 0] - The epsilon to use for equality testing.
     * @returns <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
     */
    static equalsEpsilon(left?: Matrix2, right?: Matrix2, epsilon?: number): boolean;
    /**
     * An immutable Matrix2 instance initialized to the identity matrix.
     */
    static readonly IDENTITY: Matrix2;
    /**
     * An immutable Matrix2 instance initialized to the zero matrix.
     */
    static readonly ZERO: Matrix2;
    /**
     * The index into Matrix2 for column 0, row 0.
     * @example
     * const matrix = new Cesium.Matrix2();
     * matrix[Cesium.Matrix2.COLUMN0ROW0] = 5.0; // set column 0, row 0 to 5.0
     */
    static readonly COLUMN0ROW0: number;
    /**
     * The index into Matrix2 for column 0, row 1.
     * @example
     * const matrix = new Cesium.Matrix2();
     * matrix[Cesium.Matrix2.COLUMN0ROW1] = 5.0; // set column 0, row 1 to 5.0
     */
    static readonly COLUMN0ROW1: number;
    /**
     * The index into Matrix2 for column 1, row 0.
     * @example
     * const matrix = new Cesium.Matrix2();
     * matrix[Cesium.Matrix2.COLUMN1ROW0] = 5.0; // set column 1, row 0 to 5.0
     */
    static readonly COLUMN1ROW0: number;
    /**
     * The index into Matrix2 for column 1, row 1.
     * @example
     * const matrix = new Cesium.Matrix2();
     * matrix[Cesium.Matrix2.COLUMN1ROW1] = 5.0; // set column 1, row 1 to 5.0
     */
    static readonly COLUMN1ROW1: number;
    /**
     * Gets the number of items in the collection.
     */
    length: number;
    /**
     * Duplicates the provided Matrix2 instance.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Matrix2 instance if one was not provided.
     */
    clone(result?: Matrix2): Matrix2;
    /**
     * Compares this matrix to the provided matrix componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [right] - The right hand side matrix.
     * @returns <code>true</code> if they are equal, <code>false</code> otherwise.
     */
    equals(right?: Matrix2): boolean;
    /**
     * Compares this matrix to the provided matrix componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @param [right] - The right hand side matrix.
     * @param [epsilon = 0] - The epsilon to use for equality testing.
     * @returns <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
     */
    equalsEpsilon(right?: Matrix2, epsilon?: number): boolean;
    /**
     * Creates a string representing this Matrix with each row being
     * on a separate line and in the format '(column0, column1)'.
     * @returns A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1)'.
     */
    toString(): string;
}

export interface Matrix3 extends ArrayLike<number> {
}

/**
 * A 3x3 matrix, indexable as a column-major order array.
 * Constructor parameters are in row-major order for code readability.
 * @param [column0Row0 = 0.0] - The value for column 0, row 0.
 * @param [column1Row0 = 0.0] - The value for column 1, row 0.
 * @param [column2Row0 = 0.0] - The value for column 2, row 0.
 * @param [column0Row1 = 0.0] - The value for column 0, row 1.
 * @param [column1Row1 = 0.0] - The value for column 1, row 1.
 * @param [column2Row1 = 0.0] - The value for column 2, row 1.
 * @param [column0Row2 = 0.0] - The value for column 0, row 2.
 * @param [column1Row2 = 0.0] - The value for column 1, row 2.
 * @param [column2Row2 = 0.0] - The value for column 2, row 2.
 */
export class Matrix3 implements ArrayLike<number> {
    constructor(column0Row0?: number, column1Row0?: number, column2Row0?: number, column0Row1?: number, column1Row1?: number, column2Row1?: number, column0Row2?: number, column1Row2?: number, column2Row2?: number);
    /**
     * The number of elements used to pack the object into an array.
     */
    static packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: Matrix3, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new Matrix3 instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: Matrix3): Matrix3;
    /**
     * Flattens an array of Matrix3s into an array of components. The components
     * are stored in column-major order.
     * @param array - The array of matrices to pack.
     * @param [result] - The array onto which to store the result. If this is a typed array, it must have array.length * 9 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 9) elements.
     * @returns The packed array.
     */
    static packArray(array: Matrix3[], result?: number[]): number[];
    /**
     * Unpacks an array of column-major matrix components into an array of Matrix3s.
     * @param array - The array of components to unpack.
     * @param [result] - The array onto which to store the result.
     * @returns The unpacked array.
     */
    static unpackArray(array: number[], result?: Matrix3[]): Matrix3[];
    /**
     * Duplicates a Matrix3 instance.
     * @param matrix - The matrix to duplicate.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Matrix3 instance if one was not provided. (Returns undefined if matrix is undefined)
     */
    static clone(matrix: Matrix3, result?: Matrix3): Matrix3;
    /**
     * Creates a Matrix3 from 9 consecutive elements in an array.
     * @example
     * // Create the Matrix3:
     * // [1.0, 2.0, 3.0]
     * // [1.0, 2.0, 3.0]
     * // [1.0, 2.0, 3.0]
     *
     * const v = [1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0];
     * const m = Cesium.Matrix3.fromArray(v);
     *
     * // Create same Matrix3 with using an offset into an array
     * const v2 = [0.0, 0.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0];
     * const m2 = Cesium.Matrix3.fromArray(v2, 2);
     * @param array - The array whose 9 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.
     * @param [startingIndex = 0] - The offset into the array of the first element, which corresponds to first column first row position in the matrix.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Matrix3 instance if one was not provided.
     */
    static fromArray(array: number[], startingIndex?: number, result?: Matrix3): Matrix3;
    /**
     * Creates a Matrix3 instance from a column-major order array.
     * @param values - The column-major order array.
     * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix3 instance if one was not provided.
     */
    static fromColumnMajorArray(values: number[], result?: Matrix3): Matrix3;
    /**
     * Creates a Matrix3 instance from a row-major order array.
     * The resulting matrix will be in column-major order.
     * @param values - The row-major order array.
     * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix3 instance if one was not provided.
     */
    static fromRowMajorArray(values: number[], result?: Matrix3): Matrix3;
    /**
     * Computes a 3x3 rotation matrix from the provided quaternion.
     * @param quaternion - the quaternion to use.
     * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The 3x3 rotation matrix from this quaternion.
     */
    static fromQuaternion(quaternion: Quaternion, result?: Matrix3): Matrix3;
    /**
     * Computes a 3x3 rotation matrix from the provided headingPitchRoll. (see http://en.wikipedia.org/wiki/Conversion_between_quaternions_and_Euler_angles )
     * @param headingPitchRoll - the headingPitchRoll to use.
     * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The 3x3 rotation matrix from this headingPitchRoll.
     */
    static fromHeadingPitchRoll(headingPitchRoll: HeadingPitchRoll, result?: Matrix3): Matrix3;
    /**
     * Computes a Matrix3 instance representing a non-uniform scale.
     * @example
     * // Creates
     * //   [7.0, 0.0, 0.0]
     * //   [0.0, 8.0, 0.0]
     * //   [0.0, 0.0, 9.0]
     * const m = Cesium.Matrix3.fromScale(new Cesium.Cartesian3(7.0, 8.0, 9.0));
     * @param scale - The x, y, and z scale factors.
     * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix3 instance if one was not provided.
     */
    static fromScale(scale: Cartesian3, result?: Matrix3): Matrix3;
    /**
     * Computes a Matrix3 instance representing a uniform scale.
     * @example
     * // Creates
     * //   [2.0, 0.0, 0.0]
     * //   [0.0, 2.0, 0.0]
     * //   [0.0, 0.0, 2.0]
     * const m = Cesium.Matrix3.fromUniformScale(2.0);
     * @param scale - The uniform scale factor.
     * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix3 instance if one was not provided.
     */
    static fromUniformScale(scale: number, result?: Matrix3): Matrix3;
    /**
     * Computes a Matrix3 instance representing the cross product equivalent matrix of a Cartesian3 vector.
     * @example
     * // Creates
     * //   [0.0, -9.0,  8.0]
     * //   [9.0,  0.0, -7.0]
     * //   [-8.0, 7.0,  0.0]
     * const m = Cesium.Matrix3.fromCrossProduct(new Cesium.Cartesian3(7.0, 8.0, 9.0));
     * @param vector - the vector on the left hand side of the cross product operation.
     * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix3 instance if one was not provided.
     */
    static fromCrossProduct(vector: Cartesian3, result?: Matrix3): Matrix3;
    /**
     * Creates a rotation matrix around the x-axis.
     * @example
     * // Rotate a point 45 degrees counterclockwise around the x-axis.
     * const p = new Cesium.Cartesian3(5, 6, 7);
     * const m = Cesium.Matrix3.fromRotationX(Cesium.Math.toRadians(45.0));
     * const rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());
     * @param angle - The angle, in radians, of the rotation.  Positive angles are counterclockwise.
     * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix3 instance if one was not provided.
     */
    static fromRotationX(angle: number, result?: Matrix3): Matrix3;
    /**
     * Creates a rotation matrix around the y-axis.
     * @example
     * // Rotate a point 45 degrees counterclockwise around the y-axis.
     * const p = new Cesium.Cartesian3(5, 6, 7);
     * const m = Cesium.Matrix3.fromRotationY(Cesium.Math.toRadians(45.0));
     * const rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());
     * @param angle - The angle, in radians, of the rotation.  Positive angles are counterclockwise.
     * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix3 instance if one was not provided.
     */
    static fromRotationY(angle: number, result?: Matrix3): Matrix3;
    /**
     * Creates a rotation matrix around the z-axis.
     * @example
     * // Rotate a point 45 degrees counterclockwise around the z-axis.
     * const p = new Cesium.Cartesian3(5, 6, 7);
     * const m = Cesium.Matrix3.fromRotationZ(Cesium.Math.toRadians(45.0));
     * const rotated = Cesium.Matrix3.multiplyByVector(m, p, new Cesium.Cartesian3());
     * @param angle - The angle, in radians, of the rotation.  Positive angles are counterclockwise.
     * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix3 instance if one was not provided.
     */
    static fromRotationZ(angle: number, result?: Matrix3): Matrix3;
    /**
     * Creates an Array from the provided Matrix3 instance.
     * The array will be in column-major order.
     * @param matrix - The matrix to use..
     * @param [result] - The Array onto which to store the result.
     * @returns The modified Array parameter or a new Array instance if one was not provided.
     */
    static toArray(matrix: Matrix3, result?: number[]): number[];
    /**
     * Computes the array index of the element at the provided row and column.
     * @example
     * const myMatrix = new Cesium.Matrix3();
     * const column1Row0Index = Cesium.Matrix3.getElementIndex(1, 0);
     * const column1Row0 = myMatrix[column1Row0Index]
     * myMatrix[column1Row0Index] = 10.0;
     * @param column - The zero-based index of the column.
     * @param row - The zero-based index of the row.
     * @returns The index of the element at the provided row and column.
     */
    static getElementIndex(column: number, row: number): number;
    /**
     * Retrieves a copy of the matrix column at the provided index as a Cartesian3 instance.
     * @param matrix - The matrix to use.
     * @param index - The zero-based index of the column to retrieve.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static getColumn(matrix: Matrix3, index: number, result: Cartesian3): Cartesian3;
    /**
     * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian3 instance.
     * @param matrix - The matrix to use.
     * @param index - The zero-based index of the column to set.
     * @param cartesian - The Cartesian whose values will be assigned to the specified column.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static setColumn(matrix: Matrix3, index: number, cartesian: Cartesian3, result: Matrix3): Matrix3;
    /**
     * Retrieves a copy of the matrix row at the provided index as a Cartesian3 instance.
     * @param matrix - The matrix to use.
     * @param index - The zero-based index of the row to retrieve.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static getRow(matrix: Matrix3, index: number, result: Cartesian3): Cartesian3;
    /**
     * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian3 instance.
     * @param matrix - The matrix to use.
     * @param index - The zero-based index of the row to set.
     * @param cartesian - The Cartesian whose values will be assigned to the specified row.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static setRow(matrix: Matrix3, index: number, cartesian: Cartesian3, result: Matrix3): Matrix3;
    /**
     * Computes a new matrix that replaces the scale with the provided scale.
     * This assumes the matrix is an affine transformation.
     * @param matrix - The matrix to use.
     * @param scale - The scale that replaces the scale of the provided matrix.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static setScale(matrix: Matrix3, scale: Cartesian3, result: Matrix3): Matrix3;
    /**
     * Computes a new matrix that replaces the scale with the provided uniform scale.
     * This assumes the matrix is an affine transformation.
     * @param matrix - The matrix to use.
     * @param scale - The uniform scale that replaces the scale of the provided matrix.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static setUniformScale(matrix: Matrix3, scale: number, result: Matrix3): Matrix3;
    /**
     * Extracts the non-uniform scale assuming the matrix is an affine transformation.
     * @param matrix - The matrix.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static getScale(matrix: Matrix3, result: Cartesian3): Cartesian3;
    /**
     * Computes the maximum scale assuming the matrix is an affine transformation.
     * The maximum scale is the maximum length of the column vectors.
     * @param matrix - The matrix.
     * @returns The maximum scale.
     */
    static getMaximumScale(matrix: Matrix3): number;
    /**
     * Sets the rotation assuming the matrix is an affine transformation.
     * @param matrix - The matrix.
     * @param rotation - The rotation matrix.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static setRotation(matrix: Matrix3, rotation: Matrix3, result: Matrix3): Matrix3;
    /**
     * Extracts the rotation matrix assuming the matrix is an affine transformation.
     * @param matrix - The matrix.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static getRotation(matrix: Matrix3, result: Matrix3): Matrix3;
    /**
     * Computes the product of two matrices.
     * @param left - The first matrix.
     * @param right - The second matrix.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static multiply(left: Matrix3, right: Matrix3, result: Matrix3): Matrix3;
    /**
     * Computes the sum of two matrices.
     * @param left - The first matrix.
     * @param right - The second matrix.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static add(left: Matrix3, right: Matrix3, result: Matrix3): Matrix3;
    /**
     * Computes the difference of two matrices.
     * @param left - The first matrix.
     * @param right - The second matrix.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static subtract(left: Matrix3, right: Matrix3, result: Matrix3): Matrix3;
    /**
     * Computes the product of a matrix and a column vector.
     * @param matrix - The matrix.
     * @param cartesian - The column.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static multiplyByVector(matrix: Matrix3, cartesian: Cartesian3, result: Cartesian3): Cartesian3;
    /**
     * Computes the product of a matrix and a scalar.
     * @param matrix - The matrix.
     * @param scalar - The number to multiply by.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static multiplyByScalar(matrix: Matrix3, scalar: number, result: Matrix3): Matrix3;
    /**
     * Computes the product of a matrix times a (non-uniform) scale, as if the scale were a scale matrix.
     * @example
     * // Instead of Cesium.Matrix3.multiply(m, Cesium.Matrix3.fromScale(scale), m);
     * Cesium.Matrix3.multiplyByScale(m, scale, m);
     * @param matrix - The matrix on the left-hand side.
     * @param scale - The non-uniform scale on the right-hand side.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static multiplyByScale(matrix: Matrix3, scale: Cartesian3, result: Matrix3): Matrix3;
    /**
     * Computes the product of a matrix times a uniform scale, as if the scale were a scale matrix.
     * @example
     * // Instead of Cesium.Matrix3.multiply(m, Cesium.Matrix3.fromUniformScale(scale), m);
     * Cesium.Matrix3.multiplyByUniformScale(m, scale, m);
     * @param matrix - The matrix on the left-hand side.
     * @param scale - The uniform scale on the right-hand side.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static multiplyByUniformScale(matrix: Matrix3, scale: number, result: Matrix3): Matrix3;
    /**
     * Creates a negated copy of the provided matrix.
     * @param matrix - The matrix to negate.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static negate(matrix: Matrix3, result: Matrix3): Matrix3;
    /**
     * Computes the transpose of the provided matrix.
     * @param matrix - The matrix to transpose.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static transpose(matrix: Matrix3, result: Matrix3): Matrix3;
    /**
     * Computes the eigenvectors and eigenvalues of a symmetric matrix.
     * <p>
     * Returns a diagonal matrix and unitary matrix such that:
     * <code>matrix = unitary matrix * diagonal matrix * transpose(unitary matrix)</code>
     * </p>
     * <p>
     * The values along the diagonal of the diagonal matrix are the eigenvalues. The columns
     * of the unitary matrix are the corresponding eigenvectors.
     * </p>
     * @example
     * const a = //... symetric matrix
     * const result = {
     *     unitary : new Cesium.Matrix3(),
     *     diagonal : new Cesium.Matrix3()
     * };
     * Cesium.Matrix3.computeEigenDecomposition(a, result);
     *
     * const unitaryTranspose = Cesium.Matrix3.transpose(result.unitary, new Cesium.Matrix3());
     * const b = Cesium.Matrix3.multiply(result.unitary, result.diagonal, new Cesium.Matrix3());
     * Cesium.Matrix3.multiply(b, unitaryTranspose, b); // b is now equal to a
     *
     * const lambda = Cesium.Matrix3.getColumn(result.diagonal, 0, new Cesium.Cartesian3()).x;  // first eigenvalue
     * const v = Cesium.Matrix3.getColumn(result.unitary, 0, new Cesium.Cartesian3());          // first eigenvector
     * const c = Cesium.Cartesian3.multiplyByScalar(v, lambda, new Cesium.Cartesian3());        // equal to Cesium.Matrix3.multiplyByVector(a, v)
     * @param matrix - The matrix to decompose into diagonal and unitary matrix. Expected to be symmetric.
     * @param [result] - An object with unitary and diagonal properties which are matrices onto which to store the result.
     * @returns An object with unitary and diagonal properties which are the unitary and diagonal matrices, respectively.
     */
    static computeEigenDecomposition(matrix: Matrix3, result?: any): any;
    /**
     * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.
     * @param matrix - The matrix with signed elements.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static abs(matrix: Matrix3, result: Matrix3): Matrix3;
    /**
     * Computes the determinant of the provided matrix.
     * @param matrix - The matrix to use.
     * @returns The value of the determinant of the matrix.
     */
    static determinant(matrix: Matrix3): number;
    /**
     * Computes the inverse of the provided matrix.
     * @param matrix - The matrix to invert.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static inverse(matrix: Matrix3, result: Matrix3): Matrix3;
    /**
     * Computes the inverse transpose of a matrix.
     * @param matrix - The matrix to transpose and invert.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static inverseTranspose(matrix: Matrix3, result: Matrix3): Matrix3;
    /**
     * Compares the provided matrices componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [left] - The first matrix.
     * @param [right] - The second matrix.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    static equals(left?: Matrix3, right?: Matrix3): boolean;
    /**
     * Compares the provided matrices componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @param [left] - The first matrix.
     * @param [right] - The second matrix.
     * @param [epsilon = 0] - The epsilon to use for equality testing.
     * @returns <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
     */
    static equalsEpsilon(left?: Matrix3, right?: Matrix3, epsilon?: number): boolean;
    /**
     * An immutable Matrix3 instance initialized to the identity matrix.
     */
    static readonly IDENTITY: Matrix3;
    /**
     * An immutable Matrix3 instance initialized to the zero matrix.
     */
    static readonly ZERO: Matrix3;
    /**
     * The index into Matrix3 for column 0, row 0.
     */
    static readonly COLUMN0ROW0: number;
    /**
     * The index into Matrix3 for column 0, row 1.
     */
    static readonly COLUMN0ROW1: number;
    /**
     * The index into Matrix3 for column 0, row 2.
     */
    static readonly COLUMN0ROW2: number;
    /**
     * The index into Matrix3 for column 1, row 0.
     */
    static readonly COLUMN1ROW0: number;
    /**
     * The index into Matrix3 for column 1, row 1.
     */
    static readonly COLUMN1ROW1: number;
    /**
     * The index into Matrix3 for column 1, row 2.
     */
    static readonly COLUMN1ROW2: number;
    /**
     * The index into Matrix3 for column 2, row 0.
     */
    static readonly COLUMN2ROW0: number;
    /**
     * The index into Matrix3 for column 2, row 1.
     */
    static readonly COLUMN2ROW1: number;
    /**
     * The index into Matrix3 for column 2, row 2.
     */
    static readonly COLUMN2ROW2: number;
    /**
     * Gets the number of items in the collection.
     */
    length: number;
    /**
     * Duplicates the provided Matrix3 instance.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Matrix3 instance if one was not provided.
     */
    clone(result?: Matrix3): Matrix3;
    /**
     * Compares this matrix to the provided matrix componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [right] - The right hand side matrix.
     * @returns <code>true</code> if they are equal, <code>false</code> otherwise.
     */
    equals(right?: Matrix3): boolean;
    /**
     * Compares this matrix to the provided matrix componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @param [right] - The right hand side matrix.
     * @param [epsilon = 0] - The epsilon to use for equality testing.
     * @returns <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
     */
    equalsEpsilon(right?: Matrix3, epsilon?: number): boolean;
    /**
     * Creates a string representing this Matrix with each row being
     * on a separate line and in the format '(column0, column1, column2)'.
     * @returns A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1, column2)'.
     */
    toString(): string;
}

export interface Matrix4 extends ArrayLike<number> {
}

/**
 * A 4x4 matrix, indexable as a column-major order array.
 * Constructor parameters are in row-major order for code readability.
 * @param [column0Row0 = 0.0] - The value for column 0, row 0.
 * @param [column1Row0 = 0.0] - The value for column 1, row 0.
 * @param [column2Row0 = 0.0] - The value for column 2, row 0.
 * @param [column3Row0 = 0.0] - The value for column 3, row 0.
 * @param [column0Row1 = 0.0] - The value for column 0, row 1.
 * @param [column1Row1 = 0.0] - The value for column 1, row 1.
 * @param [column2Row1 = 0.0] - The value for column 2, row 1.
 * @param [column3Row1 = 0.0] - The value for column 3, row 1.
 * @param [column0Row2 = 0.0] - The value for column 0, row 2.
 * @param [column1Row2 = 0.0] - The value for column 1, row 2.
 * @param [column2Row2 = 0.0] - The value for column 2, row 2.
 * @param [column3Row2 = 0.0] - The value for column 3, row 2.
 * @param [column0Row3 = 0.0] - The value for column 0, row 3.
 * @param [column1Row3 = 0.0] - The value for column 1, row 3.
 * @param [column2Row3 = 0.0] - The value for column 2, row 3.
 * @param [column3Row3 = 0.0] - The value for column 3, row 3.
 */
export class Matrix4 implements ArrayLike<number> {
    constructor(column0Row0?: number, column1Row0?: number, column2Row0?: number, column3Row0?: number, column0Row1?: number, column1Row1?: number, column2Row1?: number, column3Row1?: number, column0Row2?: number, column1Row2?: number, column2Row2?: number, column3Row2?: number, column0Row3?: number, column1Row3?: number, column2Row3?: number, column3Row3?: number);
    /**
     * The number of elements used to pack the object into an array.
     */
    static packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: Matrix4, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new Matrix4 instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: Matrix4): Matrix4;
    /**
     * Flattens an array of Matrix4s into an array of components. The components
     * are stored in column-major order.
     * @param array - The array of matrices to pack.
     * @param [result] - The array onto which to store the result. If this is a typed array, it must have array.length * 16 components, else a {@link DeveloperError} will be thrown. If it is a regular array, it will be resized to have (array.length * 16) elements.
     * @returns The packed array.
     */
    static packArray(array: Matrix4[], result?: number[]): number[];
    /**
     * Unpacks an array of column-major matrix components into an array of Matrix4s.
     * @param array - The array of components to unpack.
     * @param [result] - The array onto which to store the result.
     * @returns The unpacked array.
     */
    static unpackArray(array: number[], result?: Matrix4[]): Matrix4[];
    /**
     * Duplicates a Matrix4 instance.
     * @param matrix - The matrix to duplicate.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Matrix4 instance if one was not provided. (Returns undefined if matrix is undefined)
     */
    static clone(matrix: Matrix4, result?: Matrix4): Matrix4;
    /**
     * Creates a Matrix4 from 16 consecutive elements in an array.
     * @example
     * // Create the Matrix4:
     * // [1.0, 2.0, 3.0, 4.0]
     * // [1.0, 2.0, 3.0, 4.0]
     * // [1.0, 2.0, 3.0, 4.0]
     * // [1.0, 2.0, 3.0, 4.0]
     *
     * const v = [1.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0, 3.0, 4.0, 4.0, 4.0, 4.0];
     * const m = Cesium.Matrix4.fromArray(v);
     *
     * // Create same Matrix4 with using an offset into an array
     * const v2 = [0.0, 0.0, 1.0, 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 2.0, 3.0, 3.0, 3.0, 3.0, 4.0, 4.0, 4.0, 4.0];
     * const m2 = Cesium.Matrix4.fromArray(v2, 2);
     * @param array - The array whose 16 consecutive elements correspond to the positions of the matrix.  Assumes column-major order.
     * @param [startingIndex = 0] - The offset into the array of the first element, which corresponds to first column first row position in the matrix.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Matrix4 instance if one was not provided.
     */
    static fromArray(array: number[], startingIndex?: number, result?: Matrix4): Matrix4;
    /**
     * Computes a Matrix4 instance from a column-major order array.
     * @param values - The column-major order array.
     * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix4 instance if one was not provided.
     */
    static fromColumnMajorArray(values: number[], result?: Matrix4): Matrix4;
    /**
     * Computes a Matrix4 instance from a row-major order array.
     * The resulting matrix will be in column-major order.
     * @param values - The row-major order array.
     * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix4 instance if one was not provided.
     */
    static fromRowMajorArray(values: number[], result?: Matrix4): Matrix4;
    /**
     * Computes a Matrix4 instance from a Matrix3 representing the rotation
     * and a Cartesian3 representing the translation.
     * @param rotation - The upper left portion of the matrix representing the rotation.
     * @param [translation = Cartesian3.ZERO] - The upper right portion of the matrix representing the translation.
     * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix4 instance if one was not provided.
     */
    static fromRotationTranslation(rotation: Matrix3, translation?: Cartesian3, result?: Matrix4): Matrix4;
    /**
     * Computes a Matrix4 instance from a translation, rotation, and scale (TRS)
     * representation with the rotation represented as a quaternion.
     * @example
     * const result = Cesium.Matrix4.fromTranslationQuaternionRotationScale(
     *   new Cesium.Cartesian3(1.0, 2.0, 3.0), // translation
     *   Cesium.Quaternion.IDENTITY,           // rotation
     *   new Cesium.Cartesian3(7.0, 8.0, 9.0), // scale
     *   result);
     * @param translation - The translation transformation.
     * @param rotation - The rotation transformation.
     * @param scale - The non-uniform scale transformation.
     * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix4 instance if one was not provided.
     */
    static fromTranslationQuaternionRotationScale(translation: Cartesian3, rotation: Quaternion, scale: Cartesian3, result?: Matrix4): Matrix4;
    /**
     * Creates a Matrix4 instance from a {@link TranslationRotationScale} instance.
     * @param translationRotationScale - The instance.
     * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix4 instance if one was not provided.
     */
    static fromTranslationRotationScale(translationRotationScale: TranslationRotationScale, result?: Matrix4): Matrix4;
    /**
     * Creates a Matrix4 instance from a Cartesian3 representing the translation.
     * @param translation - The upper right portion of the matrix representing the translation.
     * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix4 instance if one was not provided.
     */
    static fromTranslation(translation: Cartesian3, result?: Matrix4): Matrix4;
    /**
     * Computes a Matrix4 instance representing a non-uniform scale.
     * @example
     * // Creates
     * //   [7.0, 0.0, 0.0, 0.0]
     * //   [0.0, 8.0, 0.0, 0.0]
     * //   [0.0, 0.0, 9.0, 0.0]
     * //   [0.0, 0.0, 0.0, 1.0]
     * const m = Cesium.Matrix4.fromScale(new Cesium.Cartesian3(7.0, 8.0, 9.0));
     * @param scale - The x, y, and z scale factors.
     * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix4 instance if one was not provided.
     */
    static fromScale(scale: Cartesian3, result?: Matrix4): Matrix4;
    /**
     * Computes a Matrix4 instance representing a uniform scale.
     * @example
     * // Creates
     * //   [2.0, 0.0, 0.0, 0.0]
     * //   [0.0, 2.0, 0.0, 0.0]
     * //   [0.0, 0.0, 2.0, 0.0]
     * //   [0.0, 0.0, 0.0, 1.0]
     * const m = Cesium.Matrix4.fromUniformScale(2.0);
     * @param scale - The uniform scale factor.
     * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix4 instance if one was not provided.
     */
    static fromUniformScale(scale: number, result?: Matrix4): Matrix4;
    /**
     * Creates a rotation matrix.
     * @param rotation - The rotation matrix.
     * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix4 instance if one was not provided.
     */
    static fromRotation(rotation: Matrix3, result?: Matrix4): Matrix4;
    /**
     * Computes a Matrix4 instance from a Camera.
     * @param camera - The camera to use.
     * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new Matrix4 instance if one was not provided.
     */
    static fromCamera(camera: Camera, result?: Matrix4): Matrix4;
    /**
     * Computes a Matrix4 instance representing a perspective transformation matrix.
     * @param fovY - The field of view along the Y axis in radians.
     * @param aspectRatio - The aspect ratio.
     * @param near - The distance to the near plane in meters.
     * @param far - The distance to the far plane in meters.
     * @param result - The object in which the result will be stored.
     * @returns The modified result parameter.
     */
    static computePerspectiveFieldOfView(fovY: number, aspectRatio: number, near: number, far: number, result: Matrix4): Matrix4;
    /**
     * Computes a Matrix4 instance representing an orthographic transformation matrix.
     * @param left - The number of meters to the left of the camera that will be in view.
     * @param right - The number of meters to the right of the camera that will be in view.
     * @param bottom - The number of meters below of the camera that will be in view.
     * @param top - The number of meters above of the camera that will be in view.
     * @param near - The distance to the near plane in meters.
     * @param far - The distance to the far plane in meters.
     * @param result - The object in which the result will be stored.
     * @returns The modified result parameter.
     */
    static computeOrthographicOffCenter(left: number, right: number, bottom: number, top: number, near: number, far: number, result: Matrix4): Matrix4;
    /**
     * Computes a Matrix4 instance representing an off center perspective transformation.
     * @param left - The number of meters to the left of the camera that will be in view.
     * @param right - The number of meters to the right of the camera that will be in view.
     * @param bottom - The number of meters below of the camera that will be in view.
     * @param top - The number of meters above of the camera that will be in view.
     * @param near - The distance to the near plane in meters.
     * @param far - The distance to the far plane in meters.
     * @param result - The object in which the result will be stored.
     * @returns The modified result parameter.
     */
    static computePerspectiveOffCenter(left: number, right: number, bottom: number, top: number, near: number, far: number, result: Matrix4): Matrix4;
    /**
     * Computes a Matrix4 instance representing an infinite off center perspective transformation.
     * @param left - The number of meters to the left of the camera that will be in view.
     * @param right - The number of meters to the right of the camera that will be in view.
     * @param bottom - The number of meters below of the camera that will be in view.
     * @param top - The number of meters above of the camera that will be in view.
     * @param near - The distance to the near plane in meters.
     * @param result - The object in which the result will be stored.
     * @returns The modified result parameter.
     */
    static computeInfinitePerspectiveOffCenter(left: number, right: number, bottom: number, top: number, near: number, result: Matrix4): Matrix4;
    /**
     * Computes a Matrix4 instance that transforms from normalized device coordinates to window coordinates.
     * @example
     * // Create viewport transformation using an explicit viewport and depth range.
     * const m = Cesium.Matrix4.computeViewportTransformation({
     *     x : 0.0,
     *     y : 0.0,
     *     width : 1024.0,
     *     height : 768.0
     * }, 0.0, 1.0, new Cesium.Matrix4());
     * @param [viewport = { x : 0.0, y : 0.0, width : 0.0, height : 0.0 }] - The viewport's corners as shown in Example 1.
     * @param [nearDepthRange = 0.0] - The near plane distance in window coordinates.
     * @param [farDepthRange = 1.0] - The far plane distance in window coordinates.
     * @param [result] - The object in which the result will be stored.
     * @returns The modified result parameter.
     */
    static computeViewportTransformation(viewport?: any, nearDepthRange?: number, farDepthRange?: number, result?: Matrix4): Matrix4;
    /**
     * Computes a Matrix4 instance that transforms from world space to view space.
     * @param position - The position of the camera.
     * @param direction - The forward direction.
     * @param up - The up direction.
     * @param right - The right direction.
     * @param result - The object in which the result will be stored.
     * @returns The modified result parameter.
     */
    static computeView(position: Cartesian3, direction: Cartesian3, up: Cartesian3, right: Cartesian3, result: Matrix4): Matrix4;
    /**
     * Computes an Array from the provided Matrix4 instance.
     * The array will be in column-major order.
     * @example
     * //create an array from an instance of Matrix4
     * // m = [10.0, 14.0, 18.0, 22.0]
     * //     [11.0, 15.0, 19.0, 23.0]
     * //     [12.0, 16.0, 20.0, 24.0]
     * //     [13.0, 17.0, 21.0, 25.0]
     * const a = Cesium.Matrix4.toArray(m);
     *
     * // m remains the same
     * //creates a = [10.0, 11.0, 12.0, 13.0, 14.0, 15.0, 16.0, 17.0, 18.0, 19.0, 20.0, 21.0, 22.0, 23.0, 24.0, 25.0]
     * @param matrix - The matrix to use..
     * @param [result] - The Array onto which to store the result.
     * @returns The modified Array parameter or a new Array instance if one was not provided.
     */
    static toArray(matrix: Matrix4, result?: number[]): number[];
    /**
     * Computes the array index of the element at the provided row and column.
     * @example
     * const myMatrix = new Cesium.Matrix4();
     * const column1Row0Index = Cesium.Matrix4.getElementIndex(1, 0);
     * const column1Row0 = myMatrix[column1Row0Index];
     * myMatrix[column1Row0Index] = 10.0;
     * @param row - The zero-based index of the row.
     * @param column - The zero-based index of the column.
     * @returns The index of the element at the provided row and column.
     */
    static getElementIndex(row: number, column: number): number;
    /**
     * Retrieves a copy of the matrix column at the provided index as a Cartesian4 instance.
     * @example
     * //returns a Cartesian4 instance with values from the specified column
     * // m = [10.0, 11.0, 12.0, 13.0]
     * //     [14.0, 15.0, 16.0, 17.0]
     * //     [18.0, 19.0, 20.0, 21.0]
     * //     [22.0, 23.0, 24.0, 25.0]
     *
     * //Example 1: Creates an instance of Cartesian
     * const a = Cesium.Matrix4.getColumn(m, 2, new Cesium.Cartesian4());
     * @example
     * //Example 2: Sets values for Cartesian instance
     * const a = new Cesium.Cartesian4();
     * Cesium.Matrix4.getColumn(m, 2, a);
     *
     * // a.x = 12.0; a.y = 16.0; a.z = 20.0; a.w = 24.0;
     * @param matrix - The matrix to use.
     * @param index - The zero-based index of the column to retrieve.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static getColumn(matrix: Matrix4, index: number, result: Cartesian4): Cartesian4;
    /**
     * Computes a new matrix that replaces the specified column in the provided matrix with the provided Cartesian4 instance.
     * @example
     * //creates a new Matrix4 instance with new column values from the Cartesian4 instance
     * // m = [10.0, 11.0, 12.0, 13.0]
     * //     [14.0, 15.0, 16.0, 17.0]
     * //     [18.0, 19.0, 20.0, 21.0]
     * //     [22.0, 23.0, 24.0, 25.0]
     *
     * const a = Cesium.Matrix4.setColumn(m, 2, new Cesium.Cartesian4(99.0, 98.0, 97.0, 96.0), new Cesium.Matrix4());
     *
     * // m remains the same
     * // a = [10.0, 11.0, 99.0, 13.0]
     * //     [14.0, 15.0, 98.0, 17.0]
     * //     [18.0, 19.0, 97.0, 21.0]
     * //     [22.0, 23.0, 96.0, 25.0]
     * @param matrix - The matrix to use.
     * @param index - The zero-based index of the column to set.
     * @param cartesian - The Cartesian whose values will be assigned to the specified column.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static setColumn(matrix: Matrix4, index: number, cartesian: Cartesian4, result: Matrix4): Matrix4;
    /**
     * Retrieves a copy of the matrix row at the provided index as a Cartesian4 instance.
     * @example
     * //returns a Cartesian4 instance with values from the specified column
     * // m = [10.0, 11.0, 12.0, 13.0]
     * //     [14.0, 15.0, 16.0, 17.0]
     * //     [18.0, 19.0, 20.0, 21.0]
     * //     [22.0, 23.0, 24.0, 25.0]
     *
     * //Example 1: Returns an instance of Cartesian
     * const a = Cesium.Matrix4.getRow(m, 2, new Cesium.Cartesian4());
     * @example
     * //Example 2: Sets values for a Cartesian instance
     * const a = new Cesium.Cartesian4();
     * Cesium.Matrix4.getRow(m, 2, a);
     *
     * // a.x = 18.0; a.y = 19.0; a.z = 20.0; a.w = 21.0;
     * @param matrix - The matrix to use.
     * @param index - The zero-based index of the row to retrieve.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static getRow(matrix: Matrix4, index: number, result: Cartesian4): Cartesian4;
    /**
     * Computes a new matrix that replaces the specified row in the provided matrix with the provided Cartesian4 instance.
     * @example
     * //create a new Matrix4 instance with new row values from the Cartesian4 instance
     * // m = [10.0, 11.0, 12.0, 13.0]
     * //     [14.0, 15.0, 16.0, 17.0]
     * //     [18.0, 19.0, 20.0, 21.0]
     * //     [22.0, 23.0, 24.0, 25.0]
     *
     * const a = Cesium.Matrix4.setRow(m, 2, new Cesium.Cartesian4(99.0, 98.0, 97.0, 96.0), new Cesium.Matrix4());
     *
     * // m remains the same
     * // a = [10.0, 11.0, 12.0, 13.0]
     * //     [14.0, 15.0, 16.0, 17.0]
     * //     [99.0, 98.0, 97.0, 96.0]
     * //     [22.0, 23.0, 24.0, 25.0]
     * @param matrix - The matrix to use.
     * @param index - The zero-based index of the row to set.
     * @param cartesian - The Cartesian whose values will be assigned to the specified row.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static setRow(matrix: Matrix4, index: number, cartesian: Cartesian4, result: Matrix4): Matrix4;
    /**
     * Computes a new matrix that replaces the translation in the rightmost column of the provided
     * matrix with the provided translation. This assumes the matrix is an affine transformation.
     * @param matrix - The matrix to use.
     * @param translation - The translation that replaces the translation of the provided matrix.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static setTranslation(matrix: Matrix4, translation: Cartesian3, result: Matrix4): Matrix4;
    /**
     * Computes a new matrix that replaces the scale with the provided scale.
     * This assumes the matrix is an affine transformation.
     * @param matrix - The matrix to use.
     * @param scale - The scale that replaces the scale of the provided matrix.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static setScale(matrix: Matrix4, scale: Cartesian3, result: Matrix4): Matrix4;
    /**
     * Computes a new matrix that replaces the scale with the provided uniform scale.
     * This assumes the matrix is an affine transformation.
     * @param matrix - The matrix to use.
     * @param scale - The uniform scale that replaces the scale of the provided matrix.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static setUniformScale(matrix: Matrix4, scale: number, result: Matrix4): Matrix4;
    /**
     * Extracts the non-uniform scale assuming the matrix is an affine transformation.
     * @param matrix - The matrix.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter
     */
    static getScale(matrix: Matrix4, result: Cartesian3): Cartesian3;
    /**
     * Computes the maximum scale assuming the matrix is an affine transformation.
     * The maximum scale is the maximum length of the column vectors in the upper-left
     * 3x3 matrix.
     * @param matrix - The matrix.
     * @returns The maximum scale.
     */
    static getMaximumScale(matrix: Matrix4): number;
    /**
     * Sets the rotation assuming the matrix is an affine transformation.
     * @param matrix - The matrix.
     * @param rotation - The rotation matrix.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static setRotation(matrix: Matrix4, rotation: Matrix3, result: Matrix4): Matrix4;
    /**
     * Extracts the rotation matrix assuming the matrix is an affine transformation.
     * @param matrix - The matrix.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static getRotation(matrix: Matrix4, result: Matrix3): Matrix3;
    /**
     * Computes the product of two matrices.
     * @param left - The first matrix.
     * @param right - The second matrix.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static multiply(left: Matrix4, right: Matrix4, result: Matrix4): Matrix4;
    /**
     * Computes the sum of two matrices.
     * @param left - The first matrix.
     * @param right - The second matrix.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static add(left: Matrix4, right: Matrix4, result: Matrix4): Matrix4;
    /**
     * Computes the difference of two matrices.
     * @param left - The first matrix.
     * @param right - The second matrix.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static subtract(left: Matrix4, right: Matrix4, result: Matrix4): Matrix4;
    /**
     * Computes the product of two matrices assuming the matrices are affine transformation matrices,
     * where the upper left 3x3 elements are any matrix, and
     * the upper three elements in the fourth column are the translation.
     * The bottom row is assumed to be [0, 0, 0, 1].
     * The matrix is not verified to be in the proper form.
     * This method is faster than computing the product for general 4x4
     * matrices using {@link Matrix4.multiply}.
     * @example
     * const m1 = new Cesium.Matrix4(1.0, 6.0, 7.0, 0.0, 2.0, 5.0, 8.0, 0.0, 3.0, 4.0, 9.0, 0.0, 0.0, 0.0, 0.0, 1.0);
     * const m2 = Cesium.Transforms.eastNorthUpToFixedFrame(new Cesium.Cartesian3(1.0, 1.0, 1.0));
     * const m3 = Cesium.Matrix4.multiplyTransformation(m1, m2, new Cesium.Matrix4());
     * @param left - The first matrix.
     * @param right - The second matrix.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static multiplyTransformation(left: Matrix4, right: Matrix4, result: Matrix4): Matrix4;
    /**
     * Multiplies a transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)
     * by a 3x3 rotation matrix.  This is an optimization
     * for <code>Matrix4.multiply(m, Matrix4.fromRotationTranslation(rotation), m);</code> with less allocations and arithmetic operations.
     * @example
     * // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromRotationTranslation(rotation), m);
     * Cesium.Matrix4.multiplyByMatrix3(m, rotation, m);
     * @param matrix - The matrix on the left-hand side.
     * @param rotation - The 3x3 rotation matrix on the right-hand side.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static multiplyByMatrix3(matrix: Matrix4, rotation: Matrix3, result: Matrix4): Matrix4;
    /**
     * Multiplies a transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)
     * by an implicit translation matrix defined by a {@link Cartesian3}.  This is an optimization
     * for <code>Matrix4.multiply(m, Matrix4.fromTranslation(position), m);</code> with less allocations and arithmetic operations.
     * @example
     * // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromTranslation(position), m);
     * Cesium.Matrix4.multiplyByTranslation(m, position, m);
     * @param matrix - The matrix on the left-hand side.
     * @param translation - The translation on the right-hand side.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static multiplyByTranslation(matrix: Matrix4, translation: Cartesian3, result: Matrix4): Matrix4;
    /**
     * Multiplies an affine transformation matrix (with a bottom row of <code>[0.0, 0.0, 0.0, 1.0]</code>)
     * by an implicit non-uniform scale matrix. This is an optimization
     * for <code>Matrix4.multiply(m, Matrix4.fromUniformScale(scale), m);</code>, where
     * <code>m</code> must be an affine matrix.
     * This function performs fewer allocations and arithmetic operations.
     * @example
     * // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromScale(scale), m);
     * Cesium.Matrix4.multiplyByScale(m, scale, m);
     * @param matrix - The affine matrix on the left-hand side.
     * @param scale - The non-uniform scale on the right-hand side.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static multiplyByScale(matrix: Matrix4, scale: Cartesian3, result: Matrix4): Matrix4;
    /**
     * Computes the product of a matrix times a uniform scale, as if the scale were a scale matrix.
     * @example
     * // Instead of Cesium.Matrix4.multiply(m, Cesium.Matrix4.fromUniformScale(scale), m);
     * Cesium.Matrix4.multiplyByUniformScale(m, scale, m);
     * @param matrix - The matrix on the left-hand side.
     * @param scale - The uniform scale on the right-hand side.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static multiplyByUniformScale(matrix: Matrix4, scale: number, result: Matrix4): Matrix4;
    /**
     * Computes the product of a matrix and a column vector.
     * @param matrix - The matrix.
     * @param cartesian - The vector.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static multiplyByVector(matrix: Matrix4, cartesian: Cartesian4, result: Cartesian4): Cartesian4;
    /**
     * Computes the product of a matrix and a {@link Cartesian3}.  This is equivalent to calling {@link Matrix4.multiplyByVector}
     * with a {@link Cartesian4} with a <code>w</code> component of zero.
     * @example
     * const p = new Cesium.Cartesian3(1.0, 2.0, 3.0);
     * const result = Cesium.Matrix4.multiplyByPointAsVector(matrix, p, new Cesium.Cartesian3());
     * // A shortcut for
     * //   Cartesian3 p = ...
     * //   Cesium.Matrix4.multiplyByVector(matrix, new Cesium.Cartesian4(p.x, p.y, p.z, 0.0), result);
     * @param matrix - The matrix.
     * @param cartesian - The point.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static multiplyByPointAsVector(matrix: Matrix4, cartesian: Cartesian3, result: Cartesian3): Cartesian3;
    /**
     * Computes the product of a matrix and a {@link Cartesian3}. This is equivalent to calling {@link Matrix4.multiplyByVector}
     * with a {@link Cartesian4} with a <code>w</code> component of 1, but returns a {@link Cartesian3} instead of a {@link Cartesian4}.
     * @example
     * const p = new Cesium.Cartesian3(1.0, 2.0, 3.0);
     * const result = Cesium.Matrix4.multiplyByPoint(matrix, p, new Cesium.Cartesian3());
     * @param matrix - The matrix.
     * @param cartesian - The point.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static multiplyByPoint(matrix: Matrix4, cartesian: Cartesian3, result: Cartesian3): Cartesian3;
    /**
     * Computes the product of a matrix and a scalar.
     * @example
     * //create a Matrix4 instance which is a scaled version of the supplied Matrix4
     * // m = [10.0, 11.0, 12.0, 13.0]
     * //     [14.0, 15.0, 16.0, 17.0]
     * //     [18.0, 19.0, 20.0, 21.0]
     * //     [22.0, 23.0, 24.0, 25.0]
     *
     * const a = Cesium.Matrix4.multiplyByScalar(m, -2, new Cesium.Matrix4());
     *
     * // m remains the same
     * // a = [-20.0, -22.0, -24.0, -26.0]
     * //     [-28.0, -30.0, -32.0, -34.0]
     * //     [-36.0, -38.0, -40.0, -42.0]
     * //     [-44.0, -46.0, -48.0, -50.0]
     * @param matrix - The matrix.
     * @param scalar - The number to multiply by.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static multiplyByScalar(matrix: Matrix4, scalar: number, result: Matrix4): Matrix4;
    /**
     * Computes a negated copy of the provided matrix.
     * @example
     * //create a new Matrix4 instance which is a negation of a Matrix4
     * // m = [10.0, 11.0, 12.0, 13.0]
     * //     [14.0, 15.0, 16.0, 17.0]
     * //     [18.0, 19.0, 20.0, 21.0]
     * //     [22.0, 23.0, 24.0, 25.0]
     *
     * const a = Cesium.Matrix4.negate(m, new Cesium.Matrix4());
     *
     * // m remains the same
     * // a = [-10.0, -11.0, -12.0, -13.0]
     * //     [-14.0, -15.0, -16.0, -17.0]
     * //     [-18.0, -19.0, -20.0, -21.0]
     * //     [-22.0, -23.0, -24.0, -25.0]
     * @param matrix - The matrix to negate.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static negate(matrix: Matrix4, result: Matrix4): Matrix4;
    /**
     * Computes the transpose of the provided matrix.
     * @example
     * //returns transpose of a Matrix4
     * // m = [10.0, 11.0, 12.0, 13.0]
     * //     [14.0, 15.0, 16.0, 17.0]
     * //     [18.0, 19.0, 20.0, 21.0]
     * //     [22.0, 23.0, 24.0, 25.0]
     *
     * const a = Cesium.Matrix4.transpose(m, new Cesium.Matrix4());
     *
     * // m remains the same
     * // a = [10.0, 14.0, 18.0, 22.0]
     * //     [11.0, 15.0, 19.0, 23.0]
     * //     [12.0, 16.0, 20.0, 24.0]
     * //     [13.0, 17.0, 21.0, 25.0]
     * @param matrix - The matrix to transpose.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static transpose(matrix: Matrix4, result: Matrix4): Matrix4;
    /**
     * Computes a matrix, which contains the absolute (unsigned) values of the provided matrix's elements.
     * @param matrix - The matrix with signed elements.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static abs(matrix: Matrix4, result: Matrix4): Matrix4;
    /**
     * Compares the provided matrices componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @example
     * //compares two Matrix4 instances
     *
     * // a = [10.0, 14.0, 18.0, 22.0]
     * //     [11.0, 15.0, 19.0, 23.0]
     * //     [12.0, 16.0, 20.0, 24.0]
     * //     [13.0, 17.0, 21.0, 25.0]
     *
     * // b = [10.0, 14.0, 18.0, 22.0]
     * //     [11.0, 15.0, 19.0, 23.0]
     * //     [12.0, 16.0, 20.0, 24.0]
     * //     [13.0, 17.0, 21.0, 25.0]
     *
     * if(Cesium.Matrix4.equals(a,b)) {
     *      console.log("Both matrices are equal");
     * } else {
     *      console.log("They are not equal");
     * }
     *
     * //Prints "Both matrices are equal" on the console
     * @param [left] - The first matrix.
     * @param [right] - The second matrix.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    static equals(left?: Matrix4, right?: Matrix4): boolean;
    /**
     * Compares the provided matrices componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @example
     * //compares two Matrix4 instances
     *
     * // a = [10.5, 14.5, 18.5, 22.5]
     * //     [11.5, 15.5, 19.5, 23.5]
     * //     [12.5, 16.5, 20.5, 24.5]
     * //     [13.5, 17.5, 21.5, 25.5]
     *
     * // b = [10.0, 14.0, 18.0, 22.0]
     * //     [11.0, 15.0, 19.0, 23.0]
     * //     [12.0, 16.0, 20.0, 24.0]
     * //     [13.0, 17.0, 21.0, 25.0]
     *
     * if(Cesium.Matrix4.equalsEpsilon(a,b,0.1)){
     *      console.log("Difference between both the matrices is less than 0.1");
     * } else {
     *      console.log("Difference between both the matrices is not less than 0.1");
     * }
     *
     * //Prints "Difference between both the matrices is not less than 0.1" on the console
     * @param [left] - The first matrix.
     * @param [right] - The second matrix.
     * @param [epsilon = 0] - The epsilon to use for equality testing.
     * @returns <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
     */
    static equalsEpsilon(left?: Matrix4, right?: Matrix4, epsilon?: number): boolean;
    /**
     * Gets the translation portion of the provided matrix, assuming the matrix is an affine transformation matrix.
     * @param matrix - The matrix to use.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static getTranslation(matrix: Matrix4, result: Cartesian3): Cartesian3;
    /**
     * Gets the upper left 3x3 matrix of the provided matrix.
     * @example
     * // returns a Matrix3 instance from a Matrix4 instance
     *
     * // m = [10.0, 14.0, 18.0, 22.0]
     * //     [11.0, 15.0, 19.0, 23.0]
     * //     [12.0, 16.0, 20.0, 24.0]
     * //     [13.0, 17.0, 21.0, 25.0]
     *
     * const b = new Cesium.Matrix3();
     * Cesium.Matrix4.getMatrix3(m,b);
     *
     * // b = [10.0, 14.0, 18.0]
     * //     [11.0, 15.0, 19.0]
     * //     [12.0, 16.0, 20.0]
     * @param matrix - The matrix to use.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static getMatrix3(matrix: Matrix4, result: Matrix3): Matrix3;
    /**
     * Computes the inverse of the provided matrix using Cramers Rule.
     * If the determinant is zero, the matrix can not be inverted, and an exception is thrown.
     * If the matrix is a proper rigid transformation, it is more efficient
     * to invert it with {@link Matrix4.inverseTransformation}.
     * @param matrix - The matrix to invert.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static inverse(matrix: Matrix4, result: Matrix4): Matrix4;
    /**
     * Computes the inverse of the provided matrix assuming it is a proper rigid matrix,
     * where the upper left 3x3 elements are a rotation matrix,
     * and the upper three elements in the fourth column are the translation.
     * The bottom row is assumed to be [0, 0, 0, 1].
     * The matrix is not verified to be in the proper form.
     * This method is faster than computing the inverse for a general 4x4
     * matrix using {@link Matrix4.inverse}.
     * @param matrix - The matrix to invert.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static inverseTransformation(matrix: Matrix4, result: Matrix4): Matrix4;
    /**
     * Computes the inverse transpose of a matrix.
     * @param matrix - The matrix to transpose and invert.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static inverseTranspose(matrix: Matrix4, result: Matrix4): Matrix4;
    /**
     * An immutable Matrix4 instance initialized to the identity matrix.
     */
    static readonly IDENTITY: Matrix4;
    /**
     * An immutable Matrix4 instance initialized to the zero matrix.
     */
    static readonly ZERO: Matrix4;
    /**
     * The index into Matrix4 for column 0, row 0.
     */
    static readonly COLUMN0ROW0: number;
    /**
     * The index into Matrix4 for column 0, row 1.
     */
    static readonly COLUMN0ROW1: number;
    /**
     * The index into Matrix4 for column 0, row 2.
     */
    static readonly COLUMN0ROW2: number;
    /**
     * The index into Matrix4 for column 0, row 3.
     */
    static readonly COLUMN0ROW3: number;
    /**
     * The index into Matrix4 for column 1, row 0.
     */
    static readonly COLUMN1ROW0: number;
    /**
     * The index into Matrix4 for column 1, row 1.
     */
    static readonly COLUMN1ROW1: number;
    /**
     * The index into Matrix4 for column 1, row 2.
     */
    static readonly COLUMN1ROW2: number;
    /**
     * The index into Matrix4 for column 1, row 3.
     */
    static readonly COLUMN1ROW3: number;
    /**
     * The index into Matrix4 for column 2, row 0.
     */
    static readonly COLUMN2ROW0: number;
    /**
     * The index into Matrix4 for column 2, row 1.
     */
    static readonly COLUMN2ROW1: number;
    /**
     * The index into Matrix4 for column 2, row 2.
     */
    static readonly COLUMN2ROW2: number;
    /**
     * The index into Matrix4 for column 2, row 3.
     */
    static readonly COLUMN2ROW3: number;
    /**
     * The index into Matrix4 for column 3, row 0.
     */
    static readonly COLUMN3ROW0: number;
    /**
     * The index into Matrix4 for column 3, row 1.
     */
    static readonly COLUMN3ROW1: number;
    /**
     * The index into Matrix4 for column 3, row 2.
     */
    static readonly COLUMN3ROW2: number;
    /**
     * The index into Matrix4 for column 3, row 3.
     */
    static readonly COLUMN3ROW3: number;
    /**
     * Gets the number of items in the collection.
     */
    length: number;
    /**
     * Duplicates the provided Matrix4 instance.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Matrix4 instance if one was not provided.
     */
    clone(result?: Matrix4): Matrix4;
    /**
     * Compares this matrix to the provided matrix componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [right] - The right hand side matrix.
     * @returns <code>true</code> if they are equal, <code>false</code> otherwise.
     */
    equals(right?: Matrix4): boolean;
    /**
     * Compares this matrix to the provided matrix componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @param [right] - The right hand side matrix.
     * @param [epsilon = 0] - The epsilon to use for equality testing.
     * @returns <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
     */
    equalsEpsilon(right?: Matrix4, epsilon?: number): boolean;
    /**
     * Computes a string representing this Matrix with each row being
     * on a separate line and in the format '(column0, column1, column2, column3)'.
     * @returns A string representing the provided Matrix with each row being on a separate line and in the format '(column0, column1, column2, column3)'.
     */
    toString(): string;
}

/**
 * A spline that linearly interpolates over an array of weight values used by morph targets.
 * @example
 * const times = [ 0.0, 1.5, 3.0, 4.5, 6.0 ];
 * const weights = [0.0, 1.0, 0.25, 0.75, 0.5, 0.5, 0.75, 0.25, 1.0, 0.0]; //Two targets
 * const spline = new Cesium.WeightSpline({
 *     times : times,
 *     weights : weights
 * });
 *
 * const p0 = spline.evaluate(times[0]);
 * @param options - Object with the following properties:
 * @param options.times - An array of strictly increasing, unit-less, floating-point times at each point.
 *                The values are in no way connected to the clock time. They are the parameterization for the curve.
 * @param options.weights - The array of floating-point control weights given. The weights are ordered such
 *                that all weights for the targets are given in chronological order and order in which they appear in
 *                the glTF from which the morph targets come. This means for 2 targets, weights = [w(0,0), w(0,1), w(1,0), w(1,1) ...]
 *                where i and j in w(i,j) are the time indices and target indices, respectively.
 */
export class MorphWeightSpline {
    constructor(options: {
        times: number[];
        weights: number[];
    });
    /**
     * Finds an index <code>i</code> in <code>times</code> such that the parameter
     * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.
     * @param time - The time.
     * @returns The index for the element at the start of the interval.
     */
    findTimeInterval(time: number): number;
    /**
     * Wraps the given time to the period covered by the spline.
     * @param time - The time.
     * @returns The time, wrapped around to the updated animation.
     */
    wrapTime(time: number): number;
    /**
     * Clamps the given time to the period covered by the spline.
     * @param time - The time.
     * @returns The time, clamped to the animation period.
     */
    clampTime(time: number): number;
    /**
     * Evaluates the curve at a given time.
     * @param time - The time at which to evaluate the curve.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new instance of the point on the curve at the given time.
     */
    evaluate(time: number, result?: number[]): number[];
}

/**
 * Represents a scalar value's lower and upper bound at a near distance and far distance in eye space.
 * @param [near = 0.0] - The lower bound of the camera range.
 * @param [nearValue = 0.0] - The value at the lower bound of the camera range.
 * @param [far = 1.0] - The upper bound of the camera range.
 * @param [farValue = 0.0] - The value at the upper bound of the camera range.
 */
export class NearFarScalar {
    constructor(near?: number, nearValue?: number, far?: number, farValue?: number);
    /**
     * The lower bound of the camera range.
     */
    near: number;
    /**
     * The value at the lower bound of the camera range.
     */
    nearValue: number;
    /**
     * The upper bound of the camera range.
     */
    far: number;
    /**
     * The value at the upper bound of the camera range.
     */
    farValue: number;
    /**
     * Duplicates a NearFarScalar instance.
     * @param nearFarScalar - The NearFarScalar to duplicate.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new NearFarScalar instance if one was not provided. (Returns undefined if nearFarScalar is undefined)
     */
    static clone(nearFarScalar: NearFarScalar, result?: NearFarScalar): NearFarScalar;
    /**
     * The number of elements used to pack the object into an array.
     */
    static packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: NearFarScalar, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new NearFarScalar instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: NearFarScalar): NearFarScalar;
    /**
     * Compares the provided NearFarScalar and returns <code>true</code> if they are equal,
     * <code>false</code> otherwise.
     * @param [left] - The first NearFarScalar.
     * @param [right] - The second NearFarScalar.
     * @returns <code>true</code> if left and right are equal; otherwise <code>false</code>.
     */
    static equals(left?: NearFarScalar, right?: NearFarScalar): boolean;
    /**
     * Duplicates this instance.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new NearFarScalar instance if one was not provided.
     */
    clone(result?: NearFarScalar): NearFarScalar;
    /**
     * Compares this instance to the provided NearFarScalar and returns <code>true</code> if they are equal,
     * <code>false</code> otherwise.
     * @param [right] - The right hand side NearFarScalar.
     * @returns <code>true</code> if left and right are equal; otherwise <code>false</code>.
     */
    equals(right?: NearFarScalar): boolean;
}

/**
 * Creates an Occluder derived from an object's position and radius, as well as the camera position.
 * The occluder can be used to determine whether or not other objects are visible or hidden behind the
 * visible horizon defined by the occluder and camera position.
 * @example
 * // Construct an occluder one unit away from the origin with a radius of one.
 * const cameraPosition = Cesium.Cartesian3.ZERO;
 * const occluderBoundingSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -1), 1);
 * const occluder = new Cesium.Occluder(occluderBoundingSphere, cameraPosition);
 * @param occluderBoundingSphere - The bounding sphere surrounding the occluder.
 * @param cameraPosition - The coordinate of the viewer/camera.
 */
export class Occluder {
    constructor(occluderBoundingSphere: BoundingSphere, cameraPosition: Cartesian3);
    /**
     * The position of the occluder.
     */
    position: Cartesian3;
    /**
     * The radius of the occluder.
     */
    radius: number;
    /**
     * The position of the camera.
     */
    cameraPosition: Cartesian3;
    /**
     * Creates an occluder from a bounding sphere and the camera position.
     * @param occluderBoundingSphere - The bounding sphere surrounding the occluder.
     * @param cameraPosition - The coordinate of the viewer/camera.
     * @param [result] - The object onto which to store the result.
     * @returns The occluder derived from an object's position and radius, as well as the camera position.
     */
    static fromBoundingSphere(occluderBoundingSphere: BoundingSphere, cameraPosition: Cartesian3, result?: Occluder): Occluder;
    /**
     * Determines whether or not a point, the <code>occludee</code>, is hidden from view by the occluder.
     * @example
     * const cameraPosition = new Cesium.Cartesian3(0, 0, 0);
     * const littleSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -1), 0.25);
     * const occluder = new Cesium.Occluder(littleSphere, cameraPosition);
     * const point = new Cesium.Cartesian3(0, 0, -3);
     * occluder.isPointVisible(point); //returns true
     * @param occludee - The point surrounding the occludee object.
     * @returns <code>true</code> if the occludee is visible; otherwise <code>false</code>.
     */
    isPointVisible(occludee: Cartesian3): boolean;
    /**
     * Determines whether or not a sphere, the <code>occludee</code>, is hidden from view by the occluder.
     * @example
     * const cameraPosition = new Cesium.Cartesian3(0, 0, 0);
     * const littleSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -1), 0.25);
     * const occluder = new Cesium.Occluder(littleSphere, cameraPosition);
     * const bigSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -3), 1);
     * occluder.isBoundingSphereVisible(bigSphere); //returns true
     * @param occludee - The bounding sphere surrounding the occludee object.
     * @returns <code>true</code> if the occludee is visible; otherwise <code>false</code>.
     */
    isBoundingSphereVisible(occludee: BoundingSphere): boolean;
    /**
     * Determine to what extent an occludee is visible (not visible, partially visible,  or fully visible).
     * @example
     * const sphere1 = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -1.5), 0.5);
     * const sphere2 = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -2.5), 0.5);
     * const cameraPosition = new Cesium.Cartesian3(0, 0, 0);
     * const occluder = new Cesium.Occluder(sphere1, cameraPosition);
     * occluder.computeVisibility(sphere2); //returns Visibility.NONE
     * @param occludeeBS - The bounding sphere of the occludee.
     * @returns Visibility.NONE if the occludee is not visible,
     *                       Visibility.PARTIAL if the occludee is partially visible, or
     *                       Visibility.FULL if the occludee is fully visible.
     */
    computeVisibility(occludeeBS: BoundingSphere): Visibility;
    /**
     * Computes a point that can be used as the occludee position to the visibility functions.
     * Use a radius of zero for the occludee radius.  Typically, a user computes a bounding sphere around
     * an object that is used for visibility; however it is also possible to compute a point that if
     * seen/not seen would also indicate if an object is visible/not visible.  This function is better
     * called for objects that do not move relative to the occluder and is large, such as a chunk of
     * terrain.  You are better off not calling this and using the object's bounding sphere for objects
     * such as a satellite or ground vehicle.
     * @example
     * const cameraPosition = new Cesium.Cartesian3(0, 0, 0);
     * const occluderBoundingSphere = new Cesium.BoundingSphere(new Cesium.Cartesian3(0, 0, -8), 2);
     * const occluder = new Cesium.Occluder(occluderBoundingSphere, cameraPosition);
     * const positions = [new Cesium.Cartesian3(-0.25, 0, -5.3), new Cesium.Cartesian3(0.25, 0, -5.3)];
     * const tileOccluderSphere = Cesium.BoundingSphere.fromPoints(positions);
     * const occludeePosition = tileOccluderSphere.center;
     * const occludeePt = Cesium.Occluder.computeOccludeePoint(occluderBoundingSphere, occludeePosition, positions);
     * @param occluderBoundingSphere - The bounding sphere surrounding the occluder.
     * @param occludeePosition - The point where the occludee (bounding sphere of radius 0) is located.
     * @param positions - List of altitude points on the horizon near the surface of the occluder.
     * @returns An object containing two attributes: <code>occludeePoint</code> and <code>valid</code>
     * which is a boolean value.
     */
    static computeOccludeePoint(occluderBoundingSphere: BoundingSphere, occludeePosition: Cartesian3, positions: Cartesian3[]): any;
    /**
     * Computes a point that can be used as the occludee position to the visibility functions from a rectangle.
     * @param rectangle - The rectangle used to create a bounding sphere.
     * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid used to determine positions of the rectangle.
     * @returns An object containing two attributes: <code>occludeePoint</code> and <code>valid</code>
     * which is a boolean value.
     */
    static computeOccludeePointFromRectangle(rectangle: Rectangle, ellipsoid?: Ellipsoid): any;
}

/**
 * Provides geocoding via a {@link https://opencagedata.com/|OpenCage} server.
 * @example
 * // Configure a Viewer to use the OpenCage Geocoder
 * const viewer = new Cesium.Viewer('cesiumContainer', {
 *   geocoder: new Cesium.OpenCageGeocoderService('https://api.opencagedata.com/geocode/v1/', '<API key>')
 * });
 * @param url - The endpoint to the OpenCage server.
 * @param apiKey - The OpenCage API Key.
 * @param [params] - An object with the following properties (See https://opencagedata.com/api#forward-opt):
 * @param [params.abbrv] - When set to 1 we attempt to abbreviate and shorten the formatted string we return.
 * @param [options.add_request] - When set to 1 the various request parameters are added to the response for ease of debugging.
 * @param [options.bounds] - Provides the geocoder with a hint to the region that the query resides in.
 * @param [options.countrycode] - Restricts the results to the specified country or countries (as defined by the ISO 3166-1 Alpha 2 standard).
 * @param [options.jsonp] - Wraps the returned JSON with a function name.
 * @param [options.language] - An IETF format language code.
 * @param [options.limit] - The maximum number of results we should return.
 * @param [options.min_confidence] - An integer from 1-10. Only results with at least this confidence will be returned.
 * @param [options.no_annotations] - When set to 1 results will not contain annotations.
 * @param [options.no_dedupe] - When set to 1 results will not be deduplicated.
 * @param [options.no_record] - When set to 1 the query contents are not logged.
 * @param [options.pretty] - When set to 1 results are 'pretty' printed for easier reading. Useful for debugging.
 * @param [options.proximity] - Provides the geocoder with a hint to bias results in favour of those closer to the specified location (For example: 41.40139,2.12870).
 */
export class OpenCageGeocoderService {
    constructor(url: Resource | string, apiKey: string, params?: {
        abbrv?: number;
    });
    /**
     * The Resource used to access the OpenCage endpoint.
     */
    readonly url: Resource;
    /**
     * Optional params passed to OpenCage in order to customize geocoding
     */
    readonly params: any;
    /**
     * Gets the credit to display after a geocode is performed. Typically this is used to credit
     * the geocoder service.
     */
    readonly credit: Credit | undefined;
    /**
     * @param query - The query to be sent to the geocoder service
     */
    geocode(query: string): Promise<GeocoderService.Result[]>;
}

/**
 * Creates an instance of an OrientedBoundingBox.
 * An OrientedBoundingBox of some object is a closed and convex rectangular cuboid. It can provide a tighter bounding volume than {@link BoundingSphere} or {@link AxisAlignedBoundingBox} in many cases.
 * @example
 * // Create an OrientedBoundingBox using a transformation matrix, a position where the box will be translated, and a scale.
 * const center = new Cesium.Cartesian3(1.0, 0.0, 0.0);
 * const halfAxes = Cesium.Matrix3.fromScale(new Cesium.Cartesian3(1.0, 3.0, 2.0), new Cesium.Matrix3());
 *
 * const obb = new Cesium.OrientedBoundingBox(center, halfAxes);
 * @param [center = Cartesian3.ZERO] - The center of the box.
 * @param [halfAxes = Matrix3.ZERO] - The three orthogonal half-axes of the bounding box.
 *                                          Equivalently, the transformation matrix, to rotate and scale a 2x2x2
 *                                          cube centered at the origin.
 */
export class OrientedBoundingBox {
    constructor(center?: Cartesian3, halfAxes?: Matrix3);
    /**
     * The center of the box.
     */
    center: Cartesian3;
    /**
     * The three orthogonal half-axes of the bounding box. Equivalently, the
     * transformation matrix, to rotate and scale a 2x2x2 cube centered at the
     * origin.
     */
    halfAxes: Matrix3;
    /**
     * The number of elements used to pack the object into an array.
     */
    static packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: OrientedBoundingBox, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new OrientedBoundingBox instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: OrientedBoundingBox): OrientedBoundingBox;
    /**
     * Computes an instance of an OrientedBoundingBox of the given positions.
     * This is an implementation of Stefan Gottschalk's Collision Queries using Oriented Bounding Boxes solution (PHD thesis).
     * Reference: http://gamma.cs.unc.edu/users/gottschalk/main.pdf
     * @example
     * // Compute an object oriented bounding box enclosing two points.
     * const box = Cesium.OrientedBoundingBox.fromPoints([new Cesium.Cartesian3(2, 0, 0), new Cesium.Cartesian3(-2, 0, 0)]);
     * @param [positions] - List of {@link Cartesian3} points that the bounding box will enclose.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new OrientedBoundingBox instance if one was not provided.
     */
    static fromPoints(positions?: Cartesian3[], result?: OrientedBoundingBox): OrientedBoundingBox;
    /**
     * Computes an OrientedBoundingBox that bounds a {@link Rectangle} on the surface of an {@link Ellipsoid}.
     * There are no guarantees about the orientation of the bounding box.
     * @param rectangle - The cartographic rectangle on the surface of the ellipsoid.
     * @param [minimumHeight = 0.0] - The minimum height (elevation) within the tile.
     * @param [maximumHeight = 0.0] - The maximum height (elevation) within the tile.
     * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid on which the rectangle is defined.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new OrientedBoundingBox instance if none was provided.
     */
    static fromRectangle(rectangle: Rectangle, minimumHeight?: number, maximumHeight?: number, ellipsoid?: Ellipsoid, result?: OrientedBoundingBox): OrientedBoundingBox;
    /**
     * Computes an OrientedBoundingBox that bounds an affine transformation.
     * @param transformation - The affine transformation.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new OrientedBoundingBox instance if none was provided.
     */
    static fromTransformation(transformation: Matrix4, result?: OrientedBoundingBox): OrientedBoundingBox;
    /**
     * Duplicates a OrientedBoundingBox instance.
     * @param box - The bounding box to duplicate.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new OrientedBoundingBox instance if none was provided. (Returns undefined if box is undefined)
     */
    static clone(box: OrientedBoundingBox, result?: OrientedBoundingBox): OrientedBoundingBox;
    /**
     * Determines which side of a plane the oriented bounding box is located.
     * @param box - The oriented bounding box to test.
     * @param plane - The plane to test against.
     * @returns {@link Intersect.INSIDE} if the entire box is on the side of the plane
     *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is
     *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box
     *                      intersects the plane.
     */
    static intersectPlane(box: OrientedBoundingBox, plane: Plane): Intersect;
    /**
     * Computes the estimated distance squared from the closest point on a bounding box to a point.
     * @example
     * // Sort bounding boxes from back to front
     * boxes.sort(function(a, b) {
     *     return Cesium.OrientedBoundingBox.distanceSquaredTo(b, camera.positionWC) - Cesium.OrientedBoundingBox.distanceSquaredTo(a, camera.positionWC);
     * });
     * @param box - The box.
     * @param cartesian - The point
     * @returns The distance squared from the oriented bounding box to the point. Returns 0 if the point is inside the box.
     */
    static distanceSquaredTo(box: OrientedBoundingBox, cartesian: Cartesian3): number;
    /**
     * The distances calculated by the vector from the center of the bounding box to position projected onto direction.
     * <br>
     * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the
     * closest and farthest planes from position that intersect the bounding box.
     * @param box - The bounding box to calculate the distance to.
     * @param position - The position to calculate the distance from.
     * @param direction - The direction from position.
     * @param [result] - A Interval to store the nearest and farthest distances.
     * @returns The nearest and farthest distances on the bounding box from position in direction.
     */
    static computePlaneDistances(box: OrientedBoundingBox, position: Cartesian3, direction: Cartesian3, result?: Interval): Interval;
    /**
     * Computes the eight corners of an oriented bounding box. The corners are ordered by (-X, -Y, -Z), (-X, -Y, +Z), (-X, +Y, -Z), (-X, +Y, +Z), (+X, -Y, -Z), (+X, -Y, +Z), (+X, +Y, -Z), (+X, +Y, +Z).
     * @param box - The oriented bounding box.
     * @param [result] - An array of eight {@link Cartesian3} instances onto which to store the corners.
     * @returns The modified result parameter or a new array if none was provided.
     */
    static computeCorners(box: OrientedBoundingBox, result?: Cartesian3[]): Cartesian3[];
    /**
     * Computes a transformation matrix from an oriented bounding box.
     * @param box - The oriented bounding box.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter or a new {@link Matrix4} instance if none was provided.
     */
    static computeTransformation(box: OrientedBoundingBox, result: Matrix4): Matrix4;
    /**
     * Determines whether or not a bounding box is hidden from view by the occluder.
     * @param box - The bounding box surrounding the occludee object.
     * @param occluder - The occluder.
     * @returns <code>true</code> if the box is not visible; otherwise <code>false</code>.
     */
    static isOccluded(box: OrientedBoundingBox, occluder: Occluder): boolean;
    /**
     * Determines which side of a plane the oriented bounding box is located.
     * @param plane - The plane to test against.
     * @returns {@link Intersect.INSIDE} if the entire box is on the side of the plane
     *                      the normal is pointing, {@link Intersect.OUTSIDE} if the entire box is
     *                      on the opposite side, and {@link Intersect.INTERSECTING} if the box
     *                      intersects the plane.
     */
    intersectPlane(plane: Plane): Intersect;
    /**
     * Computes the estimated distance squared from the closest point on a bounding box to a point.
     * @example
     * // Sort bounding boxes from back to front
     * boxes.sort(function(a, b) {
     *     return b.distanceSquaredTo(camera.positionWC) - a.distanceSquaredTo(camera.positionWC);
     * });
     * @param cartesian - The point
     * @returns The estimated distance squared from the bounding sphere to the point.
     */
    distanceSquaredTo(cartesian: Cartesian3): number;
    /**
     * The distances calculated by the vector from the center of the bounding box to position projected onto direction.
     * <br>
     * If you imagine the infinite number of planes with normal direction, this computes the smallest distance to the
     * closest and farthest planes from position that intersect the bounding box.
     * @param position - The position to calculate the distance from.
     * @param direction - The direction from position.
     * @param [result] - A Interval to store the nearest and farthest distances.
     * @returns The nearest and farthest distances on the bounding box from position in direction.
     */
    computePlaneDistances(position: Cartesian3, direction: Cartesian3, result?: Interval): Interval;
    /**
     * Computes the eight corners of an oriented bounding box. The corners are ordered by (-X, -Y, -Z), (-X, -Y, +Z), (-X, +Y, -Z), (-X, +Y, +Z), (+X, -Y, -Z), (+X, -Y, +Z), (+X, +Y, -Z), (+X, +Y, +Z).
     * @param [result] - An array of eight {@link Cartesian3} instances onto which to store the corners.
     * @returns The modified result parameter or a new array if none was provided.
     */
    computeCorners(result?: Cartesian3[]): Cartesian3[];
    /**
     * Computes a transformation matrix from an oriented bounding box.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter or a new {@link Matrix4} instance if none was provided.
     */
    computeTransformation(result: Matrix4): Matrix4;
    /**
     * Determines whether or not a bounding box is hidden from view by the occluder.
     * @param occluder - The occluder.
     * @returns <code>true</code> if the sphere is not visible; otherwise <code>false</code>.
     */
    isOccluded(occluder: Occluder): boolean;
    /**
     * Compares the provided OrientedBoundingBox componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param left - The first OrientedBoundingBox.
     * @param right - The second OrientedBoundingBox.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    static equals(left: OrientedBoundingBox, right: OrientedBoundingBox): boolean;
    /**
     * Duplicates this OrientedBoundingBox instance.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new OrientedBoundingBox instance if one was not provided.
     */
    clone(result?: OrientedBoundingBox): OrientedBoundingBox;
    /**
     * Compares this OrientedBoundingBox against the provided OrientedBoundingBox componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [right] - The right hand side OrientedBoundingBox.
     * @returns <code>true</code> if they are equal, <code>false</code> otherwise.
     */
    equals(right?: OrientedBoundingBox): boolean;
}

/**
 * The viewing frustum is defined by 6 planes.
 * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components
 * define the unit vector normal to the plane, and the w component is the distance of the
 * plane from the origin/camera position.
 * @example
 * const maxRadii = ellipsoid.maximumRadius;
 *
 * const frustum = new Cesium.OrthographicFrustum();
 * frustum.near = 0.01 * maxRadii;
 * frustum.far = 50.0 * maxRadii;
 * @param [options] - An object with the following properties:
 * @param [options.width] - The width of the frustum in meters.
 * @param [options.aspectRatio] - The aspect ratio of the frustum's width to it's height.
 * @param [options.near = 1.0] - The distance of the near plane.
 * @param [options.far = 500000000.0] - The distance of the far plane.
 */
export class OrthographicFrustum {
    constructor(options?: {
        width?: number;
        aspectRatio?: number;
        near?: number;
        far?: number;
    });
    /**
     * The horizontal width of the frustum in meters.
     */
    width: number;
    /**
     * The aspect ratio of the frustum's width to it's height.
     */
    aspectRatio: number;
    /**
     * The distance of the near plane.
     */
    near: number;
    /**
     * The distance of the far plane.
     */
    far: number;
    /**
     * The number of elements used to pack the object into an array.
     */
    static packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: OrthographicFrustum, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new OrthographicFrustum instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: OrthographicFrustum): OrthographicFrustum;
    /**
     * Gets the orthographic projection matrix computed from the view frustum.
     */
    readonly projectionMatrix: Matrix4;
    /**
     * Creates a culling volume for this frustum.
     * @example
     * // Check if a bounding volume intersects the frustum.
     * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);
     * const intersect = cullingVolume.computeVisibility(boundingVolume);
     * @param position - The eye position.
     * @param direction - The view direction.
     * @param up - The up direction.
     * @returns A culling volume at the given position and orientation.
     */
    computeCullingVolume(position: Cartesian3, direction: Cartesian3, up: Cartesian3): CullingVolume;
    /**
     * Returns the pixel's width and height in meters.
     * @example
     * // Example 1
     * // Get the width and height of a pixel.
     * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 0.0, scene.pixelRatio, new Cesium.Cartesian2());
     * @param drawingBufferWidth - The width of the drawing buffer.
     * @param drawingBufferHeight - The height of the drawing buffer.
     * @param distance - The distance to the near plane in meters.
     * @param pixelRatio - The scaling factor from pixel space to coordinate space.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.
     */
    getPixelDimensions(drawingBufferWidth: number, drawingBufferHeight: number, distance: number, pixelRatio: number, result: Cartesian2): Cartesian2;
    /**
     * Returns a duplicate of a OrthographicFrustum instance.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new OrthographicFrustum instance if one was not provided.
     */
    clone(result?: OrthographicFrustum): OrthographicFrustum;
    /**
     * Compares the provided OrthographicFrustum componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [other] - The right hand side OrthographicFrustum.
     * @returns <code>true</code> if they are equal, <code>false</code> otherwise.
     */
    equals(other?: OrthographicFrustum): boolean;
    /**
     * Compares the provided OrthographicFrustum componentwise and returns
     * <code>true</code> if they pass an absolute or relative tolerance test,
     * <code>false</code> otherwise.
     * @param other - The right hand side OrthographicFrustum.
     * @param relativeEpsilon - The relative epsilon tolerance to use for equality testing.
     * @param [absoluteEpsilon = relativeEpsilon] - The absolute epsilon tolerance to use for equality testing.
     * @returns <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.
     */
    equalsEpsilon(other: OrthographicFrustum, relativeEpsilon: number, absoluteEpsilon?: number): boolean;
}

/**
 * The viewing frustum is defined by 6 planes.
 * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components
 * define the unit vector normal to the plane, and the w component is the distance of the
 * plane from the origin/camera position.
 * @example
 * const maxRadii = ellipsoid.maximumRadius;
 *
 * const frustum = new Cesium.OrthographicOffCenterFrustum();
 * frustum.right = maxRadii * Cesium.Math.PI;
 * frustum.left = -c.frustum.right;
 * frustum.top = c.frustum.right * (canvas.clientHeight / canvas.clientWidth);
 * frustum.bottom = -c.frustum.top;
 * frustum.near = 0.01 * maxRadii;
 * frustum.far = 50.0 * maxRadii;
 * @param [options] - An object with the following properties:
 * @param [options.left] - The left clipping plane distance.
 * @param [options.right] - The right clipping plane distance.
 * @param [options.top] - The top clipping plane distance.
 * @param [options.bottom] - The bottom clipping plane distance.
 * @param [options.near = 1.0] - The near clipping plane distance.
 * @param [options.far = 500000000.0] - The far clipping plane distance.
 */
export class OrthographicOffCenterFrustum {
    constructor(options?: {
        left?: number;
        right?: number;
        top?: number;
        bottom?: number;
        near?: number;
        far?: number;
    });
    /**
     * The left clipping plane.
     */
    left: number;
    /**
     * The right clipping plane.
     */
    right: number;
    /**
     * The top clipping plane.
     */
    top: number;
    /**
     * The bottom clipping plane.
     */
    bottom: number;
    /**
     * The distance of the near plane.
     */
    near: number;
    /**
     * The distance of the far plane.
     */
    far: number;
    /**
     * Gets the orthographic projection matrix computed from the view frustum.
     */
    readonly projectionMatrix: Matrix4;
    /**
     * Creates a culling volume for this frustum.
     * @example
     * // Check if a bounding volume intersects the frustum.
     * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);
     * const intersect = cullingVolume.computeVisibility(boundingVolume);
     * @param position - The eye position.
     * @param direction - The view direction.
     * @param up - The up direction.
     * @returns A culling volume at the given position and orientation.
     */
    computeCullingVolume(position: Cartesian3, direction: Cartesian3, up: Cartesian3): CullingVolume;
    /**
     * Returns the pixel's width and height in meters.
     * @example
     * // Example 1
     * // Get the width and height of a pixel.
     * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 0.0, scene.pixelRatio, new Cesium.Cartesian2());
     * @param drawingBufferWidth - The width of the drawing buffer.
     * @param drawingBufferHeight - The height of the drawing buffer.
     * @param distance - The distance to the near plane in meters.
     * @param pixelRatio - The scaling factor from pixel space to coordinate space.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.
     */
    getPixelDimensions(drawingBufferWidth: number, drawingBufferHeight: number, distance: number, pixelRatio: number, result: Cartesian2): Cartesian2;
    /**
     * Returns a duplicate of a OrthographicOffCenterFrustum instance.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new OrthographicOffCenterFrustum instance if one was not provided.
     */
    clone(result?: OrthographicOffCenterFrustum): OrthographicOffCenterFrustum;
    /**
     * Compares the provided OrthographicOffCenterFrustum componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [other] - The right hand side OrthographicOffCenterFrustum.
     * @returns <code>true</code> if they are equal, <code>false</code> otherwise.
     */
    equals(other?: OrthographicOffCenterFrustum): boolean;
    /**
     * Compares the provided OrthographicOffCenterFrustum componentwise and returns
     * <code>true</code> if they pass an absolute or relative tolerance test,
     * <code>false</code> otherwise.
     * @param other - The right hand side OrthographicOffCenterFrustum.
     * @param relativeEpsilon - The relative epsilon tolerance to use for equality testing.
     * @param [absoluteEpsilon = relativeEpsilon] - The absolute epsilon tolerance to use for equality testing.
     * @returns <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.
     */
    equalsEpsilon(other: OrthographicOffCenterFrustum, relativeEpsilon: number, absoluteEpsilon?: number): boolean;
}

export namespace Packable {
    /**
     * The number of elements used to pack the object into an array.
     */
    var packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     */
    function pack(value: any, array: number[], startingIndex?: number): void;
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new Object instance if one was not provided.
     */
    function unpack(array: number[], startingIndex?: number, result?: any): any;
}

/**
 * Static interface for types which can store their values as packed
 * elements in an array.  These methods and properties are expected to be
 * defined on a constructor function.
 */
export interface Packable {
}

/**
 * Static interface for {@link Packable} types which are interpolated in a
 * different representation than their packed value.  These methods and
 * properties are expected to be defined on a constructor function.
 */
export namespace PackableForInterpolation {
    /**
     * The number of elements used to store the object into an array in its interpolatable form.
     */
    var packedInterpolationLength: number;
    /**
     * Converts a packed array into a form suitable for interpolation.
     * @param packedArray - The packed array.
     * @param [startingIndex = 0] - The index of the first element to be converted.
     * @param [lastIndex = packedArray.length] - The index of the last element to be converted.
     * @param [result] - The object into which to store the result.
     */
    function convertPackedArrayForInterpolation(packedArray: number[], startingIndex?: number, lastIndex?: number, result?: number[]): void;
    /**
     * Retrieves an instance from a packed array converted with {@link PackableForInterpolation.convertPackedArrayForInterpolation}.
     * @param array - The array previously packed for interpolation.
     * @param sourceArray - The original packed array.
     * @param [startingIndex = 0] - The startingIndex used to convert the array.
     * @param [lastIndex = packedArray.length] - The lastIndex used to convert the array.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new Object instance if one was not provided.
     */
    function unpackInterpolationResult(array: number[], sourceArray: number[], startingIndex?: number, lastIndex?: number, result?: any): any;
}

/**
 * Provides geocoding via a {@link https://pelias.io/|Pelias} server.
 * @example
 * // Configure a Viewer to use the Pelias server hosted by https://geocode.earth/
 * const viewer = new Cesium.Viewer('cesiumContainer', {
 *   geocoder: new Cesium.PeliasGeocoderService(new Cesium.Resource({
 *     url: 'https://api.geocode.earth/v1/',
 *       queryParameters: {
 *         api_key: '<Your geocode.earth API key>'
 *     }
 *   }))
 * });
 * @param url - The endpoint to the Pelias server.
 */
export class PeliasGeocoderService {
    constructor(url: Resource | string);
    /**
     * The Resource used to access the Pelias endpoint.
     */
    readonly url: Resource;
    /**
     * Gets the credit to display after a geocode is performed. Typically this is used to credit
     * the geocoder service.
     */
    readonly credit: Credit | undefined;
    /**
     * @param query - The query to be sent to the geocoder service
     * @param [type = GeocodeType.SEARCH] - The type of geocode to perform.
     */
    geocode(query: string, type?: GeocodeType): Promise<GeocoderService.Result[]>;
}

/**
 * The viewing frustum is defined by 6 planes.
 * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components
 * define the unit vector normal to the plane, and the w component is the distance of the
 * plane from the origin/camera position.
 * @example
 * const frustum = new Cesium.PerspectiveFrustum({
 *     fov : Cesium.Math.PI_OVER_THREE,
 *     aspectRatio : canvas.clientWidth / canvas.clientHeight
 *     near : 1.0,
 *     far : 1000.0
 * });
 * @param [options] - An object with the following properties:
 * @param [options.fov] - The angle of the field of view (FOV), in radians.
 * @param [options.aspectRatio] - The aspect ratio of the frustum's width to it's height.
 * @param [options.near = 1.0] - The distance of the near plane.
 * @param [options.far = 500000000.0] - The distance of the far plane.
 * @param [options.xOffset = 0.0] - The offset in the x direction.
 * @param [options.yOffset = 0.0] - The offset in the y direction.
 */
export class PerspectiveFrustum {
    constructor(options?: {
        fov?: number;
        aspectRatio?: number;
        near?: number;
        far?: number;
        xOffset?: number;
        yOffset?: number;
    });
    /**
     * The angle of the field of view (FOV), in radians.  This angle will be used
     * as the horizontal FOV if the width is greater than the height, otherwise
     * it will be the vertical FOV.
     */
    fov: number;
    /**
     * The aspect ratio of the frustum's width to it's height.
     */
    aspectRatio: number;
    /**
     * The distance of the near plane.
     */
    near: number;
    /**
     * The distance of the far plane.
     */
    far: number;
    /**
     * Offsets the frustum in the x direction.
     */
    xOffset: number;
    /**
     * Offsets the frustum in the y direction.
     */
    yOffset: number;
    /**
     * The number of elements used to pack the object into an array.
     */
    static packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: PerspectiveFrustum, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new PerspectiveFrustum instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: PerspectiveFrustum): PerspectiveFrustum;
    /**
     * Gets the perspective projection matrix computed from the view frustum.
     */
    readonly projectionMatrix: Matrix4;
    /**
     * The perspective projection matrix computed from the view frustum with an infinite far plane.
     */
    readonly infiniteProjectionMatrix: Matrix4;
    /**
     * Gets the angle of the vertical field of view, in radians.
     */
    readonly fovy: number;
    /**
     * Creates a culling volume for this frustum.
     * @example
     * // Check if a bounding volume intersects the frustum.
     * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);
     * const intersect = cullingVolume.computeVisibility(boundingVolume);
     * @param position - The eye position.
     * @param direction - The view direction.
     * @param up - The up direction.
     * @returns A culling volume at the given position and orientation.
     */
    computeCullingVolume(position: Cartesian3, direction: Cartesian3, up: Cartesian3): CullingVolume;
    /**
     * Returns the pixel's width and height in meters.
     * @example
     * // Example 1
     * // Get the width and height of a pixel.
     * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, scene.pixelRatio, new Cesium.Cartesian2());
     * @example
     * // Example 2
     * // Get the width and height of a pixel if the near plane was set to 'distance'.
     * // For example, get the size of a pixel of an image on a billboard.
     * const position = camera.position;
     * const direction = camera.direction;
     * const toCenter = Cesium.Cartesian3.subtract(primitive.boundingVolume.center, position, new Cesium.Cartesian3());      // vector from camera to a primitive
     * const toCenterProj = Cesium.Cartesian3.multiplyByScalar(direction, Cesium.Cartesian3.dot(direction, toCenter), new Cesium.Cartesian3()); // project vector onto camera direction vector
     * const distance = Cesium.Cartesian3.magnitude(toCenterProj);
     * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, scene.pixelRatio, new Cesium.Cartesian2());
     * @param drawingBufferWidth - The width of the drawing buffer.
     * @param drawingBufferHeight - The height of the drawing buffer.
     * @param distance - The distance to the near plane in meters.
     * @param pixelRatio - The scaling factor from pixel space to coordinate space.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.
     */
    getPixelDimensions(drawingBufferWidth: number, drawingBufferHeight: number, distance: number, pixelRatio: number, result: Cartesian2): Cartesian2;
    /**
     * Returns a duplicate of a PerspectiveFrustum instance.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new PerspectiveFrustum instance if one was not provided.
     */
    clone(result?: PerspectiveFrustum): PerspectiveFrustum;
    /**
     * Compares the provided PerspectiveFrustum componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [other] - The right hand side PerspectiveFrustum.
     * @returns <code>true</code> if they are equal, <code>false</code> otherwise.
     */
    equals(other?: PerspectiveFrustum): boolean;
    /**
     * Compares the provided PerspectiveFrustum componentwise and returns
     * <code>true</code> if they pass an absolute or relative tolerance test,
     * <code>false</code> otherwise.
     * @param other - The right hand side PerspectiveFrustum.
     * @param relativeEpsilon - The relative epsilon tolerance to use for equality testing.
     * @param [absoluteEpsilon = relativeEpsilon] - The absolute epsilon tolerance to use for equality testing.
     * @returns <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.
     */
    equalsEpsilon(other: PerspectiveFrustum, relativeEpsilon: number, absoluteEpsilon?: number): boolean;
}

/**
 * The viewing frustum is defined by 6 planes.
 * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components
 * define the unit vector normal to the plane, and the w component is the distance of the
 * plane from the origin/camera position.
 * @example
 * const frustum = new Cesium.PerspectiveOffCenterFrustum({
 *     left : -1.0,
 *     right : 1.0,
 *     top : 1.0,
 *     bottom : -1.0,
 *     near : 1.0,
 *     far : 100.0
 * });
 * @param [options] - An object with the following properties:
 * @param [options.left] - The left clipping plane distance.
 * @param [options.right] - The right clipping plane distance.
 * @param [options.top] - The top clipping plane distance.
 * @param [options.bottom] - The bottom clipping plane distance.
 * @param [options.near = 1.0] - The near clipping plane distance.
 * @param [options.far = 500000000.0] - The far clipping plane distance.
 */
export class PerspectiveOffCenterFrustum {
    constructor(options?: {
        left?: number;
        right?: number;
        top?: number;
        bottom?: number;
        near?: number;
        far?: number;
    });
    /**
     * Defines the left clipping plane.
     */
    left: number;
    /**
     * Defines the right clipping plane.
     */
    right: number;
    /**
     * Defines the top clipping plane.
     */
    top: number;
    /**
     * Defines the bottom clipping plane.
     */
    bottom: number;
    /**
     * The distance of the near plane.
     */
    near: number;
    /**
     * The distance of the far plane.
     */
    far: number;
    /**
     * Gets the perspective projection matrix computed from the view frustum.
     */
    readonly projectionMatrix: Matrix4;
    /**
     * Gets the perspective projection matrix computed from the view frustum with an infinite far plane.
     */
    readonly infiniteProjectionMatrix: Matrix4;
    /**
     * Creates a culling volume for this frustum.
     * @example
     * // Check if a bounding volume intersects the frustum.
     * const cullingVolume = frustum.computeCullingVolume(cameraPosition, cameraDirection, cameraUp);
     * const intersect = cullingVolume.computeVisibility(boundingVolume);
     * @param position - The eye position.
     * @param direction - The view direction.
     * @param up - The up direction.
     * @returns A culling volume at the given position and orientation.
     */
    computeCullingVolume(position: Cartesian3, direction: Cartesian3, up: Cartesian3): CullingVolume;
    /**
     * Returns the pixel's width and height in meters.
     * @example
     * // Example 1
     * // Get the width and height of a pixel.
     * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, 1.0, scene.pixelRatio, new Cesium.Cartesian2());
     * @example
     * // Example 2
     * // Get the width and height of a pixel if the near plane was set to 'distance'.
     * // For example, get the size of a pixel of an image on a billboard.
     * const position = camera.position;
     * const direction = camera.direction;
     * const toCenter = Cesium.Cartesian3.subtract(primitive.boundingVolume.center, position, new Cesium.Cartesian3());      // vector from camera to a primitive
     * const toCenterProj = Cesium.Cartesian3.multiplyByScalar(direction, Cesium.Cartesian3.dot(direction, toCenter), new Cesium.Cartesian3()); // project vector onto camera direction vector
     * const distance = Cesium.Cartesian3.magnitude(toCenterProj);
     * const pixelSize = camera.frustum.getPixelDimensions(scene.drawingBufferWidth, scene.drawingBufferHeight, distance, scene.pixelRatio, new Cesium.Cartesian2());
     * @param drawingBufferWidth - The width of the drawing buffer.
     * @param drawingBufferHeight - The height of the drawing buffer.
     * @param distance - The distance to the near plane in meters.
     * @param pixelRatio - The scaling factor from pixel space to coordinate space.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter or a new instance of {@link Cartesian2} with the pixel's width and height in the x and y properties, respectively.
     */
    getPixelDimensions(drawingBufferWidth: number, drawingBufferHeight: number, distance: number, pixelRatio: number, result: Cartesian2): Cartesian2;
    /**
     * Returns a duplicate of a PerspectiveOffCenterFrustum instance.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new PerspectiveFrustum instance if one was not provided.
     */
    clone(result?: PerspectiveOffCenterFrustum): PerspectiveOffCenterFrustum;
    /**
     * Compares the provided PerspectiveOffCenterFrustum componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [other] - The right hand side PerspectiveOffCenterFrustum.
     * @returns <code>true</code> if they are equal, <code>false</code> otherwise.
     */
    equals(other?: PerspectiveOffCenterFrustum): boolean;
    /**
     * Compares the provided PerspectiveOffCenterFrustum componentwise and returns
     * <code>true</code> if they pass an absolute or relative tolerance test,
     * <code>false</code> otherwise.
     * @param other - The right hand side PerspectiveOffCenterFrustum.
     * @param relativeEpsilon - The relative epsilon tolerance to use for equality testing.
     * @param [absoluteEpsilon = relativeEpsilon] - The absolute epsilon tolerance to use for equality testing.
     * @returns <code>true</code> if this and other are within the provided epsilon, <code>false</code> otherwise.
     */
    equalsEpsilon(other: PerspectiveOffCenterFrustum, relativeEpsilon: number, absoluteEpsilon?: number): boolean;
}

/**
 * A utility class for generating custom map pins as canvas elements.
 * <br /><br />
 * <div align='center'>
 * <img src='Images/PinBuilder.png' width='500'/><br />
 * Example pins generated using both the maki icon set, which ships with Cesium, and single character text.
 * </div>
 */
export class PinBuilder {
    constructor();
    /**
     * Creates an empty pin of the specified color and size.
     * @param color - The color of the pin.
     * @param size - The size of the pin, in pixels.
     * @returns The canvas element that represents the generated pin.
     */
    fromColor(color: Color, size: number): HTMLCanvasElement;
    /**
     * Creates a pin with the specified icon, color, and size.
     * @param url - The url of the image to be stamped onto the pin.
     * @param color - The color of the pin.
     * @param size - The size of the pin, in pixels.
     * @returns The canvas element or a Promise to the canvas element that represents the generated pin.
     */
    fromUrl(url: Resource | string, color: Color, size: number): HTMLCanvasElement | Promise<HTMLCanvasElement>;
    /**
     * Creates a pin with the specified {@link https://www.mapbox.com/maki/|maki} icon identifier, color, and size.
     * @param id - The id of the maki icon to be stamped onto the pin.
     * @param color - The color of the pin.
     * @param size - The size of the pin, in pixels.
     * @returns The canvas element or a Promise to the canvas element that represents the generated pin.
     */
    fromMakiIconId(id: string, color: Color, size: number): HTMLCanvasElement | Promise<HTMLCanvasElement>;
    /**
     * Creates a pin with the specified text, color, and size.  The text will be sized to be as large as possible
     * while still being contained completely within the pin.
     * @param text - The text to be stamped onto the pin.
     * @param color - The color of the pin.
     * @param size - The size of the pin, in pixels.
     * @returns The canvas element that represents the generated pin.
     */
    fromText(text: string, color: Color, size: number): HTMLCanvasElement;
}

/**
 * The format of a pixel, i.e., the number of components it has and what they represent.
 */
export enum PixelFormat {
    /**
     * A pixel format containing a depth value.
     */
    DEPTH_COMPONENT = WebGLConstants.DEPTH_COMPONENT,
    /**
     * A pixel format containing a depth and stencil value, most often used with {@link PixelDatatype.UNSIGNED_INT_24_8}.
     */
    DEPTH_STENCIL = WebGLConstants.DEPTH_STENCIL,
    /**
     * A pixel format containing an alpha channel.
     */
    ALPHA = WebGLConstants.ALPHA,
    /**
     * A pixel format containing a red channel
     */
    RED = WebGLConstants.RED,
    /**
     * A pixel format containing red and green channels.
     */
    RG = WebGLConstants.RG,
    /**
     * A pixel format containing red, green, and blue channels.
     */
    RGB = WebGLConstants.RGB,
    /**
     * A pixel format containing red, green, blue, and alpha channels.
     */
    RGBA = WebGLConstants.RGBA,
    /**
     * A pixel format containing a luminance (intensity) channel.
     */
    LUMINANCE = WebGLConstants.LUMINANCE,
    /**
     * A pixel format containing luminance (intensity) and alpha channels.
     */
    LUMINANCE_ALPHA = WebGLConstants.LUMINANCE_ALPHA,
    /**
     * A pixel format containing red, green, and blue channels that is DXT1 compressed.
     */
    RGB_DXT1 = WebGLConstants.COMPRESSED_RGB_S3TC_DXT1_EXT,
    /**
     * A pixel format containing red, green, blue, and alpha channels that is DXT1 compressed.
     */
    RGBA_DXT1 = WebGLConstants.COMPRESSED_RGBA_S3TC_DXT1_EXT,
    /**
     * A pixel format containing red, green, blue, and alpha channels that is DXT3 compressed.
     */
    RGBA_DXT3 = WebGLConstants.COMPRESSED_RGBA_S3TC_DXT3_EXT,
    /**
     * A pixel format containing red, green, blue, and alpha channels that is DXT5 compressed.
     */
    RGBA_DXT5 = WebGLConstants.COMPRESSED_RGBA_S3TC_DXT5_EXT,
    /**
     * A pixel format containing red, green, and blue channels that is PVR 4bpp compressed.
     */
    RGB_PVRTC_4BPPV1 = WebGLConstants.COMPRESSED_RGB_PVRTC_4BPPV1_IMG,
    /**
     * A pixel format containing red, green, and blue channels that is PVR 2bpp compressed.
     */
    RGB_PVRTC_2BPPV1 = WebGLConstants.COMPRESSED_RGB_PVRTC_2BPPV1_IMG,
    /**
     * A pixel format containing red, green, blue, and alpha channels that is PVR 4bpp compressed.
     */
    RGBA_PVRTC_4BPPV1 = WebGLConstants.COMPRESSED_RGBA_PVRTC_4BPPV1_IMG,
    /**
     * A pixel format containing red, green, blue, and alpha channels that is PVR 2bpp compressed.
     */
    RGBA_PVRTC_2BPPV1 = WebGLConstants.COMPRESSED_RGBA_PVRTC_2BPPV1_IMG,
    /**
     * A pixel format containing red, green, blue, and alpha channels that is ASTC compressed.
     */
    RGBA_ASTC = WebGLConstants.COMPRESSED_RGBA_ASTC_4x4_WEBGL,
    /**
     * A pixel format containing red, green, and blue channels that is ETC1 compressed.
     */
    RGB_ETC1 = WebGLConstants.COMPRESSED_RGB_ETC1_WEBGL,
    /**
     * A pixel format containing red, green, and blue channels that is ETC2 compressed.
     */
    RGB8_ETC2 = WebGLConstants.COMPRESSED_RGB8_ETC2,
    /**
     * A pixel format containing red, green, blue, and alpha channels that is ETC2 compressed.
     */
    RGBA8_ETC2_EAC = WebGLConstants.COMPRESSED_RGBA8_ETC2_EAC,
    /**
     * A pixel format containing red, green, blue, and alpha channels that is BC7 compressed.
     */
    RGBA_BC7 = WebGLConstants.COMPRESSED_RGBA_BPTC_UNORM
}

/**
 * A plane in Hessian Normal Form defined by
 * <pre>
 * ax + by + cz + d = 0
 * </pre>
 * where (a, b, c) is the plane's <code>normal</code>, d is the signed
 * <code>distance</code> to the plane, and (x, y, z) is any point on
 * the plane.
 * @example
 * // The plane x=0
 * const plane = new Cesium.Plane(Cesium.Cartesian3.UNIT_X, 0.0);
 * @param normal - The plane's normal (normalized).
 * @param distance - The shortest distance from the origin to the plane.  The sign of
 * <code>distance</code> determines which side of the plane the origin
 * is on.  If <code>distance</code> is positive, the origin is in the half-space
 * in the direction of the normal; if negative, the origin is in the half-space
 * opposite to the normal; if zero, the plane passes through the origin.
 */
export class Plane {
    constructor(normal: Cartesian3, distance: number);
    /**
     * The plane's normal.
     */
    normal: Cartesian3;
    /**
     * The shortest distance from the origin to the plane.  The sign of
     * <code>distance</code> determines which side of the plane the origin
     * is on.  If <code>distance</code> is positive, the origin is in the half-space
     * in the direction of the normal; if negative, the origin is in the half-space
     * opposite to the normal; if zero, the plane passes through the origin.
     */
    distance: number;
    /**
     * Creates a plane from a normal and a point on the plane.
     * @example
     * const point = Cesium.Cartesian3.fromDegrees(-72.0, 40.0);
     * const normal = ellipsoid.geodeticSurfaceNormal(point);
     * const tangentPlane = Cesium.Plane.fromPointNormal(point, normal);
     * @param point - The point on the plane.
     * @param normal - The plane's normal (normalized).
     * @param [result] - The object onto which to store the result.
     * @returns A new plane instance or the modified result parameter.
     */
    static fromPointNormal(point: Cartesian3, normal: Cartesian3, result?: Plane): Plane;
    /**
     * Creates a plane from the general equation
     * @param coefficients - The plane's normal (normalized).
     * @param [result] - The object onto which to store the result.
     * @returns A new plane instance or the modified result parameter.
     */
    static fromCartesian4(coefficients: Cartesian4, result?: Plane): Plane;
    /**
     * Computes the signed shortest distance of a point to a plane.
     * The sign of the distance determines which side of the plane the point
     * is on.  If the distance is positive, the point is in the half-space
     * in the direction of the normal; if negative, the point is in the half-space
     * opposite to the normal; if zero, the plane passes through the point.
     * @param plane - The plane.
     * @param point - The point.
     * @returns The signed shortest distance of the point to the plane.
     */
    static getPointDistance(plane: Plane, point: Cartesian3): number;
    /**
     * Projects a point onto the plane.
     * @param plane - The plane to project the point onto
     * @param point - The point to project onto the plane
     * @param [result] - The result point.  If undefined, a new Cartesian3 will be created.
     * @returns The modified result parameter or a new Cartesian3 instance if one was not provided.
     */
    static projectPointOntoPlane(plane: Plane, point: Cartesian3, result?: Cartesian3): Cartesian3;
    /**
     * Transforms the plane by the given transformation matrix.
     * @param plane - The plane.
     * @param transform - The transformation matrix.
     * @param [result] - The object into which to store the result.
     * @returns The plane transformed by the given transformation matrix.
     */
    static transform(plane: Plane, transform: Matrix4, result?: Plane): Plane;
    /**
     * Duplicates a Plane instance.
     * @param plane - The plane to duplicate.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Plane instance if one was not provided.
     */
    static clone(plane: Plane, result?: Plane): Plane;
    /**
     * Compares the provided Planes by normal and distance and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param left - The first plane.
     * @param right - The second plane.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    static equals(left: Plane, right: Plane): boolean;
    /**
     * A constant initialized to the XY plane passing through the origin, with normal in positive Z.
     */
    static readonly ORIGIN_XY_PLANE: Plane;
    /**
     * A constant initialized to the YZ plane passing through the origin, with normal in positive X.
     */
    static readonly ORIGIN_YZ_PLANE: Plane;
    /**
     * A constant initialized to the ZX plane passing through the origin, with normal in positive Y.
     */
    static readonly ORIGIN_ZX_PLANE: Plane;
}

/**
 * Describes geometry representing a plane centered at the origin, with a unit width and length.
 * @example
 * const planeGeometry = new Cesium.PlaneGeometry({
 *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY
 * });
 * @param [options] - Object with the following properties:
 * @param [options.vertexFormat = VertexFormat.DEFAULT] - The vertex attributes to be computed.
 */
export class PlaneGeometry {
    constructor(options?: {
        vertexFormat?: VertexFormat;
    });
    /**
     * The number of elements used to pack the object into an array.
     */
    static packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: PlaneGeometry, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new PlaneGeometry instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: PlaneGeometry): PlaneGeometry;
    /**
     * Computes the geometric representation of a plane, including its vertices, indices, and a bounding sphere.
     * @param planeGeometry - A description of the plane.
     * @returns The computed vertices and indices.
     */
    static createGeometry(planeGeometry: PlaneGeometry): Geometry | undefined;
}

/**
 * Describes geometry representing the outline of a plane centered at the origin, with a unit width and length.
 */
export class PlaneOutlineGeometry {
    constructor();
    /**
     * The number of elements used to pack the object into an array.
     */
    static packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @returns The array that was packed into
     */
    static pack(value: PlaneOutlineGeometry, array: number[]): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new PlaneOutlineGeometry instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: PlaneOutlineGeometry): PlaneOutlineGeometry;
    /**
     * Computes the geometric representation of an outline of a plane, including its vertices, indices, and a bounding sphere.
     * @returns The computed vertices and indices.
     */
    static createGeometry(): Geometry | undefined;
}

/**
 * A description of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.
 * @example
 * // 1. create a polygon from points
 * const polygon = new Cesium.PolygonGeometry({
 *   polygonHierarchy : new Cesium.PolygonHierarchy(
 *     Cesium.Cartesian3.fromDegreesArray([
 *       -72.0, 40.0,
 *       -70.0, 35.0,
 *       -75.0, 30.0,
 *       -70.0, 30.0,
 *       -68.0, 40.0
 *     ])
 *   )
 * });
 * const geometry = Cesium.PolygonGeometry.createGeometry(polygon);
 *
 * // 2. create a nested polygon with holes
 * const polygonWithHole = new Cesium.PolygonGeometry({
 *   polygonHierarchy : new Cesium.PolygonHierarchy(
 *     Cesium.Cartesian3.fromDegreesArray([
 *       -109.0, 30.0,
 *       -95.0, 30.0,
 *       -95.0, 40.0,
 *       -109.0, 40.0
 *     ]),
 *     [new Cesium.PolygonHierarchy(
 *       Cesium.Cartesian3.fromDegreesArray([
 *         -107.0, 31.0,
 *         -107.0, 39.0,
 *         -97.0, 39.0,
 *         -97.0, 31.0
 *       ]),
 *       [new Cesium.PolygonHierarchy(
 *         Cesium.Cartesian3.fromDegreesArray([
 *           -105.0, 33.0,
 *           -99.0, 33.0,
 *           -99.0, 37.0,
 *           -105.0, 37.0
 *         ]),
 *         [new Cesium.PolygonHierarchy(
 *           Cesium.Cartesian3.fromDegreesArray([
 *             -103.0, 34.0,
 *             -101.0, 34.0,
 *             -101.0, 36.0,
 *             -103.0, 36.0
 *           ])
 *         )]
 *       )]
 *     )]
 *   )
 * });
 * const geometry = Cesium.PolygonGeometry.createGeometry(polygonWithHole);
 *
 * // 3. create extruded polygon
 * const extrudedPolygon = new Cesium.PolygonGeometry({
 *   polygonHierarchy : new Cesium.PolygonHierarchy(
 *     Cesium.Cartesian3.fromDegreesArray([
 *       -72.0, 40.0,
 *       -70.0, 35.0,
 *       -75.0, 30.0,
 *       -70.0, 30.0,
 *       -68.0, 40.0
 *     ])
 *   ),
 *   extrudedHeight: 300000
 * });
 * const geometry = Cesium.PolygonGeometry.createGeometry(extrudedPolygon);
 * @param options - Object with the following properties:
 * @param options.polygonHierarchy - A polygon hierarchy that can include holes.
 * @param [options.height = 0.0] - The distance in meters between the polygon and the ellipsoid surface.
 * @param [options.extrudedHeight] - The distance in meters between the polygon's extruded face and the ellipsoid surface.
 * @param [options.vertexFormat = VertexFormat.DEFAULT] - The vertex attributes to be computed.
 * @param [options.stRotation = 0.0] - The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.
 * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid to be used as a reference.
 * @param [options.granularity = Math.RADIANS_PER_DEGREE] - The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
 * @param [options.perPositionHeight = false] - Use the height of options.positions for each position instead of using options.height to determine the height.
 * @param [options.closeTop = true] - When false, leaves off the top of an extruded polygon open.
 * @param [options.closeBottom = true] - When false, leaves off the bottom of an extruded polygon open.
 * @param [options.arcType = ArcType.GEODESIC] - The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.
 * @param [options.textureCoordinates] - Texture coordinates as a {@link PolygonHierarchy} of {@link Cartesian2} points. Has no effect for ground primitives.
 */
export class PolygonGeometry {
    constructor(options: {
        polygonHierarchy: PolygonHierarchy;
        height?: number;
        extrudedHeight?: number;
        vertexFormat?: VertexFormat;
        stRotation?: number;
        ellipsoid?: Ellipsoid;
        granularity?: number;
        perPositionHeight?: boolean;
        closeTop?: boolean;
        closeBottom?: boolean;
        arcType?: ArcType;
        textureCoordinates?: PolygonHierarchy;
    });
    /**
     * The number of elements used to pack the object into an array.
     */
    packedLength: number;
    /**
     * A description of a polygon from an array of positions. Polygon geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.
     * @example
     * // create a polygon from points
     * const polygon = Cesium.PolygonGeometry.fromPositions({
     *   positions : Cesium.Cartesian3.fromDegreesArray([
     *     -72.0, 40.0,
     *     -70.0, 35.0,
     *     -75.0, 30.0,
     *     -70.0, 30.0,
     *     -68.0, 40.0
     *   ])
     * });
     * const geometry = Cesium.PolygonGeometry.createGeometry(polygon);
     * @param options - Object with the following properties:
     * @param options.positions - An array of positions that defined the corner points of the polygon.
     * @param [options.height = 0.0] - The height of the polygon.
     * @param [options.extrudedHeight] - The height of the polygon extrusion.
     * @param [options.vertexFormat = VertexFormat.DEFAULT] - The vertex attributes to be computed.
     * @param [options.stRotation = 0.0] - The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.
     * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid to be used as a reference.
     * @param [options.granularity = Math.RADIANS_PER_DEGREE] - The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
     * @param [options.perPositionHeight = false] - Use the height of options.positions for each position instead of using options.height to determine the height.
     * @param [options.closeTop = true] - When false, leaves off the top of an extruded polygon open.
     * @param [options.closeBottom = true] - When false, leaves off the bottom of an extruded polygon open.
     * @param [options.arcType = ArcType.GEODESIC] - The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.
     * @param [options.textureCoordinates] - Texture coordinates as a {@link PolygonHierarchy} of {@link Cartesian2} points. Has no effect for ground primitives.
     */
    static fromPositions(options: {
        positions: Cartesian3[];
        height?: number;
        extrudedHeight?: number;
        vertexFormat?: VertexFormat;
        stRotation?: number;
        ellipsoid?: Ellipsoid;
        granularity?: number;
        perPositionHeight?: boolean;
        closeTop?: boolean;
        closeBottom?: boolean;
        arcType?: ArcType;
        textureCoordinates?: PolygonHierarchy;
    }): PolygonGeometry;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: PolygonGeometry, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     */
    static unpack(array: number[], startingIndex?: number, result?: PolygonGeometry): void;
    /**
     * Computes a rectangle which encloses the polygon defined by the list of positions, including cases over the international date line and the poles.
     * @param positions - A linear ring defining the outer boundary of the polygon.
     * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid to be used as a reference.
     * @param [arcType = ArcType.GEODESIC] - The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.
     * @param [result] - An object in which to store the result.
     * @returns The result rectangle
     */
    static computeRectangleFromPositions(positions: Cartesian3[], ellipsoid?: Ellipsoid, arcType?: ArcType, result?: Rectangle): Rectangle;
    /**
     * Returns the bounding rectangle given the provided options
     * @param options - Object with the following properties:
     * @param options.polygonHierarchy - A polygon hierarchy that can include holes.
     * @param [options.granularity = Math.RADIANS_PER_DEGREE] - The distance, in radians, between each latitude and longitude. Determines the number of positions sampled.
     * @param [options.arcType = ArcType.GEODESIC] - The type of line the polygon edges must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.
     * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid to be used as a reference.
     * @param [result] - An object in which to store the result.
     * @returns The result rectangle
     */
    static computeRectangle(options: {
        polygonHierarchy: PolygonHierarchy;
        granularity?: number;
        arcType?: ArcType;
        ellipsoid?: Ellipsoid;
    }, result?: Rectangle): Rectangle;
    /**
     * Computes the geometric representation of a polygon, including its vertices, indices, and a bounding sphere.
     * @param polygonGeometry - A description of the polygon.
     * @returns The computed vertices and indices.
     */
    static createGeometry(polygonGeometry: PolygonGeometry): Geometry | undefined;
}

/**
 * An hierarchy of linear rings which define a polygon and its holes.
 * The holes themselves may also have holes which nest inner polygons.
 * @param [positions] - A linear ring defining the outer boundary of the polygon or hole.
 * @param [holes] - An array of polygon hierarchies defining holes in the polygon.
 */
export class PolygonHierarchy {
    constructor(positions?: Cartesian3[], holes?: PolygonHierarchy[]);
    /**
     * A linear ring defining the outer boundary of the polygon or hole.
     */
    positions: Cartesian3[];
    /**
     * An array of polygon hierarchies defining holes in the polygon.
     */
    holes: PolygonHierarchy[];
}

/**
 * A description of the outline of a polygon on the ellipsoid. The polygon is defined by a polygon hierarchy.
 * @example
 * // 1. create a polygon outline from points
 * const polygon = new Cesium.PolygonOutlineGeometry({
 *   polygonHierarchy : new Cesium.PolygonHierarchy(
 *     Cesium.Cartesian3.fromDegreesArray([
 *       -72.0, 40.0,
 *       -70.0, 35.0,
 *       -75.0, 30.0,
 *       -70.0, 30.0,
 *       -68.0, 40.0
 *     ])
 *   )
 * });
 * const geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygon);
 *
 * // 2. create a nested polygon with holes outline
 * const polygonWithHole = new Cesium.PolygonOutlineGeometry({
 *   polygonHierarchy : new Cesium.PolygonHierarchy(
 *     Cesium.Cartesian3.fromDegreesArray([
 *       -109.0, 30.0,
 *       -95.0, 30.0,
 *       -95.0, 40.0,
 *       -109.0, 40.0
 *     ]),
 *     [new Cesium.PolygonHierarchy(
 *       Cesium.Cartesian3.fromDegreesArray([
 *         -107.0, 31.0,
 *         -107.0, 39.0,
 *         -97.0, 39.0,
 *         -97.0, 31.0
 *       ]),
 *       [new Cesium.PolygonHierarchy(
 *         Cesium.Cartesian3.fromDegreesArray([
 *           -105.0, 33.0,
 *           -99.0, 33.0,
 *           -99.0, 37.0,
 *           -105.0, 37.0
 *         ]),
 *         [new Cesium.PolygonHierarchy(
 *           Cesium.Cartesian3.fromDegreesArray([
 *             -103.0, 34.0,
 *             -101.0, 34.0,
 *             -101.0, 36.0,
 *             -103.0, 36.0
 *           ])
 *         )]
 *       )]
 *     )]
 *   )
 * });
 * const geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygonWithHole);
 *
 * // 3. create extruded polygon outline
 * const extrudedPolygon = new Cesium.PolygonOutlineGeometry({
 *   polygonHierarchy : new Cesium.PolygonHierarchy(
 *     Cesium.Cartesian3.fromDegreesArray([
 *       -72.0, 40.0,
 *       -70.0, 35.0,
 *       -75.0, 30.0,
 *       -70.0, 30.0,
 *       -68.0, 40.0
 *     ])
 *   ),
 *   extrudedHeight: 300000
 * });
 * const geometry = Cesium.PolygonOutlineGeometry.createGeometry(extrudedPolygon);
 * @param options - Object with the following properties:
 * @param options.polygonHierarchy - A polygon hierarchy that can include holes.
 * @param [options.height = 0.0] - The distance in meters between the polygon and the ellipsoid surface.
 * @param [options.extrudedHeight] - The distance in meters between the polygon's extruded face and the ellipsoid surface.
 * @param [options.vertexFormat = VertexFormat.DEFAULT] - The vertex attributes to be computed.
 * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid to be used as a reference.
 * @param [options.granularity = Math.RADIANS_PER_DEGREE] - The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
 * @param [options.perPositionHeight = false] - Use the height of options.positions for each position instead of using options.height to determine the height.
 * @param [options.arcType = ArcType.GEODESIC] - The type of path the outline must follow. Valid options are {@link ArcType.GEODESIC} and {@link ArcType.RHUMB}.
 */
export class PolygonOutlineGeometry {
    constructor(options: {
        polygonHierarchy: PolygonHierarchy;
        height?: number;
        extrudedHeight?: number;
        vertexFormat?: VertexFormat;
        ellipsoid?: Ellipsoid;
        granularity?: number;
        perPositionHeight?: boolean;
        arcType?: ArcType;
    });
    /**
     * The number of elements used to pack the object into an array.
     */
    packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: PolygonOutlineGeometry, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new PolygonOutlineGeometry instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: PolygonOutlineGeometry): PolygonOutlineGeometry;
    /**
     * A description of a polygon outline from an array of positions.
     * @example
     * // create a polygon from points
     * const polygon = Cesium.PolygonOutlineGeometry.fromPositions({
     *   positions : Cesium.Cartesian3.fromDegreesArray([
     *     -72.0, 40.0,
     *     -70.0, 35.0,
     *     -75.0, 30.0,
     *     -70.0, 30.0,
     *     -68.0, 40.0
     *   ])
     * });
     * const geometry = Cesium.PolygonOutlineGeometry.createGeometry(polygon);
     * @param options - Object with the following properties:
     * @param options.positions - An array of positions that defined the corner points of the polygon.
     * @param [options.height = 0.0] - The height of the polygon.
     * @param [options.extrudedHeight] - The height of the polygon extrusion.
     * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid to be used as a reference.
     * @param [options.granularity = Math.RADIANS_PER_DEGREE] - The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
     * @param [options.perPositionHeight = false] - Use the height of options.positions for each position instead of using options.height to determine the height.
     * @param [options.arcType = ArcType.GEODESIC] - The type of path the outline must follow. Valid options are {@link LinkType.GEODESIC} and {@link ArcType.RHUMB}.
     */
    static fromPositions(options: {
        positions: Cartesian3[];
        height?: number;
        extrudedHeight?: number;
        ellipsoid?: Ellipsoid;
        granularity?: number;
        perPositionHeight?: boolean;
        arcType?: ArcType;
    }): PolygonOutlineGeometry;
    /**
     * Computes the geometric representation of a polygon outline, including its vertices, indices, and a bounding sphere.
     * @param polygonGeometry - A description of the polygon outline.
     * @returns The computed vertices and indices.
     */
    static createGeometry(polygonGeometry: PolygonOutlineGeometry): Geometry | undefined;
}

/**
 * A description of a polyline modeled as a line strip; the first two positions define a line segment,
 * and each additional position defines a line segment from the previous position. The polyline is capable of
 * displaying with a material.
 * @example
 * // A polyline with two connected line segments
 * const polyline = new Cesium.PolylineGeometry({
 *   positions : Cesium.Cartesian3.fromDegreesArray([
 *     0.0, 0.0,
 *     5.0, 0.0,
 *     5.0, 5.0
 *   ]),
 *   width : 10.0
 * });
 * const geometry = Cesium.PolylineGeometry.createGeometry(polyline);
 * @param options - Object with the following properties:
 * @param options.positions - An array of {@link Cartesian3} defining the positions in the polyline as a line strip.
 * @param [options.width = 1.0] - The width in pixels.
 * @param [options.colors] - An Array of {@link Color} defining the per vertex or per segment colors.
 * @param [options.colorsPerVertex = false] - A boolean that determines whether the colors will be flat across each segment of the line or interpolated across the vertices.
 * @param [options.arcType = ArcType.GEODESIC] - The type of line the polyline segments must follow.
 * @param [options.granularity = Math.RADIANS_PER_DEGREE] - The distance, in radians, between each latitude and longitude if options.arcType is not ArcType.NONE. Determines the number of positions in the buffer.
 * @param [options.vertexFormat = VertexFormat.DEFAULT] - The vertex attributes to be computed.
 * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid to be used as a reference.
 */
export class PolylineGeometry {
    constructor(options: {
        positions: Cartesian3[];
        width?: number;
        colors?: Color[];
        colorsPerVertex?: boolean;
        arcType?: ArcType;
        granularity?: number;
        vertexFormat?: VertexFormat;
        ellipsoid?: Ellipsoid;
    });
    /**
     * The number of elements used to pack the object into an array.
     */
    packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: PolylineGeometry, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new PolylineGeometry instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: PolylineGeometry): PolylineGeometry;
    /**
     * Computes the geometric representation of a polyline, including its vertices, indices, and a bounding sphere.
     * @param polylineGeometry - A description of the polyline.
     * @returns The computed vertices and indices.
     */
    static createGeometry(polylineGeometry: PolylineGeometry): Geometry | undefined;
}

/**
 * A description of a polyline with a volume (a 2D shape extruded along a polyline).
 * @example
 * function computeCircle(radius) {
 *   const positions = [];
 *   for (let i = 0; i < 360; i++) {
 *     const radians = Cesium.Math.toRadians(i);
 *     positions.push(new Cesium.Cartesian2(radius * Math.cos(radians), radius * Math.sin(radians)));
 *   }
 *   return positions;
 * }
 *
 * const volume = new Cesium.PolylineVolumeGeometry({
 *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY,
 *   polylinePositions : Cesium.Cartesian3.fromDegreesArray([
 *     -72.0, 40.0,
 *     -70.0, 35.0
 *   ]),
 *   shapePositions : computeCircle(100000.0)
 * });
 * @param options - Object with the following properties:
 * @param options.polylinePositions - An array of {@link Cartesian3} positions that define the center of the polyline volume.
 * @param options.shapePositions - An array of {@link Cartesian2} positions that define the shape to be extruded along the polyline
 * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid to be used as a reference.
 * @param [options.granularity = Math.RADIANS_PER_DEGREE] - The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
 * @param [options.vertexFormat = VertexFormat.DEFAULT] - The vertex attributes to be computed.
 * @param [options.cornerType = CornerType.ROUNDED] - Determines the style of the corners.
 */
export class PolylineVolumeGeometry {
    constructor(options: {
        polylinePositions: Cartesian3[];
        shapePositions: Cartesian2[];
        ellipsoid?: Ellipsoid;
        granularity?: number;
        vertexFormat?: VertexFormat;
        cornerType?: CornerType;
    });
    /**
     * The number of elements used to pack the object into an array.
     */
    packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: PolylineVolumeGeometry, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new PolylineVolumeGeometry instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: PolylineVolumeGeometry): PolylineVolumeGeometry;
    /**
     * Computes the geometric representation of a polyline with a volume, including its vertices, indices, and a bounding sphere.
     * @param polylineVolumeGeometry - A description of the polyline volume.
     * @returns The computed vertices and indices.
     */
    static createGeometry(polylineVolumeGeometry: PolylineVolumeGeometry): Geometry | undefined;
}

/**
 * A description of a polyline with a volume (a 2D shape extruded along a polyline).
 * @example
 * function computeCircle(radius) {
 *   const positions = [];
 *   for (let i = 0; i < 360; i++) {
 *     const radians = Cesium.Math.toRadians(i);
 *     positions.push(new Cesium.Cartesian2(radius * Math.cos(radians), radius * Math.sin(radians)));
 *   }
 *   return positions;
 * }
 *
 * const volumeOutline = new Cesium.PolylineVolumeOutlineGeometry({
 *   polylinePositions : Cesium.Cartesian3.fromDegreesArray([
 *     -72.0, 40.0,
 *     -70.0, 35.0
 *   ]),
 *   shapePositions : computeCircle(100000.0)
 * });
 * @param options - Object with the following properties:
 * @param options.polylinePositions - An array of positions that define the center of the polyline volume.
 * @param options.shapePositions - An array of positions that define the shape to be extruded along the polyline
 * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid to be used as a reference.
 * @param [options.granularity = Math.RADIANS_PER_DEGREE] - The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
 * @param [options.cornerType = CornerType.ROUNDED] - Determines the style of the corners.
 */
export class PolylineVolumeOutlineGeometry {
    constructor(options: {
        polylinePositions: Cartesian3[];
        shapePositions: Cartesian2[];
        ellipsoid?: Ellipsoid;
        granularity?: number;
        cornerType?: CornerType;
    });
    /**
     * The number of elements used to pack the object into an array.
     */
    packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: PolylineVolumeOutlineGeometry, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new PolylineVolumeOutlineGeometry instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: PolylineVolumeOutlineGeometry): PolylineVolumeOutlineGeometry;
    /**
     * Computes the geometric representation of the outline of a polyline with a volume, including its vertices, indices, and a bounding sphere.
     * @param polylineVolumeOutlineGeometry - A description of the polyline volume outline.
     * @returns The computed vertices and indices.
     */
    static createGeometry(polylineVolumeOutlineGeometry: PolylineVolumeOutlineGeometry): Geometry | undefined;
}

/**
 * The type of a geometric primitive, i.e., points, lines, and triangles.
 */
export enum PrimitiveType {
    /**
     * Points primitive where each vertex (or index) is a separate point.
     */
    POINTS = WebGLConstants.POINTS,
    /**
     * Lines primitive where each two vertices (or indices) is a line segment.  Line segments are not necessarily connected.
     */
    LINES = WebGLConstants.LINES,
    /**
     * Line loop primitive where each vertex (or index) after the first connects a line to
     * the previous vertex, and the last vertex implicitly connects to the first.
     */
    LINE_LOOP = WebGLConstants.LINE_LOOP,
    /**
     * Line strip primitive where each vertex (or index) after the first connects a line to the previous vertex.
     */
    LINE_STRIP = WebGLConstants.LINE_STRIP,
    /**
     * Triangles primitive where each three vertices (or indices) is a triangle.  Triangles do not necessarily share edges.
     */
    TRIANGLES = WebGLConstants.TRIANGLES,
    /**
     * Triangle strip primitive where each vertex (or index) after the first two connect to
     * the previous two vertices forming a triangle.  For example, this can be used to model a wall.
     */
    TRIANGLE_STRIP = WebGLConstants.TRIANGLE_STRIP,
    /**
     * Triangle fan primitive where each vertex (or index) after the first two connect to
     * the previous vertex and the first vertex forming a triangle.  For example, this can be used
     * to model a cone or circle.
     */
    TRIANGLE_FAN = WebGLConstants.TRIANGLE_FAN
}

/**
 * Base class for proxying requested made by {@link Resource}.
 */
export class Proxy {
    constructor();
    /**
     * Get the final URL to use to request a given resource.
     * @param resource - The resource to request.
     * @returns proxied resource
     */
    getURL(resource: string): string;
}

/**
 * Defines functions for 2nd order polynomial functions of one variable with only real coefficients.
 */
export namespace QuadraticRealPolynomial {
    /**
     * Provides the discriminant of the quadratic equation from the supplied coefficients.
     * @param a - The coefficient of the 2nd order monomial.
     * @param b - The coefficient of the 1st order monomial.
     * @param c - The coefficient of the 0th order monomial.
     * @returns The value of the discriminant.
     */
    function computeDiscriminant(a: number, b: number, c: number): number;
    /**
     * Provides the real valued roots of the quadratic polynomial with the provided coefficients.
     * @param a - The coefficient of the 2nd order monomial.
     * @param b - The coefficient of the 1st order monomial.
     * @param c - The coefficient of the 0th order monomial.
     * @returns The real valued roots.
     */
    function computeRealRoots(a: number, b: number, c: number): number[];
}

/**
 * Terrain data for a single tile where the terrain data is represented as a quantized mesh.  A quantized
 * mesh consists of three vertex attributes, longitude, latitude, and height.  All attributes are expressed
 * as 16-bit values in the range 0 to 32767.  Longitude and latitude are zero at the southwest corner
 * of the tile and 32767 at the northeast corner.  Height is zero at the minimum height in the tile
 * and 32767 at the maximum height in the tile.
 * @example
 * const data = new Cesium.QuantizedMeshTerrainData({
 *     minimumHeight : -100,
 *     maximumHeight : 2101,
 *     quantizedVertices : new Uint16Array([// order is SW NW SE NE
 *                                          // longitude
 *                                          0, 0, 32767, 32767,
 *                                          // latitude
 *                                          0, 32767, 0, 32767,
 *                                          // heights
 *                                          16384, 0, 32767, 16384]),
 *     indices : new Uint16Array([0, 3, 1,
 *                                0, 2, 3]),
 *     boundingSphere : new Cesium.BoundingSphere(new Cesium.Cartesian3(1.0, 2.0, 3.0), 10000),
 *     orientedBoundingBox : new Cesium.OrientedBoundingBox(new Cesium.Cartesian3(1.0, 2.0, 3.0), Cesium.Matrix3.fromRotationX(Cesium.Math.PI, new Cesium.Matrix3())),
 *     horizonOcclusionPoint : new Cesium.Cartesian3(3.0, 2.0, 1.0),
 *     westIndices : [0, 1],
 *     southIndices : [0, 1],
 *     eastIndices : [2, 3],
 *     northIndices : [1, 3],
 *     westSkirtHeight : 1.0,
 *     southSkirtHeight : 1.0,
 *     eastSkirtHeight : 1.0,
 *     northSkirtHeight : 1.0
 * });
 * @param options - Object with the following properties:
 * @param options.quantizedVertices - The buffer containing the quantized mesh.
 * @param options.indices - The indices specifying how the quantized vertices are linked
 *                      together into triangles.  Each three indices specifies one triangle.
 * @param options.minimumHeight - The minimum terrain height within the tile, in meters above the ellipsoid.
 * @param options.maximumHeight - The maximum terrain height within the tile, in meters above the ellipsoid.
 * @param options.boundingSphere - A sphere bounding all of the vertices in the mesh.
 * @param [options.orientedBoundingBox] - An OrientedBoundingBox bounding all of the vertices in the mesh.
 * @param options.horizonOcclusionPoint - The horizon occlusion point of the mesh.  If this point
 *                      is below the horizon, the entire tile is assumed to be below the horizon as well.
 *                      The point is expressed in ellipsoid-scaled coordinates.
 * @param options.westIndices - The indices of the vertices on the western edge of the tile.
 * @param options.southIndices - The indices of the vertices on the southern edge of the tile.
 * @param options.eastIndices - The indices of the vertices on the eastern edge of the tile.
 * @param options.northIndices - The indices of the vertices on the northern edge of the tile.
 * @param options.westSkirtHeight - The height of the skirt to add on the western edge of the tile.
 * @param options.southSkirtHeight - The height of the skirt to add on the southern edge of the tile.
 * @param options.eastSkirtHeight - The height of the skirt to add on the eastern edge of the tile.
 * @param options.northSkirtHeight - The height of the skirt to add on the northern edge of the tile.
 * @param [options.childTileMask = 15] - A bit mask indicating which of this tile's four children exist.
 *                 If a child's bit is set, geometry will be requested for that tile as well when it
 *                 is needed.  If the bit is cleared, the child tile is not requested and geometry is
 *                 instead upsampled from the parent.  The bit values are as follows:
 *                 <table>
 *                  <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>
 *                  <tr><td>0</td><td>1</td><td>Southwest</td></tr>
 *                  <tr><td>1</td><td>2</td><td>Southeast</td></tr>
 *                  <tr><td>2</td><td>4</td><td>Northwest</td></tr>
 *                  <tr><td>3</td><td>8</td><td>Northeast</td></tr>
 *                 </table>
 * @param [options.createdByUpsampling = false] - True if this instance was created by upsampling another instance;
 *                  otherwise, false.
 * @param [options.encodedNormals] - The buffer containing per vertex normals, encoded using 'oct' encoding
 * @param [options.waterMask] - The buffer containing the watermask.
 * @param [options.credits] - Array of credits for this tile.
 */
export class QuantizedMeshTerrainData {
    constructor(options: {
        quantizedVertices: Uint16Array;
        indices: Uint16Array | Uint32Array;
        minimumHeight: number;
        maximumHeight: number;
        boundingSphere: BoundingSphere;
        orientedBoundingBox?: OrientedBoundingBox;
        horizonOcclusionPoint: Cartesian3;
        westIndices: number[];
        southIndices: number[];
        eastIndices: number[];
        northIndices: number[];
        westSkirtHeight: number;
        southSkirtHeight: number;
        eastSkirtHeight: number;
        northSkirtHeight: number;
        childTileMask?: number;
        createdByUpsampling?: boolean;
        encodedNormals?: Uint8Array;
        waterMask?: Uint8Array;
        credits?: Credit[];
    });
    /**
     * An array of credits for this tile.
     */
    credits: Credit[];
    /**
     * The water mask included in this terrain data, if any.  A water mask is a rectangular
     * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.
     * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.
     */
    waterMask: Uint8Array | HTMLImageElement | HTMLCanvasElement;
    /**
     * Upsamples this terrain data for use by a descendant tile.  The resulting instance will contain a subset of the
     * vertices in this instance, interpolated if necessary.
     * @param tilingScheme - The tiling scheme of this terrain data.
     * @param thisX - The X coordinate of this tile in the tiling scheme.
     * @param thisY - The Y coordinate of this tile in the tiling scheme.
     * @param thisLevel - The level of this tile in the tiling scheme.
     * @param descendantX - The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.
     * @param descendantY - The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.
     * @param descendantLevel - The level within the tiling scheme of the descendant tile for which we are upsampling.
     * @returns A promise for upsampled heightmap terrain data for the descendant tile,
     *          or undefined if too many asynchronous upsample operations are in progress and the request has been
     *          deferred.
     */
    upsample(tilingScheme: TilingScheme, thisX: number, thisY: number, thisLevel: number, descendantX: number, descendantY: number, descendantLevel: number): Promise<QuantizedMeshTerrainData> | undefined;
    /**
     * Computes the terrain height at a specified longitude and latitude.
     * @param rectangle - The rectangle covered by this terrain data.
     * @param longitude - The longitude in radians.
     * @param latitude - The latitude in radians.
     * @returns The terrain height at the specified position.  The position is clamped to
     *          the rectangle, so expect incorrect results for positions far outside the rectangle.
     */
    interpolateHeight(rectangle: Rectangle, longitude: number, latitude: number): number;
    /**
     * Determines if a given child tile is available, based on the
     * {@link HeightmapTerrainData.childTileMask}.  The given child tile coordinates are assumed
     * to be one of the four children of this tile.  If non-child tile coordinates are
     * given, the availability of the southeast child tile is returned.
     * @param thisX - The tile X coordinate of this (the parent) tile.
     * @param thisY - The tile Y coordinate of this (the parent) tile.
     * @param childX - The tile X coordinate of the child tile to check for availability.
     * @param childY - The tile Y coordinate of the child tile to check for availability.
     * @returns True if the child tile is available; otherwise, false.
     */
    isChildAvailable(thisX: number, thisY: number, childX: number, childY: number): boolean;
    /**
     * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution
     * terrain data.  If this value is false, the data was obtained from some other source, such
     * as by downloading it from a remote server.  This method should return true for instances
     * returned from a call to {@link HeightmapTerrainData#upsample}.
     * @returns True if this instance was created by upsampling; otherwise, false.
     */
    wasCreatedByUpsampling(): boolean;
}

/**
 * Defines functions for 4th order polynomial functions of one variable with only real coefficients.
 */
export namespace QuarticRealPolynomial {
    /**
     * Provides the discriminant of the quartic equation from the supplied coefficients.
     * @param a - The coefficient of the 4th order monomial.
     * @param b - The coefficient of the 3rd order monomial.
     * @param c - The coefficient of the 2nd order monomial.
     * @param d - The coefficient of the 1st order monomial.
     * @param e - The coefficient of the 0th order monomial.
     * @returns The value of the discriminant.
     */
    function computeDiscriminant(a: number, b: number, c: number, d: number, e: number): number;
    /**
     * Provides the real valued roots of the quartic polynomial with the provided coefficients.
     * @param a - The coefficient of the 4th order monomial.
     * @param b - The coefficient of the 3rd order monomial.
     * @param c - The coefficient of the 2nd order monomial.
     * @param d - The coefficient of the 1st order monomial.
     * @param e - The coefficient of the 0th order monomial.
     * @returns The real valued roots.
     */
    function computeRealRoots(a: number, b: number, c: number, d: number, e: number): number[];
}

/**
 * A set of 4-dimensional coordinates used to represent rotation in 3-dimensional space.
 * @param [x = 0.0] - The X component.
 * @param [y = 0.0] - The Y component.
 * @param [z = 0.0] - The Z component.
 * @param [w = 0.0] - The W component.
 */
export class Quaternion {
    constructor(x?: number, y?: number, z?: number, w?: number);
    /**
     * The X component.
     */
    x: number;
    /**
     * The Y component.
     */
    y: number;
    /**
     * The Z component.
     */
    z: number;
    /**
     * The W component.
     */
    w: number;
    /**
     * Computes a quaternion representing a rotation around an axis.
     * @param axis - The axis of rotation.
     * @param angle - The angle in radians to rotate around the axis.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Quaternion instance if one was not provided.
     */
    static fromAxisAngle(axis: Cartesian3, angle: number, result?: Quaternion): Quaternion;
    /**
     * Computes a Quaternion from the provided Matrix3 instance.
     * @param matrix - The rotation matrix.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Quaternion instance if one was not provided.
     */
    static fromRotationMatrix(matrix: Matrix3, result?: Quaternion): Quaternion;
    /**
     * Computes a rotation from the given heading, pitch and roll angles. Heading is the rotation about the
     * negative z axis. Pitch is the rotation about the negative y axis. Roll is the rotation about
     * the positive x axis.
     * @param headingPitchRoll - The rotation expressed as a heading, pitch and roll.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Quaternion instance if none was provided.
     */
    static fromHeadingPitchRoll(headingPitchRoll: HeadingPitchRoll, result?: Quaternion): Quaternion;
    /**
     * The number of elements used to pack the object into an array.
     */
    static packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: Quaternion, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new Quaternion instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: Quaternion): Quaternion;
    /**
     * The number of elements used to store the object into an array in its interpolatable form.
     */
    static packedInterpolationLength: number;
    /**
     * Converts a packed array into a form suitable for interpolation.
     * @param packedArray - The packed array.
     * @param [startingIndex = 0] - The index of the first element to be converted.
     * @param [lastIndex = packedArray.length] - The index of the last element to be converted.
     * @param [result] - The object into which to store the result.
     */
    static convertPackedArrayForInterpolation(packedArray: number[], startingIndex?: number, lastIndex?: number, result?: number[]): void;
    /**
     * Retrieves an instance from a packed array converted with {@link convertPackedArrayForInterpolation}.
     * @param array - The array previously packed for interpolation.
     * @param sourceArray - The original packed array.
     * @param [firstIndex = 0] - The firstIndex used to convert the array.
     * @param [lastIndex = packedArray.length] - The lastIndex used to convert the array.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new Quaternion instance if one was not provided.
     */
    static unpackInterpolationResult(array: number[], sourceArray: number[], firstIndex?: number, lastIndex?: number, result?: Quaternion): Quaternion;
    /**
     * Duplicates a Quaternion instance.
     * @param quaternion - The quaternion to duplicate.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Quaternion instance if one was not provided. (Returns undefined if quaternion is undefined)
     */
    static clone(quaternion: Quaternion, result?: Quaternion): Quaternion;
    /**
     * Computes the conjugate of the provided quaternion.
     * @param quaternion - The quaternion to conjugate.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static conjugate(quaternion: Quaternion, result: Quaternion): Quaternion;
    /**
     * Computes magnitude squared for the provided quaternion.
     * @param quaternion - The quaternion to conjugate.
     * @returns The magnitude squared.
     */
    static magnitudeSquared(quaternion: Quaternion): number;
    /**
     * Computes magnitude for the provided quaternion.
     * @param quaternion - The quaternion to conjugate.
     * @returns The magnitude.
     */
    static magnitude(quaternion: Quaternion): number;
    /**
     * Computes the normalized form of the provided quaternion.
     * @param quaternion - The quaternion to normalize.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static normalize(quaternion: Quaternion, result: Quaternion): Quaternion;
    /**
     * Computes the inverse of the provided quaternion.
     * @param quaternion - The quaternion to normalize.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static inverse(quaternion: Quaternion, result: Quaternion): Quaternion;
    /**
     * Computes the componentwise sum of two quaternions.
     * @param left - The first quaternion.
     * @param right - The second quaternion.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static add(left: Quaternion, right: Quaternion, result: Quaternion): Quaternion;
    /**
     * Computes the componentwise difference of two quaternions.
     * @param left - The first quaternion.
     * @param right - The second quaternion.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static subtract(left: Quaternion, right: Quaternion, result: Quaternion): Quaternion;
    /**
     * Negates the provided quaternion.
     * @param quaternion - The quaternion to be negated.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static negate(quaternion: Quaternion, result: Quaternion): Quaternion;
    /**
     * Computes the dot (scalar) product of two quaternions.
     * @param left - The first quaternion.
     * @param right - The second quaternion.
     * @returns The dot product.
     */
    static dot(left: Quaternion, right: Quaternion): number;
    /**
     * Computes the product of two quaternions.
     * @param left - The first quaternion.
     * @param right - The second quaternion.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static multiply(left: Quaternion, right: Quaternion, result: Quaternion): Quaternion;
    /**
     * Multiplies the provided quaternion componentwise by the provided scalar.
     * @param quaternion - The quaternion to be scaled.
     * @param scalar - The scalar to multiply with.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static multiplyByScalar(quaternion: Quaternion, scalar: number, result: Quaternion): Quaternion;
    /**
     * Divides the provided quaternion componentwise by the provided scalar.
     * @param quaternion - The quaternion to be divided.
     * @param scalar - The scalar to divide by.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static divideByScalar(quaternion: Quaternion, scalar: number, result: Quaternion): Quaternion;
    /**
     * Computes the axis of rotation of the provided quaternion.
     * @param quaternion - The quaternion to use.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static computeAxis(quaternion: Quaternion, result: Cartesian3): Cartesian3;
    /**
     * Computes the angle of rotation of the provided quaternion.
     * @param quaternion - The quaternion to use.
     * @returns The angle of rotation.
     */
    static computeAngle(quaternion: Quaternion): number;
    /**
     * Computes the linear interpolation or extrapolation at t using the provided quaternions.
     * @param start - The value corresponding to t at 0.0.
     * @param end - The value corresponding to t at 1.0.
     * @param t - The point along t at which to interpolate.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static lerp(start: Quaternion, end: Quaternion, t: number, result: Quaternion): Quaternion;
    /**
     * Computes the spherical linear interpolation or extrapolation at t using the provided quaternions.
     * @param start - The value corresponding to t at 0.0.
     * @param end - The value corresponding to t at 1.0.
     * @param t - The point along t at which to interpolate.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static slerp(start: Quaternion, end: Quaternion, t: number, result: Quaternion): Quaternion;
    /**
     * The logarithmic quaternion function.
     * @param quaternion - The unit quaternion.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static log(quaternion: Quaternion, result: Cartesian3): Cartesian3;
    /**
     * The exponential quaternion function.
     * @param cartesian - The cartesian.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static exp(cartesian: Cartesian3, result: Quaternion): Quaternion;
    /**
     * Computes an inner quadrangle point.
     * <p>This will compute quaternions that ensure a squad curve is C<sup>1</sup>.</p>
     * @param q0 - The first quaternion.
     * @param q1 - The second quaternion.
     * @param q2 - The third quaternion.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static computeInnerQuadrangle(q0: Quaternion, q1: Quaternion, q2: Quaternion, result: Quaternion): Quaternion;
    /**
     * Computes the spherical quadrangle interpolation between quaternions.
     * @example
     * // 1. compute the squad interpolation between two quaternions on a curve
     * const s0 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[i - 1], quaternions[i], quaternions[i + 1], new Cesium.Quaternion());
     * const s1 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[i], quaternions[i + 1], quaternions[i + 2], new Cesium.Quaternion());
     * const q = Cesium.Quaternion.squad(quaternions[i], quaternions[i + 1], s0, s1, t, new Cesium.Quaternion());
     *
     * // 2. compute the squad interpolation as above but where the first quaternion is a end point.
     * const s1 = Cesium.Quaternion.computeInnerQuadrangle(quaternions[0], quaternions[1], quaternions[2], new Cesium.Quaternion());
     * const q = Cesium.Quaternion.squad(quaternions[0], quaternions[1], quaternions[0], s1, t, new Cesium.Quaternion());
     * @param q0 - The first quaternion.
     * @param q1 - The second quaternion.
     * @param s0 - The first inner quadrangle.
     * @param s1 - The second inner quadrangle.
     * @param t - The time in [0,1] used to interpolate.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static squad(q0: Quaternion, q1: Quaternion, s0: Quaternion, s1: Quaternion, t: number, result: Quaternion): Quaternion;
    /**
     * Computes the spherical linear interpolation or extrapolation at t using the provided quaternions.
     * This implementation is faster than {@link Quaternion#slerp}, but is only accurate up to 10<sup>-6</sup>.
     * @param start - The value corresponding to t at 0.0.
     * @param end - The value corresponding to t at 1.0.
     * @param t - The point along t at which to interpolate.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter.
     */
    static fastSlerp(start: Quaternion, end: Quaternion, t: number, result: Quaternion): Quaternion;
    /**
     * Computes the spherical quadrangle interpolation between quaternions.
     * An implementation that is faster than {@link Quaternion#squad}, but less accurate.
     * @param q0 - The first quaternion.
     * @param q1 - The second quaternion.
     * @param s0 - The first inner quadrangle.
     * @param s1 - The second inner quadrangle.
     * @param t - The time in [0,1] used to interpolate.
     * @param result - The object onto which to store the result.
     * @returns The modified result parameter or a new instance if none was provided.
     */
    static fastSquad(q0: Quaternion, q1: Quaternion, s0: Quaternion, s1: Quaternion, t: number, result: Quaternion): Quaternion;
    /**
     * Compares the provided quaternions componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [left] - The first quaternion.
     * @param [right] - The second quaternion.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    static equals(left?: Quaternion, right?: Quaternion): boolean;
    /**
     * Compares the provided quaternions componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @param [left] - The first quaternion.
     * @param [right] - The second quaternion.
     * @param [epsilon = 0] - The epsilon to use for equality testing.
     * @returns <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
     */
    static equalsEpsilon(left?: Quaternion, right?: Quaternion, epsilon?: number): boolean;
    /**
     * An immutable Quaternion instance initialized to (0.0, 0.0, 0.0, 0.0).
     */
    static readonly ZERO: Quaternion;
    /**
     * An immutable Quaternion instance initialized to (0.0, 0.0, 0.0, 1.0).
     */
    static readonly IDENTITY: Quaternion;
    /**
     * Duplicates this Quaternion instance.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Quaternion instance if one was not provided.
     */
    clone(result?: Quaternion): Quaternion;
    /**
     * Compares this and the provided quaternion componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [right] - The right hand side quaternion.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    equals(right?: Quaternion): boolean;
    /**
     * Compares this and the provided quaternion componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @param [right] - The right hand side quaternion.
     * @param [epsilon = 0] - The epsilon to use for equality testing.
     * @returns <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
     */
    equalsEpsilon(right?: Quaternion, epsilon?: number): boolean;
    /**
     * Returns a string representing this quaternion in the format (x, y, z, w).
     * @returns A string representing this Quaternion.
     */
    toString(): string;
}

/**
 * A spline that uses spherical linear (slerp) interpolation to create a quaternion curve.
 * The generated curve is in the class C<sup>1</sup>.
 * @param options - Object with the following properties:
 * @param options.times - An array of strictly increasing, unit-less, floating-point times at each point.
 *                The values are in no way connected to the clock time. They are the parameterization for the curve.
 * @param options.points - The array of {@link Quaternion} control points.
 */
export class QuaternionSpline {
    constructor(options: {
        times: number[];
        points: Quaternion[];
    });
    /**
     * An array of times for the control points.
     */
    readonly times: number[];
    /**
     * An array of {@link Quaternion} control points.
     */
    readonly points: Quaternion[];
    /**
     * Finds an index <code>i</code> in <code>times</code> such that the parameter
     * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.
     * @param time - The time.
     * @returns The index for the element at the start of the interval.
     */
    findTimeInterval(time: number): number;
    /**
     * Wraps the given time to the period covered by the spline.
     * @param time - The time.
     * @returns The time, wrapped around to the updated animation.
     */
    wrapTime(time: number): number;
    /**
     * Clamps the given time to the period covered by the spline.
     * @param time - The time.
     * @returns The time, clamped to the animation period.
     */
    clampTime(time: number): number;
    /**
     * Evaluates the curve at a given time.
     * @param time - The time at which to evaluate the curve.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new instance of the point on the curve at the given time.
     */
    evaluate(time: number, result?: Quaternion): Quaternion;
}

/**
 * A queue that can enqueue items at the end, and dequeue items from the front.
 */
export class Queue {
    constructor();
    /**
     * The length of the queue.
     */
    readonly length: number;
    /**
     * Enqueues the specified item.
     * @param item - The item to enqueue.
     */
    enqueue(item: any): void;
    /**
     * Dequeues an item.  Returns undefined if the queue is empty.
     * @returns The the dequeued item.
     */
    dequeue(): any;
    /**
     * Returns the item at the front of the queue.  Returns undefined if the queue is empty.
     * @returns The item at the front of the queue.
     */
    peek(): any;
    /**
     * Check whether this queue contains the specified item.
     * @param item - The item to search for.
     */
    contains(item: any): void;
    /**
     * Remove all items from the queue.
     */
    clear(): void;
    /**
     * Sort the items in the queue in-place.
     * @param compareFunction - A function that defines the sort order.
     */
    sort(compareFunction: Queue.Comparator): void;
}

export namespace Queue {
    /**
     * A function used to compare two items while sorting a queue.
     * @example
     * function compareNumbers(a, b) {
     *     return a - b;
     * }
     * @param a - An item in the array.
     * @param b - An item in the array.
     */
    type Comparator = (a: any, b: any) => number;
}

/**
 * Represents a ray that extends infinitely from the provided origin in the provided direction.
 * @param [origin = Cartesian3.ZERO] - The origin of the ray.
 * @param [direction = Cartesian3.ZERO] - The direction of the ray.
 */
export class Ray {
    constructor(origin?: Cartesian3, direction?: Cartesian3);
    /**
     * The origin of the ray.
     */
    origin: Cartesian3;
    /**
     * The direction of the ray.
     */
    direction: Cartesian3;
    /**
     * Duplicates a Ray instance.
     * @param ray - The ray to duplicate.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Ray instance if one was not provided. (Returns undefined if ray is undefined)
     */
    static clone(ray: Ray, result?: Ray): Ray;
    /**
     * Computes the point along the ray given by r(t) = o + t*d,
     * where o is the origin of the ray and d is the direction.
     * @example
     * //Get the first intersection point of a ray and an ellipsoid.
     * const intersection = Cesium.IntersectionTests.rayEllipsoid(ray, ellipsoid);
     * const point = Cesium.Ray.getPoint(ray, intersection.start);
     * @param ray - The ray.
     * @param t - A scalar value.
     * @param [result] - The object in which the result will be stored.
     * @returns The modified result parameter, or a new instance if none was provided.
     */
    static getPoint(ray: Ray, t: number, result?: Cartesian3): Cartesian3;
}

/**
 * A two dimensional region specified as longitude and latitude coordinates.
 * @param [west = 0.0] - The westernmost longitude, in radians, in the range [-Pi, Pi].
 * @param [south = 0.0] - The southernmost latitude, in radians, in the range [-Pi/2, Pi/2].
 * @param [east = 0.0] - The easternmost longitude, in radians, in the range [-Pi, Pi].
 * @param [north = 0.0] - The northernmost latitude, in radians, in the range [-Pi/2, Pi/2].
 */
export class Rectangle {
    constructor(west?: number, south?: number, east?: number, north?: number);
    /**
     * The westernmost longitude in radians in the range [-Pi, Pi].
     */
    west: number;
    /**
     * The southernmost latitude in radians in the range [-Pi/2, Pi/2].
     */
    south: number;
    /**
     * The easternmost longitude in radians in the range [-Pi, Pi].
     */
    east: number;
    /**
     * The northernmost latitude in radians in the range [-Pi/2, Pi/2].
     */
    north: number;
    /**
     * Gets the width of the rectangle in radians.
     */
    readonly width: number;
    /**
     * Gets the height of the rectangle in radians.
     */
    readonly height: number;
    /**
     * The number of elements used to pack the object into an array.
     */
    static packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: Rectangle, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new Rectangle instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: Rectangle): Rectangle;
    /**
     * Computes the width of a rectangle in radians.
     * @param rectangle - The rectangle to compute the width of.
     * @returns The width.
     */
    static computeWidth(rectangle: Rectangle): number;
    /**
     * Computes the height of a rectangle in radians.
     * @param rectangle - The rectangle to compute the height of.
     * @returns The height.
     */
    static computeHeight(rectangle: Rectangle): number;
    /**
     * Creates a rectangle given the boundary longitude and latitude in degrees.
     * @example
     * const rectangle = Cesium.Rectangle.fromDegrees(0.0, 20.0, 10.0, 30.0);
     * @param [west = 0.0] - The westernmost longitude in degrees in the range [-180.0, 180.0].
     * @param [south = 0.0] - The southernmost latitude in degrees in the range [-90.0, 90.0].
     * @param [east = 0.0] - The easternmost longitude in degrees in the range [-180.0, 180.0].
     * @param [north = 0.0] - The northernmost latitude in degrees in the range [-90.0, 90.0].
     * @param [result] - The object onto which to store the result, or undefined if a new instance should be created.
     * @returns The modified result parameter or a new Rectangle instance if none was provided.
     */
    static fromDegrees(west?: number, south?: number, east?: number, north?: number, result?: Rectangle): Rectangle;
    /**
     * Creates a rectangle given the boundary longitude and latitude in radians.
     * @example
     * const rectangle = Cesium.Rectangle.fromRadians(0.0, Math.PI/4, Math.PI/8, 3*Math.PI/4);
     * @param [west = 0.0] - The westernmost longitude in radians in the range [-Math.PI, Math.PI].
     * @param [south = 0.0] - The southernmost latitude in radians in the range [-Math.PI/2, Math.PI/2].
     * @param [east = 0.0] - The easternmost longitude in radians in the range [-Math.PI, Math.PI].
     * @param [north = 0.0] - The northernmost latitude in radians in the range [-Math.PI/2, Math.PI/2].
     * @param [result] - The object onto which to store the result, or undefined if a new instance should be created.
     * @returns The modified result parameter or a new Rectangle instance if none was provided.
     */
    static fromRadians(west?: number, south?: number, east?: number, north?: number, result?: Rectangle): Rectangle;
    /**
     * Creates the smallest possible Rectangle that encloses all positions in the provided array.
     * @param cartographics - The list of Cartographic instances.
     * @param [result] - The object onto which to store the result, or undefined if a new instance should be created.
     * @returns The modified result parameter or a new Rectangle instance if none was provided.
     */
    static fromCartographicArray(cartographics: Cartographic[], result?: Rectangle): Rectangle;
    /**
     * Creates the smallest possible Rectangle that encloses all positions in the provided array.
     * @param cartesians - The list of Cartesian instances.
     * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid the cartesians are on.
     * @param [result] - The object onto which to store the result, or undefined if a new instance should be created.
     * @returns The modified result parameter or a new Rectangle instance if none was provided.
     */
    static fromCartesianArray(cartesians: Cartesian3[], ellipsoid?: Ellipsoid, result?: Rectangle): Rectangle;
    /**
     * Duplicates a Rectangle.
     * @param rectangle - The rectangle to clone.
     * @param [result] - The object onto which to store the result, or undefined if a new instance should be created.
     * @returns The modified result parameter or a new Rectangle instance if none was provided. (Returns undefined if rectangle is undefined)
     */
    static clone(rectangle: Rectangle, result?: Rectangle): Rectangle;
    /**
     * Compares the provided Rectangles componentwise and returns
     * <code>true</code> if they pass an absolute or relative tolerance test,
     * <code>false</code> otherwise.
     * @param [left] - The first Rectangle.
     * @param [right] - The second Rectangle.
     * @param [absoluteEpsilon = 0] - The absolute epsilon tolerance to use for equality testing.
     * @returns <code>true</code> if left and right are within the provided epsilon, <code>false</code> otherwise.
     */
    static equalsEpsilon(left?: Rectangle, right?: Rectangle, absoluteEpsilon?: number): boolean;
    /**
     * Duplicates this Rectangle.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Rectangle instance if none was provided.
     */
    clone(result?: Rectangle): Rectangle;
    /**
     * Compares the provided Rectangle with this Rectangle componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [other] - The Rectangle to compare.
     * @returns <code>true</code> if the Rectangles are equal, <code>false</code> otherwise.
     */
    equals(other?: Rectangle): boolean;
    /**
     * Compares the provided rectangles and returns <code>true</code> if they are equal,
     * <code>false</code> otherwise.
     * @param [left] - The first Rectangle.
     * @param [right] - The second Rectangle.
     * @returns <code>true</code> if left and right are equal; otherwise <code>false</code>.
     */
    static equals(left?: Rectangle, right?: Rectangle): boolean;
    /**
     * Compares the provided Rectangle with this Rectangle componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @param [other] - The Rectangle to compare.
     * @param [epsilon = 0] - The epsilon to use for equality testing.
     * @returns <code>true</code> if the Rectangles are within the provided epsilon, <code>false</code> otherwise.
     */
    equalsEpsilon(other?: Rectangle, epsilon?: number): boolean;
    /**
     * Checks a Rectangle's properties and throws if they are not in valid ranges.
     * @param rectangle - The rectangle to validate
     */
    static validate(rectangle: Rectangle): void;
    /**
     * Computes the southwest corner of a rectangle.
     * @param rectangle - The rectangle for which to find the corner
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Cartographic instance if none was provided.
     */
    static southwest(rectangle: Rectangle, result?: Cartographic): Cartographic;
    /**
     * Computes the northwest corner of a rectangle.
     * @param rectangle - The rectangle for which to find the corner
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Cartographic instance if none was provided.
     */
    static northwest(rectangle: Rectangle, result?: Cartographic): Cartographic;
    /**
     * Computes the northeast corner of a rectangle.
     * @param rectangle - The rectangle for which to find the corner
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Cartographic instance if none was provided.
     */
    static northeast(rectangle: Rectangle, result?: Cartographic): Cartographic;
    /**
     * Computes the southeast corner of a rectangle.
     * @param rectangle - The rectangle for which to find the corner
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Cartographic instance if none was provided.
     */
    static southeast(rectangle: Rectangle, result?: Cartographic): Cartographic;
    /**
     * Computes the center of a rectangle.
     * @param rectangle - The rectangle for which to find the center
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Cartographic instance if none was provided.
     */
    static center(rectangle: Rectangle, result?: Cartographic): Cartographic;
    /**
     * Computes the intersection of two rectangles.  This function assumes that the rectangle's coordinates are
     * latitude and longitude in radians and produces a correct intersection, taking into account the fact that
     * the same angle can be represented with multiple values as well as the wrapping of longitude at the
     * anti-meridian.  For a simple intersection that ignores these factors and can be used with projected
     * coordinates, see {@link Rectangle.simpleIntersection}.
     * @param rectangle - On rectangle to find an intersection
     * @param otherRectangle - Another rectangle to find an intersection
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter, a new Rectangle instance if none was provided or undefined if there is no intersection.
     */
    static intersection(rectangle: Rectangle, otherRectangle: Rectangle, result?: Rectangle): Rectangle | undefined;
    /**
     * Computes a simple intersection of two rectangles.  Unlike {@link Rectangle.intersection}, this function
     * does not attempt to put the angular coordinates into a consistent range or to account for crossing the
     * anti-meridian.  As such, it can be used for rectangles where the coordinates are not simply latitude
     * and longitude (i.e. projected coordinates).
     * @param rectangle - On rectangle to find an intersection
     * @param otherRectangle - Another rectangle to find an intersection
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter, a new Rectangle instance if none was provided or undefined if there is no intersection.
     */
    static simpleIntersection(rectangle: Rectangle, otherRectangle: Rectangle, result?: Rectangle): Rectangle | undefined;
    /**
     * Computes a rectangle that is the union of two rectangles.
     * @param rectangle - A rectangle to enclose in rectangle.
     * @param otherRectangle - A rectangle to enclose in a rectangle.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Rectangle instance if none was provided.
     */
    static union(rectangle: Rectangle, otherRectangle: Rectangle, result?: Rectangle): Rectangle;
    /**
     * Computes a rectangle by enlarging the provided rectangle until it contains the provided cartographic.
     * @param rectangle - A rectangle to expand.
     * @param cartographic - A cartographic to enclose in a rectangle.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Rectangle instance if one was not provided.
     */
    static expand(rectangle: Rectangle, cartographic: Cartographic, result?: Rectangle): Rectangle;
    /**
     * Returns true if the cartographic is on or inside the rectangle, false otherwise.
     * @param rectangle - The rectangle
     * @param cartographic - The cartographic to test.
     * @returns true if the provided cartographic is inside the rectangle, false otherwise.
     */
    static contains(rectangle: Rectangle, cartographic: Cartographic): boolean;
    /**
     * Samples a rectangle so that it includes a list of Cartesian points suitable for passing to
     * {@link BoundingSphere#fromPoints}.  Sampling is necessary to account
     * for rectangles that cover the poles or cross the equator.
     * @param rectangle - The rectangle to subsample.
     * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid to use.
     * @param [surfaceHeight = 0.0] - The height of the rectangle above the ellipsoid.
     * @param [result] - The array of Cartesians onto which to store the result.
     * @returns The modified result parameter or a new Array of Cartesians instances if none was provided.
     */
    static subsample(rectangle: Rectangle, ellipsoid?: Ellipsoid, surfaceHeight?: number, result?: Cartesian3[]): Cartesian3[];
    /**
     * Computes a subsection of a rectangle from normalized coordinates in the range [0.0, 1.0].
     * @param rectangle - The rectangle to subsection.
     * @param westLerp - The west interpolation factor in the range [0.0, 1.0]. Must be less than or equal to eastLerp.
     * @param southLerp - The south interpolation factor in the range [0.0, 1.0]. Must be less than or equal to northLerp.
     * @param eastLerp - The east interpolation factor in the range [0.0, 1.0]. Must be greater than or equal to westLerp.
     * @param northLerp - The north interpolation factor in the range [0.0, 1.0]. Must be greater than or equal to southLerp.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Rectangle instance if none was provided.
     */
    static subsection(rectangle: Rectangle, westLerp: number, southLerp: number, eastLerp: number, northLerp: number, result?: Rectangle): Rectangle;
    /**
     * The largest possible rectangle.
     */
    static readonly MAX_VALUE: Rectangle;
}

/**
 * A description of a cartographic rectangle on an ellipsoid centered at the origin. Rectangle geometry can be rendered with both {@link Primitive} and {@link GroundPrimitive}.
 * @example
 * // 1. create a rectangle
 * const rectangle = new Cesium.RectangleGeometry({
 *   ellipsoid : Cesium.Ellipsoid.WGS84,
 *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),
 *   height : 10000.0
 * });
 * const geometry = Cesium.RectangleGeometry.createGeometry(rectangle);
 *
 * // 2. create an extruded rectangle without a top
 * const rectangle = new Cesium.RectangleGeometry({
 *   ellipsoid : Cesium.Ellipsoid.WGS84,
 *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),
 *   height : 10000.0,
 *   extrudedHeight: 300000
 * });
 * const geometry = Cesium.RectangleGeometry.createGeometry(rectangle);
 * @param options - Object with the following properties:
 * @param options.rectangle - A cartographic rectangle with north, south, east and west properties in radians.
 * @param [options.vertexFormat = VertexFormat.DEFAULT] - The vertex attributes to be computed.
 * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid on which the rectangle lies.
 * @param [options.granularity = Math.RADIANS_PER_DEGREE] - The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
 * @param [options.height = 0.0] - The distance in meters between the rectangle and the ellipsoid surface.
 * @param [options.rotation = 0.0] - The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.
 * @param [options.stRotation = 0.0] - The rotation of the texture coordinates, in radians. A positive rotation is counter-clockwise.
 * @param [options.extrudedHeight] - The distance in meters between the rectangle's extruded face and the ellipsoid surface.
 */
export class RectangleGeometry {
    constructor(options: {
        rectangle: Rectangle;
        vertexFormat?: VertexFormat;
        ellipsoid?: Ellipsoid;
        granularity?: number;
        height?: number;
        rotation?: number;
        stRotation?: number;
        extrudedHeight?: number;
    });
    /**
     * The number of elements used to pack the object into an array.
     */
    static packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: RectangleGeometry, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new RectangleGeometry instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: RectangleGeometry): RectangleGeometry;
    /**
     * Computes the bounding rectangle based on the provided options
     * @param options - Object with the following properties:
     * @param options.rectangle - A cartographic rectangle with north, south, east and west properties in radians.
     * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid on which the rectangle lies.
     * @param [options.granularity = Math.RADIANS_PER_DEGREE] - The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
     * @param [options.rotation = 0.0] - The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.
     * @param [result] - An object in which to store the result.
     * @returns The result rectangle
     */
    static computeRectangle(options: {
        rectangle: Rectangle;
        ellipsoid?: Ellipsoid;
        granularity?: number;
        rotation?: number;
    }, result?: Rectangle): Rectangle;
    /**
     * Computes the geometric representation of a rectangle, including its vertices, indices, and a bounding sphere.
     * @param rectangleGeometry - A description of the rectangle.
     * @returns The computed vertices and indices.
     */
    static createGeometry(rectangleGeometry: RectangleGeometry): Geometry | undefined;
}

/**
 * A description of the outline of a a cartographic rectangle on an ellipsoid centered at the origin.
 * @example
 * const rectangle = new Cesium.RectangleOutlineGeometry({
 *   ellipsoid : Cesium.Ellipsoid.WGS84,
 *   rectangle : Cesium.Rectangle.fromDegrees(-80.0, 39.0, -74.0, 42.0),
 *   height : 10000.0
 * });
 * const geometry = Cesium.RectangleOutlineGeometry.createGeometry(rectangle);
 * @param options - Object with the following properties:
 * @param options.rectangle - A cartographic rectangle with north, south, east and west properties in radians.
 * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid on which the rectangle lies.
 * @param [options.granularity = Math.RADIANS_PER_DEGREE] - The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
 * @param [options.height = 0.0] - The distance in meters between the rectangle and the ellipsoid surface.
 * @param [options.rotation = 0.0] - The rotation of the rectangle, in radians. A positive rotation is counter-clockwise.
 * @param [options.extrudedHeight] - The distance in meters between the rectangle's extruded face and the ellipsoid surface.
 */
export class RectangleOutlineGeometry {
    constructor(options: {
        rectangle: Rectangle;
        ellipsoid?: Ellipsoid;
        granularity?: number;
        height?: number;
        rotation?: number;
        extrudedHeight?: number;
    });
    /**
     * The number of elements used to pack the object into an array.
     */
    static packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: RectangleOutlineGeometry, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new Quaternion instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: RectangleOutlineGeometry): RectangleOutlineGeometry;
    /**
     * Computes the geometric representation of an outline of a rectangle, including its vertices, indices, and a bounding sphere.
     * @param rectangleGeometry - A description of the rectangle outline.
     * @returns The computed vertices and indices.
     */
    static createGeometry(rectangleGeometry: RectangleOutlineGeometry): Geometry | undefined;
}

/**
 * Constants for identifying well-known reference frames.
 */
export enum ReferenceFrame {
    /**
     * The fixed frame.
     */
    FIXED = 0,
    /**
     * The inertial frame.
     */
    INERTIAL = 1
}

/**
 * Stores information for making a request. In general this does not need to be constructed directly.
 * @param [options] - An object with the following properties:
 * @param [options.url] - The url to request.
 * @param [options.requestFunction] - The function that makes the actual data request.
 * @param [options.cancelFunction] - The function that is called when the request is cancelled.
 * @param [options.priorityFunction] - The function that is called to update the request's priority, which occurs once per frame.
 * @param [options.priority = 0.0] - The initial priority of the request.
 * @param [options.throttle = false] - Whether to throttle and prioritize the request. If false, the request will be sent immediately. If true, the request will be throttled and sent based on priority.
 * @param [options.throttleByServer = false] - Whether to throttle the request by server.
 * @param [options.type = RequestType.OTHER] - The type of request.
 * @param [options.serverKey] - A key used to identify the server that a request is going to.
 */
export class Request {
    constructor(options?: {
        url?: string;
        requestFunction?: Request.RequestCallback;
        cancelFunction?: Request.CancelCallback;
        priorityFunction?: Request.PriorityCallback;
        priority?: number;
        throttle?: boolean;
        throttleByServer?: boolean;
        type?: RequestType;
        serverKey?: string;
    });
    /**
     * The URL to request.
     */
    url: string;
    /**
     * The function that makes the actual data request.
     */
    requestFunction: Request.RequestCallback;
    /**
     * The function that is called when the request is cancelled.
     */
    cancelFunction: Request.CancelCallback;
    /**
     * The function that is called to update the request's priority, which occurs once per frame.
     */
    priorityFunction: Request.PriorityCallback;
    /**
     * Priority is a unit-less value where lower values represent higher priority.
     * For world-based objects, this is usually the distance from the camera.
     * A request that does not have a priority function defaults to a priority of 0.
     *
     * If priorityFunction is defined, this value is updated every frame with the result of that call.
     */
    priority: number;
    /**
     * Whether to throttle and prioritize the request. If false, the request will be sent immediately. If true, the
     * request will be throttled and sent based on priority.
     */
    readonly throttle: boolean;
    /**
     * Whether to throttle the request by server. Browsers typically support about 6-8 parallel connections
     * for HTTP/1 servers, and an unlimited amount of connections for HTTP/2 servers. Setting this value
     * to <code>true</code> is preferable for requests going through HTTP/1 servers.
     */
    readonly throttleByServer: boolean;
    /**
     * Type of request.
     */
    readonly type: RequestType;
    /**
     * The current state of the request.
     */
    readonly state: RequestState;
    /**
     * Duplicates a Request instance.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Resource instance if one was not provided.
     */
    clone(result?: Request): Request;
}

export namespace Request {
    /**
     * The function that makes the actual data request.
     */
    type RequestCallback = () => Promise<void>;
    /**
     * The function that is called when the request is cancelled.
     */
    type CancelCallback = () => void;
    /**
     * The function that is called to update the request's priority, which occurs once per frame.
     */
    type PriorityCallback = () => number;
}

/**
 * An event that is raised when a request encounters an error.
 * @param [statusCode] - The HTTP error status code, such as 404.
 * @param [response] - The response included along with the error.
 * @param [responseHeaders] - The response headers, represented either as an object literal or as a
 *                        string in the format returned by XMLHttpRequest's getAllResponseHeaders() function.
 */
export class RequestErrorEvent {
    constructor(statusCode?: number, response?: any, responseHeaders?: string | any);
    /**
     * The HTTP error status code, such as 404.  If the error does not have a particular
     * HTTP code, this property will be undefined.
     */
    statusCode: number;
    /**
     * The response included along with the error.  If the error does not include a response,
     * this property will be undefined.
     */
    response: any;
    /**
     * The headers included in the response, represented as an object literal of key/value pairs.
     * If the error does not include any headers, this property will be undefined.
     */
    responseHeaders: any;
    /**
     * Creates a string representing this RequestErrorEvent.
     * @returns A string representing the provided RequestErrorEvent.
     */
    toString(): string;
}

/**
 * The request scheduler is used to track and constrain the number of active requests in order to prioritize incoming requests. The ability
 * to retain control over the number of requests in CesiumJS is important because due to events such as changes in the camera position,
 * a lot of new requests may be generated and a lot of in-flight requests may become redundant. The request scheduler manually constrains the
 * number of requests so that newer requests wait in a shorter queue and don't have to compete for bandwidth with requests that have expired.
 */
export namespace RequestScheduler {
    /**
     * The maximum number of simultaneous active requests. Un-throttled requests do not observe this limit.
     */
    var maximumRequests: number;
    /**
     * The maximum number of simultaneous active requests per server. Un-throttled requests or servers specifically
     * listed in {@link requestsByServer} do not observe this limit.
     */
    var maximumRequestsPerServer: number;
    /**
     * A per server key list of overrides to use for throttling instead of <code>maximumRequestsPerServer</code>.
     * Useful when streaming data from a known HTTP/2 or HTTP/3 server.
     * @example
     * RequestScheduler.requestsByServer["myserver.com:443"] = 18;
     * @example
     * RequestScheduler.requestsByServer = {
     *   "api.cesium.com:443": 18,
     *   "assets.cesium.com:443": 18,
     * };
     */
    var requestsByServer: any;
    /**
     * Specifies if the request scheduler should throttle incoming requests, or let the browser queue requests under its control.
     */
    var throttleRequests: boolean;
}

/**
 * State of the request.
 */
export enum RequestState {
    /**
     * Initial unissued state.
     */
    UNISSUED = 0,
    /**
     * Issued but not yet active. Will become active when open slots are available.
     */
    ISSUED = 1,
    /**
     * Actual http request has been sent.
     */
    ACTIVE = 2,
    /**
     * Request completed successfully.
     */
    RECEIVED = 3,
    /**
     * Request was cancelled, either explicitly or automatically because of low priority.
     */
    CANCELLED = 4,
    /**
     * Request failed.
     */
    FAILED = 5
}

/**
 * An enum identifying the type of request. Used for finer grained logging and priority sorting.
 */
export enum RequestType {
    /**
     * Terrain request.
     */
    TERRAIN = 0,
    /**
     * Imagery request.
     */
    IMAGERY = 1,
    /**
     * 3D Tiles request.
     */
    TILES3D = 2,
    /**
     * Other request.
     */
    OTHER = 3
}

export namespace Resource {
    /**
     * Initialization options for the Resource constructor
     * url - The url of the resource.
     * [queryParameters] - An object containing query parameters that will be sent when retrieving the resource.
     * [templateValues] - Key/Value pairs that are used to replace template values (eg. {x}).
     * [headers = {}] - Additional HTTP headers that will be sent.
     * [proxy] - A proxy to be used when loading the resource.
     * [retryCallback] - The Function to call when a request for this resource fails. If it returns true, the request will be retried.
     * [retryAttempts = 0] - The number of times the retryCallback should be called before giving up.
     * [request] - A Request object that will be used. Intended for internal use only.
     * [parseUrl = true] - If true, parse the url for query parameters; otherwise store the url without change
     */
    type ConstructorOptions = {
        url: string;
        queryParameters?: any;
        templateValues?: any;
        headers?: any;
        proxy?: Proxy;
        retryCallback?: Resource.RetryCallback;
        retryAttempts?: number;
        request?: Request;
        parseUrl?: boolean;
    };
    /**
     * A function that returns the value of the property.
     * @param [resource] - The resource that failed to load.
     * @param [error] - The error that occurred during the loading of the resource.
     */
    type RetryCallback = (resource?: Resource, error?: RequestErrorEvent) => boolean | Promise<boolean>;
}

/**
 * A resource that includes the location and any other parameters we need to retrieve it or create derived resources. It also provides the ability to retry requests.
 * @example
 * function refreshTokenRetryCallback(resource, error) {
 *   if (error.statusCode === 403) {
 *     // 403 status code means a new token should be generated
 *     return getNewAccessToken()
 *       .then(function(token) {
 *         resource.queryParameters.access_token = token;
 *         return true;
 *       })
 *       .catch(function() {
 *         return false;
 *       });
 *   }
 *
 *   return false;
 * }
 *
 * const resource = new Resource({
 *    url: 'http://server.com/path/to/resource.json',
 *    proxy: new DefaultProxy('/proxy/'),
 *    headers: {
 *      'X-My-Header': 'valueOfHeader'
 *    },
 *    queryParameters: {
 *      'access_token': '123-435-456-000'
 *    },
 *    retryCallback: refreshTokenRetryCallback,
 *    retryAttempts: 1
 * });
 * @param options - A url or an object describing initialization options
 */
export class Resource {
    constructor(options: string | Resource.ConstructorOptions);
    /**
     * Additional HTTP headers that will be sent with the request.
     */
    headers: any;
    /**
     * A Request object that will be used. Intended for internal use only.
     */
    request: Request;
    /**
     * A proxy to be used when loading the resource.
     */
    proxy: Proxy;
    /**
     * Function to call when a request for this resource fails. If it returns true or a Promise that resolves to true, the request will be retried.
     */
    retryCallback: (...params: any[]) => any;
    /**
     * The number of times the retryCallback should be called before giving up.
     */
    retryAttempts: number;
    /**
     * Returns true if blobs are supported.
     */
    static readonly isBlobSupported: boolean;
    /**
     * Query parameters appended to the url.
     */
    readonly queryParameters: any;
    /**
     * The key/value pairs used to replace template parameters in the url.
     */
    readonly templateValues: any;
    /**
     * The url to the resource with template values replaced, query string appended and encoded by proxy if one was set.
     */
    url: string;
    /**
     * The file extension of the resource.
     */
    readonly extension: string;
    /**
     * True if the Resource refers to a data URI.
     */
    isDataUri: boolean;
    /**
     * True if the Resource refers to a blob URI.
     */
    isBlobUri: boolean;
    /**
     * True if the Resource refers to a cross origin URL.
     */
    isCrossOriginUrl: boolean;
    /**
     * True if the Resource has request headers. This is equivalent to checking if the headers property has any keys.
     */
    hasHeaders: boolean;
    /**
     * Override Object#toString so that implicit string conversion gives the
     * complete URL represented by this Resource.
     * @returns The URL represented by this Resource
     */
    toString(): string;
    /**
     * Returns the url, optional with the query string and processed by a proxy.
     * @param [query = false] - If true, the query string is included.
     * @param [proxy = false] - If true, the url is processed by the proxy object, if defined.
     * @returns The url with all the requested components.
     */
    getUrlComponent(query?: boolean, proxy?: boolean): string;
    /**
     * Combines the specified object and the existing query parameters. This allows you to add many parameters at once,
     *  as opposed to adding them one at a time to the queryParameters property. If a value is already set, it will be replaced with the new value.
     * @param params - The query parameters
     * @param [useAsDefault = false] - If true the params will be used as the default values, so they will only be set if they are undefined.
     */
    setQueryParameters(params: any, useAsDefault?: boolean): void;
    /**
     * Combines the specified object and the existing query parameters. This allows you to add many parameters at once,
     *  as opposed to adding them one at a time to the queryParameters property.
     * @param params - The query parameters
     */
    appendQueryParameters(params: any): void;
    /**
     * Combines the specified object and the existing template values. This allows you to add many values at once,
     *  as opposed to adding them one at a time to the templateValues property. If a value is already set, it will become an array and the new value will be appended.
     * @param template - The template values
     * @param [useAsDefault = false] - If true the values will be used as the default values, so they will only be set if they are undefined.
     */
    setTemplateValues(template: any, useAsDefault?: boolean): void;
    /**
     * Returns a resource relative to the current instance. All properties remain the same as the current instance unless overridden in options.
     * @param options - An object with the following properties
     * @param [options.url] - The url that will be resolved relative to the url of the current instance.
     * @param [options.queryParameters] - An object containing query parameters that will be combined with those of the current instance.
     * @param [options.templateValues] - Key/Value pairs that are used to replace template values (eg. {x}). These will be combined with those of the current instance.
     * @param [options.headers = {}] - Additional HTTP headers that will be sent.
     * @param [options.proxy] - A proxy to be used when loading the resource.
     * @param [options.retryCallback] - The function to call when loading the resource fails.
     * @param [options.retryAttempts] - The number of times the retryCallback should be called before giving up.
     * @param [options.request] - A Request object that will be used. Intended for internal use only.
     * @param [options.preserveQueryParameters = false] - If true, this will keep all query parameters from the current resource and derived resource. If false, derived parameters will replace those of the current resource.
     * @returns The resource derived from the current one.
     */
    getDerivedResource(options: {
        url?: string;
        queryParameters?: any;
        templateValues?: any;
        headers?: any;
        proxy?: Proxy;
        retryCallback?: Resource.RetryCallback;
        retryAttempts?: number;
        request?: Request;
        preserveQueryParameters?: boolean;
    }): Resource;
    /**
     * Duplicates a Resource instance.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Resource instance if one was not provided.
     */
    clone(result?: Resource): Resource;
    /**
     * Returns the base path of the Resource.
     * @param [includeQuery = false] - Whether or not to include the query string and fragment form the uri
     * @returns The base URI of the resource
     */
    getBaseUri(includeQuery?: boolean): string;
    /**
     * Appends a forward slash to the URL.
     */
    appendForwardSlash(): void;
    /**
     * Asynchronously loads the resource as raw binary data.  Returns a promise that will resolve to
     * an ArrayBuffer once loaded, or reject if the resource failed to load.  The data is loaded
     * using XMLHttpRequest, which means that in order to make requests to another origin,
     * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
     * @example
     * // load a single URL asynchronously
     * resource.fetchArrayBuffer().then(function(arrayBuffer) {
     *     // use the data
     * }).catch(function(error) {
     *     // an error occurred
     * });
     * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
     */
    fetchArrayBuffer(): Promise<ArrayBuffer> | undefined;
    /**
     * Creates a Resource and calls fetchArrayBuffer() on it.
     * @param options - A url or an object with the following properties
     * @param options.url - The url of the resource.
     * @param [options.queryParameters] - An object containing query parameters that will be sent when retrieving the resource.
     * @param [options.templateValues] - Key/Value pairs that are used to replace template values (eg. {x}).
     * @param [options.headers = {}] - Additional HTTP headers that will be sent.
     * @param [options.proxy] - A proxy to be used when loading the resource.
     * @param [options.retryCallback] - The Function to call when a request for this resource fails. If it returns true, the request will be retried.
     * @param [options.retryAttempts = 0] - The number of times the retryCallback should be called before giving up.
     * @param [options.request] - A Request object that will be used. Intended for internal use only.
     * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
     */
    static fetchArrayBuffer(options: {
        url: string;
        queryParameters?: any;
        templateValues?: any;
        headers?: any;
        proxy?: Proxy;
        retryCallback?: Resource.RetryCallback;
        retryAttempts?: number;
        request?: Request;
    }): Promise<ArrayBuffer> | undefined;
    /**
     * Asynchronously loads the given resource as a blob.  Returns a promise that will resolve to
     * a Blob once loaded, or reject if the resource failed to load.  The data is loaded
     * using XMLHttpRequest, which means that in order to make requests to another origin,
     * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
     * @example
     * // load a single URL asynchronously
     * resource.fetchBlob().then(function(blob) {
     *     // use the data
     * }).catch(function(error) {
     *     // an error occurred
     * });
     * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
     */
    fetchBlob(): Promise<Blob> | undefined;
    /**
     * Creates a Resource and calls fetchBlob() on it.
     * @param options - A url or an object with the following properties
     * @param options.url - The url of the resource.
     * @param [options.queryParameters] - An object containing query parameters that will be sent when retrieving the resource.
     * @param [options.templateValues] - Key/Value pairs that are used to replace template values (eg. {x}).
     * @param [options.headers = {}] - Additional HTTP headers that will be sent.
     * @param [options.proxy] - A proxy to be used when loading the resource.
     * @param [options.retryCallback] - The Function to call when a request for this resource fails. If it returns true, the request will be retried.
     * @param [options.retryAttempts = 0] - The number of times the retryCallback should be called before giving up.
     * @param [options.request] - A Request object that will be used. Intended for internal use only.
     * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
     */
    static fetchBlob(options: {
        url: string;
        queryParameters?: any;
        templateValues?: any;
        headers?: any;
        proxy?: Proxy;
        retryCallback?: Resource.RetryCallback;
        retryAttempts?: number;
        request?: Request;
    }): Promise<Blob> | undefined;
    /**
     * Asynchronously loads the given image resource.  Returns a promise that will resolve to
     * an {@link https://developer.mozilla.org/en-US/docs/Web/API/ImageBitmap|ImageBitmap} if <code>preferImageBitmap</code> is true and the browser supports <code>createImageBitmap</code> or otherwise an
     * {@link https://developer.mozilla.org/en-US/docs/Web/API/HTMLImageElement|Image} once loaded, or reject if the image failed to load.
     * @example
     * // load a single image asynchronously
     * resource.fetchImage().then(function(image) {
     *     // use the loaded image
     * }).catch(function(error) {
     *     // an error occurred
     * });
     *
     * // load several images in parallel
     * Promise.all([resource1.fetchImage(), resource2.fetchImage()]).then(function(images) {
     *     // images is an array containing all the loaded images
     * });
     * @param [options] - An object with the following properties.
     * @param [options.preferBlob = false] - If true, we will load the image via a blob.
     * @param [options.preferImageBitmap = false] - If true, image will be decoded during fetch and an <code>ImageBitmap</code> is returned.
     * @param [options.flipY = false] - If true, image will be vertically flipped during decode. Only applies if the browser supports <code>createImageBitmap</code>.
     * @param [options.skipColorSpaceConversion = false] - If true, any custom gamma or color profiles in the image will be ignored. Only applies if the browser supports <code>createImageBitmap</code>.
     * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
     */
    fetchImage(options?: {
        preferBlob?: boolean;
        preferImageBitmap?: boolean;
        flipY?: boolean;
        skipColorSpaceConversion?: boolean;
    }): Promise<ImageBitmap | HTMLImageElement> | undefined;
    /**
     * Creates a Resource and calls fetchImage() on it.
     * @param options - A url or an object with the following properties
     * @param options.url - The url of the resource.
     * @param [options.queryParameters] - An object containing query parameters that will be sent when retrieving the resource.
     * @param [options.templateValues] - Key/Value pairs that are used to replace template values (eg. {x}).
     * @param [options.headers = {}] - Additional HTTP headers that will be sent.
     * @param [options.proxy] - A proxy to be used when loading the resource.
     * @param [options.flipY = false] - Whether to vertically flip the image during fetch and decode. Only applies when requesting an image and the browser supports <code>createImageBitmap</code>.
     * @param [options.retryCallback] - The Function to call when a request for this resource fails. If it returns true, the request will be retried.
     * @param [options.retryAttempts = 0] - The number of times the retryCallback should be called before giving up.
     * @param [options.request] - A Request object that will be used. Intended for internal use only.
     * @param [options.preferBlob = false] - If true, we will load the image via a blob.
     * @param [options.preferImageBitmap = false] - If true, image will be decoded during fetch and an <code>ImageBitmap</code> is returned.
     * @param [options.skipColorSpaceConversion = false] - If true, any custom gamma or color profiles in the image will be ignored. Only applies when requesting an image and the browser supports <code>createImageBitmap</code>.
     * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
     */
    static fetchImage(options: {
        url: string;
        queryParameters?: any;
        templateValues?: any;
        headers?: any;
        proxy?: Proxy;
        flipY?: boolean;
        retryCallback?: Resource.RetryCallback;
        retryAttempts?: number;
        request?: Request;
        preferBlob?: boolean;
        preferImageBitmap?: boolean;
        skipColorSpaceConversion?: boolean;
    }): Promise<ImageBitmap | HTMLImageElement> | undefined;
    /**
     * Asynchronously loads the given resource as text.  Returns a promise that will resolve to
     * a String once loaded, or reject if the resource failed to load.  The data is loaded
     * using XMLHttpRequest, which means that in order to make requests to another origin,
     * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
     * @example
     * // load text from a URL, setting a custom header
     * const resource = new Resource({
     *   url: 'http://someUrl.com/someJson.txt',
     *   headers: {
     *     'X-Custom-Header' : 'some value'
     *   }
     * });
     * resource.fetchText().then(function(text) {
     *     // Do something with the text
     * }).catch(function(error) {
     *     // an error occurred
     * });
     * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
     */
    fetchText(): Promise<string> | undefined;
    /**
     * Creates a Resource and calls fetchText() on it.
     * @param options - A url or an object with the following properties
     * @param options.url - The url of the resource.
     * @param [options.queryParameters] - An object containing query parameters that will be sent when retrieving the resource.
     * @param [options.templateValues] - Key/Value pairs that are used to replace template values (eg. {x}).
     * @param [options.headers = {}] - Additional HTTP headers that will be sent.
     * @param [options.proxy] - A proxy to be used when loading the resource.
     * @param [options.retryCallback] - The Function to call when a request for this resource fails. If it returns true, the request will be retried.
     * @param [options.retryAttempts = 0] - The number of times the retryCallback should be called before giving up.
     * @param [options.request] - A Request object that will be used. Intended for internal use only.
     * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
     */
    static fetchText(options: {
        url: string;
        queryParameters?: any;
        templateValues?: any;
        headers?: any;
        proxy?: Proxy;
        retryCallback?: Resource.RetryCallback;
        retryAttempts?: number;
        request?: Request;
    }): Promise<string> | undefined;
    /**
     * Asynchronously loads the given resource as JSON.  Returns a promise that will resolve to
     * a JSON object once loaded, or reject if the resource failed to load.  The data is loaded
     * using XMLHttpRequest, which means that in order to make requests to another origin,
     * the server must have Cross-Origin Resource Sharing (CORS) headers enabled. This function
     * adds 'Accept: application/json,&#42;&#47;&#42;;q=0.01' to the request headers, if not
     * already specified.
     * @example
     * resource.fetchJson().then(function(jsonData) {
     *     // Do something with the JSON object
     * }).catch(function(error) {
     *     // an error occurred
     * });
     * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
     */
    fetchJson(): Promise<any> | undefined;
    /**
     * Creates a Resource and calls fetchJson() on it.
     * @param options - A url or an object with the following properties
     * @param options.url - The url of the resource.
     * @param [options.queryParameters] - An object containing query parameters that will be sent when retrieving the resource.
     * @param [options.templateValues] - Key/Value pairs that are used to replace template values (eg. {x}).
     * @param [options.headers = {}] - Additional HTTP headers that will be sent.
     * @param [options.proxy] - A proxy to be used when loading the resource.
     * @param [options.retryCallback] - The Function to call when a request for this resource fails. If it returns true, the request will be retried.
     * @param [options.retryAttempts = 0] - The number of times the retryCallback should be called before giving up.
     * @param [options.request] - A Request object that will be used. Intended for internal use only.
     * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
     */
    static fetchJson(options: {
        url: string;
        queryParameters?: any;
        templateValues?: any;
        headers?: any;
        proxy?: Proxy;
        retryCallback?: Resource.RetryCallback;
        retryAttempts?: number;
        request?: Request;
    }): Promise<any> | undefined;
    /**
     * Asynchronously loads the given resource as XML.  Returns a promise that will resolve to
     * an XML Document once loaded, or reject if the resource failed to load.  The data is loaded
     * using XMLHttpRequest, which means that in order to make requests to another origin,
     * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
     * @example
     * // load XML from a URL, setting a custom header
     * Cesium.loadXML('http://someUrl.com/someXML.xml', {
     *   'X-Custom-Header' : 'some value'
     * }).then(function(document) {
     *     // Do something with the document
     * }).catch(function(error) {
     *     // an error occurred
     * });
     * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
     */
    fetchXML(): Promise<XMLDocument> | undefined;
    /**
     * Creates a Resource and calls fetchXML() on it.
     * @param options - A url or an object with the following properties
     * @param options.url - The url of the resource.
     * @param [options.queryParameters] - An object containing query parameters that will be sent when retrieving the resource.
     * @param [options.templateValues] - Key/Value pairs that are used to replace template values (eg. {x}).
     * @param [options.headers = {}] - Additional HTTP headers that will be sent.
     * @param [options.proxy] - A proxy to be used when loading the resource.
     * @param [options.retryCallback] - The Function to call when a request for this resource fails. If it returns true, the request will be retried.
     * @param [options.retryAttempts = 0] - The number of times the retryCallback should be called before giving up.
     * @param [options.request] - A Request object that will be used. Intended for internal use only.
     * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
     */
    static fetchXML(options: {
        url: string;
        queryParameters?: any;
        templateValues?: any;
        headers?: any;
        proxy?: Proxy;
        retryCallback?: Resource.RetryCallback;
        retryAttempts?: number;
        request?: Request;
    }): Promise<XMLDocument> | undefined;
    /**
     * Requests a resource using JSONP.
     * @example
     * // load a data asynchronously
     * resource.fetchJsonp().then(function(data) {
     *     // use the loaded data
     * }).catch(function(error) {
     *     // an error occurred
     * });
     * @param [callbackParameterName = 'callback'] - The callback parameter name that the server expects.
     * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
     */
    fetchJsonp(callbackParameterName?: string): Promise<any> | undefined;
    /**
     * Creates a Resource from a URL and calls fetchJsonp() on it.
     * @param options - A url or an object with the following properties
     * @param options.url - The url of the resource.
     * @param [options.queryParameters] - An object containing query parameters that will be sent when retrieving the resource.
     * @param [options.templateValues] - Key/Value pairs that are used to replace template values (eg. {x}).
     * @param [options.headers = {}] - Additional HTTP headers that will be sent.
     * @param [options.proxy] - A proxy to be used when loading the resource.
     * @param [options.retryCallback] - The Function to call when a request for this resource fails. If it returns true, the request will be retried.
     * @param [options.retryAttempts = 0] - The number of times the retryCallback should be called before giving up.
     * @param [options.request] - A Request object that will be used. Intended for internal use only.
     * @param [options.callbackParameterName = 'callback'] - The callback parameter name that the server expects.
     * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
     */
    static fetchJsonp(options: {
        url: string;
        queryParameters?: any;
        templateValues?: any;
        headers?: any;
        proxy?: Proxy;
        retryCallback?: Resource.RetryCallback;
        retryAttempts?: number;
        request?: Request;
        callbackParameterName?: string;
    }): Promise<any> | undefined;
    /**
     * Asynchronously loads the given resource.  Returns a promise that will resolve to
     * the result once loaded, or reject if the resource failed to load.  The data is loaded
     * using XMLHttpRequest, which means that in order to make requests to another origin,
     * the server must have Cross-Origin Resource Sharing (CORS) headers enabled. It's recommended that you use
     * the more specific functions eg. fetchJson, fetchBlob, etc.
     * @example
     * resource.fetch()
     *   .then(function(body) {
     *       // use the data
     *   }).catch(function(error) {
     *       // an error occurred
     *   });
     * @param [options] - Object with the following properties:
     * @param [options.responseType] - The type of response.  This controls the type of item returned.
     * @param [options.headers] - Additional HTTP headers to send with the request, if any.
     * @param [options.overrideMimeType] - Overrides the MIME type returned by the server.
     * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
     */
    fetch(options?: {
        responseType?: string;
        headers?: any;
        overrideMimeType?: string;
    }): Promise<any> | undefined;
    /**
     * Creates a Resource from a URL and calls fetch() on it.
     * @param options - A url or an object with the following properties
     * @param options.url - The url of the resource.
     * @param [options.queryParameters] - An object containing query parameters that will be sent when retrieving the resource.
     * @param [options.templateValues] - Key/Value pairs that are used to replace template values (eg. {x}).
     * @param [options.headers = {}] - Additional HTTP headers that will be sent.
     * @param [options.proxy] - A proxy to be used when loading the resource.
     * @param [options.retryCallback] - The Function to call when a request for this resource fails. If it returns true, the request will be retried.
     * @param [options.retryAttempts = 0] - The number of times the retryCallback should be called before giving up.
     * @param [options.request] - A Request object that will be used. Intended for internal use only.
     * @param [options.responseType] - The type of response.  This controls the type of item returned.
     * @param [options.overrideMimeType] - Overrides the MIME type returned by the server.
     * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
     */
    static fetch(options: {
        url: string;
        queryParameters?: any;
        templateValues?: any;
        headers?: any;
        proxy?: Proxy;
        retryCallback?: Resource.RetryCallback;
        retryAttempts?: number;
        request?: Request;
        responseType?: string;
        overrideMimeType?: string;
    }): Promise<any> | undefined;
    /**
     * Asynchronously deletes the given resource.  Returns a promise that will resolve to
     * the result once loaded, or reject if the resource failed to load.  The data is loaded
     * using XMLHttpRequest, which means that in order to make requests to another origin,
     * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
     * @example
     * resource.delete()
     *   .then(function(body) {
     *       // use the data
     *   }).catch(function(error) {
     *       // an error occurred
     *   });
     * @param [options] - Object with the following properties:
     * @param [options.responseType] - The type of response.  This controls the type of item returned.
     * @param [options.headers] - Additional HTTP headers to send with the request, if any.
     * @param [options.overrideMimeType] - Overrides the MIME type returned by the server.
     * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
     */
    delete(options?: {
        responseType?: string;
        headers?: any;
        overrideMimeType?: string;
    }): Promise<any> | undefined;
    /**
     * Creates a Resource from a URL and calls delete() on it.
     * @param options - A url or an object with the following properties
     * @param options.url - The url of the resource.
     * @param [options.data] - Data that is posted with the resource.
     * @param [options.queryParameters] - An object containing query parameters that will be sent when retrieving the resource.
     * @param [options.templateValues] - Key/Value pairs that are used to replace template values (eg. {x}).
     * @param [options.headers = {}] - Additional HTTP headers that will be sent.
     * @param [options.proxy] - A proxy to be used when loading the resource.
     * @param [options.retryCallback] - The Function to call when a request for this resource fails. If it returns true, the request will be retried.
     * @param [options.retryAttempts = 0] - The number of times the retryCallback should be called before giving up.
     * @param [options.request] - A Request object that will be used. Intended for internal use only.
     * @param [options.responseType] - The type of response.  This controls the type of item returned.
     * @param [options.overrideMimeType] - Overrides the MIME type returned by the server.
     * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
     */
    static delete(options: {
        url: string;
        data?: any;
        queryParameters?: any;
        templateValues?: any;
        headers?: any;
        proxy?: Proxy;
        retryCallback?: Resource.RetryCallback;
        retryAttempts?: number;
        request?: Request;
        responseType?: string;
        overrideMimeType?: string;
    }): Promise<any> | undefined;
    /**
     * Asynchronously gets headers the given resource.  Returns a promise that will resolve to
     * the result once loaded, or reject if the resource failed to load.  The data is loaded
     * using XMLHttpRequest, which means that in order to make requests to another origin,
     * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
     * @example
     * resource.head()
     *   .then(function(headers) {
     *       // use the data
     *   }).catch(function(error) {
     *       // an error occurred
     *   });
     * @param [options] - Object with the following properties:
     * @param [options.responseType] - The type of response.  This controls the type of item returned.
     * @param [options.headers] - Additional HTTP headers to send with the request, if any.
     * @param [options.overrideMimeType] - Overrides the MIME type returned by the server.
     * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
     */
    head(options?: {
        responseType?: string;
        headers?: any;
        overrideMimeType?: string;
    }): Promise<any> | undefined;
    /**
     * Creates a Resource from a URL and calls head() on it.
     * @param options - A url or an object with the following properties
     * @param options.url - The url of the resource.
     * @param [options.queryParameters] - An object containing query parameters that will be sent when retrieving the resource.
     * @param [options.templateValues] - Key/Value pairs that are used to replace template values (eg. {x}).
     * @param [options.headers = {}] - Additional HTTP headers that will be sent.
     * @param [options.proxy] - A proxy to be used when loading the resource.
     * @param [options.retryCallback] - The Function to call when a request for this resource fails. If it returns true, the request will be retried.
     * @param [options.retryAttempts = 0] - The number of times the retryCallback should be called before giving up.
     * @param [options.request] - A Request object that will be used. Intended for internal use only.
     * @param [options.responseType] - The type of response.  This controls the type of item returned.
     * @param [options.overrideMimeType] - Overrides the MIME type returned by the server.
     * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
     */
    static head(options: {
        url: string;
        queryParameters?: any;
        templateValues?: any;
        headers?: any;
        proxy?: Proxy;
        retryCallback?: Resource.RetryCallback;
        retryAttempts?: number;
        request?: Request;
        responseType?: string;
        overrideMimeType?: string;
    }): Promise<any> | undefined;
    /**
     * Asynchronously gets options the given resource.  Returns a promise that will resolve to
     * the result once loaded, or reject if the resource failed to load.  The data is loaded
     * using XMLHttpRequest, which means that in order to make requests to another origin,
     * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
     * @example
     * resource.options()
     *   .then(function(headers) {
     *       // use the data
     *   }).catch(function(error) {
     *       // an error occurred
     *   });
     * @param [options] - Object with the following properties:
     * @param [options.responseType] - The type of response.  This controls the type of item returned.
     * @param [options.headers] - Additional HTTP headers to send with the request, if any.
     * @param [options.overrideMimeType] - Overrides the MIME type returned by the server.
     * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
     */
    options(options?: {
        responseType?: string;
        headers?: any;
        overrideMimeType?: string;
    }): Promise<any> | undefined;
    /**
     * Creates a Resource from a URL and calls options() on it.
     * @param options - A url or an object with the following properties
     * @param options.url - The url of the resource.
     * @param [options.queryParameters] - An object containing query parameters that will be sent when retrieving the resource.
     * @param [options.templateValues] - Key/Value pairs that are used to replace template values (eg. {x}).
     * @param [options.headers = {}] - Additional HTTP headers that will be sent.
     * @param [options.proxy] - A proxy to be used when loading the resource.
     * @param [options.retryCallback] - The Function to call when a request for this resource fails. If it returns true, the request will be retried.
     * @param [options.retryAttempts = 0] - The number of times the retryCallback should be called before giving up.
     * @param [options.request] - A Request object that will be used. Intended for internal use only.
     * @param [options.responseType] - The type of response.  This controls the type of item returned.
     * @param [options.overrideMimeType] - Overrides the MIME type returned by the server.
     * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
     */
    static options(options: {
        url: string;
        queryParameters?: any;
        templateValues?: any;
        headers?: any;
        proxy?: Proxy;
        retryCallback?: Resource.RetryCallback;
        retryAttempts?: number;
        request?: Request;
        responseType?: string;
        overrideMimeType?: string;
    }): Promise<any> | undefined;
    /**
     * Asynchronously posts data to the given resource.  Returns a promise that will resolve to
     * the result once loaded, or reject if the resource failed to load.  The data is loaded
     * using XMLHttpRequest, which means that in order to make requests to another origin,
     * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
     * @example
     * resource.post(data)
     *   .then(function(result) {
     *       // use the result
     *   }).catch(function(error) {
     *       // an error occurred
     *   });
     * @param data - Data that is posted with the resource.
     * @param [options] - Object with the following properties:
     * @param [options.data] - Data that is posted with the resource.
     * @param [options.responseType] - The type of response.  This controls the type of item returned.
     * @param [options.headers] - Additional HTTP headers to send with the request, if any.
     * @param [options.overrideMimeType] - Overrides the MIME type returned by the server.
     * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
     */
    post(data: any, options?: {
        data?: any;
        responseType?: string;
        headers?: any;
        overrideMimeType?: string;
    }): Promise<any> | undefined;
    /**
     * Creates a Resource from a URL and calls post() on it.
     * @param options - A url or an object with the following properties
     * @param options.url - The url of the resource.
     * @param options.data - Data that is posted with the resource.
     * @param [options.queryParameters] - An object containing query parameters that will be sent when retrieving the resource.
     * @param [options.templateValues] - Key/Value pairs that are used to replace template values (eg. {x}).
     * @param [options.headers = {}] - Additional HTTP headers that will be sent.
     * @param [options.proxy] - A proxy to be used when loading the resource.
     * @param [options.retryCallback] - The Function to call when a request for this resource fails. If it returns true, the request will be retried.
     * @param [options.retryAttempts = 0] - The number of times the retryCallback should be called before giving up.
     * @param [options.request] - A Request object that will be used. Intended for internal use only.
     * @param [options.responseType] - The type of response.  This controls the type of item returned.
     * @param [options.overrideMimeType] - Overrides the MIME type returned by the server.
     * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
     */
    static post(options: {
        url: string;
        data: any;
        queryParameters?: any;
        templateValues?: any;
        headers?: any;
        proxy?: Proxy;
        retryCallback?: Resource.RetryCallback;
        retryAttempts?: number;
        request?: Request;
        responseType?: string;
        overrideMimeType?: string;
    }): Promise<any> | undefined;
    /**
     * Asynchronously puts data to the given resource.  Returns a promise that will resolve to
     * the result once loaded, or reject if the resource failed to load.  The data is loaded
     * using XMLHttpRequest, which means that in order to make requests to another origin,
     * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
     * @example
     * resource.put(data)
     *   .then(function(result) {
     *       // use the result
     *   }).catch(function(error) {
     *       // an error occurred
     *   });
     * @param data - Data that is posted with the resource.
     * @param [options] - Object with the following properties:
     * @param [options.responseType] - The type of response.  This controls the type of item returned.
     * @param [options.headers] - Additional HTTP headers to send with the request, if any.
     * @param [options.overrideMimeType] - Overrides the MIME type returned by the server.
     * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
     */
    put(data: any, options?: {
        responseType?: string;
        headers?: any;
        overrideMimeType?: string;
    }): Promise<any> | undefined;
    /**
     * Creates a Resource from a URL and calls put() on it.
     * @param options - A url or an object with the following properties
     * @param options.url - The url of the resource.
     * @param options.data - Data that is posted with the resource.
     * @param [options.queryParameters] - An object containing query parameters that will be sent when retrieving the resource.
     * @param [options.templateValues] - Key/Value pairs that are used to replace template values (eg. {x}).
     * @param [options.headers = {}] - Additional HTTP headers that will be sent.
     * @param [options.proxy] - A proxy to be used when loading the resource.
     * @param [options.retryCallback] - The Function to call when a request for this resource fails. If it returns true, the request will be retried.
     * @param [options.retryAttempts = 0] - The number of times the retryCallback should be called before giving up.
     * @param [options.request] - A Request object that will be used. Intended for internal use only.
     * @param [options.responseType] - The type of response.  This controls the type of item returned.
     * @param [options.overrideMimeType] - Overrides the MIME type returned by the server.
     * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
     */
    static put(options: {
        url: string;
        data: any;
        queryParameters?: any;
        templateValues?: any;
        headers?: any;
        proxy?: Proxy;
        retryCallback?: Resource.RetryCallback;
        retryAttempts?: number;
        request?: Request;
        responseType?: string;
        overrideMimeType?: string;
    }): Promise<any> | undefined;
    /**
     * Asynchronously patches data to the given resource.  Returns a promise that will resolve to
     * the result once loaded, or reject if the resource failed to load.  The data is loaded
     * using XMLHttpRequest, which means that in order to make requests to another origin,
     * the server must have Cross-Origin Resource Sharing (CORS) headers enabled.
     * @example
     * resource.patch(data)
     *   .then(function(result) {
     *       // use the result
     *   }).catch(function(error) {
     *       // an error occurred
     *   });
     * @param data - Data that is posted with the resource.
     * @param [options] - Object with the following properties:
     * @param [options.responseType] - The type of response.  This controls the type of item returned.
     * @param [options.headers] - Additional HTTP headers to send with the request, if any.
     * @param [options.overrideMimeType] - Overrides the MIME type returned by the server.
     * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
     */
    patch(data: any, options?: {
        responseType?: string;
        headers?: any;
        overrideMimeType?: string;
    }): Promise<any> | undefined;
    /**
     * Creates a Resource from a URL and calls patch() on it.
     * @param options - A url or an object with the following properties
     * @param options.url - The url of the resource.
     * @param options.data - Data that is posted with the resource.
     * @param [options.queryParameters] - An object containing query parameters that will be sent when retrieving the resource.
     * @param [options.templateValues] - Key/Value pairs that are used to replace template values (eg. {x}).
     * @param [options.headers = {}] - Additional HTTP headers that will be sent.
     * @param [options.proxy] - A proxy to be used when loading the resource.
     * @param [options.retryCallback] - The Function to call when a request for this resource fails. If it returns true, the request will be retried.
     * @param [options.retryAttempts = 0] - The number of times the retryCallback should be called before giving up.
     * @param [options.request] - A Request object that will be used. Intended for internal use only.
     * @param [options.responseType] - The type of response.  This controls the type of item returned.
     * @param [options.overrideMimeType] - Overrides the MIME type returned by the server.
     * @returns a promise that will resolve to the requested data when loaded. Returns undefined if <code>request.throttle</code> is true and the request does not have high enough priority.
     */
    static patch(options: {
        url: string;
        data: any;
        queryParameters?: any;
        templateValues?: any;
        headers?: any;
        proxy?: Proxy;
        retryCallback?: Resource.RetryCallback;
        retryAttempts?: number;
        request?: Request;
        responseType?: string;
        overrideMimeType?: string;
    }): Promise<any> | undefined;
    /**
     * A resource instance initialized to the current browser location
     */
    static readonly DEFAULT: Resource;
}

/**
 * Constructs an exception object that is thrown due to an error that can occur at runtime, e.g.,
 * out of memory, could not compile shader, etc.  If a function may throw this
 * exception, the calling code should be prepared to catch it.
 * <br /><br />
 * On the other hand, a {@link DeveloperError} indicates an exception due
 * to a developer error, e.g., invalid argument, that usually indicates a bug in the
 * calling code.
 * @param [message] - The error message for this exception.
 */
export class RuntimeError extends Error {
    constructor(message?: string);
    /**
     * 'RuntimeError' indicating that this exception was thrown due to a runtime error.
     */
    readonly name: string;
    /**
     * The explanation for why this exception was thrown.
     */
    readonly message: string;
    /**
     * The stack trace of this exception, if available.
     */
    readonly stack: string;
}

export namespace ScreenSpaceEventHandler {
    /**
     * An Event that occurs at a single position on screen.
     */
    type PositionedEvent = {
        position: Cartesian2;
    };
    /**
     * @param event - The event which triggered the listener
     */
    type PositionedEventCallback = (event: ScreenSpaceEventHandler.PositionedEvent) => void;
    /**
     * An Event that starts at one position and ends at another.
     */
    type MotionEvent = {
        startPosition: Cartesian2;
        endPosition: Cartesian2;
    };
    /**
     * @param event - The event which triggered the listener
     */
    type MotionEventCallback = (event: ScreenSpaceEventHandler.MotionEvent) => void;
    /**
     * An Event that occurs at a two positions on screen.
     */
    type TwoPointEvent = {
        position1: Cartesian2;
        position2: Cartesian2;
    };
    /**
     * @param event - The event which triggered the listener
     */
    type TwoPointEventCallback = (event: ScreenSpaceEventHandler.TwoPointEvent) => void;
    /**
     * An Event that starts at a two positions on screen and moves to two other positions.
     */
    type TwoPointMotionEvent = {
        position1: Cartesian2;
        position2: Cartesian2;
        previousPosition1: Cartesian2;
        previousPosition2: Cartesian2;
    };
    /**
     * @param event - The event which triggered the listener
     */
    type TwoPointMotionEventCallback = (event: ScreenSpaceEventHandler.TwoPointMotionEvent) => void;
    /**
     * @param delta - The amount that the mouse wheel moved
     */
    type WheelEventCallback = (delta: number) => void;
}

/**
 * Handles user input events. Custom functions can be added to be executed on
 * when the user enters input.
 * @param [element = document] - The element to add events to.
 */
export class ScreenSpaceEventHandler {
    constructor(element?: HTMLCanvasElement);
    /**
     * Set a function to be executed on an input event.
     * @param action - Function to be executed when the input event occurs.
     * @param type - The ScreenSpaceEventType of input event.
     * @param [modifier] - A KeyboardEventModifier key that is held when a <code>type</code>
     * event occurs.
     */
    setInputAction(action: ScreenSpaceEventHandler.PositionedEventCallback | ScreenSpaceEventHandler.MotionEventCallback | ScreenSpaceEventHandler.WheelEventCallback | ScreenSpaceEventHandler.TwoPointEventCallback | ScreenSpaceEventHandler.TwoPointMotionEventCallback, type: ScreenSpaceEventType, modifier?: KeyboardEventModifier): void;
    /**
     * Returns the function to be executed on an input event.
     * @param type - The ScreenSpaceEventType of input event.
     * @param [modifier] - A KeyboardEventModifier key that is held when a <code>type</code>
     * event occurs.
     * @returns The function to be executed on an input event.
     */
    getInputAction(type: ScreenSpaceEventType, modifier?: KeyboardEventModifier): ScreenSpaceEventHandler.PositionedEventCallback | ScreenSpaceEventHandler.MotionEventCallback | ScreenSpaceEventHandler.WheelEventCallback | ScreenSpaceEventHandler.TwoPointEventCallback | ScreenSpaceEventHandler.TwoPointMotionEventCallback;
    /**
     * Removes the function to be executed on an input event.
     * @param type - The ScreenSpaceEventType of input event.
     * @param [modifier] - A KeyboardEventModifier key that is held when a <code>type</code>
     * event occurs.
     */
    removeInputAction(type: ScreenSpaceEventType, modifier?: KeyboardEventModifier): void;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     */
    isDestroyed(): boolean;
    /**
     * Removes listeners held by this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     * @example
     * handler = handler && handler.destroy();
     */
    destroy(): void;
    /**
     * The amount of time, in milliseconds, that mouse events will be disabled after
     * receiving any touch events, such that any emulated mouse events will be ignored.
     */
    static mouseEmulationIgnoreMilliseconds: number;
    /**
     * The amount of time, in milliseconds, before a touch on the screen becomes a
     * touch and hold.
     */
    static touchHoldDelayMilliseconds: number;
}

/**
 * This enumerated type is for classifying mouse events: down, up, click, double click, move and move while a button is held down.
 */
export enum ScreenSpaceEventType {
    /**
     * Represents a mouse left button down event.
     */
    LEFT_DOWN = 0,
    /**
     * Represents a mouse left button up event.
     */
    LEFT_UP = 1,
    /**
     * Represents a mouse left click event.
     */
    LEFT_CLICK = 2,
    /**
     * Represents a mouse left double click event.
     */
    LEFT_DOUBLE_CLICK = 3,
    /**
     * Represents a mouse left button down event.
     */
    RIGHT_DOWN = 5,
    /**
     * Represents a mouse right button up event.
     */
    RIGHT_UP = 6,
    /**
     * Represents a mouse right click event.
     */
    RIGHT_CLICK = 7,
    /**
     * Represents a mouse middle button down event.
     */
    MIDDLE_DOWN = 10,
    /**
     * Represents a mouse middle button up event.
     */
    MIDDLE_UP = 11,
    /**
     * Represents a mouse middle click event.
     */
    MIDDLE_CLICK = 12,
    /**
     * Represents a mouse move event.
     */
    MOUSE_MOVE = 15,
    /**
     * Represents a mouse wheel event.
     */
    WHEEL = 16,
    /**
     * Represents the start of a two-finger event on a touch surface.
     */
    PINCH_START = 17,
    /**
     * Represents the end of a two-finger event on a touch surface.
     */
    PINCH_END = 18,
    /**
     * Represents a change of a two-finger event on a touch surface.
     */
    PINCH_MOVE = 19
}

/**
 * Value and type information for per-instance geometry attribute that determines if the geometry instance will be shown.
 * @example
 * const instance = new Cesium.GeometryInstance({
 *   geometry : new Cesium.BoxGeometry({
 *     vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL,
 *     minimum : new Cesium.Cartesian3(-250000.0, -250000.0, -250000.0),
 *     maximum : new Cesium.Cartesian3(250000.0, 250000.0, 250000.0)
 *   }),
 *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(
 *     Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 1000000.0), new Cesium.Matrix4()),
 *   id : 'box',
 *   attributes : {
 *     show : new Cesium.ShowGeometryInstanceAttribute(false)
 *   }
 * });
 * @param [show = true] - Determines if the geometry instance will be shown.
 */
export class ShowGeometryInstanceAttribute {
    constructor(show?: boolean);
    /**
     * The values for the attributes stored in a typed array.
     */
    value: Uint8Array;
    /**
     * The datatype of each component in the attribute, e.g., individual elements in
     * {@link ColorGeometryInstanceAttribute#value}.
     */
    readonly componentDatatype: ComponentDatatype;
    /**
     * The number of components in the attributes, i.e., {@link ColorGeometryInstanceAttribute#value}.
     */
    readonly componentsPerAttribute: number;
    /**
     * When <code>true</code> and <code>componentDatatype</code> is an integer format,
     * indicate that the components should be mapped to the range [0, 1] (unsigned)
     * or [-1, 1] (signed) when they are accessed as floating-point for rendering.
     */
    readonly normalize: boolean;
    /**
     * Converts a boolean show to a typed array that can be used to assign a show attribute.
     * @example
     * const attributes = primitive.getGeometryInstanceAttributes('an id');
     * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true, attributes.show);
     * @param show - The show value.
     * @param [result] - The array to store the result in, if undefined a new instance will be created.
     * @returns The modified result parameter or a new instance if result was undefined.
     */
    static toValue(show: boolean, result?: Uint8Array): Uint8Array;
}

/**
 * Contains functions for finding the Cartesian coordinates of the sun and the moon in the
 * Earth-centered inertial frame.
 */
export namespace Simon1994PlanetaryPositions {
    /**
     * Computes the position of the Sun in the Earth-centered inertial frame
     * @param [julianDate] - The time at which to compute the Sun's position, if not provided the current system time is used.
     * @param [result] - The object onto which to store the result.
     * @returns Calculated sun position
     */
    function computeSunPositionInEarthInertialFrame(julianDate?: JulianDate, result?: Cartesian3): Cartesian3;
    /**
     * Computes the position of the Moon in the Earth-centered inertial frame
     * @param [julianDate] - The time at which to compute the Sun's position, if not provided the current system time is used.
     * @param [result] - The object onto which to store the result.
     * @returns Calculated moon position
     */
    function computeMoonPositionInEarthInertialFrame(julianDate?: JulianDate, result?: Cartesian3): Cartesian3;
}

/**
 * A description of a polyline modeled as a line strip; the first two positions define a line segment,
 * and each additional position defines a line segment from the previous position.
 * @example
 * // A polyline with two connected line segments
 * const polyline = new Cesium.SimplePolylineGeometry({
 *   positions : Cesium.Cartesian3.fromDegreesArray([
 *     0.0, 0.0,
 *     5.0, 0.0,
 *     5.0, 5.0
 *   ])
 * });
 * const geometry = Cesium.SimplePolylineGeometry.createGeometry(polyline);
 * @param options - Object with the following properties:
 * @param options.positions - An array of {@link Cartesian3} defining the positions in the polyline as a line strip.
 * @param [options.colors] - An Array of {@link Color} defining the per vertex or per segment colors.
 * @param [options.colorsPerVertex = false] - A boolean that determines whether the colors will be flat across each segment of the line or interpolated across the vertices.
 * @param [options.arcType = ArcType.GEODESIC] - The type of line the polyline segments must follow.
 * @param [options.granularity = Math.RADIANS_PER_DEGREE] - The distance, in radians, between each latitude and longitude if options.arcType is not ArcType.NONE. Determines the number of positions in the buffer.
 * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid to be used as a reference.
 */
export class SimplePolylineGeometry {
    constructor(options: {
        positions: Cartesian3[];
        colors?: Color[];
        colorsPerVertex?: boolean;
        arcType?: ArcType;
        granularity?: number;
        ellipsoid?: Ellipsoid;
    });
    /**
     * The number of elements used to pack the object into an array.
     */
    packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: SimplePolylineGeometry, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new SimplePolylineGeometry instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: SimplePolylineGeometry): SimplePolylineGeometry;
    /**
     * Computes the geometric representation of a simple polyline, including its vertices, indices, and a bounding sphere.
     * @param simplePolylineGeometry - A description of the polyline.
     * @returns The computed vertices and indices.
     */
    static createGeometry(simplePolylineGeometry: SimplePolylineGeometry): Geometry | undefined;
}

/**
 * A description of a sphere centered at the origin.
 * @example
 * const sphere = new Cesium.SphereGeometry({
 *   radius : 100.0,
 *   vertexFormat : Cesium.VertexFormat.POSITION_ONLY
 * });
 * const geometry = Cesium.SphereGeometry.createGeometry(sphere);
 * @param [options] - Object with the following properties:
 * @param [options.radius = 1.0] - The radius of the sphere.
 * @param [options.stackPartitions = 64] - The number of times to partition the ellipsoid into stacks.
 * @param [options.slicePartitions = 64] - The number of times to partition the ellipsoid into radial slices.
 * @param [options.vertexFormat = VertexFormat.DEFAULT] - The vertex attributes to be computed.
 */
export class SphereGeometry {
    constructor(options?: {
        radius?: number;
        stackPartitions?: number;
        slicePartitions?: number;
        vertexFormat?: VertexFormat;
    });
    /**
     * The number of elements used to pack the object into an array.
     */
    static packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: SphereGeometry, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new SphereGeometry instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: SphereGeometry): SphereGeometry;
    /**
     * Computes the geometric representation of a sphere, including its vertices, indices, and a bounding sphere.
     * @param sphereGeometry - A description of the sphere.
     * @returns The computed vertices and indices.
     */
    static createGeometry(sphereGeometry: SphereGeometry): Geometry | undefined;
}

/**
 * A description of the outline of a sphere.
 * @example
 * const sphere = new Cesium.SphereOutlineGeometry({
 *   radius : 100.0,
 *   stackPartitions : 6,
 *   slicePartitions: 5
 * });
 * const geometry = Cesium.SphereOutlineGeometry.createGeometry(sphere);
 * @param [options] - Object with the following properties:
 * @param [options.radius = 1.0] - The radius of the sphere.
 * @param [options.stackPartitions = 10] - The count of stacks for the sphere (1 greater than the number of parallel lines).
 * @param [options.slicePartitions = 8] - The count of slices for the sphere (Equal to the number of radial lines).
 * @param [options.subdivisions = 200] - The number of points per line, determining the granularity of the curvature .
 */
export class SphereOutlineGeometry {
    constructor(options?: {
        radius?: number;
        stackPartitions?: number;
        slicePartitions?: number;
        subdivisions?: number;
    });
    /**
     * The number of elements used to pack the object into an array.
     */
    static packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: SphereOutlineGeometry, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new SphereOutlineGeometry instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: SphereOutlineGeometry): SphereOutlineGeometry;
    /**
     * Computes the geometric representation of an outline of a sphere, including its vertices, indices, and a bounding sphere.
     * @param sphereGeometry - A description of the sphere outline.
     * @returns The computed vertices and indices.
     */
    static createGeometry(sphereGeometry: SphereOutlineGeometry): Geometry | undefined;
}

/**
 * A set of curvilinear 3-dimensional coordinates.
 * @param [clock = 0.0] - The angular coordinate lying in the xy-plane measured from the positive x-axis and toward the positive y-axis.
 * @param [cone = 0.0] - The angular coordinate measured from the positive z-axis and toward the negative z-axis.
 * @param [magnitude = 1.0] - The linear coordinate measured from the origin.
 */
export class Spherical {
    constructor(clock?: number, cone?: number, magnitude?: number);
    /**
     * The clock component.
     */
    clock: number;
    /**
     * The cone component.
     */
    cone: number;
    /**
     * The magnitude component.
     */
    magnitude: number;
    /**
     * Converts the provided Cartesian3 into Spherical coordinates.
     * @param cartesian3 - The Cartesian3 to be converted to Spherical.
     * @param [result] - The object in which the result will be stored, if undefined a new instance will be created.
     * @returns The modified result parameter, or a new instance if one was not provided.
     */
    static fromCartesian3(cartesian3: Cartesian3, result?: Spherical): Spherical;
    /**
     * Creates a duplicate of a Spherical.
     * @param spherical - The spherical to clone.
     * @param [result] - The object to store the result into, if undefined a new instance will be created.
     * @returns The modified result parameter or a new instance if result was undefined. (Returns undefined if spherical is undefined)
     */
    static clone(spherical: Spherical, result?: Spherical): Spherical;
    /**
     * Computes the normalized version of the provided spherical.
     * @param spherical - The spherical to be normalized.
     * @param [result] - The object to store the result into, if undefined a new instance will be created.
     * @returns The modified result parameter or a new instance if result was undefined.
     */
    static normalize(spherical: Spherical, result?: Spherical): Spherical;
    /**
     * Returns true if the first spherical is equal to the second spherical, false otherwise.
     * @param left - The first Spherical to be compared.
     * @param right - The second Spherical to be compared.
     * @returns true if the first spherical is equal to the second spherical, false otherwise.
     */
    static equals(left: Spherical, right: Spherical): boolean;
    /**
     * Returns true if the first spherical is within the provided epsilon of the second spherical, false otherwise.
     * @param left - The first Spherical to be compared.
     * @param right - The second Spherical to be compared.
     * @param [epsilon = 0.0] - The epsilon to compare against.
     * @returns true if the first spherical is within the provided epsilon of the second spherical, false otherwise.
     */
    static equalsEpsilon(left: Spherical, right: Spherical, epsilon?: number): boolean;
    /**
     * Returns true if this spherical is equal to the provided spherical, false otherwise.
     * @param other - The Spherical to be compared.
     * @returns true if this spherical is equal to the provided spherical, false otherwise.
     */
    equals(other: Spherical): boolean;
    /**
     * Creates a duplicate of this Spherical.
     * @param [result] - The object to store the result into, if undefined a new instance will be created.
     * @returns The modified result parameter or a new instance if result was undefined.
     */
    clone(result?: Spherical): Spherical;
    /**
     * Returns true if this spherical is within the provided epsilon of the provided spherical, false otherwise.
     * @param other - The Spherical to be compared.
     * @param epsilon - The epsilon to compare against.
     * @returns true if this spherical is within the provided epsilon of the provided spherical, false otherwise.
     */
    equalsEpsilon(other: Spherical, epsilon: number): boolean;
    /**
     * Returns a string representing this instance in the format (clock, cone, magnitude).
     * @returns A string representing this instance.
     */
    toString(): string;
}

/**
 * Creates a curve parameterized and evaluated by time. This type describes an interface
 * and is not intended to be instantiated directly.
 */
export class Spline {
    constructor();
    /**
     * An array of times for the control points.
     */
    times: number[];
    /**
     * An array of control points.
     */
    points: Cartesian3[] | Quaternion[];
    /**
     * Evaluates the curve at a given time.
     * @param time - The time at which to evaluate the curve.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new instance of the point on the curve at the given time.
     */
    evaluate(time: number, result?: Cartesian3 | Quaternion | number[]): Cartesian3 | Quaternion | number[];
    /**
     * Finds an index <code>i</code> in <code>times</code> such that the parameter
     * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.
     * @param time - The time.
     * @param startIndex - The index from which to start the search.
     * @returns The index for the element at the start of the interval.
     */
    findTimeInterval(time: number, startIndex: number): number;
    /**
     * Wraps the given time to the period covered by the spline.
     * @param time - The time.
     * @returns The time, wrapped around the animation period.
     */
    wrapTime(time: number): number;
    /**
     * Clamps the given time to the period covered by the spline.
     * @param time - The time.
     * @returns The time, clamped to the animation period.
     */
    clampTime(time: number): number;
}

/**
 * A spline that is composed of piecewise constants representing a step function.
 * @example
 * const times = [ 0.0, 1.5, 3.0, 4.5, 6.0 ];
 * const spline = new Cesium.SteppedSpline({
 *     times : times,
 *     points : [
 *         new Cesium.Cartesian3(1235398.0, -4810983.0, 4146266.0),
 *         new Cesium.Cartesian3(1372574.0, -5345182.0, 4606657.0),
 *         new Cesium.Cartesian3(-757983.0, -5542796.0, 4514323.0),
 *         new Cesium.Cartesian3(-2821260.0, -5248423.0, 4021290.0),
 *         new Cesium.Cartesian3(-2539788.0, -4724797.0, 3620093.0)
 *     ]
 * });
 *
 * const p0 = spline.evaluate(times[0]);
 * @param options - Object with the following properties:
 * @param options.times - An array of strictly increasing, unit-less, floating-point times at each point. The values are in no way connected to the clock time. They are the parameterization for the curve.
 * @param options.points - The array of control points.
 */
export class SteppedSpline {
    constructor(options: {
        times: number[];
        points: number[] | Cartesian3[] | Quaternion[];
    });
    /**
     * An array of times for the control points.
     */
    readonly times: number[];
    /**
     * An array of control points.
     */
    readonly points: number[] | Cartesian3[] | Quaternion[];
    /**
     * Finds an index <code>i</code> in <code>times</code> such that the parameter
     * <code>time</code> is in the interval <code>[times[i], times[i + 1]]</code>.
     * @param time - The time.
     * @param startIndex - The index from which to start the search.
     * @returns The index for the element at the start of the interval.
     */
    findTimeInterval(time: number, startIndex: number): number;
    /**
     * Wraps the given time to the period covered by the spline.
     * @param time - The time.
     * @returns The time, wrapped around to the updated animation.
     */
    wrapTime(time: number): number;
    /**
     * Clamps the given time to the period covered by the spline.
     * @param time - The time.
     * @returns The time, clamped to the animation period.
     */
    clampTime(time: number): number;
    /**
     * Evaluates the curve at a given time.
     * @param time - The time at which to evaluate the curve.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new instance of the point on the curve at the given time.
     */
    evaluate(time: number, result?: Cartesian3 | Quaternion): number | Cartesian3 | Quaternion;
}

/**
 * Represents a point in stereographic coordinates, which can be obtained by projecting a cartesian coordinate from one pole onto a tangent plane at the other pole.
 * The stereographic projection faithfully represents the relative directions of all great circles passing through its center point.
 * To faithfully represents angles everywhere, this is a conformal projection, which means points are projected onto an arbrary sphere.
 * @param [position] - The steroegraphic coordinates.
 * @param [tangentPlane] - The tangent plane onto which the point was projected.
 */
export function Stereographic(position?: Cartesian2, tangentPlane?: EllipseGeometry): void;

/**
 * A wrapper around a web worker that allows scheduling tasks for a given worker,
 * returning results asynchronously via a promise.
 *
 * The Worker is not constructed until a task is scheduled.
 * @param workerPath - The Url to the worker. This can either be an absolute path or relative to the Cesium Workers folder.
 * @param [maximumActiveTasks = Number.POSITIVE_INFINITY] - The maximum number of active tasks.  Once exceeded,
 *                                        scheduleTask will not queue any more tasks, allowing
 *                                        work to be rescheduled in future frames.
 */
export class TaskProcessor {
    constructor(workerPath: string, maximumActiveTasks?: number);
    /**
     * Schedule a task to be processed by the web worker asynchronously.  If there are currently more
     * tasks active than the maximum set by the constructor, will immediately return undefined.
     * Otherwise, returns a promise that will resolve to the result posted back by the worker when
     * finished.
     * @example
     * const taskProcessor = new Cesium.TaskProcessor('myWorkerPath');
     * const promise = taskProcessor.scheduleTask({
     *     someParameter : true,
     *     another : 'hello'
     * });
     * if (!Cesium.defined(promise)) {
     *     // too many active tasks - try again later
     * } else {
     *     promise.then(function(result) {
     *         // use the result of the task
     *     });
     * }
     * @param parameters - Any input data that will be posted to the worker.
     * @param [transferableObjects] - An array of objects contained in parameters that should be
     *                                      transferred to the worker instead of copied.
     * @returns Either a promise that will resolve to the result when available, or undefined
     *                    if there are too many active tasks,
     */
    scheduleTask(parameters: any, transferableObjects?: object[]): Promise<object> | undefined;
    /**
     * Posts a message to a web worker with configuration to initialize loading
     * and compiling a web assembly module asynchronously, as well as an optional
     * fallback JavaScript module to use if Web Assembly is not supported.
     * @param [webAssemblyOptions] - An object with the following properties:
     * @param [webAssemblyOptions.modulePath] - The path of the web assembly JavaScript wrapper module.
     * @param [webAssemblyOptions.wasmBinaryFile] - The path of the web assembly binary file.
     * @param [webAssemblyOptions.fallbackModulePath] - The path of the fallback JavaScript module to use if web assembly is not supported.
     * @returns A promise that resolves to the result when the web worker has loaded and compiled the web assembly module and is ready to process tasks.
     */
    initWebAssemblyModule(webAssemblyOptions?: {
        modulePath?: string;
        wasmBinaryFile?: string;
        fallbackModulePath?: string;
    }): Promise<any>;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * @returns True if this object was destroyed; otherwise, false.
     */
    isDestroyed(): boolean;
    /**
     * Destroys this object.  This will immediately terminate the Worker.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     */
    destroy(): void;
}

/**
 * Terrain data for a single tile.  This type describes an
 * interface and is not intended to be instantiated directly.
 */
export class TerrainData {
    constructor();
    /**
     * An array of credits for this tile.
     */
    credits: Credit[];
    /**
     * The water mask included in this terrain data, if any.  A water mask is a rectangular
     * Uint8Array or image where a value of 255 indicates water and a value of 0 indicates land.
     * Values in between 0 and 255 are allowed as well to smoothly blend between land and water.
     */
    waterMask: Uint8Array | HTMLImageElement | HTMLCanvasElement;
    /**
     * Computes the terrain height at a specified longitude and latitude.
     * @param rectangle - The rectangle covered by this terrain data.
     * @param longitude - The longitude in radians.
     * @param latitude - The latitude in radians.
     * @returns The terrain height at the specified position.  If the position
     *          is outside the rectangle, this method will extrapolate the height, which is likely to be wildly
     *          incorrect for positions far outside the rectangle.
     */
    interpolateHeight(rectangle: Rectangle, longitude: number, latitude: number): number;
    /**
     * Determines if a given child tile is available, based on the
     * {@link TerrainData#childTileMask}.  The given child tile coordinates are assumed
     * to be one of the four children of this tile.  If non-child tile coordinates are
     * given, the availability of the southeast child tile is returned.
     * @param thisX - The tile X coordinate of this (the parent) tile.
     * @param thisY - The tile Y coordinate of this (the parent) tile.
     * @param childX - The tile X coordinate of the child tile to check for availability.
     * @param childY - The tile Y coordinate of the child tile to check for availability.
     * @returns True if the child tile is available; otherwise, false.
     */
    isChildAvailable(thisX: number, thisY: number, childX: number, childY: number): boolean;
    /**
     * Upsamples this terrain data for use by a descendant tile.
     * @param tilingScheme - The tiling scheme of this terrain data.
     * @param thisX - The X coordinate of this tile in the tiling scheme.
     * @param thisY - The Y coordinate of this tile in the tiling scheme.
     * @param thisLevel - The level of this tile in the tiling scheme.
     * @param descendantX - The X coordinate within the tiling scheme of the descendant tile for which we are upsampling.
     * @param descendantY - The Y coordinate within the tiling scheme of the descendant tile for which we are upsampling.
     * @param descendantLevel - The level within the tiling scheme of the descendant tile for which we are upsampling.
     * @returns A promise for upsampled terrain data for the descendant tile,
     *          or undefined if too many asynchronous upsample operations are in progress and the request has been
     *          deferred.
     */
    upsample(tilingScheme: TilingScheme, thisX: number, thisY: number, thisLevel: number, descendantX: number, descendantY: number, descendantLevel: number): Promise<TerrainData> | undefined;
    /**
     * Gets a value indicating whether or not this terrain data was created by upsampling lower resolution
     * terrain data.  If this value is false, the data was obtained from some other source, such
     * as by downloading it from a remote server.  This method should return true for instances
     * returned from a call to {@link TerrainData#upsample}.
     * @returns True if this instance was created by upsampling; otherwise, false.
     */
    wasCreatedByUpsampling(): boolean;
}

export namespace TerrainProvider {
    /**
     * A function that is called when an error occurs.
     * @param err - An object holding details about the error that occurred.
     */
    type ErrorEvent = (this: TerrainProvider, err: TileProviderError) => void;
}

/**
 * Provides terrain or other geometry for the surface of an ellipsoid.  The surface geometry is
 * organized into a pyramid of tiles according to a {@link TilingScheme}.  This type describes an
 * interface and is not intended to be instantiated directly.
 */
export class TerrainProvider {
    constructor();
    /**
     * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing
     * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
     * are passed an instance of {@link TileProviderError}.
     */
    readonly errorEvent: Event<TerrainProvider.ErrorEvent>;
    /**
     * Gets the credit to display when this terrain provider is active.  Typically this is used to credit
     * the source of the terrain.
     */
    readonly credit: Credit;
    /**
     * Gets the tiling scheme used by the provider.
     */
    readonly tilingScheme: TilingScheme;
    /**
     * Gets a value indicating whether or not the provider includes a water mask.  The water mask
     * indicates which areas of the globe are water rather than land, so they can be rendered
     * as a reflective surface with animated waves.
     */
    readonly hasWaterMask: boolean;
    /**
     * Gets a value indicating whether or not the requested tiles include vertex normals.
     */
    readonly hasVertexNormals: boolean;
    /**
     * Gets an object that can be used to determine availability of terrain from this provider, such as
     * at points and in rectangles. This property may be undefined if availability
     * information is not available.
     */
    readonly availability: TileAvailability;
    /**
     * Gets a list of indices for a triangle mesh representing a regular grid.  Calling
     * this function multiple times with the same grid width and height returns the
     * same list of indices.  The total number of vertices must be less than or equal
     * to 65536.
     * @param width - The number of vertices in the regular grid in the horizontal direction.
     * @param height - The number of vertices in the regular grid in the vertical direction.
     * @returns The list of indices. Uint16Array gets returned for 64KB or less and Uint32Array for 4GB or less.
     */
    static getRegularGridIndices(width: number, height: number): Uint16Array | Uint32Array;
    /**
     * Specifies the quality of terrain created from heightmaps.  A value of 1.0 will
     * ensure that adjacent heightmap vertices are separated by no more than
     * {@link Globe.maximumScreenSpaceError} screen pixels and will probably go very slowly.
     * A value of 0.5 will cut the estimated level zero geometric error in half, allowing twice the
     * screen pixels between adjacent heightmap vertices and thus rendering more quickly.
     */
    static heightmapTerrainQuality: number;
    /**
     * Determines an appropriate geometric error estimate when the geometry comes from a heightmap.
     * @param ellipsoid - The ellipsoid to which the terrain is attached.
     * @param tileImageWidth - The width, in pixels, of the heightmap associated with a single tile.
     * @param numberOfTilesAtLevelZero - The number of tiles in the horizontal direction at tile level zero.
     * @returns An estimated geometric error.
     */
    static getEstimatedLevelZeroGeometricErrorForAHeightmap(ellipsoid: Ellipsoid, tileImageWidth: number, numberOfTilesAtLevelZero: number): number;
    /**
     * Requests the geometry for a given tile. The result must include terrain data and
     * may optionally include a water mask and an indication of which child tiles are available.
     * @param x - The X coordinate of the tile for which to request geometry.
     * @param y - The Y coordinate of the tile for which to request geometry.
     * @param level - The level of the tile for which to request geometry.
     * @param [request] - The request object. Intended for internal use only.
     * @returns A promise for the requested geometry.  If this method
     *          returns undefined instead of a promise, it is an indication that too many requests are already
     *          pending and the request will be retried later.
     */
    requestTileGeometry(x: number, y: number, level: number, request?: Request): Promise<TerrainData> | undefined;
    /**
     * Gets the maximum geometric error allowed in a tile at a given level.
     * @param level - The tile level for which to get the maximum geometric error.
     * @returns The maximum geometric error.
     */
    getLevelMaximumGeometricError(level: number): number;
    /**
     * Determines whether data for a tile is available to be loaded.
     * @param x - The X coordinate of the tile for which to request geometry.
     * @param y - The Y coordinate of the tile for which to request geometry.
     * @param level - The level of the tile for which to request geometry.
     * @returns Undefined if not supported by the terrain provider, otherwise true or false.
     */
    getTileDataAvailable(x: number, y: number, level: number): boolean | undefined;
    /**
     * Makes sure we load availability data for a tile
     * @param x - The X coordinate of the tile for which to request geometry.
     * @param y - The Y coordinate of the tile for which to request geometry.
     * @param level - The level of the tile for which to request geometry.
     * @returns Undefined if nothing need to be loaded or a Promise that resolves when all required tiles are loaded
     */
    loadTileDataAvailability(x: number, y: number, level: number): undefined | Promise<void>;
}

/**
 * Reports the availability of tiles in a {@link TilingScheme}.
 * @param tilingScheme - The tiling scheme in which to report availability.
 * @param maximumLevel - The maximum tile level that is potentially available.
 */
export class TileAvailability {
    constructor(tilingScheme: TilingScheme, maximumLevel: number);
    /**
     * Marks a rectangular range of tiles in a particular level as being available.  For best performance,
     * add your ranges in order of increasing level.
     * @param level - The level.
     * @param startX - The X coordinate of the first available tiles at the level.
     * @param startY - The Y coordinate of the first available tiles at the level.
     * @param endX - The X coordinate of the last available tiles at the level.
     * @param endY - The Y coordinate of the last available tiles at the level.
     */
    addAvailableTileRange(level: number, startX: number, startY: number, endX: number, endY: number): void;
    /**
     * Determines the level of the most detailed tile covering the position.  This function
     * usually completes in time logarithmic to the number of rectangles added with
     * {@link TileAvailability#addAvailableTileRange}.
     * @param position - The position for which to determine the maximum available level.  The height component is ignored.
     * @returns The level of the most detailed tile covering the position.
     */
    computeMaximumLevelAtPosition(position: Cartographic): number;
    /**
     * Finds the most detailed level that is available _everywhere_ within a given rectangle.  More detailed
     * tiles may be available in parts of the rectangle, but not the whole thing.  The return value of this
     * function may be safely passed to {@link sampleTerrain} for any position within the rectangle.  This function
     * usually completes in time logarithmic to the number of rectangles added with
     * {@link TileAvailability#addAvailableTileRange}.
     * @param rectangle - The rectangle.
     * @returns The best available level for the entire rectangle.
     */
    computeBestAvailableLevelOverRectangle(rectangle: Rectangle): number;
    /**
     * Determines if a particular tile is available.
     * @param level - The tile level to check.
     * @param x - The X coordinate of the tile to check.
     * @param y - The Y coordinate of the tile to check.
     * @returns True if the tile is available; otherwise, false.
     */
    isTileAvailable(level: number, x: number, y: number): boolean;
    /**
     * Computes a bit mask indicating which of a tile's four children exist.
     * If a child's bit is set, a tile is available for that child.  If it is cleared,
     * the tile is not available.  The bit values are as follows:
     * <table>
     *     <tr><th>Bit Position</th><th>Bit Value</th><th>Child Tile</th></tr>
     *     <tr><td>0</td><td>1</td><td>Southwest</td></tr>
     *     <tr><td>1</td><td>2</td><td>Southeast</td></tr>
     *     <tr><td>2</td><td>4</td><td>Northwest</td></tr>
     *     <tr><td>3</td><td>8</td><td>Northeast</td></tr>
     * </table>
     * @param level - The level of the parent tile.
     * @param x - The X coordinate of the parent tile.
     * @param y - The Y coordinate of the parent tile.
     * @returns The bit mask indicating child availability.
     */
    computeChildMaskForTile(level: number, x: number, y: number): number;
}

/**
 * Provides details about an error that occurred in an {@link ImageryProvider} or a {@link TerrainProvider}.
 * @param provider - The imagery or terrain provider that experienced the error.
 * @param message - A message describing the error.
 * @param [x] - The X coordinate of the tile that experienced the error, or undefined if the error
 *        is not specific to a particular tile.
 * @param [y] - The Y coordinate of the tile that experienced the error, or undefined if the error
 *        is not specific to a particular tile.
 * @param [level] - The level of the tile that experienced the error, or undefined if the error
 *        is not specific to a particular tile.
 * @param [timesRetried = 0] - The number of times this operation has been retried.
 * @param [error] - The error or exception that occurred, if any.
 */
export class TileProviderError {
    constructor(provider: ImageryProvider | TerrainProvider, message: string, x?: number, y?: number, level?: number, timesRetried?: number, error?: Error);
    /**
     * The {@link ImageryProvider} or {@link TerrainProvider} that experienced the error.
     */
    provider: ImageryProvider | TerrainProvider;
    /**
     * The message describing the error.
     */
    message: string;
    /**
     * The X coordinate of the tile that experienced the error.  If the error is not specific
     * to a particular tile, this property will be undefined.
     */
    x: number;
    /**
     * The Y coordinate of the tile that experienced the error.  If the error is not specific
     * to a particular tile, this property will be undefined.
     */
    y: number;
    /**
     * The level-of-detail of the tile that experienced the error.  If the error is not specific
     * to a particular tile, this property will be undefined.
     */
    level: number;
    /**
     * The number of times this operation has been retried.
     */
    timesRetried: number;
    /**
     * True if the failed operation should be retried; otherwise, false.  The imagery or terrain provider
     * will set the initial value of this property before raising the event, but any listeners
     * can change it.  The value after the last listener is invoked will be acted upon.
     */
    retry: boolean;
    /**
     * The error or exception that occurred, if any.
     */
    error: Error;
    /**
     * Reports an error in an {@link ImageryProvider} or {@link TerrainProvider} by raising an event if it has any listeners, or by
     * logging the error to the console if the event has no listeners.  This method also tracks the number
     * of times the operation has been retried.
     * @param previousError - The error instance returned by this function the last
     *        time it was called for this error, or undefined if this is the first time this error has
     *        occurred.
     * @param [provider] - The imagery or terrain provider that encountered the error.
     * @param [event] - The event to raise to inform listeners of the error.
     * @param [message] - The message describing the error.
     * @param [x] - The X coordinate of the tile that experienced the error, or undefined if the
     *        error is not specific to a particular tile.
     * @param [y] - The Y coordinate of the tile that experienced the error, or undefined if the
     *        error is not specific to a particular tile.
     * @param [level] - The level-of-detail of the tile that experienced the error, or undefined if the
     *        error is not specific to a particular tile.
     * @param [errorDetails] - The error or exception that occurred, if any.
     * @returns The error instance that was passed to the event listeners and that
     *          should be passed to this function the next time it is called for the same error in order
     *          to track retry counts.
     */
    static reportError(previousError: TileProviderError, provider?: ImageryProvider | TerrainProvider, event?: Event, message?: string, x?: number, y?: number, level?: number, errorDetails?: Error): TileProviderError;
    /**
     * Reports success of an operation by resetting the retry count of a previous error, if any.  This way,
     * if the error occurs again in the future, the listeners will be informed that it has not yet been retried.
     * @param previousError - The previous error, or undefined if this operation has
     *        not previously resulted in an error.
     */
    static reportSuccess(previousError: TileProviderError): void;
}

export namespace TileProviderError {
    /**
     * A function that will be called to retry the operation.
     */
    type RetryFunction = () => void;
}

/**
 * A tiling scheme for geometry or imagery on the surface of an ellipsoid.  At level-of-detail zero,
 * the coarsest, least-detailed level, the number of tiles is configurable.
 * At level of detail one, each of the level zero tiles has four children, two in each direction.
 * At level of detail two, each of the level one tiles has four children, two in each direction.
 * This continues for as many levels as are present in the geometry or imagery source.
 */
export class TilingScheme {
    constructor();
    /**
     * Gets the ellipsoid that is tiled by the tiling scheme.
     */
    ellipsoid: Ellipsoid;
    /**
     * Gets the rectangle, in radians, covered by this tiling scheme.
     */
    rectangle: Rectangle;
    /**
     * Gets the map projection used by the tiling scheme.
     */
    projection: MapProjection;
    /**
     * Gets the total number of tiles in the X direction at a specified level-of-detail.
     * @param level - The level-of-detail.
     * @returns The number of tiles in the X direction at the given level.
     */
    getNumberOfXTilesAtLevel(level: number): number;
    /**
     * Gets the total number of tiles in the Y direction at a specified level-of-detail.
     * @param level - The level-of-detail.
     * @returns The number of tiles in the Y direction at the given level.
     */
    getNumberOfYTilesAtLevel(level: number): number;
    /**
     * Transforms a rectangle specified in geodetic radians to the native coordinate system
     * of this tiling scheme.
     * @param rectangle - The rectangle to transform.
     * @param [result] - The instance to which to copy the result, or undefined if a new instance
     *        should be created.
     * @returns The specified 'result', or a new object containing the native rectangle if 'result'
     *          is undefined.
     */
    rectangleToNativeRectangle(rectangle: Rectangle, result?: Rectangle): Rectangle;
    /**
     * Converts tile x, y coordinates and level to a rectangle expressed in the native coordinates
     * of the tiling scheme.
     * @param x - The integer x coordinate of the tile.
     * @param y - The integer y coordinate of the tile.
     * @param level - The tile level-of-detail.  Zero is the least detailed.
     * @param [result] - The instance to which to copy the result, or undefined if a new instance
     *        should be created.
     * @returns The specified 'result', or a new object containing the rectangle
     *          if 'result' is undefined.
     */
    tileXYToNativeRectangle(x: number, y: number, level: number, result?: any): Rectangle;
    /**
     * Converts tile x, y coordinates and level to a cartographic rectangle in radians.
     * @param x - The integer x coordinate of the tile.
     * @param y - The integer y coordinate of the tile.
     * @param level - The tile level-of-detail.  Zero is the least detailed.
     * @param [result] - The instance to which to copy the result, or undefined if a new instance
     *        should be created.
     * @returns The specified 'result', or a new object containing the rectangle
     *          if 'result' is undefined.
     */
    tileXYToRectangle(x: number, y: number, level: number, result?: any): Rectangle;
    /**
     * Calculates the tile x, y coordinates of the tile containing
     * a given cartographic position.
     * @param position - The position.
     * @param level - The tile level-of-detail.  Zero is the least detailed.
     * @param [result] - The instance to which to copy the result, or undefined if a new instance
     *        should be created.
     * @returns The specified 'result', or a new object containing the tile x, y coordinates
     *          if 'result' is undefined.
     */
    positionToTileXY(position: Cartographic, level: number, result?: Cartesian2): Cartesian2;
}

/**
 * An interval defined by a start and a stop time; optionally including those times as part of the interval.
 * Arbitrary data can optionally be associated with each instance for used with {@link TimeIntervalCollection}.
 * @example
 * // Create an instance that spans August 1st, 1980 and is associated
 * // with a Cartesian position.
 * const timeInterval = new Cesium.TimeInterval({
 *     start : Cesium.JulianDate.fromIso8601('1980-08-01T00:00:00Z'),
 *     stop : Cesium.JulianDate.fromIso8601('1980-08-02T00:00:00Z'),
 *     isStartIncluded : true,
 *     isStopIncluded : false,
 *     data : Cesium.Cartesian3.fromDegrees(39.921037, -75.170082)
 * });
 * @example
 * // Create two instances from ISO 8601 intervals with associated numeric data
 * // then compute their intersection, summing the data they contain.
 * const left = Cesium.TimeInterval.fromIso8601({
 *     iso8601 : '2000/2010',
 *     data : 2
 * });
 *
 * const right = Cesium.TimeInterval.fromIso8601({
 *     iso8601 : '1995/2005',
 *     data : 3
 * });
 *
 * //The result of the below intersection will be an interval equivalent to
 * //const intersection = Cesium.TimeInterval.fromIso8601({
 * //  iso8601 : '2000/2005',
 * //  data : 5
 * //});
 * const intersection = new Cesium.TimeInterval();
 * Cesium.TimeInterval.intersect(left, right, intersection, function(leftData, rightData) {
 *     return leftData + rightData;
 * });
 * @example
 * // Check if an interval contains a specific time.
 * const dateToCheck = Cesium.JulianDate.fromIso8601('1982-09-08T11:30:00Z');
 * const containsDate = Cesium.TimeInterval.contains(timeInterval, dateToCheck);
 * @param [options] - Object with the following properties:
 * @param [options.start = new JulianDate()] - The start time of the interval.
 * @param [options.stop = new JulianDate()] - The stop time of the interval.
 * @param [options.isStartIncluded = true] - <code>true</code> if <code>options.start</code> is included in the interval, <code>false</code> otherwise.
 * @param [options.isStopIncluded = true] - <code>true</code> if <code>options.stop</code> is included in the interval, <code>false</code> otherwise.
 * @param [options.data] - Arbitrary data associated with this interval.
 */
export class TimeInterval {
    constructor(options?: {
        start?: JulianDate;
        stop?: JulianDate;
        isStartIncluded?: boolean;
        isStopIncluded?: boolean;
        data?: any;
    });
    /**
     * Gets or sets the start time of this interval.
     */
    start: JulianDate;
    /**
     * Gets or sets the stop time of this interval.
     */
    stop: JulianDate;
    /**
     * Gets or sets the data associated with this interval.
     */
    data: any;
    /**
     * Gets or sets whether or not the start time is included in this interval.
     */
    isStartIncluded: boolean;
    /**
     * Gets or sets whether or not the stop time is included in this interval.
     */
    isStopIncluded: boolean;
    /**
     * Gets whether or not this interval is empty.
     */
    readonly isEmpty: boolean;
    /**
     * Creates a new instance from a {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} interval.
     * @param options - Object with the following properties:
     * @param options.iso8601 - An ISO 8601 interval.
     * @param [options.isStartIncluded = true] - <code>true</code> if <code>options.start</code> is included in the interval, <code>false</code> otherwise.
     * @param [options.isStopIncluded = true] - <code>true</code> if <code>options.stop</code> is included in the interval, <code>false</code> otherwise.
     * @param [options.data] - Arbitrary data associated with this interval.
     * @param [result] - An existing instance to use for the result.
     * @returns The modified result parameter or a new instance if none was provided.
     */
    static fromIso8601(options: {
        iso8601: string;
        isStartIncluded?: boolean;
        isStopIncluded?: boolean;
        data?: any;
    }, result?: TimeInterval): TimeInterval;
    /**
     * Creates an ISO8601 representation of the provided interval.
     * @param timeInterval - The interval to be converted.
     * @param [precision] - The number of fractional digits used to represent the seconds component.  By default, the most precise representation is used.
     * @returns The ISO8601 representation of the provided interval.
     */
    static toIso8601(timeInterval: TimeInterval, precision?: number): string;
    /**
     * Duplicates the provided instance.
     * @param [timeInterval] - The instance to clone.
     * @param [result] - An existing instance to use for the result.
     * @returns The modified result parameter or a new instance if none was provided.
     */
    static clone(timeInterval?: TimeInterval, result?: TimeInterval): TimeInterval;
    /**
     * Compares two instances and returns <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [left] - The first instance.
     * @param [right] - The second instance.
     * @param [dataComparer] - A function which compares the data of the two intervals.  If omitted, reference equality is used.
     * @returns <code>true</code> if the dates are equal; otherwise, <code>false</code>.
     */
    static equals(left?: TimeInterval, right?: TimeInterval, dataComparer?: TimeInterval.DataComparer): boolean;
    /**
     * Compares two instances and returns <code>true</code> if they are within <code>epsilon</code> seconds of
     * each other.  That is, in order for the dates to be considered equal (and for
     * this function to return <code>true</code>), the absolute value of the difference between them, in
     * seconds, must be less than <code>epsilon</code>.
     * @param [left] - The first instance.
     * @param [right] - The second instance.
     * @param [epsilon = 0] - The maximum number of seconds that should separate the two instances.
     * @param [dataComparer] - A function which compares the data of the two intervals.  If omitted, reference equality is used.
     * @returns <code>true</code> if the two dates are within <code>epsilon</code> seconds of each other; otherwise <code>false</code>.
     */
    static equalsEpsilon(left?: TimeInterval, right?: TimeInterval, epsilon?: number, dataComparer?: TimeInterval.DataComparer): boolean;
    /**
     * Computes the intersection of two intervals, optionally merging their data.
     * @param left - The first interval.
     * @param [right] - The second interval.
     * @param [result] - An existing instance to use for the result.
     * @param [mergeCallback] - A function which merges the data of the two intervals. If omitted, the data from the left interval will be used.
     * @returns The modified result parameter.
     */
    static intersect(left: TimeInterval, right?: TimeInterval, result?: TimeInterval, mergeCallback?: TimeInterval.MergeCallback): TimeInterval;
    /**
     * Checks if the specified date is inside the provided interval.
     * @param timeInterval - The interval.
     * @param julianDate - The date to check.
     * @returns <code>true</code> if the interval contains the specified date, <code>false</code> otherwise.
     */
    static contains(timeInterval: TimeInterval, julianDate: JulianDate): boolean;
    /**
     * Duplicates this instance.
     * @param [result] - An existing instance to use for the result.
     * @returns The modified result parameter or a new instance if none was provided.
     */
    clone(result?: TimeInterval): TimeInterval;
    /**
     * Compares this instance against the provided instance componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [right] - The right hand side interval.
     * @param [dataComparer] - A function which compares the data of the two intervals.  If omitted, reference equality is used.
     * @returns <code>true</code> if they are equal, <code>false</code> otherwise.
     */
    equals(right?: TimeInterval, dataComparer?: TimeInterval.DataComparer): boolean;
    /**
     * Compares this instance against the provided instance componentwise and returns
     * <code>true</code> if they are within the provided epsilon,
     * <code>false</code> otherwise.
     * @param [right] - The right hand side interval.
     * @param [epsilon = 0] - The epsilon to use for equality testing.
     * @param [dataComparer] - A function which compares the data of the two intervals.  If omitted, reference equality is used.
     * @returns <code>true</code> if they are within the provided epsilon, <code>false</code> otherwise.
     */
    equalsEpsilon(right?: TimeInterval, epsilon?: number, dataComparer?: TimeInterval.DataComparer): boolean;
    /**
     * Creates a string representing this TimeInterval in ISO8601 format.
     * @returns A string representing this TimeInterval in ISO8601 format.
     */
    toString(): string;
    /**
     * An immutable empty interval.
     */
    static readonly EMPTY: TimeInterval;
}

export namespace TimeInterval {
    /**
     * Function interface for merging interval data.
     * @param leftData - The first data instance.
     * @param rightData - The second data instance.
     */
    type MergeCallback = (leftData: any, rightData: any) => any;
    /**
     * Function interface for comparing interval data.
     * @param leftData - The first data instance.
     * @param rightData - The second data instance.
     */
    type DataComparer = (leftData: any, rightData: any) => boolean;
}

/**
 * A non-overlapping collection of {@link TimeInterval} instances sorted by start time.
 * @param [intervals] - An array of intervals to add to the collection.
 */
export class TimeIntervalCollection {
    constructor(intervals?: TimeInterval[]);
    /**
     * Gets an event that is raised whenever the collection of intervals change.
     */
    readonly changedEvent: Event;
    /**
     * Gets the start time of the collection.
     */
    readonly start: JulianDate;
    /**
     * Gets whether or not the start time is included in the collection.
     */
    readonly isStartIncluded: boolean;
    /**
     * Gets the stop time of the collection.
     */
    readonly stop: JulianDate;
    /**
     * Gets whether or not the stop time is included in the collection.
     */
    readonly isStopIncluded: boolean;
    /**
     * Gets the number of intervals in the collection.
     */
    readonly length: number;
    /**
     * Gets whether or not the collection is empty.
     */
    readonly isEmpty: boolean;
    /**
     * Compares this instance against the provided instance componentwise and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [right] - The right hand side collection.
     * @param [dataComparer] - A function which compares the data of the two intervals.  If omitted, reference equality is used.
     * @returns <code>true</code> if they are equal, <code>false</code> otherwise.
     */
    equals(right?: TimeIntervalCollection, dataComparer?: TimeInterval.DataComparer): boolean;
    /**
     * Gets the interval at the specified index.
     * @param index - The index of the interval to retrieve.
     * @returns The interval at the specified index, or <code>undefined</code> if no interval exists as that index.
     */
    get(index: number): TimeInterval | undefined;
    /**
     * Removes all intervals from the collection.
     */
    removeAll(): void;
    /**
     * Finds and returns the interval that contains the specified date.
     * @param date - The date to search for.
     * @returns The interval containing the specified date, <code>undefined</code> if no such interval exists.
     */
    findIntervalContainingDate(date: JulianDate): TimeInterval | undefined;
    /**
     * Finds and returns the data for the interval that contains the specified date.
     * @param date - The date to search for.
     * @returns The data for the interval containing the specified date, or <code>undefined</code> if no such interval exists.
     */
    findDataForIntervalContainingDate(date: JulianDate): any;
    /**
     * Checks if the specified date is inside this collection.
     * @param julianDate - The date to check.
     * @returns <code>true</code> if the collection contains the specified date, <code>false</code> otherwise.
     */
    contains(julianDate: JulianDate): boolean;
    /**
     * Finds and returns the index of the interval in the collection that contains the specified date.
     * @param date - The date to search for.
     * @returns The index of the interval that contains the specified date, if no such interval exists,
     * it returns a negative number which is the bitwise complement of the index of the next interval that
     * starts after the date, or if no interval starts after the specified date, the bitwise complement of
     * the length of the collection.
     */
    indexOf(date: JulianDate): number;
    /**
     * Returns the first interval in the collection that matches the specified parameters.
     * All parameters are optional and <code>undefined</code> parameters are treated as a don't care condition.
     * @param [options] - Object with the following properties:
     * @param [options.start] - The start time of the interval.
     * @param [options.stop] - The stop time of the interval.
     * @param [options.isStartIncluded] - <code>true</code> if <code>options.start</code> is included in the interval, <code>false</code> otherwise.
     * @param [options.isStopIncluded] - <code>true</code> if <code>options.stop</code> is included in the interval, <code>false</code> otherwise.
     * @returns The first interval in the collection that matches the specified parameters.
     */
    findInterval(options?: {
        start?: JulianDate;
        stop?: JulianDate;
        isStartIncluded?: boolean;
        isStopIncluded?: boolean;
    }): TimeInterval | undefined;
    /**
     * Adds an interval to the collection, merging intervals that contain the same data and
     * splitting intervals of different data as needed in order to maintain a non-overlapping collection.
     * The data in the new interval takes precedence over any existing intervals in the collection.
     * @param interval - The interval to add.
     * @param [dataComparer] - A function which compares the data of the two intervals.  If omitted, reference equality is used.
     */
    addInterval(interval: TimeInterval, dataComparer?: TimeInterval.DataComparer): void;
    /**
     * Removes the specified interval from this interval collection, creating a hole over the specified interval.
     * The data property of the input interval is ignored.
     * @param interval - The interval to remove.
     * @returns <code>true</code> if the interval was removed, <code>false</code> if no part of the interval was in the collection.
     */
    removeInterval(interval: TimeInterval): boolean;
    /**
     * Creates a new instance that is the intersection of this collection and the provided collection.
     * @param other - The collection to intersect with.
     * @param [dataComparer] - A function which compares the data of the two intervals.  If omitted, reference equality is used.
     * @param [mergeCallback] - A function which merges the data of the two intervals. If omitted, the data from the left interval will be used.
     * @returns A new TimeIntervalCollection which is the intersection of this collection and the provided collection.
     */
    intersect(other: TimeIntervalCollection, dataComparer?: TimeInterval.DataComparer, mergeCallback?: TimeInterval.MergeCallback): TimeIntervalCollection;
    /**
     * Creates a new instance from a JulianDate array.
     * @param options - Object with the following properties:
     * @param options.julianDates - An array of ISO 8601 dates.
     * @param [options.isStartIncluded = true] - <code>true</code> if start time is included in the interval, <code>false</code> otherwise.
     * @param [options.isStopIncluded = true] - <code>true</code> if stop time is included in the interval, <code>false</code> otherwise.
     * @param [options.leadingInterval = false] - <code>true</code> if you want to add a interval from Iso8601.MINIMUM_VALUE to start time,  <code>false</code> otherwise.
     * @param [options.trailingInterval = false] - <code>true</code> if you want to add a interval from stop time to Iso8601.MAXIMUM_VALUE,  <code>false</code> otherwise.
     * @param [options.dataCallback] - A function that will be return the data that is called with each interval before it is added to the collection. If unspecified, the data will be the index in the collection.
     * @param [result] - An existing instance to use for the result.
     * @returns The modified result parameter or a new instance if none was provided.
     */
    static fromJulianDateArray(options: {
        julianDates: JulianDate[];
        isStartIncluded?: boolean;
        isStopIncluded?: boolean;
        leadingInterval?: boolean;
        trailingInterval?: boolean;
        dataCallback?: (...params: any[]) => any;
    }, result?: TimeIntervalCollection): TimeIntervalCollection;
    /**
     * Creates a new instance from an {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} time interval (start/end/duration).
     * @param options - Object with the following properties:
     * @param options.iso8601 - An ISO 8601 interval.
     * @param [options.isStartIncluded = true] - <code>true</code> if start time is included in the interval, <code>false</code> otherwise.
     * @param [options.isStopIncluded = true] - <code>true</code> if stop time is included in the interval, <code>false</code> otherwise.
     * @param [options.leadingInterval = false] - <code>true</code> if you want to add a interval from Iso8601.MINIMUM_VALUE to start time,  <code>false</code> otherwise.
     * @param [options.trailingInterval = false] - <code>true</code> if you want to add a interval from stop time to Iso8601.MAXIMUM_VALUE,  <code>false</code> otherwise.
     * @param [options.dataCallback] - A function that will be return the data that is called with each interval before it is added to the collection. If unspecified, the data will be the index in the collection.
     * @param [result] - An existing instance to use for the result.
     * @returns The modified result parameter or a new instance if none was provided.
     */
    static fromIso8601(options: {
        iso8601: string;
        isStartIncluded?: boolean;
        isStopIncluded?: boolean;
        leadingInterval?: boolean;
        trailingInterval?: boolean;
        dataCallback?: (...params: any[]) => any;
    }, result?: TimeIntervalCollection): TimeIntervalCollection;
    /**
     * Creates a new instance from a {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} date array.
     * @param options - Object with the following properties:
     * @param options.iso8601Dates - An array of ISO 8601 dates.
     * @param [options.isStartIncluded = true] - <code>true</code> if start time is included in the interval, <code>false</code> otherwise.
     * @param [options.isStopIncluded = true] - <code>true</code> if stop time is included in the interval, <code>false</code> otherwise.
     * @param [options.leadingInterval = false] - <code>true</code> if you want to add a interval from Iso8601.MINIMUM_VALUE to start time,  <code>false</code> otherwise.
     * @param [options.trailingInterval = false] - <code>true</code> if you want to add a interval from stop time to Iso8601.MAXIMUM_VALUE,  <code>false</code> otherwise.
     * @param [options.dataCallback] - A function that will be return the data that is called with each interval before it is added to the collection. If unspecified, the data will be the index in the collection.
     * @param [result] - An existing instance to use for the result.
     * @returns The modified result parameter or a new instance if none was provided.
     */
    static fromIso8601DateArray(options: {
        iso8601Dates: string[];
        isStartIncluded?: boolean;
        isStopIncluded?: boolean;
        leadingInterval?: boolean;
        trailingInterval?: boolean;
        dataCallback?: (...params: any[]) => any;
    }, result?: TimeIntervalCollection): TimeIntervalCollection;
    /**
     * Creates a new instance from a {@link http://en.wikipedia.org/wiki/ISO_8601|ISO 8601} duration array.
     * @param options - Object with the following properties:
     * @param options.epoch - An date that the durations are relative to.
     * @param options.iso8601Durations - An array of ISO 8601 durations.
     * @param [options.relativeToPrevious = false] - <code>true</code> if durations are relative to previous date, <code>false</code> if always relative to the epoch.
     * @param [options.isStartIncluded = true] - <code>true</code> if start time is included in the interval, <code>false</code> otherwise.
     * @param [options.isStopIncluded = true] - <code>true</code> if stop time is included in the interval, <code>false</code> otherwise.
     * @param [options.leadingInterval = false] - <code>true</code> if you want to add a interval from Iso8601.MINIMUM_VALUE to start time,  <code>false</code> otherwise.
     * @param [options.trailingInterval = false] - <code>true</code> if you want to add a interval from stop time to Iso8601.MAXIMUM_VALUE,  <code>false</code> otherwise.
     * @param [options.dataCallback] - A function that will be return the data that is called with each interval before it is added to the collection. If unspecified, the data will be the index in the collection.
     * @param [result] - An existing instance to use for the result.
     * @returns The modified result parameter or a new instance if none was provided.
     */
    static fromIso8601DurationArray(options: {
        epoch: JulianDate;
        iso8601Durations: string;
        relativeToPrevious?: boolean;
        isStartIncluded?: boolean;
        isStopIncluded?: boolean;
        leadingInterval?: boolean;
        trailingInterval?: boolean;
        dataCallback?: (...params: any[]) => any;
    }, result?: TimeIntervalCollection): TimeIntervalCollection;
}

/**
 * Provides the type of time standards which JulianDate can take as input.
 */
export enum TimeStandard {
    /**
     * Represents the coordinated Universal Time (UTC) time standard.
     *
     * UTC is related to TAI according to the relationship
     * <code>UTC = TAI - deltaT</code> where <code>deltaT</code> is the number of leap
     * seconds which have been introduced as of the time in TAI.
     */
    UTC = 0,
    /**
     * Represents the International Atomic Time (TAI) time standard.
     * TAI is the principal time standard to which the other time standards are related.
     */
    TAI = 1
}

/**
 * Contains functions for transforming positions to various reference frames.
 */
export namespace Transforms {
    /**
     * Generates a function that computes a 4x4 transformation matrix from a reference frame
     * centered at the provided origin to the provided ellipsoid's fixed reference frame.
     * @param firstAxis - name of the first axis of the local reference frame. Must be
     *  'east', 'north', 'up', 'west', 'south' or 'down'.
     * @param secondAxis - name of the second axis of the local reference frame. Must be
     *  'east', 'north', 'up', 'west', 'south' or 'down'.
     * @returns The function that will computes a
     * 4x4 transformation matrix from a reference frame, with first axis and second axis compliant with the parameters,
     */
    function localFrameToFixedFrameGenerator(firstAxis: string, secondAxis: string): Transforms.LocalFrameToFixedFrame;
    /**
     * Computes a 4x4 transformation matrix from a reference frame
     * centered at the provided origin to the provided ellipsoid's fixed reference frame.
     * @param origin - The center point of the local reference frame.
     * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid whose fixed frame is used in the transformation.
     * @param [result] - The object onto which to store the result.
     */
    type LocalFrameToFixedFrame = (origin: Cartesian3, ellipsoid?: Ellipsoid, result?: Matrix4) => Matrix4;
    /**
     * Computes a 4x4 transformation matrix from a reference frame with an east-north-up axes
     * centered at the provided origin to the provided ellipsoid's fixed reference frame.
     * The local axes are defined as:
     * <ul>
     * <li>The <code>x</code> axis points in the local east direction.</li>
     * <li>The <code>y</code> axis points in the local north direction.</li>
     * <li>The <code>z</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>
     * </ul>
     * @example
     * // Get the transform from local east-north-up at cartographic (0.0, 0.0) to Earth's fixed frame.
     * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
     * const transform = Cesium.Transforms.eastNorthUpToFixedFrame(center);
     * @param origin - The center point of the local reference frame.
     * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid whose fixed frame is used in the transformation.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Matrix4 instance if none was provided.
     */
    function eastNorthUpToFixedFrame(origin: Cartesian3, ellipsoid?: Ellipsoid, result?: Matrix4): Matrix4;
    /**
     * Computes a 4x4 transformation matrix from a reference frame with an north-east-down axes
     * centered at the provided origin to the provided ellipsoid's fixed reference frame.
     * The local axes are defined as:
     * <ul>
     * <li>The <code>x</code> axis points in the local north direction.</li>
     * <li>The <code>y</code> axis points in the local east direction.</li>
     * <li>The <code>z</code> axis points in the opposite direction of the ellipsoid surface normal which passes through the position.</li>
     * </ul>
     * @example
     * // Get the transform from local north-east-down at cartographic (0.0, 0.0) to Earth's fixed frame.
     * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
     * const transform = Cesium.Transforms.northEastDownToFixedFrame(center);
     * @param origin - The center point of the local reference frame.
     * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid whose fixed frame is used in the transformation.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Matrix4 instance if none was provided.
     */
    function northEastDownToFixedFrame(origin: Cartesian3, ellipsoid?: Ellipsoid, result?: Matrix4): Matrix4;
    /**
     * Computes a 4x4 transformation matrix from a reference frame with an north-up-east axes
     * centered at the provided origin to the provided ellipsoid's fixed reference frame.
     * The local axes are defined as:
     * <ul>
     * <li>The <code>x</code> axis points in the local north direction.</li>
     * <li>The <code>y</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>
     * <li>The <code>z</code> axis points in the local east direction.</li>
     * </ul>
     * @example
     * // Get the transform from local north-up-east at cartographic (0.0, 0.0) to Earth's fixed frame.
     * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
     * const transform = Cesium.Transforms.northUpEastToFixedFrame(center);
     * @param origin - The center point of the local reference frame.
     * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid whose fixed frame is used in the transformation.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Matrix4 instance if none was provided.
     */
    function northUpEastToFixedFrame(origin: Cartesian3, ellipsoid?: Ellipsoid, result?: Matrix4): Matrix4;
    /**
     * Computes a 4x4 transformation matrix from a reference frame with an north-west-up axes
     * centered at the provided origin to the provided ellipsoid's fixed reference frame.
     * The local axes are defined as:
     * <ul>
     * <li>The <code>x</code> axis points in the local north direction.</li>
     * <li>The <code>y</code> axis points in the local west direction.</li>
     * <li>The <code>z</code> axis points in the direction of the ellipsoid surface normal which passes through the position.</li>
     * </ul>
     * @example
     * // Get the transform from local north-West-Up at cartographic (0.0, 0.0) to Earth's fixed frame.
     * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
     * const transform = Cesium.Transforms.northWestUpToFixedFrame(center);
     * @param origin - The center point of the local reference frame.
     * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid whose fixed frame is used in the transformation.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Matrix4 instance if none was provided.
     */
    function northWestUpToFixedFrame(origin: Cartesian3, ellipsoid?: Ellipsoid, result?: Matrix4): Matrix4;
    /**
     * Computes a 4x4 transformation matrix from a reference frame with axes computed from the heading-pitch-roll angles
     * centered at the provided origin to the provided ellipsoid's fixed reference frame. Heading is the rotation from the local north
     * direction where a positive angle is increasing eastward. Pitch is the rotation from the local east-north plane. Positive pitch angles
     * are above the plane. Negative pitch angles are below the plane. Roll is the first rotation applied about the local east axis.
     * @example
     * // Get the transform from local heading-pitch-roll at cartographic (0.0, 0.0) to Earth's fixed frame.
     * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
     * const heading = -Cesium.Math.PI_OVER_TWO;
     * const pitch = Cesium.Math.PI_OVER_FOUR;
     * const roll = 0.0;
     * const hpr = new Cesium.HeadingPitchRoll(heading, pitch, roll);
     * const transform = Cesium.Transforms.headingPitchRollToFixedFrame(center, hpr);
     * @param origin - The center point of the local reference frame.
     * @param headingPitchRoll - The heading, pitch, and roll.
     * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid whose fixed frame is used in the transformation.
     * @param [fixedFrameTransform = Transforms.eastNorthUpToFixedFrame] - A 4x4 transformation
     *  matrix from a reference frame to the provided ellipsoid's fixed reference frame
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Matrix4 instance if none was provided.
     */
    function headingPitchRollToFixedFrame(origin: Cartesian3, headingPitchRoll: HeadingPitchRoll, ellipsoid?: Ellipsoid, fixedFrameTransform?: Transforms.LocalFrameToFixedFrame, result?: Matrix4): Matrix4;
    /**
     * Computes a quaternion from a reference frame with axes computed from the heading-pitch-roll angles
     * centered at the provided origin. Heading is the rotation from the local north
     * direction where a positive angle is increasing eastward. Pitch is the rotation from the local east-north plane. Positive pitch angles
     * are above the plane. Negative pitch angles are below the plane. Roll is the first rotation applied about the local east axis.
     * @example
     * // Get the quaternion from local heading-pitch-roll at cartographic (0.0, 0.0) to Earth's fixed frame.
     * const center = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
     * const heading = -Cesium.Math.PI_OVER_TWO;
     * const pitch = Cesium.Math.PI_OVER_FOUR;
     * const roll = 0.0;
     * const hpr = new HeadingPitchRoll(heading, pitch, roll);
     * const quaternion = Cesium.Transforms.headingPitchRollQuaternion(center, hpr);
     * @param origin - The center point of the local reference frame.
     * @param headingPitchRoll - The heading, pitch, and roll.
     * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid whose fixed frame is used in the transformation.
     * @param [fixedFrameTransform = Transforms.eastNorthUpToFixedFrame] - A 4x4 transformation
     *  matrix from a reference frame to the provided ellipsoid's fixed reference frame
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Quaternion instance if none was provided.
     */
    function headingPitchRollQuaternion(origin: Cartesian3, headingPitchRoll: HeadingPitchRoll, ellipsoid?: Ellipsoid, fixedFrameTransform?: Transforms.LocalFrameToFixedFrame, result?: Quaternion): Quaternion;
    /**
     * Computes heading-pitch-roll angles from a transform in a particular reference frame. Heading is the rotation from the local north
     * direction where a positive angle is increasing eastward. Pitch is the rotation from the local east-north plane. Positive pitch angles
     * are above the plane. Negative pitch angles are below the plane. Roll is the first rotation applied about the local east axis.
     * @param transform - The transform
     * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid whose fixed frame is used in the transformation.
     * @param [fixedFrameTransform = Transforms.eastNorthUpToFixedFrame] - A 4x4 transformation
     *  matrix from a reference frame to the provided ellipsoid's fixed reference frame
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new HeadingPitchRoll instance if none was provided.
     */
    function fixedFrameToHeadingPitchRoll(transform: Matrix4, ellipsoid?: Ellipsoid, fixedFrameTransform?: Transforms.LocalFrameToFixedFrame, result?: HeadingPitchRoll): HeadingPitchRoll;
    /**
     * Computes a rotation matrix to transform a point or vector from True Equator Mean Equinox (TEME) axes to the
     * pseudo-fixed axes at a given time.  This method treats the UT1 time standard as equivalent to UTC.
     * @example
     * //Set the view to the inertial frame.
     * scene.postUpdate.addEventListener(function(scene, time) {
     *    const now = Cesium.JulianDate.now();
     *    const offset = Cesium.Matrix4.multiplyByPoint(camera.transform, camera.position, new Cesium.Cartesian3());
     *    const transform = Cesium.Matrix4.fromRotationTranslation(Cesium.Transforms.computeTemeToPseudoFixedMatrix(now));
     *    const inverseTransform = Cesium.Matrix4.inverseTransformation(transform, new Cesium.Matrix4());
     *    Cesium.Matrix4.multiplyByPoint(inverseTransform, offset, offset);
     *    camera.lookAtTransform(transform, offset);
     * });
     * @param date - The time at which to compute the rotation matrix.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Matrix3 instance if none was provided.
     */
    function computeTemeToPseudoFixedMatrix(date: JulianDate, result?: Matrix3): Matrix3;
    /**
     * Preloads the data necessary to transform between the ICRF and Fixed axes, in either
     * direction, over a given interval.  This function returns a promise that, when resolved,
     * indicates that the preload has completed.
     * @example
     * const interval = new Cesium.TimeInterval(...);
     * await Cesium.Transforms.preloadIcrfFixed(interval));
     * // the data is now loaded
     * @param timeInterval - The interval to preload.
     * @returns A promise that, when resolved, indicates that the preload has completed
     *          and evaluation of the transformation between the fixed and ICRF axes will
     *          no longer return undefined for a time inside the interval.
     */
    function preloadIcrfFixed(timeInterval: TimeInterval): Promise<void>;
    /**
     * Computes a rotation matrix to transform a point or vector from the International Celestial
     * Reference Frame (GCRF/ICRF) inertial frame axes to the Earth-Fixed frame axes (ITRF)
     * at a given time.  This function may return undefined if the data necessary to
     * do the transformation is not yet loaded.
     * @example
     * scene.postUpdate.addEventListener(function(scene, time) {
     *   // View in ICRF.
     *   const icrfToFixed = Cesium.Transforms.computeIcrfToFixedMatrix(time);
     *   if (Cesium.defined(icrfToFixed)) {
     *     const offset = Cesium.Cartesian3.clone(camera.position);
     *     const transform = Cesium.Matrix4.fromRotationTranslation(icrfToFixed);
     *     camera.lookAtTransform(transform, offset);
     *   }
     * });
     * @param date - The time at which to compute the rotation matrix.
     * @param [result] - The object onto which to store the result.  If this parameter is
     *                  not specified, a new instance is created and returned.
     * @returns The rotation matrix, or undefined if the data necessary to do the
     *                   transformation is not yet loaded.
     */
    function computeIcrfToFixedMatrix(date: JulianDate, result?: Matrix3): Matrix3;
    /**
     * Computes a rotation matrix to transform a point or vector from the Earth-Fixed frame axes (ITRF)
     * to the International Celestial Reference Frame (GCRF/ICRF) inertial frame axes
     * at a given time.  This function may return undefined if the data necessary to
     * do the transformation is not yet loaded.
     * @example
     * // Transform a point from the Fixed axes to the ICRF axes.
     * const now = Cesium.JulianDate.now();
     * const pointInFixed = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
     * const fixedToIcrf = Cesium.Transforms.computeFixedToIcrfMatrix(now);
     * let pointInInertial = new Cesium.Cartesian3();
     * if (Cesium.defined(fixedToIcrf)) {
     *     pointInInertial = Cesium.Matrix3.multiplyByVector(fixedToIcrf, pointInFixed, pointInInertial);
     * }
     * @param date - The time at which to compute the rotation matrix.
     * @param [result] - The object onto which to store the result.  If this parameter is
     *                  not specified, a new instance is created and returned.
     * @returns The rotation matrix, or undefined if the data necessary to do the
     *                   transformation is not yet loaded.
     */
    function computeFixedToIcrfMatrix(date: JulianDate, result?: Matrix3): Matrix3;
    /**
     * Transform a point from model coordinates to window coordinates.
     * @param modelViewProjectionMatrix - The 4x4 model-view-projection matrix.
     * @param viewportTransformation - The 4x4 viewport transformation.
     * @param point - The point to transform.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Cartesian2 instance if none was provided.
     */
    function pointToWindowCoordinates(modelViewProjectionMatrix: Matrix4, viewportTransformation: Matrix4, point: Cartesian3, result?: Cartesian2): Cartesian2;
    /**
     * Transform a position and velocity to a rotation matrix.
     * @param position - The position to transform.
     * @param velocity - The velocity vector to transform.
     * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid whose fixed frame is used in the transformation.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Matrix3 instance if none was provided.
     */
    function rotationMatrixFromPositionVelocity(position: Cartesian3, velocity: Cartesian3, ellipsoid?: Ellipsoid, result?: Matrix3): Matrix3;
}

/**
 * An affine transformation defined by a translation, rotation, and scale.
 * @param [translation = Cartesian3.ZERO] - A {@link Cartesian3} specifying the (x, y, z) translation to apply to the node.
 * @param [rotation = Quaternion.IDENTITY] - A {@link Quaternion} specifying the (x, y, z, w) rotation to apply to the node.
 * @param [scale = new Cartesian3(1.0, 1.0, 1.0)] - A {@link Cartesian3} specifying the (x, y, z) scaling to apply to the node.
 */
export class TranslationRotationScale {
    constructor(translation?: Cartesian3, rotation?: Quaternion, scale?: Cartesian3);
    /**
     * Gets or sets the (x, y, z) translation to apply to the node.
     */
    translation: Cartesian3;
    /**
     * Gets or sets the (x, y, z, w) rotation to apply to the node.
     */
    rotation: Quaternion;
    /**
     * Gets or sets the (x, y, z) scaling to apply to the node.
     */
    scale: Cartesian3;
    /**
     * Compares this instance against the provided instance and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [right] - The right hand side TranslationRotationScale.
     * @returns <code>true</code> if they are equal, <code>false</code> otherwise.
     */
    equals(right?: TranslationRotationScale): boolean;
}

/**
 * Uses the Tridiagonal Matrix Algorithm, also known as the Thomas Algorithm, to solve
 * a system of linear equations where the coefficient matrix is a tridiagonal matrix.
 */
export namespace TridiagonalSystemSolver {
    /**
     * Solves a tridiagonal system of linear equations.
     * @example
     * const lowerDiagonal = [1.0, 1.0, 1.0, 1.0];
     * const diagonal = [2.0, 4.0, 4.0, 4.0, 2.0];
     * const upperDiagonal = [1.0, 1.0, 1.0, 1.0];
     * const rightHandSide = [
     *     new Cesium.Cartesian3(410757.0, -1595711.0, 1375302.0),
     *     new Cesium.Cartesian3(-5986705.0, -2190640.0, 1099600.0),
     *     new Cesium.Cartesian3(-12593180.0, 288588.0, -1755549.0),
     *     new Cesium.Cartesian3(-5349898.0, 2457005.0, -2685438.0),
     *     new Cesium.Cartesian3(845820.0, 1573488.0, -1205591.0)
     * ];
     *
     * const solution = Cesium.TridiagonalSystemSolver.solve(lowerDiagonal, diagonal, upperDiagonal, rightHandSide);
     * @param diagonal - An array with length <code>n</code> that contains the diagonal of the coefficient matrix.
     * @param lower - An array with length <code>n - 1</code> that contains the lower diagonal of the coefficient matrix.
     * @param upper - An array with length <code>n - 1</code> that contains the upper diagonal of the coefficient matrix.
     * @param right - An array of Cartesians with length <code>n</code> that is the right side of the system of equations.
     * @returns An array of Cartesians with length <code>n</code> that is the solution to the tridiagonal system of equations.
     */
    function solve(diagonal: number[], lower: number[], upper: number[], right: Cartesian3[]): Cartesian3[];
}

/**
 * A singleton that contains all of the servers that are trusted. Credentials will be sent with
 * any requests to these servers.
 */
export namespace TrustedServers {
    /**
     * Adds a trusted server to the registry
     * @example
     * // Add a trusted server
     * TrustedServers.add('my.server.com', 80);
     * @param host - The host to be added.
     * @param port - The port used to access the host.
     */
    function add(host: string, port: number): void;
    /**
     * Removes a trusted server from the registry
     * @example
     * // Remove a trusted server
     * TrustedServers.remove('my.server.com', 80);
     * @param host - The host to be removed.
     * @param port - The port used to access the host.
     */
    function remove(host: string, port: number): void;
    /**
     * Tests whether a server is trusted or not. The server must have been added with the port if it is included in the url.
     * @example
     * // Add server
     * TrustedServers.add('my.server.com', 81);
     *
     * // Check if server is trusted
     * if (TrustedServers.contains('https://my.server.com:81/path/to/file.png')) {
     *     // my.server.com:81 is trusted
     * }
     * if (TrustedServers.contains('https://my.server.com/path/to/file.png')) {
     *     // my.server.com isn't trusted
     * }
     * @param url - The url to be tested against the trusted list
     * @returns Returns true if url is trusted, false otherwise.
     */
    function contains(url: string): boolean;
    /**
     * Clears the registry
     * @example
     * // Remove a trusted server
     * TrustedServers.clear();
     */
    function clear(): void;
}

export namespace VRTheWorldTerrainProvider {
    /**
     * Initialization options for the VRTheWorldTerrainProvider constructor
     * [ellipsoid] - The ellipsoid.  If not specified, the WGS84 ellipsoid is used.
     * [credit] - A credit for the data source, which is displayed on the canvas.
     */
    type ConstructorOptions = {
        ellipsoid?: Ellipsoid;
        credit?: Credit | string;
    };
}

/**
 * <div class="notice">
 * To construct a VRTheWorldTerrainProvider, call {@link VRTheWorldTerrainProvider.fromUrl}. Do not call the constructor directly.
 * </div>
 *
 * A {@link TerrainProvider} that produces terrain geometry by tessellating height maps
 * retrieved from a {@link http://vr-theworld.com/|VT MÄK VR-TheWorld server}.
 * @example
 * const terrainProvider = await Cesium.VRTheWorldTerrainProvider.fromUrl(
 *   "https://www.vr-theworld.com/vr-theworld/tiles1.0.0/73/"
 * );
 * viewer.terrainProvider = terrainProvider;
 * @param [options] - An object describing initialization options.
 */
export class VRTheWorldTerrainProvider {
    constructor(options?: VRTheWorldTerrainProvider.ConstructorOptions);
    /**
     * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing
     * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
     * are passed an instance of {@link TileProviderError}.
     */
    readonly errorEvent: Event;
    /**
     * Gets the credit to display when this terrain provider is active.  Typically this is used to credit
     * the source of the terrain.
     */
    readonly credit: Credit;
    /**
     * Gets the tiling scheme used by this provider.
     */
    readonly tilingScheme: GeographicTilingScheme;
    /**
     * Gets a value indicating whether or not the provider includes a water mask.  The water mask
     * indicates which areas of the globe are water rather than land, so they can be rendered
     * as a reflective surface with animated waves.
     */
    readonly hasWaterMask: boolean;
    /**
     * Gets a value indicating whether or not the requested tiles include vertex normals.
     */
    readonly hasVertexNormals: boolean;
    /**
     * Gets an object that can be used to determine availability of terrain from this provider, such as
     * at points and in rectangles. This property may be undefined if availability
     * information is not available.
     */
    readonly availability: TileAvailability;
    /**
     * Creates a {@link TerrainProvider} that produces terrain geometry by tessellating height maps
     * retrieved from a {@link http://vr-theworld.com/|VT MÄK VR-TheWorld server}.
     * @example
     * const terrainProvider = await Cesium.VRTheWorldTerrainProvider.fromUrl(
     *   "https://www.vr-theworld.com/vr-theworld/tiles1.0.0/73/"
     * );
     * viewer.terrainProvider = terrainProvider;
     * @param url - The URL of the VR-TheWorld TileMap.
     * @param [options] - An object describing initialization options.
     */
    static fromUrl(url: Resource | string, options?: VRTheWorldTerrainProvider.ConstructorOptions): Promise<VRTheWorldTerrainProvider>;
    /**
     * Requests the geometry for a given tile. The result includes terrain
     * data and indicates that all child tiles are available.
     * @param x - The X coordinate of the tile for which to request geometry.
     * @param y - The Y coordinate of the tile for which to request geometry.
     * @param level - The level of the tile for which to request geometry.
     * @param [request] - The request object. Intended for internal use only.
     * @returns A promise for the requested geometry.  If this method
     *          returns undefined instead of a promise, it is an indication that too many requests are already
     *          pending and the request will be retried later.
     */
    requestTileGeometry(x: number, y: number, level: number, request?: Request): Promise<TerrainData> | undefined;
    /**
     * Gets the maximum geometric error allowed in a tile at a given level.
     * @param level - The tile level for which to get the maximum geometric error.
     * @returns The maximum geometric error.
     */
    getLevelMaximumGeometricError(level: number): number;
    /**
     * Determines whether data for a tile is available to be loaded.
     * @param x - The X coordinate of the tile for which to request geometry.
     * @param y - The Y coordinate of the tile for which to request geometry.
     * @param level - The level of the tile for which to request geometry.
     * @returns Undefined if not supported, otherwise true or false.
     */
    getTileDataAvailable(x: number, y: number, level: number): boolean | undefined;
    /**
     * Makes sure we load availability data for a tile
     * @param x - The X coordinate of the tile for which to request geometry.
     * @param y - The Y coordinate of the tile for which to request geometry.
     * @param level - The level of the tile for which to request geometry.
     * @returns Undefined if nothing need to be loaded or a Promise that resolves when all required tiles are loaded
     */
    loadTileDataAvailability(x: number, y: number, level: number): undefined | Promise<void>;
}

/**
 * A vertex format defines what attributes make up a vertex.  A VertexFormat can be provided
 * to a {@link Geometry} to request that certain properties be computed, e.g., just position,
 * position and normal, etc.
 * @example
 * // Create a vertex format with position and 2D texture coordinate attributes.
 * const format = new Cesium.VertexFormat({
 *   position : true,
 *   st : true
 * });
 * @param [options] - An object with boolean properties corresponding to VertexFormat properties as shown in the code example.
 */
export class VertexFormat {
    constructor(options?: any);
    /**
     * When <code>true</code>, the vertex has a 3D position attribute.
     * <p>
     * 64-bit floating-point (for precision).  3 components per attribute.
     * </p>
     */
    position: boolean;
    /**
     * When <code>true</code>, the vertex has a normal attribute (normalized), which is commonly used for lighting.
     * <p>
     * 32-bit floating-point.  3 components per attribute.
     * </p>
     */
    normal: boolean;
    /**
     * When <code>true</code>, the vertex has a 2D texture coordinate attribute.
     * <p>
     * 32-bit floating-point.  2 components per attribute
     * </p>
     */
    st: boolean;
    /**
     * When <code>true</code>, the vertex has a bitangent attribute (normalized), which is used for tangent-space effects like bump mapping.
     * <p>
     * 32-bit floating-point.  3 components per attribute.
     * </p>
     */
    bitangent: boolean;
    /**
     * When <code>true</code>, the vertex has a tangent attribute (normalized), which is used for tangent-space effects like bump mapping.
     * <p>
     * 32-bit floating-point.  3 components per attribute.
     * </p>
     */
    tangent: boolean;
    /**
     * When <code>true</code>, the vertex has an RGB color attribute.
     * <p>
     * 8-bit unsigned byte.  3 components per attribute.
     * </p>
     */
    color: boolean;
    /**
     * An immutable vertex format with only a position attribute.
     */
    static readonly POSITION_ONLY: VertexFormat;
    /**
     * An immutable vertex format with position and normal attributes.
     * This is compatible with per-instance color appearances like {@link PerInstanceColorAppearance}.
     */
    static readonly POSITION_AND_NORMAL: VertexFormat;
    /**
     * An immutable vertex format with position, normal, and st attributes.
     * This is compatible with {@link MaterialAppearance} when {@link MaterialAppearance#materialSupport}
     * is <code>TEXTURED/code>.
     */
    static readonly POSITION_NORMAL_AND_ST: VertexFormat;
    /**
     * An immutable vertex format with position and st attributes.
     * This is compatible with {@link EllipsoidSurfaceAppearance}.
     */
    static readonly POSITION_AND_ST: VertexFormat;
    /**
     * An immutable vertex format with position and color attributes.
     */
    static readonly POSITION_AND_COLOR: VertexFormat;
    /**
     * An immutable vertex format with well-known attributes: position, normal, st, tangent, and bitangent.
     */
    static readonly ALL: VertexFormat;
    /**
     * An immutable vertex format with position, normal, and st attributes.
     * This is compatible with most appearances and materials; however
     * normal and st attributes are not always required.  When this is
     * known in advance, another <code>VertexFormat</code> should be used.
     */
    static readonly DEFAULT: VertexFormat;
    /**
     * The number of elements used to pack the object into an array.
     */
    static packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: VertexFormat, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new VertexFormat instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: VertexFormat): VertexFormat;
    /**
     * Duplicates a VertexFormat instance.
     * @param vertexFormat - The vertex format to duplicate.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new VertexFormat instance if one was not provided. (Returns undefined if vertexFormat is undefined)
     */
    static clone(vertexFormat: VertexFormat, result?: VertexFormat): VertexFormat;
}

/**
 * Synchronizes a video element with a simulation clock.
 * @param [options] - Object with the following properties:
 * @param [options.clock] - The clock instance used to drive the video.
 * @param [options.element] - The video element to be synchronized.
 * @param [options.epoch = Iso8601.MINIMUM_VALUE] - The simulation time that marks the start of the video.
 * @param [options.tolerance = 1.0] - The maximum amount of time, in seconds, that the clock and video can diverge.
 */
export class VideoSynchronizer {
    constructor(options?: {
        clock?: Clock;
        element?: HTMLVideoElement;
        epoch?: JulianDate;
        tolerance?: number;
    });
    /**
     * Gets or sets the simulation time that marks the start of the video.
     */
    epoch: JulianDate;
    /**
     * Gets or sets the amount of time in seconds the video's currentTime
     * and the clock's currentTime can diverge before a video seek is performed.
     * Lower values make the synchronization more accurate but video
     * performance might suffer.  Higher values provide better performance
     * but at the cost of accuracy.
     */
    tolerance: number;
    /**
     * Gets or sets the clock used to drive the video element.
     */
    clock: Clock;
    /**
     * Gets or sets the video element to synchronize.
     */
    element: HTMLVideoElement;
    /**
     * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.
     */
    destroy(): void;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * @returns True if this object was destroyed; otherwise, false.
     */
    isDestroyed(): boolean;
}

/**
 * This enumerated type is used in determining to what extent an object, the occludee,
 * is visible during horizon culling. An occluder may fully block an occludee, in which case
 * it has no visibility, may partially block an occludee from view, or may not block it at all,
 * leading to full visibility.
 */
export enum Visibility {
    /**
     * Represents that no part of an object is visible.
     */
    NONE = -1,
    /**
     * Represents that part, but not all, of an object is visible
     */
    PARTIAL = 0,
    /**
     * Represents that an object is visible in its entirety.
     */
    FULL = 1
}

/**
 * A description of a wall, which is similar to a KML line string. A wall is defined by a series of points,
 * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.
 * @example
 * // create a wall that spans from ground level to 10000 meters
 * const wall = new Cesium.WallGeometry({
 *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([
 *     19.0, 47.0, 10000.0,
 *     19.0, 48.0, 10000.0,
 *     20.0, 48.0, 10000.0,
 *     20.0, 47.0, 10000.0,
 *     19.0, 47.0, 10000.0
 *   ])
 * });
 * const geometry = Cesium.WallGeometry.createGeometry(wall);
 * @param options - Object with the following properties:
 * @param options.positions - An array of Cartesian objects, which are the points of the wall.
 * @param [options.granularity = Math.RADIANS_PER_DEGREE] - The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
 * @param [options.maximumHeights] - An array parallel to <code>positions</code> that give the maximum height of the
 *        wall at <code>positions</code>. If undefined, the height of each position in used.
 * @param [options.minimumHeights] - An array parallel to <code>positions</code> that give the minimum height of the
 *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.
 * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid for coordinate manipulation
 * @param [options.vertexFormat = VertexFormat.DEFAULT] - The vertex attributes to be computed.
 */
export class WallGeometry {
    constructor(options: {
        positions: Cartesian3[];
        granularity?: number;
        maximumHeights?: number[];
        minimumHeights?: number[];
        ellipsoid?: Ellipsoid;
        vertexFormat?: VertexFormat;
    });
    /**
     * The number of elements used to pack the object into an array.
     */
    packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: WallGeometry, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new WallGeometry instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: WallGeometry): WallGeometry;
    /**
     * A description of a wall, which is similar to a KML line string. A wall is defined by a series of points,
     * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.
     * @example
     * // create a wall that spans from 10000 meters to 20000 meters
     * const wall = Cesium.WallGeometry.fromConstantHeights({
     *   positions : Cesium.Cartesian3.fromDegreesArray([
     *     19.0, 47.0,
     *     19.0, 48.0,
     *     20.0, 48.0,
     *     20.0, 47.0,
     *     19.0, 47.0,
     *   ]),
     *   minimumHeight : 20000.0,
     *   maximumHeight : 10000.0
     * });
     * const geometry = Cesium.WallGeometry.createGeometry(wall);
     * @param options - Object with the following properties:
     * @param options.positions - An array of Cartesian objects, which are the points of the wall.
     * @param [options.maximumHeight] - A constant that defines the maximum height of the
     *        wall at <code>positions</code>. If undefined, the height of each position in used.
     * @param [options.minimumHeight] - A constant that defines the minimum height of the
     *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.
     * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid for coordinate manipulation
     * @param [options.vertexFormat = VertexFormat.DEFAULT] - The vertex attributes to be computed.
     */
    static fromConstantHeights(options: {
        positions: Cartesian3[];
        maximumHeight?: number;
        minimumHeight?: number;
        ellipsoid?: Ellipsoid;
        vertexFormat?: VertexFormat;
    }): WallGeometry;
    /**
     * Computes the geometric representation of a wall, including its vertices, indices, and a bounding sphere.
     * @param wallGeometry - A description of the wall.
     * @returns The computed vertices and indices.
     */
    static createGeometry(wallGeometry: WallGeometry): Geometry | undefined;
}

/**
 * A description of a wall outline. A wall is defined by a series of points,
 * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.
 * @example
 * // create a wall outline that spans from ground level to 10000 meters
 * const wall = new Cesium.WallOutlineGeometry({
 *   positions : Cesium.Cartesian3.fromDegreesArrayHeights([
 *     19.0, 47.0, 10000.0,
 *     19.0, 48.0, 10000.0,
 *     20.0, 48.0, 10000.0,
 *     20.0, 47.0, 10000.0,
 *     19.0, 47.0, 10000.0
 *   ])
 * });
 * const geometry = Cesium.WallOutlineGeometry.createGeometry(wall);
 * @param options - Object with the following properties:
 * @param options.positions - An array of Cartesian objects, which are the points of the wall.
 * @param [options.granularity = Math.RADIANS_PER_DEGREE] - The distance, in radians, between each latitude and longitude. Determines the number of positions in the buffer.
 * @param [options.maximumHeights] - An array parallel to <code>positions</code> that give the maximum height of the
 *        wall at <code>positions</code>. If undefined, the height of each position in used.
 * @param [options.minimumHeights] - An array parallel to <code>positions</code> that give the minimum height of the
 *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.
 * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid for coordinate manipulation
 */
export class WallOutlineGeometry {
    constructor(options: {
        positions: Cartesian3[];
        granularity?: number;
        maximumHeights?: number[];
        minimumHeights?: number[];
        ellipsoid?: Ellipsoid;
    });
    /**
     * The number of elements used to pack the object into an array.
     */
    packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    static pack(value: WallOutlineGeometry, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new WallOutlineGeometry instance if one was not provided.
     */
    static unpack(array: number[], startingIndex?: number, result?: WallOutlineGeometry): WallOutlineGeometry;
    /**
     * A description of a walloutline. A wall is defined by a series of points,
     * which extrude down to the ground. Optionally, they can extrude downwards to a specified height.
     * @example
     * // create a wall that spans from 10000 meters to 20000 meters
     * const wall = Cesium.WallOutlineGeometry.fromConstantHeights({
     *   positions : Cesium.Cartesian3.fromDegreesArray([
     *     19.0, 47.0,
     *     19.0, 48.0,
     *     20.0, 48.0,
     *     20.0, 47.0,
     *     19.0, 47.0,
     *   ]),
     *   minimumHeight : 20000.0,
     *   maximumHeight : 10000.0
     * });
     * const geometry = Cesium.WallOutlineGeometry.createGeometry(wall);
     * @param options - Object with the following properties:
     * @param options.positions - An array of Cartesian objects, which are the points of the wall.
     * @param [options.maximumHeight] - A constant that defines the maximum height of the
     *        wall at <code>positions</code>. If undefined, the height of each position in used.
     * @param [options.minimumHeight] - A constant that defines the minimum height of the
     *        wall at <code>positions</code>. If undefined, the height at each position is 0.0.
     * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid for coordinate manipulation
     */
    static fromConstantHeights(options: {
        positions: Cartesian3[];
        maximumHeight?: number;
        minimumHeight?: number;
        ellipsoid?: Ellipsoid;
    }): WallOutlineGeometry;
    /**
     * Computes the geometric representation of a wall outline, including its vertices, indices, and a bounding sphere.
     * @param wallGeometry - A description of the wall outline.
     * @returns The computed vertices and indices.
     */
    static createGeometry(wallGeometry: WallOutlineGeometry): Geometry | undefined;
}

/**
 * The map projection used by Google Maps, Bing Maps, and most of ArcGIS Online, EPSG:3857.  This
 * projection use longitude and latitude expressed with the WGS84 and transforms them to Mercator using
 * the spherical (rather than ellipsoidal) equations.
 * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid.
 */
export class WebMercatorProjection {
    constructor(ellipsoid?: Ellipsoid);
    /**
     * Gets the {@link Ellipsoid}.
     */
    readonly ellipsoid: Ellipsoid;
    /**
     * Converts a Mercator angle, in the range -PI to PI, to a geodetic latitude
     * in the range -PI/2 to PI/2.
     * @param mercatorAngle - The angle to convert.
     * @returns The geodetic latitude in radians.
     */
    static mercatorAngleToGeodeticLatitude(mercatorAngle: number): number;
    /**
     * Converts a geodetic latitude in radians, in the range -PI/2 to PI/2, to a Mercator
     * angle in the range -PI to PI.
     * @param latitude - The geodetic latitude in radians.
     * @returns The Mercator angle.
     */
    static geodeticLatitudeToMercatorAngle(latitude: number): number;
    /**
     * The maximum latitude (both North and South) supported by a Web Mercator
     * (EPSG:3857) projection.  Technically, the Mercator projection is defined
     * for any latitude up to (but not including) 90 degrees, but it makes sense
     * to cut it off sooner because it grows exponentially with increasing latitude.
     * The logic behind this particular cutoff value, which is the one used by
     * Google Maps, Bing Maps, and Esri, is that it makes the projection
     * square.  That is, the rectangle is equal in the X and Y directions.
     *
     * The constant value is computed by calling:
     *    WebMercatorProjection.mercatorAngleToGeodeticLatitude(Math.PI)
     */
    static MaximumLatitude: number;
    /**
     * Converts geodetic ellipsoid coordinates, in radians, to the equivalent Web Mercator
     * X, Y, Z coordinates expressed in meters and returned in a {@link Cartesian3}.  The height
     * is copied unmodified to the Z coordinate.
     * @param cartographic - The cartographic coordinates in radians.
     * @param [result] - The instance to which to copy the result, or undefined if a
     *        new instance should be created.
     * @returns The equivalent web mercator X, Y, Z coordinates, in meters.
     */
    project(cartographic: Cartographic, result?: Cartesian3): Cartesian3;
    /**
     * Converts Web Mercator X, Y coordinates, expressed in meters, to a {@link Cartographic}
     * containing geodetic ellipsoid coordinates.  The Z coordinate is copied unmodified to the
     * height.
     * @param cartesian - The web mercator Cartesian position to unrproject with height (z) in meters.
     * @param [result] - The instance to which to copy the result, or undefined if a
     *        new instance should be created.
     * @returns The equivalent cartographic coordinates.
     */
    unproject(cartesian: Cartesian3, result?: Cartographic): Cartographic;
}

/**
 * A tiling scheme for geometry referenced to a {@link WebMercatorProjection}, EPSG:3857.  This is
 * the tiling scheme used by Google Maps, Microsoft Bing Maps, and most of ESRI ArcGIS Online.
 * @param [options] - Object with the following properties:
 * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid whose surface is being tiled. Defaults to
 * the WGS84 ellipsoid.
 * @param [options.numberOfLevelZeroTilesX = 1] - The number of tiles in the X direction at level zero of
 *        the tile tree.
 * @param [options.numberOfLevelZeroTilesY = 1] - The number of tiles in the Y direction at level zero of
 *        the tile tree.
 * @param [options.rectangleSouthwestInMeters] - The southwest corner of the rectangle covered by the
 *        tiling scheme, in meters.  If this parameter or rectangleNortheastInMeters is not specified, the entire
 *        globe is covered in the longitude direction and an equal distance is covered in the latitude
 *        direction, resulting in a square projection.
 * @param [options.rectangleNortheastInMeters] - The northeast corner of the rectangle covered by the
 *        tiling scheme, in meters.  If this parameter or rectangleSouthwestInMeters is not specified, the entire
 *        globe is covered in the longitude direction and an equal distance is covered in the latitude
 *        direction, resulting in a square projection.
 */
export class WebMercatorTilingScheme {
    constructor(options?: {
        ellipsoid?: Ellipsoid;
        numberOfLevelZeroTilesX?: number;
        numberOfLevelZeroTilesY?: number;
        rectangleSouthwestInMeters?: Cartesian2;
        rectangleNortheastInMeters?: Cartesian2;
    });
    /**
     * Gets the ellipsoid that is tiled by this tiling scheme.
     */
    ellipsoid: Ellipsoid;
    /**
     * Gets the rectangle, in radians, covered by this tiling scheme.
     */
    rectangle: Rectangle;
    /**
     * Gets the map projection used by this tiling scheme.
     */
    projection: MapProjection;
    /**
     * Gets the total number of tiles in the X direction at a specified level-of-detail.
     * @param level - The level-of-detail.
     * @returns The number of tiles in the X direction at the given level.
     */
    getNumberOfXTilesAtLevel(level: number): number;
    /**
     * Gets the total number of tiles in the Y direction at a specified level-of-detail.
     * @param level - The level-of-detail.
     * @returns The number of tiles in the Y direction at the given level.
     */
    getNumberOfYTilesAtLevel(level: number): number;
    /**
     * Transforms a rectangle specified in geodetic radians to the native coordinate system
     * of this tiling scheme.
     * @param rectangle - The rectangle to transform.
     * @param [result] - The instance to which to copy the result, or undefined if a new instance
     *        should be created.
     * @returns The specified 'result', or a new object containing the native rectangle if 'result'
     *          is undefined.
     */
    rectangleToNativeRectangle(rectangle: Rectangle, result?: Rectangle): Rectangle;
    /**
     * Converts tile x, y coordinates and level to a rectangle expressed in the native coordinates
     * of the tiling scheme.
     * @param x - The integer x coordinate of the tile.
     * @param y - The integer y coordinate of the tile.
     * @param level - The tile level-of-detail.  Zero is the least detailed.
     * @param [result] - The instance to which to copy the result, or undefined if a new instance
     *        should be created.
     * @returns The specified 'result', or a new object containing the rectangle
     *          if 'result' is undefined.
     */
    tileXYToNativeRectangle(x: number, y: number, level: number, result?: any): Rectangle;
    /**
     * Converts tile x, y coordinates and level to a cartographic rectangle in radians.
     * @param x - The integer x coordinate of the tile.
     * @param y - The integer y coordinate of the tile.
     * @param level - The tile level-of-detail.  Zero is the least detailed.
     * @param [result] - The instance to which to copy the result, or undefined if a new instance
     *        should be created.
     * @returns The specified 'result', or a new object containing the rectangle
     *          if 'result' is undefined.
     */
    tileXYToRectangle(x: number, y: number, level: number, result?: any): Rectangle;
    /**
     * Calculates the tile x, y coordinates of the tile containing
     * a given cartographic position.
     * @param position - The position.
     * @param level - The tile level-of-detail.  Zero is the least detailed.
     * @param [result] - The instance to which to copy the result, or undefined if a new instance
     *        should be created.
     * @returns The specified 'result', or a new object containing the tile x, y coordinates
     *          if 'result' is undefined.
     */
    positionToTileXY(position: Cartographic, level: number, result?: Cartesian2): Cartesian2;
}

/**
 * Winding order defines the order of vertices for a triangle to be considered front-facing.
 */
export enum WindingOrder {
    /**
     * Vertices are in clockwise order.
     */
    CLOCKWISE = WebGLConstants.CW,
    /**
     * Vertices are in counter-clockwise order.
     */
    COUNTER_CLOCKWISE = WebGLConstants.CCW
}

/**
 * Computes the barycentric coordinates for a point with respect to a triangle.
 * @example
 * // Returns Cartesian3.UNIT_X
 * const p = new Cesium.Cartesian3(-1.0, 0.0, 0.0);
 * const b = Cesium.barycentricCoordinates(p,
 *   new Cesium.Cartesian3(-1.0, 0.0, 0.0),
 *   new Cesium.Cartesian3( 1.0, 0.0, 0.0),
 *   new Cesium.Cartesian3( 0.0, 1.0, 1.0));
 * @param point - The point to test.
 * @param p0 - The first point of the triangle, corresponding to the barycentric x-axis.
 * @param p1 - The second point of the triangle, corresponding to the barycentric y-axis.
 * @param p2 - The third point of the triangle, corresponding to the barycentric z-axis.
 * @param [result] - The object onto which to store the result.
 * @returns The modified result parameter or a new Cartesian3 instance if one was not provided. If the triangle is degenerate the function will return undefined.
 */
export function barycentricCoordinates(point: Cartesian2 | Cartesian3, p0: Cartesian2 | Cartesian3, p1: Cartesian2 | Cartesian3, p2: Cartesian2 | Cartesian3, result?: Cartesian3): Cartesian3 | undefined;

/**
 * Finds an item in a sorted array.
 * @example
 * // Create a comparator function to search through an array of numbers.
 * function comparator(a, b) {
 *     return a - b;
 * };
 * const numbers = [0, 2, 4, 6, 8];
 * const index = Cesium.binarySearch(numbers, 6, comparator); // 3
 * @param array - The sorted array to search.
 * @param itemToFind - The item to find in the array.
 * @param comparator - The function to use to compare the item to
 *        elements in the array.
 * @returns The index of <code>itemToFind</code> in the array, if it exists.  If <code>itemToFind</code>
 *        does not exist, the return value is a negative number which is the bitwise complement (~)
 *        of the index before which the itemToFind should be inserted in order to maintain the
 *        sorted order of the array.
 */
export function binarySearch(array: any[], itemToFind: any, comparator: binarySearchComparator): number;

/**
 * A function used to compare two items while performing a binary search.
 * @example
 * function compareNumbers(a, b) {
 *     return a - b;
 * }
 * @param a - An item in the array.
 * @param b - The item being searched for.
 */
export type binarySearchComparator = (a: any, b: any) => number;

/**
 * Given a relative URL under the Cesium base URL, returns an absolute URL.
 * @example
 * const viewer = new Cesium.Viewer("cesiumContainer", {
 *   baseLayer: Cesium.ImageryLayer.fromProviderAsync(
 *     Cesium.TileMapServiceImageryProvider.fromUrl(
 *       Cesium.buildModuleUrl("Assets/Textures/NaturalEarthII"),
 *     )),
 *   baseLayerPicker: false,
 * });
 * @param relativeUrl - The relative path.
 * @returns The absolutely URL representation of the provided path.
 */
export function buildModuleUrl(relativeUrl: string): string;

/**
 * Clones an object, returning a new object containing the same properties.
 * @param object - The object to clone.
 * @param [deep = false] - If true, all properties will be deep cloned recursively.
 * @returns The cloned object.
 */
export function clone(object: any, deep?: boolean): any;

/**
 * Merges two objects, copying their properties onto a new combined object. When two objects have the same
 * property, the value of the property on the first object is used.  If either object is undefined,
 * it will be treated as an empty object.
 * @example
 * const object1 = {
 *     propOne : 1,
 *     propTwo : {
 *         value1 : 10
 *     }
 * }
 * const object2 = {
 *     propTwo : 2
 * }
 * const final = Cesium.combine(object1, object2);
 *
 * // final === {
 * //     propOne : 1,
 * //     propTwo : {
 * //         value1 : 10
 * //     }
 * // }
 * @param [object1] - The first object to merge.
 * @param [object2] - The second object to merge.
 * @param [deep = false] - Perform a recursive merge.
 * @returns The combined object containing all properties from both objects.
 */
export function combine(object1?: any, object2?: any, deep?: boolean): any;

/**
 * Creates a Globally unique identifier (GUID) string.  A GUID is 128 bits long, and can guarantee uniqueness across space and time.
 * @example
 * this.guid = Cesium.createGuid();
 */
export function createGuid(): string;

/**
 * Creates a {@link CesiumTerrainProvider} instance for the {@link https://cesium.com/content/#cesium-world-terrain|Cesium World Terrain}.
 * @example
 * // Create Cesium World Terrain with default settings
 * try {
 *   const viewer = new Cesium.Viewer("cesiumContainer", {
 *     terrainProvider: await Cesium.createWorldTerrainAsync();
 *   });
 * } catch (error) {
 *   console.log(error);
 * }
 * @example
 * // Create Cesium World Terrain with water and normals.
 * try {
 *   const viewer1 = new Cesium.Viewer("cesiumContainer", {
 *     terrainProvider: await Cesium.createWorldTerrainAsync({
 *       requestWaterMask: true,
 *       requestVertexNormals: true
 *     });
 *   });
 * } catch (error) {
 *   console.log(error);
 * }
 * @param [options] - Object with the following properties:
 * @param [options.requestVertexNormals = false] - Flag that indicates if the client should request additional lighting information from the server if available.
 * @param [options.requestWaterMask = false] - Flag that indicates if the client should request per tile water masks from the server if available.
 * @returns A promise that resolves to the created CesiumTerrainProvider
 */
export function createWorldTerrainAsync(options?: {
    requestVertexNormals?: boolean;
    requestWaterMask?: boolean;
}): Promise<CesiumTerrainProvider>;

/**
 * Returns the first parameter if not undefined, otherwise the second parameter.
 * Useful for setting a default value for a parameter.
 * @example
 * param = Cesium.defaultValue(param, 'default');
 * @returns Returns the first parameter if not undefined, otherwise the second parameter.
 */
export function defaultValue(a: any, b: any): any;

/**
 * @example
 * if (Cesium.defined(positions)) {
 *      doSomething();
 * } else {
 *      doSomethingElse();
 * }
 * @param value - The object.
 * @returns Returns true if the object is defined, returns false otherwise.
 */
export function defined<Type>(value: Type): value is NonNullable<Type>;

/**
 * Destroys an object.  Each of the object's functions, including functions in its prototype,
 * is replaced with a function that throws a {@link DeveloperError}, except for the object's
 * <code>isDestroyed</code> function, which is set to a function that returns <code>true</code>.
 * The object's properties are removed with <code>delete</code>.
 * <br /><br />
 * This function is used by objects that hold native resources, e.g., WebGL resources, which
 * need to be explicitly released.  Client code calls an object's <code>destroy</code> function,
 * which then releases the native resource and calls <code>destroyObject</code> to put itself
 * in a destroyed state.
 * @example
 * // How a texture would destroy itself.
 * this.destroy = function () {
 *     _gl.deleteTexture(_texture);
 *     return Cesium.destroyObject(this);
 * };
 * @param object - The object to destroy.
 * @param [message] - The message to include in the exception that is thrown if
 *                           a destroyed object's function is called.
 */
export function destroyObject(object: any, message?: string): void;

/**
 * Formats an error object into a String.  If available, uses name, message, and stack
 * properties, otherwise, falls back on toString().
 * @param object - The item to find in the array.
 * @returns A string containing the formatted error.
 */
export function formatError(object: any): string;

/**
 * Given a relative Uri and a base Uri, returns the absolute Uri of the relative Uri.
 * @example
 * //absolute Uri will be "https://test.com/awesome.png";
 * const absoluteUri = Cesium.getAbsoluteUri('awesome.png', 'https://test.com');
 * @param relative - The relative Uri.
 * @param [base] - The base Uri.
 * @returns The absolute Uri of the given relative Uri.
 */
export function getAbsoluteUri(relative: string, base?: string): string;

/**
 * Given a URI, returns the base path of the URI.
 * @example
 * // basePath will be "/Gallery/";
 * const basePath = Cesium.getBaseUri('/Gallery/simple.czml?value=true&example=false');
 *
 * // basePath will be "/Gallery/?value=true&example=false";
 * const basePath = Cesium.getBaseUri('/Gallery/simple.czml?value=true&example=false', true);
 * @param uri - The Uri.
 * @param [includeQuery = false] - Whether or not to include the query string and fragment form the uri
 * @returns The base path of the Uri.
 */
export function getBaseUri(uri: string, includeQuery?: boolean): string;

/**
 * Given a URI, returns the extension of the URI.
 * @example
 * //extension will be "czml";
 * const extension = Cesium.getExtensionFromUri('/Gallery/simple.czml?value=true&example=false');
 * @param uri - The Uri.
 * @returns The extension of the Uri.
 */
export function getExtensionFromUri(uri: string): string;

/**
 * Given a URI, returns the last segment of the URI, removing any path or query information.
 * @example
 * //fileName will be"simple.czml";
 * const fileName = Cesium.getFilenameFromUri('/Gallery/simple.czml?value=true&example=false');
 * @param uri - The Uri.
 * @returns The last segment of the Uri.
 */
export function getFilenameFromUri(uri: string): string;

/**
 * Extract a pixel array from a loaded image.  Draws the image
 * into a canvas so it can read the pixels back.
 * @param image - The image to extract pixels from.
 * @param width - The width of the image. If not defined, then image.width is assigned.
 * @param height - The height of the image. If not defined, then image.height is assigned.
 * @returns The pixels of the image.
 */
export function getImagePixels(image: HTMLImageElement | ImageBitmap, width: number, height: number): ImageData;

/**
 * Gets a timestamp that can be used in measuring the time between events.  Timestamps
 * are expressed in milliseconds, but it is not specified what the milliseconds are
 * measured from.  This function uses performance.now() if it is available, or Date.now()
 * otherwise.
 * @returns The timestamp in milliseconds since some unspecified reference time.
 */
export function getTimestamp(): number;

/**
 * Determines if a given date is a leap year.
 * @example
 * const leapYear = Cesium.isLeapYear(2000); // true
 * @param year - The year to be tested.
 * @returns True if <code>year</code> is a leap year.
 */
export function isLeapYear(year: number): boolean;

/**
 * A stable merge sort.
 * @example
 * // Assume array contains BoundingSpheres in world coordinates.
 * // Sort them in ascending order of distance from the camera.
 * const position = camera.positionWC;
 * Cesium.mergeSort(array, function(a, b, position) {
 *     return Cesium.BoundingSphere.distanceSquaredTo(b, position) - Cesium.BoundingSphere.distanceSquaredTo(a, position);
 * }, position);
 * @param array - The array to sort.
 * @param comparator - The function to use to compare elements in the array.
 * @param [userDefinedObject] - Any item to pass as the third parameter to <code>comparator</code>.
 */
export function mergeSort(array: any[], comparator: mergeSortComparator, userDefinedObject?: any): void;

/**
 * A function used to compare two items while performing a merge sort.
 * @example
 * function compareNumbers(a, b, userDefinedObject) {
 *     return a - b;
 * }
 * @param a - An item in the array.
 * @param b - An item in the array.
 * @param [userDefinedObject] - An object that was passed to {@link mergeSort}.
 */
export type mergeSortComparator = (a: any, b: any, userDefinedObject?: any) => number;

/**
 * Converts an object representing a set of name/value pairs into a query string,
 * with names and values encoded properly for use in a URL.  Values that are arrays
 * will produce multiple values with the same name.
 * @example
 * const str = Cesium.objectToQuery({
 *     key1 : 'some value',
 *     key2 : 'a/b',
 *     key3 : ['x', 'y']
 * });
 * @param obj - The object containing data to encode.
 * @returns An encoded query string.
 */
export function objectToQuery(obj: any): string;

/**
 * Determines if a point is inside a triangle.
 * @example
 * // Returns true
 * const p = new Cesium.Cartesian2(0.25, 0.25);
 * const b = Cesium.pointInsideTriangle(p,
 *   new Cesium.Cartesian2(0.0, 0.0),
 *   new Cesium.Cartesian2(1.0, 0.0),
 *   new Cesium.Cartesian2(0.0, 1.0));
 * @param point - The point to test.
 * @param p0 - The first point of the triangle.
 * @param p1 - The second point of the triangle.
 * @param p2 - The third point of the triangle.
 * @returns <code>true</code> if the point is inside the triangle; otherwise, <code>false</code>.
 */
export function pointInsideTriangle(point: Cartesian2 | Cartesian3, p0: Cartesian2 | Cartesian3, p1: Cartesian2 | Cartesian3, p2: Cartesian2 | Cartesian3): boolean;

/**
 * Parses a query string into an object, where the keys and values of the object are the
 * name/value pairs from the query string, decoded. If a name appears multiple times,
 * the value in the object will be an array of values.
 * @example
 * const obj = Cesium.queryToObject('key1=some%20value&key2=a%2Fb&key3=x&key3=y');
 * // obj will be:
 * // {
 * //   key1 : 'some value',
 * //   key2 : 'a/b',
 * //   key3 : ['x', 'y']
 * // }
 * @param queryString - The query string.
 * @returns An object containing the parameters parsed from the query string.
 */
export function queryToObject(queryString: string): any;

/**
 * Initiates a terrain height query for an array of {@link Cartographic} positions by
 * requesting tiles from a terrain provider, sampling, and interpolating.  The interpolation
 * matches the triangles used to render the terrain at the specified level.  The query
 * happens asynchronously, so this function returns a promise that is resolved when
 * the query completes.  Each point height is modified in place.  If a height can not be
 * determined because no terrain data is available for the specified level at that location,
 * or another error occurs, the height is set to undefined.  As is typical of the
 * {@link Cartographic} type, the supplied height is a height above the reference ellipsoid
 * (such as {@link Ellipsoid.WGS84}) rather than an altitude above mean sea level.  In other
 * words, it will not necessarily be 0.0 if sampled in the ocean. This function needs the
 * terrain level of detail as input, if you need to get the altitude of the terrain as precisely
 * as possible (i.e. with maximum level of detail) use {@link sampleTerrainMostDetailed}.
 * @example
 * // Query the terrain height of two Cartographic positions
 * const terrainProvider = await Cesium.createWorldTerrainAsync();
 * const positions = [
 *     Cesium.Cartographic.fromDegrees(86.925145, 27.988257),
 *     Cesium.Cartographic.fromDegrees(87.0, 28.0)
 * ];
 * const updatedPositions = await Cesium.sampleTerrain(terrainProvider, 11, positions);
 * // positions[0].height and positions[1].height have been updated.
 * // updatedPositions is just a reference to positions.
 *
 * // To handle tile errors, pass true for the rejectOnTileFail parameter.
 * try {
 *    const updatedPositions = await Cesium.sampleTerrain(terrainProvider, 11, positions, true);
 * } catch (error) {
 *   // A tile request error occurred.
 * }
 * @param terrainProvider - The terrain provider from which to query heights.
 * @param level - The terrain level-of-detail from which to query terrain heights.
 * @param positions - The positions to update with terrain heights.
 * @param [rejectOnTileFail = false] - If true, for a failed terrain tile request the promise will be rejected. If false, returned heights will be undefined.
 * @returns A promise that resolves to the provided list of positions when terrain the query has completed.
 */
export function sampleTerrain(terrainProvider: TerrainProvider, level: number, positions: Cartographic[], rejectOnTileFail?: boolean): Promise<Cartographic[]>;

/**
 * Initiates a sampleTerrain() request at the maximum available tile level for a terrain dataset.
 * @example
 * // Query the terrain height of two Cartographic positions
 * const terrainProvider = await Cesium.createWorldTerrainAsync();
 * const positions = [
 *     Cesium.Cartographic.fromDegrees(86.925145, 27.988257),
 *     Cesium.Cartographic.fromDegrees(87.0, 28.0)
 * ];
 * const updatedPositions = await Cesium.sampleTerrainMostDetailed(terrainProvider, positions);
 * // positions[0].height and positions[1].height have been updated.
 * // updatedPositions is just a reference to positions.
 *
 * // To handle tile errors, pass true for the rejectOnTileFail parameter.
 * try {
 *    const updatedPositions = await Cesium.sampleTerrainMostDetailed(terrainProvider, positions, true);
 * } catch (error) {
 *   // A tile request error occurred.
 * }
 * @param terrainProvider - The terrain provider from which to query heights.
 * @param positions - The positions to update with terrain heights.
 * @param [rejectOnTileFail = false] - If true, for a failed terrain tile request the promise will be rejected. If false, returned heights will be undefined.
 * @returns A promise that resolves to the provided list of positions when terrain the query has completed.  This
 *                                     promise will reject if the terrain provider's `availability` property is undefined.
 */
export function sampleTerrainMostDetailed(terrainProvider: TerrainProvider, positions: Cartographic[], rejectOnTileFail?: boolean): Promise<Cartographic[]>;

/**
 * Subdivides an array into a number of smaller, equal sized arrays.
 * @param array - The array to divide.
 * @param numberOfArrays - The number of arrays to divide the provided array into.
 */
export function subdivideArray(array: any[], numberOfArrays: number): void;

/**
 * Writes the given text into a new canvas.  The canvas will be sized to fit the text.
 * If text is blank, returns undefined.
 * @param text - The text to write.
 * @param [options] - Object with the following properties:
 * @param [options.font = '10px sans-serif'] - The CSS font to use.
 * @param [options.textBaseline = 'bottom'] - The baseline of the text.
 * @param [options.fill = true] - Whether to fill the text.
 * @param [options.stroke = false] - Whether to stroke the text.
 * @param [options.fillColor = Color.WHITE] - The fill color.
 * @param [options.strokeColor = Color.BLACK] - The stroke color.
 * @param [options.strokeWidth = 1] - The stroke width.
 * @param [options.backgroundColor = Color.TRANSPARENT] - The background color of the canvas.
 * @param [options.padding = 0] - The pixel size of the padding to add around the text.
 * @returns A new canvas with the given text drawn into it.  The dimensions object
 *                   from measureText will also be added to the returned canvas. If text is
 *                   blank, returns undefined.
 */
export function writeTextToCanvas(text: string, options?: {
    font?: string;
    textBaseline?: string;
    fill?: boolean;
    stroke?: boolean;
    fillColor?: Color;
    strokeColor?: Color;
    strokeWidth?: number;
    backgroundColor?: Color;
    padding?: number;
}): HTMLCanvasElement | undefined;

export namespace BillboardGraphics {
    /**
     * Initialization options for the BillboardGraphics constructor
     * [show = true] - A boolean Property specifying the visibility of the billboard.
     * [image] - A Property specifying the Image, URI, or Canvas to use for the billboard.
     * [scale = 1.0] - A numeric Property specifying the scale to apply to the image size.
     * [pixelOffset = Cartesian2.ZERO] - A {@link Cartesian2} Property specifying the pixel offset.
     * [eyeOffset = Cartesian3.ZERO] - A {@link Cartesian3} Property specifying the eye offset.
     * [horizontalOrigin = HorizontalOrigin.CENTER] - A Property specifying the {@link HorizontalOrigin}.
     * [verticalOrigin = VerticalOrigin.CENTER] - A Property specifying the {@link VerticalOrigin}.
     * [heightReference = HeightReference.NONE] - A Property specifying what the height is relative to.
     * [color = Color.WHITE] - A Property specifying the tint {@link Color} of the image.
     * [rotation = 0] - A numeric Property specifying the rotation about the alignedAxis.
     * [alignedAxis = Cartesian3.ZERO] - A {@link Cartesian3} Property specifying the unit vector axis of rotation.
     * [sizeInMeters] - A boolean Property specifying whether this billboard's size should be measured in meters.
     * [width] - A numeric Property specifying the width of the billboard in pixels, overriding the native size.
     * [height] - A numeric Property specifying the height of the billboard in pixels, overriding the native size.
     * [scaleByDistance] - A {@link NearFarScalar} Property used to scale the point based on distance from the camera.
     * [translucencyByDistance] - A {@link NearFarScalar} Property used to set translucency based on distance from the camera.
     * [pixelOffsetScaleByDistance] - A {@link NearFarScalar} Property used to set pixelOffset based on distance from the camera.
     * [imageSubRegion] - A Property specifying a {@link BoundingRectangle} that defines a sub-region of the image to use for the billboard, rather than the entire image, measured in pixels from the bottom-left.
     * [distanceDisplayCondition] - A Property specifying at what distance from the camera that this billboard will be displayed.
     * [disableDepthTestDistance] - A Property specifying the distance from the camera at which to disable the depth test to.
     */
    type ConstructorOptions = {
        show?: Property | boolean;
        image?: Property | string | HTMLCanvasElement;
        scale?: Property | number;
        pixelOffset?: Property | Cartesian2;
        eyeOffset?: Property | Cartesian3;
        horizontalOrigin?: Property | HorizontalOrigin;
        verticalOrigin?: Property | VerticalOrigin;
        heightReference?: Property | HeightReference;
        color?: Property | Color;
        rotation?: Property | number;
        alignedAxis?: Property | Cartesian3;
        sizeInMeters?: Property | boolean;
        width?: Property | number;
        height?: Property | number;
        scaleByDistance?: Property | NearFarScalar;
        translucencyByDistance?: Property | NearFarScalar;
        pixelOffsetScaleByDistance?: Property | NearFarScalar;
        imageSubRegion?: Property | BoundingRectangle;
        distanceDisplayCondition?: Property | DistanceDisplayCondition;
        disableDepthTestDistance?: Property | number;
    };
}

/**
 * Describes a two dimensional icon located at the position of the containing {@link Entity}.
 * <p>
 * <div align='center'>
 * <img src='Images/Billboard.png' width='400' height='300' /><br />
 * Example billboards
 * </div>
 * </p>
 * @param [options] - Object describing initialization options
 */
export class BillboardGraphics {
    constructor(options?: BillboardGraphics.ConstructorOptions);
    /**
     * Gets the event that is raised whenever a property or sub-property is changed or modified.
     */
    readonly definitionChanged: Event;
    /**
     * Gets or sets the boolean Property specifying the visibility of the billboard.
     */
    show: Property | undefined;
    /**
     * Gets or sets the Property specifying the Image, URI, or Canvas to use for the billboard.
     */
    image: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the uniform scale to apply to the image.
     * A scale greater than <code>1.0</code> enlarges the billboard while a scale less than <code>1.0</code> shrinks it.
     * <p>
     * <div align='center'>
     * <img src='Images/Billboard.setScale.png' width='400' height='300' /><br/>
     * From left to right in the above image, the scales are <code>0.5</code>, <code>1.0</code>, and <code>2.0</code>.
     * </div>
     * </p>
     */
    scale: Property | undefined;
    /**
     * Gets or sets the {@link Cartesian2} Property specifying the billboard's pixel offset in screen space
     * from the origin of this billboard.  This is commonly used to align multiple billboards and labels at
     * the same position, e.g., an image and text.  The screen space origin is the top, left corner of the
     * canvas; <code>x</code> increases from left to right, and <code>y</code> increases from top to bottom.
     * <p>
     * <div align='center'>
     * <table border='0' cellpadding='5'><tr>
     * <td align='center'><code>default</code><br/><img src='Images/Billboard.setPixelOffset.default.png' width='250' height='188' /></td>
     * <td align='center'><code>b.pixeloffset = new Cartesian2(50, 25);</code><br/><img src='Images/Billboard.setPixelOffset.x50y-25.png' width='250' height='188' /></td>
     * </tr></table>
     * The billboard's origin is indicated by the yellow point.
     * </div>
     * </p>
     */
    pixelOffset: Property | undefined;
    /**
     * Gets or sets the {@link Cartesian3} Property specifying the billboard's offset in eye coordinates.
     * Eye coordinates is a left-handed coordinate system, where <code>x</code> points towards the viewer's
     * right, <code>y</code> points up, and <code>z</code> points into the screen.
     * <p>
     * An eye offset is commonly used to arrange multiple billboards or objects at the same position, e.g., to
     * arrange a billboard above its corresponding 3D model.
     * </p>
     * Below, the billboard is positioned at the center of the Earth but an eye offset makes it always
     * appear on top of the Earth regardless of the viewer's or Earth's orientation.
     * <p>
     * <div align='center'>
     * <table border='0' cellpadding='5'><tr>
     * <td align='center'><img src='Images/Billboard.setEyeOffset.one.png' width='250' height='188' /></td>
     * <td align='center'><img src='Images/Billboard.setEyeOffset.two.png' width='250' height='188' /></td>
     * </tr></table>
     * <code>b.eyeOffset = new Cartesian3(0.0, 8000000.0, 0.0);</code>
     * </div>
     * </p>
     */
    eyeOffset: Property | undefined;
    /**
     * Gets or sets the Property specifying the {@link HorizontalOrigin}.
     */
    horizontalOrigin: Property | undefined;
    /**
     * Gets or sets the Property specifying the {@link VerticalOrigin}.
     */
    verticalOrigin: Property | undefined;
    /**
     * Gets or sets the Property specifying the {@link HeightReference}.
     */
    heightReference: Property | undefined;
    /**
     * Gets or sets the Property specifying the {@link Color} that is multiplied with the <code>image</code>.
     * This has two common use cases.  First, the same white texture may be used by many different billboards,
     * each with a different color, to create colored billboards. Second, the color's alpha component can be
     * used to make the billboard translucent as shown below. An alpha of <code>0.0</code> makes the billboard
     * transparent, and <code>1.0</code> makes the billboard opaque.
     * <p>
     * <div align='center'>
     * <table border='0' cellpadding='5'><tr>
     * <td align='center'><code>default</code><br/><img src='Images/Billboard.setColor.Alpha255.png' width='250' height='188' /></td>
     * <td align='center'><code>alpha : 0.5</code><br/><img src='Images/Billboard.setColor.Alpha127.png' width='250' height='188' /></td>
     * </tr></table>
     * </div>
     * </p>
     */
    color: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the rotation of the image
     * counter clockwise from the <code>alignedAxis</code>.
     */
    rotation: Property | undefined;
    /**
     * Gets or sets the {@link Cartesian3} Property specifying the unit vector axis of rotation
     * in the fixed frame. When set to Cartesian3.ZERO the rotation is from the top of the screen.
     */
    alignedAxis: Property | undefined;
    /**
     * Gets or sets the boolean Property specifying if this billboard's size will be measured in meters.
     */
    sizeInMeters: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the width of the billboard in pixels.
     * When undefined, the native width is used.
     */
    width: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the height of the billboard in pixels.
     * When undefined, the native height is used.
     */
    height: Property | undefined;
    /**
     * Gets or sets {@link NearFarScalar} Property specifying the scale of the billboard based on the distance from the camera.
     * A billboard's scale will interpolate between the {@link NearFarScalar#nearValue} and
     * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
     * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
     * Outside of these ranges the billboard's scale remains clamped to the nearest bound.
     */
    scaleByDistance: Property | undefined;
    /**
     * Gets or sets {@link NearFarScalar} Property specifying the translucency of the billboard based on the distance from the camera.
     * A billboard's translucency will interpolate between the {@link NearFarScalar#nearValue} and
     * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
     * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
     * Outside of these ranges the billboard's translucency remains clamped to the nearest bound.
     */
    translucencyByDistance: Property | undefined;
    /**
     * Gets or sets {@link NearFarScalar} Property specifying the pixel offset of the billboard based on the distance from the camera.
     * A billboard's pixel offset will interpolate between the {@link NearFarScalar#nearValue} and
     * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
     * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
     * Outside of these ranges the billboard's pixel offset remains clamped to the nearest bound.
     */
    pixelOffsetScaleByDistance: Property | undefined;
    /**
     * Gets or sets the Property specifying a {@link BoundingRectangle} that defines a
     * sub-region of the <code>image</code> to use for the billboard, rather than the entire image,
     * measured in pixels from the bottom-left.
     */
    imageSubRegion: Property | undefined;
    /**
     * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this billboard will be displayed.
     */
    distanceDisplayCondition: Property | undefined;
    /**
     * Gets or sets the distance from the camera at which to disable the depth test to, for example, prevent clipping against terrain.
     * When set to zero, the depth test is always applied. When set to Number.POSITIVE_INFINITY, the depth test is never applied.
     */
    disableDepthTestDistance: Property | undefined;
    /**
     * Duplicates this instance.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new instance if one was not provided.
     */
    clone(result?: BillboardGraphics): BillboardGraphics;
    /**
     * Assigns each unassigned property on this object to the value
     * of the same property on the provided source object.
     * @param source - The object to be merged into this object.
     */
    merge(source: BillboardGraphics): void;
}

/**
 * A {@link Visualizer} which maps {@link Entity#billboard} to a {@link Billboard}.
 * @param entityCluster - The entity cluster to manage the collection of billboards and optionally cluster with other entities.
 * @param entityCollection - The entityCollection to visualize.
 */
export class BillboardVisualizer {
    constructor(entityCluster: EntityCluster, entityCollection: EntityCollection);
    /**
     * Updates the primitives created by this visualizer to match their
     * Entity counterpart at the given time.
     * @param time - The time to update to.
     * @returns This function always returns true.
     */
    update(time: JulianDate): boolean;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * @returns True if this object was destroyed; otherwise, false.
     */
    isDestroyed(): boolean;
    /**
     * Removes and destroys all primitives created by this instance.
     */
    destroy(): void;
}

/**
 * A {@link GeometryUpdater} for boxes.
 * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
 * @param entity - The entity containing the geometry to be visualized.
 * @param scene - The scene where visualization is taking place.
 */
export class BoxGeometryUpdater {
    constructor(entity: Entity, scene: Scene);
    /**
     * Creates the geometry instance which represents the fill of the geometry.
     * @param time - The time to use when retrieving initial attribute values.
     * @returns The geometry instance representing the filled portion of the geometry.
     */
    createFillGeometryInstance(time: JulianDate): GeometryInstance;
    /**
     * Creates the geometry instance which represents the outline of the geometry.
     * @param time - The time to use when retrieving initial attribute values.
     * @returns The geometry instance representing the outline portion of the geometry.
     */
    createOutlineGeometryInstance(time: JulianDate): GeometryInstance;
}

export namespace BoxGraphics {
    /**
     * Initialization options for the BoxGraphics constructor
     * [show = true] - A boolean Property specifying the visibility of the box.
     * [dimensions] - A {@link Cartesian3} Property specifying the length, width, and height of the box.
     * [heightReference = HeightReference.NONE] - A Property specifying what the height from the entity position is relative to.
     * [fill = true] - A boolean Property specifying whether the box is filled with the provided material.
     * [material = Color.WHITE] - A Property specifying the material used to fill the box.
     * [outline = false] - A boolean Property specifying whether the box is outlined.
     * [outlineColor = Color.BLACK] - A Property specifying the {@link Color} of the outline.
     * [outlineWidth = 1.0] - A numeric Property specifying the width of the outline.
     * [shadows = ShadowMode.DISABLED] - An enum Property specifying whether the box casts or receives shadows from light sources.
     * [distanceDisplayCondition] - A Property specifying at what distance from the camera that this box will be displayed.
     */
    type ConstructorOptions = {
        show?: Property | boolean;
        dimensions?: Property | Cartesian3;
        heightReference?: Property | HeightReference;
        fill?: Property | boolean;
        material?: MaterialProperty | Color;
        outline?: Property | boolean;
        outlineColor?: Property | Color;
        outlineWidth?: Property | number;
        shadows?: Property | ShadowMode;
        distanceDisplayCondition?: Property | DistanceDisplayCondition;
    };
}

/**
 * Describes a box. The center position and orientation are determined by the containing {@link Entity}.
 * @param [options] - Object describing initialization options
 */
export class BoxGraphics {
    constructor(options?: BoxGraphics.ConstructorOptions);
    /**
     * Gets the event that is raised whenever a property or sub-property is changed or modified.
     */
    readonly definitionChanged: Event;
    /**
     * Gets or sets the boolean Property specifying the visibility of the box.
     */
    show: Property | undefined;
    /**
     * Gets or sets {@link Cartesian3} Property property specifying the length, width, and height of the box.
     */
    dimensions: Property | undefined;
    /**
     * Gets or sets the Property specifying the {@link HeightReference}.
     */
    heightReference: Property | undefined;
    /**
     * Gets or sets the boolean Property specifying whether the box is filled with the provided material.
     */
    fill: Property | undefined;
    /**
     * Gets or sets the material used to fill the box.
     */
    material: MaterialProperty | undefined;
    /**
     * Gets or sets the Property specifying whether the box is outlined.
     */
    outline: Property | undefined;
    /**
     * Gets or sets the Property specifying the {@link Color} of the outline.
     */
    outlineColor: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the width of the outline.
     * <p>
     * Note: This property will be ignored on all major browsers on Windows platforms. For details, see (@link https://github.com/CesiumGS/cesium/issues/40}.
     * </p>
     */
    outlineWidth: Property | undefined;
    /**
     * Get or sets the enum Property specifying whether the box
     * casts or receives shadows from light sources.
     */
    shadows: Property | undefined;
    /**
     * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this box will be displayed.
     */
    distanceDisplayCondition: Property | undefined;
    /**
     * Duplicates this instance.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new instance if one was not provided.
     */
    clone(result?: BoxGraphics): BoxGraphics;
    /**
     * Assigns each unassigned property on this object to the value
     * of the same property on the provided source object.
     * @param source - The object to be merged into this object.
     */
    merge(source: BoxGraphics): void;
}

/**
 * A {@link Property} whose value is lazily evaluated by a callback function.
 * @param callback - The function to be called when the property is evaluated.
 * @param isConstant - <code>true</code> when the callback function returns the same value every time, <code>false</code> if the value will change.
 */
export class CallbackProperty {
    constructor(callback: CallbackProperty.Callback, isConstant: boolean);
    /**
     * Gets a value indicating if this property is constant.
     */
    readonly isConstant: boolean;
    /**
     * Gets the event that is raised whenever the definition of this property changes.
     * The definition is changed whenever setCallback is called.
     */
    readonly definitionChanged: Event;
    /**
     * Gets the value of the property.
     * @param time - The time for which to retrieve the value.
     * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
     * @returns The modified result parameter or a new instance if the result parameter was not supplied or is unsupported.
     */
    getValue(time: JulianDate, result?: any): any;
    /**
     * Sets the callback to be used.
     * @param callback - The function to be called when the property is evaluated.
     * @param isConstant - <code>true</code> when the callback function returns the same value every time, <code>false</code> if the value will change.
     */
    setCallback(callback: CallbackProperty.Callback, isConstant: boolean): void;
    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [other] - The other property.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    equals(other?: Property): boolean;
}

export namespace CallbackProperty {
    /**
     * A function that returns the value of the property.
     * @param time - The time for which to retrieve the value.
     * @param [result] - The object to store the value into. If omitted, the function must create and return a new instance.
     */
    type Callback = (time: JulianDate, result?: any) => any;
}

export namespace Cesium3DTilesetGraphics {
    /**
     * Initialization options for the Cesium3DTilesetGraphics constructor
     * [show = true] - A boolean Property specifying the visibility of the tileset.
     * [uri] - A string or Resource Property specifying the URI of the tileset.
     * [maximumScreenSpaceError] - A number or Property specifying the maximum screen space error used to drive level of detail refinement.
     */
    type ConstructorOptions = {
        show?: Property | boolean;
        uri?: Property | string | Resource;
        maximumScreenSpaceError?: Property | number;
    };
}

/**
 * A 3D Tiles tileset represented by an {@link Entity}.
 * The tileset modelMatrix is determined by the containing Entity position and orientation
 * or is left unset if position is undefined.
 * @param [options] - Object describing initialization options
 */
export class Cesium3DTilesetGraphics {
    constructor(options?: Cesium3DTilesetGraphics.ConstructorOptions);
    /**
     * Gets the event that is raised whenever a property or sub-property is changed or modified.
     */
    readonly definitionChanged: Event;
    /**
     * Gets or sets the boolean Property specifying the visibility of the model.
     */
    show: Property | undefined;
    /**
     * Gets or sets the string Property specifying the URI of the glTF asset.
     */
    uri: Property | undefined;
    /**
     * Gets or sets the maximum screen space error used to drive level of detail refinement.
     */
    maximumScreenSpaceError: Property | undefined;
    /**
     * Duplicates this instance.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new instance if one was not provided.
     */
    clone(result?: Cesium3DTilesetGraphics): Cesium3DTilesetGraphics;
    /**
     * Assigns each unassigned property on this object to the value
     * of the same property on the provided source object.
     * @param source - The object to be merged into this object.
     */
    merge(source: Cesium3DTilesetGraphics): void;
}

/**
 * A {@link Visualizer} which maps {@link Entity#tileset} to a {@link Cesium3DTileset}.
 * @param scene - The scene the primitives will be rendered in.
 * @param entityCollection - The entityCollection to visualize.
 */
export class Cesium3DTilesetVisualizer {
    constructor(scene: Scene, entityCollection: EntityCollection);
    /**
     * Updates models created this visualizer to match their
     * Entity counterpart at the given time.
     * @param time - The time to update to.
     * @returns This function always returns true.
     */
    update(time: JulianDate): boolean;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * @returns True if this object was destroyed; otherwise, false.
     */
    isDestroyed(): boolean;
    /**
     * Removes and destroys all primitives created by this instance.
     */
    destroy(): void;
}

/**
 * A {@link MaterialProperty} that maps to checkerboard {@link Material} uniforms.
 * @param [options] - Object with the following properties:
 * @param [options.evenColor = Color.WHITE] - A Property specifying the first {@link Color}.
 * @param [options.oddColor = Color.BLACK] - A Property specifying the second {@link Color}.
 * @param [options.repeat = new Cartesian2(2.0, 2.0)] - A {@link Cartesian2} Property specifying how many times the tiles repeat in each direction.
 */
export class CheckerboardMaterialProperty {
    constructor(options?: {
        evenColor?: Property | Color;
        oddColor?: Property | Color;
        repeat?: Property | Cartesian2;
    });
    /**
     * Gets a value indicating if this property is constant.  A property is considered
     * constant if getValue always returns the same result for the current definition.
     */
    readonly isConstant: boolean;
    /**
     * Gets the event that is raised whenever the definition of this property changes.
     * The definition is considered to have changed if a call to getValue would return
     * a different result for the same time.
     */
    readonly definitionChanged: Event;
    /**
     * Gets or sets the Property specifying the first {@link Color}.
     */
    evenColor: Property | undefined;
    /**
     * Gets or sets the Property specifying the second {@link Color}.
     */
    oddColor: Property | undefined;
    /**
     * Gets or sets the {@link Cartesian2} Property specifying how many times the tiles repeat in each direction.
     */
    repeat: Property | undefined;
    /**
     * Gets the {@link Material} type at the provided time.
     * @param time - The time for which to retrieve the type.
     * @returns The type of material.
     */
    getType(time: JulianDate): string;
    /**
     * Gets the value of the property at the provided time.
     * @param time - The time for which to retrieve the value.
     * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
     * @returns The modified result parameter or a new instance if the result parameter was not supplied.
     */
    getValue(time: JulianDate, result?: any): any;
    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [other] - The other property.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    equals(other?: Property): boolean;
}

/**
 * A {@link MaterialProperty} that maps to solid color {@link Material} uniforms.
 * @param [color = Color.WHITE] - The {@link Color} Property to be used.
 */
export class ColorMaterialProperty {
    constructor(color?: Property | Color);
    /**
     * Gets a value indicating if this property is constant.  A property is considered
     * constant if getValue always returns the same result for the current definition.
     */
    readonly isConstant: boolean;
    /**
     * Gets the event that is raised whenever the definition of this property changes.
     * The definition is considered to have changed if a call to getValue would return
     * a different result for the same time.
     */
    readonly definitionChanged: Event;
    /**
     * Gets or sets the {@link Color} {@link Property}.
     */
    color: Property | undefined;
    /**
     * Gets the {@link Material} type at the provided time.
     * @param time - The time for which to retrieve the type.
     * @returns The type of material.
     */
    getType(time: JulianDate): string;
    /**
     * Gets the value of the property at the provided time.
     * @param time - The time for which to retrieve the value.
     * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
     * @returns The modified result parameter or a new instance if the result parameter was not supplied.
     */
    getValue(time: JulianDate, result?: any): any;
    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [other] - The other property.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    equals(other?: Property): boolean;
}

/**
 * Non-destructively composites multiple {@link EntityCollection} instances into a single collection.
 * If a Entity with the same ID exists in multiple collections, it is non-destructively
 * merged into a single new entity instance.  If an entity has the same property in multiple
 * collections, the property of the Entity in the last collection of the list it
 * belongs to is used.  CompositeEntityCollection can be used almost anywhere that a
 * EntityCollection is used.
 * @param [collections] - The initial list of EntityCollection instances to merge.
 * @param [owner] - The data source (or composite entity collection) which created this collection.
 */
export class CompositeEntityCollection {
    constructor(collections?: EntityCollection[], owner?: DataSource | CompositeEntityCollection);
    /**
     * Gets the event that is fired when entities are added or removed from the collection.
     * The generated event is a {@link EntityCollection.collectionChangedEventCallback}.
     */
    readonly collectionChanged: Event;
    /**
     * Gets a globally unique identifier for this collection.
     */
    readonly id: string;
    /**
     * Gets the array of Entity instances in the collection.
     * This array should not be modified directly.
     */
    readonly values: Entity[];
    /**
     * Gets the owner of this composite entity collection, ie. the data source or composite entity collection which created it.
     */
    readonly owner: DataSource | CompositeEntityCollection;
    /**
     * Adds a collection to the composite.
     * @param collection - the collection to add.
     * @param [index] - the index to add the collection at.  If omitted, the collection will
     *                         added on top of all existing collections.
     */
    addCollection(collection: EntityCollection, index?: number): void;
    /**
     * Removes a collection from this composite, if present.
     * @param collection - The collection to remove.
     * @returns true if the collection was in the composite and was removed,
     *                    false if the collection was not in the composite.
     */
    removeCollection(collection: EntityCollection): boolean;
    /**
     * Removes all collections from this composite.
     */
    removeAllCollections(): void;
    /**
     * Checks to see if the composite contains a given collection.
     * @param collection - the collection to check for.
     * @returns true if the composite contains the collection, false otherwise.
     */
    containsCollection(collection: EntityCollection): boolean;
    /**
     * Returns true if the provided entity is in this collection, false otherwise.
     * @param entity - The entity.
     * @returns true if the provided entity is in this collection, false otherwise.
     */
    contains(entity: Entity): boolean;
    /**
     * Determines the index of a given collection in the composite.
     * @param collection - The collection to find the index of.
     * @returns The index of the collection in the composite, or -1 if the collection does not exist in the composite.
     */
    indexOfCollection(collection: EntityCollection): number;
    /**
     * Gets a collection by index from the composite.
     * @param index - the index to retrieve.
     */
    getCollection(index: number): void;
    /**
     * Gets the number of collections in this composite.
     */
    getCollectionsLength(): void;
    /**
     * Raises a collection up one position in the composite.
     * @param collection - the collection to move.
     */
    raiseCollection(collection: EntityCollection): void;
    /**
     * Lowers a collection down one position in the composite.
     * @param collection - the collection to move.
     */
    lowerCollection(collection: EntityCollection): void;
    /**
     * Raises a collection to the top of the composite.
     * @param collection - the collection to move.
     */
    raiseCollectionToTop(collection: EntityCollection): void;
    /**
     * Lowers a collection to the bottom of the composite.
     * @param collection - the collection to move.
     */
    lowerCollectionToBottom(collection: EntityCollection): void;
    /**
     * Prevents {@link EntityCollection#collectionChanged} events from being raised
     * until a corresponding call is made to {@link EntityCollection#resumeEvents}, at which
     * point a single event will be raised that covers all suspended operations.
     * This allows for many items to be added and removed efficiently.
     * While events are suspended, recompositing of the collections will
     * also be suspended, as this can be a costly operation.
     * This function can be safely called multiple times as long as there
     * are corresponding calls to {@link EntityCollection#resumeEvents}.
     */
    suspendEvents(): void;
    /**
     * Resumes raising {@link EntityCollection#collectionChanged} events immediately
     * when an item is added or removed.  Any modifications made while while events were suspended
     * will be triggered as a single event when this function is called.  This function also ensures
     * the collection is recomposited if events are also resumed.
     * This function is reference counted and can safely be called multiple times as long as there
     * are corresponding calls to {@link EntityCollection#resumeEvents}.
     */
    resumeEvents(): void;
    /**
     * Computes the maximum availability of the entities in the collection.
     * If the collection contains a mix of infinitely available data and non-infinite data,
     * It will return the interval pertaining to the non-infinite data only.  If all
     * data is infinite, an infinite interval will be returned.
     * @returns The availability of entities in the collection.
     */
    computeAvailability(): TimeInterval;
    /**
     * Gets an entity with the specified id.
     * @param id - The id of the entity to retrieve.
     * @returns The entity with the provided id or undefined if the id did not exist in the collection.
     */
    getById(id: string): Entity | undefined;
}

/**
 * A {@link CompositeProperty} which is also a {@link MaterialProperty}.
 */
export class CompositeMaterialProperty {
    constructor();
    /**
     * Gets a value indicating if this property is constant.  A property is considered
     * constant if getValue always returns the same result for the current definition.
     */
    readonly isConstant: boolean;
    /**
     * Gets the event that is raised whenever the definition of this property changes.
     * The definition is changed whenever setValue is called with data different
     * than the current value.
     */
    readonly definitionChanged: Event;
    /**
     * Gets the interval collection.
     */
    intervals: TimeIntervalCollection;
    /**
     * Gets the {@link Material} type at the provided time.
     * @param time - The time for which to retrieve the type.
     * @returns The type of material.
     */
    getType(time: JulianDate): string;
    /**
     * Gets the value of the property at the provided time.
     * @param time - The time for which to retrieve the value.
     * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
     * @returns The modified result parameter or a new instance if the result parameter was not supplied.
     */
    getValue(time: JulianDate, result?: any): any;
    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [other] - The other property.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    equals(other?: Property): boolean;
}

/**
 * A {@link CompositeProperty} which is also a {@link PositionProperty}.
 * @param [referenceFrame = ReferenceFrame.FIXED] - The reference frame in which the position is defined.
 */
export class CompositePositionProperty {
    constructor(referenceFrame?: ReferenceFrame);
    /**
     * Gets a value indicating if this property is constant.  A property is considered
     * constant if getValue always returns the same result for the current definition.
     */
    readonly isConstant: boolean;
    /**
     * Gets the event that is raised whenever the definition of this property changes.
     * The definition is changed whenever setValue is called with data different
     * than the current value.
     */
    readonly definitionChanged: Event;
    /**
     * Gets the interval collection.
     */
    intervals: TimeIntervalCollection;
    /**
     * Gets or sets the reference frame which this position presents itself as.
     * Each PositionProperty making up this object has it's own reference frame,
     * so this property merely exposes a "preferred" reference frame for clients
     * to use.
     */
    referenceFrame: ReferenceFrame;
    /**
     * Gets the value of the property at the provided time in the fixed frame.
     * @param time - The time for which to retrieve the value.
     * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
     * @returns The modified result parameter or a new instance if the result parameter was not supplied.
     */
    getValue(time: JulianDate, result?: Cartesian3): Cartesian3 | undefined;
    /**
     * Gets the value of the property at the provided time and in the provided reference frame.
     * @param time - The time for which to retrieve the value.
     * @param referenceFrame - The desired referenceFrame of the result.
     * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
     * @returns The modified result parameter or a new instance if the result parameter was not supplied.
     */
    getValueInReferenceFrame(time: JulianDate, referenceFrame: ReferenceFrame, result?: Cartesian3): Cartesian3 | undefined;
    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [other] - The other property.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    equals(other?: Property): boolean;
}

/**
 * A {@link Property} which is defined by a {@link TimeIntervalCollection}, where the
 * data property of each {@link TimeInterval} is another Property instance which is
 * evaluated at the provided time.
 * @example
 * const constantProperty = ...;
 * const sampledProperty = ...;
 *
 * //Create a composite property from two previously defined properties
 * //where the property is valid on August 1st, 2012 and uses a constant
 * //property for the first half of the day and a sampled property for the
 * //remaining half.
 * const composite = new Cesium.CompositeProperty();
 * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({
 *     iso8601 : '2012-08-01T00:00:00.00Z/2012-08-01T12:00:00.00Z',
 *     data : constantProperty
 * }));
 * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({
 *     iso8601 : '2012-08-01T12:00:00.00Z/2012-08-02T00:00:00.00Z',
 *     isStartIncluded : false,
 *     isStopIncluded : false,
 *     data : sampledProperty
 * }));
 */
export class CompositeProperty {
    constructor();
    /**
     * Gets a value indicating if this property is constant.  A property is considered
     * constant if getValue always returns the same result for the current definition.
     */
    readonly isConstant: boolean;
    /**
     * Gets the event that is raised whenever the definition of this property changes.
     * The definition is changed whenever setValue is called with data different
     * than the current value.
     */
    readonly definitionChanged: Event;
    /**
     * Gets the interval collection.
     */
    intervals: TimeIntervalCollection;
    /**
     * Gets the value of the property at the provided time.
     * @param time - The time for which to retrieve the value.
     * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
     * @returns The modified result parameter or a new instance if the result parameter was not supplied.
     */
    getValue(time: JulianDate, result?: any): any;
    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [other] - The other property.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    equals(other?: Property): boolean;
}

/**
 * A {@link PositionProperty} whose value does not change in respect to the
 * {@link ReferenceFrame} in which is it defined.
 * @param [value] - The property value.
 * @param [referenceFrame = ReferenceFrame.FIXED] - The reference frame in which the position is defined.
 */
export class ConstantPositionProperty {
    constructor(value?: Cartesian3, referenceFrame?: ReferenceFrame);
    /**
     * Gets a value indicating if this property is constant.  A property is considered
     * constant if getValue always returns the same result for the current definition.
     */
    readonly isConstant: boolean;
    /**
     * Gets the event that is raised whenever the definition of this property changes.
     * The definition is considered to have changed if a call to getValue would return
     * a different result for the same time.
     */
    readonly definitionChanged: Event;
    /**
     * Gets the reference frame in which the position is defined.
     */
    referenceFrame: ReferenceFrame;
    /**
     * Gets the value of the property at the provided time in the fixed frame.
     * @param time - The time for which to retrieve the value.
     * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
     * @returns The modified result parameter or a new instance if the result parameter was not supplied.
     */
    getValue(time: JulianDate, result?: any): any;
    /**
     * Sets the value of the property.
     * @param value - The property value.
     * @param [referenceFrame = this.referenceFrame] - The reference frame in which the position is defined.
     */
    setValue(value: Cartesian3, referenceFrame?: ReferenceFrame): void;
    /**
     * Gets the value of the property at the provided time and in the provided reference frame.
     * @param time - The time for which to retrieve the value.
     * @param referenceFrame - The desired referenceFrame of the result.
     * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
     * @returns The modified result parameter or a new instance if the result parameter was not supplied.
     */
    getValueInReferenceFrame(time: JulianDate, referenceFrame: ReferenceFrame, result?: Cartesian3): Cartesian3;
    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [other] - The other property.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    equals(other?: Property): boolean;
}

/**
 * A {@link Property} whose value does not change with respect to simulation time.
 * @param [value] - The property value.
 */
export class ConstantProperty {
    constructor(value?: any);
    /**
     * Gets a value indicating if this property is constant.
     * This property always returns <code>true</code>.
     */
    readonly isConstant: boolean;
    /**
     * Gets the event that is raised whenever the definition of this property changes.
     * The definition is changed whenever setValue is called with data different
     * than the current value.
     */
    readonly definitionChanged: Event;
    /**
     * Gets the value of the property.
     * @param [time] - The time for which to retrieve the value.  This parameter is unused since the value does not change with respect to time.
     * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
     * @returns The modified result parameter or a new instance if the result parameter was not supplied.
     */
    getValue(time?: JulianDate, result?: any): any;
    /**
     * Sets the value of the property.
     * @param value - The property value.
     */
    setValue(value: any): void;
    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [other] - The other property.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    equals(other?: Property): boolean;
    /**
     * Gets this property's value.
     * @returns This property's value.
     */
    valueOf(): any;
    /**
     * Creates a string representing this property's value.
     * @returns A string representing the property's value.
     */
    toString(): string;
}

/**
 * A {@link GeometryUpdater} for corridors.
 * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
 * @param entity - The entity containing the geometry to be visualized.
 * @param scene - The scene where visualization is taking place.
 */
export class CorridorGeometryUpdater {
    constructor(entity: Entity, scene: Scene);
    /**
     * Creates the geometry instance which represents the fill of the geometry.
     * @param time - The time to use when retrieving initial attribute values.
     * @returns The geometry instance representing the filled portion of the geometry.
     */
    createFillGeometryInstance(time: JulianDate): GeometryInstance;
    /**
     * Creates the geometry instance which represents the outline of the geometry.
     * @param time - The time to use when retrieving initial attribute values.
     * @returns The geometry instance representing the outline portion of the geometry.
     */
    createOutlineGeometryInstance(time: JulianDate): GeometryInstance;
}

export namespace CorridorGraphics {
    /**
     * Initialization options for the CorridorGraphics constructor
     * [show = true] - A boolean Property specifying the visibility of the corridor.
     * [positions] - A Property specifying the array of {@link Cartesian3} positions that define the centerline of the corridor.
     * [width] - A numeric Property specifying the distance between the edges of the corridor.
     * [height = 0] - A numeric Property specifying the altitude of the corridor relative to the ellipsoid surface.
     * [heightReference = HeightReference.NONE] - A Property specifying what the height is relative to.
     * [extrudedHeight] - A numeric Property specifying the altitude of the corridor's extruded face relative to the ellipsoid surface.
     * [extrudedHeightReference = HeightReference.NONE] - A Property specifying what the extrudedHeight is relative to.
     * [cornerType = CornerType.ROUNDED] - A {@link CornerType} Property specifying the style of the corners.
     * [granularity = Cesium.Math.RADIANS_PER_DEGREE] - A numeric Property specifying the distance between each latitude and longitude.
     * [fill = true] - A boolean Property specifying whether the corridor is filled with the provided material.
     * [material = Color.WHITE] - A Property specifying the material used to fill the corridor.
     * [outline = false] - A boolean Property specifying whether the corridor is outlined.
     * [outlineColor = Color.BLACK] - A Property specifying the {@link Color} of the outline.
     * [outlineWidth = 1.0] - A numeric Property specifying the width of the outline.
     * [shadows = ShadowMode.DISABLED] - An enum Property specifying whether the corridor casts or receives shadows from light sources.
     * [distanceDisplayCondition] - A Property specifying at what distance from the camera that this corridor will be displayed.
     * [classificationType = ClassificationType.BOTH] - An enum Property specifying whether this corridor will classify terrain, 3D Tiles, or both when on the ground.
     * [zIndex] - A Property specifying the zIndex of the corridor, used for ordering.  Only has an effect if height and extrudedHeight are undefined, and if the corridor is static.
     */
    type ConstructorOptions = {
        show?: Property | boolean;
        positions?: Property | Cartesian3[];
        width?: Property | number;
        height?: Property | number;
        heightReference?: Property | HeightReference;
        extrudedHeight?: Property | number;
        extrudedHeightReference?: Property | HeightReference;
        cornerType?: Property | CornerType;
        granularity?: Property | number;
        fill?: Property | boolean;
        material?: MaterialProperty | Color;
        outline?: Property | boolean;
        outlineColor?: Property | Color;
        outlineWidth?: Property | number;
        shadows?: Property | ShadowMode;
        distanceDisplayCondition?: Property | DistanceDisplayCondition;
        classificationType?: Property | ClassificationType;
        zIndex?: ConstantProperty | number;
    };
}

/**
 * Describes a corridor, which is a shape defined by a centerline and width that
 * conforms to the curvature of the globe. It can be placed on the surface or at altitude
 * and can optionally be extruded into a volume.
 * @param [options] - Object describing initialization options
 */
export class CorridorGraphics {
    constructor(options?: CorridorGraphics.ConstructorOptions);
    /**
     * Gets the event that is raised whenever a property or sub-property is changed or modified.
     */
    readonly definitionChanged: Event;
    /**
     * Gets or sets the boolean Property specifying the visibility of the corridor.
     */
    show: Property | undefined;
    /**
     * Gets or sets a Property specifying the array of {@link Cartesian3} positions that define the centerline of the corridor.
     */
    positions: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the width of the outline.
     */
    width: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the altitude of the corridor.
     */
    height: Property | undefined;
    /**
     * Gets or sets the Property specifying the {@link HeightReference}.
     */
    heightReference: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the altitude of the corridor extrusion.
     * Setting this property creates a corridor shaped volume starting at height and ending
     * at this altitude.
     */
    extrudedHeight: Property | undefined;
    /**
     * Gets or sets the Property specifying the extruded {@link HeightReference}.
     */
    extrudedHeightReference: Property | undefined;
    /**
     * Gets or sets the {@link CornerType} Property specifying how corners are styled.
     */
    cornerType: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the sampling distance between each latitude and longitude point.
     */
    granularity: Property | undefined;
    /**
     * Gets or sets the boolean Property specifying whether the corridor is filled with the provided material.
     */
    fill: Property | undefined;
    /**
     * Gets or sets the Property specifying the material used to fill the corridor.
     */
    material: MaterialProperty | undefined;
    /**
     * Gets or sets the Property specifying whether the corridor is outlined.
     */
    outline: Property | undefined;
    /**
     * Gets or sets the Property specifying the {@link Color} of the outline.
     */
    outlineColor: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the width of the outline.
     * <p>
     * Note: This property will be ignored on all major browsers on Windows platforms. For details, see (@link https://github.com/CesiumGS/cesium/issues/40}.
     * </p>
     */
    outlineWidth: Property | undefined;
    /**
     * Get or sets the enum Property specifying whether the corridor
     * casts or receives shadows from light sources.
     */
    shadows: Property | undefined;
    /**
     * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this corridor will be displayed.
     */
    distanceDisplayCondition: Property | undefined;
    /**
     * Gets or sets the {@link ClassificationType} Property specifying whether this corridor will classify terrain, 3D Tiles, or both when on the ground.
     */
    classificationType: Property | undefined;
    /**
     * Gets or sets the zIndex Property specifying the ordering of the corridor.  Only has an effect if the coridor is static and neither height or exturdedHeight are specified.
     */
    zIndex: ConstantProperty | undefined;
    /**
     * Duplicates this instance.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new instance if one was not provided.
     */
    clone(result?: CorridorGraphics): CorridorGraphics;
    /**
     * Assigns each unassigned property on this object to the value
     * of the same property on the provided source object.
     * @param source - The object to be merged into this object.
     */
    merge(source: CorridorGraphics): void;
}

/**
 * A {@link DataSource} implementation which can be used to manually manage a group of entities.
 * @example
 * const dataSource = new Cesium.CustomDataSource('myData');
 *
 * const entity = dataSource.entities.add({
 *    position : Cesium.Cartesian3.fromDegrees(1, 2, 0),
 *    billboard : {
 *        image : 'image.png'
 *    }
 * });
 *
 * viewer.dataSources.add(dataSource);
 * @param [name] - A human-readable name for this instance.
 */
export class CustomDataSource {
    constructor(name?: string);
    /**
     * Gets or sets a human-readable name for this instance.
     */
    name: string;
    /**
     * Gets or sets the clock for this instance.
     */
    clock: DataSourceClock;
    /**
     * Gets the collection of {@link Entity} instances.
     */
    entities: EntityCollection;
    /**
     * Gets or sets whether the data source is currently loading data.
     */
    isLoading: boolean;
    /**
     * Gets an event that will be raised when the underlying data changes.
     */
    changedEvent: Event;
    /**
     * Gets an event that will be raised if an error is encountered during processing.
     */
    errorEvent: Event;
    /**
     * Gets an event that will be raised when the data source either starts or stops loading.
     */
    loadingEvent: Event;
    /**
     * Gets whether or not this data source should be displayed.
     */
    show: boolean;
    /**
     * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.
     */
    clustering: EntityCluster;
    /**
     * Updates the data source to the provided time.  This function is optional and
     * is not required to be implemented.  It is provided for data sources which
     * retrieve data based on the current animation time or scene state.
     * If implemented, update will be called by {@link DataSourceDisplay} once a frame.
     * @param time - The simulation time.
     * @returns True if this data source is ready to be displayed at the provided time, false otherwise.
     */
    update(time: JulianDate): boolean;
}

/**
 * A {@link GeometryUpdater} for cylinders.
 * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
 * @param entity - The entity containing the geometry to be visualized.
 * @param scene - The scene where visualization is taking place.
 */
export class CylinderGeometryUpdater {
    constructor(entity: Entity, scene: Scene);
    /**
     * Creates the geometry instance which represents the fill of the geometry.
     * @param time - The time to use when retrieving initial attribute values.
     * @returns The geometry instance representing the filled portion of the geometry.
     */
    createFillGeometryInstance(time: JulianDate): GeometryInstance;
    /**
     * Creates the geometry instance which represents the outline of the geometry.
     * @param time - The time to use when retrieving initial attribute values.
     * @returns The geometry instance representing the outline portion of the geometry.
     */
    createOutlineGeometryInstance(time: JulianDate): GeometryInstance;
}

export namespace CylinderGraphics {
    /**
     * Initialization options for the CylinderGraphics constructor
     * [show = true] - A boolean Property specifying the visibility of the cylinder.
     * [length] - A numeric Property specifying the length of the cylinder.
     * [topRadius] - A numeric Property specifying the radius of the top of the cylinder.
     * [bottomRadius] - A numeric Property specifying the radius of the bottom of the cylinder.
     * [heightReference = HeightReference.NONE] - A Property specifying what the height from the entity position is relative to.
     * [fill = true] - A boolean Property specifying whether the cylinder is filled with the provided material.
     * [material = Color.WHITE] - A Property specifying the material used to fill the cylinder.
     * [outline = false] - A boolean Property specifying whether the cylinder is outlined.
     * [outlineColor = Color.BLACK] - A Property specifying the {@link Color} of the outline.
     * [outlineWidth = 1.0] - A numeric Property specifying the width of the outline.
     * [numberOfVerticalLines = 16] - A numeric Property specifying the number of vertical lines to draw along the perimeter for the outline.
     * [slices = 128] - The number of edges around the perimeter of the cylinder.
     * [shadows = ShadowMode.DISABLED] - An enum Property specifying whether the cylinder casts or receives shadows from light sources.
     * [distanceDisplayCondition] - A Property specifying at what distance from the camera that this cylinder will be displayed.
     */
    type ConstructorOptions = {
        show?: Property | boolean;
        length?: Property | number;
        topRadius?: Property | number;
        bottomRadius?: Property | number;
        heightReference?: Property | HeightReference;
        fill?: Property | boolean;
        material?: MaterialProperty | Color;
        outline?: Property | boolean;
        outlineColor?: Property | Color;
        outlineWidth?: Property | number;
        numberOfVerticalLines?: Property | number;
        slices?: Property | number;
        shadows?: Property | ShadowMode;
        distanceDisplayCondition?: Property | DistanceDisplayCondition;
    };
}

/**
 * Describes a cylinder, truncated cone, or cone defined by a length, top radius, and bottom radius.
 * The center position and orientation are determined by the containing {@link Entity}.
 * @param [options] - Object describing initialization options
 */
export class CylinderGraphics {
    constructor(options?: CylinderGraphics.ConstructorOptions);
    /**
     * Gets the event that is raised whenever a property or sub-property is changed or modified.
     */
    readonly definitionChanged: Event;
    /**
     * Gets or sets the boolean Property specifying the visibility of the cylinder.
     */
    show: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the length of the cylinder.
     */
    length: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the radius of the top of the cylinder.
     */
    topRadius: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the radius of the bottom of the cylinder.
     */
    bottomRadius: Property | undefined;
    /**
     * Gets or sets the Property specifying the {@link HeightReference}.
     */
    heightReference: Property | undefined;
    /**
     * Gets or sets the boolean Property specifying whether the cylinder is filled with the provided material.
     */
    fill: Property | undefined;
    /**
     * Gets or sets the Property specifying the material used to fill the cylinder.
     */
    material: MaterialProperty | undefined;
    /**
     * Gets or sets the boolean Property specifying whether the cylinder is outlined.
     */
    outline: Property | undefined;
    /**
     * Gets or sets the Property specifying the {@link Color} of the outline.
     */
    outlineColor: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the width of the outline.
     * <p>
     * Note: This property will be ignored on all major browsers on Windows platforms. For details, see (@link https://github.com/CesiumGS/cesium/issues/40}.
     * </p>
     */
    outlineWidth: Property | undefined;
    /**
     * Gets or sets the Property specifying the number of vertical lines to draw along the perimeter for the outline.
     */
    numberOfVerticalLines: Property | undefined;
    /**
     * Gets or sets the Property specifying the number of edges around the perimeter of the cylinder.
     */
    slices: Property | undefined;
    /**
     * Get or sets the enum Property specifying whether the cylinder
     * casts or receives shadows from light sources.
     */
    shadows: Property | undefined;
    /**
     * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this cylinder will be displayed.
     */
    distanceDisplayCondition: Property | undefined;
    /**
     * Duplicates this instance.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new instance if one was not provided.
     */
    clone(result?: CylinderGraphics): CylinderGraphics;
    /**
     * Assigns each unassigned property on this object to the value
     * of the same property on the provided source object.
     * @param source - The object to be merged into this object.
     */
    merge(source: CylinderGraphics): void;
}

export namespace CzmlDataSource {
    /**
     * Initialization options for the <code>load</code> method.
     * [sourceUri] - Overrides the url to use for resolving relative links.
     * [credit] - A credit for the data source, which is displayed on the canvas.
     */
    type LoadOptions = {
        sourceUri?: Resource | string;
        credit?: Credit | string;
    };
    type UpdaterFunction = (entity: Entity, packet: any, entityCollection: EntityCollection, sourceUri: string) => void;
}

/**
 * A {@link DataSource} which processes {@link https://github.com/AnalyticalGraphicsInc/czml-writer/wiki/CZML-Guide|CZML}.
 * @param [name] - An optional name for the data source.  This value will be overwritten if a loaded document contains a name.
 */
export class CzmlDataSource {
    constructor(name?: string);
    /**
     * Creates a Promise to a new instance loaded with the provided CZML data.
     * @param czml - A url or CZML object to be processed.
     * @param [options] - An object specifying configuration options
     * @returns A promise that resolves to the new instance once the data is processed.
     */
    static load(czml: Resource | string | any, options?: CzmlDataSource.LoadOptions): Promise<CzmlDataSource>;
    /**
     * Gets a human-readable name for this instance.
     */
    name: string;
    /**
     * Gets the clock settings defined by the loaded CZML.  If no clock is explicitly
     * defined in the CZML, the combined availability of all objects is returned.  If
     * only static data exists, this value is undefined.
     */
    clock: DataSourceClock;
    /**
     * Gets the collection of {@link Entity} instances.
     */
    entities: EntityCollection;
    /**
     * Gets a value indicating if the data source is currently loading data.
     */
    isLoading: boolean;
    /**
     * Gets an event that will be raised when the underlying data changes.
     */
    changedEvent: Event;
    /**
     * Gets an event that will be raised if an error is encountered during processing.
     */
    errorEvent: Event;
    /**
     * Gets an event that will be raised when the data source either starts or stops loading.
     */
    loadingEvent: Event;
    /**
     * Gets whether or not this data source should be displayed.
     */
    show: boolean;
    /**
     * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.
     */
    clustering: EntityCluster;
    /**
     * Gets the credit that will be displayed for the data source
     */
    credit: Credit;
    /**
     * Gets the array of CZML processing functions.
     */
    static updaters: CzmlDataSource.UpdaterFunction[];
    /**
     * Processes the provided url or CZML object without clearing any existing data.
     * @param czml - A url or CZML object to be processed.
     * @param [options] - An object specifying configuration options
     * @returns A promise that resolves to this instances once the data is processed.
     */
    process(czml: Resource | string | any, options?: CzmlDataSource.LoadOptions): Promise<CzmlDataSource>;
    /**
     * Loads the provided url or CZML object, replacing any existing data.
     * @param czml - A url or CZML object to be processed.
     * @param [options] - An object specifying configuration options
     * @returns A promise that resolves to this instances once the data is processed.
     */
    load(czml: Resource | string | any, options?: CzmlDataSource.LoadOptions): Promise<CzmlDataSource>;
    /**
     * Updates the data source to the provided time.  This function is optional and
     * is not required to be implemented.  It is provided for data sources which
     * retrieve data based on the current animation time or scene state.
     * If implemented, update will be called by {@link DataSourceDisplay} once a frame.
     * @param time - The simulation time.
     * @returns True if this data source is ready to be displayed at the provided time, false otherwise.
     */
    update(time: JulianDate): boolean;
    /**
     * A helper function used by custom CZML updater functions
     * which creates or updates a {@link Property} from a CZML packet.
     * @param type - The constructor function for the property being processed.
     * @param object - The object on which the property will be added or updated.
     * @param propertyName - The name of the property on the object.
     * @param packetData - The CZML packet being processed.
     * @param interval - A constraining interval for which the data is valid.
     * @param sourceUri - The originating uri of the data being processed.
     * @param entityCollection - The collection being processsed.
     */
    static processPacketData(type: (...params: any[]) => any, object: any, propertyName: string, packetData: any, interval: TimeInterval, sourceUri: string, entityCollection: EntityCollection): void;
    /**
     * A helper function used by custom CZML updater functions
     * which creates or updates a {@link PositionProperty} from a CZML packet.
     * @param object - The object on which the property will be added or updated.
     * @param propertyName - The name of the property on the object.
     * @param packetData - The CZML packet being processed.
     * @param interval - A constraining interval for which the data is valid.
     * @param sourceUri - The originating uri of the data being processed.
     * @param entityCollection - The collection being processsed.
     */
    static processPositionPacketData(object: any, propertyName: string, packetData: any, interval: TimeInterval, sourceUri: string, entityCollection: EntityCollection): void;
    /**
     * A helper function used by custom CZML updater functions
     * which creates or updates a {@link MaterialProperty} from a CZML packet.
     * @param object - The object on which the property will be added or updated.
     * @param propertyName - The name of the property on the object.
     * @param packetData - The CZML packet being processed.
     * @param interval - A constraining interval for which the data is valid.
     * @param sourceUri - The originating uri of the data being processed.
     * @param entityCollection - The collection being processsed.
     */
    static processMaterialPacketData(object: any, propertyName: string, packetData: any, interval: TimeInterval, sourceUri: string, entityCollection: EntityCollection): void;
}

/**
 * Defines the interface for data sources, which turn arbitrary data into a
 * {@link EntityCollection} for generic consumption. This object is an interface
 * for documentation purposes and is not intended to be instantiated directly.
 */
export class DataSource {
    constructor();
    /**
     * Gets a human-readable name for this instance.
     */
    name: string;
    /**
     * Gets the preferred clock settings for this data source.
     */
    clock: DataSourceClock;
    /**
     * Gets the collection of {@link Entity} instances.
     */
    entities: EntityCollection;
    /**
     * Gets a value indicating if the data source is currently loading data.
     */
    isLoading: boolean;
    /**
     * Gets an event that will be raised when the underlying data changes.
     */
    changedEvent: Event;
    /**
     * Gets an event that will be raised if an error is encountered during processing.
     */
    errorEvent: Event<(arg0: this, arg1: RequestErrorEvent) => void>;
    /**
     * Gets an event that will be raised when the value of isLoading changes.
     */
    loadingEvent: Event<(arg0: this, arg1: boolean) => void>;
    /**
     * Gets whether or not this data source should be displayed.
     */
    show: boolean;
    /**
     * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.
     */
    clustering: EntityCluster;
    /**
     * Updates the data source to the provided time.  This function is optional and
     * is not required to be implemented.  It is provided for data sources which
     * retrieve data based on the current animation time or scene state.
     * If implemented, update will be called by {@link DataSourceDisplay} once a frame.
     * @param time - The simulation time.
     * @returns True if this data source is ready to be displayed at the provided time, false otherwise.
     */
    update(time: JulianDate): boolean;
}

/**
 * Represents desired clock settings for a particular {@link DataSource}.  These settings may be applied
 * to the {@link Clock} when the DataSource is loaded.
 */
export class DataSourceClock {
    constructor();
    /**
     * Gets the event that is raised whenever a new property is assigned.
     */
    readonly definitionChanged: Event;
    /**
     * Gets or sets the desired start time of the clock.
     * See {@link Clock#startTime}.
     */
    startTime: JulianDate;
    /**
     * Gets or sets the desired stop time of the clock.
     * See {@link Clock#stopTime}.
     */
    stopTime: JulianDate;
    /**
     * Gets or sets the desired current time when this data source is loaded.
     * See {@link Clock#currentTime}.
     */
    currentTime: JulianDate;
    /**
     * Gets or sets the desired clock range setting.
     * See {@link Clock#clockRange}.
     */
    clockRange: ClockRange;
    /**
     * Gets or sets the desired clock step setting.
     * See {@link Clock#clockStep}.
     */
    clockStep: ClockStep;
    /**
     * Gets or sets the desired clock multiplier.
     * See {@link Clock#multiplier}.
     */
    multiplier: number;
    /**
     * Duplicates a DataSourceClock instance.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new instance if one was not provided.
     */
    clone(result?: DataSourceClock): DataSourceClock;
    /**
     * Returns true if this DataSourceClock is equivalent to the other
     * @param other - The other DataSourceClock to compare to.
     * @returns <code>true</code> if the DataSourceClocks are equal; otherwise, <code>false</code>.
     */
    equals(other: DataSourceClock): boolean;
    /**
     * Assigns each unassigned property on this object to the value
     * of the same property on the provided source object.
     * @param source - The object to be merged into this object.
     */
    merge(source: DataSourceClock): void;
    /**
     * Gets the value of this clock instance as a {@link Clock} object.
     * @returns The modified result parameter or a new instance if one was not provided.
     */
    getValue(): Clock;
}

/**
 * A collection of {@link DataSource} instances.
 */
export class DataSourceCollection {
    constructor();
    /**
     * Gets the number of data sources in this collection.
     */
    readonly length: number;
    /**
     * An event that is raised when a data source is added to the collection.
     * Event handlers are passed the data source that was added.
     */
    readonly dataSourceAdded: Event;
    /**
     * An event that is raised when a data source is removed from the collection.
     * Event handlers are passed the data source that was removed.
     */
    readonly dataSourceRemoved: Event;
    /**
     * An event that is raised when a data source changes position in the collection.  Event handlers are passed the data source
     * that was moved, its new index after the move, and its old index prior to the move.
     */
    readonly dataSourceMoved: Event;
    /**
     * Adds a data source to the collection.
     * @param dataSource - A data source or a promise to a data source to add to the collection.
     *                                        When passing a promise, the data source will not actually be added
     *                                        to the collection until the promise resolves successfully.
     * @returns A Promise that resolves once the data source has been added to the collection.
     */
    add(dataSource: DataSource | Promise<DataSource>): Promise<DataSource>;
    /**
     * Removes a data source from this collection, if present.
     * @param dataSource - The data source to remove.
     * @param [destroy = false] - Whether to destroy the data source in addition to removing it.
     * @returns true if the data source was in the collection and was removed,
     *                    false if the data source was not in the collection.
     */
    remove(dataSource: DataSource, destroy?: boolean): boolean;
    /**
     * Removes all data sources from this collection.
     * @param [destroy = false] - whether to destroy the data sources in addition to removing them.
     */
    removeAll(destroy?: boolean): void;
    /**
     * Checks to see if the collection contains a given data source.
     * @param dataSource - The data source to check for.
     * @returns true if the collection contains the data source, false otherwise.
     */
    contains(dataSource: DataSource): boolean;
    /**
     * Determines the index of a given data source in the collection.
     * @param dataSource - The data source to find the index of.
     * @returns The index of the data source in the collection, or -1 if the data source does not exist in the collection.
     */
    indexOf(dataSource: DataSource): number;
    /**
     * Gets a data source by index from the collection.
     * @param index - the index to retrieve.
     * @returns The data source at the specified index.
     */
    get(index: number): DataSource;
    /**
     * Gets a data source by name from the collection.
     * @param name - The name to retrieve.
     * @returns A list of all data sources matching the provided name.
     */
    getByName(name: string): DataSource[];
    /**
     * Raises a data source up one position in the collection.
     * @param dataSource - The data source to move.
     */
    raise(dataSource: DataSource): void;
    /**
     * Lowers a data source down one position in the collection.
     * @param dataSource - The data source to move.
     */
    lower(dataSource: DataSource): void;
    /**
     * Raises a data source to the top of the collection.
     * @param dataSource - The data source to move.
     */
    raiseToTop(dataSource: DataSource): void;
    /**
     * Lowers a data source to the bottom of the collection.
     * @param dataSource - The data source to move.
     */
    lowerToBottom(dataSource: DataSource): void;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * @returns true if this object was destroyed; otherwise, false.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the resources held by all data sources in this collection.  Explicitly destroying this
     * object allows for deterministic release of WebGL resources, instead of relying on the garbage
     * collector. Once this object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     * @example
     * dataSourceCollection = dataSourceCollection && dataSourceCollection.destroy();
     */
    destroy(): void;
}

/**
 * Visualizes a collection of {@link DataSource} instances.
 * @param options - Object with the following properties:
 * @param options.scene - The scene in which to display the data.
 * @param options.dataSourceCollection - The data sources to display.
 * @param [options.visualizersCallback = DataSourceDisplay.defaultVisualizersCallback] - A function which creates an array of visualizers used for visualization.
 *        If undefined, all standard visualizers are used.
 */
export class DataSourceDisplay {
    constructor(options: {
        scene: Scene;
        dataSourceCollection: DataSourceCollection;
        visualizersCallback?: DataSourceDisplay.VisualizersCallback;
    });
    /**
     * Gets or sets the default function which creates an array of visualizers used for visualization.
     * By default, this function uses all standard visualizers.
     */
    static defaultVisualizersCallback(): void;
    /**
     * Gets the scene associated with this display.
     */
    scene: Scene;
    /**
     * Gets the collection of data sources to display.
     */
    dataSources: DataSourceCollection;
    /**
     * Gets the default data source instance which can be used to
     * manually create and visualize entities not tied to
     * a specific data source. This instance is always available
     * and does not appear in the list dataSources collection.
     */
    defaultDataSource: CustomDataSource;
    /**
     * Gets a value indicating whether or not all entities in the data source are ready
     */
    readonly ready: boolean;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * @returns True if this object was destroyed; otherwise, false.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     * @example
     * dataSourceDisplay = dataSourceDisplay.destroy();
     */
    destroy(): void;
    /**
     * Updates the display to the provided time.
     * @param time - The simulation time.
     * @returns True if all data sources are ready to be displayed, false otherwise.
     */
    update(time: JulianDate): boolean;
}

export namespace DataSourceDisplay {
    /**
     * A function which creates an array of visualizers used for visualization.
     * @example
     * function createVisualizers(scene, entityCluster, dataSource) {
     *     return [new Cesium.BillboardVisualizer(entityCluster, dataSource.entities)];
     * }
     * @param scene - The scene to create visualizers for.
     * @param entityCluster - The entity cluster to create visualizers for.
     * @param dataSource - The data source to create visualizers for.
     */
    type VisualizersCallback = (scene: Scene, entityCluster: EntityCluster, dataSource: DataSource) => Visualizer[];
}

/**
 * A {@link GeometryUpdater} for ellipses.
 * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
 * @param entity - The entity containing the geometry to be visualized.
 * @param scene - The scene where visualization is taking place.
 */
export class EllipseGeometryUpdater {
    constructor(entity: Entity, scene: Scene);
    /**
     * Creates the geometry instance which represents the fill of the geometry.
     * @param time - The time to use when retrieving initial attribute values.
     * @returns The geometry instance representing the filled portion of the geometry.
     */
    createFillGeometryInstance(time: JulianDate): GeometryInstance;
    /**
     * Creates the geometry instance which represents the outline of the geometry.
     * @param time - The time to use when retrieving initial attribute values.
     * @returns The geometry instance representing the outline portion of the geometry.
     */
    createOutlineGeometryInstance(time: JulianDate): GeometryInstance;
    /**
     * Gets a value indicating if the geometry should be drawn on terrain.
     */
    readonly onTerrain: boolean;
}

export namespace EllipseGraphics {
    /**
     * Initialization options for the EllipseGraphics constructor
     * [show = true] - A boolean Property specifying the visibility of the ellipse.
     * [semiMajorAxis] - The numeric Property specifying the semi-major axis.
     * [semiMinorAxis] - The numeric Property specifying the semi-minor axis.
     * [height = 0] - A numeric Property specifying the altitude of the ellipse relative to the ellipsoid surface.
     * [heightReference = HeightReference.NONE] - A Property specifying what the height is relative to.
     * [extrudedHeight] - A numeric Property specifying the altitude of the ellipse's extruded face relative to the ellipsoid surface.
     * [extrudedHeightReference = HeightReference.NONE] - A Property specifying what the extrudedHeight is relative to.
     * [rotation = 0.0] - A numeric property specifying the rotation of the ellipse counter-clockwise from north.
     * [stRotation = 0.0] - A numeric property specifying the rotation of the ellipse texture counter-clockwise from north.
     * [granularity = Cesium.Math.RADIANS_PER_DEGREE] - A numeric Property specifying the angular distance between points on the ellipse.
     * [fill = true] - A boolean Property specifying whether the ellipse is filled with the provided material.
     * [material = Color.WHITE] - A Property specifying the material used to fill the ellipse.
     * [outline = false] - A boolean Property specifying whether the ellipse is outlined.
     * [outlineColor = Color.BLACK] - A Property specifying the {@link Color} of the outline.
     * [outlineWidth = 1.0] - A numeric Property specifying the width of the outline.
     * [numberOfVerticalLines = 16] - A numeric Property specifying the number of vertical lines to draw along the perimeter for the outline.
     * [shadows = ShadowMode.DISABLED] - An enum Property specifying whether the ellipse casts or receives shadows from light sources.
     * [distanceDisplayCondition] - A Property specifying at what distance from the camera that this ellipse will be displayed.
     * [classificationType = ClassificationType.BOTH] - An enum Property specifying whether this ellipse will classify terrain, 3D Tiles, or both when on the ground.
     * [zIndex = 0] - A property specifying the zIndex of the Ellipse.  Used for ordering ground geometry.  Only has an effect if the ellipse is constant and neither height or exturdedHeight are specified.
     */
    type ConstructorOptions = {
        show?: Property | boolean;
        semiMajorAxis?: Property | number;
        semiMinorAxis?: Property | number;
        height?: Property | number;
        heightReference?: Property | HeightReference;
        extrudedHeight?: Property | number;
        extrudedHeightReference?: Property | HeightReference;
        rotation?: Property | number;
        stRotation?: Property | number;
        granularity?: Property | number;
        fill?: Property | boolean;
        material?: MaterialProperty | Color;
        outline?: Property | boolean;
        outlineColor?: Property | Color;
        outlineWidth?: Property | number;
        numberOfVerticalLines?: Property | number;
        shadows?: Property | ShadowMode;
        distanceDisplayCondition?: Property | DistanceDisplayCondition;
        classificationType?: Property | ClassificationType;
        zIndex?: ConstantProperty | number;
    };
}

/**
 * Describes an ellipse defined by a center point and semi-major and semi-minor axes.
 * The ellipse conforms to the curvature of the globe and can be placed on the surface or
 * at altitude and can optionally be extruded into a volume.
 * The center point is determined by the containing {@link Entity}.
 * @param [options] - Object describing initialization options
 */
export class EllipseGraphics {
    constructor(options?: EllipseGraphics.ConstructorOptions);
    /**
     * Gets the event that is raised whenever a property or sub-property is changed or modified.
     */
    readonly definitionChanged: Event;
    /**
     * Gets or sets the boolean Property specifying the visibility of the ellipse.
     */
    show: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the semi-major axis.
     */
    semiMajorAxis: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the semi-minor axis.
     */
    semiMinorAxis: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the altitude of the ellipse.
     */
    height: Property | undefined;
    /**
     * Gets or sets the Property specifying the {@link HeightReference}.
     */
    heightReference: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the altitude of the ellipse extrusion.
     * Setting this property creates volume starting at height and ending at this altitude.
     */
    extrudedHeight: Property | undefined;
    /**
     * Gets or sets the Property specifying the extruded {@link HeightReference}.
     */
    extrudedHeightReference: Property | undefined;
    /**
     * Gets or sets the numeric property specifying the rotation of the ellipse counter-clockwise from north.
     */
    rotation: Property | undefined;
    /**
     * Gets or sets the numeric property specifying the rotation of the ellipse texture counter-clockwise from north.
     */
    stRotation: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the angular distance between points on the ellipse.
     */
    granularity: Property | undefined;
    /**
     * Gets or sets the boolean Property specifying whether the ellipse is filled with the provided material.
     */
    fill: Property | undefined;
    /**
     * Gets or sets the Property specifying the material used to fill the ellipse.
     */
    material: MaterialProperty | undefined;
    /**
     * Gets or sets the Property specifying whether the ellipse is outlined.
     */
    outline: Property | undefined;
    /**
     * Gets or sets the Property specifying the {@link Color} of the outline.
     */
    outlineColor: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the width of the outline.
     * <p>
     * Note: This property will be ignored on all major browsers on Windows platforms. For details, see (@link https://github.com/CesiumGS/cesium/issues/40}.
     * </p>
     */
    outlineWidth: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the number of vertical lines to draw along the perimeter for the outline.
     */
    numberOfVerticalLines: Property | undefined;
    /**
     * Get or sets the enum Property specifying whether the ellipse
     * casts or receives shadows from light sources.
     */
    shadows: Property | undefined;
    /**
     * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this ellipse will be displayed.
     */
    distanceDisplayCondition: Property | undefined;
    /**
     * Gets or sets the {@link ClassificationType} Property specifying whether this ellipse will classify terrain, 3D Tiles, or both when on the ground.
     */
    classificationType: Property | undefined;
    /**
     * Gets or sets the zIndex Property specifying the ellipse ordering.  Only has an effect if the ellipse is constant and neither height or extrudedHeight are specified
     */
    zIndex: ConstantProperty | undefined;
    /**
     * Duplicates this instance.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new instance if one was not provided.
     */
    clone(result?: EllipseGraphics): EllipseGraphics;
    /**
     * Assigns each unassigned property on this object to the value
     * of the same property on the provided source object.
     * @param source - The object to be merged into this object.
     */
    merge(source: EllipseGraphics): void;
}

/**
 * A {@link GeometryUpdater} for ellipsoids.
 * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
 * @param entity - The entity containing the geometry to be visualized.
 * @param scene - The scene where visualization is taking place.
 */
export class EllipsoidGeometryUpdater {
    constructor(entity: Entity, scene: Scene);
    /**
     * Creates the geometry instance which represents the fill of the geometry.
     * @param time - The time to use when retrieving initial attribute values.
     * @param [skipModelMatrix = false] - Whether to compute a model matrix for the geometry instance
     * @param [modelMatrixResult] - Used to store the result of the model matrix calculation
     * @returns The geometry instance representing the filled portion of the geometry.
     */
    createFillGeometryInstance(time: JulianDate, skipModelMatrix?: boolean, modelMatrixResult?: Matrix4): GeometryInstance;
    /**
     * Creates the geometry instance which represents the outline of the geometry.
     * @param time - The time to use when retrieving initial attribute values.
     * @param [skipModelMatrix = false] - Whether to compute a model matrix for the geometry instance
     * @param [modelMatrixResult] - Used to store the result of the model matrix calculation
     * @returns The geometry instance representing the outline portion of the geometry.
     */
    createOutlineGeometryInstance(time: JulianDate, skipModelMatrix?: boolean, modelMatrixResult?: Matrix4): GeometryInstance;
}

export namespace EllipsoidGraphics {
    /**
     * Initialization options for the EllipsoidGraphics constructor
     * [show = true] - A boolean Property specifying the visibility of the ellipsoid.
     * [radii] - A {@link Cartesian3} Property specifying the radii of the ellipsoid.
     * [innerRadii] - A {@link Cartesian3} Property specifying the inner radii of the ellipsoid.
     * [minimumClock = 0.0] - A Property specifying the minimum clock angle of the ellipsoid.
     * [maximumClock = 2*PI] - A Property specifying the maximum clock angle of the ellipsoid.
     * [minimumCone = 0.0] - A Property specifying the minimum cone angle of the ellipsoid.
     * [maximumCone = PI] - A Property specifying the maximum cone angle of the ellipsoid.
     * [heightReference = HeightReference.NONE] - A Property specifying what the height from the entity position is relative to.
     * [fill = true] - A boolean Property specifying whether the ellipsoid is filled with the provided material.
     * [material = Color.WHITE] - A Property specifying the material used to fill the ellipsoid.
     * [outline = false] - A boolean Property specifying whether the ellipsoid is outlined.
     * [outlineColor = Color.BLACK] - A Property specifying the {@link Color} of the outline.
     * [outlineWidth = 1.0] - A numeric Property specifying the width of the outline.
     * [stackPartitions = 64] - A Property specifying the number of stacks.
     * [slicePartitions = 64] - A Property specifying the number of radial slices.
     * [subdivisions = 128] - A Property specifying the number of samples per outline ring, determining the granularity of the curvature.
     * [shadows = ShadowMode.DISABLED] - An enum Property specifying whether the ellipsoid casts or receives shadows from light sources.
     * [distanceDisplayCondition] - A Property specifying at what distance from the camera that this ellipsoid will be displayed.
     */
    type ConstructorOptions = {
        show?: Property | boolean;
        radii?: Property | Cartesian3;
        innerRadii?: Property | Cartesian3;
        minimumClock?: Property | number;
        maximumClock?: Property | number;
        minimumCone?: Property | number;
        maximumCone?: Property | number;
        heightReference?: Property | HeightReference;
        fill?: Property | boolean;
        material?: MaterialProperty | Color;
        outline?: Property | boolean;
        outlineColor?: Property | Color;
        outlineWidth?: Property | number;
        stackPartitions?: Property | number;
        slicePartitions?: Property | number;
        subdivisions?: Property | number;
        shadows?: Property | ShadowMode;
        distanceDisplayCondition?: Property | DistanceDisplayCondition;
    };
}

/**
 * Describe an ellipsoid or sphere.  The center position and orientation are determined by the containing {@link Entity}.
 * @param [options] - Object describing initialization options
 */
export class EllipsoidGraphics {
    constructor(options?: EllipsoidGraphics.ConstructorOptions);
    /**
     * Gets the event that is raised whenever a property or sub-property is changed or modified.
     */
    readonly definitionChanged: Event;
    /**
     * Gets or sets the boolean Property specifying the visibility of the ellipsoid.
     */
    show: Property | undefined;
    /**
     * Gets or sets the {@link Cartesian3} {@link Property} specifying the radii of the ellipsoid.
     */
    radii: Property | undefined;
    /**
     * Gets or sets the {@link Cartesian3} {@link Property} specifying the inner radii of the ellipsoid.
     */
    innerRadii: Property | undefined;
    /**
     * Gets or sets the Property specifying the minimum clock angle of the ellipsoid.
     */
    minimumClock: Property | undefined;
    /**
     * Gets or sets the Property specifying the maximum clock angle of the ellipsoid.
     */
    maximumClock: Property | undefined;
    /**
     * Gets or sets the Property specifying the minimum cone angle of the ellipsoid.
     */
    minimumCone: Property | undefined;
    /**
     * Gets or sets the Property specifying the maximum cone angle of the ellipsoid.
     */
    maximumCone: Property | undefined;
    /**
     * Gets or sets the Property specifying the {@link HeightReference}.
     */
    heightReference: Property | undefined;
    /**
     * Gets or sets the boolean Property specifying whether the ellipsoid is filled with the provided material.
     */
    fill: Property | undefined;
    /**
     * Gets or sets the Property specifying the material used to fill the ellipsoid.
     */
    material: MaterialProperty;
    /**
     * Gets or sets the Property specifying whether the ellipsoid is outlined.
     */
    outline: Property | undefined;
    /**
     * Gets or sets the Property specifying the {@link Color} of the outline.
     */
    outlineColor: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the width of the outline.
     * <p>
     * Note: This property will be ignored on all major browsers on Windows platforms. For details, see (@link https://github.com/CesiumGS/cesium/issues/40}.
     * </p>
     */
    outlineWidth: Property | undefined;
    /**
     * Gets or sets the Property specifying the number of stacks.
     */
    stackPartitions: Property | undefined;
    /**
     * Gets or sets the Property specifying the number of radial slices per 360 degrees.
     */
    slicePartitions: Property | undefined;
    /**
     * Gets or sets the Property specifying the number of samples per outline ring, determining the granularity of the curvature.
     */
    subdivisions: Property | undefined;
    /**
     * Get or sets the enum Property specifying whether the ellipsoid
     * casts or receives shadows from light sources.
     */
    shadows: Property | undefined;
    /**
     * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this ellipsoid will be displayed.
     */
    distanceDisplayCondition: Property | undefined;
    /**
     * Duplicates this instance.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new instance if one was not provided.
     */
    clone(result?: EllipsoidGraphics): EllipsoidGraphics;
    /**
     * Assigns each unassigned property on this object to the value
     * of the same property on the provided source object.
     * @param source - The object to be merged into this object.
     */
    merge(source: EllipsoidGraphics): void;
}

export namespace Entity {
    /**
     * Initialization options for the Entity constructor
     * [id] - A unique identifier for this object. If none is provided, a GUID is generated.
     * [name] - A human readable name to display to users. It does not have to be unique.
     * [availability] - The availability, if any, associated with this object.
     * [show] - A boolean value indicating if the entity and its children are displayed.
     * [description] - A string Property specifying an HTML description for this entity.
     * [position] - A Property specifying the entity position.
     * [orientation] - A Property specifying the entity orientation.
     * [viewFrom] - A suggested initial offset for viewing this object.
     * [parent] - A parent entity to associate with this entity.
     * [billboard] - A billboard to associate with this entity.
     * [box] - A box to associate with this entity.
     * [corridor] - A corridor to associate with this entity.
     * [cylinder] - A cylinder to associate with this entity.
     * [ellipse] - A ellipse to associate with this entity.
     * [ellipsoid] - A ellipsoid to associate with this entity.
     * [label] - A options.label to associate with this entity.
     * [model] - A model to associate with this entity.
     * [tileset] - A 3D Tiles tileset to associate with this entity.
     * [path] - A path to associate with this entity.
     * [plane] - A plane to associate with this entity.
     * [point] - A point to associate with this entity.
     * [polygon] - A polygon to associate with this entity.
     * [polyline] - A polyline to associate with this entity.
     * [properties] - Arbitrary properties to associate with this entity.
     * [polylineVolume] - A polylineVolume to associate with this entity.
     * [rectangle] - A rectangle to associate with this entity.
     * [wall] - A wall to associate with this entity.
     */
    type ConstructorOptions = {
        id?: string;
        name?: string;
        availability?: TimeIntervalCollection;
        show?: boolean;
        description?: Property | string;
        position?: PositionProperty | Cartesian3;
        orientation?: Property;
        viewFrom?: Property;
        parent?: Entity;
        billboard?: BillboardGraphics | BillboardGraphics.ConstructorOptions;
        box?: BoxGraphics | BoxGraphics.ConstructorOptions;
        corridor?: CorridorGraphics | CorridorGraphics.ConstructorOptions;
        cylinder?: CylinderGraphics | CylinderGraphics.ConstructorOptions;
        ellipse?: EllipseGraphics | EllipseGraphics.ConstructorOptions;
        ellipsoid?: EllipsoidGraphics | EllipsoidGraphics.ConstructorOptions;
        label?: LabelGraphics | LabelGraphics.ConstructorOptions;
        model?: ModelGraphics | ModelGraphics.ConstructorOptions;
        tileset?: Cesium3DTilesetGraphics | Cesium3DTilesetGraphics.ConstructorOptions;
        path?: PathGraphics | PathGraphics.ConstructorOptions;
        plane?: PlaneGraphics | PlaneGraphics.ConstructorOptions;
        point?: PointGraphics | PointGraphics.ConstructorOptions;
        polygon?: PolygonGraphics | PolygonGraphics.ConstructorOptions;
        polyline?: PolylineGraphics | PolylineGraphics.ConstructorOptions;
        properties?: PropertyBag | {
            [key: string]: any;
        };
        polylineVolume?: PolylineVolumeGraphics | PolylineVolumeGraphics.ConstructorOptions;
        rectangle?: RectangleGraphics | RectangleGraphics.ConstructorOptions;
        wall?: WallGraphics | WallGraphics.ConstructorOptions;
    };
}

/**
 * Entity instances aggregate multiple forms of visualization into a single high-level object.
 * They can be created manually and added to {@link Viewer#entities} or be produced by
 * data sources, such as {@link CzmlDataSource} and {@link GeoJsonDataSource}.
 * @param [options] - Object describing initialization options
 */
export class Entity {
    constructor(options?: Entity.ConstructorOptions);
    /**
     * Gets or sets the entity collection that this entity belongs to.
     */
    entityCollection: EntityCollection;
    /**
     * The availability, if any, associated with this object.
     * If availability is undefined, it is assumed that this object's
     * other properties will return valid data for any provided time.
     * If availability exists, the objects other properties will only
     * provide valid data if queried within the given interval.
     */
    availability: TimeIntervalCollection | undefined;
    /**
     * Gets the unique ID associated with this object.
     */
    id: string;
    /**
     * Gets the event that is raised whenever a property or sub-property is changed or modified.
     */
    readonly definitionChanged: Event;
    /**
     * Gets or sets the name of the object.  The name is intended for end-user
     * consumption and does not need to be unique.
     */
    name: string | undefined;
    /**
     * Gets or sets whether this entity should be displayed. When set to true,
     * the entity is only displayed if the parent entity's show property is also true.
     */
    show: boolean;
    /**
     * Gets whether this entity is being displayed, taking into account
     * the visibility of any ancestor entities.
     */
    isShowing: boolean;
    /**
     * Gets or sets the parent object.
     */
    parent: Entity | undefined;
    /**
     * Gets the names of all properties registered on this instance.
     */
    propertyNames: string[];
    /**
     * Gets or sets the billboard.
     */
    billboard: BillboardGraphics | undefined;
    /**
     * Gets or sets the box.
     */
    box: BoxGraphics | undefined;
    /**
     * Gets or sets the corridor.
     */
    corridor: CorridorGraphics | undefined;
    /**
     * Gets or sets the cylinder.
     */
    cylinder: CylinderGraphics | undefined;
    /**
     * Gets or sets the description.
     */
    description: Property | undefined;
    /**
     * Gets or sets the ellipse.
     */
    ellipse: EllipseGraphics | undefined;
    /**
     * Gets or sets the ellipsoid.
     */
    ellipsoid: EllipsoidGraphics | undefined;
    /**
     * Gets or sets the label.
     */
    label: LabelGraphics | undefined;
    /**
     * Gets or sets the model.
     */
    model: ModelGraphics | undefined;
    /**
     * Gets or sets the tileset.
     */
    tileset: Cesium3DTilesetGraphics | undefined;
    /**
     * Gets or sets the orientation.
     */
    orientation: Property | undefined;
    /**
     * Gets or sets the path.
     */
    path: PathGraphics | undefined;
    /**
     * Gets or sets the plane.
     */
    plane: PlaneGraphics | undefined;
    /**
     * Gets or sets the point graphic.
     */
    point: PointGraphics | undefined;
    /**
     * Gets or sets the polygon.
     */
    polygon: PolygonGraphics | undefined;
    /**
     * Gets or sets the polyline.
     */
    polyline: PolylineGraphics | undefined;
    /**
     * Gets or sets the polyline volume.
     */
    polylineVolume: PolylineVolumeGraphics | undefined;
    /**
     * Gets or sets the bag of arbitrary properties associated with this entity.
     */
    properties: PropertyBag | undefined;
    /**
     * Gets or sets the position.
     */
    position: PositionProperty | undefined;
    /**
     * Gets or sets the rectangle.
     */
    rectangle: RectangleGraphics | undefined;
    /**
     * Gets or sets the suggested initial offset when tracking this object.
     * The offset is typically defined in the east-north-up reference frame,
     * but may be another frame depending on the object's velocity.
     */
    viewFrom: Property | undefined;
    /**
     * Gets or sets the wall.
     */
    wall: WallGraphics | undefined;
    /**
     * Given a time, returns true if this object should have data during that time.
     * @param time - The time to check availability for.
     * @returns true if the object should have data during the provided time, false otherwise.
     */
    isAvailable(time: JulianDate): boolean;
    /**
     * Adds a property to this object.  Once a property is added, it can be
     * observed with {@link Entity#definitionChanged} and composited
     * with {@link CompositeEntityCollection}
     * @param propertyName - The name of the property to add.
     */
    addProperty(propertyName: string): void;
    /**
     * Removed a property previously added with addProperty.
     * @param propertyName - The name of the property to remove.
     */
    removeProperty(propertyName: string): void;
    /**
     * Assigns each unassigned property on this object to the value
     * of the same property on the provided source object.
     * @param source - The object to be merged into this object.
     */
    merge(source: Entity): void;
    /**
     * Computes the model matrix for the entity's transform at specified time. Returns undefined if position is undefined
     * @param time - The time to retrieve model matrix for.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new Matrix4 instance if one was not provided. Result is undefined if position is undefined.
     */
    computeModelMatrix(time: JulianDate, result?: Matrix4): Matrix4;
    /**
     * Checks if the given Scene supports materials besides Color on Entities draped on terrain or 3D Tiles.
     * If this feature is not supported, Entities with non-color materials but no `height` will
     * instead be rendered as if height is 0.
     * @param scene - The current scene.
     * @returns Whether or not the current scene supports materials for entities on terrain.
     */
    static supportsMaterialsforEntitiesOnTerrain(scene: Scene): boolean;
    /**
     * Checks if the given Scene supports polylines clamped to terrain or 3D Tiles.
     * If this feature is not supported, Entities with PolylineGraphics will be rendered with vertices at
     * the provided heights and using the `arcType` parameter instead of clamped to the ground.
     * @param scene - The current scene.
     * @returns Whether or not the current scene supports polylines on terrain or 3D TIles.
     */
    static supportsPolylinesOnTerrain(scene: Scene): boolean;
}

/**
 * Defines how screen space objects (billboards, points, labels) are clustered.
 * @param [options] - An object with the following properties:
 * @param [options.enabled = false] - Whether or not to enable clustering.
 * @param [options.pixelRange = 80] - The pixel range to extend the screen space bounding box.
 * @param [options.minimumClusterSize = 2] - The minimum number of screen space objects that can be clustered.
 * @param [options.clusterBillboards = true] - Whether or not to cluster the billboards of an entity.
 * @param [options.clusterLabels = true] - Whether or not to cluster the labels of an entity.
 * @param [options.clusterPoints = true] - Whether or not to cluster the points of an entity.
 * @param [options.show = true] - Determines if the entities in the cluster will be shown.
 */
export class EntityCluster {
    constructor(options?: {
        enabled?: boolean;
        pixelRange?: number;
        minimumClusterSize?: number;
        clusterBillboards?: boolean;
        clusterLabels?: boolean;
        clusterPoints?: boolean;
        show?: boolean;
    });
    /**
     * Determines if entities in this collection will be shown.
     */
    show: boolean;
    /**
     * Gets or sets whether clustering is enabled.
     */
    enabled: boolean;
    /**
     * Gets or sets the pixel range to extend the screen space bounding box.
     */
    pixelRange: number;
    /**
     * Gets or sets the minimum number of screen space objects that can be clustered.
     */
    minimumClusterSize: number;
    /**
     * Gets the event that will be raised when a new cluster will be displayed. The signature of the event listener is {@link EntityCluster.newClusterCallback}.
     */
    clusterEvent: Event<EntityCluster.newClusterCallback>;
    /**
     * Gets or sets whether clustering billboard entities is enabled.
     */
    clusterBillboards: boolean;
    /**
     * Gets or sets whether clustering labels entities is enabled.
     */
    clusterLabels: boolean;
    /**
     * Gets or sets whether clustering point entities is enabled.
     */
    clusterPoints: boolean;
    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <p>
     * Unlike other objects that use WebGL resources, this object can be reused. For example, if a data source is removed
     * from a data source collection and added to another.
     * </p>
     */
    destroy(): void;
}

export namespace EntityCluster {
    /**
     * A event listener function used to style clusters.
     * @example
     * // The default cluster values.
     * dataSource.clustering.clusterEvent.addEventListener(function(entities, cluster) {
     *     cluster.label.show = true;
     *     cluster.label.text = entities.length.toLocaleString();
     * });
     * @param clusteredEntities - An array of the entities contained in the cluster.
     * @param cluster - An object containing the Billboard, Label, and Point
     * primitives that represent this cluster of entities.
     */
    type newClusterCallback = (clusteredEntities: Entity[], cluster: {
        billboard: Billboard;
        label: Label;
        point: PointPrimitive;
    }) => void;
}

/**
 * An observable collection of {@link Entity} instances where each entity has a unique id.
 * @param [owner] - The data source (or composite entity collection) which created this collection.
 */
export class EntityCollection {
    constructor(owner?: DataSource | CompositeEntityCollection);
    /**
     * Prevents {@link EntityCollection#collectionChanged} events from being raised
     * until a corresponding call is made to {@link EntityCollection#resumeEvents}, at which
     * point a single event will be raised that covers all suspended operations.
     * This allows for many items to be added and removed efficiently.
     * This function can be safely called multiple times as long as there
     * are corresponding calls to {@link EntityCollection#resumeEvents}.
     */
    suspendEvents(): void;
    /**
     * Resumes raising {@link EntityCollection#collectionChanged} events immediately
     * when an item is added or removed.  Any modifications made while while events were suspended
     * will be triggered as a single event when this function is called.
     * This function is reference counted and can safely be called multiple times as long as there
     * are corresponding calls to {@link EntityCollection#resumeEvents}.
     */
    resumeEvents(): void;
    /**
     * Gets the event that is fired when entities are added or removed from the collection.
     * The generated event is a {@link EntityCollection.CollectionChangedEventCallback}.
     */
    readonly collectionChanged: Event<EntityCollection.CollectionChangedEventCallback>;
    /**
     * Gets a globally unique identifier for this collection.
     */
    readonly id: string;
    /**
     * Gets the array of Entity instances in the collection.
     * This array should not be modified directly.
     */
    readonly values: Entity[];
    /**
     * Gets whether or not this entity collection should be
     * displayed.  When true, each entity is only displayed if
     * its own show property is also true.
     */
    show: boolean;
    /**
     * Gets the owner of this entity collection, ie. the data source or composite entity collection which created it.
     */
    readonly owner: DataSource | CompositeEntityCollection;
    /**
     * Computes the maximum availability of the entities in the collection.
     * If the collection contains a mix of infinitely available data and non-infinite data,
     * it will return the interval pertaining to the non-infinite data only.  If all
     * data is infinite, an infinite interval will be returned.
     * @returns The availability of entities in the collection.
     */
    computeAvailability(): TimeInterval;
    /**
     * Add an entity to the collection.
     * @param entity - The entity to be added.
     * @returns The entity that was added.
     */
    add(entity: Entity | Entity.ConstructorOptions): Entity;
    /**
     * Removes an entity from the collection.
     * @param entity - The entity to be removed.
     * @returns true if the item was removed, false if it did not exist in the collection.
     */
    remove(entity: Entity): boolean;
    /**
     * Returns true if the provided entity is in this collection, false otherwise.
     * @param entity - The entity.
     * @returns true if the provided entity is in this collection, false otherwise.
     */
    contains(entity: Entity): boolean;
    /**
     * Removes an entity with the provided id from the collection.
     * @param id - The id of the entity to remove.
     * @returns true if the item was removed, false if no item with the provided id existed in the collection.
     */
    removeById(id: string): boolean;
    /**
     * Removes all Entities from the collection.
     */
    removeAll(): void;
    /**
     * Gets an entity with the specified id.
     * @param id - The id of the entity to retrieve.
     * @returns The entity with the provided id or undefined if the id did not exist in the collection.
     */
    getById(id: string): Entity | undefined;
    /**
     * Gets an entity with the specified id or creates it and adds it to the collection if it does not exist.
     * @param id - The id of the entity to retrieve or create.
     * @returns The new or existing object.
     */
    getOrCreateEntity(id: string): Entity;
}

export namespace EntityCollection {
    /**
     * The signature of the event generated by {@link EntityCollection#collectionChanged}.
     * @param collection - The collection that triggered the event.
     * @param added - The array of {@link Entity} instances that have been added to the collection.
     * @param removed - The array of {@link Entity} instances that have been removed from the collection.
     * @param changed - The array of {@link Entity} instances that have been modified.
     */
    type CollectionChangedEventCallback = (collection: EntityCollection, added: Entity[], removed: Entity[], changed: Entity[]) => void;
}

/**
 * A utility object for tracking an entity with the camera.
 * @param entity - The entity to track with the camera.
 * @param scene - The scene to use.
 * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid to use for orienting the camera.
 */
export class EntityView {
    constructor(entity: Entity, scene: Scene, ellipsoid?: Ellipsoid);
    /**
     * The entity to track with the camera.
     */
    entity: Entity;
    /**
     * The scene in which to track the object.
     */
    scene: Scene;
    /**
     * The ellipsoid to use for orienting the camera.
     */
    ellipsoid: Ellipsoid;
    /**
     * The bounding sphere of the object.
     */
    boundingSphere: BoundingSphere;
    /**
     * Gets or sets a camera offset that will be used to
     * initialize subsequent EntityViews.
     */
    static defaultOffset3D: Cartesian3;
    /**
     * Should be called each animation frame to update the camera
     * to the latest settings.
     * @param time - The current animation time.
     * @param [boundingSphere] - bounding sphere of the object.
     */
    update(time: JulianDate, boundingSphere?: BoundingSphere): void;
}

export namespace GeoJsonDataSource {
    /**
     * Initialization options for the <code>load</code> method.
     * [sourceUri] - Overrides the url to use for resolving relative links.
     * [describe = GeoJsonDataSource.defaultDescribeProperty] - A function which returns a Property object (or just a string).
     * [markerSize = GeoJsonDataSource.markerSize] - The default size of the map pin created for each point, in pixels.
     * [markerSymbol = GeoJsonDataSource.markerSymbol] - The default symbol of the map pin created for each point.
     * [markerColor = GeoJsonDataSource.markerColor] - The default color of the map pin created for each point.
     * [stroke = GeoJsonDataSource.stroke] - The default color of polylines and polygon outlines.
     * [strokeWidth = GeoJsonDataSource.strokeWidth] - The default width of polylines and polygon outlines.
     * [fill = GeoJsonDataSource.fill] - The default color for polygon interiors.
     * [clampToGround = GeoJsonDataSource.clampToGround] - true if we want the geometry features (polygons or linestrings) clamped to the ground.
     * [credit] - A credit for the data source, which is displayed on the canvas.
     */
    type LoadOptions = {
        sourceUri?: string;
        describe?: GeoJsonDataSource.describe;
        markerSize?: number;
        markerSymbol?: string;
        markerColor?: Color;
        stroke?: Color;
        strokeWidth?: number;
        fill?: Color;
        clampToGround?: boolean;
        credit?: Credit | string;
    };
    /**
     * This callback is displayed as part of the GeoJsonDataSource class.
     * @param properties - The properties of the feature.
     * @param nameProperty - The property key that Cesium estimates to have the name of the feature.
     */
    type describe = (properties: any, nameProperty: string) => void;
}

/**
 * A {@link DataSource} which processes both
 * {@link http://www.geojson.org/|GeoJSON} and {@link https://github.com/mbostock/topojson|TopoJSON} data.
 * {@link https://github.com/mapbox/simplestyle-spec|simplestyle-spec} properties will also be used if they
 * are present.
 * @example
 * const viewer = new Cesium.Viewer('cesiumContainer');
 * viewer.dataSources.add(Cesium.GeoJsonDataSource.load('../../SampleData/ne_10m_us_states.topojson', {
 *   stroke: Cesium.Color.HOTPINK,
 *   fill: Cesium.Color.PINK,
 *   strokeWidth: 3,
 *   markerSymbol: '?'
 * }));
 * @param [name] - The name of this data source.  If undefined, a name will be taken from
 *                        the name of the GeoJSON file.
 */
export class GeoJsonDataSource {
    constructor(name?: string);
    /**
     * Creates a Promise to a new instance loaded with the provided GeoJSON or TopoJSON data.
     * @param data - A url, GeoJSON object, or TopoJSON object to be loaded.
     * @param [options] - An object specifying configuration options
     * @returns A promise that will resolve when the data is loaded.
     */
    static load(data: Resource | string | any, options?: GeoJsonDataSource.LoadOptions): Promise<GeoJsonDataSource>;
    /**
     * Gets or sets the default size of the map pin created for each point, in pixels.
     */
    static markerSize: number;
    /**
     * Gets or sets the default symbol of the map pin created for each point.
     * This can be any valid {@link http://mapbox.com/maki/|Maki} identifier, any single character,
     * or blank if no symbol is to be used.
     */
    static markerSymbol: string;
    /**
     * Gets or sets the default color of the map pin created for each point.
     */
    static markerColor: Color;
    /**
     * Gets or sets the default color of polylines and polygon outlines.
     */
    static stroke: Color;
    /**
     * Gets or sets the default width of polylines and polygon outlines.
     */
    static strokeWidth: number;
    /**
     * Gets or sets default color for polygon interiors.
     */
    static fill: Color;
    /**
     * Gets or sets default of whether to clamp to the ground.
     */
    static clampToGround: boolean;
    /**
     * Gets an object that maps the name of a crs to a callback function which takes a GeoJSON coordinate
     * and transforms it into a WGS84 Earth-fixed Cartesian.  Older versions of GeoJSON which
     * supported the EPSG type can be added to this list as well, by specifying the complete EPSG name,
     * for example 'EPSG:4326'.
     */
    static crsNames: any;
    /**
     * Gets an object that maps the href property of a crs link to a callback function
     * which takes the crs properties object and returns a Promise that resolves
     * to a function that takes a GeoJSON coordinate and transforms it into a WGS84 Earth-fixed Cartesian.
     * Items in this object take precedence over those defined in <code>crsLinkHrefs</code>, assuming
     * the link has a type specified.
     */
    static crsLinkHrefs: any;
    /**
     * Gets an object that maps the type property of a crs link to a callback function
     * which takes the crs properties object and returns a Promise that resolves
     * to a function that takes a GeoJSON coordinate and transforms it into a WGS84 Earth-fixed Cartesian.
     * Items in <code>crsLinkHrefs</code> take precedence over this object.
     */
    static crsLinkTypes: any;
    /**
     * Gets or sets a human-readable name for this instance.
     */
    name: string;
    /**
     * This DataSource only defines static data, therefore this property is always undefined.
     */
    clock: DataSourceClock;
    /**
     * Gets the collection of {@link Entity} instances.
     */
    entities: EntityCollection;
    /**
     * Gets a value indicating if the data source is currently loading data.
     */
    isLoading: boolean;
    /**
     * Gets an event that will be raised when the underlying data changes.
     */
    changedEvent: Event;
    /**
     * Gets an event that will be raised if an error is encountered during processing.
     */
    errorEvent: Event;
    /**
     * Gets an event that will be raised when the data source either starts or stops loading.
     */
    loadingEvent: Event;
    /**
     * Gets whether or not this data source should be displayed.
     */
    show: boolean;
    /**
     * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.
     */
    clustering: EntityCluster;
    /**
     * Gets the credit that will be displayed for the data source
     */
    credit: Credit;
    /**
     * Asynchronously loads the provided GeoJSON or TopoJSON data, replacing any existing data.
     * @param data - A url, GeoJSON object, or TopoJSON object to be loaded.
     * @param [options] - An object specifying configuration options
     * @returns a promise that will resolve when the GeoJSON is loaded.
     */
    load(data: Resource | string | any, options?: GeoJsonDataSource.LoadOptions): Promise<GeoJsonDataSource>;
    /**
     * Asynchronously loads the provided GeoJSON or TopoJSON data, without replacing any existing data.
     * @param data - A url, GeoJSON object, or TopoJSON object to be loaded.
     * @param [options] - An object specifying configuration options
     * @returns a promise that will resolve when the GeoJSON is loaded.
     */
    process(data: Resource | string | any, options?: GeoJsonDataSource.LoadOptions): Promise<GeoJsonDataSource>;
    /**
     * Updates the data source to the provided time.  This function is optional and
     * is not required to be implemented.  It is provided for data sources which
     * retrieve data based on the current animation time or scene state.
     * If implemented, update will be called by {@link DataSourceDisplay} once a frame.
     * @param time - The simulation time.
     * @returns True if this data source is ready to be displayed at the provided time, false otherwise.
     */
    update(time: JulianDate): boolean;
}

/**
 * An abstract class for updating geometry entities.
 * @param options - An object with the following properties:
 * @param options.entity - The entity containing the geometry to be visualized.
 * @param options.scene - The scene where visualization is taking place.
 * @param options.geometryOptions - Options for the geometry
 * @param options.geometryPropertyName - The geometry property name
 * @param options.observedPropertyNames - The entity properties this geometry cares about
 */
export class GeometryUpdater {
    constructor(options: {
        entity: Entity;
        scene: Scene;
        geometryOptions: any;
        geometryPropertyName: string;
        observedPropertyNames: string[];
    });
    /**
     * Gets the unique ID associated with this updater
     */
    readonly id: string;
    /**
     * Gets the entity associated with this geometry.
     */
    readonly entity: Entity;
    /**
     * Gets a value indicating if the geometry has a fill component.
     */
    readonly fillEnabled: boolean;
    /**
     * Gets a value indicating if fill visibility varies with simulation time.
     */
    readonly hasConstantFill: boolean;
    /**
     * Gets the material property used to fill the geometry.
     */
    readonly fillMaterialProperty: MaterialProperty;
    /**
     * Gets a value indicating if the geometry has an outline component.
     */
    readonly outlineEnabled: boolean;
    /**
     * Gets a value indicating if the geometry has an outline component.
     */
    readonly hasConstantOutline: boolean;
    /**
     * Gets the {@link Color} property for the geometry outline.
     */
    readonly outlineColorProperty: Property;
    /**
     * Gets the constant with of the geometry outline, in pixels.
     * This value is only valid if isDynamic is false.
     */
    readonly outlineWidth: number;
    /**
     * Gets the property specifying whether the geometry
     * casts or receives shadows from light sources.
     */
    readonly shadowsProperty: Property;
    /**
     * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this geometry will be displayed.
     */
    readonly distanceDisplayConditionProperty: Property;
    /**
     * Gets or sets the {@link ClassificationType} Property specifying if this geometry will classify terrain, 3D Tiles, or both when on the ground.
     */
    readonly classificationTypeProperty: Property;
    /**
     * Gets a value indicating if the geometry is time-varying.
     * If true, all visualization is delegated to a DynamicGeometryUpdater
     * returned by GeometryUpdater#createDynamicUpdater.
     */
    readonly isDynamic: boolean;
    /**
     * Gets a value indicating if the geometry is closed.
     * This property is only valid for static geometry.
     */
    readonly isClosed: boolean;
    /**
     * Gets an event that is raised whenever the public properties
     * of this updater change.
     */
    readonly geometryChanged: boolean;
    /**
     * Checks if the geometry is outlined at the provided time.
     * @param time - The time for which to retrieve visibility.
     * @returns true if geometry is outlined at the provided time, false otherwise.
     */
    isOutlineVisible(time: JulianDate): boolean;
    /**
     * Checks if the geometry is filled at the provided time.
     * @param time - The time for which to retrieve visibility.
     * @returns true if geometry is filled at the provided time, false otherwise.
     */
    isFilled(time: JulianDate): boolean;
    /**
     * Creates the geometry instance which represents the fill of the geometry.
     * @param time - The time to use when retrieving initial attribute values.
     * @returns The geometry instance representing the filled portion of the geometry.
     */
    createFillGeometryInstance(time: JulianDate): GeometryInstance;
    /**
     * Creates the geometry instance which represents the outline of the geometry.
     * @param time - The time to use when retrieving initial attribute values.
     * @returns The geometry instance representing the outline portion of the geometry.
     */
    createOutlineGeometryInstance(time: JulianDate): GeometryInstance;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * @returns True if this object was destroyed; otherwise, false.
     */
    isDestroyed(): boolean;
    /**
     * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.
     */
    destroy(): void;
}

/**
 * A general purpose visualizer for geometry represented by {@link Primitive} instances.
 * @param scene - The scene the primitives will be rendered in.
 * @param entityCollection - The entityCollection to visualize.
 * @param [primitives = scene.primitives] - A collection to add primitives related to the entities
 * @param [groundPrimitives = scene.groundPrimitives] - A collection to add ground primitives related to the entities
 */
export class GeometryVisualizer {
    constructor(scene: Scene, entityCollection: EntityCollection, primitives?: PrimitiveCollection, groundPrimitives?: PrimitiveCollection);
    /**
     * Updates all of the primitives created by this visualizer to match their
     * Entity counterpart at the given time.
     * @param time - The time to update to.
     * @returns True if the visualizer successfully updated to the provided time,
     * false if the visualizer is waiting for asynchronous primitives to be created.
     */
    update(time: JulianDate): boolean;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * @returns True if this object was destroyed; otherwise, false.
     */
    isDestroyed(): boolean;
    /**
     * Removes and destroys all primitives created by this instance.
     */
    destroy(): void;
}

/**
 * A {@link DataSource} which processes the GPS Exchange Format (GPX).
 * @example
 * const viewer = new Cesium.Viewer('cesiumContainer');
 * viewer.dataSources.add(Cesium.GpxDataSource.load('../../SampleData/track.gpx'));
 */
export class GpxDataSource {
    constructor();
    /**
     * Creates a Promise to a new instance loaded with the provided GPX data.
     * @param data - A url, parsed GPX document, or Blob containing binary GPX data.
     * @param [options] - An object with the following properties:
     * @param [options.clampToGround] - True if the symbols should be rendered at the same height as the terrain
     * @param [options.waypointImage] - Image to use for waypoint billboards.
     * @param [options.trackImage] - Image to use for track billboards.
     * @param [options.trackColor] - Color to use for track lines.
     * @param [options.routeColor] - Color to use for route lines.
     * @returns A promise that will resolve to a new GpxDataSource instance once the gpx is loaded.
     */
    static load(data: string | Document | Blob, options?: {
        clampToGround?: boolean;
        waypointImage?: string;
        trackImage?: string;
        trackColor?: string;
        routeColor?: string;
    }): Promise<GpxDataSource>;
    /**
     * Gets a human-readable name for this instance.
     * This will be automatically be set to the GPX document name on load.
     */
    name: string;
    /**
     * Gets the version of the GPX Schema in use.
     */
    version: string;
    /**
     * Gets the creator of the GPX document.
     */
    creator: string;
    /**
     * Gets an object containing metadata about the GPX file.
     */
    metadata: any;
    /**
     * Gets the clock settings defined by the loaded GPX. This represents the total
     * availability interval for all time-dynamic data. If the GPX does not contain
     * time-dynamic data, this value is undefined.
     */
    clock: DataSourceClock;
    /**
     * Gets the collection of {@link Entity} instances.
     */
    entities: EntityCollection;
    /**
     * Gets a value indicating if the data source is currently loading data.
     */
    isLoading: boolean;
    /**
     * Gets an event that will be raised when the underlying data changes.
     */
    changedEvent: Event;
    /**
     * Gets an event that will be raised if an error is encountered during processing.
     */
    errorEvent: Event;
    /**
     * Gets an event that will be raised when the data source either starts or stops loading.
     */
    loadingEvent: Event;
    /**
     * Gets whether or not this data source should be displayed.
     */
    show: boolean;
    /**
     * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.
     */
    clustering: EntityCluster;
    /**
     * Updates the data source to the provided time.  This function is optional and
     * is not required to be implemented.  It is provided for data sources which
     * retrieve data based on the current animation time or scene state.
     * If implemented, update will be called by {@link DataSourceDisplay} once a frame.
     * @param time - The simulation time.
     * @returns True if this data source is ready to be displayed at the provided time, false otherwise.
     */
    update(time: JulianDate): boolean;
    /**
     * Asynchronously loads the provided GPX data, replacing any existing data.
     * @param data - A url, parsed GPX document, or Blob containing binary GPX data or a parsed GPX document.
     * @param [options] - An object with the following properties:
     * @param [options.clampToGround] - True if the symbols should be rendered at the same height as the terrain
     * @param [options.waypointImage] - Image to use for waypoint billboards.
     * @param [options.trackImage] - Image to use for track billboards.
     * @param [options.trackColor] - Color to use for track lines.
     * @param [options.routeColor] - Color to use for route lines.
     * @returns A promise that will resolve to this instances once the GPX is loaded.
     */
    load(data: string | Document | Blob, options?: {
        clampToGround?: boolean;
        waypointImage?: string;
        trackImage?: string;
        trackColor?: string;
        routeColor?: string;
    }): Promise<GpxDataSource>;
}

/**
 * A {@link MaterialProperty} that maps to grid {@link Material} uniforms.
 * @param [options] - Object with the following properties:
 * @param [options.color = Color.WHITE] - A Property specifying the grid {@link Color}.
 * @param [options.cellAlpha = 0.1] - A numeric Property specifying cell alpha values.
 * @param [options.lineCount = new Cartesian2(8, 8)] - A {@link Cartesian2} Property specifying the number of grid lines along each axis.
 * @param [options.lineThickness = new Cartesian2(1.0, 1.0)] - A {@link Cartesian2} Property specifying the thickness of grid lines along each axis.
 * @param [options.lineOffset = new Cartesian2(0.0, 0.0)] - A {@link Cartesian2} Property specifying starting offset of grid lines along each axis.
 */
export class GridMaterialProperty {
    constructor(options?: {
        color?: Property | Color;
        cellAlpha?: Property | number;
        lineCount?: Property | Cartesian2;
        lineThickness?: Property | Cartesian2;
        lineOffset?: Property | Cartesian2;
    });
    /**
     * Gets a value indicating if this property is constant.  A property is considered
     * constant if getValue always returns the same result for the current definition.
     */
    readonly isConstant: boolean;
    /**
     * Gets the event that is raised whenever the definition of this property changes.
     * The definition is considered to have changed if a call to getValue would return
     * a different result for the same time.
     */
    readonly definitionChanged: Event;
    /**
     * Gets or sets the Property specifying the grid {@link Color}.
     */
    color: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying cell alpha values.
     */
    cellAlpha: Property | undefined;
    /**
     * Gets or sets the {@link Cartesian2} Property specifying the number of grid lines along each axis.
     */
    lineCount: Property | undefined;
    /**
     * Gets or sets the {@link Cartesian2} Property specifying the thickness of grid lines along each axis.
     */
    lineThickness: Property | undefined;
    /**
     * Gets or sets the {@link Cartesian2} Property specifying the starting offset of grid lines along each axis.
     */
    lineOffset: Property | undefined;
    /**
     * Gets the {@link Material} type at the provided time.
     * @param time - The time for which to retrieve the type.
     * @returns The type of material.
     */
    getType(time: JulianDate): string;
    /**
     * Gets the value of the property at the provided time.
     * @param time - The time for which to retrieve the value.
     * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
     * @returns The modified result parameter or a new instance if the result parameter was not supplied.
     */
    getValue(time: JulianDate, result?: any): any;
    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [other] - The other property.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    equals(other?: Property): boolean;
}

/**
 * An abstract class for updating ground geometry entities.
 * @param options - An object with the following properties:
 * @param options.entity - The entity containing the geometry to be visualized.
 * @param options.scene - The scene where visualization is taking place.
 * @param options.geometryOptions - Options for the geometry
 * @param options.geometryPropertyName - The geometry property name
 * @param options.observedPropertyNames - The entity properties this geometry cares about
 */
export class GroundGeometryUpdater {
    constructor(options: {
        entity: Entity;
        scene: Scene;
        geometryOptions: any;
        geometryPropertyName: string;
        observedPropertyNames: string[];
    });
    /**
     * Gets the zindex
     */
    readonly zIndex: number;
    /**
     * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.
     */
    destroy(): void;
}

/**
 * A {@link MaterialProperty} that maps to image {@link Material} uniforms.
 * @param [options] - Object with the following properties:
 * @param [options.image] - A Property specifying the Image, URL, Canvas, or Video.
 * @param [options.repeat = new Cartesian2(1.0, 1.0)] - A {@link Cartesian2} Property specifying the number of times the image repeats in each direction.
 * @param [options.color = Color.WHITE] - The color applied to the image
 * @param [options.transparent = false] - Set to true when the image has transparency (for example, when a png has transparent sections)
 */
export class ImageMaterialProperty {
    constructor(options?: {
        image?: Property | string | HTMLImageElement | HTMLCanvasElement | HTMLVideoElement;
        repeat?: Property | Cartesian2;
        color?: Property | Color;
        transparent?: Property | boolean;
    });
    /**
     * Gets a value indicating if this property is constant.  A property is considered
     * constant if getValue always returns the same result for the current definition.
     */
    readonly isConstant: boolean;
    /**
     * Gets the event that is raised whenever the definition of this property changes.
     * The definition is considered to have changed if a call to getValue would return
     * a different result for the same time.
     */
    readonly definitionChanged: Event;
    /**
     * Gets or sets the Property specifying Image, URL, Canvas, or Video to use.
     */
    image: Property | undefined;
    /**
     * Gets or sets the {@link Cartesian2} Property specifying the number of times the image repeats in each direction.
     */
    repeat: Property | undefined;
    /**
     * Gets or sets the Color Property specifying the desired color applied to the image.
     */
    color: Property | undefined;
    /**
     * Gets or sets the Boolean Property specifying whether the image has transparency
     */
    transparent: Property | undefined;
    /**
     * Gets the {@link Material} type at the provided time.
     * @param time - The time for which to retrieve the type.
     * @returns The type of material.
     */
    getType(time: JulianDate): string;
    /**
     * Gets the value of the property at the provided time.
     * @param time - The time for which to retrieve the value.
     * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
     * @returns The modified result parameter or a new instance if the result parameter was not supplied.
     */
    getValue(time: JulianDate, result?: any): any;
    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [other] - The other property.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    equals(other?: Property): boolean;
}

/**
 * Representation of <Camera> from KML
 * @param position - camera position
 * @param headingPitchRoll - camera orientation
 */
export class KmlCamera {
    constructor(position: Cartesian3, headingPitchRoll: HeadingPitchRoll);
}

export namespace KmlDataSource {
    /**
     * Initialization options for the `load` method.
     * [sourceUri] - Overrides the url to use for resolving relative links and other KML network features.
     * [clampToGround = false] - true if we want the geometry features (Polygons, LineStrings and LinearRings) clamped to the ground.
     * [ellipsoid = Ellipsoid.WGS84] - The global ellipsoid used for geographical calculations.
     * [screenOverlayContainer] - A container for ScreenOverlay images.
     */
    type LoadOptions = {
        sourceUri?: string;
        clampToGround?: boolean;
        ellipsoid?: Ellipsoid;
        screenOverlayContainer?: Element | string;
    };
    /**
     * Options for constructing a new KmlDataSource, or calling the static `load` method.
     * [camera] - The camera that is used for viewRefreshModes and sending camera properties to network links.
     * [canvas] - The canvas that is used for sending viewer properties to network links.
     * [credit] - A credit for the data source, which is displayed on the canvas.
     * [sourceUri] - Overrides the url to use for resolving relative links and other KML network features.
     * [clampToGround = false] - true if we want the geometry features (Polygons, LineStrings and LinearRings) clamped to the ground.
     * [ellipsoid = Ellipsoid.WGS84] - The global ellipsoid used for geographical calculations.
     * [screenOverlayContainer] - A container for ScreenOverlay images.
     */
    type ConstructorOptions = {
        camera?: Camera;
        canvas?: HTMLCanvasElement;
        credit?: Credit | string;
        sourceUri?: string;
        clampToGround?: boolean;
        ellipsoid?: Ellipsoid;
        screenOverlayContainer?: Element | string;
    };
}

/**
 * A {@link DataSource} which processes Keyhole Markup Language 2.2 (KML).
 * <p>
 * KML support in Cesium is incomplete, but a large amount of the standard,
 * as well as Google's <code>gx</code> extension namespace, is supported. See Github issue
 * {@link https://github.com/CesiumGS/cesium/issues/873|#873} for a
 * detailed list of what is and isn't supported. Cesium will also write information to the
 * console when it encounters most unsupported features.
 * </p>
 * <p>
 * Non visual feature data, such as <code>atom:author</code> and <code>ExtendedData</code>
 * is exposed via an instance of {@link KmlFeatureData}, which is added to each {@link Entity}
 * under the <code>kml</code> property.
 * </p>
 * @example
 * const viewer = new Cesium.Viewer('cesiumContainer');
 * viewer.dataSources.add(Cesium.KmlDataSource.load('../../SampleData/facilities.kmz',
 *      {
 *           camera: viewer.scene.camera,
 *           canvas: viewer.scene.canvas
 *      })
 * );
 * @param [options] - Object describing initialization options
 */
export class KmlDataSource {
    constructor(options?: KmlDataSource.ConstructorOptions);
    /**
     * The current size of this Canvas will be used to populate the Link parameters
     * for client height and width.
     */
    canvas: HTMLCanvasElement | undefined;
    /**
     * The position and orientation of this {@link Camera} will be used to
     * populate various camera parameters when making network requests.
     * Camera movement will determine when to trigger NetworkLink refresh if
     * <code>viewRefreshMode</code> is <code>onStop</code>.
     */
    camera: Camera | undefined;
    /**
     * Creates a Promise to a new instance loaded with the provided KML data.
     * @param data - A url, parsed KML document, or Blob containing binary KMZ data or a parsed KML document.
     * @param [options] - An object specifying configuration options
     * @returns A promise that will resolve to a new KmlDataSource instance once the KML is loaded.
     */
    static load(data: Resource | string | Document | Blob, options?: KmlDataSource.ConstructorOptions): Promise<KmlDataSource>;
    /**
     * Gets or sets a human-readable name for this instance.
     * This will be automatically be set to the KML document name on load.
     */
    name: string;
    /**
     * Gets the clock settings defined by the loaded KML. This represents the total
     * availability interval for all time-dynamic data. If the KML does not contain
     * time-dynamic data, this value is undefined.
     */
    clock: DataSourceClock;
    /**
     * Gets the collection of {@link Entity} instances.
     */
    entities: EntityCollection;
    /**
     * Gets a value indicating if the data source is currently loading data.
     */
    isLoading: boolean;
    /**
     * Gets an event that will be raised when the underlying data changes.
     */
    changedEvent: Event;
    /**
     * Gets an event that will be raised if an error is encountered during processing.
     */
    errorEvent: Event;
    /**
     * Gets an event that will be raised when the data source either starts or stops loading.
     */
    loadingEvent: Event;
    /**
     * Gets an event that will be raised when the data source refreshes a network link.
     */
    refreshEvent: Event;
    /**
     * Gets an event that will be raised when the data source finds an unsupported node type.
     */
    unsupportedNodeEvent: Event;
    /**
     * Gets whether or not this data source should be displayed.
     */
    show: boolean;
    /**
     * Gets or sets the clustering options for this data source. This object can be shared between multiple data sources.
     */
    clustering: EntityCluster;
    /**
     * Gets the credit that will be displayed for the data source
     */
    credit: Credit;
    /**
     * Gets the KML Tours that are used to guide the camera to specified destinations on given time intervals.
     */
    kmlTours: KmlTour[];
    /**
     * Asynchronously loads the provided KML data, replacing any existing data.
     * @param data - A url, parsed KML document, or Blob containing binary KMZ data or a parsed KML document.
     * @param [options] - An object specifying configuration options
     * @returns A promise that will resolve to this instances once the KML is loaded.
     */
    load(data: Resource | string | Document | Blob, options?: KmlDataSource.LoadOptions): Promise<KmlDataSource>;
    /**
     * Cleans up any non-entity elements created by the data source. Currently this only affects ScreenOverlay elements.
     */
    destroy(): void;
    /**
     * Updates any NetworkLink that require updating.
     * @param time - The simulation time.
     * @returns True if this data source is ready to be displayed at the provided time, false otherwise.
     */
    update(time: JulianDate): boolean;
}

/**
 * Contains KML Feature data loaded into the <code>Entity.kml</code> property by {@link KmlDataSource}.
 */
export class KmlFeatureData {
    constructor();
    /**
     * Gets the atom syndication format author field.
     */
    author: KmlFeatureData.Author;
    /**
     * Gets the link.
     */
    link: KmlFeatureData.Link;
    /**
     * Gets the unstructured address field.
     */
    address: string;
    /**
     * Gets the phone number.
     */
    phoneNumber: string;
    /**
     * Gets the snippet.
     */
    snippet: string;
    /**
     * Gets the extended data, parsed into a JSON object.
     * Currently only the <code>Data</code> property is supported.
     * <code>SchemaData</code> and custom data are ignored.
     */
    extendedData: string;
}

export namespace KmlFeatureData {
    /**
     * name - Gets the name.
     * uri - Gets the URI.
     * age - Gets the email.
     */
    type Author = {
        name: string;
        uri: string;
        age: number;
    };
    /**
     * href - Gets the href.
     * hreflang - Gets the language of the linked resource.
     * rel - Gets the link relation.
     * type - Gets the link type.
     * title - Gets the link title.
     * length - Gets the link length.
     */
    type Link = {
        href: string;
        hreflang: string;
        rel: string;
        type: string;
        title: string;
        length: string;
    };
}

/**
 * @param position - camera position
 * @param headingPitchRange - camera orientation
 */
export class KmlLookAt {
    constructor(position: Cartesian3, headingPitchRange: HeadingPitchRange);
}

/**
 * Describes a KmlTour, which uses KmlTourFlyTo, and KmlTourWait to
 * guide the camera to a specified destinations on given time intervals.
 * @param name - name parsed from KML
 * @param id - id parsed from KML
 * @param playlist - array with KmlTourFlyTos and KmlTourWaits
 */
export class KmlTour {
    constructor(name: string, id: string, playlist: any[]);
    /**
     * Id of kml gx:Tour entry
     */
    id: string;
    /**
     * Tour name
     */
    name: string;
    /**
     * Index of current entry from playlist
     */
    playlistIndex: number;
    /**
     * Array of playlist entries
     */
    playlist: any[];
    /**
     * Event will be called when tour starts to play,
     * before any playlist entry starts to play.
     */
    tourStart: Event;
    /**
     * Event will be called when all playlist entries are
     * played, or tour playback being canceled.
     *
     * If tour playback was terminated, event callback will
     * be called with terminated=true parameter.
     */
    tourEnd: Event;
    /**
     * Event will be called when entry from playlist starts to play.
     *
     * Event callback will be called with curent entry as first parameter.
     */
    entryStart: Event;
    /**
     * Event will be called when entry from playlist ends to play.
     *
     * Event callback will be called with following parameters:
     * 1. entry - entry
     * 2. terminated - true if playback was terminated by calling {@link KmlTour#stop}
     */
    entryEnd: Event;
    /**
     * Add entry to this tour playlist.
     * @param entry - an entry to add to the playlist.
     */
    addPlaylistEntry(entry: KmlTourFlyTo | KmlTourWait): void;
    /**
     * Play this tour.
     * @param widget - The widget.
     * @param [cameraOptions] - these options will be merged with {@link Camera#flyTo}
     * options for FlyTo playlist entries.
     */
    play(widget: CesiumWidget, cameraOptions?: any): void;
    /**
     * Stop curently playing tour.
     */
    stop(): void;
}

/**
 * Transitions the KmlTour to the next destination. This transition is facilitated
 * using a specified flyToMode over a given number of seconds.
 * @param duration - entry duration
 * @param flyToMode - KML fly to mode: bounce, smooth, etc
 * @param view - KmlCamera or KmlLookAt
 */
export class KmlTourFlyTo {
    constructor(duration: number, flyToMode: string, view: KmlCamera | KmlLookAt);
    /**
     * Play this playlist entry
     * @param done - function which will be called when playback ends
     * @param camera - Cesium camera
     * @param [cameraOptions] - which will be merged with camera flyTo options. See {@link Camera#flyTo}
     */
    play(done: KmlTourFlyTo.DoneCallback, camera: Camera, cameraOptions?: any): void;
    /**
     * Stop execution of curent entry. Cancel camera flyTo
     */
    stop(): void;
    /**
     * Returns options for {@link Camera#flyTo} or {@link Camera#flyToBoundingSphere}
     * depends on this.view type.
     * @param cameraOptions - options to merge with generated. See {@link Camera#flyTo}
     * @returns {@link Camera#flyTo} or {@link Camera#flyToBoundingSphere} options
     */
    getCameraOptions(cameraOptions: any): any;
}

export namespace KmlTourFlyTo {
    /**
     * A function that will be executed when the flight completes.
     * @param terminated - true if {@link KmlTourFlyTo#stop} was
     * called before entry done playback.
     */
    type DoneCallback = (terminated: boolean) => void;
}

/**
 * Pauses the KmlTour for a given number of seconds.
 * @param duration - entry duration
 */
export class KmlTourWait {
    constructor(duration: number);
    /**
     * Play this playlist entry
     * @param done - function which will be called when playback ends
     */
    play(done: KmlTourWait.DoneCallback): void;
    /**
     * Stop execution of curent entry, cancel curent timeout
     */
    stop(): void;
}

export namespace KmlTourWait {
    /**
     * A function which will be called when playback ends.
     * @param terminated - true if {@link KmlTourWait#stop} was
     * called before entry done playback.
     */
    type DoneCallback = (terminated: boolean) => void;
}

export namespace LabelGraphics {
    /**
     * Initialization options for the LabelGraphics constructor
     * [show = true] - A boolean Property specifying the visibility of the label.
     * [text] - A Property specifying the text. Explicit newlines '\n' are supported.
     * [font = '30px sans-serif'] - A Property specifying the CSS font.
     * [style = LabelStyle.FILL] - A Property specifying the {@link LabelStyle}.
     * [scale = 1.0] - A numeric Property specifying the scale to apply to the text.
     * [showBackground = false] - A boolean Property specifying the visibility of the background behind the label.
     * [backgroundColor = new Color(0.165, 0.165, 0.165, 0.8)] - A Property specifying the background {@link Color}.
     * [backgroundPadding = new Cartesian2(7, 5)] - A {@link Cartesian2} Property specifying the horizontal and vertical background padding in pixels.
     * [pixelOffset = Cartesian2.ZERO] - A {@link Cartesian2} Property specifying the pixel offset.
     * [eyeOffset = Cartesian3.ZERO] - A {@link Cartesian3} Property specifying the eye offset.
     * [horizontalOrigin = HorizontalOrigin.CENTER] - A Property specifying the {@link HorizontalOrigin}.
     * [verticalOrigin = VerticalOrigin.CENTER] - A Property specifying the {@link VerticalOrigin}.
     * [heightReference = HeightReference.NONE] - A Property specifying what the height is relative to.
     * [fillColor = Color.WHITE] - A Property specifying the fill {@link Color}.
     * [outlineColor = Color.BLACK] - A Property specifying the outline {@link Color}.
     * [outlineWidth = 1.0] - A numeric Property specifying the outline width.
     * [translucencyByDistance] - A {@link NearFarScalar} Property used to set translucency based on distance from the camera.
     * [pixelOffsetScaleByDistance] - A {@link NearFarScalar} Property used to set pixelOffset based on distance from the camera.
     * [scaleByDistance] - A {@link NearFarScalar} Property used to set scale based on distance from the camera.
     * [distanceDisplayCondition] - A Property specifying at what distance from the camera that this label will be displayed.
     * [disableDepthTestDistance] - A Property specifying the distance from the camera at which to disable the depth test to.
     */
    type ConstructorOptions = {
        show?: Property | boolean;
        text?: Property | string;
        font?: Property | string;
        style?: Property | LabelStyle;
        scale?: Property | number;
        showBackground?: Property | boolean;
        backgroundColor?: Property | Color;
        backgroundPadding?: Property | Cartesian2;
        pixelOffset?: Property | Cartesian2;
        eyeOffset?: Property | Cartesian3;
        horizontalOrigin?: Property | HorizontalOrigin;
        verticalOrigin?: Property | VerticalOrigin;
        heightReference?: Property | HeightReference;
        fillColor?: Property | Color;
        outlineColor?: Property | Color;
        outlineWidth?: Property | number;
        translucencyByDistance?: Property | NearFarScalar;
        pixelOffsetScaleByDistance?: Property | NearFarScalar;
        scaleByDistance?: Property | NearFarScalar;
        distanceDisplayCondition?: Property | DistanceDisplayCondition;
        disableDepthTestDistance?: Property | number;
    };
}

/**
 * Describes a two dimensional label located at the position of the containing {@link Entity}.
 * <p>
 * <div align='center'>
 * <img src='Images/Label.png' width='400' height='300' /><br />
 * Example labels
 * </div>
 * </p>
 * @param [options] - Object describing initialization options
 */
export class LabelGraphics {
    constructor(options?: LabelGraphics.ConstructorOptions);
    /**
     * Gets the event that is raised whenever a property or sub-property is changed or modified.
     */
    readonly definitionChanged: Event;
    /**
     * Gets or sets the boolean Property specifying the visibility of the label.
     */
    show: Property | undefined;
    /**
     * Gets or sets the string Property specifying the text of the label.
     * Explicit newlines '\n' are supported.
     */
    text: Property | undefined;
    /**
     * Gets or sets the string Property specifying the font in CSS syntax.
     */
    font: Property | undefined;
    /**
     * Gets or sets the Property specifying the {@link LabelStyle}.
     */
    style: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the uniform scale to apply to the image.
     * A scale greater than <code>1.0</code> enlarges the label while a scale less than <code>1.0</code> shrinks it.
     * <p>
     * <div align='center'>
     * <img src='Images/Label.setScale.png' width='400' height='300' /><br/>
     * From left to right in the above image, the scales are <code>0.5</code>, <code>1.0</code>,
     * and <code>2.0</code>.
     * </div>
     * </p>
     */
    scale: Property | undefined;
    /**
     * Gets or sets the boolean Property specifying the visibility of the background behind the label.
     */
    showBackground: Property | undefined;
    /**
     * Gets or sets the Property specifying the background {@link Color}.
     */
    backgroundColor: Property | undefined;
    /**
     * Gets or sets the {@link Cartesian2} Property specifying the label's horizontal and vertical
     * background padding in pixels.
     */
    backgroundPadding: Property | undefined;
    /**
     * Gets or sets the {@link Cartesian2} Property specifying the label's pixel offset in screen space
     * from the origin of this label.  This is commonly used to align multiple labels and labels at
     * the same position, e.g., an image and text.  The screen space origin is the top, left corner of the
     * canvas; <code>x</code> increases from left to right, and <code>y</code> increases from top to bottom.
     * <p>
     * <div align='center'>
     * <table border='0' cellpadding='5'><tr>
     * <td align='center'><code>default</code><br/><img src='Images/Label.setPixelOffset.default.png' width='250' height='188' /></td>
     * <td align='center'><code>l.pixeloffset = new Cartesian2(25, 75);</code><br/><img src='Images/Label.setPixelOffset.x50y-25.png' width='250' height='188' /></td>
     * </tr></table>
     * The label's origin is indicated by the yellow point.
     * </div>
     * </p>
     */
    pixelOffset: Property | undefined;
    /**
     * Gets or sets the {@link Cartesian3} Property specifying the label's offset in eye coordinates.
     * Eye coordinates is a left-handed coordinate system, where <code>x</code> points towards the viewer's
     * right, <code>y</code> points up, and <code>z</code> points into the screen.
     * <p>
     * An eye offset is commonly used to arrange multiple labels or objects at the same position, e.g., to
     * arrange a label above its corresponding 3D model.
     * </p>
     * Below, the label is positioned at the center of the Earth but an eye offset makes it always
     * appear on top of the Earth regardless of the viewer's or Earth's orientation.
     * <p>
     * <div align='center'>
     * <table border='0' cellpadding='5'><tr>
     * <td align='center'><img src='Images/Billboard.setEyeOffset.one.png' width='250' height='188' /></td>
     * <td align='center'><img src='Images/Billboard.setEyeOffset.two.png' width='250' height='188' /></td>
     * </tr></table>
     * <code>l.eyeOffset = new Cartesian3(0.0, 8000000.0, 0.0);</code><br /><br />
     * </div>
     * </p>
     */
    eyeOffset: Property | undefined;
    /**
     * Gets or sets the Property specifying the {@link HorizontalOrigin}.
     */
    horizontalOrigin: Property | undefined;
    /**
     * Gets or sets the Property specifying the {@link VerticalOrigin}.
     */
    verticalOrigin: Property | undefined;
    /**
     * Gets or sets the Property specifying the {@link HeightReference}.
     */
    heightReference: Property | undefined;
    /**
     * Gets or sets the Property specifying the fill {@link Color}.
     */
    fillColor: Property | undefined;
    /**
     * Gets or sets the Property specifying the outline {@link Color}.
     */
    outlineColor: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the outline width.
     */
    outlineWidth: Property | undefined;
    /**
     * Gets or sets {@link NearFarScalar} Property specifying the translucency of the label based on the distance from the camera.
     * A label's translucency will interpolate between the {@link NearFarScalar#nearValue} and
     * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
     * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
     * Outside of these ranges the label's translucency remains clamped to the nearest bound.
     */
    translucencyByDistance: Property | undefined;
    /**
     * Gets or sets {@link NearFarScalar} Property specifying the pixel offset of the label based on the distance from the camera.
     * A label's pixel offset will interpolate between the {@link NearFarScalar#nearValue} and
     * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
     * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
     * Outside of these ranges the label's pixel offset remains clamped to the nearest bound.
     */
    pixelOffsetScaleByDistance: Property | undefined;
    /**
     * Gets or sets near and far scaling properties of a Label based on the label's distance from the camera.
     * A label's scale will interpolate between the {@link NearFarScalar#nearValue} and
     * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
     * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
     * Outside of these ranges the label's scale remains clamped to the nearest bound.  If undefined,
     * scaleByDistance will be disabled.
     */
    scaleByDistance: Property | undefined;
    /**
     * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this label will be displayed.
     */
    distanceDisplayCondition: Property | undefined;
    /**
     * Gets or sets the distance from the camera at which to disable the depth test to, for example, prevent clipping against terrain.
     * When set to zero, the depth test is always applied. When set to Number.POSITIVE_INFINITY, the depth test is never applied.
     */
    disableDepthTestDistance: Property | undefined;
    /**
     * Duplicates this instance.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new instance if one was not provided.
     */
    clone(result?: LabelGraphics): LabelGraphics;
    /**
     * Assigns each unassigned property on this object to the value
     * of the same property on the provided source object.
     * @param source - The object to be merged into this object.
     */
    merge(source: LabelGraphics): void;
}

/**
 * A {@link Visualizer} which maps the {@link LabelGraphics} instance
 * in {@link Entity#label} to a {@link Label}.
 * @param entityCluster - The entity cluster to manage the collection of billboards and optionally cluster with other entities.
 * @param entityCollection - The entityCollection to visualize.
 */
export class LabelVisualizer {
    constructor(entityCluster: EntityCluster, entityCollection: EntityCollection);
    /**
     * Updates the primitives created by this visualizer to match their
     * Entity counterpart at the given time.
     * @param time - The time to update to.
     * @returns This function always returns true.
     */
    update(time: JulianDate): boolean;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * @returns True if this object was destroyed; otherwise, false.
     */
    isDestroyed(): boolean;
    /**
     * Removes and destroys all primitives created by this instance.
     */
    destroy(): void;
}

/**
 * The interface for all {@link Property} objects that represent {@link Material} uniforms.
 * This type defines an interface and cannot be instantiated directly.
 */
export class MaterialProperty {
    constructor();
    /**
     * Gets a value indicating if this property is constant.  A property is considered
     * constant if getValue always returns the same result for the current definition.
     */
    readonly isConstant: boolean;
    /**
     * Gets the event that is raised whenever the definition of this property changes.
     * The definition is considered to have changed if a call to getValue would return
     * a different result for the same time.
     */
    readonly definitionChanged: Event;
    /**
     * Gets the {@link Material} type at the provided time.
     * @param time - The time for which to retrieve the type.
     * @returns The type of material.
     */
    getType(time: JulianDate): string;
    /**
     * Gets the value of the property at the provided time.
     * @param time - The time for which to retrieve the value.
     * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
     * @returns The modified result parameter or a new instance if the result parameter was not supplied.
     */
    getValue(time: JulianDate, result?: any): any;
    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [other] - The other property.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    equals(other?: Property): boolean;
}

export namespace ModelGraphics {
    /**
     * Initialization options for the ModelGraphics constructor
     * [show = true] - A boolean Property specifying the visibility of the model.
     * [uri] - A string or Resource Property specifying the URI of the glTF asset.
     * [scale = 1.0] - A numeric Property specifying a uniform linear scale.
     * [minimumPixelSize = 0.0] - A numeric Property specifying the approximate minimum pixel size of the model regardless of zoom.
     * [maximumScale] - The maximum scale size of a model. An upper limit for minimumPixelSize.
     * [incrementallyLoadTextures = true] - Determine if textures may continue to stream in after the model is loaded.
     * [runAnimations = true] - A boolean Property specifying if glTF animations specified in the model should be started.
     * [clampAnimations = true] - A boolean Property specifying if glTF animations should hold the last pose for time durations with no keyframes.
     * [shadows = ShadowMode.ENABLED] - An enum Property specifying whether the model casts or receives shadows from light sources.
     * [heightReference = HeightReference.NONE] - A Property specifying what the height is relative to.
     * [silhouetteColor = Color.RED] - A Property specifying the {@link Color} of the silhouette.
     * [silhouetteSize = 0.0] - A numeric Property specifying the size of the silhouette in pixels.
     * [color = Color.WHITE] - A Property specifying the {@link Color} that blends with the model's rendered color.
     * [colorBlendMode = ColorBlendMode.HIGHLIGHT] - An enum Property specifying how the color blends with the model.
     * [colorBlendAmount = 0.5] - A numeric Property specifying the color strength when the <code>colorBlendMode</code> is <code>MIX</code>. A value of 0.0 results in the model's rendered color while a value of 1.0 results in a solid color, with any value in-between resulting in a mix of the two.
     * [imageBasedLightingFactor = new Cartesian2(1.0, 1.0)] - A property specifying the contribution from diffuse and specular image-based lighting.
     * [lightColor] - A property specifying the light color when shading the model. When <code>undefined</code> the scene's light color is used instead.
     * [distanceDisplayCondition] - A Property specifying at what distance from the camera that this model will be displayed.
     * [nodeTransformations] - An object, where keys are names of nodes, and values are {@link TranslationRotationScale} Properties describing the transformation to apply to that node. The transformation is applied after the node's existing transformation as specified in the glTF, and does not replace the node's existing transformation.
     * [articulations] - An object, where keys are composed of an articulation name, a single space, and a stage name, and the values are numeric properties.
     * [clippingPlanes] - A property specifying the {@link ClippingPlaneCollection} used to selectively disable rendering the model.
     * [customShader] - A property specifying the {@link CustomShader} to apply to this model.
     */
    type ConstructorOptions = {
        show?: Property | boolean;
        uri?: Property | string | Resource;
        scale?: Property | number;
        minimumPixelSize?: Property | number;
        maximumScale?: Property | number;
        incrementallyLoadTextures?: Property | boolean;
        runAnimations?: Property | boolean;
        clampAnimations?: Property | boolean;
        shadows?: Property | ShadowMode;
        heightReference?: Property | HeightReference;
        silhouetteColor?: Property | Color;
        silhouetteSize?: Property | number;
        color?: Property | Color;
        colorBlendMode?: Property | ColorBlendMode;
        colorBlendAmount?: Property | number;
        imageBasedLightingFactor?: Property | Cartesian2;
        lightColor?: Property | Color;
        distanceDisplayCondition?: Property | DistanceDisplayCondition;
        nodeTransformations?: PropertyBag | {
            [key: string]: TranslationRotationScale;
        };
        articulations?: PropertyBag | {
            [key: string]: number;
        };
        clippingPlanes?: Property | ClippingPlaneCollection;
        customShader?: Property | CustomShader;
    };
}

/**
 * A 3D model based on {@link https://github.com/KhronosGroup/glTF|glTF}, the runtime asset format for WebGL, OpenGL ES, and OpenGL.
 * The position and orientation of the model is determined by the containing {@link Entity}.
 * <p>
 * Cesium includes support for glTF geometry, materials, animations, and skinning.
 * Cameras and lights are not currently supported.
 * </p>
 * @param [options] - Object describing initialization options
 */
export class ModelGraphics {
    constructor(options?: ModelGraphics.ConstructorOptions);
    /**
     * Gets the event that is raised whenever a property or sub-property is changed or modified.
     */
    readonly definitionChanged: Event;
    /**
     * Gets or sets the boolean Property specifying the visibility of the model.
     */
    show: Property | undefined;
    /**
     * Gets or sets the string Property specifying the URI of the glTF asset.
     */
    uri: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying a uniform linear scale
     * for this model. Values greater than 1.0 increase the size of the model while
     * values less than 1.0 decrease it.
     */
    scale: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the approximate minimum
     * pixel size of the model regardless of zoom. This can be used to ensure that
     * a model is visible even when the viewer zooms out.  When <code>0.0</code>,
     * no minimum size is enforced.
     */
    minimumPixelSize: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the maximum scale
     * size of a model. This property is used as an upper limit for
     * {@link ModelGraphics#minimumPixelSize}.
     */
    maximumScale: Property | undefined;
    /**
     * Get or sets the boolean Property specifying whether textures
     * may continue to stream in after the model is loaded.
     */
    incrementallyLoadTextures: Property | undefined;
    /**
     * Gets or sets the boolean Property specifying if glTF animations should be run.
     */
    runAnimations: Property | undefined;
    /**
     * Gets or sets the boolean Property specifying if glTF animations should hold the last pose for time durations with no keyframes.
     */
    clampAnimations: Property | undefined;
    /**
     * Get or sets the enum Property specifying whether the model
     * casts or receives shadows from light sources.
     */
    shadows: Property | undefined;
    /**
     * Gets or sets the Property specifying the {@link HeightReference}.
     */
    heightReference: Property | undefined;
    /**
     * Gets or sets the Property specifying the {@link Color} of the silhouette.
     */
    silhouetteColor: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the size of the silhouette in pixels.
     */
    silhouetteSize: Property | undefined;
    /**
     * Gets or sets the Property specifying the {@link Color} that blends with the model's rendered color.
     */
    color: Property | undefined;
    /**
     * Gets or sets the enum Property specifying how the color blends with the model.
     */
    colorBlendMode: Property | undefined;
    /**
     * A numeric Property specifying the color strength when the <code>colorBlendMode</code> is MIX.
     * A value of 0.0 results in the model's rendered color while a value of 1.0 results in a solid color, with
     * any value in-between resulting in a mix of the two.
     */
    colorBlendAmount: Property | undefined;
    /**
     * A property specifying the {@link Cartesian2} used to scale the diffuse and specular image-based lighting contribution to the final color.
     */
    imageBasedLightingFactor: Property | undefined;
    /**
     * A property specifying the {@link Cartesian3} light color when shading the model. When <code>undefined</code> the scene's light color is used instead.
     */
    lightColor: Property | undefined;
    /**
     * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this model will be displayed.
     */
    distanceDisplayCondition: Property | undefined;
    /**
     * Gets or sets the set of node transformations to apply to this model.  This is represented as an {@link PropertyBag}, where keys are
     * names of nodes, and values are {@link TranslationRotationScale} Properties describing the transformation to apply to that node.
     * The transformation is applied after the node's existing transformation as specified in the glTF, and does not replace the node's existing transformation.
     */
    nodeTransformations: PropertyBag;
    /**
     * Gets or sets the set of articulation values to apply to this model.  This is represented as an {@link PropertyBag}, where keys are
     * composed as the name of the articulation, a single space, and the name of the stage.
     */
    articulations: PropertyBag;
    /**
     * A property specifying the {@link ClippingPlaneCollection} used to selectively disable rendering the model.
     */
    clippingPlanes: Property | undefined;
    /**
     * Gets or sets the {@link CustomShader} to apply to this model. When <code>undefined</code>, no custom shader code is used.
     */
    customShader: Property | undefined;
    /**
     * Duplicates this instance.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new instance if one was not provided.
     */
    clone(result?: ModelGraphics): ModelGraphics;
    /**
     * Assigns each unassigned property on this object to the value
     * of the same property on the provided source object.
     * @param source - The object to be merged into this object.
     */
    merge(source: ModelGraphics): void;
}

/**
 * A {@link Visualizer} which maps {@link Entity#model} to a {@link Model}.
 * @param scene - The scene the primitives will be rendered in.
 * @param entityCollection - The entityCollection to visualize.
 */
export class ModelVisualizer {
    constructor(scene: Scene, entityCollection: EntityCollection);
    /**
     * Updates models created this visualizer to match their
     * Entity counterpart at the given time.
     * @param time - The time to update to.
     * @returns This function always returns true.
     */
    update(time: JulianDate): boolean;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * @returns True if this object was destroyed; otherwise, false.
     */
    isDestroyed(): boolean;
    /**
     * Removes and destroys all primitives created by this instance.
     */
    destroy(): void;
}

/**
 * A {@link Property} that produces {@link TranslationRotationScale} data.
 * @param [options] - Object with the following properties:
 * @param [options.translation = Cartesian3.ZERO] - A {@link Cartesian3} Property specifying the (x, y, z) translation to apply to the node.
 * @param [options.rotation = Quaternion.IDENTITY] - A {@link Quaternion} Property specifying the (x, y, z, w) rotation to apply to the node.
 * @param [options.scale = new Cartesian3(1.0, 1.0, 1.0)] - A {@link Cartesian3} Property specifying the (x, y, z) scaling to apply to the node.
 */
export class NodeTransformationProperty {
    constructor(options?: {
        translation?: Property | Cartesian3;
        rotation?: Property | Quaternion;
        scale?: Property | Cartesian3;
    });
    /**
     * Gets a value indicating if this property is constant.  A property is considered
     * constant if getValue always returns the same result for the current definition.
     */
    readonly isConstant: boolean;
    /**
     * Gets the event that is raised whenever the definition of this property changes.
     * The definition is considered to have changed if a call to getValue would return
     * a different result for the same time.
     */
    readonly definitionChanged: Event;
    /**
     * Gets or sets the {@link Cartesian3} Property specifying the (x, y, z) translation to apply to the node.
     */
    translation: Property | undefined;
    /**
     * Gets or sets the {@link Quaternion} Property specifying the (x, y, z, w) rotation to apply to the node.
     */
    rotation: Property | undefined;
    /**
     * Gets or sets the {@link Cartesian3} Property specifying the (x, y, z) scaling to apply to the node.
     */
    scale: Property | undefined;
    /**
     * Gets the value of the property at the provided time.
     * @param time - The time for which to retrieve the value.
     * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
     * @returns The modified result parameter or a new instance if the result parameter was not supplied.
     */
    getValue(time: JulianDate, result?: TranslationRotationScale): TranslationRotationScale;
    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [other] - The other property.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    equals(other?: Property): boolean;
}

export namespace PathGraphics {
    /**
     * Initialization options for the PathGraphics constructor
     * [show = true] - A boolean Property specifying the visibility of the path.
     * [leadTime] - A Property specifying the number of seconds in front the object to show.
     * [trailTime] - A Property specifying the number of seconds behind of the object to show.
     * [width = 1.0] - A numeric Property specifying the width in pixels.
     * [resolution = 60] - A numeric Property specifying the maximum number of seconds to step when sampling the position.
     * [material = Color.WHITE] - A Property specifying the material used to draw the path.
     * [distanceDisplayCondition] - A Property specifying at what distance from the camera that this path will be displayed.
     */
    type ConstructorOptions = {
        show?: Property | boolean;
        leadTime?: Property | number;
        trailTime?: Property | number;
        width?: Property | number;
        resolution?: Property | number;
        material?: MaterialProperty | Color;
        distanceDisplayCondition?: Property | DistanceDisplayCondition;
    };
}

/**
 * Describes a polyline defined as the path made by an {@link Entity} as it moves over time.
 * @param [options] - Object describing initialization options
 */
export class PathGraphics {
    constructor(options?: PathGraphics.ConstructorOptions);
    /**
     * Gets the event that is raised whenever a property or sub-property is changed or modified.
     */
    readonly definitionChanged: Event;
    /**
     * Gets or sets the boolean Property specifying the visibility of the path.
     */
    show: Property | undefined;
    /**
     * Gets or sets the Property specifying the number of seconds in front of the object to show.
     */
    leadTime: Property | undefined;
    /**
     * Gets or sets the Property specifying the number of seconds behind the object to show.
     */
    trailTime: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the width in pixels.
     */
    width: Property | undefined;
    /**
     * Gets or sets the Property specifying the maximum number of seconds to step when sampling the position.
     */
    resolution: Property | undefined;
    /**
     * Gets or sets the Property specifying the material used to draw the path.
     */
    material: MaterialProperty;
    /**
     * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this path will be displayed.
     */
    distanceDisplayCondition: Property | undefined;
    /**
     * Duplicates this instance.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new instance if one was not provided.
     */
    clone(result?: PathGraphics): PathGraphics;
    /**
     * Assigns each unassigned property on this object to the value
     * of the same property on the provided source object.
     * @param source - The object to be merged into this object.
     */
    merge(source: PathGraphics): void;
}

/**
 * A {@link Visualizer} which maps {@link Entity#path} to a {@link Polyline}.
 * @param scene - The scene the primitives will be rendered in.
 * @param entityCollection - The entityCollection to visualize.
 */
export class PathVisualizer {
    constructor(scene: Scene, entityCollection: EntityCollection);
    /**
     * Updates all of the primitives created by this visualizer to match their
     * Entity counterpart at the given time.
     * @param time - The time to update to.
     * @returns This function always returns true.
     */
    update(time: JulianDate): boolean;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * @returns True if this object was destroyed; otherwise, false.
     */
    isDestroyed(): boolean;
    /**
     * Removes and destroys all primitives created by this instance.
     */
    destroy(): void;
}

/**
 * A {@link GeometryUpdater} for planes.
 * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
 * @param entity - The entity containing the geometry to be visualized.
 * @param scene - The scene where visualization is taking place.
 */
export class PlaneGeometryUpdater {
    constructor(entity: Entity, scene: Scene);
    /**
     * Creates the geometry instance which represents the fill of the geometry.
     * @param time - The time to use when retrieving initial attribute values.
     * @returns The geometry instance representing the filled portion of the geometry.
     */
    createFillGeometryInstance(time: JulianDate): GeometryInstance;
    /**
     * Creates the geometry instance which represents the outline of the geometry.
     * @param time - The time to use when retrieving initial attribute values.
     * @returns The geometry instance representing the outline portion of the geometry.
     */
    createOutlineGeometryInstance(time: JulianDate): GeometryInstance;
}

export namespace PlaneGraphics {
    /**
     * Initialization options for the PlaneGraphics constructor
     * [show = true] - A boolean Property specifying the visibility of the plane.
     * [plane] - A {@link Plane} Property specifying the normal and distance for the plane.
     * [dimensions] - A {@link Cartesian2} Property specifying the width and height of the plane.
     * [fill = true] - A boolean Property specifying whether the plane is filled with the provided material.
     * [material = Color.WHITE] - A Property specifying the material used to fill the plane.
     * [outline = false] - A boolean Property specifying whether the plane is outlined.
     * [outlineColor = Color.BLACK] - A Property specifying the {@link Color} of the outline.
     * [outlineWidth = 1.0] - A numeric Property specifying the width of the outline.
     * [shadows = ShadowMode.DISABLED] - An enum Property specifying whether the plane casts or receives shadows from light sources.
     * [distanceDisplayCondition] - A Property specifying at what distance from the camera that this plane will be displayed.
     */
    type ConstructorOptions = {
        show?: Property | boolean;
        plane?: Property | Plane;
        dimensions?: Property | Cartesian2;
        fill?: Property | boolean;
        material?: MaterialProperty | Color;
        outline?: Property | boolean;
        outlineColor?: Property | Color;
        outlineWidth?: Property | number;
        shadows?: Property | ShadowMode;
        distanceDisplayCondition?: Property | DistanceDisplayCondition;
    };
}

/**
 * Describes a plane. The center position and orientation are determined by the containing {@link Entity}.
 * @param [options] - Object describing initialization options
 */
export class PlaneGraphics {
    constructor(options?: PlaneGraphics.ConstructorOptions);
    /**
     * Gets the event that is raised whenever a property or sub-property is changed or modified.
     */
    readonly definitionChanged: Event;
    /**
     * Gets or sets the boolean Property specifying the visibility of the plane.
     */
    show: Property | undefined;
    /**
     * Gets or sets the {@link Plane} Property specifying the normal and distance of the plane.
     */
    plane: Property | undefined;
    /**
     * Gets or sets the {@link Cartesian2} Property specifying the width and height of the plane.
     */
    dimensions: Property | undefined;
    /**
     * Gets or sets the boolean Property specifying whether the plane is filled with the provided material.
     */
    fill: Property | undefined;
    /**
     * Gets or sets the material used to fill the plane.
     */
    material: MaterialProperty;
    /**
     * Gets or sets the Property specifying whether the plane is outlined.
     */
    outline: Property | undefined;
    /**
     * Gets or sets the Property specifying the {@link Color} of the outline.
     */
    outlineColor: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the width of the outline.
     * <p>
     * Note: This property will be ignored on all major browsers on Windows platforms. For details, see (@link https://github.com/CesiumGS/cesium/issues/40}.
     * </p>
     */
    outlineWidth: Property | undefined;
    /**
     * Get or sets the enum Property specifying whether the plane
     * casts or receives shadows from light sources.
     */
    shadows: Property | undefined;
    /**
     * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this plane will be displayed.
     */
    distanceDisplayCondition: Property | undefined;
    /**
     * Duplicates this instance.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new instance if one was not provided.
     */
    clone(result?: PlaneGraphics): PlaneGraphics;
    /**
     * Assigns each unassigned property on this object to the value
     * of the same property on the provided source object.
     * @param source - The object to be merged into this object.
     */
    merge(source: PlaneGraphics): void;
}

export namespace PointGraphics {
    /**
     * Initialization options for the PointGraphics constructor
     * [show = true] - A boolean Property specifying the visibility of the point.
     * [pixelSize = 1] - A numeric Property specifying the size in pixels.
     * [heightReference = HeightReference.NONE] - A Property specifying what the height is relative to.
     * [color = Color.WHITE] - A Property specifying the {@link Color} of the point.
     * [outlineColor = Color.BLACK] - A Property specifying the {@link Color} of the outline.
     * [outlineWidth = 0] - A numeric Property specifying the the outline width in pixels.
     * [scaleByDistance] - A {@link NearFarScalar} Property used to scale the point based on distance.
     * [translucencyByDistance] - A {@link NearFarScalar} Property used to set translucency based on distance from the camera.
     * [distanceDisplayCondition] - A Property specifying at what distance from the camera that this point will be displayed.
     * [disableDepthTestDistance] - A Property specifying the distance from the camera at which to disable the depth test to.
     */
    type ConstructorOptions = {
        show?: Property | boolean;
        pixelSize?: Property | number;
        heightReference?: Property | HeightReference;
        color?: Property | Color;
        outlineColor?: Property | Color;
        outlineWidth?: Property | number;
        scaleByDistance?: Property | NearFarScalar;
        translucencyByDistance?: Property | NearFarScalar;
        distanceDisplayCondition?: Property | DistanceDisplayCondition;
        disableDepthTestDistance?: Property | number;
    };
}

/**
 * Describes a graphical point located at the position of the containing {@link Entity}.
 * @param [options] - Object describing initialization options
 */
export class PointGraphics {
    constructor(options?: PointGraphics.ConstructorOptions);
    /**
     * Gets the event that is raised whenever a property or sub-property is changed or modified.
     */
    readonly definitionChanged: Event;
    /**
     * Gets or sets the boolean Property specifying the visibility of the point.
     */
    show: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the size in pixels.
     */
    pixelSize: Property | undefined;
    /**
     * Gets or sets the Property specifying the {@link HeightReference}.
     */
    heightReference: Property | undefined;
    /**
     * Gets or sets the Property specifying the {@link Color} of the point.
     */
    color: Property | undefined;
    /**
     * Gets or sets the Property specifying the {@link Color} of the outline.
     */
    outlineColor: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the the outline width in pixels.
     */
    outlineWidth: Property | undefined;
    /**
     * Gets or sets the {@link NearFarScalar} Property used to scale the point based on distance.
     * If undefined, a constant size is used.
     */
    scaleByDistance: Property | undefined;
    /**
     * Gets or sets {@link NearFarScalar} Property specifying the translucency of the point based on the distance from the camera.
     * A point's translucency will interpolate between the {@link NearFarScalar#nearValue} and
     * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
     * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
     * Outside of these ranges the points's translucency remains clamped to the nearest bound.
     */
    translucencyByDistance: Property | undefined;
    /**
     * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this point will be displayed.
     */
    distanceDisplayCondition: Property | undefined;
    /**
     * Gets or sets the distance from the camera at which to disable the depth test to, for example, prevent clipping against terrain.
     * When set to zero, the depth test is always applied. When set to Number.POSITIVE_INFINITY, the depth test is never applied.
     */
    disableDepthTestDistance: Property | undefined;
    /**
     * Duplicates this instance.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new instance if one was not provided.
     */
    clone(result?: PointGraphics): PointGraphics;
    /**
     * Assigns each unassigned property on this object to the value
     * of the same property on the provided source object.
     * @param source - The object to be merged into this object.
     */
    merge(source: PointGraphics): void;
}

/**
 * A {@link Visualizer} which maps {@link Entity#point} to a {@link PointPrimitive}.
 * @param entityCluster - The entity cluster to manage the collection of billboards and optionally cluster with other entities.
 * @param entityCollection - The entityCollection to visualize.
 */
export class PointVisualizer {
    constructor(entityCluster: EntityCluster, entityCollection: EntityCollection);
    /**
     * Updates the primitives created by this visualizer to match their
     * Entity counterpart at the given time.
     * @param time - The time to update to.
     * @returns This function always returns true.
     */
    update(time: JulianDate): boolean;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * @returns True if this object was destroyed; otherwise, false.
     */
    isDestroyed(): boolean;
    /**
     * Removes and destroys all primitives created by this instance.
     */
    destroy(): void;
}

/**
 * A {@link GeometryUpdater} for polygons.
 * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
 * @param entity - The entity containing the geometry to be visualized.
 * @param scene - The scene where visualization is taking place.
 */
export class PolygonGeometryUpdater {
    constructor(entity: Entity, scene: Scene);
    /**
     * Creates the geometry instance which represents the fill of the geometry.
     * @param time - The time to use when retrieving initial attribute values.
     * @returns The geometry instance representing the filled portion of the geometry.
     */
    createFillGeometryInstance(time: JulianDate): GeometryInstance;
    /**
     * Creates the geometry instance which represents the outline of the geometry.
     * @param time - The time to use when retrieving initial attribute values.
     * @returns The geometry instance representing the outline portion of the geometry.
     */
    createOutlineGeometryInstance(time: JulianDate): GeometryInstance;
}

export namespace PolygonGraphics {
    /**
     * Initialization options for the PolygonGraphics constructor
     * [show = true] - A boolean Property specifying the visibility of the polygon.
     * [hierarchy] - A Property specifying the {@link PolygonHierarchy}.
     * [height = 0] - A numeric Property specifying the altitude of the polygon relative to the ellipsoid surface.
     * [heightReference = HeightReference.NONE] - A Property specifying what the height is relative to.
     * [extrudedHeight] - A numeric Property specifying the altitude of the polygon's extruded face relative to the ellipsoid surface.
     * [extrudedHeightReference = HeightReference.NONE] - A Property specifying what the extrudedHeight is relative to.
     * [stRotation = 0.0] - A numeric property specifying the rotation of the polygon texture counter-clockwise from north. Only has an effect if textureCoordinates is not defined.
     * [granularity = Cesium.Math.RADIANS_PER_DEGREE] - A numeric Property specifying the angular distance between each latitude and longitude point.
     * [fill = true] - A boolean Property specifying whether the polygon is filled with the provided material.
     * [material = Color.WHITE] - A Property specifying the material used to fill the polygon.
     * [outline = false] - A boolean Property specifying whether the polygon is outlined.
     * [outlineColor = Color.BLACK] - A Property specifying the {@link Color} of the outline.
     * [outlineWidth = 1.0] - A numeric Property specifying the width of the outline.
     * [perPositionHeight = false] - A boolean specifying whether or not the height of each position is used.
     * [closeTop = true] - When false, leaves off the top of an extruded polygon open.
     * [closeBottom = true] - When false, leaves off the bottom of an extruded polygon open.
     * [arcType = ArcType.GEODESIC] - The type of line the polygon edges must follow.
     * [shadows = ShadowMode.DISABLED] - An enum Property specifying whether the polygon casts or receives shadows from light sources.
     * [distanceDisplayCondition] - A Property specifying at what distance from the camera that this polygon will be displayed.
     * [classificationType = ClassificationType.BOTH] - An enum Property specifying whether this polygon will classify terrain, 3D Tiles, or both when on the ground.
     * [zIndex = 0] - A property specifying the zIndex used for ordering ground geometry.  Only has an effect if the polygon is constant and neither height or extrudedHeight are specified.
     * [textureCoordinates] - A Property specifying texture coordinates as a {@link PolygonHierarchy} of {@link Cartesian2} points. Has no effect for ground primitives.
     */
    type ConstructorOptions = {
        show?: Property | boolean;
        hierarchy?: Property | PolygonHierarchy | Cartesian3[];
        height?: Property | number;
        heightReference?: Property | HeightReference;
        extrudedHeight?: Property | number;
        extrudedHeightReference?: Property | HeightReference;
        stRotation?: Property | number;
        granularity?: Property | number;
        fill?: Property | boolean;
        material?: MaterialProperty | Color;
        outline?: Property | boolean;
        outlineColor?: Property | Color;
        outlineWidth?: Property | number;
        perPositionHeight?: Property | boolean;
        closeTop?: boolean | boolean;
        closeBottom?: boolean | boolean;
        arcType?: Property | ArcType;
        shadows?: Property | ShadowMode;
        distanceDisplayCondition?: Property | DistanceDisplayCondition;
        classificationType?: Property | ClassificationType;
        zIndex?: ConstantProperty | number;
        textureCoordinates?: Property | PolygonHierarchy;
    };
}

/**
 * Describes a polygon defined by an hierarchy of linear rings which make up the outer shape and any nested holes.
 * The polygon conforms to the curvature of the globe and can be placed on the surface or
 * at altitude and can optionally be extruded into a volume.
 * @param [options] - Object describing initialization options
 */
export class PolygonGraphics {
    constructor(options?: PolygonGraphics.ConstructorOptions);
    /**
     * Gets the event that is raised whenever a property or sub-property is changed or modified.
     */
    readonly definitionChanged: Event;
    /**
     * Gets or sets the boolean Property specifying the visibility of the polygon.
     */
    show: Property | undefined;
    /**
     * Gets or sets the Property specifying the {@link PolygonHierarchy}.
     */
    hierarchy: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the constant altitude of the polygon.
     */
    height: Property | undefined;
    /**
     * Gets or sets the Property specifying the {@link HeightReference}.
     */
    heightReference: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the altitude of the polygon extrusion.
     * If {@link PolygonGraphics#perPositionHeight} is false, the volume starts at {@link PolygonGraphics#height} and ends at this altitude.
     * If {@link PolygonGraphics#perPositionHeight} is true, the volume starts at the height of each {@link PolygonGraphics#hierarchy} position and ends at this altitude.
     */
    extrudedHeight: Property | undefined;
    /**
     * Gets or sets the Property specifying the extruded {@link HeightReference}.
     */
    extrudedHeightReference: Property | undefined;
    /**
     * Gets or sets the numeric property specifying the rotation of the polygon texture counter-clockwise from north. Only has an effect if textureCoordinates is not defined.
     */
    stRotation: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the angular distance between points on the polygon.
     */
    granularity: Property | undefined;
    /**
     * Gets or sets the boolean Property specifying whether the polygon is filled with the provided material.
     */
    fill: Property | undefined;
    /**
     * Gets or sets the Property specifying the material used to fill the polygon.
     */
    material: MaterialProperty;
    /**
     * Gets or sets the Property specifying whether the polygon is outlined.
     */
    outline: Property | undefined;
    /**
     * Gets or sets the Property specifying the {@link Color} of the outline.
     */
    outlineColor: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the width of the outline.
     * <p>
     * Note: This property will be ignored on all major browsers on Windows platforms. For details, see (@link https://github.com/CesiumGS/cesium/issues/40}.
     * </p>
     */
    outlineWidth: Property | undefined;
    /**
     * Gets or sets the boolean specifying whether or not the the height of each position is used.
     * If true, the shape will have non-uniform altitude defined by the height of each {@link PolygonGraphics#hierarchy} position.
     * If false, the shape will have a constant altitude as specified by {@link PolygonGraphics#height}.
     */
    perPositionHeight: Property | undefined;
    /**
     * Gets or sets a boolean specifying whether or not the top of an extruded polygon is included.
     */
    closeTop: Property | undefined;
    /**
     * Gets or sets a boolean specifying whether or not the bottom of an extruded polygon is included.
     */
    closeBottom: Property | undefined;
    /**
     * Gets or sets the {@link ArcType} Property specifying the type of lines the polygon edges use.
     */
    arcType: Property | undefined;
    /**
     * Get or sets the enum Property specifying whether the polygon
     * casts or receives shadows from light sources.
     */
    shadows: Property | undefined;
    /**
     * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this polygon will be displayed.
     */
    distanceDisplayCondition: Property | undefined;
    /**
     * Gets or sets the {@link ClassificationType} Property specifying whether this polygon will classify terrain, 3D Tiles, or both when on the ground.
     */
    classificationType: Property | undefined;
    /**
     * Gets or sets the zIndex Prperty specifying the ordering of ground geometry.  Only has an effect if the polygon is constant and neither height or extrudedHeight are specified.
     */
    zIndex: ConstantProperty | undefined;
    /**
     * A Property specifying texture coordinates as a {@link PolygonHierarchy} of {@link Cartesian2} points. Has no effect for ground primitives.
     */
    textureCoordinates: Property | undefined;
    /**
     * Duplicates this instance.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new instance if one was not provided.
     */
    clone(result?: PolygonGraphics): PolygonGraphics;
    /**
     * Assigns each unassigned property on this object to the value
     * of the same property on the provided source object.
     * @param source - The object to be merged into this object.
     */
    merge(source: PolygonGraphics): void;
}

/**
 * A {@link MaterialProperty} that maps to PolylineArrow {@link Material} uniforms.
 * @param [color = Color.WHITE] - The {@link Color} Property to be used.
 */
export class PolylineArrowMaterialProperty {
    constructor(color?: Property | Color);
    /**
     * Gets a value indicating if this property is constant.  A property is considered
     * constant if getValue always returns the same result for the current definition.
     */
    readonly isConstant: boolean;
    /**
     * Gets the event that is raised whenever the definition of this property changes.
     * The definition is considered to have changed if a call to getValue would return
     * a different result for the same time.
     */
    readonly definitionChanged: Event;
    /**
     * Gets or sets the {@link Color} {@link Property}.
     */
    color: Property | undefined;
    /**
     * Gets the {@link Material} type at the provided time.
     * @param time - The time for which to retrieve the type.
     * @returns The type of material.
     */
    getType(time: JulianDate): string;
    /**
     * Gets the value of the property at the provided time.
     * @param time - The time for which to retrieve the value.
     * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
     * @returns The modified result parameter or a new instance if the result parameter was not supplied.
     */
    getValue(time: JulianDate, result?: any): any;
    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [other] - The other property.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    equals(other?: Property): boolean;
}

/**
 * A {@link MaterialProperty} that maps to polyline dash {@link Material} uniforms.
 * @param [options] - Object with the following properties:
 * @param [options.color = Color.WHITE] - A Property specifying the {@link Color} of the line.
 * @param [options.gapColor = Color.TRANSPARENT] - A Property specifying the {@link Color} of the gaps in the line.
 * @param [options.dashLength = 16.0] - A numeric Property specifying the length of the dash pattern in pixels.
 * @param [options.dashPattern = 255.0] - A numeric Property specifying a 16 bit pattern for the dash
 */
export class PolylineDashMaterialProperty {
    constructor(options?: {
        color?: Property | Color;
        gapColor?: Property | Color;
        dashLength?: Property | number;
        dashPattern?: Property | number;
    });
    /**
     * Gets a value indicating if this property is constant.  A property is considered
     * constant if getValue always returns the same result for the current definition.
     */
    readonly isConstant: boolean;
    /**
     * Gets the event that is raised whenever the definition of this property changes.
     * The definition is considered to have changed if a call to getValue would return
     * a different result for the same time.
     */
    readonly definitionChanged: Event;
    /**
     * Gets or sets the Property specifying the {@link Color} of the line.
     */
    color: Property | undefined;
    /**
     * Gets or sets the Property specifying the {@link Color} of the gaps in the line.
     */
    gapColor: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the length of a dash cycle
     */
    dashLength: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying a dash pattern
     */
    dashPattern: Property | undefined;
    /**
     * Gets the {@link Material} type at the provided time.
     * @param time - The time for which to retrieve the type.
     * @returns The type of material.
     */
    getType(time: JulianDate): string;
    /**
     * Gets the value of the property at the provided time.
     * @param time - The time for which to retrieve the value.
     * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
     * @returns The modified result parameter or a new instance if the result parameter was not supplied.
     */
    getValue(time: JulianDate, result?: any): any;
    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [other] - The other property.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    equals(other?: Property): boolean;
}

/**
 * A {@link GeometryUpdater} for polylines.
 * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
 * @param entity - The entity containing the geometry to be visualized.
 * @param scene - The scene where visualization is taking place.
 */
export class PolylineGeometryUpdater {
    constructor(entity: Entity, scene: Scene);
    /**
     * Gets the unique ID associated with this updater
     */
    readonly id: string;
    /**
     * Gets the entity associated with this geometry.
     */
    readonly entity: Entity;
    /**
     * Gets a value indicating if the geometry has a fill component.
     */
    readonly fillEnabled: boolean;
    /**
     * Gets a value indicating if fill visibility varies with simulation time.
     */
    readonly hasConstantFill: boolean;
    /**
     * Gets the material property used to fill the geometry.
     */
    readonly fillMaterialProperty: MaterialProperty;
    /**
     * Gets the material property used to fill the geometry when it fails the depth test.
     */
    readonly depthFailMaterialProperty: MaterialProperty;
    /**
     * Gets a value indicating if the geometry has an outline component.
     */
    readonly outlineEnabled: boolean;
    /**
     * Gets a value indicating if outline visibility varies with simulation time.
     */
    readonly hasConstantOutline: boolean;
    /**
     * Gets the {@link Color} property for the geometry outline.
     */
    readonly outlineColorProperty: Property;
    /**
     * Gets the property specifying whether the geometry
     * casts or receives shadows from light sources.
     */
    readonly shadowsProperty: Property;
    /**
     * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this geometry will be displayed.
     */
    readonly distanceDisplayConditionProperty: Property;
    /**
     * Gets or sets the {@link ClassificationType} Property specifying if this geometry will classify terrain, 3D Tiles, or both when on the ground.
     */
    readonly classificationTypeProperty: Property;
    /**
     * Gets a value indicating if the geometry is time-varying.
     * If true, all visualization is delegated to the {@link DynamicGeometryUpdater}
     * returned by GeometryUpdater#createDynamicUpdater.
     */
    readonly isDynamic: boolean;
    /**
     * Gets a value indicating if the geometry is closed.
     * This property is only valid for static geometry.
     */
    readonly isClosed: boolean;
    /**
     * Gets an event that is raised whenever the public properties
     * of this updater change.
     */
    readonly geometryChanged: boolean;
    /**
     * Gets a value indicating if the path of the line.
     */
    readonly arcType: ArcType;
    /**
     * Gets a value indicating if the geometry is clamped to the ground.
     * Returns false if polylines on terrain is not supported.
     */
    readonly clampToGround: boolean;
    /**
     * Gets the zindex
     */
    readonly zIndex: number;
    /**
     * Checks if the geometry is outlined at the provided time.
     * @param time - The time for which to retrieve visibility.
     * @returns true if geometry is outlined at the provided time, false otherwise.
     */
    isOutlineVisible(time: JulianDate): boolean;
    /**
     * Checks if the geometry is filled at the provided time.
     * @param time - The time for which to retrieve visibility.
     * @returns true if geometry is filled at the provided time, false otherwise.
     */
    isFilled(time: JulianDate): boolean;
    /**
     * Creates the geometry instance which represents the fill of the geometry.
     * @param time - The time to use when retrieving initial attribute values.
     * @returns The geometry instance representing the filled portion of the geometry.
     */
    createFillGeometryInstance(time: JulianDate): GeometryInstance;
    /**
     * Creates the geometry instance which represents the outline of the geometry.
     * @param time - The time to use when retrieving initial attribute values.
     * @returns The geometry instance representing the outline portion of the geometry.
     */
    createOutlineGeometryInstance(time: JulianDate): GeometryInstance;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * @returns True if this object was destroyed; otherwise, false.
     */
    isDestroyed(): boolean;
    /**
     * Destroys and resources used by the object.  Once an object is destroyed, it should not be used.
     */
    destroy(): void;
}

/**
 * A {@link MaterialProperty} that maps to polyline glow {@link Material} uniforms.
 * @param [options] - Object with the following properties:
 * @param [options.color = Color.WHITE] - A Property specifying the {@link Color} of the line.
 * @param [options.glowPower = 0.25] - A numeric Property specifying the strength of the glow, as a percentage of the total line width.
 * @param [options.taperPower = 1.0] - A numeric Property specifying the strength of the tapering effect, as a percentage of the total line length.  If 1.0 or higher, no taper effect is used.
 */
export class PolylineGlowMaterialProperty {
    constructor(options?: {
        color?: Property | Color;
        glowPower?: Property | number;
        taperPower?: Property | number;
    });
    /**
     * Gets a value indicating if this property is constant.  A property is considered
     * constant if getValue always returns the same result for the current definition.
     */
    readonly isConstant: boolean;
    /**
     * Gets the event that is raised whenever the definition of this property changes.
     * The definition is considered to have changed if a call to getValue would return
     * a different result for the same time.
     */
    readonly definitionChanged: Event;
    /**
     * Gets or sets the Property specifying the {@link Color} of the line.
     */
    color: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the strength of the glow, as a percentage of the total line width (less than 1.0).
     */
    glowPower: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the strength of the tapering effect, as a percentage of the total line length.  If 1.0 or higher, no taper effect is used.
     */
    taperPower: Property | undefined;
    /**
     * Gets the {@link Material} type at the provided time.
     * @param time - The time for which to retrieve the type.
     * @returns The type of material.
     */
    getType(time: JulianDate): string;
    /**
     * Gets the value of the property at the provided time.
     * @param time - The time for which to retrieve the value.
     * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
     * @returns The modified result parameter or a new instance if the result parameter was not supplied.
     */
    getValue(time: JulianDate, result?: any): any;
    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [other] - The other property.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    equals(other?: Property): boolean;
}

export namespace PolylineGraphics {
    /**
     * Initialization options for the PolylineGraphics constructor
     * [show = true] - A boolean Property specifying the visibility of the polyline.
     * [positions] - A Property specifying the array of {@link Cartesian3} positions that define the line strip.
     * [width = 1.0] - A numeric Property specifying the width in pixels.
     * [granularity = Cesium.Math.RADIANS_PER_DEGREE] - A numeric Property specifying the angular distance between each latitude and longitude if arcType is not ArcType.NONE.
     * [material = Color.WHITE] - A Property specifying the material used to draw the polyline.
     * [depthFailMaterial] - A property specifying the material used to draw the polyline when it is below the terrain.
     * [arcType = ArcType.GEODESIC] - The type of line the polyline segments must follow.
     * [clampToGround = false] - A boolean Property specifying whether the Polyline should be clamped to the ground.
     * [shadows = ShadowMode.DISABLED] - An enum Property specifying whether the polyline casts or receives shadows from light sources.
     * [distanceDisplayCondition] - A Property specifying at what distance from the camera that this polyline will be displayed.
     * [classificationType = ClassificationType.BOTH] - An enum Property specifying whether this polyline will classify terrain, 3D Tiles, or both when on the ground.
     * [zIndex = 0] - A Property specifying the zIndex used for ordering ground geometry. Only has an effect if `clampToGround` is true and polylines on terrain is supported.
     */
    type ConstructorOptions = {
        show?: Property | boolean;
        positions?: Property | Cartesian3[];
        width?: Property | number;
        granularity?: Property | number;
        material?: MaterialProperty | Color;
        depthFailMaterial?: MaterialProperty | Color;
        arcType?: Property | ArcType;
        clampToGround?: Property | boolean;
        shadows?: Property | ShadowMode;
        distanceDisplayCondition?: Property | DistanceDisplayCondition;
        classificationType?: Property | ClassificationType;
        zIndex?: Property | number;
    };
}

/**
 * Describes a polyline. The first two positions define a line segment,
 * and each additional position defines a line segment from the previous position. The segments
 * can be linear connected points, great arcs, or clamped to terrain.
 * @param [options] - Object describing initialization options
 */
export class PolylineGraphics {
    constructor(options?: PolylineGraphics.ConstructorOptions);
    /**
     * Gets the event that is raised whenever a property or sub-property is changed or modified.
     */
    readonly definitionChanged: Event;
    /**
     * Gets or sets the boolean Property specifying the visibility of the polyline.
     */
    show: Property | undefined;
    /**
     * Gets or sets the Property specifying the array of {@link Cartesian3}
     * positions that define the line strip.
     */
    positions: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the width in pixels.
     */
    width: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the angular distance between each latitude and longitude if arcType is not ArcType.NONE and clampToGround is false.
     */
    granularity: Property | undefined;
    /**
     * Gets or sets the Property specifying the material used to draw the polyline.
     */
    material: MaterialProperty;
    /**
     * Gets or sets the Property specifying the material used to draw the polyline when it fails the depth test.
     * <p>
     * Requires the EXT_frag_depth WebGL extension to render properly. If the extension is not supported,
     * there may be artifacts.
     * </p>
     */
    depthFailMaterial: MaterialProperty;
    /**
     * Gets or sets the {@link ArcType} Property specifying whether the line segments should be great arcs, rhumb lines or linearly connected.
     */
    arcType: Property | undefined;
    /**
     * Gets or sets the boolean Property specifying whether the polyline
     * should be clamped to the ground.
     */
    clampToGround: Property | undefined;
    /**
     * Get or sets the enum Property specifying whether the polyline
     * casts or receives shadows from light sources.
     */
    shadows: Property | undefined;
    /**
     * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this polyline will be displayed.
     */
    distanceDisplayCondition: Property | undefined;
    /**
     * Gets or sets the {@link ClassificationType} Property specifying whether this polyline will classify terrain, 3D Tiles, or both when on the ground.
     */
    classificationType: Property | undefined;
    /**
     * Gets or sets the zIndex Property specifying the ordering of the polyline. Only has an effect if `clampToGround` is true and polylines on terrain is supported.
     */
    zIndex: ConstantProperty | undefined;
    /**
     * Duplicates this instance.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new instance if one was not provided.
     */
    clone(result?: PolylineGraphics): PolylineGraphics;
    /**
     * Assigns each unassigned property on this object to the value
     * of the same property on the provided source object.
     * @param source - The object to be merged into this object.
     */
    merge(source: PolylineGraphics): void;
}

/**
 * A {@link MaterialProperty} that maps to polyline outline {@link Material} uniforms.
 * @param [options] - Object with the following properties:
 * @param [options.color = Color.WHITE] - A Property specifying the {@link Color} of the line.
 * @param [options.outlineColor = Color.BLACK] - A Property specifying the {@link Color} of the outline.
 * @param [options.outlineWidth = 1.0] - A numeric Property specifying the width of the outline, in pixels.
 */
export class PolylineOutlineMaterialProperty {
    constructor(options?: {
        color?: Property | Color;
        outlineColor?: Property | Color;
        outlineWidth?: Property | number;
    });
    /**
     * Gets a value indicating if this property is constant.  A property is considered
     * constant if getValue always returns the same result for the current definition.
     */
    readonly isConstant: boolean;
    /**
     * Gets the event that is raised whenever the definition of this property changes.
     * The definition is considered to have changed if a call to getValue would return
     * a different result for the same time.
     */
    readonly definitionChanged: Event;
    /**
     * Gets or sets the Property specifying the {@link Color} of the line.
     */
    color: Property | undefined;
    /**
     * Gets or sets the Property specifying the {@link Color} of the outline.
     */
    outlineColor: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the width of the outline.
     */
    outlineWidth: Property | undefined;
    /**
     * Gets the {@link Material} type at the provided time.
     * @param time - The time for which to retrieve the type.
     * @returns The type of material.
     */
    getType(time: JulianDate): string;
    /**
     * Gets the value of the property at the provided time.
     * @param time - The time for which to retrieve the value.
     * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
     * @returns The modified result parameter or a new instance if the result parameter was not supplied.
     */
    getValue(time: JulianDate, result?: any): any;
    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [other] - The other property.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    equals(other?: Property): boolean;
}

/**
 * A visualizer for polylines represented by {@link Primitive} instances.
 * @param scene - The scene the primitives will be rendered in.
 * @param entityCollection - The entityCollection to visualize.
 * @param [primitives = scene.primitives] - A collection to add primitives related to the entities
 * @param [groundPrimitives = scene.groundPrimitives] - A collection to add ground primitives related to the entities
 */
export class PolylineVisualizer {
    constructor(scene: Scene, entityCollection: EntityCollection, primitives?: PrimitiveCollection, groundPrimitives?: PrimitiveCollection);
    /**
     * Updates all of the primitives created by this visualizer to match their
     * Entity counterpart at the given time.
     * @param time - The time to update to.
     * @returns True if the visualizer successfully updated to the provided time,
     * false if the visualizer is waiting for asynchronous primitives to be created.
     */
    update(time: JulianDate): boolean;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * @returns True if this object was destroyed; otherwise, false.
     */
    isDestroyed(): boolean;
    /**
     * Removes and destroys all primitives created by this instance.
     */
    destroy(): void;
}

/**
 * A {@link GeometryUpdater} for polyline volumes.
 * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
 * @param entity - The entity containing the geometry to be visualized.
 * @param scene - The scene where visualization is taking place.
 */
export class PolylineVolumeGeometryUpdater {
    constructor(entity: Entity, scene: Scene);
    /**
     * Creates the geometry instance which represents the fill of the geometry.
     * @param time - The time to use when retrieving initial attribute values.
     * @returns The geometry instance representing the filled portion of the geometry.
     */
    createFillGeometryInstance(time: JulianDate): GeometryInstance;
    /**
     * Creates the geometry instance which represents the outline of the geometry.
     * @param time - The time to use when retrieving initial attribute values.
     * @returns The geometry instance representing the outline portion of the geometry.
     */
    createOutlineGeometryInstance(time: JulianDate): GeometryInstance;
}

export namespace PolylineVolumeGraphics {
    /**
     * Initialization options for the PolylineVolumeGraphics constructor
     * [show = true] - A boolean Property specifying the visibility of the volume.
     * [positions] - A Property specifying the array of {@link Cartesian3} positions which define the line strip.
     * [shape] - A Property specifying the array of {@link Cartesian2} positions which define the shape to be extruded.
     * [cornerType = CornerType.ROUNDED] - A {@link CornerType} Property specifying the style of the corners.
     * [granularity = Cesium.Math.RADIANS_PER_DEGREE] - A numeric Property specifying the angular distance between each latitude and longitude point.
     * [fill = true] - A boolean Property specifying whether the volume is filled with the provided material.
     * [material = Color.WHITE] - A Property specifying the material used to fill the volume.
     * [outline = false] - A boolean Property specifying whether the volume is outlined.
     * [outlineColor = Color.BLACK] - A Property specifying the {@link Color} of the outline.
     * [outlineWidth = 1.0] - A numeric Property specifying the width of the outline.
     * [shadows = ShadowMode.DISABLED] - An enum Property specifying whether the volume casts or receives shadows from light sources.
     * [distanceDisplayCondition] - A Property specifying at what distance from the camera that this volume will be displayed.
     */
    type ConstructorOptions = {
        show?: Property | boolean;
        positions?: Property | Cartesian3[];
        shape?: Property | Cartesian2[];
        cornerType?: Property | CornerType;
        granularity?: Property | number;
        fill?: Property | boolean;
        material?: MaterialProperty | Color;
        outline?: Property | boolean;
        outlineColor?: Property | Color;
        outlineWidth?: Property | number;
        shadows?: Property | ShadowMode;
        distanceDisplayCondition?: Property | DistanceDisplayCondition;
    };
}

/**
 * Describes a polyline volume defined as a line strip and corresponding two dimensional shape which is extruded along it.
 * The resulting volume conforms to the curvature of the globe.
 * @param [options] - Object describing initialization options
 */
export class PolylineVolumeGraphics {
    constructor(options?: PolylineVolumeGraphics.ConstructorOptions);
    /**
     * Gets the event that is raised whenever a property or sub-property is changed or modified.
     */
    readonly definitionChanged: Event;
    /**
     * Gets or sets the boolean Property specifying the visibility of the volume.
     */
    show: Property | undefined;
    /**
     * Gets or sets the Property specifying the array of {@link Cartesian3} positions which define the line strip.
     */
    positions: Property | undefined;
    /**
     * Gets or sets the Property specifying the array of {@link Cartesian2} positions which define the shape to be extruded.
     */
    shape: Property | undefined;
    /**
     * Gets or sets the {@link CornerType} Property specifying the style of the corners.
     */
    cornerType: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the angular distance between points on the volume.
     */
    granularity: Property | undefined;
    /**
     * Gets or sets the boolean Property specifying whether the volume is filled with the provided material.
     */
    fill: Property | undefined;
    /**
     * Gets or sets the Property specifying the material used to fill the volume.
     */
    material: MaterialProperty;
    /**
     * Gets or sets the Property specifying whether the volume is outlined.
     */
    outline: Property | undefined;
    /**
     * Gets or sets the Property specifying the {@link Color} of the outline.
     */
    outlineColor: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the width of the outline.
     * <p>
     * Note: This property will be ignored on all major browsers on Windows platforms. For details, see (@link https://github.com/CesiumGS/cesium/issues/40}.
     * </p>
     */
    outlineWidth: Property | undefined;
    /**
     * Get or sets the enum Property specifying whether the volume
     * casts or receives shadows from light sources.
     */
    shadows: Property | undefined;
    /**
     * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this volume will be displayed.
     */
    distanceDisplayCondition: Property | undefined;
    /**
     * Duplicates this instance.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new instance if one was not provided.
     */
    clone(result?: PolylineVolumeGraphics): PolylineVolumeGraphics;
    /**
     * Assigns each unassigned property on this object to the value
     * of the same property on the provided source object.
     * @param source - The object to be merged into this object.
     */
    merge(source: PolylineVolumeGraphics): void;
}

/**
 * The interface for all {@link Property} objects that define a world
 * location as a {@link Cartesian3} with an associated {@link ReferenceFrame}.
 * This type defines an interface and cannot be instantiated directly.
 */
export class PositionProperty {
    constructor();
    /**
     * Gets a value indicating if this property is constant.  A property is considered
     * constant if getValue always returns the same result for the current definition.
     */
    readonly isConstant: boolean;
    /**
     * Gets the event that is raised whenever the definition of this property changes.
     * The definition is considered to have changed if a call to getValue would return
     * a different result for the same time.
     */
    readonly definitionChanged: Event;
    /**
     * Gets the reference frame that the position is defined in.
     */
    referenceFrame: ReferenceFrame;
    /**
     * Gets the value of the property at the provided time in the fixed frame.
     * @param time - The time for which to retrieve the value.
     * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
     * @returns The modified result parameter or a new instance if the result parameter was not supplied.
     */
    getValue(time: JulianDate, result?: Cartesian3): Cartesian3 | undefined;
    /**
     * Gets the value of the property at the provided time and in the provided reference frame.
     * @param time - The time for which to retrieve the value.
     * @param referenceFrame - The desired referenceFrame of the result.
     * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
     * @returns The modified result parameter or a new instance if the result parameter was not supplied.
     */
    getValueInReferenceFrame(time: JulianDate, referenceFrame: ReferenceFrame, result?: Cartesian3): Cartesian3 | undefined;
    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [other] - The other property.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    equals(other?: Property): boolean;
}

/**
 * A {@link Property} whose value is an array whose items are the computed value
 * of other PositionProperty instances.
 * @param [value] - An array of Property instances.
 * @param [referenceFrame = ReferenceFrame.FIXED] - The reference frame in which the position is defined.
 */
export class PositionPropertyArray {
    constructor(value?: Property[], referenceFrame?: ReferenceFrame);
    /**
     * Gets a value indicating if this property is constant.  This property
     * is considered constant if all property items in the array are constant.
     */
    readonly isConstant: boolean;
    /**
     * Gets the event that is raised whenever the definition of this property changes.
     * The definition is changed whenever setValue is called with data different
     * than the current value or one of the properties in the array also changes.
     */
    readonly definitionChanged: Event;
    /**
     * Gets the reference frame in which the position is defined.
     */
    referenceFrame: ReferenceFrame;
    /**
     * Gets the value of the property.
     * @param time - The time for which to retrieve the value.
     * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
     * @returns The modified result parameter or a new instance if the result parameter was not supplied.
     */
    getValue(time: JulianDate, result?: Cartesian3[]): Cartesian3[];
    /**
     * Gets the value of the property at the provided time and in the provided reference frame.
     * @param time - The time for which to retrieve the value.
     * @param referenceFrame - The desired referenceFrame of the result.
     * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
     * @returns The modified result parameter or a new instance if the result parameter was not supplied.
     */
    getValueInReferenceFrame(time: JulianDate, referenceFrame: ReferenceFrame, result?: Cartesian3[]): Cartesian3[];
    /**
     * Sets the value of the property.
     * @param value - An array of Property instances.
     */
    setValue(value: Property[]): void;
    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [other] - The other property.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    equals(other?: Property): boolean;
}

/**
 * The interface for all properties, which represent a value that can optionally vary over time.
 * This type defines an interface and cannot be instantiated directly.
 */
export class Property {
    constructor();
    /**
     * Gets a value indicating if this property is constant.  A property is considered
     * constant if getValue always returns the same result for the current definition.
     */
    readonly isConstant: boolean;
    /**
     * Gets the event that is raised whenever the definition of this property changes.
     * The definition is considered to have changed if a call to getValue would return
     * a different result for the same time.
     */
    readonly definitionChanged: Event;
    /**
     * Gets the value of the property at the provided time.
     * @param time - The time for which to retrieve the value.
     * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
     * @returns The modified result parameter or a new instance if the result parameter was not supplied.
     */
    getValue(time: JulianDate, result?: any): any;
    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [other] - The other property.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    equals(other?: Property): boolean;
}

/**
 * A {@link Property} whose value is an array whose items are the computed value
 * of other property instances.
 * @param [value] - An array of Property instances.
 */
export class PropertyArray {
    constructor(value?: Property[]);
    /**
     * Gets a value indicating if this property is constant.  This property
     * is considered constant if all property items in the array are constant.
     */
    readonly isConstant: boolean;
    /**
     * Gets the event that is raised whenever the definition of this property changes.
     * The definition is changed whenever setValue is called with data different
     * than the current value or one of the properties in the array also changes.
     */
    readonly definitionChanged: Event;
    /**
     * Gets the value of the property.
     * @param time - The time for which to retrieve the value.
     * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
     * @returns The modified result parameter, which is an array of values produced by evaluating each of the contained properties at the given time or a new instance if the result parameter was not supplied.
     */
    getValue(time: JulianDate, result?: object[]): object[];
    /**
     * Sets the value of the property.
     * @param value - An array of Property instances.
     */
    setValue(value: Property[]): void;
    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [other] - The other property.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    equals(other?: Property): boolean;
}

export interface PropertyBag extends Record<string, any> {
}

/**
 * A {@link Property} whose value is a key-value mapping of property names to the computed value of other properties.
 * @param [value] - An object, containing key-value mapping of property names to properties.
 * @param [createPropertyCallback] - A function that will be called when the value of any of the properties in value are not a Property.
 */
export class PropertyBag implements Record<string, any> {
    constructor(value?: any, createPropertyCallback?: (...params: any[]) => any);
    /**
     * Gets the names of all properties registered on this instance.
     */
    propertyNames: any[];
    /**
     * Gets a value indicating if this property is constant.  This property
     * is considered constant if all property items in this object are constant.
     */
    readonly isConstant: boolean;
    /**
     * Gets the event that is raised whenever the set of properties contained in this
     * object changes, or one of the properties itself changes.
     */
    readonly definitionChanged: Event;
    /**
     * Determines if this object has defined a property with the given name.
     * @param propertyName - The name of the property to check for.
     * @returns True if this object has defined a property with the given name, false otherwise.
     */
    hasProperty(propertyName: string): boolean;
    /**
     * Adds a property to this object.
     * @param propertyName - The name of the property to add.
     * @param [value] - The value of the new property, if provided.
     * @param [createPropertyCallback] - A function that will be called when the value of this new property is set to a value that is not a Property.
     */
    addProperty(propertyName: string, value?: any, createPropertyCallback?: (...params: any[]) => any): void;
    /**
     * Removed a property previously added with addProperty.
     * @param propertyName - The name of the property to remove.
     */
    removeProperty(propertyName: string): void;
    /**
     * Gets the value of this property.  Each contained property will be evaluated at the given time, and the overall
     * result will be an object, mapping property names to those values.
     * @param time - The time for which to retrieve the value.
     * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
     * Note that any properties in result which are not part of this PropertyBag will be left as-is.
     * @returns The modified result parameter or a new instance if the result parameter was not supplied.
     */
    getValue(time: JulianDate, result?: any): any;
    /**
     * Assigns each unassigned property on this object to the value
     * of the same property on the provided source object.
     * @param source - The object to be merged into this object.
     * @param [createPropertyCallback] - A function that will be called when the value of any of the properties in value are not a Property.
     */
    merge(source: any, createPropertyCallback?: (...params: any[]) => any): void;
    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [other] - The other property.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    equals(other?: Property): boolean;
}

/**
 * A {@link GeometryUpdater} for rectangles.
 * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
 * @param entity - The entity containing the geometry to be visualized.
 * @param scene - The scene where visualization is taking place.
 */
export class RectangleGeometryUpdater {
    constructor(entity: Entity, scene: Scene);
    /**
     * Creates the geometry instance which represents the fill of the geometry.
     * @param time - The time to use when retrieving initial attribute values.
     * @returns The geometry instance representing the filled portion of the geometry.
     */
    createFillGeometryInstance(time: JulianDate): GeometryInstance;
    /**
     * Creates the geometry instance which represents the outline of the geometry.
     * @param time - The time to use when retrieving initial attribute values.
     * @returns The geometry instance representing the outline portion of the geometry.
     */
    createOutlineGeometryInstance(time: JulianDate): GeometryInstance;
}

export namespace RectangleGraphics {
    /**
     * Initialization options for the RectangleGraphics constructor
     * [show = true] - A boolean Property specifying the visibility of the rectangle.
     * [coordinates] - The Property specifying the {@link Rectangle}.
     * [height = 0] - A numeric Property specifying the altitude of the rectangle relative to the ellipsoid surface.
     * [heightReference = HeightReference.NONE] - A Property specifying what the height is relative to.
     * [extrudedHeight] - A numeric Property specifying the altitude of the rectangle's extruded face relative to the ellipsoid surface.
     * [extrudedHeightReference = HeightReference.NONE] - A Property specifying what the extrudedHeight is relative to.
     * [rotation = 0.0] - A numeric property specifying the rotation of the rectangle clockwise from north.
     * [stRotation = 0.0] - A numeric property specifying the rotation of the rectangle texture counter-clockwise from north.
     * [granularity = Cesium.Math.RADIANS_PER_DEGREE] - A numeric Property specifying the angular distance between points on the rectangle.
     * [fill = true] - A boolean Property specifying whether the rectangle is filled with the provided material.
     * [material = Color.WHITE] - A Property specifying the material used to fill the rectangle.
     * [outline = false] - A boolean Property specifying whether the rectangle is outlined.
     * [outlineColor = Color.BLACK] - A Property specifying the {@link Color} of the outline.
     * [outlineWidth = 1.0] - A numeric Property specifying the width of the outline.
     * [shadows = ShadowMode.DISABLED] - An enum Property specifying whether the rectangle casts or receives shadows from light sources.
     * [distanceDisplayCondition] - A Property specifying at what distance from the camera that this rectangle will be displayed.
     * [classificationType = ClassificationType.BOTH] - An enum Property specifying whether this rectangle will classify terrain, 3D Tiles, or both when on the ground.
     * [zIndex = 0] - A Property specifying the zIndex used for ordering ground geometry.  Only has an effect if the rectangle is constant and neither height or extrudedHeight are specified.
     */
    type ConstructorOptions = {
        show?: Property | boolean;
        coordinates?: Property | Rectangle;
        height?: Property | number;
        heightReference?: Property | HeightReference;
        extrudedHeight?: Property | number;
        extrudedHeightReference?: Property | HeightReference;
        rotation?: Property | number;
        stRotation?: Property | number;
        granularity?: Property | number;
        fill?: Property | boolean;
        material?: MaterialProperty | Color;
        outline?: Property | boolean;
        outlineColor?: Property | Color;
        outlineWidth?: Property | number;
        shadows?: Property | ShadowMode;
        distanceDisplayCondition?: Property | DistanceDisplayCondition;
        classificationType?: Property | ClassificationType;
        zIndex?: Property | number;
    };
}

/**
 * Describes graphics for a {@link Rectangle}.
 * The rectangle conforms to the curvature of the globe and can be placed on the surface or
 * at altitude and can optionally be extruded into a volume.
 * @param [options] - Object describing initialization options
 */
export class RectangleGraphics {
    constructor(options?: RectangleGraphics.ConstructorOptions);
    /**
     * Gets the event that is raised whenever a property or sub-property is changed or modified.
     */
    readonly definitionChanged: Event;
    /**
     * Gets or sets the boolean Property specifying the visibility of the rectangle.
     */
    show: Property | undefined;
    /**
     * Gets or sets the Property specifying the {@link Rectangle}.
     */
    coordinates: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the altitude of the rectangle.
     */
    height: Property | undefined;
    /**
     * Gets or sets the Property specifying the {@link HeightReference}.
     */
    heightReference: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the altitude of the rectangle extrusion.
     * Setting this property creates volume starting at height and ending at this altitude.
     */
    extrudedHeight: Property | undefined;
    /**
     * Gets or sets the Property specifying the extruded {@link HeightReference}.
     */
    extrudedHeightReference: Property | undefined;
    /**
     * Gets or sets the numeric property specifying the rotation of the rectangle clockwise from north.
     */
    rotation: Property | undefined;
    /**
     * Gets or sets the numeric property specifying the rotation of the rectangle texture counter-clockwise from north.
     */
    stRotation: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the angular distance between points on the rectangle.
     */
    granularity: Property | undefined;
    /**
     * Gets or sets the boolean Property specifying whether the rectangle is filled with the provided material.
     */
    fill: Property | undefined;
    /**
     * Gets or sets the Property specifying the material used to fill the rectangle.
     */
    material: MaterialProperty;
    /**
     * Gets or sets the Property specifying whether the rectangle is outlined.
     */
    outline: Property | undefined;
    /**
     * Gets or sets the Property specifying the {@link Color} of the outline.
     */
    outlineColor: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the width of the outline.
     * <p>
     * Note: This property will be ignored on all major browsers on Windows platforms. For details, see (@link https://github.com/CesiumGS/cesium/issues/40}.
     * </p>
     */
    outlineWidth: Property | undefined;
    /**
     * Get or sets the enum Property specifying whether the rectangle
     * casts or receives shadows from light sources.
     */
    shadows: Property | undefined;
    /**
     * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this rectangle will be displayed.
     */
    distanceDisplayCondition: Property | undefined;
    /**
     * Gets or sets the {@link ClassificationType} Property specifying whether this rectangle will classify terrain, 3D Tiles, or both when on the ground.
     */
    classificationType: Property | undefined;
    /**
     * Gets or sets the zIndex Property specifying the ordering of the rectangle.  Only has an effect if the rectangle is constant and neither height or extrudedHeight are specified.
     */
    zIndex: ConstantProperty | undefined;
    /**
     * Duplicates this instance.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new instance if one was not provided.
     */
    clone(result?: RectangleGraphics): RectangleGraphics;
    /**
     * Assigns each unassigned property on this object to the value
     * of the same property on the provided source object.
     * @param source - The object to be merged into this object.
     */
    merge(source: RectangleGraphics): void;
}

/**
 * A {@link Property} which transparently links to another property on a provided object.
 * @example
 * const collection = new Cesium.EntityCollection();
 *
 * //Create a new entity and assign a billboard scale.
 * const object1 = new Cesium.Entity({id:'object1'});
 * object1.billboard = new Cesium.BillboardGraphics();
 * object1.billboard.scale = new Cesium.ConstantProperty(2.0);
 * collection.add(object1);
 *
 * //Create a second entity and reference the scale from the first one.
 * const object2 = new Cesium.Entity({id:'object2'});
 * object2.model = new Cesium.ModelGraphics();
 * object2.model.scale = new Cesium.ReferenceProperty(collection, 'object1', ['billboard', 'scale']);
 * collection.add(object2);
 *
 * //Create a third object, but use the fromString helper function.
 * const object3 = new Cesium.Entity({id:'object3'});
 * object3.billboard = new Cesium.BillboardGraphics();
 * object3.billboard.scale = Cesium.ReferenceProperty.fromString(collection, 'object1#billboard.scale');
 * collection.add(object3);
 *
 * //You can refer to an entity with a # or . in id and property names by escaping them.
 * const object4 = new Cesium.Entity({id:'#object.4'});
 * object4.billboard = new Cesium.BillboardGraphics();
 * object4.billboard.scale = new Cesium.ConstantProperty(2.0);
 * collection.add(object4);
 *
 * const object5 = new Cesium.Entity({id:'object5'});
 * object5.billboard = new Cesium.BillboardGraphics();
 * object5.billboard.scale = Cesium.ReferenceProperty.fromString(collection, '\\#object\\.4#billboard.scale');
 * collection.add(object5);
 * @param targetCollection - The entity collection which will be used to resolve the reference.
 * @param targetId - The id of the entity which is being referenced.
 * @param targetPropertyNames - The names of the property on the target entity which we will use.
 */
export class ReferenceProperty {
    constructor(targetCollection: EntityCollection, targetId: string, targetPropertyNames: string[]);
    /**
     * Gets a value indicating if this property is constant.
     */
    readonly isConstant: boolean;
    /**
     * Gets the event that is raised whenever the definition of this property changes.
     * The definition is changed whenever the referenced property's definition is changed.
     */
    readonly definitionChanged: Event;
    /**
     * Gets the reference frame that the position is defined in.
     * This property is only valid if the referenced property is a {@link PositionProperty}.
     */
    readonly referenceFrame: ReferenceFrame;
    /**
     * Gets the id of the entity being referenced.
     */
    readonly targetId: string;
    /**
     * Gets the collection containing the entity being referenced.
     */
    readonly targetCollection: EntityCollection;
    /**
     * Gets the array of property names used to retrieve the referenced property.
     */
    readonly targetPropertyNames: any;
    /**
     * Gets the resolved instance of the underlying referenced property.
     */
    readonly resolvedProperty: Property | undefined;
    /**
     * Creates a new instance given the entity collection that will
     * be used to resolve it and a string indicating the target entity id and property.
     * The format of the string is "objectId#foo.bar", where # separates the id from
     * property path and . separates sub-properties.  If the reference identifier or
     * or any sub-properties contains a # . or \ they must be escaped.
     * @returns A new instance of ReferenceProperty.
     */
    static fromString(targetCollection: EntityCollection, referenceString: string): ReferenceProperty;
    /**
     * Gets the value of the property at the provided time.
     * @param time - The time for which to retrieve the value.
     * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
     * @returns The modified result parameter or a new instance if the result parameter was not supplied.
     */
    getValue(time: JulianDate, result?: any): any;
    /**
     * Gets the value of the property at the provided time and in the provided reference frame.
     * This method is only valid if the property being referenced is a {@link PositionProperty}.
     * @param time - The time for which to retrieve the value.
     * @param referenceFrame - The desired referenceFrame of the result.
     * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
     * @returns The modified result parameter or a new instance if the result parameter was not supplied.
     */
    getValueInReferenceFrame(time: JulianDate, referenceFrame: ReferenceFrame, result?: Cartesian3): Cartesian3;
    /**
     * Gets the {@link Material} type at the provided time.
     * This method is only valid if the property being referenced is a {@link MaterialProperty}.
     * @param time - The time for which to retrieve the type.
     * @returns The type of material.
     */
    getType(time: JulianDate): string;
    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [other] - The other property.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    equals(other?: Property): boolean;
}

export namespace Rotation {
    /**
     * The number of elements used to pack the object into an array.
     */
    var packedLength: number;
    /**
     * Stores the provided instance into the provided array.
     * @param value - The value to pack.
     * @param array - The array to pack into.
     * @param [startingIndex = 0] - The index into the array at which to start packing the elements.
     * @returns The array that was packed into
     */
    function pack(value: Rotation, array: number[], startingIndex?: number): number[];
    /**
     * Retrieves an instance from a packed array.
     * @param array - The packed array.
     * @param [startingIndex = 0] - The starting index of the element to be unpacked.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new Rotation instance if one was not provided.
     */
    function unpack(array: number[], startingIndex?: number, result?: Rotation): Rotation;
    /**
     * Converts a packed array into a form suitable for interpolation.
     * @param packedArray - The packed array.
     * @param [startingIndex = 0] - The index of the first element to be converted.
     * @param [lastIndex = packedArray.length] - The index of the last element to be converted.
     * @param [result] - The object into which to store the result.
     */
    function convertPackedArrayForInterpolation(packedArray: number[], startingIndex?: number, lastIndex?: number, result?: number[]): void;
    /**
     * Retrieves an instance from a packed array converted with {@link Rotation.convertPackedArrayForInterpolation}.
     * @param array - The array previously packed for interpolation.
     * @param sourceArray - The original packed array.
     * @param [firstIndex = 0] - The firstIndex used to convert the array.
     * @param [lastIndex = packedArray.length] - The lastIndex used to convert the array.
     * @param [result] - The object into which to store the result.
     * @returns The modified result parameter or a new Rotation instance if one was not provided.
     */
    function unpackInterpolationResult(array: number[], sourceArray: number[], firstIndex?: number, lastIndex?: number, result?: Rotation): Rotation;
}

/**
 * Represents a {@link Packable} number that always interpolates values
 * towards the shortest angle of rotation. This object is never used directly
 * but is instead passed to the constructor of {@link SampledProperty}
 * in order to represent a two-dimensional angle of rotation.
 * @example
 * const time1 = Cesium.JulianDate.fromIso8601('2010-05-07T00:00:00');
 * const time2 = Cesium.JulianDate.fromIso8601('2010-05-07T00:01:00');
 * const time3 = Cesium.JulianDate.fromIso8601('2010-05-07T00:02:00');
 *
 * const property = new Cesium.SampledProperty(Cesium.Rotation);
 * property.addSample(time1, 0);
 * property.addSample(time3, Cesium.Math.toRadians(350));
 *
 * //Getting the value at time2 will equal 355 degrees instead
 * //of 175 degrees (which is what you get if you construct
 * //a SampledProperty(Number) instead.  Note, the actual
 * //return value is in radians, not degrees.
 * property.getValue(time2);
 */
export interface Rotation {
}

/**
 * A {@link SampledProperty} which is also a {@link PositionProperty}.
 * @param [referenceFrame = ReferenceFrame.FIXED] - The reference frame in which the position is defined.
 * @param [numberOfDerivatives = 0] - The number of derivatives that accompany each position; i.e. velocity, acceleration, etc...
 */
export class SampledPositionProperty {
    constructor(referenceFrame?: ReferenceFrame, numberOfDerivatives?: number);
    /**
     * Gets a value indicating if this property is constant.  A property is considered
     * constant if getValue always returns the same result for the current definition.
     */
    readonly isConstant: boolean;
    /**
     * Gets the event that is raised whenever the definition of this property changes.
     * The definition is considered to have changed if a call to getValue would return
     * a different result for the same time.
     */
    readonly definitionChanged: Event;
    /**
     * Gets the reference frame in which the position is defined.
     */
    referenceFrame: ReferenceFrame;
    /**
     * Gets the degree of interpolation to perform when retrieving a value. Call <code>setInterpolationOptions</code> to set this.
     */
    readonly interpolationDegree: number;
    /**
     * Gets the interpolation algorithm to use when retrieving a value. Call <code>setInterpolationOptions</code> to set this.
     */
    readonly interpolationAlgorithm: InterpolationAlgorithm;
    /**
     * The number of derivatives contained by this property; i.e. 0 for just position, 1 for velocity, etc.
     */
    numberOfDerivatives: number;
    /**
     * Gets or sets the type of extrapolation to perform when a value
     * is requested at a time after any available samples.
     */
    forwardExtrapolationType: ExtrapolationType;
    /**
     * Gets or sets the amount of time to extrapolate forward before
     * the property becomes undefined.  A value of 0 will extrapolate forever.
     */
    forwardExtrapolationDuration: number;
    /**
     * Gets or sets the type of extrapolation to perform when a value
     * is requested at a time before any available samples.
     */
    backwardExtrapolationType: ExtrapolationType;
    /**
     * Gets or sets the amount of time to extrapolate backward
     * before the property becomes undefined.  A value of 0 will extrapolate forever.
     */
    backwardExtrapolationDuration: number;
    /**
     * Gets the position at the provided time.
     * @param time - The time for which to retrieve the value.
     * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
     * @returns The modified result parameter or a new instance if the result parameter was not supplied.
     */
    getValue(time: JulianDate, result?: Cartesian3): Cartesian3 | undefined;
    /**
     * Gets the position at the provided time and in the provided reference frame.
     * @param time - The time for which to retrieve the value.
     * @param referenceFrame - The desired referenceFrame of the result.
     * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
     * @returns The modified result parameter or a new instance if the result parameter was not supplied.
     */
    getValueInReferenceFrame(time: JulianDate, referenceFrame: ReferenceFrame, result?: Cartesian3): Cartesian3 | undefined;
    /**
     * Sets the algorithm and degree to use when interpolating a position.
     * @param [options] - Object with the following properties:
     * @param [options.interpolationAlgorithm] - The new interpolation algorithm.  If undefined, the existing property will be unchanged.
     * @param [options.interpolationDegree] - The new interpolation degree.  If undefined, the existing property will be unchanged.
     */
    setInterpolationOptions(options?: {
        interpolationAlgorithm?: InterpolationAlgorithm;
        interpolationDegree?: number;
    }): void;
    /**
     * Adds a new sample.
     * @param time - The sample time.
     * @param position - The position at the provided time.
     * @param [derivatives] - The array of derivative values at the provided time.
     */
    addSample(time: JulianDate, position: Cartesian3, derivatives?: Cartesian3[]): void;
    /**
     * Adds multiple samples via parallel arrays.
     * @param times - An array of JulianDate instances where each index is a sample time.
     * @param positions - An array of Cartesian3 position instances, where each value corresponds to the provided time index.
     * @param [derivatives] - An array where each value is another array containing derivatives for the corresponding time index.
     */
    addSamples(times: JulianDate[], positions: Cartesian3[], derivatives?: any[][]): void;
    /**
     * Adds samples as a single packed array where each new sample is represented as a date,
     * followed by the packed representation of the corresponding value and derivatives.
     * @param packedSamples - The array of packed samples.
     * @param [epoch] - If any of the dates in packedSamples are numbers, they are considered an offset from this epoch, in seconds.
     */
    addSamplesPackedArray(packedSamples: number[], epoch?: JulianDate): void;
    /**
     * Removes a sample at the given time, if present.
     * @param time - The sample time.
     * @returns <code>true</code> if a sample at time was removed, <code>false</code> otherwise.
     */
    removeSample(time: JulianDate): boolean;
    /**
     * Removes all samples for the given time interval.
     * @param time - The time interval for which to remove all samples.
     */
    removeSamples(time: TimeInterval): void;
    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [other] - The other property.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    equals(other?: Property): boolean;
}

/**
 * A {@link Property} whose value is interpolated for a given time from the
 * provided set of samples and specified interpolation algorithm and degree.
 * @example
 * //Create a linearly interpolated Cartesian2
 * const property = new Cesium.SampledProperty(Cesium.Cartesian2);
 *
 * //Populate it with data
 * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:00:00.00Z'), new Cesium.Cartesian2(0, 0));
 * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-02T00:00:00.00Z'), new Cesium.Cartesian2(4, 7));
 *
 * //Retrieve an interpolated value
 * const result = property.getValue(Cesium.JulianDate.fromIso8601('2012-08-01T12:00:00.00Z'));
 * @example
 * //Create a simple numeric SampledProperty that uses third degree Hermite Polynomial Approximation
 * const property = new Cesium.SampledProperty(Number);
 * property.setInterpolationOptions({
 *     interpolationDegree : 3,
 *     interpolationAlgorithm : Cesium.HermitePolynomialApproximation
 * });
 *
 * //Populate it with data
 * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:00:00.00Z'), 1.0);
 * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:01:00.00Z'), 6.0);
 * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:02:00.00Z'), 12.0);
 * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:03:30.00Z'), 5.0);
 * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:06:30.00Z'), 2.0);
 *
 * //Samples can be added in any order.
 * property.addSample(Cesium.JulianDate.fromIso8601('2012-08-01T00:00:30.00Z'), 6.2);
 *
 * //Retrieve an interpolated value
 * const result = property.getValue(Cesium.JulianDate.fromIso8601('2012-08-01T00:02:34.00Z'));
 * @param type - The type of property.
 * @param [derivativeTypes] - When supplied, indicates that samples will contain derivative information of the specified types.
 */
export class SampledProperty {
    constructor(type: number | Packable, derivativeTypes?: Packable[]);
    /**
     * Gets a value indicating if this property is constant.  A property is considered
     * constant if getValue always returns the same result for the current definition.
     */
    readonly isConstant: boolean;
    /**
     * Gets the event that is raised whenever the definition of this property changes.
     * The definition is considered to have changed if a call to getValue would return
     * a different result for the same time.
     */
    readonly definitionChanged: Event;
    /**
     * Gets the type of property.
     */
    type: any;
    /**
     * Gets the derivative types used by this property.
     */
    derivativeTypes: Packable[];
    /**
     * Gets the degree of interpolation to perform when retrieving a value.
     */
    interpolationDegree: number;
    /**
     * Gets the interpolation algorithm to use when retrieving a value.
     */
    interpolationAlgorithm: InterpolationAlgorithm;
    /**
     * Gets or sets the type of extrapolation to perform when a value
     * is requested at a time after any available samples.
     */
    forwardExtrapolationType: ExtrapolationType;
    /**
     * Gets or sets the amount of time to extrapolate forward before
     * the property becomes undefined.  A value of 0 will extrapolate forever.
     */
    forwardExtrapolationDuration: number;
    /**
     * Gets or sets the type of extrapolation to perform when a value
     * is requested at a time before any available samples.
     */
    backwardExtrapolationType: ExtrapolationType;
    /**
     * Gets or sets the amount of time to extrapolate backward
     * before the property becomes undefined.  A value of 0 will extrapolate forever.
     */
    backwardExtrapolationDuration: number;
    /**
     * Gets the value of the property at the provided time.
     * @param time - The time for which to retrieve the value.
     * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
     * @returns The modified result parameter or a new instance if the result parameter was not supplied.
     */
    getValue(time: JulianDate, result?: any): any;
    /**
     * Sets the algorithm and degree to use when interpolating a value.
     * @param [options] - Object with the following properties:
     * @param [options.interpolationAlgorithm] - The new interpolation algorithm.  If undefined, the existing property will be unchanged.
     * @param [options.interpolationDegree] - The new interpolation degree.  If undefined, the existing property will be unchanged.
     */
    setInterpolationOptions(options?: {
        interpolationAlgorithm?: InterpolationAlgorithm;
        interpolationDegree?: number;
    }): void;
    /**
     * Adds a new sample.
     * @param time - The sample time.
     * @param value - The value at the provided time.
     * @param [derivatives] - The array of derivatives at the provided time.
     */
    addSample(time: JulianDate, value: Packable, derivatives?: Packable[]): void;
    /**
     * Adds an array of samples.
     * @param times - An array of JulianDate instances where each index is a sample time.
     * @param values - The array of values, where each value corresponds to the provided times index.
     * @param [derivativeValues] - An array where each item is the array of derivatives at the equivalent time index.
     */
    addSamples(times: JulianDate[], values: Packable[], derivativeValues?: any[][]): void;
    /**
     * Adds samples as a single packed array where each new sample is represented as a date,
     * followed by the packed representation of the corresponding value and derivatives.
     * @param packedSamples - The array of packed samples.
     * @param [epoch] - If any of the dates in packedSamples are numbers, they are considered an offset from this epoch, in seconds.
     */
    addSamplesPackedArray(packedSamples: number[], epoch?: JulianDate): void;
    /**
     * Removes a sample at the given time, if present.
     * @param time - The sample time.
     * @returns <code>true</code> if a sample at time was removed, <code>false</code> otherwise.
     */
    removeSample(time: JulianDate): boolean;
    /**
     * Removes all samples for the given time interval.
     * @param time - The time interval for which to remove all samples.
     */
    removeSamples(time: TimeInterval): void;
    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [other] - The other property.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    equals(other?: Property): boolean;
}

/**
 * A {@link MaterialProperty} that maps to stripe {@link Material} uniforms.
 * @param [options] - Object with the following properties:
 * @param [options.orientation = StripeOrientation.HORIZONTAL] - A Property specifying the {@link StripeOrientation}.
 * @param [options.evenColor = Color.WHITE] - A Property specifying the first {@link Color}.
 * @param [options.oddColor = Color.BLACK] - A Property specifying the second {@link Color}.
 * @param [options.offset = 0] - A numeric Property specifying how far into the pattern to start the material.
 * @param [options.repeat = 1] - A numeric Property specifying how many times the stripes repeat.
 */
export class StripeMaterialProperty {
    constructor(options?: {
        orientation?: Property | StripeOrientation;
        evenColor?: Property | Color;
        oddColor?: Property | Color;
        offset?: Property | number;
        repeat?: Property | number;
    });
    /**
     * Gets a value indicating if this property is constant.  A property is considered
     * constant if getValue always returns the same result for the current definition.
     */
    readonly isConstant: boolean;
    /**
     * Gets the event that is raised whenever the definition of this property changes.
     * The definition is considered to have changed if a call to getValue would return
     * a different result for the same time.
     */
    readonly definitionChanged: Event;
    /**
     * Gets or sets the Property specifying the {@link StripeOrientation}/
     */
    orientation: Property | undefined;
    /**
     * Gets or sets the Property specifying the first {@link Color}.
     */
    evenColor: Property | undefined;
    /**
     * Gets or sets the Property specifying the second {@link Color}.
     */
    oddColor: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the point into the pattern
     * to begin drawing; with 0.0 being the beginning of the even color, 1.0 the beginning
     * of the odd color, 2.0 being the even color again, and any multiple or fractional values
     * being in between.
     */
    offset: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying how many times the stripes repeat.
     */
    repeat: Property | undefined;
    /**
     * Gets the {@link Material} type at the provided time.
     * @param time - The time for which to retrieve the type.
     * @returns The type of material.
     */
    getType(time: JulianDate): string;
    /**
     * Gets the value of the property at the provided time.
     * @param time - The time for which to retrieve the value.
     * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
     * @returns The modified result parameter or a new instance if the result parameter was not supplied.
     */
    getValue(time: JulianDate, result?: any): any;
    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [other] - The other property.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    equals(other?: Property): boolean;
}

/**
 * Defined the orientation of stripes in {@link StripeMaterialProperty}.
 */
export enum StripeOrientation {
    /**
     * Horizontal orientation.
     */
    HORIZONTAL = 0,
    /**
     * Vertical orientation.
     */
    VERTICAL = 1
}

/**
 * A {@link TimeIntervalCollectionProperty} which is also a {@link PositionProperty}.
 * @param [referenceFrame = ReferenceFrame.FIXED] - The reference frame in which the position is defined.
 */
export class TimeIntervalCollectionPositionProperty {
    constructor(referenceFrame?: ReferenceFrame);
    /**
     * Gets a value indicating if this property is constant.  A property is considered
     * constant if getValue always returns the same result for the current definition.
     */
    readonly isConstant: boolean;
    /**
     * Gets the event that is raised whenever the definition of this property changes.
     * The definition is considered to have changed if a call to getValue would return
     * a different result for the same time.
     */
    readonly definitionChanged: Event;
    /**
     * Gets the interval collection.
     */
    readonly intervals: TimeIntervalCollection;
    /**
     * Gets the reference frame in which the position is defined.
     */
    readonly referenceFrame: ReferenceFrame;
    /**
     * Gets the value of the property at the provided time in the fixed frame.
     * @param time - The time for which to retrieve the value.
     * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
     * @returns The modified result parameter or a new instance if the result parameter was not supplied.
     */
    getValue(time: JulianDate, result?: any): Cartesian3 | undefined;
    /**
     * Gets the value of the property at the provided time and in the provided reference frame.
     * @param time - The time for which to retrieve the value.
     * @param referenceFrame - The desired referenceFrame of the result.
     * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
     * @returns The modified result parameter or a new instance if the result parameter was not supplied.
     */
    getValueInReferenceFrame(time: JulianDate, referenceFrame: ReferenceFrame, result?: Cartesian3): Cartesian3 | undefined;
    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [other] - The other property.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    equals(other?: Property): boolean;
}

/**
 * A {@link Property} which is defined by a {@link TimeIntervalCollection}, where the
 * data property of each {@link TimeInterval} represents the value at time.
 * @example
 * //Create a Cartesian2 interval property which contains data on August 1st, 2012
 * //and uses a different value every 6 hours.
 * const composite = new Cesium.TimeIntervalCollectionProperty();
 * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({
 *     iso8601 : '2012-08-01T00:00:00.00Z/2012-08-01T06:00:00.00Z',
 *     isStartIncluded : true,
 *     isStopIncluded : false,
 *     data : new Cesium.Cartesian2(2.0, 3.4)
 * }));
 * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({
 *     iso8601 : '2012-08-01T06:00:00.00Z/2012-08-01T12:00:00.00Z',
 *     isStartIncluded : true,
 *     isStopIncluded : false,
 *     data : new Cesium.Cartesian2(12.0, 2.7)
 * }));
 * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({
 *     iso8601 : '2012-08-01T12:00:00.00Z/2012-08-01T18:00:00.00Z',
 *     isStartIncluded : true,
 *     isStopIncluded : false,
 *     data : new Cesium.Cartesian2(5.0, 12.4)
 * }));
 * composite.intervals.addInterval(Cesium.TimeInterval.fromIso8601({
 *     iso8601 : '2012-08-01T18:00:00.00Z/2012-08-02T00:00:00.00Z',
 *     isStartIncluded : true,
 *     isStopIncluded : true,
 *     data : new Cesium.Cartesian2(85.0, 4.1)
 * }));
 */
export class TimeIntervalCollectionProperty {
    constructor();
    /**
     * Gets a value indicating if this property is constant.  A property is considered
     * constant if getValue always returns the same result for the current definition.
     */
    readonly isConstant: boolean;
    /**
     * Gets the event that is raised whenever the definition of this property changes.
     * The definition is changed whenever setValue is called with data different
     * than the current value.
     */
    readonly definitionChanged: Event;
    /**
     * Gets the interval collection.
     */
    readonly intervals: TimeIntervalCollection;
    /**
     * Gets the value of the property at the provided time.
     * @param time - The time for which to retrieve the value.
     * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
     * @returns The modified result parameter or a new instance if the result parameter was not supplied.
     */
    getValue(time: JulianDate, result?: any): any;
    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [other] - The other property.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    equals(other?: Property): boolean;
}

/**
 * A {@link Property} which evaluates to a {@link Quaternion} rotation
 * based on the velocity of the provided {@link PositionProperty}.
 * @example
 * //Create an entity with position and orientation.
 * const position = new Cesium.SampledProperty();
 * position.addSamples(...);
 * const entity = viewer.entities.add({
 *   position : position,
 *   orientation : new Cesium.VelocityOrientationProperty(position)
 * }));
 * @param [position] - The position property used to compute the orientation.
 * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid used to determine which way is up.
 */
export class VelocityOrientationProperty {
    constructor(position?: PositionProperty, ellipsoid?: Ellipsoid);
    /**
     * Gets a value indicating if this property is constant.
     */
    readonly isConstant: boolean;
    /**
     * Gets the event that is raised whenever the definition of this property changes.
     */
    readonly definitionChanged: Event;
    /**
     * Gets or sets the position property used to compute orientation.
     */
    position: Property | undefined;
    /**
     * Gets or sets the ellipsoid used to determine which way is up.
     */
    ellipsoid: Property | undefined;
    /**
     * Gets the value of the property at the provided time.
     * @param [time] - The time for which to retrieve the value.
     * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
     * @returns The modified result parameter or a new instance if the result parameter was not supplied.
     */
    getValue(time?: JulianDate, result?: Quaternion): Quaternion;
    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [other] - The other property.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    equals(other?: Property): boolean;
}

/**
 * A {@link Property} which evaluates to a {@link Cartesian3} vector
 * based on the velocity of the provided {@link PositionProperty}.
 * @example
 * //Create an entity with a billboard rotated to match its velocity.
 * const position = new Cesium.SampledProperty();
 * position.addSamples(...);
 * const entity = viewer.entities.add({
 *   position : position,
 *   billboard : {
 *     image : 'image.png',
 *     alignedAxis : new Cesium.VelocityVectorProperty(position, true) // alignedAxis must be a unit vector
 *   }
 * }));
 * @param [position] - The position property used to compute the velocity.
 * @param [normalize = true] - Whether to normalize the computed velocity vector.
 */
export class VelocityVectorProperty {
    constructor(position?: PositionProperty, normalize?: boolean);
    /**
     * Gets a value indicating if this property is constant.
     */
    readonly isConstant: boolean;
    /**
     * Gets the event that is raised whenever the definition of this property changes.
     */
    readonly definitionChanged: Event;
    /**
     * Gets or sets the position property used to compute the velocity vector.
     */
    position: Property | undefined;
    /**
     * Gets or sets whether the vector produced by this property
     * will be normalized or not.
     */
    normalize: boolean;
    /**
     * Gets the value of the property at the provided time.
     * @param [time] - The time for which to retrieve the value.
     * @param [result] - The object to store the value into, if omitted, a new instance is created and returned.
     * @returns The modified result parameter or a new instance if the result parameter was not supplied.
     */
    getValue(time?: JulianDate, result?: Cartesian3): Cartesian3;
    /**
     * Compares this property to the provided property and returns
     * <code>true</code> if they are equal, <code>false</code> otherwise.
     * @param [other] - The other property.
     * @returns <code>true</code> if left and right are equal, <code>false</code> otherwise.
     */
    equals(other?: Property): boolean;
}

/**
 * Defines the interface for visualizers. Visualizers are plug-ins to
 * {@link DataSourceDisplay} that render data associated with
 * {@link DataSource} instances.
 * This object is an interface for documentation purposes and is not intended
 * to be instantiated directly.
 */
export class Visualizer {
    constructor();
    /**
     * Updates the visualization to the provided time.
     * @param time - The time.
     * @returns True if the display was updated to the provided time,
     * false if the visualizer is waiting for an asynchronous operation to
     * complete before data can be updated.
     */
    update(time: JulianDate): boolean;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * @returns True if this object was destroyed; otherwise, false.
     */
    isDestroyed(): boolean;
    /**
     * Removes all visualization and cleans up any resources associated with this instance.
     */
    destroy(): void;
}

/**
 * A {@link GeometryUpdater} for walls.
 * Clients do not normally create this class directly, but instead rely on {@link DataSourceDisplay}.
 * @param entity - The entity containing the geometry to be visualized.
 * @param scene - The scene where visualization is taking place.
 */
export class WallGeometryUpdater {
    constructor(entity: Entity, scene: Scene);
    /**
     * Creates the geometry instance which represents the fill of the geometry.
     * @param time - The time to use when retrieving initial attribute values.
     * @returns The geometry instance representing the filled portion of the geometry.
     */
    createFillGeometryInstance(time: JulianDate): GeometryInstance;
    /**
     * Creates the geometry instance which represents the outline of the geometry.
     * @param time - The time to use when retrieving initial attribute values.
     * @returns The geometry instance representing the outline portion of the geometry.
     */
    createOutlineGeometryInstance(time: JulianDate): GeometryInstance;
}

export namespace WallGraphics {
    /**
     * Initialization options for the WallGraphics constructor
     * [show = true] - A boolean Property specifying the visibility of the wall.
     * [positions] - A Property specifying the array of {@link Cartesian3} positions which define the top of the wall.
     * [minimumHeights] - A Property specifying an array of heights to be used for the bottom of the wall instead of the globe surface.
     * [maximumHeights] - A Property specifying an array of heights to be used for the top of the wall instead of the height of each position.
     * [granularity = Cesium.Math.RADIANS_PER_DEGREE] - A numeric Property specifying the angular distance between each latitude and longitude point.
     * [fill = true] - A boolean Property specifying whether the wall is filled with the provided material.
     * [material = Color.WHITE] - A Property specifying the material used to fill the wall.
     * [outline = false] - A boolean Property specifying whether the wall is outlined.
     * [outlineColor = Color.BLACK] - A Property specifying the {@link Color} of the outline.
     * [outlineWidth = 1.0] - A numeric Property specifying the width of the outline.
     * [shadows = ShadowMode.DISABLED] - An enum Property specifying whether the wall casts or receives shadows from light sources.
     * [distanceDisplayCondition] - A Property specifying at what distance from the camera that this wall will be displayed.
     */
    type ConstructorOptions = {
        show?: Property | boolean;
        positions?: Property | Cartesian3[];
        minimumHeights?: Property | number[];
        maximumHeights?: Property | number[];
        granularity?: Property | number;
        fill?: Property | boolean;
        material?: MaterialProperty | Color;
        outline?: Property | boolean;
        outlineColor?: Property | Color;
        outlineWidth?: Property | number;
        shadows?: Property | ShadowMode;
        distanceDisplayCondition?: Property | DistanceDisplayCondition;
    };
}

/**
 * Describes a two dimensional wall defined as a line strip and optional maximum and minimum heights.
 * The wall conforms to the curvature of the globe and can be placed along the surface or at altitude.
 * @param [options] - Object describing initialization options
 */
export class WallGraphics {
    constructor(options?: WallGraphics.ConstructorOptions);
    /**
     * Gets the event that is raised whenever a property or sub-property is changed or modified.
     */
    readonly definitionChanged: Event;
    /**
     * Gets or sets the boolean Property specifying the visibility of the wall.
     */
    show: Property | undefined;
    /**
     * Gets or sets the Property specifying the array of {@link Cartesian3} positions which define the top of the wall.
     */
    positions: Property | undefined;
    /**
     * Gets or sets the Property specifying an array of heights to be used for the bottom of the wall instead of the surface of the globe.
     * If defined, the array must be the same length as {@link Wall#positions}.
     */
    minimumHeights: Property | undefined;
    /**
     * Gets or sets the Property specifying an array of heights to be used for the top of the wall instead of the height of each position.
     * If defined, the array must be the same length as {@link Wall#positions}.
     */
    maximumHeights: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the angular distance between points on the wall.
     */
    granularity: Property | undefined;
    /**
     * Gets or sets the boolean Property specifying whether the wall is filled with the provided material.
     */
    fill: Property | undefined;
    /**
     * Gets or sets the Property specifying the material used to fill the wall.
     */
    material: MaterialProperty;
    /**
     * Gets or sets the Property specifying whether the wall is outlined.
     */
    outline: Property | undefined;
    /**
     * Gets or sets the Property specifying the {@link Color} of the outline.
     */
    outlineColor: Property | undefined;
    /**
     * Gets or sets the numeric Property specifying the width of the outline.
     * <p>
     * Note: This property will be ignored on all major browsers on Windows platforms. For details, see (@link https://github.com/CesiumGS/cesium/issues/40}.
     * </p>
     */
    outlineWidth: Property | undefined;
    /**
     * Get or sets the enum Property specifying whether the wall
     * casts or receives shadows from light sources.
     */
    shadows: Property | undefined;
    /**
     * Gets or sets the {@link DistanceDisplayCondition} Property specifying at what distance from the camera that this wall will be displayed.
     */
    distanceDisplayCondition: Property | undefined;
    /**
     * Duplicates this instance.
     * @param [result] - The object onto which to store the result.
     * @returns The modified result parameter or a new instance if one was not provided.
     */
    clone(result?: WallGraphics): WallGraphics;
    /**
     * Assigns each unassigned property on this object to the value
     * of the same property on the provided source object.
     * @param source - The object to be merged into this object.
     */
    merge(source: WallGraphics): void;
}

/**
 * kml - The generated KML.
 * externalFiles - An object dictionary of external files
 */
export type exportKmlResultKml = {
    kml: string;
    externalFiles: {
        [key: string]: Blob;
    };
};

/**
 * kmz - The generated kmz file.
 */
export type exportKmlResultKmz = {
    kmz: Blob;
};

/**
 * Exports an EntityCollection as a KML document. Only Point, Billboard, Model, Path, Polygon, Polyline geometries
 * will be exported. Note that there is not a 1 to 1 mapping of Entity properties to KML Feature properties. For
 * example, entity properties that are time dynamic but cannot be dynamic in KML are exported with their values at
 * options.time or the beginning of the EntityCollection's time interval if not specified. For time-dynamic properties
 * that are supported in KML, we use the samples if it is a {@link SampledProperty} otherwise we sample the value using
 * the options.sampleDuration. Point, Billboard, Model and Path geometries with time-dynamic positions will be exported
 * as gx:Track Features. Not all Materials are representable in KML, so for more advanced Materials just the primary
 * color is used. Canvas objects are exported as PNG images.
 * @example
 * Cesium.exportKml({
 *      entities: entityCollection
 *  })
 *   .then(function(result) {
 *     // The XML string is in result.kml
 *
 *     const externalFiles = result.externalFiles
 *     for(const file in externalFiles) {
 *       // file is the name of the file used in the KML document as the href
 *       // externalFiles[file] is a blob with the contents of the file
 *     }
 *   });
 * @param options - An object with the following properties:
 * @param options.entities - The EntityCollection to export as KML.
 * @param [options.ellipsoid = Ellipsoid.WGS84] - The ellipsoid for the output file.
 * @param [options.modelCallback] - A callback that will be called with a {@link ModelGraphics} instance and should return the URI to use in the KML. Required if a model exists in the entity collection.
 * @param [options.time = entities.computeAvailability().start] - The time value to use to get properties that are not time varying in KML.
 * @param [options.defaultAvailability = entities.computeAvailability()] - The interval that will be sampled if an entity doesn't have an availability.
 * @param [options.sampleDuration = 60] - The number of seconds to sample properties that are varying in KML.
 * @param [options.kmz = false] - If true KML and external files will be compressed into a kmz file.
 * @returns A promise that resolved to an object containing the KML string and a dictionary of external file blobs, or a kmz file as a blob if options.kmz is true.
 */
export function exportKml(options: {
    entities: EntityCollection;
    ellipsoid?: Ellipsoid;
    modelCallback?: exportKmlModelCallback;
    time?: JulianDate;
    defaultAvailability?: TimeInterval;
    sampleDuration?: number;
    kmz?: boolean;
}): Promise<exportKmlResultKml | exportKmlResultKmz>;

/**
 * Since KML does not support glTF models, this callback is required to specify what URL to use for the model in the KML document.
 * It can also be used to add additional files to the <code>externalFiles</code> object, which is the list of files embedded in the exported KMZ,
 * or otherwise returned with the KML string when exporting.
 * @param model - The ModelGraphics instance for an Entity.
 * @param time - The time that any properties should use to get the value.
 * @param externalFiles - An object that maps a filename to a Blob or a Promise that resolves to a Blob.
 */
export type exportKmlModelCallback = (model: ModelGraphics, time: JulianDate, externalFiles: any) => string;

/**
 * Options to control the setting up of a WebGL Context.
 * <p>
 * <code>allowTextureFilterAnisotropic</code> defaults to true, which enables
 * anisotropic texture filtering when the WebGL extension is supported.
 * Setting this to false will improve performance, but hurt visual quality,
 * especially for horizon views.
 * </p>
 * [requestWebgl1 = false] - If true and the browser supports it, use a WebGL 1 rendering context
 * [allowTextureFilterAnisotropic = true] - If true, use anisotropic filtering during texture sampling
 * [webgl] - WebGL options to be passed on to canvas.getContext
 * [getWebGLStub] - A function to create a WebGL stub for testing
 */
export type ContextOptions = {
    requestWebgl1?: boolean;
    allowTextureFilterAnisotropic?: boolean;
    webgl?: WebGLOptions;
    getWebGLStub?: (...params: any[]) => any;
};

/**
 * WebGL options to be passed on to HTMLCanvasElement.getContext().
 * See {@link https://registry.khronos.org/webgl/specs/latest/1.0/#5.2|WebGLContextAttributes}
 * but note the modified defaults for 'alpha', 'stencil', and 'powerPreference'
 *
 * <p>
 * <code>alpha</code> defaults to false, which can improve performance
 * compared to the standard WebGL default of true.  If an application needs
 * to composite Cesium above other HTML elements using alpha-blending, set
 * <code>alpha</code> to true.
 * </p>
 */
export type WebGLOptions = {
    alpha?: boolean;
    depth?: boolean;
    stencil?: boolean;
    antialias?: boolean;
    premultipliedAlpha?: boolean;
    preserveDrawingBuffer?: boolean;
    powerPreference?: "default" | "low-power" | "high-performance";
    failIfMajorPerformanceCaveat?: boolean;
};

/**
 * The data type of a pixel.
 */
export enum PixelDatatype {
    UNSIGNED_BYTE = WebGLConstants.UNSIGNED_BYTE,
    UNSIGNED_SHORT = WebGLConstants.UNSIGNED_SHORT,
    UNSIGNED_INT = WebGLConstants.UNSIGNED_INT,
    FLOAT = WebGLConstants.FLOAT,
    HALF_FLOAT = WebGLConstants.HALF_FLOAT_OES,
    UNSIGNED_INT_24_8 = WebGLConstants.UNSIGNED_INT_24_8,
    UNSIGNED_SHORT_4_4_4_4 = WebGLConstants.UNSIGNED_SHORT_4_4_4_4,
    UNSIGNED_SHORT_5_5_5_1 = WebGLConstants.UNSIGNED_SHORT_5_5_5_1,
    UNSIGNED_SHORT_5_6_5 = WebGLConstants.UNSIGNED_SHORT_5_6_5
}

/**
 * Enumerates all possible filters used when magnifying WebGL textures.
 */
export enum TextureMagnificationFilter {
    /**
     * Samples the texture by returning the closest pixel.
     */
    NEAREST = WebGLConstants.NEAREST,
    /**
     * Samples the texture through bi-linear interpolation of the four nearest pixels. This produces smoother results than <code>NEAREST</code> filtering.
     */
    LINEAR = WebGLConstants.LINEAR
}

/**
 * Enumerates all possible filters used when minifying WebGL textures.
 */
export enum TextureMinificationFilter {
    /**
     * Samples the texture by returning the closest pixel.
     */
    NEAREST = WebGLConstants.NEAREST,
    /**
     * Samples the texture through bi-linear interpolation of the four nearest pixels. This produces smoother results than <code>NEAREST</code> filtering.
     */
    LINEAR = WebGLConstants.LINEAR,
    /**
     * Selects the nearest mip level and applies nearest sampling within that level.
     * <p>
     * Requires that the texture has a mipmap. The mip level is chosen by the view angle and screen-space size of the texture.
     * </p>
     */
    NEAREST_MIPMAP_NEAREST = WebGLConstants.NEAREST_MIPMAP_NEAREST,
    /**
     * Selects the nearest mip level and applies linear sampling within that level.
     * <p>
     * Requires that the texture has a mipmap. The mip level is chosen by the view angle and screen-space size of the texture.
     * </p>
     */
    LINEAR_MIPMAP_NEAREST = WebGLConstants.LINEAR_MIPMAP_NEAREST,
    /**
     * Read texture values with nearest sampling from two adjacent mip levels and linearly interpolate the results.
     * <p>
     * This option provides a good balance of visual quality and speed when sampling from a mipmapped texture.
     * </p>
     * <p>
     * Requires that the texture has a mipmap. The mip level is chosen by the view angle and screen-space size of the texture.
     * </p>
     */
    NEAREST_MIPMAP_LINEAR = WebGLConstants.NEAREST_MIPMAP_LINEAR,
    /**
     * Read texture values with linear sampling from two adjacent mip levels and linearly interpolate the results.
     * <p>
     * This option provides a good balance of visual quality and speed when sampling from a mipmapped texture.
     * </p>
     * <p>
     * Requires that the texture has a mipmap. The mip level is chosen by the view angle and screen-space size of the texture.
     * </p>
     */
    LINEAR_MIPMAP_LINEAR = WebGLConstants.LINEAR_MIPMAP_LINEAR
}

/**
 * An appearance defines the full GLSL vertex and fragment shaders and the
 * render state used to draw a {@link Primitive}.  All appearances implement
 * this base <code>Appearance</code> interface.
 * @param [options] - Object with the following properties:
 * @param [options.translucent = true] - When <code>true</code>, the geometry is expected to appear translucent so {@link Appearance#renderState} has alpha blending enabled.
 * @param [options.closed = false] - When <code>true</code>, the geometry is expected to be closed so {@link Appearance#renderState} has backface culling enabled.
 * @param [options.material = Material.ColorType] - The material used to determine the fragment color.
 * @param [options.vertexShaderSource] - Optional GLSL vertex shader source to override the default vertex shader.
 * @param [options.fragmentShaderSource] - Optional GLSL fragment shader source to override the default fragment shader.
 * @param [options.renderState] - Optional render state to override the default render state.
 */
export class Appearance {
    constructor(options?: {
        translucent?: boolean;
        closed?: boolean;
        material?: Material;
        vertexShaderSource?: string;
        fragmentShaderSource?: string;
        renderState?: any;
    });
    /**
     * The material used to determine the fragment color.  Unlike other {@link Appearance}
     * properties, this is not read-only, so an appearance's material can change on the fly.
     */
    material: Material;
    /**
     * When <code>true</code>, the geometry is expected to appear translucent.
     */
    translucent: boolean;
    /**
     * The GLSL source code for the vertex shader.
     */
    readonly vertexShaderSource: string;
    /**
     * The GLSL source code for the fragment shader.  The full fragment shader
     * source is built procedurally taking into account the {@link Appearance#material}.
     * Use {@link Appearance#getFragmentShaderSource} to get the full source.
     */
    readonly fragmentShaderSource: string;
    /**
     * The WebGL fixed-function state to use when rendering the geometry.
     */
    readonly renderState: any;
    /**
     * When <code>true</code>, the geometry is expected to be closed.
     */
    readonly closed: boolean;
    /**
     * Procedurally creates the full GLSL fragment shader source for this appearance
     * taking into account {@link Appearance#fragmentShaderSource} and {@link Appearance#material}.
     * @returns The full GLSL fragment shader source.
     */
    getFragmentShaderSource(): string;
    /**
     * Determines if the geometry is translucent based on {@link Appearance#translucent} and {@link Material#isTranslucent}.
     * @returns <code>true</code> if the appearance is translucent.
     */
    isTranslucent(): boolean;
    /**
     * Creates a render state.  This is not the final render state instance; instead,
     * it can contain a subset of render state properties identical to the render state
     * created in the context.
     * @returns The render state.
     */
    getRenderState(): any;
}

/**
 * ArcGisBaseMapType enumerates the ArcGIS image tile layers that are supported by default.
 */
export enum ArcGisBaseMapType {
    SATELLITE = 1,
    OCEANS = 2,
    HILLSHADE = 3
}

export namespace ArcGisMapServerImageryProvider {
    /**
     * Initialization options for the ArcGisMapServerImageryProvider constructor
     * [tileDiscardPolicy] - The policy that determines if a tile
     *        is invalid and should be discarded.  If this value is not specified, a default
     *        {@link DiscardMissingTileImagePolicy} is used for tiled map servers, and a
     *        {@link NeverTileDiscardPolicy} is used for non-tiled map servers.  In the former case,
     *        we request tile 0,0 at the maximum tile level and check pixels (0,0), (200,20), (20,200),
     *        (80,110), and (160, 130).  If all of these pixels are transparent, the discard check is
     *        disabled and no tiles are discarded.  If any of them have a non-transparent color, any
     *        tile that has the same values in these pixel locations is discarded.  The end result of
     *        these defaults should be correct tile discarding for a standard ArcGIS Server.  To ensure
     *        that no tiles are discarded, construct and pass a {@link NeverTileDiscardPolicy} for this
     *        parameter.
     * [usePreCachedTilesIfAvailable = true] - If true, the server's pre-cached
     *        tiles are used if they are available. Exporting Tiles is only supported with deprecated APIs.
     * [layers] - A comma-separated list of the layers to show, or undefined if all layers should be shown.
     * [enablePickFeatures = true] - If true, {@link ArcGisMapServerImageryProvider#pickFeatures} will invoke
     *        the Identify service on the MapServer and return the features included in the response.  If false,
     *        {@link ArcGisMapServerImageryProvider#pickFeatures} will immediately return undefined (indicating no pickable features)
     *        without communicating with the server.  Set this property to false if you don't want this provider's features to
     *        be pickable. Can be overridden by setting the {@link ArcGisMapServerImageryProvider#enablePickFeatures} property on the object.
     * [rectangle = Rectangle.MAX_VALUE] - The rectangle of the layer.  This parameter is ignored when accessing
     *                    a tiled layer.
     * [tilingScheme = new GeographicTilingScheme()] - The tiling scheme to use to divide the world into tiles.
     *                       This parameter is ignored when accessing a tiled server.
     * [ellipsoid] - The ellipsoid.  If the tilingScheme is specified and used,
     *                    this parameter is ignored and the tiling scheme's ellipsoid is used instead. If neither
     *                    parameter is specified, the WGS84 ellipsoid is used.
     * [credit] - A credit for the data source, which is displayed on the canvas.  This parameter is ignored when accessing a tiled server.
     * [tileWidth = 256] - The width of each tile in pixels.  This parameter is ignored when accessing a tiled server.
     * [tileHeight = 256] - The height of each tile in pixels.  This parameter is ignored when accessing a tiled server.
     * [maximumLevel] - The maximum tile level to request, or undefined if there is no maximum.  This parameter is ignored when accessing
     *                                        a tiled server.
     */
    type ConstructorOptions = {
        tileDiscardPolicy?: TileDiscardPolicy;
        usePreCachedTilesIfAvailable?: boolean;
        layers?: string;
        enablePickFeatures?: boolean;
        rectangle?: Rectangle;
        tilingScheme?: TilingScheme;
        ellipsoid?: Ellipsoid;
        credit?: Credit | string;
        tileWidth?: number;
        tileHeight?: number;
        maximumLevel?: number;
    };
}

/**
 * <div class="notice">
 * This object is normally not instantiated directly, use {@link ArcGisMapServerImageryProvider.fromBasemapType} or {@link ArcGisMapServerImageryProvider.fromUrl}.
 * </div>
 *
 * Provides tiled imagery hosted by an ArcGIS MapServer.  By default, the server's pre-cached tiles are
 * used, if available.
 *
 * <br/>
 *
 * An {@link https://developers.arcgis.com/documentation/mapping-apis-and-services/security| ArcGIS Access Token } is required to authenticate requests to an ArcGIS Image Tile service.
 * To access secure ArcGIS resources, it's required to create an ArcGIS developer
 * account or an ArcGIS online account, then implement an authentication method to obtain an access token.
 * @example
 * // Set the default access token for accessing ArcGIS Image Tile service
 * Cesium.ArcGisMapService.defaultAccessToken = "<ArcGIS Access Token>";
 *
 * // Add a base layer from a default ArcGIS basemap
 * const viewer = new Cesium.Viewer("cesiumContainer", {
 *   baseLayer: Cesium.ImageryLayer.fromProviderAsync(
 *     Cesium.ArcGisMapServerImageryProvider.fromBasemapType(
 *       Cesium.ArcGisBaseMapType.SATELLITE
 *     )
 *   ),
 * });
 * @example
 * // Create an imagery provider from the url directly
 * const esri = await Cesium.ArcGisMapServerImageryProvider.fromUrl(
 *   "https://ibasemaps-api.arcgis.com/arcgis/rest/services/World_Imagery/MapServer", {
 *     token: "<ArcGIS Access Token>"
 * });
 * @param [options] - Object describing initialization options
 */
export class ArcGisMapServerImageryProvider {
    constructor(options?: ArcGisMapServerImageryProvider.ConstructorOptions);
    /**
     * Gets or sets a value indicating whether feature picking is enabled.  If true, {@link ArcGisMapServerImageryProvider#pickFeatures} will
     * invoke the "identify" operation on the ArcGIS server and return the features included in the response.  If false,
     * {@link ArcGisMapServerImageryProvider#pickFeatures} will immediately return undefined (indicating no pickable features)
     * without communicating with the server.
     */
    enablePickFeatures: boolean;
    /**
     * Creates an {@link ImageryProvider} which provides tiled imagery from an ArcGIS base map.
     * @example
     * // Set the default access token for accessing ArcGIS Image Tile service
     * Cesium.ArcGisMapService.defaultAccessToken = "<ArcGIS Access Token>";
     *
     * // Add a base layer from a default ArcGIS basemap
     * const provider = await Cesium.ArcGisMapServerImageryProvider.fromBasemapType(
     *   Cesium.ArcGisBaseMapType.SATELLITE);
     * @example
     * // Add a base layer from a default ArcGIS Basemap
     * const viewer = new Cesium.Viewer("cesiumContainer", {
     *   baseLayer: Cesium.ImageryLayer.fromProviderAsync(
     *     Cesium.ArcGisMapServerImageryProvider.fromBasemapType(
     *       Cesium.ArcGisBaseMapType.HILLSHADE, {
     *         token: "<ArcGIS Access Token>"
     *       }
     *     )
     *   ),
     * });
     * @param style - The style of the ArcGIS base map imagery. Valid options are {@link ArcGisBaseMapType.SATELLITE}, {@link ArcGisBaseMapType.OCEANS}, and {@link ArcGisBaseMapType.HILLSHADE}.
     * @param [options] - Object describing initialization options.
     * @returns A promise that resolves to the created ArcGisMapServerImageryProvider.
     */
    static fromBasemapType(style: ArcGisBaseMapType, options?: ArcGisMapServerImageryProvider.ConstructorOptions): Promise<ArcGisMapServerImageryProvider>;
    /**
     * Gets the URL of the ArcGIS MapServer.
     */
    readonly url: string;
    /**
     * Gets the ArcGIS token used to authenticate with the ArcGis MapServer service.
     */
    readonly token: string;
    /**
     * Gets the proxy used by this provider.
     */
    readonly proxy: Proxy;
    /**
     * Gets the width of each tile, in pixels.
     */
    readonly tileWidth: number;
    /**
     * Gets the height of each tile, in pixels.
     */
    readonly tileHeight: number;
    /**
     * Gets the maximum level-of-detail that can be requested.
     */
    readonly maximumLevel: number | undefined;
    /**
     * Gets the minimum level-of-detail that can be requested.
     */
    readonly minimumLevel: number;
    /**
     * Gets the tiling scheme used by this provider.
     */
    readonly tilingScheme: TilingScheme;
    /**
     * Gets the rectangle, in radians, of the imagery provided by this instance.
     */
    readonly rectangle: Rectangle;
    /**
     * Gets the tile discard policy.  If not undefined, the discard policy is responsible
     * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
     * returns undefined, no tiles are filtered.
     */
    readonly tileDiscardPolicy: TileDiscardPolicy;
    /**
     * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
     * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
     * are passed an instance of {@link TileProviderError}.
     */
    readonly errorEvent: Event;
    /**
     * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
     * the source of the imagery.
     */
    readonly credit: Credit;
    /**
     * Gets a value indicating whether this imagery provider is using pre-cached tiles from the
     * ArcGIS MapServer.
     */
    readonly usingPrecachedTiles: boolean;
    /**
     * Gets a value indicating whether or not the images provided by this imagery provider
     * include an alpha channel.  If this property is false, an alpha channel, if present, will
     * be ignored.  If this property is true, any images without an alpha channel will be treated
     * as if their alpha is 1.0 everywhere.  When this property is false, memory usage
     * and texture upload time are reduced.
     */
    readonly hasAlphaChannel: boolean;
    /**
     * Gets the comma-separated list of layer IDs to show.
     */
    layers: string;
    /**
     * Creates an {@link ImageryProvider} which provides tiled imagery hosted by an ArcGIS MapServer.  By default, the server's pre-cached tiles are
     * used, if available.
     * @example
     * const esri = await Cesium.ArcGisMapServerImageryProvider.fromUrl(
     *     "https://services.arcgisonline.com/ArcGIS/rest/services/World_Imagery/MapServer"
     * );
     * @param url - The URL of the ArcGIS MapServer service.
     * @param [options] - Object describing initialization options.
     * @returns A promise that resolves to the created ArcGisMapServerImageryProvider.
     */
    static fromUrl(url: Resource | string, options?: ArcGisMapServerImageryProvider.ConstructorOptions): Promise<ArcGisMapServerImageryProvider>;
    /**
     * Gets the credits to be displayed when a given tile is displayed.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level;
     * @returns The credits to be displayed when the tile is displayed.
     */
    getTileCredits(x: number, y: number, level: number): Credit[];
    /**
     * Requests the image for a given tile.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level.
     * @param [request] - The request object. Intended for internal use only.
     * @returns A promise for the image that will resolve when the image is available, or
     *          undefined if there are too many active requests to the server, and the request should be retried later.
     */
    requestImage(x: number, y: number, level: number, request?: Request): Promise<ImageryTypes> | undefined;
    /**
     * /**
     * Asynchronously determines what features, if any, are located at a given longitude and latitude within
     * a tile.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level.
     * @param longitude - The longitude at which to pick features.
     * @param latitude - The latitude at which to pick features.
     * @returns A promise for the picked features that will resolve when the asynchronous
     *                   picking completes.  The resolved value is an array of {@link ImageryLayerFeatureInfo}
     *                   instances.  The array may be empty if no features are found at the given location.
     */
    pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): Promise<ImageryLayerFeatureInfo[]> | undefined;
}

/**
 * Default options for accessing the ArcGIS image tile service.
 *
 * An ArcGIS access token is required to access ArcGIS image tile layers.
 * A default token is provided for evaluation purposes only.
 * To obtain an access token, go to {@link https://developers.arcgis.com} and create a free account.
 * More info can be found in the {@link https://developers.arcgis.com/documentation/mapping-apis-and-services/security/ | ArcGIS developer guide}.
 */
export namespace ArcGisMapService {
    /**
     * Gets or sets the default ArcGIS access token.
     */
    var defaultAccessToken: string;
    /**
     * Gets or sets the URL of the ArcGIS World Imagery tile service.
     */
    var defaultWorldImageryServer: string | Resource;
    /**
     * Gets or sets the URL of the ArcGIS World Hillshade tile service.
     */
    var defaultWorldHillshadeServer: string | Resource;
    /**
     * Gets or sets the URL of the ArcGIS World Oceans tile service.
     */
    var defaultWorldOceanServer: string | Resource;
    function getDefaultTokenCredit(providedKey: string): string | undefined;
}

/**
 * An enum describing the x, y, and z axes and helper conversion functions.
 */
export enum Axis {
    /**
     * Denotes the x-axis.
     */
    X = 0,
    /**
     * Denotes the y-axis.
     */
    Y = 1,
    /**
     * Denotes the z-axis.
     */
    Z = 2
}

/**
 * <div class="notice">
 * A billboard is created and its initial
 * properties are set by calling {@link BillboardCollection#add}. Do not call the constructor directly.
 * </div>
 * A viewport-aligned image positioned in the 3D scene, that is created
 * and rendered using a {@link BillboardCollection}.
 * <br /><br />
 * <div align='center'>
 * <img src='Images/Billboard.png' width='400' height='300' /><br />
 * Example billboards
 * </div>
 */
export class Billboard {
    constructor();
    /**
     * Determines if this billboard will be shown.  Use this to hide or show a billboard, instead
     * of removing it and re-adding it to the collection.
     */
    show: boolean;
    /**
     * Gets or sets the Cartesian position of this billboard.
     */
    position: Cartesian3;
    /**
     * Gets or sets the height reference of this billboard.
     */
    heightReference: HeightReference;
    /**
     * Gets or sets the pixel offset in screen space from the origin of this billboard.  This is commonly used
     * to align multiple billboards and labels at the same position, e.g., an image and text.  The
     * screen space origin is the top, left corner of the canvas; <code>x</code> increases from
     * left to right, and <code>y</code> increases from top to bottom.
     * <br /><br />
     * <div align='center'>
     * <table border='0' cellpadding='5'><tr>
     * <td align='center'><code>default</code><br/><img src='Images/Billboard.setPixelOffset.default.png' width='250' height='188' /></td>
     * <td align='center'><code>b.pixeloffset = new Cartesian2(50, 25);</code><br/><img src='Images/Billboard.setPixelOffset.x50y-25.png' width='250' height='188' /></td>
     * </tr></table>
     * The billboard's origin is indicated by the yellow point.
     * </div>
     */
    pixelOffset: Cartesian2;
    /**
     * Gets or sets near and far scaling properties of a Billboard based on the billboard's distance from the camera.
     * A billboard's scale will interpolate between the {@link NearFarScalar#nearValue} and
     * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
     * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
     * Outside of these ranges the billboard's scale remains clamped to the nearest bound.  If undefined,
     * scaleByDistance will be disabled.
     * @example
     * // Example 1.
     * // Set a billboard's scaleByDistance to scale by 1.5 when the
     * // camera is 1500 meters from the billboard and disappear as
     * // the camera distance approaches 8.0e6 meters.
     * b.scaleByDistance = new Cesium.NearFarScalar(1.5e2, 1.5, 8.0e6, 0.0);
     * @example
     * // Example 2.
     * // disable scaling by distance
     * b.scaleByDistance = undefined;
     */
    scaleByDistance: NearFarScalar;
    /**
     * Gets or sets near and far translucency properties of a Billboard based on the billboard's distance from the camera.
     * A billboard's translucency will interpolate between the {@link NearFarScalar#nearValue} and
     * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
     * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
     * Outside of these ranges the billboard's translucency remains clamped to the nearest bound.  If undefined,
     * translucencyByDistance will be disabled.
     * @example
     * // Example 1.
     * // Set a billboard's translucency to 1.0 when the
     * // camera is 1500 meters from the billboard and disappear as
     * // the camera distance approaches 8.0e6 meters.
     * b.translucencyByDistance = new Cesium.NearFarScalar(1.5e2, 1.0, 8.0e6, 0.0);
     * @example
     * // Example 2.
     * // disable translucency by distance
     * b.translucencyByDistance = undefined;
     */
    translucencyByDistance: NearFarScalar;
    /**
     * Gets or sets near and far pixel offset scaling properties of a Billboard based on the billboard's distance from the camera.
     * A billboard's pixel offset will be scaled between the {@link NearFarScalar#nearValue} and
     * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
     * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
     * Outside of these ranges the billboard's pixel offset scale remains clamped to the nearest bound.  If undefined,
     * pixelOffsetScaleByDistance will be disabled.
     * @example
     * // Example 1.
     * // Set a billboard's pixel offset scale to 0.0 when the
     * // camera is 1500 meters from the billboard and scale pixel offset to 10.0 pixels
     * // in the y direction the camera distance approaches 8.0e6 meters.
     * b.pixelOffset = new Cesium.Cartesian2(0.0, 1.0);
     * b.pixelOffsetScaleByDistance = new Cesium.NearFarScalar(1.5e2, 0.0, 8.0e6, 10.0);
     * @example
     * // Example 2.
     * // disable pixel offset by distance
     * b.pixelOffsetScaleByDistance = undefined;
     */
    pixelOffsetScaleByDistance: NearFarScalar;
    /**
     * Gets or sets the 3D Cartesian offset applied to this billboard in eye coordinates.  Eye coordinates is a left-handed
     * coordinate system, where <code>x</code> points towards the viewer's right, <code>y</code> points up, and
     * <code>z</code> points into the screen.  Eye coordinates use the same scale as world and model coordinates,
     * which is typically meters.
     * <br /><br />
     * An eye offset is commonly used to arrange multiple billboards or objects at the same position, e.g., to
     * arrange a billboard above its corresponding 3D model.
     * <br /><br />
     * Below, the billboard is positioned at the center of the Earth but an eye offset makes it always
     * appear on top of the Earth regardless of the viewer's or Earth's orientation.
     * <br /><br />
     * <div align='center'>
     * <table border='0' cellpadding='5'><tr>
     * <td align='center'><img src='Images/Billboard.setEyeOffset.one.png' width='250' height='188' /></td>
     * <td align='center'><img src='Images/Billboard.setEyeOffset.two.png' width='250' height='188' /></td>
     * </tr></table>
     * <code>b.eyeOffset = new Cartesian3(0.0, 8000000.0, 0.0);</code><br /><br />
     * </div>
     */
    eyeOffset: Cartesian3;
    /**
     * Gets or sets the horizontal origin of this billboard, which determines if the billboard is
     * to the left, center, or right of its anchor position.
     * <br /><br />
     * <div align='center'>
     * <img src='Images/Billboard.setHorizontalOrigin.png' width='648' height='196' /><br />
     * </div>
     * @example
     * // Use a bottom, left origin
     * b.horizontalOrigin = Cesium.HorizontalOrigin.LEFT;
     * b.verticalOrigin = Cesium.VerticalOrigin.BOTTOM;
     */
    horizontalOrigin: HorizontalOrigin;
    /**
     * Gets or sets the vertical origin of this billboard, which determines if the billboard is
     * to the above, below, or at the center of its anchor position.
     * <br /><br />
     * <div align='center'>
     * <img src='Images/Billboard.setVerticalOrigin.png' width='695' height='175' /><br />
     * </div>
     * @example
     * // Use a bottom, left origin
     * b.horizontalOrigin = Cesium.HorizontalOrigin.LEFT;
     * b.verticalOrigin = Cesium.VerticalOrigin.BOTTOM;
     */
    verticalOrigin: VerticalOrigin;
    /**
     * Gets or sets the uniform scale that is multiplied with the billboard's image size in pixels.
     * A scale of <code>1.0</code> does not change the size of the billboard; a scale greater than
     * <code>1.0</code> enlarges the billboard; a positive scale less than <code>1.0</code> shrinks
     * the billboard.
     * <br /><br />
     * <div align='center'>
     * <img src='Images/Billboard.setScale.png' width='400' height='300' /><br/>
     * From left to right in the above image, the scales are <code>0.5</code>, <code>1.0</code>,
     * and <code>2.0</code>.
     * </div>
     */
    scale: number;
    /**
     * Gets or sets the color that is multiplied with the billboard's texture.  This has two common use cases.  First,
     * the same white texture may be used by many different billboards, each with a different color, to create
     * colored billboards.  Second, the color's alpha component can be used to make the billboard translucent as shown below.
     * An alpha of <code>0.0</code> makes the billboard transparent, and <code>1.0</code> makes the billboard opaque.
     * <br /><br />
     * <div align='center'>
     * <table border='0' cellpadding='5'><tr>
     * <td align='center'><code>default</code><br/><img src='Images/Billboard.setColor.Alpha255.png' width='250' height='188' /></td>
     * <td align='center'><code>alpha : 0.5</code><br/><img src='Images/Billboard.setColor.Alpha127.png' width='250' height='188' /></td>
     * </tr></table>
     * </div>
     * <br />
     * The red, green, blue, and alpha values are indicated by <code>value</code>'s <code>red</code>, <code>green</code>,
     * <code>blue</code>, and <code>alpha</code> properties as shown in Example 1.  These components range from <code>0.0</code>
     * (no intensity) to <code>1.0</code> (full intensity).
     * @example
     * // Example 1. Assign yellow.
     * b.color = Cesium.Color.YELLOW;
     * @example
     * // Example 2. Make a billboard 50% translucent.
     * b.color = new Cesium.Color(1.0, 1.0, 1.0, 0.5);
     */
    color: Color;
    /**
     * Gets or sets the rotation angle in radians.
     */
    rotation: number;
    /**
     * Gets or sets the aligned axis in world space. The aligned axis is the unit vector that the billboard up vector points towards.
     * The default is the zero vector, which means the billboard is aligned to the screen up vector.
     * @example
     * // Example 1.
     * // Have the billboard up vector point north
     * billboard.alignedAxis = Cesium.Cartesian3.UNIT_Z;
     * @example
     * // Example 2.
     * // Have the billboard point east.
     * billboard.alignedAxis = Cesium.Cartesian3.UNIT_Z;
     * billboard.rotation = -Cesium.Math.PI_OVER_TWO;
     * @example
     * // Example 3.
     * // Reset the aligned axis
     * billboard.alignedAxis = Cesium.Cartesian3.ZERO;
     */
    alignedAxis: Cartesian3;
    /**
     * Gets or sets a width for the billboard. If undefined, the image width will be used.
     */
    width: number;
    /**
     * Gets or sets a height for the billboard. If undefined, the image height will be used.
     */
    height: number;
    /**
     * Gets or sets if the billboard size is in meters or pixels. <code>true</code> to size the billboard in meters;
     * otherwise, the size is in pixels.
     */
    sizeInMeters: boolean;
    /**
     * Gets or sets the condition specifying at what distance from the camera that this billboard will be displayed.
     */
    distanceDisplayCondition: DistanceDisplayCondition;
    /**
     * Gets or sets the distance from the camera at which to disable the depth test to, for example, prevent clipping against terrain.
     * When set to zero, the depth test is always applied. When set to Number.POSITIVE_INFINITY, the depth test is never applied.
     */
    disableDepthTestDistance: number;
    /**
     * Gets or sets the user-defined object returned when the billboard is picked.
     */
    id: any;
    /**
     * <p>
     * Gets or sets the image to be used for this billboard.  If a texture has already been created for the
     * given image, the existing texture is used.
     * </p>
     * <p>
     * This property can be set to a loaded Image, a URL which will be loaded as an Image automatically,
     * a canvas, or another billboard's image property (from the same billboard collection).
     * </p>
     * @example
     * // load an image from a URL
     * b.image = 'some/image/url.png';
     *
     * // assuming b1 and b2 are billboards in the same billboard collection,
     * // use the same image for both billboards.
     * b2.image = b1.image;
     */
    image: string;
    /**
     * When <code>true</code>, this billboard is ready to render, i.e., the image
     * has been downloaded and the WebGL resources are created.
     */
    readonly ready: boolean;
    /**
     * <p>
     * Sets the image to be used for this billboard.  If a texture has already been created for the
     * given id, the existing texture is used.
     * </p>
     * <p>
     * This function is useful for dynamically creating textures that are shared across many billboards.
     * Only the first billboard will actually call the function and create the texture, while subsequent
     * billboards created with the same id will simply re-use the existing texture.
     * </p>
     * <p>
     * To load an image from a URL, setting the {@link Billboard#image} property is more convenient.
     * </p>
     * @example
     * // create a billboard image dynamically
     * function drawImage(id) {
     *   // create and draw an image using a canvas
     *   const canvas = document.createElement('canvas');
     *   const context2D = canvas.getContext('2d');
     *   // ... draw image
     *   return canvas;
     * }
     * // drawImage will be called to create the texture
     * b.setImage('myImage', drawImage);
     *
     * // subsequent billboards created in the same collection using the same id will use the existing
     * // texture, without the need to create the canvas or draw the image
     * b2.setImage('myImage', drawImage);
     * @param id - The id of the image.  This can be any string that uniquely identifies the image.
     * @param image - The image to load.  This parameter
     *        can either be a loaded Image or Canvas, a URL which will be loaded as an Image automatically,
     *        or a function which will be called to create the image if it hasn't been loaded already.
     */
    setImage(id: string, image: HTMLImageElement | HTMLCanvasElement | string | Resource | Billboard.CreateImageCallback): void;
    /**
     * Uses a sub-region of the image with the given id as the image for this billboard,
     * measured in pixels from the bottom-left.
     * @param id - The id of the image to use.
     * @param subRegion - The sub-region of the image.
     */
    setImageSubRegion(id: string, subRegion: BoundingRectangle): void;
    /**
     * Computes the screen-space position of the billboard's origin, taking into account eye and pixel offsets.
     * The screen space origin is the top, left corner of the canvas; <code>x</code> increases from
     * left to right, and <code>y</code> increases from top to bottom.
     * @example
     * console.log(b.computeScreenSpacePosition(scene).toString());
     * @param scene - The scene.
     * @param [result] - The object onto which to store the result.
     * @returns The screen-space position of the billboard.
     */
    computeScreenSpacePosition(scene: Scene, result?: Cartesian2): Cartesian2;
    /**
     * Determines if this billboard equals another billboard.  Billboards are equal if all their properties
     * are equal.  Billboards in different collections can be equal.
     * @param other - The billboard to compare for equality.
     * @returns <code>true</code> if the billboards are equal; otherwise, <code>false</code>.
     */
    equals(other: Billboard): boolean;
}

export namespace Billboard {
    /**
     * A function that creates an image.
     * @param id - The identifier of the image to load.
     */
    type CreateImageCallback = (id: string) => HTMLImageElement | HTMLCanvasElement | Promise<HTMLImageElement | HTMLCanvasElement>;
}

/**
 * A renderable collection of billboards.  Billboards are viewport-aligned
 * images positioned in the 3D scene.
 * <br /><br />
 * <div align='center'>
 * <img src='Images/Billboard.png' width='400' height='300' /><br />
 * Example billboards
 * </div>
 * <br /><br />
 * Billboards are added and removed from the collection using {@link BillboardCollection#add}
 * and {@link BillboardCollection#remove}.  Billboards in a collection automatically share textures
 * for images with the same identifier.
 * @example
 * // Create a billboard collection with two billboards
 * const billboards = scene.primitives.add(new Cesium.BillboardCollection());
 * billboards.add({
 *   position : new Cesium.Cartesian3(1.0, 2.0, 3.0),
 *   image : 'url/to/image'
 * });
 * billboards.add({
 *   position : new Cesium.Cartesian3(4.0, 5.0, 6.0),
 *   image : 'url/to/another/image'
 * });
 * @param [options] - Object with the following properties:
 * @param [options.modelMatrix = Matrix4.IDENTITY] - The 4x4 transformation matrix that transforms each billboard from model to world coordinates.
 * @param [options.debugShowBoundingVolume = false] - For debugging only. Determines if this primitive's commands' bounding spheres are shown.
 * @param [options.scene] - Must be passed in for billboards that use the height reference property or will be depth tested against the globe.
 * @param [options.blendOption = BlendOption.OPAQUE_AND_TRANSLUCENT] - The billboard blending option. The default
 * is used for rendering both opaque and translucent billboards. However, if either all of the billboards are completely opaque or all are completely translucent,
 * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve performance by up to 2x.
 * @param [options.show = true] - Determines if the billboards in the collection will be shown.
 */
export class BillboardCollection {
    constructor(options?: {
        modelMatrix?: Matrix4;
        debugShowBoundingVolume?: boolean;
        scene?: Scene;
        blendOption?: BlendOption;
        show?: boolean;
    });
    /**
     * Determines if billboards in this collection will be shown.
     */
    show: boolean;
    /**
     * The 4x4 transformation matrix that transforms each billboard in this collection from model to world coordinates.
     * When this is the identity matrix, the billboards are drawn in world coordinates, i.e., Earth's WGS84 coordinates.
     * Local reference frames can be used by providing a different transformation matrix, like that returned
     * by {@link Transforms.eastNorthUpToFixedFrame}.
     * @example
     * const center = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);
     * billboards.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(center);
     * billboards.add({
     *   image : 'url/to/image',
     *   position : new Cesium.Cartesian3(0.0, 0.0, 0.0) // center
     * });
     * billboards.add({
     *   image : 'url/to/image',
     *   position : new Cesium.Cartesian3(1000000.0, 0.0, 0.0) // east
     * });
     * billboards.add({
     *   image : 'url/to/image',
     *   position : new Cesium.Cartesian3(0.0, 1000000.0, 0.0) // north
     * });
     * billboards.add({
     *   image : 'url/to/image',
     *   position : new Cesium.Cartesian3(0.0, 0.0, 1000000.0) // up
     * });
     */
    modelMatrix: Matrix4;
    /**
     * This property is for debugging only; it is not for production use nor is it optimized.
     * <p>
     * Draws the bounding sphere for each draw command in the primitive.
     * </p>
     */
    debugShowBoundingVolume: boolean;
    /**
     * This property is for debugging only; it is not for production use nor is it optimized.
     * <p>
     * Draws the texture atlas for this BillboardCollection as a fullscreen quad.
     * </p>
     */
    debugShowTextureAtlas: boolean;
    /**
     * The billboard blending option. The default is used for rendering both opaque and translucent billboards.
     * However, if either all of the billboards are completely opaque or all are completely translucent,
     * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve
     * performance by up to 2x.
     */
    blendOption: BlendOption;
    /**
     * Returns the number of billboards in this collection.  This is commonly used with
     * {@link BillboardCollection#get} to iterate over all the billboards
     * in the collection.
     */
    length: number;
    /**
     * Creates and adds a billboard with the specified initial properties to the collection.
     * The added billboard is returned so it can be modified or removed from the collection later.
     * @example
     * // Example 1:  Add a billboard, specifying all the default values.
     * const b = billboards.add({
     *   show : true,
     *   position : Cesium.Cartesian3.ZERO,
     *   pixelOffset : Cesium.Cartesian2.ZERO,
     *   eyeOffset : Cesium.Cartesian3.ZERO,
     *   heightReference : Cesium.HeightReference.NONE,
     *   horizontalOrigin : Cesium.HorizontalOrigin.CENTER,
     *   verticalOrigin : Cesium.VerticalOrigin.CENTER,
     *   scale : 1.0,
     *   image : 'url/to/image',
     *   imageSubRegion : undefined,
     *   color : Cesium.Color.WHITE,
     *   id : undefined,
     *   rotation : 0.0,
     *   alignedAxis : Cesium.Cartesian3.ZERO,
     *   width : undefined,
     *   height : undefined,
     *   scaleByDistance : undefined,
     *   translucencyByDistance : undefined,
     *   pixelOffsetScaleByDistance : undefined,
     *   sizeInMeters : false,
     *   distanceDisplayCondition : undefined
     * });
     * @example
     * // Example 2:  Specify only the billboard's cartographic position.
     * const b = billboards.add({
     *   position : Cesium.Cartesian3.fromDegrees(longitude, latitude, height)
     * });
     * @param [options] - A template describing the billboard's properties as shown in Example 1.
     * @returns The billboard that was added to the collection.
     */
    add(options?: any): Billboard;
    /**
     * Removes a billboard from the collection.
     * @example
     * const b = billboards.add(...);
     * billboards.remove(b);  // Returns true
     * @param billboard - The billboard to remove.
     * @returns <code>true</code> if the billboard was removed; <code>false</code> if the billboard was not found in the collection.
     */
    remove(billboard: Billboard): boolean;
    /**
     * Removes all billboards from the collection.
     * @example
     * billboards.add(...);
     * billboards.add(...);
     * billboards.removeAll();
     */
    removeAll(): void;
    /**
     * Check whether this collection contains a given billboard.
     * @param [billboard] - The billboard to check for.
     * @returns true if this collection contains the billboard, false otherwise.
     */
    contains(billboard?: Billboard): boolean;
    /**
     * Returns the billboard in the collection at the specified index.  Indices are zero-based
     * and increase as billboards are added.  Removing a billboard shifts all billboards after
     * it to the left, changing their indices.  This function is commonly used with
     * {@link BillboardCollection#length} to iterate over all the billboards
     * in the collection.
     * @example
     * // Toggle the show property of every billboard in the collection
     * const len = billboards.length;
     * for (let i = 0; i < len; ++i) {
     *   const b = billboards.get(i);
     *   b.show = !b.show;
     * }
     * @param index - The zero-based index of the billboard.
     * @returns The billboard at the specified index.
     */
    get(index: number): Billboard;
    /**
     * Called when {@link Viewer} or {@link CesiumWidget} render the scene to
     * get the draw commands needed to render this primitive.
     * <p>
     * Do not call this function directly.  This is documented just to
     * list the exceptions that may be propagated when the scene is rendered:
     * </p>
     */
    update(): void;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     * @example
     * billboards = billboards && billboards.destroy();
     */
    destroy(): void;
}

export namespace BingMapsImageryProvider {
    /**
     * Initialization options for the BingMapsImageryProvider constructor
     * [key] - The Bing Maps key for your application, which can be
     *        created at {@link https://www.bingmapsportal.com/}.
     * [tileProtocol] - The protocol to use when loading tiles, e.g. 'http' or 'https'.
     *        By default, tiles are loaded using the same protocol as the page.
     * [mapStyle = BingMapsStyle.AERIAL] - The type of Bing Maps imagery to load.
     * [culture = ''] - The culture to use when requesting Bing Maps imagery. Not
     *        all cultures are supported. See {@link http://msdn.microsoft.com/en-us/library/hh441729.aspx}
     *        for information on the supported cultures.
     * [ellipsoid] - The ellipsoid.  If not specified, the WGS84 ellipsoid is used.
     * [tileDiscardPolicy] - The policy that determines if a tile
     *        is invalid and should be discarded.  By default, a {@link DiscardEmptyTileImagePolicy}
     *        will be used, with the expectation that the Bing Maps server will send a zero-length response for missing tiles.
     *        To ensure that no tiles are discarded, construct and pass a {@link NeverTileDiscardPolicy} for this parameter.
     */
    type ConstructorOptions = {
        key?: string;
        tileProtocol?: string;
        mapStyle?: BingMapsStyle;
        culture?: string;
        ellipsoid?: Ellipsoid;
        tileDiscardPolicy?: TileDiscardPolicy;
    };
}

/**
 * <div class="notice">
 * To construct a BingMapsImageryProvider, call {@link BingMapsImageryProvider.fromUrl}. Do not call the constructor directly.
 * </div>
 *
 * Provides tiled imagery using the Bing Maps Imagery REST API.
 * @example
 * const bing = await Cesium.BingMapsImageryProvider.fromUrl(
 *   "https://dev.virtualearth.net", {
 *     key: "get-yours-at-https://www.bingmapsportal.com/",
 *     mapStyle: Cesium.BingMapsStyle.AERIAL
 * });
 * @param options - Object describing initialization options
 */
export class BingMapsImageryProvider {
    constructor(options: BingMapsImageryProvider.ConstructorOptions);
    /**
     * Gets the name of the BingMaps server url hosting the imagery.
     */
    readonly url: string;
    /**
     * Gets the proxy used by this provider.
     */
    readonly proxy: Proxy;
    /**
     * Gets the Bing Maps key.
     */
    readonly key: string;
    /**
     * Gets the type of Bing Maps imagery to load.
     */
    readonly mapStyle: BingMapsStyle;
    /**
     * The culture to use when requesting Bing Maps imagery. Not
     * all cultures are supported. See {@link http://msdn.microsoft.com/en-us/library/hh441729.aspx}
     * for information on the supported cultures.
     */
    readonly culture: string;
    /**
     * Gets the width of each tile, in pixels.
     */
    readonly tileWidth: number;
    /**
     * Gets the height of each tile, in pixels.
     */
    readonly tileHeight: number;
    /**
     * Gets the maximum level-of-detail that can be requested.
     */
    readonly maximumLevel: number | undefined;
    /**
     * Gets the minimum level-of-detail that can be requested.
     */
    readonly minimumLevel: number;
    /**
     * Gets the tiling scheme used by this provider.
     */
    readonly tilingScheme: TilingScheme;
    /**
     * Gets the rectangle, in radians, of the imagery provided by this instance.
     */
    readonly rectangle: Rectangle;
    /**
     * Gets the tile discard policy.  If not undefined, the discard policy is responsible
     * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
     * returns undefined, no tiles are filtered.
     */
    readonly tileDiscardPolicy: TileDiscardPolicy;
    /**
     * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
     * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
     * are passed an instance of {@link TileProviderError}.
     */
    readonly errorEvent: Event;
    /**
     * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
     * the source of the imagery.
     */
    readonly credit: Credit;
    /**
     * Gets a value indicating whether or not the images provided by this imagery provider
     * include an alpha channel.  If this property is false, an alpha channel, if present, will
     * be ignored.  If this property is true, any images without an alpha channel will be treated
     * as if their alpha is 1.0 everywhere.  Setting this property to false reduces memory usage
     * and texture upload time.
     */
    readonly hasAlphaChannel: boolean;
    /**
     * Creates an {@link ImageryProvider} which provides tiled imagery using the Bing Maps Imagery REST API.
     * @example
     * const bing = await Cesium.BingMapsImageryProvider.fromUrl(
     *   "https://dev.virtualearth.net", {
     *     key: "get-yours-at-https://www.bingmapsportal.com/",
     *     mapStyle: Cesium.BingMapsStyle.AERIAL
     * });
     * @param url - The url of the Bing Maps server hosting the imagery.
     * @param options - Object describing initialization options
     * @returns A promise that resolves to the created BingMapsImageryProvider
     */
    static fromUrl(url: Resource | string, options: BingMapsImageryProvider.ConstructorOptions): Promise<BingMapsImageryProvider>;
    /**
     * Gets the credits to be displayed when a given tile is displayed.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level;
     * @returns The credits to be displayed when the tile is displayed.
     */
    getTileCredits(x: number, y: number, level: number): Credit[];
    /**
     * Requests the image for a given tile.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level.
     * @param [request] - The request object. Intended for internal use only.
     * @returns A promise for the image that will resolve when the image is available, or
     *          undefined if there are too many active requests to the server, and the request should be retried later.
     */
    requestImage(x: number, y: number, level: number, request?: Request): Promise<ImageryTypes> | undefined;
    /**
     * Picking features is not currently supported by this imagery provider, so this function simply returns
     * undefined.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level.
     * @param longitude - The longitude at which to pick features.
     * @param latitude - The latitude at which to pick features.
     * @returns Undefined since picking is not supported.
     */
    pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): undefined;
    /**
     * Converts a tiles (x, y, level) position into a quadkey used to request an image
     * from a Bing Maps server.
     * @param x - The tile's x coordinate.
     * @param y - The tile's y coordinate.
     * @param level - The tile's zoom level.
     */
    static tileXYToQuadKey(x: number, y: number, level: number): void;
    /**
     * Converts a tile's quadkey used to request an image from a Bing Maps server into the
     * (x, y, level) position.
     * @param quadkey - The tile's quad key
     */
    static quadKeyToTileXY(quadkey: string): void;
    /**
     * Gets or sets the URL to the Bing logo for display in the credit.
     */
    static logoUrl: string;
}

/**
 * The types of imagery provided by Bing Maps.
 */
export enum BingMapsStyle {
    /**
     * Aerial imagery.
     */
    AERIAL = "Aerial",
    /**
     * Aerial imagery with a road overlay.
     */
    AERIAL_WITH_LABELS = "AerialWithLabels",
    /**
     * Aerial imagery with a road overlay.
     */
    AERIAL_WITH_LABELS_ON_DEMAND = "AerialWithLabelsOnDemand",
    /**
     * Roads without additional imagery.
     */
    ROAD = "Road",
    /**
     * Roads without additional imagery.
     */
    ROAD_ON_DEMAND = "RoadOnDemand",
    /**
     * A dark version of the road maps.
     */
    CANVAS_DARK = "CanvasDark",
    /**
     * A lighter version of the road maps.
     */
    CANVAS_LIGHT = "CanvasLight",
    /**
     * A grayscale version of the road maps.
     */
    CANVAS_GRAY = "CanvasGray",
    /**
     * Ordnance Survey imagery. This imagery is visible only for the London, UK area.
     */
    ORDNANCE_SURVEY = "OrdnanceSurvey",
    /**
     * Collins Bart imagery.
     */
    COLLINS_BART = "CollinsBart"
}

/**
 * Determines how two pixels' values are combined.
 */
export enum BlendEquation {
    /**
     * Pixel values are added componentwise.  This is used in additive blending for translucency.
     */
    ADD = WebGLConstants.FUNC_ADD,
    /**
     * Pixel values are subtracted componentwise (source - destination).  This is used in alpha blending for translucency.
     */
    SUBTRACT = WebGLConstants.FUNC_SUBTRACT,
    /**
     * Pixel values are subtracted componentwise (destination - source).
     */
    REVERSE_SUBTRACT = WebGLConstants.FUNC_REVERSE_SUBTRACT,
    /**
     * Pixel values are given to the minimum function (min(source, destination)).
     *
     * This equation operates on each pixel color component.
     */
    MIN = WebGLConstants.MIN,
    /**
     * Pixel values are given to the maximum function (max(source, destination)).
     *
     * This equation operates on each pixel color component.
     */
    MAX = WebGLConstants.MAX
}

/**
 * Determines how blending factors are computed.
 */
export enum BlendFunction {
    /**
     * The blend factor is zero.
     */
    ZERO = WebGLConstants.ZERO,
    /**
     * The blend factor is one.
     */
    ONE = WebGLConstants.ONE,
    /**
     * The blend factor is the source color.
     */
    SOURCE_COLOR = WebGLConstants.SRC_COLOR,
    /**
     * The blend factor is one minus the source color.
     */
    ONE_MINUS_SOURCE_COLOR = WebGLConstants.ONE_MINUS_SRC_COLOR,
    /**
     * The blend factor is the destination color.
     */
    DESTINATION_COLOR = WebGLConstants.DST_COLOR,
    /**
     * The blend factor is one minus the destination color.
     */
    ONE_MINUS_DESTINATION_COLOR = WebGLConstants.ONE_MINUS_DST_COLOR,
    /**
     * The blend factor is the source alpha.
     */
    SOURCE_ALPHA = WebGLConstants.SRC_ALPHA,
    /**
     * The blend factor is one minus the source alpha.
     */
    ONE_MINUS_SOURCE_ALPHA = WebGLConstants.ONE_MINUS_SRC_ALPHA,
    /**
     * The blend factor is the destination alpha.
     */
    DESTINATION_ALPHA = WebGLConstants.DST_ALPHA,
    /**
     * The blend factor is one minus the destination alpha.
     */
    ONE_MINUS_DESTINATION_ALPHA = WebGLConstants.ONE_MINUS_DST_ALPHA,
    /**
     * The blend factor is the constant color.
     */
    CONSTANT_COLOR = WebGLConstants.CONSTANT_COLOR,
    /**
     * The blend factor is one minus the constant color.
     */
    ONE_MINUS_CONSTANT_COLOR = WebGLConstants.ONE_MINUS_CONSTANT_COLOR,
    /**
     * The blend factor is the constant alpha.
     */
    CONSTANT_ALPHA = WebGLConstants.CONSTANT_ALPHA,
    /**
     * The blend factor is one minus the constant alpha.
     */
    ONE_MINUS_CONSTANT_ALPHA = WebGLConstants.ONE_MINUS_CONSTANT_ALPHA,
    /**
     * The blend factor is the saturated source alpha.
     */
    SOURCE_ALPHA_SATURATE = WebGLConstants.SRC_ALPHA_SATURATE
}

/**
 * Determines how opaque and translucent parts of billboards, points, and labels are blended with the scene.
 */
export enum BlendOption {
    /**
     * The billboards, points, or labels in the collection are completely opaque.
     */
    OPAQUE = 0,
    /**
     * The billboards, points, or labels in the collection are completely translucent.
     */
    TRANSLUCENT = 1,
    /**
     * The billboards, points, or labels in the collection are both opaque and translucent.
     */
    OPAQUE_AND_TRANSLUCENT = 2
}

/**
 * The blending state combines {@link BlendEquation} and {@link BlendFunction} and the
 * <code>enabled</code> flag to define the full blending state for combining source and
 * destination fragments when rendering.
 * <p>
 * This is a helper when using custom render states with {@link Appearance#renderState}.
 * </p>
 */
export namespace BlendingState {
    /**
     * Blending is disabled.
     */
    const DISABLED: any;
    /**
     * Blending is enabled using alpha blending, <code>source(source.alpha) + destination(1 - source.alpha)</code>.
     */
    const ALPHA_BLEND: any;
    /**
     * Blending is enabled using alpha blending with premultiplied alpha, <code>source + destination(1 - source.alpha)</code>.
     */
    const PRE_MULTIPLIED_ALPHA_BLEND: any;
    /**
     * Blending is enabled using additive blending, <code>source(source.alpha) + destination</code>.
     */
    const ADDITIVE_BLEND: any;
}

/**
 * A ParticleEmitter that emits particles within a box.
 * Particles will be positioned randomly within the box and have initial velocities emanating from the center of the box.
 * @param dimensions - The width, height and depth dimensions of the box.
 */
export class BoxEmitter {
    constructor(dimensions: Cartesian3);
    /**
     * The width, height and depth dimensions of the box in meters.
     */
    dimensions: Cartesian3;
}

/**
 * An orientation given by a pair of unit vectors
 * direction - The unit "direction" vector
 * up - The unit "up" vector
 */
export type DirectionUp = {
    direction: Cartesian3;
    up: Cartesian3;
};

/**
 * An orientation given by numeric heading, pitch, and roll
 * [heading = 0.0] - The heading in radians
 * [pitch = -Math.PI_OVER_TWO] - The pitch in radians
 * [roll = 0.0] - The roll in radians
 */
export type HeadingPitchRollValues = {
    heading?: number;
    pitch?: number;
    roll?: number;
};

/**
 * The camera is defined by a position, orientation, and view frustum.
 * <br /><br />
 * The orientation forms an orthonormal basis with a view, up and right = view x up unit vectors.
 * <br /><br />
 * The viewing frustum is defined by 6 planes.
 * Each plane is represented by a {@link Cartesian4} object, where the x, y, and z components
 * define the unit vector normal to the plane, and the w component is the distance of the
 * plane from the origin/camera position.
 * @example
 * // Create a camera looking down the negative z-axis, positioned at the origin,
 * // with a field of view of 60 degrees, and 1:1 aspect ratio.
 * const camera = new Cesium.Camera(scene);
 * camera.position = new Cesium.Cartesian3();
 * camera.direction = Cesium.Cartesian3.negate(Cesium.Cartesian3.UNIT_Z, new Cesium.Cartesian3());
 * camera.up = Cesium.Cartesian3.clone(Cesium.Cartesian3.UNIT_Y);
 * camera.frustum.fov = Cesium.Math.PI_OVER_THREE;
 * camera.frustum.near = 1.0;
 * camera.frustum.far = 2.0;
 * @param scene - The scene.
 */
export class Camera {
    constructor(scene: Scene);
    /**
     * The position of the camera.
     */
    position: Cartesian3;
    /**
     * The view direction of the camera.
     */
    direction: Cartesian3;
    /**
     * The up direction of the camera.
     */
    up: Cartesian3;
    /**
     * The right direction of the camera.
     */
    right: Cartesian3;
    /**
     * The region of space in view.
     */
    frustum: PerspectiveFrustum | PerspectiveOffCenterFrustum | OrthographicFrustum;
    /**
     * The default amount to move the camera when an argument is not
     * provided to the move methods.
     */
    defaultMoveAmount: number;
    /**
     * The default amount to rotate the camera when an argument is not
     * provided to the look methods.
     */
    defaultLookAmount: number;
    /**
     * The default amount to rotate the camera when an argument is not
     * provided to the rotate methods.
     */
    defaultRotateAmount: number;
    /**
     * The default amount to move the camera when an argument is not
     * provided to the zoom methods.
     */
    defaultZoomAmount: number;
    /**
     * If set, the camera will not be able to rotate past this axis in either direction.
     */
    constrainedAxis: Cartesian3;
    /**
     * The factor multiplied by the the map size used to determine where to clamp the camera position
     * when zooming out from the surface. The default is 1.5. Only valid for 2D and the map is rotatable.
     */
    maximumZoomFactor: number;
    /**
     * The amount the camera has to change before the <code>changed</code> event is raised. The value is a percentage in the [0, 1] range.
     */
    percentageChanged: number;
    /**
     * The default rectangle the camera will view on creation.
     */
    static DEFAULT_VIEW_RECTANGLE: Rectangle;
    /**
     * A scalar to multiply to the camera position and add it back after setting the camera to view the rectangle.
     * A value of zero means the camera will view the entire {@link Camera#DEFAULT_VIEW_RECTANGLE}, a value greater than zero
     * will move it further away from the extent, and a value less than zero will move it close to the extent.
     */
    static DEFAULT_VIEW_FACTOR: number;
    /**
     * The default heading/pitch/range that is used when the camera flies to a location that contains a bounding sphere.
     */
    static DEFAULT_OFFSET: HeadingPitchRange;
    /**
     * Gets the camera's reference frame. The inverse of this transformation is appended to the view matrix.
     */
    readonly transform: Matrix4;
    /**
     * Gets the inverse camera transform.
     */
    readonly inverseTransform: Matrix4;
    /**
     * Gets the view matrix.
     */
    readonly viewMatrix: Matrix4;
    /**
     * Gets the inverse view matrix.
     */
    readonly inverseViewMatrix: Matrix4;
    /**
     * Gets the {@link Cartographic} position of the camera, with longitude and latitude
     * expressed in radians and height in meters.  In 2D and Columbus View, it is possible
     * for the returned longitude and latitude to be outside the range of valid longitudes
     * and latitudes when the camera is outside the map.
     */
    readonly positionCartographic: Cartographic;
    /**
     * Gets the position of the camera in world coordinates.
     */
    readonly positionWC: Cartesian3;
    /**
     * Gets the view direction of the camera in world coordinates.
     */
    readonly directionWC: Cartesian3;
    /**
     * Gets the up direction of the camera in world coordinates.
     */
    readonly upWC: Cartesian3;
    /**
     * Gets the right direction of the camera in world coordinates.
     */
    readonly rightWC: Cartesian3;
    /**
     * Gets the camera heading in radians.
     */
    readonly heading: number;
    /**
     * Gets the camera pitch in radians.
     */
    readonly pitch: number;
    /**
     * Gets the camera roll in radians.
     */
    readonly roll: number;
    /**
     * Gets the event that will be raised at when the camera starts to move.
     */
    readonly moveStart: Event;
    /**
     * Gets the event that will be raised when the camera has stopped moving.
     */
    readonly moveEnd: Event;
    /**
     * Gets the event that will be raised when the camera has changed by <code>percentageChanged</code>.
     */
    readonly changed: Event;
    /**
     * Sets the camera position, orientation and transform.
     * @example
     * // 1. Set position with a top-down view
     * viewer.camera.setView({
     *     destination : Cesium.Cartesian3.fromDegrees(-117.16, 32.71, 15000.0)
     * });
     *
     * // 2 Set view with heading, pitch and roll
     * viewer.camera.setView({
     *     destination : cartesianPosition,
     *     orientation: {
     *         heading : Cesium.Math.toRadians(90.0), // east, default value is 0.0 (north)
     *         pitch : Cesium.Math.toRadians(-90),    // default value (looking down)
     *         roll : 0.0                             // default value
     *     }
     * });
     *
     * // 3. Change heading, pitch and roll with the camera position remaining the same.
     * viewer.camera.setView({
     *     orientation: {
     *         heading : Cesium.Math.toRadians(90.0), // east, default value is 0.0 (north)
     *         pitch : Cesium.Math.toRadians(-90),    // default value (looking down)
     *         roll : 0.0                             // default value
     *     }
     * });
     *
     *
     * // 4. View rectangle with a top-down view
     * viewer.camera.setView({
     *     destination : Cesium.Rectangle.fromDegrees(west, south, east, north)
     * });
     *
     * // 5. Set position with an orientation using unit vectors.
     * viewer.camera.setView({
     *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),
     *     orientation : {
     *         direction : new Cesium.Cartesian3(-0.04231243104240401, -0.20123236049443421, -0.97862924300734),
     *         up : new Cesium.Cartesian3(-0.47934589305293746, -0.8553216253114552, 0.1966022179118339)
     *     }
     * });
     * @param options - Object with the following properties:
     * @param [options.destination] - The final position of the camera in WGS84 (world) coordinates or a rectangle that would be visible from a top-down view.
     * @param [options.orientation] - An object that contains either direction and up properties or heading, pitch and roll properties. By default, the direction will point
     * towards the center of the frame in 3D and in the negative z direction in Columbus view. The up direction will point towards local north in 3D and in the positive
     * y direction in Columbus view. Orientation is not used in 2D when in infinite scrolling mode.
     * @param [options.endTransform] - Transform matrix representing the reference frame of the camera.
     * @param [options.convert] - Whether to convert the destination from world coordinates to scene coordinates (only relevant when not using 3D). Defaults to <code>true</code>.
     */
    setView(options: {
        destination?: Cartesian3 | Rectangle;
        orientation?: HeadingPitchRollValues | DirectionUp;
        endTransform?: Matrix4;
        convert?: boolean;
    }): void;
    /**
     * Fly the camera to the home view.  Use {@link Camera#.DEFAULT_VIEW_RECTANGLE} to set
     * the default view for the 3D scene.  The home view for 2D and columbus view shows the
     * entire map.
     * @param [duration] - The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight. See {@link Camera#flyTo}
     */
    flyHome(duration?: number): void;
    /**
     * Transform a vector or point from world coordinates to the camera's reference frame.
     * @param cartesian - The vector or point to transform.
     * @param [result] - The object onto which to store the result.
     * @returns The transformed vector or point.
     */
    worldToCameraCoordinates(cartesian: Cartesian4, result?: Cartesian4): Cartesian4;
    /**
     * Transform a point from world coordinates to the camera's reference frame.
     * @param cartesian - The point to transform.
     * @param [result] - The object onto which to store the result.
     * @returns The transformed point.
     */
    worldToCameraCoordinatesPoint(cartesian: Cartesian3, result?: Cartesian3): Cartesian3;
    /**
     * Transform a vector from world coordinates to the camera's reference frame.
     * @param cartesian - The vector to transform.
     * @param [result] - The object onto which to store the result.
     * @returns The transformed vector.
     */
    worldToCameraCoordinatesVector(cartesian: Cartesian3, result?: Cartesian3): Cartesian3;
    /**
     * Transform a vector or point from the camera's reference frame to world coordinates.
     * @param cartesian - The vector or point to transform.
     * @param [result] - The object onto which to store the result.
     * @returns The transformed vector or point.
     */
    cameraToWorldCoordinates(cartesian: Cartesian4, result?: Cartesian4): Cartesian4;
    /**
     * Transform a point from the camera's reference frame to world coordinates.
     * @param cartesian - The point to transform.
     * @param [result] - The object onto which to store the result.
     * @returns The transformed point.
     */
    cameraToWorldCoordinatesPoint(cartesian: Cartesian3, result?: Cartesian3): Cartesian3;
    /**
     * Transform a vector from the camera's reference frame to world coordinates.
     * @param cartesian - The vector to transform.
     * @param [result] - The object onto which to store the result.
     * @returns The transformed vector.
     */
    cameraToWorldCoordinatesVector(cartesian: Cartesian3, result?: Cartesian3): Cartesian3;
    /**
     * Translates the camera's position by <code>amount</code> along <code>direction</code>.
     * @param direction - The direction to move.
     * @param [amount] - The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.
     */
    move(direction: Cartesian3, amount?: number): void;
    /**
     * Translates the camera's position by <code>amount</code> along the camera's view vector.
     * When in 2D mode, this will zoom in the camera instead of translating the camera's position.
     * @param [amount] - The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.
     */
    moveForward(amount?: number): void;
    /**
     * Translates the camera's position by <code>amount</code> along the opposite direction
     * of the camera's view vector.
     * When in 2D mode, this will zoom out the camera instead of translating the camera's position.
     * @param [amount] - The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.
     */
    moveBackward(amount?: number): void;
    /**
     * Translates the camera's position by <code>amount</code> along the camera's up vector.
     * @param [amount] - The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.
     */
    moveUp(amount?: number): void;
    /**
     * Translates the camera's position by <code>amount</code> along the opposite direction
     * of the camera's up vector.
     * @param [amount] - The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.
     */
    moveDown(amount?: number): void;
    /**
     * Translates the camera's position by <code>amount</code> along the camera's right vector.
     * @param [amount] - The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.
     */
    moveRight(amount?: number): void;
    /**
     * Translates the camera's position by <code>amount</code> along the opposite direction
     * of the camera's right vector.
     * @param [amount] - The amount, in meters, to move. Defaults to <code>defaultMoveAmount</code>.
     */
    moveLeft(amount?: number): void;
    /**
     * Rotates the camera around its up vector by amount, in radians, in the opposite direction
     * of its right vector if not in 2D mode.
     * @param [amount] - The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.
     */
    lookLeft(amount?: number): void;
    /**
     * Rotates the camera around its up vector by amount, in radians, in the direction
     * of its right vector if not in 2D mode.
     * @param [amount] - The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.
     */
    lookRight(amount?: number): void;
    /**
     * Rotates the camera around its right vector by amount, in radians, in the direction
     * of its up vector if not in 2D mode.
     * @param [amount] - The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.
     */
    lookUp(amount?: number): void;
    /**
     * Rotates the camera around its right vector by amount, in radians, in the opposite direction
     * of its up vector if not in 2D mode.
     * @param [amount] - The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.
     */
    lookDown(amount?: number): void;
    /**
     * Rotate each of the camera's orientation vectors around <code>axis</code> by <code>angle</code>
     * @param axis - The axis to rotate around.
     * @param [angle] - The angle, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.
     */
    look(axis: Cartesian3, angle?: number): void;
    /**
     * Rotate the camera counter-clockwise around its direction vector by amount, in radians.
     * @param [amount] - The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.
     */
    twistLeft(amount?: number): void;
    /**
     * Rotate the camera clockwise around its direction vector by amount, in radians.
     * @param [amount] - The amount, in radians, to rotate by. Defaults to <code>defaultLookAmount</code>.
     */
    twistRight(amount?: number): void;
    /**
     * Rotates the camera around <code>axis</code> by <code>angle</code>. The distance
     * of the camera's position to the center of the camera's reference frame remains the same.
     * @param axis - The axis to rotate around given in world coordinates.
     * @param [angle] - The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.
     */
    rotate(axis: Cartesian3, angle?: number): void;
    /**
     * Rotates the camera around the center of the camera's reference frame by angle downwards.
     * @param [angle] - The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.
     */
    rotateDown(angle?: number): void;
    /**
     * Rotates the camera around the center of the camera's reference frame by angle upwards.
     * @param [angle] - The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.
     */
    rotateUp(angle?: number): void;
    /**
     * Rotates the camera around the center of the camera's reference frame by angle to the right.
     * @param [angle] - The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.
     */
    rotateRight(angle?: number): void;
    /**
     * Rotates the camera around the center of the camera's reference frame by angle to the left.
     * @param [angle] - The angle, in radians, to rotate by. Defaults to <code>defaultRotateAmount</code>.
     */
    rotateLeft(angle?: number): void;
    /**
     * Zooms <code>amount</code> along the camera's view vector.
     * @param [amount] - The amount to move. Defaults to <code>defaultZoomAmount</code>.
     */
    zoomIn(amount?: number): void;
    /**
     * Zooms <code>amount</code> along the opposite direction of
     * the camera's view vector.
     * @param [amount] - The amount to move. Defaults to <code>defaultZoomAmount</code>.
     */
    zoomOut(amount?: number): void;
    /**
     * Gets the magnitude of the camera position. In 3D, this is the vector magnitude. In 2D and
     * Columbus view, this is the distance to the map.
     * @returns The magnitude of the position.
     */
    getMagnitude(): number;
    /**
     * Sets the camera position and orientation using a target and offset. The target must be given in
     * world coordinates. The offset can be either a cartesian or heading/pitch/range in the local east-north-up reference frame centered at the target.
     * If the offset is a cartesian, then it is an offset from the center of the reference frame defined by the transformation matrix. If the offset
     * is heading/pitch/range, then the heading and the pitch angles are defined in the reference frame defined by the transformation matrix.
     * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch
     * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center.
     *
     * In 2D, there must be a top down view. The camera will be placed above the target looking down. The height above the
     * target will be the magnitude of the offset. The heading will be determined from the offset. If the heading cannot be
     * determined from the offset, the heading will be north.
     * @example
     * // 1. Using a cartesian offset
     * const center = Cesium.Cartesian3.fromDegrees(-98.0, 40.0);
     * viewer.camera.lookAt(center, new Cesium.Cartesian3(0.0, -4790000.0, 3930000.0));
     *
     * // 2. Using a HeadingPitchRange offset
     * const center = Cesium.Cartesian3.fromDegrees(-72.0, 40.0);
     * const heading = Cesium.Math.toRadians(50.0);
     * const pitch = Cesium.Math.toRadians(-20.0);
     * const range = 5000.0;
     * viewer.camera.lookAt(center, new Cesium.HeadingPitchRange(heading, pitch, range));
     * @param target - The target position in world coordinates.
     * @param offset - The offset from the target in the local east-north-up reference frame centered at the target.
     */
    lookAt(target: Cartesian3, offset: Cartesian3 | HeadingPitchRange): void;
    /**
     * Sets the camera position and orientation using a target and transformation matrix. The offset can be either a cartesian or heading/pitch/range.
     * If the offset is a cartesian, then it is an offset from the center of the reference frame defined by the transformation matrix. If the offset
     * is heading/pitch/range, then the heading and the pitch angles are defined in the reference frame defined by the transformation matrix.
     * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch
     * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center.
     *
     * In 2D, there must be a top down view. The camera will be placed above the center of the reference frame. The height above the
     * target will be the magnitude of the offset. The heading will be determined from the offset. If the heading cannot be
     * determined from the offset, the heading will be north.
     * @example
     * // 1. Using a cartesian offset
     * const transform = Cesium.Transforms.eastNorthUpToFixedFrame(Cesium.Cartesian3.fromDegrees(-98.0, 40.0));
     * viewer.camera.lookAtTransform(transform, new Cesium.Cartesian3(0.0, -4790000.0, 3930000.0));
     *
     * // 2. Using a HeadingPitchRange offset
     * const transform = Cesium.Transforms.eastNorthUpToFixedFrame(Cesium.Cartesian3.fromDegrees(-72.0, 40.0));
     * const heading = Cesium.Math.toRadians(50.0);
     * const pitch = Cesium.Math.toRadians(-20.0);
     * const range = 5000.0;
     * viewer.camera.lookAtTransform(transform, new Cesium.HeadingPitchRange(heading, pitch, range));
     * @param transform - The transformation matrix defining the reference frame.
     * @param [offset] - The offset from the target in a reference frame centered at the target.
     */
    lookAtTransform(transform: Matrix4, offset?: Cartesian3 | HeadingPitchRange): void;
    /**
     * Get the camera position needed to view a rectangle on an ellipsoid or map
     * @param rectangle - The rectangle to view.
     * @param [result] - The camera position needed to view the rectangle
     * @returns The camera position needed to view the rectangle
     */
    getRectangleCameraCoordinates(rectangle: Rectangle, result?: Cartesian3): Cartesian3;
    /**
     * Pick an ellipsoid or map.
     * @example
     * const canvas = viewer.scene.canvas;
     * const center = new Cesium.Cartesian2(canvas.clientWidth / 2.0, canvas.clientHeight / 2.0);
     * const ellipsoid = viewer.scene.globe.ellipsoid;
     * const result = viewer.camera.pickEllipsoid(center, ellipsoid);
     * @param windowPosition - The x and y coordinates of a pixel.
     * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid to pick.
     * @param [result] - The object onto which to store the result.
     * @returns If the ellipsoid or map was picked,
     * returns the point on the surface of the ellipsoid or map in world
     * coordinates. If the ellipsoid or map was not picked, returns undefined.
     */
    pickEllipsoid(windowPosition: Cartesian2, ellipsoid?: Ellipsoid, result?: Cartesian3): Cartesian3 | undefined;
    /**
     * Create a ray from the camera position through the pixel at <code>windowPosition</code>
     * in world coordinates.
     * @param windowPosition - The x and y coordinates of a pixel.
     * @param [result] - The object onto which to store the result.
     * @returns Returns the {@link Cartesian3} position and direction of the ray, or undefined if the pick ray cannot be determined.
     */
    getPickRay(windowPosition: Cartesian2, result?: Ray): Ray | undefined;
    /**
     * Return the distance from the camera to the front of the bounding sphere.
     * @param boundingSphere - The bounding sphere in world coordinates.
     * @returns The distance to the bounding sphere.
     */
    distanceToBoundingSphere(boundingSphere: BoundingSphere): number;
    /**
     * Return the pixel size in meters.
     * @param boundingSphere - The bounding sphere in world coordinates.
     * @param drawingBufferWidth - The drawing buffer width.
     * @param drawingBufferHeight - The drawing buffer height.
     * @returns The pixel size in meters.
     */
    getPixelSize(boundingSphere: BoundingSphere, drawingBufferWidth: number, drawingBufferHeight: number): number;
    /**
     * Cancels the current camera flight and leaves the camera at its current location.
     * If no flight is in progress, this this function does nothing.
     */
    cancelFlight(): void;
    /**
     * Completes the current camera flight and moves the camera immediately to its final destination.
     * If no flight is in progress, this this function does nothing.
     */
    completeFlight(): void;
    /**
     * Flies the camera from its current position to a new position.
     * @example
     * // 1. Fly to a position with a top-down view
     * viewer.camera.flyTo({
     *     destination : Cesium.Cartesian3.fromDegrees(-117.16, 32.71, 15000.0)
     * });
     *
     * // 2. Fly to a Rectangle with a top-down view
     * viewer.camera.flyTo({
     *     destination : Cesium.Rectangle.fromDegrees(west, south, east, north)
     * });
     *
     * // 3. Fly to a position with an orientation using unit vectors.
     * viewer.camera.flyTo({
     *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),
     *     orientation : {
     *         direction : new Cesium.Cartesian3(-0.04231243104240401, -0.20123236049443421, -0.97862924300734),
     *         up : new Cesium.Cartesian3(-0.47934589305293746, -0.8553216253114552, 0.1966022179118339)
     *     }
     * });
     *
     * // 4. Fly to a position with an orientation using heading, pitch and roll.
     * viewer.camera.flyTo({
     *     destination : Cesium.Cartesian3.fromDegrees(-122.19, 46.25, 5000.0),
     *     orientation : {
     *         heading : Cesium.Math.toRadians(175.0),
     *         pitch : Cesium.Math.toRadians(-35.0),
     *         roll : 0.0
     *     }
     * });
     * @param options - Object with the following properties:
     * @param options.destination - The final position of the camera in WGS84 (world) coordinates or a rectangle that would be visible from a top-down view.
     * @param [options.orientation] - An object that contains either direction and up properties or heading, pitch and roll properties. By default, the direction will point
     * towards the center of the frame in 3D and in the negative z direction in Columbus view. The up direction will point towards local north in 3D and in the positive
     * y direction in Columbus view.  Orientation is not used in 2D when in infinite scrolling mode.
     * @param [options.duration] - The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight.
     * @param [options.complete] - The function to execute when the flight is complete.
     * @param [options.cancel] - The function to execute if the flight is cancelled.
     * @param [options.endTransform] - Transform matrix representing the reference frame the camera will be in when the flight is completed.
     * @param [options.maximumHeight] - The maximum height at the peak of the flight.
     * @param [options.pitchAdjustHeight] - If camera flyes higher than that value, adjust pitch duiring the flight to look down, and keep Earth in viewport.
     * @param [options.flyOverLongitude] - There are always two ways between 2 points on globe. This option force camera to choose fight direction to fly over that longitude.
     * @param [options.flyOverLongitudeWeight] - Fly over the lon specifyed via flyOverLongitude only if that way is not longer than short way times flyOverLongitudeWeight.
     * @param [options.convert] - Whether to convert the destination from world coordinates to scene coordinates (only relevant when not using 3D). Defaults to <code>true</code>.
     * @param [options.easingFunction] - Controls how the time is interpolated over the duration of the flight.
     */
    flyTo(options: {
        destination: Cartesian3 | Rectangle;
        orientation?: any;
        duration?: number;
        complete?: Camera.FlightCompleteCallback;
        cancel?: Camera.FlightCancelledCallback;
        endTransform?: Matrix4;
        maximumHeight?: number;
        pitchAdjustHeight?: number;
        flyOverLongitude?: number;
        flyOverLongitudeWeight?: number;
        convert?: boolean;
        easingFunction?: EasingFunction.Callback;
    }): void;
    /**
     * Sets the camera so that the current view contains the provided bounding sphere.
     *
     * <p>The offset is heading/pitch/range in the local east-north-up reference frame centered at the center of the bounding sphere.
     * The heading and the pitch angles are defined in the local east-north-up reference frame.
     * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch
     * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center. If the range is
     * zero, a range will be computed such that the whole bounding sphere is visible.</p>
     *
     * <p>In 2D, there must be a top down view. The camera will be placed above the target looking down. The height above the
     * target will be the range. The heading will be determined from the offset. If the heading cannot be
     * determined from the offset, the heading will be north.</p>
     * @param boundingSphere - The bounding sphere to view, in world coordinates.
     * @param [offset] - The offset from the target in the local east-north-up reference frame centered at the target.
     */
    viewBoundingSphere(boundingSphere: BoundingSphere, offset?: HeadingPitchRange): void;
    /**
     * Flies the camera to a location where the current view contains the provided bounding sphere.
     *
     * <p> The offset is heading/pitch/range in the local east-north-up reference frame centered at the center of the bounding sphere.
     * The heading and the pitch angles are defined in the local east-north-up reference frame.
     * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch
     * angles are below the plane. Negative pitch angles are above the plane. The range is the distance from the center. If the range is
     * zero, a range will be computed such that the whole bounding sphere is visible.</p>
     *
     * <p>In 2D and Columbus View, there must be a top down view. The camera will be placed above the target looking down. The height above the
     * target will be the range. The heading will be aligned to local north.</p>
     * @param boundingSphere - The bounding sphere to view, in world coordinates.
     * @param [options] - Object with the following properties:
     * @param [options.duration] - The duration of the flight in seconds. If omitted, Cesium attempts to calculate an ideal duration based on the distance to be traveled by the flight.
     * @param [options.offset] - The offset from the target in the local east-north-up reference frame centered at the target.
     * @param [options.complete] - The function to execute when the flight is complete.
     * @param [options.cancel] - The function to execute if the flight is cancelled.
     * @param [options.endTransform] - Transform matrix representing the reference frame the camera will be in when the flight is completed.
     * @param [options.maximumHeight] - The maximum height at the peak of the flight.
     * @param [options.pitchAdjustHeight] - If camera flyes higher than that value, adjust pitch duiring the flight to look down, and keep Earth in viewport.
     * @param [options.flyOverLongitude] - There are always two ways between 2 points on globe. This option force camera to choose fight direction to fly over that longitude.
     * @param [options.flyOverLongitudeWeight] - Fly over the lon specifyed via flyOverLongitude only if that way is not longer than short way times flyOverLongitudeWeight.
     * @param [options.easingFunction] - Controls how the time is interpolated over the duration of the flight.
     */
    flyToBoundingSphere(boundingSphere: BoundingSphere, options?: {
        duration?: number;
        offset?: HeadingPitchRange;
        complete?: Camera.FlightCompleteCallback;
        cancel?: Camera.FlightCancelledCallback;
        endTransform?: Matrix4;
        maximumHeight?: number;
        pitchAdjustHeight?: number;
        flyOverLongitude?: number;
        flyOverLongitudeWeight?: number;
        easingFunction?: EasingFunction.Callback;
    }): void;
    /**
     * Computes the approximate visible rectangle on the ellipsoid.
     * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid that you want to know the visible region.
     * @param [result] - The rectangle in which to store the result
     * @returns The visible rectangle or undefined if the ellipsoid isn't visible at all.
     */
    computeViewRectangle(ellipsoid?: Ellipsoid, result?: Rectangle): Rectangle | undefined;
    /**
     * Switches the frustum/projection to perspective.
     *
     * This function is a no-op in 2D which must always be orthographic.
     */
    switchToPerspectiveFrustum(): void;
    /**
     * Switches the frustum/projection to orthographic.
     *
     * This function is a no-op in 2D which will always be orthographic.
     */
    switchToOrthographicFrustum(): void;
}

export namespace Camera {
    /**
     * A function that will execute when a flight completes.
     */
    type FlightCompleteCallback = () => void;
    /**
     * A function that will execute when a flight is cancelled.
     */
    type FlightCancelledCallback = () => void;
}

/**
 * Aggregates input events. For example, suppose the following inputs are received between frames:
 * left mouse button down, mouse move, mouse move, left mouse button up. These events will be aggregated into
 * one event with a start and end position of the mouse.
 * @param [canvas = document] - The element to handle events for.
 */
export class CameraEventAggregator {
    constructor(canvas?: HTMLCanvasElement);
    /**
     * Gets the current mouse position.
     */
    currentMousePosition: Cartesian2;
    /**
     * Gets whether any mouse button is down, a touch has started, or the wheel has been moved.
     */
    anyButtonDown: boolean;
    /**
     * Gets if a mouse button down or touch has started and has been moved.
     * @param type - The camera event type.
     * @param [modifier] - The keyboard modifier.
     * @returns Returns <code>true</code> if a mouse button down or touch has started and has been moved; otherwise, <code>false</code>
     */
    isMoving(type: CameraEventType, modifier?: KeyboardEventModifier): boolean;
    /**
     * Gets the aggregated start and end position of the current event.
     * @param type - The camera event type.
     * @param [modifier] - The keyboard modifier.
     * @returns An object with two {@link Cartesian2} properties: <code>startPosition</code> and <code>endPosition</code>.
     */
    getMovement(type: CameraEventType, modifier?: KeyboardEventModifier): any;
    /**
     * Gets the start and end position of the last move event (not the aggregated event).
     * @param type - The camera event type.
     * @param [modifier] - The keyboard modifier.
     * @returns An object with two {@link Cartesian2} properties: <code>startPosition</code> and <code>endPosition</code> or <code>undefined</code>.
     */
    getLastMovement(type: CameraEventType, modifier?: KeyboardEventModifier): any | undefined;
    /**
     * Gets whether the mouse button is down or a touch has started.
     * @param type - The camera event type.
     * @param [modifier] - The keyboard modifier.
     * @returns Whether the mouse button is down or a touch has started.
     */
    isButtonDown(type: CameraEventType, modifier?: KeyboardEventModifier): boolean;
    /**
     * Gets the mouse position that started the aggregation.
     * @param type - The camera event type.
     * @param [modifier] - The keyboard modifier.
     * @returns The mouse position.
     */
    getStartMousePosition(type: CameraEventType, modifier?: KeyboardEventModifier): Cartesian2;
    /**
     * Gets the time the button was pressed or the touch was started.
     * @param type - The camera event type.
     * @param [modifier] - The keyboard modifier.
     * @returns The time the button was pressed or the touch was started.
     */
    getButtonPressTime(type: CameraEventType, modifier?: KeyboardEventModifier): Date;
    /**
     * Gets the time the button was released or the touch was ended.
     * @param type - The camera event type.
     * @param [modifier] - The keyboard modifier.
     * @returns The time the button was released or the touch was ended.
     */
    getButtonReleaseTime(type: CameraEventType, modifier?: KeyboardEventModifier): Date;
    /**
     * Signals that all of the events have been handled and the aggregator should be reset to handle new events.
     */
    reset(): void;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     */
    isDestroyed(): boolean;
    /**
     * Removes mouse listeners held by this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     * @example
     * handler = handler && handler.destroy();
     */
    destroy(): void;
}

/**
 * Enumerates the available input for interacting with the camera.
 */
export enum CameraEventType {
    /**
     * A left mouse button press followed by moving the mouse and releasing the button.
     */
    LEFT_DRAG = 0,
    /**
     * A right mouse button press followed by moving the mouse and releasing the button.
     */
    RIGHT_DRAG = 1,
    /**
     * A middle mouse button press followed by moving the mouse and releasing the button.
     */
    MIDDLE_DRAG = 2,
    /**
     * Scrolling the middle mouse button.
     */
    WHEEL = 3,
    /**
     * A two-finger touch on a touch surface.
     */
    PINCH = 4
}

/**
 * A tile in a {@link Cesium3DTileset}.  When a tile is first created, its content is not loaded;
 * the content is loaded on-demand when needed based on the view.
 * <p>
 * Do not construct this directly, instead access tiles through {@link Cesium3DTileset#tileVisible}.
 * </p>
 * @param tileset - The tileset
 * @param baseResource - The base resource for the tileset
 * @param header - The JSON header for the tile
 * @param parent - The parent tile of the new tile
 */
export class Cesium3DTile {
    constructor(tileset: Cesium3DTileset, baseResource: Resource, header: any, parent: Cesium3DTile);
    /**
     * The local transform of this tile.
     */
    transform: Matrix4;
    /**
     * The final computed transform of this tile.
     */
    readonly computedTransform: Matrix4;
    /**
     * The error, in meters, introduced if this tile is rendered and its children are not.
     * This is used to compute screen space error, i.e., the error measured in pixels.
     */
    readonly geometricError: number;
    /**
     * Gets the tile's children.
     */
    readonly children: Cesium3DTile[];
    /**
     * This tile's parent or <code>undefined</code> if this tile is the root.
     * <p>
     * When a tile's content points to an external tileset JSON file, the external tileset's
     * root tile's parent is not <code>undefined</code>; instead, the parent references
     * the tile (with its content pointing to an external tileset JSON file) as if the two tilesets were merged.
     * </p>
     */
    readonly parent: Cesium3DTile;
    /**
     * The time in seconds after the tile's content is ready when the content expires and new content is requested.
     */
    expireDuration: number;
    /**
     * The date when the content expires and new content is requested.
     */
    expireDate: JulianDate;
    /**
     * The tileset containing this tile.
     */
    readonly tileset: Cesium3DTileset;
    /**
     * The tile's content.  This represents the actual tile's payload,
     * not the content's metadata in the tileset JSON file.
     */
    readonly content: Cesium3DTileContent;
    /**
     * Get the bounding sphere derived from the tile's bounding volume.
     */
    readonly boundingSphere: BoundingSphere;
    /**
     * Returns the <code>extras</code> property in the tileset JSON for this tile, which contains application specific metadata.
     * Returns <code>undefined</code> if <code>extras</code> does not exist.
     */
    readonly extras: any;
    /**
     * Gets the I3S Node for the tile.
     */
    i3sNode: string;
}

/**
 * Defines how per-feature colors set from the Cesium API or declarative styling blend with the source colors from
 * the original feature, e.g. glTF material or per-point color in the tile.
 * <p>
 * When <code>REPLACE</code> or <code>MIX</code> are used and the source color is a glTF material, the technique must assign the
 * <code>_3DTILESDIFFUSE</code> semantic to the diffuse color parameter. Otherwise only <code>HIGHLIGHT</code> is supported.
 * </p>
 * <p>
 * A feature whose color evaluates to white (1.0, 1.0, 1.0) is always rendered without color blending, regardless of the
 * tileset's color blend mode.
 * </p>
 * <pre><code>
 * "techniques": {
 *   "technique0": {
 *     "parameters": {
 *       "diffuse": {
 *         "semantic": "_3DTILESDIFFUSE",
 *         "type": 35666
 *       }
 *     }
 *   }
 * }
 * </code></pre>
 */
export enum Cesium3DTileColorBlendMode {
    /**
     * Multiplies the source color by the feature color.
     */
    HIGHLIGHT = 0,
    /**
     * Replaces the source color with the feature color.
     */
    REPLACE = 1,
    /**
     * Blends the source color and feature color together.
     */
    MIX = 2
}

/**
 * The content of a tile in a {@link Cesium3DTileset}.
 * <p>
 * Derived classes of this interface provide access to individual features in the tile.
 * Access derived objects through {@link Cesium3DTile#content}.
 * </p>
 * <p>
 * This type describes an interface and is not intended to be instantiated directly.
 * </p>
 */
export class Cesium3DTileContent {
    constructor();
    /**
     * Gets the number of features in the tile.
     */
    readonly featuresLength: number;
    /**
     * Gets the number of points in the tile.
     * <p>
     * Only applicable for tiles with Point Cloud content. This is different than {@link Cesium3DTileContent#featuresLength} which
     * equals the number of groups of points as distinguished by the <code>BATCH_ID</code> feature table semantic.
     * </p>
     */
    readonly pointsLength: number;
    /**
     * Gets the number of triangles in the tile.
     */
    readonly trianglesLength: number;
    /**
     * Gets the tile's geometry memory in bytes.
     */
    readonly geometryByteLength: number;
    /**
     * Gets the tile's texture memory in bytes.
     */
    readonly texturesByteLength: number;
    /**
     * Gets the amount of memory used by the batch table textures and any binary
     * metadata properties not accounted for in geometryByteLength or
     * texturesByteLength
     */
    readonly batchTableByteLength: number;
    /**
     * Gets the array of {@link Cesium3DTileContent} objects for contents that contain other contents, such as composite tiles. The inner contents may in turn have inner contents, such as a composite tile that contains a composite tile.
     */
    readonly innerContents: any[];
    /**
     * Returns true when the tile's content is ready to render; otherwise false
     */
    readonly ready: boolean;
    /**
     * Gets the tileset for this tile.
     */
    readonly tileset: Cesium3DTileset;
    /**
     * Gets the tile containing this content.
     */
    readonly tile: Cesium3DTile;
    /**
     * Gets the url of the tile's content.
     */
    readonly url: string;
    /**
     * Returns whether the feature has this property.
     * @param batchId - The batchId for the feature.
     * @param name - The case-sensitive name of the property.
     * @returns <code>true</code> if the feature has this property; otherwise, <code>false</code>.
     */
    hasProperty(batchId: number, name: string): boolean;
    /**
     * Returns the {@link Cesium3DTileFeature} object for the feature with the
     * given <code>batchId</code>.  This object is used to get and modify the
     * feature's properties.
     * <p>
     * Features in a tile are ordered by <code>batchId</code>, an index used to retrieve their metadata from the batch table.
     * </p>
     * @param batchId - The batchId for the feature.
     * @returns The corresponding {@link Cesium3DTileFeature} object.
     */
    getFeature(batchId: number): Cesium3DTileFeature;
}

/**
 * A feature of a {@link Cesium3DTileset}.
 * <p>
 * Provides access to a feature's properties stored in the tile's batch table, as well
 * as the ability to show/hide a feature and change its highlight color via
 * {@link Cesium3DTileFeature#show} and {@link Cesium3DTileFeature#color}, respectively.
 * </p>
 * <p>
 * Modifications to a <code>Cesium3DTileFeature</code> object have the lifetime of the tile's
 * content.  If the tile's content is unloaded, e.g., due to it going out of view and needing
 * to free space in the cache for visible tiles, listen to the {@link Cesium3DTileset#tileUnload} event to save any
 * modifications. Also listen to the {@link Cesium3DTileset#tileVisible} event to reapply any modifications.
 * </p>
 * <p>
 * Do not construct this directly.  Access it through {@link Cesium3DTileContent#getFeature}
 * or picking using {@link Scene#pick}.
 * </p>
 * @example
 * // On mouse over, display all the properties for a feature in the console log.
 * handler.setInputAction(function(movement) {
 *     const feature = scene.pick(movement.endPosition);
 *     if (feature instanceof Cesium.Cesium3DTileFeature) {
 *         const propertyIds = feature.getPropertyIds();
 *         const length = propertyIds.length;
 *         for (let i = 0; i < length; ++i) {
 *             const propertyId = propertyIds[i];
 *             console.log(`{propertyId}: ${feature.getProperty(propertyId)}`);
 *         }
 *     }
 * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
 */
export class Cesium3DTileFeature {
    constructor();
    /**
     * Gets or sets if the feature will be shown. This is set for all features
     * when a style's show is evaluated.
     */
    show: boolean;
    /**
     * Gets or sets the highlight color multiplied with the feature's color.  When
     * this is white, the feature's color is not changed. This is set for all features
     * when a style's color is evaluated.
     */
    color: Color;
    /**
     * Gets a typed array containing the ECEF positions of the polyline.
     * Returns undefined if {@link Cesium3DTileset#vectorKeepDecodedPositions} is false
     * or the feature is not a polyline in a vector tile.
     */
    polylinePositions: Float64Array;
    /**
     * Gets the tileset containing the feature.
     */
    readonly tileset: Cesium3DTileset;
    /**
     * All objects returned by {@link Scene#pick} have a <code>primitive</code> property. This returns
     * the tileset containing the feature.
     */
    readonly primitive: Cesium3DTileset;
    /**
     * Get the feature ID associated with this feature. For 3D Tiles 1.0, the
     * batch ID is returned. For EXT_mesh_features, this is the feature ID from
     * the selected feature ID set.
     */
    readonly featureId: number;
    /**
     * Returns whether the feature contains this property. This includes properties from this feature's
     * class and inherited classes when using a batch table hierarchy.
     * @param name - The case-sensitive name of the property.
     * @returns Whether the feature contains this property.
     */
    hasProperty(name: string): boolean;
    /**
     * Returns an array of property IDs for the feature. This includes properties from this feature's
     * class and inherited classes when using a batch table hierarchy.
     * @param [results] - An array into which to store the results.
     * @returns The IDs of the feature's properties.
     */
    getPropertyIds(results?: string[]): string[];
    /**
     * Returns a copy of the value of the feature's property with the given name. This includes properties from this feature's
     * class and inherited classes when using a batch table hierarchy.
     * @example
     * // Display all the properties for a feature in the console log.
     * const propertyIds = feature.getPropertyIds();
     * const length = propertyIds.length;
     * for (let i = 0; i < length; ++i) {
     *     const propertyId = propertyIds[i];
     *     console.log(`{propertyId}: ${feature.getProperty(propertyId)}`);
     * }
     * @param name - The case-sensitive name of the property.
     * @returns The value of the property or <code>undefined</code> if the feature does not have this property.
     */
    getProperty(name: string): any;
    /**
     * Returns a copy of the feature's property with the given name, examining all
     * the metadata from 3D Tiles 1.0 formats, the EXT_structural_metadata and legacy
     * EXT_feature_metadata glTF extensions, and the metadata present either in the
     * tileset JSON (3D Tiles 1.1) or in the 3DTILES_metadata 3D Tiles extension.
     * Metadata is checked against name from most specific to most general and the
     * first match is returned. Metadata is checked in this order:
     *
     * <ol>
     *   <li>Batch table (structural metadata) property by semantic</li>
     *   <li>Batch table (structural metadata) property by property ID</li>
     *   <li>Content metadata property by semantic</li>
     *   <li>Content metadata property by property</li>
     *   <li>Tile metadata property by semantic</li>
     *   <li>Tile metadata property by property ID</li>
     *   <li>Subtree metadata property by semantic</li>
     *   <li>Subtree metadata property by property ID</li>
     *   <li>Group metadata property by semantic</li>
     *   <li>Group metadata property by property ID</li>
     *   <li>Tileset metadata property by semantic</li>
     *   <li>Tileset metadata property by property ID</li>
     *   <li>Otherwise, return undefined</li>
     * </ol>
     * <p>
     * For 3D Tiles Next details, see the {@link https://github.com/CesiumGS/3d-tiles/tree/main/extensions/3DTILES_metadata|3DTILES_metadata Extension}
     * for 3D Tiles, as well as the {@link https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_structural_metadata|EXT_structural_metadata Extension}
     * for glTF. For the legacy glTF extension, see {@link https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_feature_metadata|EXT_feature_metadata Extension}
     * </p>
     * @param content - The content for accessing the metadata
     * @param batchId - The batch ID (or feature ID) of the feature to get a property for
     * @param name - The semantic or property ID of the feature. Semantics are checked before property IDs in each granularity of metadata.
     * @returns The value of the property or <code>undefined</code> if the feature does not have this property.
     */
    static getPropertyInherited(content: Cesium3DTileContent, batchId: number, name: string): any;
    /**
     * Sets the value of the feature's property with the given name.
     * <p>
     * If a property with the given name doesn't exist, it is created.
     * </p>
     * @example
     * const height = feature.getProperty('Height'); // e.g., the height of a building
     * @example
     * const name = 'clicked';
     * if (feature.getProperty(name)) {
     *     console.log('already clicked');
     * } else {
     *     feature.setProperty(name, true);
     *     console.log('first click');
     * }
     * @param name - The case-sensitive name of the property.
     * @param value - The value of the property that will be copied.
     */
    setProperty(name: string, value: any): void;
}

/**
 * A point feature of a {@link Cesium3DTileset}.
 * <p>
 * Provides access to a feature's properties stored in the tile's batch table, as well
 * as the ability to show/hide a feature and change its point properties
 * </p>
 * <p>
 * Modifications to a <code>Cesium3DTilePointFeature</code> object have the lifetime of the tile's
 * content.  If the tile's content is unloaded, e.g., due to it going out of view and needing
 * to free space in the cache for visible tiles, listen to the {@link Cesium3DTileset#tileUnload} event to save any
 * modifications. Also listen to the {@link Cesium3DTileset#tileVisible} event to reapply any modifications.
 * </p>
 * <p>
 * Do not construct this directly.  Access it through {@link Cesium3DTileContent#getFeature}
 * or picking using {@link Scene#pick} and {@link Scene#pickPosition}.
 * </p>
 * @example
 * // On mouse over, display all the properties for a feature in the console log.
 * handler.setInputAction(function(movement) {
 *     const feature = scene.pick(movement.endPosition);
 *     if (feature instanceof Cesium.Cesium3DTilePointFeature) {
 *         const propertyIds = feature.getPropertyIds();
 *         const length = propertyIds.length;
 *         for (let i = 0; i < length; ++i) {
 *             const propertyId = propertyIds[i];
 *             console.log(`{propertyId}: ${feature.getProperty(propertyId)}`);
 *         }
 *     }
 * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
 */
export class Cesium3DTilePointFeature {
    constructor();
    /**
     * Gets or sets if the feature will be shown. This is set for all features
     * when a style's show is evaluated.
     */
    show: boolean;
    /**
     * Gets or sets the color of the point of this feature.
     * <p>
     * Only applied when <code>image</code> is <code>undefined</code>.
     * </p>
     */
    color: Color;
    /**
     * Gets or sets the point size of this feature.
     * <p>
     * Only applied when <code>image</code> is <code>undefined</code>.
     * </p>
     */
    pointSize: number;
    /**
     * Gets or sets the point outline color of this feature.
     * <p>
     * Only applied when <code>image</code> is <code>undefined</code>.
     * </p>
     */
    pointOutlineColor: Color;
    /**
     * Gets or sets the point outline width in pixels of this feature.
     * <p>
     * Only applied when <code>image</code> is <code>undefined</code>.
     * </p>
     */
    pointOutlineWidth: number;
    /**
     * Gets or sets the label color of this feature.
     * <p>
     * The color will be applied to the label if <code>labelText</code> is defined.
     * </p>
     */
    labelColor: Color;
    /**
     * Gets or sets the label outline color of this feature.
     * <p>
     * The outline color will be applied to the label if <code>labelText</code> is defined.
     * </p>
     */
    labelOutlineColor: Color;
    /**
     * Gets or sets the outline width in pixels of this feature.
     * <p>
     * The outline width will be applied to the point if <code>labelText</code> is defined.
     * </p>
     */
    labelOutlineWidth: number;
    /**
     * Gets or sets the font of this feature.
     * <p>
     * Only applied when the <code>labelText</code> is defined.
     * </p>
     */
    font: string;
    /**
     * Gets or sets the fill and outline style of this feature.
     * <p>
     * Only applied when <code>labelText</code> is defined.
     * </p>
     */
    labelStyle: LabelStyle;
    /**
     * Gets or sets the text for this feature.
     */
    labelText: string;
    /**
     * Gets or sets the background color of the text for this feature.
     * <p>
     * Only applied when <code>labelText</code> is defined.
     * </p>
     */
    backgroundColor: Color;
    /**
     * Gets or sets the background padding of the text for this feature.
     * <p>
     * Only applied when <code>labelText</code> is defined.
     * </p>
     */
    backgroundPadding: Cartesian2;
    /**
     * Gets or sets whether to display the background of the text for this feature.
     * <p>
     * Only applied when <code>labelText</code> is defined.
     * </p>
     */
    backgroundEnabled: boolean;
    /**
     * Gets or sets the near and far scaling properties for this feature.
     */
    scaleByDistance: NearFarScalar;
    /**
     * Gets or sets the near and far translucency properties for this feature.
     */
    translucencyByDistance: NearFarScalar;
    /**
     * Gets or sets the condition specifying at what distance from the camera that this feature will be displayed.
     */
    distanceDisplayCondition: DistanceDisplayCondition;
    /**
     * Gets or sets the height offset in meters of this feature.
     */
    heightOffset: number;
    /**
     * Gets or sets whether the anchor line is displayed.
     * <p>
     * Only applied when <code>heightOffset</code> is defined.
     * </p>
     */
    anchorLineEnabled: boolean;
    /**
     * Gets or sets the color for the anchor line.
     * <p>
     * Only applied when <code>heightOffset</code> is defined.
     * </p>
     */
    anchorLineColor: Color;
    /**
     * Gets or sets the image of this feature.
     */
    image: string;
    /**
     * Gets or sets the distance where depth testing will be disabled.
     */
    disableDepthTestDistance: number;
    /**
     * Gets or sets the horizontal origin of this point, which determines if the point is
     * to the left, center, or right of its anchor position.
     */
    horizontalOrigin: HorizontalOrigin;
    /**
     * Gets or sets the vertical origin of this point, which determines if the point is
     * to the bottom, center, or top of its anchor position.
     */
    verticalOrigin: VerticalOrigin;
    /**
     * Gets or sets the horizontal origin of this point's text, which determines if the point's text is
     * to the left, center, or right of its anchor position.
     */
    labelHorizontalOrigin: HorizontalOrigin;
    /**
     * Get or sets the vertical origin of this point's text, which determines if the point's text is
     * to the bottom, center, top, or baseline of it's anchor point.
     */
    labelVerticalOrigin: VerticalOrigin;
    /**
     * Gets the tileset containing the feature.
     */
    readonly tileset: Cesium3DTileset;
    /**
     * All objects returned by {@link Scene#pick} have a <code>primitive</code> property. This returns
     * the tileset containing the feature.
     */
    readonly primitive: Cesium3DTileset;
    /**
     * Returns whether the feature contains this property. This includes properties from this feature's
     * class and inherited classes when using a batch table hierarchy.
     * @param name - The case-sensitive name of the property.
     * @returns Whether the feature contains this property.
     */
    hasProperty(name: string): boolean;
    /**
     * Returns an array of property IDs for the feature. This includes properties from this feature's
     * class and inherited classes when using a batch table hierarchy.
     * @param [results] - An array into which to store the results.
     * @returns The IDs of the feature's properties.
     */
    getPropertyIds(results?: string[]): string[];
    /**
     * Returns a copy of the value of the feature's property with the given name. This includes properties from this feature's
     * class and inherited classes when using a batch table hierarchy.
     * @example
     * // Display all the properties for a feature in the console log.
     * const propertyIds = feature.getPropertyIds();
     * const length = propertyIds.length;
     * for (let i = 0; i < length; ++i) {
     *     const propertyId = propertyIds[i];
     *     console.log(`{propertyId} : ${feature.getProperty(propertyId)}`);
     * }
     * @param name - The case-sensitive name of the property.
     * @returns The value of the property or <code>undefined</code> if the feature does not have this property.
     */
    getProperty(name: string): any;
    /**
     * Sets the value of the feature's property with the given name.
     * <p>
     * If a property with the given name doesn't exist, it is created.
     * </p>
     * @example
     * const height = feature.getProperty('Height'); // e.g., the height of a building
     * @example
     * const name = 'clicked';
     * if (feature.getProperty(name)) {
     *     console.log('already clicked');
     * } else {
     *     feature.setProperty(name, true);
     *     console.log('first click');
     * }
     * @param name - The case-sensitive name of the property.
     * @param value - The value of the property that will be copied.
     */
    setProperty(name: string, value: any): void;
}

/**
 * A style that is applied to a {@link Cesium3DTileset}.
 * <p>
 * Evaluates an expression defined using the
 * {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Styling|3D Tiles Styling language}.
 * </p>
 * @example
 * tileset.style = new Cesium.Cesium3DTileStyle({
 *     color : {
 *         conditions : [
 *             ['${Height} >= 100', 'color("purple", 0.5)'],
 *             ['${Height} >= 50', 'color("red")'],
 *             ['true', 'color("blue")']
 *         ]
 *     },
 *     show : '${Height} > 0',
 *     meta : {
 *         description : '"Building id ${id} has height ${Height}."'
 *     }
 * });
 * @example
 * tileset.style = new Cesium.Cesium3DTileStyle({
 *     color : 'vec4(${Temperature})',
 *     pointSize : '${Temperature} * 2.0'
 * });
 * @param [style] - An object defining a style.
 */
export class Cesium3DTileStyle {
    constructor(style?: any);
    /**
     * Gets the object defining the style using the
     * {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Styling|3D Tiles Styling language}.
     */
    readonly style: any;
    /**
     * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>show</code> property. Alternatively a boolean, string, or object defining a show style can be used.
     * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
     * <p>
     * The expression must return or convert to a <code>Boolean</code>.
     * </p>
     * <p>
     * This expression is applicable to all tile formats.
     * </p>
     * @example
     * const style = new Cesium3DTileStyle({
     *     show : '(regExp("^Chest").test(${County})) && (${YearBuilt} >= 1970)'
     * });
     * style.show.evaluate(feature); // returns true or false depending on the feature's properties
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override show expression with a custom function
     * style.show = {
     *     evaluate : function(feature) {
     *         return true;
     *     }
     * };
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override show expression with a boolean
     * style.show = true;
     * };
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override show expression with a string
     * style.show = '${Height} > 0';
     * };
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override show expression with a condition
     * style.show = {
     *     conditions: [
     *         ['${height} > 2', 'false'],
     *         ['true', 'true']
     *     ];
     * };
     */
    show: StyleExpression;
    /**
     * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>color</code> property. Alternatively a string or object defining a color style can be used.
     * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
     * <p>
     * The expression must return a <code>Color</code>.
     * </p>
     * <p>
     * This expression is applicable to all tile formats.
     * </p>
     * @example
     * const style = new Cesium3DTileStyle({
     *     color : '(${Temperature} > 90) ? color("red") : color("white")'
     * });
     * style.color.evaluateColor(feature, result); // returns a Cesium.Color object
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override color expression with a custom function
     * style.color = {
     *     evaluateColor : function(feature, result) {
     *         return Cesium.Color.clone(Cesium.Color.WHITE, result);
     *     }
     * };
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override color expression with a string
     * style.color = 'color("blue")';
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override color expression with a condition
     * style.color = {
     *     conditions : [
     *         ['${height} > 2', 'color("cyan")'],
     *         ['true', 'color("blue")']
     *     ]
     * };
     */
    color: StyleExpression;
    /**
     * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>pointSize</code> property. Alternatively a string or object defining a point size style can be used.
     * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
     * <p>
     * The expression must return a <code>Number</code>.
     * </p>
     * <p>
     * This expression is only applicable to point features in a Vector tile or a Point Cloud tile.
     * </p>
     * @example
     * const style = new Cesium3DTileStyle({
     *     pointSize : '(${Temperature} > 90) ? 2.0 : 1.0'
     * });
     * style.pointSize.evaluate(feature); // returns a Number
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override pointSize expression with a custom function
     * style.pointSize = {
     *     evaluate : function(feature) {
     *         return 1.0;
     *     }
     * };
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override pointSize expression with a number
     * style.pointSize = 1.0;
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override pointSize expression with a string
     * style.pointSize = '${height} / 10';
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override pointSize expression with a condition
     * style.pointSize =  {
     *     conditions : [
     *         ['${height} > 2', '1.0'],
     *         ['true', '2.0']
     *     ]
     * };
     */
    pointSize: StyleExpression;
    /**
     * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>pointOutlineColor</code> property. Alternatively a string or object defining a color style can be used.
     * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
     * <p>
     * The expression must return a <code>Color</code>.
     * </p>
     * <p>
     * This expression is only applicable to point features in a Vector tile.
     * </p>
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override pointOutlineColor expression with a string
     * style.pointOutlineColor = 'color("blue")';
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override pointOutlineColor expression with a condition
     * style.pointOutlineColor = {
     *     conditions : [
     *         ['${height} > 2', 'color("cyan")'],
     *         ['true', 'color("blue")']
     *     ]
     * };
     */
    pointOutlineColor: StyleExpression;
    /**
     * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>pointOutlineWidth</code> property. Alternatively a string or object defining a number style can be used.
     * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
     * <p>
     * The expression must return a <code>Number</code>.
     * </p>
     * <p>
     * This expression is only applicable to point features in a Vector tile.
     * </p>
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override pointOutlineWidth expression with a string
     * style.pointOutlineWidth = '5';
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override pointOutlineWidth expression with a condition
     * style.pointOutlineWidth = {
     *     conditions : [
     *         ['${height} > 2', '5'],
     *         ['true', '0']
     *     ]
     * };
     */
    pointOutlineWidth: StyleExpression;
    /**
     * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>labelColor</code> property. Alternatively a string or object defining a color style can be used.
     * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
     * <p>
     * The expression must return a <code>Color</code>.
     * </p>
     * <p>
     * This expression is only applicable to point features in a Vector tile.
     * </p>
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override labelColor expression with a string
     * style.labelColor = 'color("blue")';
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override labelColor expression with a condition
     * style.labelColor = {
     *     conditions : [
     *         ['${height} > 2', 'color("cyan")'],
     *         ['true', 'color("blue")']
     *     ]
     * };
     */
    labelColor: StyleExpression;
    /**
     * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>labelOutlineColor</code> property. Alternatively a string or object defining a color style can be used.
     * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
     * <p>
     * The expression must return a <code>Color</code>.
     * </p>
     * <p>
     * This expression is only applicable to point features in a Vector tile.
     * </p>
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override labelOutlineColor expression with a string
     * style.labelOutlineColor = 'color("blue")';
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override labelOutlineColor expression with a condition
     * style.labelOutlineColor = {
     *     conditions : [
     *         ['${height} > 2', 'color("cyan")'],
     *         ['true', 'color("blue")']
     *     ]
     * };
     */
    labelOutlineColor: StyleExpression;
    /**
     * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>labelOutlineWidth</code> property. Alternatively a string or object defining a number style can be used.
     * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
     * <p>
     * The expression must return a <code>Number</code>.
     * </p>
     * <p>
     * This expression is only applicable to point features in a Vector tile.
     * </p>
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override labelOutlineWidth expression with a string
     * style.labelOutlineWidth = '5';
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override labelOutlineWidth expression with a condition
     * style.labelOutlineWidth = {
     *     conditions : [
     *         ['${height} > 2', '5'],
     *         ['true', '0']
     *     ]
     * };
     */
    labelOutlineWidth: StyleExpression;
    /**
     * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>font</code> property. Alternatively a string or object defining a string style can be used.
     * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
     * <p>
     * The expression must return a <code>String</code>.
     * </p>
     * <p>
     * This expression is only applicable to point features in a Vector tile.
     * </p>
     * @example
     * const style = new Cesium3DTileStyle({
     *     font : '(${Temperature} > 90) ? "30px Helvetica" : "24px Helvetica"'
     * });
     * style.font.evaluate(feature); // returns a String
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override font expression with a custom function
     * style.font = {
     *     evaluate : function(feature) {
     *         return '24px Helvetica';
     *     }
     * };
     */
    font: StyleExpression;
    /**
     * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>label style</code> property. Alternatively a string or object defining a number style can be used.
     * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
     * <p>
     * The expression must return a <code>LabelStyle</code>.
     * </p>
     * <p>
     * This expression is only applicable to point features in a Vector tile.
     * </p>
     * @example
     * const style = new Cesium3DTileStyle({
     *     labelStyle : `(\${Temperature} > 90) ? ${LabelStyle.FILL_AND_OUTLINE} : ${LabelStyle.FILL}`
     * });
     * style.labelStyle.evaluate(feature); // returns a LabelStyle
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override labelStyle expression with a custom function
     * style.labelStyle = {
     *     evaluate : function(feature) {
     *         return LabelStyle.FILL;
     *     }
     * };
     */
    labelStyle: StyleExpression;
    /**
     * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>labelText</code> property. Alternatively a string or object defining a string style can be used.
     * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
     * <p>
     * The expression must return a <code>String</code>.
     * </p>
     * <p>
     * This expression is only applicable to point features in a Vector tile.
     * </p>
     * @example
     * const style = new Cesium3DTileStyle({
     *     labelText : '(${Temperature} > 90) ? ">90" : "<=90"'
     * });
     * style.labelText.evaluate(feature); // returns a String
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override labelText expression with a custom function
     * style.labelText = {
     *     evaluate : function(feature) {
     *         return 'Example label text';
     *     }
     * };
     */
    labelText: StyleExpression;
    /**
     * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>backgroundColor</code> property. Alternatively a string or object defining a color style can be used.
     * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
     * <p>
     * The expression must return a <code>Color</code>.
     * </p>
     * <p>
     * This expression is only applicable to point features in a Vector tile.
     * </p>
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override backgroundColor expression with a string
     * style.backgroundColor = 'color("blue")';
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override backgroundColor expression with a condition
     * style.backgroundColor = {
     *     conditions : [
     *         ['${height} > 2', 'color("cyan")'],
     *         ['true', 'color("blue")']
     *     ]
     * };
     */
    backgroundColor: StyleExpression;
    /**
     * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>backgroundPadding</code> property. Alternatively a string or object defining a vec2 style can be used.
     * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
     * <p>
     * The expression must return a <code>Cartesian2</code>.
     * </p>
     * <p>
     * This expression is only applicable to point features in a Vector tile.
     * </p>
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override backgroundPadding expression with a string
     * style.backgroundPadding = 'vec2(5.0, 7.0)';
     * style.backgroundPadding.evaluate(feature); // returns a Cartesian2
     */
    backgroundPadding: StyleExpression;
    /**
     * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>backgroundEnabled</code> property. Alternatively a string or object defining a boolean style can be used.
     * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
     * <p>
     * The expression must return a <code>Boolean</code>.
     * </p>
     * <p>
     * This expression is only applicable to point features in a Vector tile.
     * </p>
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override backgroundEnabled expression with a string
     * style.backgroundEnabled = 'true';
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override backgroundEnabled expression with a condition
     * style.backgroundEnabled = {
     *     conditions : [
     *         ['${height} > 2', 'true'],
     *         ['true', 'false']
     *     ]
     * };
     */
    backgroundEnabled: StyleExpression;
    /**
     * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>scaleByDistance</code> property. Alternatively a string or object defining a vec4 style can be used.
     * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
     * <p>
     * The expression must return a <code>Cartesian4</code>.
     * </p>
     * <p>
     * This expression is only applicable to point features in a Vector tile.
     * </p>
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override scaleByDistance expression with a string
     * style.scaleByDistance = 'vec4(1.5e2, 2.0, 1.5e7, 0.5)';
     * style.scaleByDistance.evaluate(feature); // returns a Cartesian4
     */
    scaleByDistance: StyleExpression;
    /**
     * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>translucencyByDistance</code> property. Alternatively a string or object defining a vec4 style can be used.
     * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
     * <p>
     * The expression must return a <code>Cartesian4</code>.
     * </p>
     * <p>
     * This expression is only applicable to point features in a Vector tile.
     * </p>
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override translucencyByDistance expression with a string
     * style.translucencyByDistance = 'vec4(1.5e2, 1.0, 1.5e7, 0.2)';
     * style.translucencyByDistance.evaluate(feature); // returns a Cartesian4
     */
    translucencyByDistance: StyleExpression;
    /**
     * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>distanceDisplayCondition</code> property. Alternatively a string or object defining a vec2 style can be used.
     * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
     * <p>
     * The expression must return a <code>Cartesian2</code>.
     * </p>
     * <p>
     * This expression is only applicable to point features in a Vector tile.
     * </p>
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override distanceDisplayCondition expression with a string
     * style.distanceDisplayCondition = 'vec2(0.0, 5.5e6)';
     * style.distanceDisplayCondition.evaluate(feature); // returns a Cartesian2
     */
    distanceDisplayCondition: StyleExpression;
    /**
     * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>heightOffset</code> property. Alternatively a string or object defining a number style can be used.
     * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
     * <p>
     * The expression must return a <code>Number</code>.
     * </p>
     * <p>
     * This expression is only applicable to point features in a Vector tile.
     * </p>
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override heightOffset expression with a string
     * style.heightOffset = '2.0';
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override heightOffset expression with a condition
     * style.heightOffset = {
     *     conditions : [
     *         ['${height} > 2', '4.0'],
     *         ['true', '2.0']
     *     ]
     * };
     */
    heightOffset: StyleExpression;
    /**
     * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>anchorLineEnabled</code> property. Alternatively a string or object defining a boolean style can be used.
     * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
     * <p>
     * The expression must return a <code>Boolean</code>.
     * </p>
     * <p>
     * This expression is only applicable to point features in a Vector tile.
     * </p>
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override anchorLineEnabled expression with a string
     * style.anchorLineEnabled = 'true';
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override anchorLineEnabled expression with a condition
     * style.anchorLineEnabled = {
     *     conditions : [
     *         ['${height} > 2', 'true'],
     *         ['true', 'false']
     *     ]
     * };
     */
    anchorLineEnabled: StyleExpression;
    /**
     * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>anchorLineColor</code> property. Alternatively a string or object defining a color style can be used.
     * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
     * <p>
     * The expression must return a <code>Color</code>.
     * </p>
     * <p>
     * This expression is only applicable to point features in a Vector tile.
     * </p>
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override anchorLineColor expression with a string
     * style.anchorLineColor = 'color("blue")';
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override anchorLineColor expression with a condition
     * style.anchorLineColor = {
     *     conditions : [
     *         ['${height} > 2', 'color("cyan")'],
     *         ['true', 'color("blue")']
     *     ]
     * };
     */
    anchorLineColor: StyleExpression;
    /**
     * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>image</code> property. Alternatively a string or object defining a string style can be used.
     * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
     * <p>
     * The expression must return a <code>String</code>.
     * </p>
     * <p>
     * This expression is only applicable to point features in a Vector tile.
     * </p>
     * @example
     * const style = new Cesium3DTileStyle({
     *     image : '(${Temperature} > 90) ? "/url/to/image1" : "/url/to/image2"'
     * });
     * style.image.evaluate(feature); // returns a String
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override image expression with a custom function
     * style.image = {
     *     evaluate : function(feature) {
     *         return '/url/to/image';
     *     }
     * };
     */
    image: StyleExpression;
    /**
     * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>disableDepthTestDistance</code> property. Alternatively a string or object defining a number style can be used.
     * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
     * <p>
     * The expression must return a <code>Number</code>.
     * </p>
     * <p>
     * This expression is only applicable to point features in a Vector tile.
     * </p>
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override disableDepthTestDistance expression with a string
     * style.disableDepthTestDistance = '1000.0';
     * style.disableDepthTestDistance.evaluate(feature); // returns a Number
     */
    disableDepthTestDistance: StyleExpression;
    /**
     * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>horizontalOrigin</code> property. Alternatively a string or object defining a number style can be used.
     * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
     * <p>
     * The expression must return a <code>HorizontalOrigin</code>.
     * </p>
     * <p>
     * This expression is only applicable to point features in a Vector tile.
     * </p>
     * @example
     * const style = new Cesium3DTileStyle({
     *     horizontalOrigin : HorizontalOrigin.LEFT
     * });
     * style.horizontalOrigin.evaluate(feature); // returns a HorizontalOrigin
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override horizontalOrigin expression with a custom function
     * style.horizontalOrigin = {
     *     evaluate : function(feature) {
     *         return HorizontalOrigin.CENTER;
     *     }
     * };
     */
    horizontalOrigin: StyleExpression;
    /**
     * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>verticalOrigin</code> property. Alternatively a string or object defining a number style can be used.
     * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
     * <p>
     * The expression must return a <code>VerticalOrigin</code>.
     * </p>
     * <p>
     * This expression is only applicable to point features in a Vector tile.
     * </p>
     * @example
     * const style = new Cesium3DTileStyle({
     *     verticalOrigin : VerticalOrigin.TOP
     * });
     * style.verticalOrigin.evaluate(feature); // returns a VerticalOrigin
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override verticalOrigin expression with a custom function
     * style.verticalOrigin = {
     *     evaluate : function(feature) {
     *         return VerticalOrigin.CENTER;
     *     }
     * };
     */
    verticalOrigin: StyleExpression;
    /**
     * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>labelHorizontalOrigin</code> property. Alternatively a string or object defining a number style can be used.
     * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
     * <p>
     * The expression must return a <code>HorizontalOrigin</code>.
     * </p>
     * <p>
     * This expression is only applicable to point features in a Vector tile.
     * </p>
     * @example
     * const style = new Cesium3DTileStyle({
     *     labelHorizontalOrigin : HorizontalOrigin.LEFT
     * });
     * style.labelHorizontalOrigin.evaluate(feature); // returns a HorizontalOrigin
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override labelHorizontalOrigin expression with a custom function
     * style.labelHorizontalOrigin = {
     *     evaluate : function(feature) {
     *         return HorizontalOrigin.CENTER;
     *     }
     * };
     */
    labelHorizontalOrigin: StyleExpression;
    /**
     * Gets or sets the {@link StyleExpression} object used to evaluate the style's <code>labelVerticalOrigin</code> property. Alternatively a string or object defining a number style can be used.
     * The getter will return the internal {@link Expression} or {@link ConditionsExpression}, which may differ from the value provided to the setter.
     * <p>
     * The expression must return a <code>VerticalOrigin</code>.
     * </p>
     * <p>
     * This expression is only applicable to point features in a Vector tile.
     * </p>
     * @example
     * const style = new Cesium3DTileStyle({
     *     labelVerticalOrigin : VerticalOrigin.TOP
     * });
     * style.labelVerticalOrigin.evaluate(feature); // returns a VerticalOrigin
     * @example
     * const style = new Cesium.Cesium3DTileStyle();
     * // Override labelVerticalOrigin expression with a custom function
     * style.labelVerticalOrigin = {
     *     evaluate : function(feature) {
     *         return VerticalOrigin.CENTER;
     *     }
     * };
     */
    labelVerticalOrigin: StyleExpression;
    /**
     * Gets or sets the object containing application-specific expression that can be explicitly
     * evaluated, e.g., for display in a UI.
     * @example
     * const style = new Cesium3DTileStyle({
     *     meta : {
     *         description : '"Building id ${id} has height ${Height}."'
     *     }
     * });
     * style.meta.description.evaluate(feature); // returns a String with the substituted variables
     */
    meta: StyleExpression;
}

/**
 * A {@link VoxelProvider} that fetches voxel data from a 3D Tiles tileset.
 * <p>
 * Implements the {@link VoxelProvider} interface.
 * </p>
 * <div class="notice">
 * This object is normally not instantiated directly, use {@link Cesium3DTilesVoxelProvider.fromUrl}.
 * </div>
 * @param options - Object with the following properties:
 */
export class Cesium3DTilesVoxelProvider extends VoxelProvider {
    constructor(options: any);
    /**
     * Creates a {@link VoxelProvider} that fetches voxel data from a 3D Tiles tileset.
     * @param url - The URL to a tileset JSON file
     * @returns The created provider
     */
    static fromUrl(url: Resource | string): Promise<Cesium3DTilesVoxelProvider>;
    /**
     * A transform from local space to global space. If undefined, the identity matrix will be used instead.
     */
    readonly globalTransform: Matrix4 | undefined;
    /**
     * A transform from shape space to local space. If undefined, the identity matrix will be used instead.
     */
    readonly shapeTransform: Matrix4 | undefined;
    /**
     * Gets the {@link VoxelShapeType}
     * This should not be called before {@link VoxelProvider#ready} returns true.
     */
    readonly shape: VoxelShapeType;
    /**
     * Gets the minimum bounds.
     * If undefined, the shape's default minimum bounds will be used instead.
     * This should not be called before {@link VoxelProvider#ready} returns true.
     */
    readonly minBounds: Cartesian3 | undefined;
    /**
     * Gets the maximum bounds.
     * If undefined, the shape's default maximum bounds will be used instead.
     * This should not be called before {@link VoxelProvider#ready} returns true.
     */
    readonly maxBounds: Cartesian3 | undefined;
    /**
     * Gets the number of voxels per dimension of a tile. This is the same for all tiles in the dataset.
     * This should not be called before {@link VoxelProvider#ready} returns true.
     */
    readonly dimensions: Cartesian3;
    /**
     * Gets the number of padding voxels before the tile. This improves rendering quality when sampling the edge of a tile, but it increases memory usage.
     * This should not be called before {@link VoxelProvider#ready} returns true.
     */
    readonly paddingBefore: Cartesian3 | undefined;
    /**
     * Gets the number of padding voxels after the tile. This improves rendering quality when sampling the edge of a tile, but it increases memory usage.
     * This should not be called before {@link VoxelProvider#ready} returns true.
     */
    readonly paddingAfter: Cartesian3 | undefined;
    /**
     * Gets the metadata names.
     * This should not be called before {@link VoxelProvider#ready} returns true.
     */
    readonly names: string[];
    /**
     * Gets the metadata types.
     * This should not be called before {@link VoxelProvider#ready} returns true.
     */
    readonly types: MetadataType[];
    /**
     * Gets the metadata component types.
     * This should not be called before {@link VoxelProvider#ready} returns true.
     */
    readonly componentTypes: MetadataComponentType[];
    /**
     * Gets the metadata minimum values.
     * This should not be called before {@link VoxelProvider#ready} returns true.
     */
    readonly minimumValues: number[][] | undefined;
    /**
     * Gets the metadata maximum values.
     * This should not be called before {@link VoxelProvider#ready} returns true.
     */
    readonly maximumValues: number[][] | undefined;
    /**
     * The maximum number of tiles that exist for this provider. This value is used as a hint to the voxel renderer to allocate an appropriate amount of GPU memory. If this value is not known it can be undefined.
     * This should not be called before {@link VoxelProvider#ready} returns true.
     */
    readonly maximumTileCount: number | undefined;
    /**
     * Requests the data for a given tile. The data is a flattened 3D array ordered by X, then Y, then Z.
     * This function should not be called before {@link VoxelProvider#ready} returns true.
     * @param [options] - Object with the following properties:
     * @param [options.tileLevel = 0] - The tile's level.
     * @param [options.tileX = 0] - The tile's X coordinate.
     * @param [options.tileY = 0] - The tile's Y coordinate.
     * @param [options.tileZ = 0] - The tile's Z coordinate.
     * @returns A promise to an array of typed arrays containing the requested voxel data or undefined if there was a problem loading the data.
     */
    requestData(options?: {
        tileLevel?: number;
        tileX?: number;
        tileY?: number;
        tileZ?: number;
    }): Promise<any[][]> | undefined;
}

export namespace Cesium3DTileset {
    /**
     * Initialization options for the Cesium3DTileset constructor
     * [show = true] - Determines if the tileset will be shown.
     * [modelMatrix = Matrix4.IDENTITY] - A 4x4 transformation matrix that transforms the tileset's root tile.
     * [modelUpAxis = Axis.Y] - Which axis is considered up when loading models for tile contents.
     * [modelForwardAxis = Axis.X] - Which axis is considered forward when loading models for tile contents.
     * [shadows = ShadowMode.ENABLED] - Determines whether the tileset casts or receives shadows from light sources.
     * [maximumScreenSpaceError = 16] - The maximum screen space error used to drive level of detail refinement.
     * [cacheBytes = 536870912] - The size (in bytes) to which the tile cache will be trimmed, if the cache contains tiles not needed for the current view.
     * [maximumCacheOverflowBytes = 536870912] - The maximum additional memory (in bytes) to allow for cache headroom, if more than {@link Cesium3DTileset#cacheBytes} are needed for the current view.
     * [cullWithChildrenBounds = true] - Optimization option. Whether to cull tiles using the union of their children bounding volumes.
     * [cullRequestsWhileMoving = true] - Optimization option. Don't request tiles that will likely be unused when they come back because of the camera's movement. This optimization only applies to stationary tilesets.
     * [cullRequestsWhileMovingMultiplier = 60.0] - Optimization option. Multiplier used in culling requests while moving. Larger is more aggressive culling, smaller less aggressive culling.
     * [preloadWhenHidden = false] - Preload tiles when <code>tileset.show</code> is <code>false</code>. Loads tiles as if the tileset is visible but does not render them.
     * [preloadFlightDestinations = true] - Optimization option. Preload tiles at the camera's flight destination while the camera is in flight.
     * [preferLeaves = false] - Optimization option. Prefer loading of leaves first.
     * [dynamicScreenSpaceError = false] - Optimization option. Reduce the screen space error for tiles that are further away from the camera.
     * [dynamicScreenSpaceErrorDensity = 0.00278] - Density used to adjust the dynamic screen space error, similar to fog density.
     * [dynamicScreenSpaceErrorFactor = 4.0] - A factor used to increase the computed dynamic screen space error.
     * [dynamicScreenSpaceErrorHeightFalloff = 0.25] - A ratio of the tileset's height at which the density starts to falloff.
     * [progressiveResolutionHeightFraction = 0.3] - Optimization option. If between (0.0, 0.5], tiles at or above the screen space error for the reduced screen resolution of <code>progressiveResolutionHeightFraction*screenHeight</code> will be prioritized first. This can help get a quick layer of tiles down while full resolution tiles continue to load.
     * [foveatedScreenSpaceError = true] - Optimization option. Prioritize loading tiles in the center of the screen by temporarily raising the screen space error for tiles around the edge of the screen. Screen space error returns to normal once all the tiles in the center of the screen as determined by the {@link Cesium3DTileset#foveatedConeSize} are loaded.
     * [foveatedConeSize = 0.1] - Optimization option. Used when {@link Cesium3DTileset#foveatedScreenSpaceError} is true to control the cone size that determines which tiles are deferred. Tiles that are inside this cone are loaded immediately. Tiles outside the cone are potentially deferred based on how far outside the cone they are and their screen space error. This is controlled by {@link Cesium3DTileset#foveatedInterpolationCallback} and {@link Cesium3DTileset#foveatedMinimumScreenSpaceErrorRelaxation}. Setting this to 0.0 means the cone will be the line formed by the camera position and its view direction. Setting this to 1.0 means the cone encompasses the entire field of view of the camera, disabling the effect.
     * [foveatedMinimumScreenSpaceErrorRelaxation = 0.0] - Optimization option. Used when {@link Cesium3DTileset#foveatedScreenSpaceError} is true to control the starting screen space error relaxation for tiles outside the foveated cone. The screen space error will be raised starting with tileset value up to {@link Cesium3DTileset#maximumScreenSpaceError} based on the provided {@link Cesium3DTileset#foveatedInterpolationCallback}.
     * [foveatedInterpolationCallback = Math.lerp] - Optimization option. Used when {@link Cesium3DTileset#foveatedScreenSpaceError} is true to control how much to raise the screen space error for tiles outside the foveated cone, interpolating between {@link Cesium3DTileset#foveatedMinimumScreenSpaceErrorRelaxation} and {@link Cesium3DTileset#maximumScreenSpaceError}
     * [foveatedTimeDelay = 0.2] - Optimization option. Used when {@link Cesium3DTileset#foveatedScreenSpaceError} is true to control how long in seconds to wait after the camera stops moving before deferred tiles start loading in. This time delay prevents requesting tiles around the edges of the screen when the camera is moving. Setting this to 0.0 will immediately request all tiles in any given view.
     * [skipLevelOfDetail = false] - Optimization option. Determines if level of detail skipping should be applied during the traversal.
     * [baseScreenSpaceError = 1024] - When <code>skipLevelOfDetail</code> is <code>true</code>, the screen space error that must be reached before skipping levels of detail.
     * [skipScreenSpaceErrorFactor = 16] - When <code>skipLevelOfDetail</code> is <code>true</code>, a multiplier defining the minimum screen space error to skip. Used in conjunction with <code>skipLevels</code> to determine which tiles to load.
     * [skipLevels = 1] - When <code>skipLevelOfDetail</code> is <code>true</code>, a constant defining the minimum number of levels to skip when loading tiles. When it is 0, no levels are skipped. Used in conjunction with <code>skipScreenSpaceErrorFactor</code> to determine which tiles to load.
     * [immediatelyLoadDesiredLevelOfDetail = false] - When <code>skipLevelOfDetail</code> is <code>true</code>, only tiles that meet the maximum screen space error will ever be downloaded. Skipping factors are ignored and just the desired tiles are loaded.
     * [loadSiblings = false] - When <code>skipLevelOfDetail</code> is <code>true</code>, determines whether siblings of visible tiles are always downloaded during traversal.
     * [clippingPlanes] - The {@link ClippingPlaneCollection} used to selectively disable rendering the tileset.
     * [classificationType] - Determines whether terrain, 3D Tiles or both will be classified by this tileset. See {@link Cesium3DTileset#classificationType} for details about restrictions and limitations.
     * [ellipsoid = Ellipsoid.WGS84] - The ellipsoid determining the size and shape of the globe.
     * [pointCloudShading] - Options for constructing a {@link PointCloudShading} object to control point attenuation based on geometric error and lighting.
     * [lightColor] - The light color when shading models. When <code>undefined</code> the scene's light color is used instead.
     * [imageBasedLighting] - The properties for managing image-based lighting for this tileset.
     * [backFaceCulling = true] - Whether to cull back-facing geometry. When true, back face culling is determined by the glTF material's doubleSided property; when false, back face culling is disabled.
     * [enableShowOutline = true] - Whether to enable outlines for models using the {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/CESIUM_primitive_outline|CESIUM_primitive_outline} extension. This can be set to false to avoid the additional processing of geometry at load time. When false, the showOutlines and outlineColor options are ignored.
     * [showOutline = true] - Whether to display the outline for models using the {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/CESIUM_primitive_outline|CESIUM_primitive_outline} extension. When true, outlines are displayed. When false, outlines are not displayed.
     * [outlineColor = Color.BLACK] - The color to use when rendering outlines.
     * [vectorClassificationOnly = false] - Indicates that only the tileset's vector tiles should be used for classification.
     * [vectorKeepDecodedPositions = false] - Whether vector tiles should keep decoded positions in memory. This is used with {@link Cesium3DTileFeature.getPolylinePositions}.
     * [featureIdLabel = "featureId_0"] - Label of the feature ID set to use for picking and styling. For EXT_mesh_features, this is the feature ID's label property, or "featureId_N" (where N is the index in the featureIds array) when not specified. EXT_feature_metadata did not have a label field, so such feature ID sets are always labeled "featureId_N" where N is the index in the list of all feature Ids, where feature ID attributes are listed before feature ID textures. If featureIdLabel is an integer N, it is converted to the string "featureId_N" automatically. If both per-primitive and per-instance feature IDs are present, the instance feature IDs take priority.
     * [instanceFeatureIdLabel = "instanceFeatureId_0"] - Label of the instance feature ID set used for picking and styling. If instanceFeatureIdLabel is set to an integer N, it is converted to the string "instanceFeatureId_N" automatically. If both per-primitive and per-instance feature IDs are present, the instance feature IDs take priority.
     * [showCreditsOnScreen = false] - Whether to display the credits of this tileset on screen.
     * [splitDirection = SplitDirection.NONE] - The {@link SplitDirection} split to apply to this tileset.
     * [projectTo2D = false] - Whether to accurately project the tileset to 2D. If this is true, the tileset will be projected accurately to 2D, but it will use more memory to do so. If this is false, the tileset will use less memory and will still render in 2D / CV mode, but its projected positions may be inaccurate. This cannot be set after the tileset has loaded.
     * [debugHeatmapTilePropertyName] - The tile variable to colorize as a heatmap. All rendered tiles will be colorized relative to each other's specified variable value.
     * [debugFreezeFrame = false] - For debugging only. Determines if only the tiles from last frame should be used for rendering.
     * [debugColorizeTiles = false] - For debugging only. When true, assigns a random color to each tile.
     * [enableDebugWireframe] - For debugging only. This must be true for debugWireframe to work in WebGL1. This cannot be set after the tileset has loaded.
     * [debugWireframe = false] - For debugging only. When true, render's each tile's content as a wireframe.
     * [debugShowBoundingVolume = false] - For debugging only. When true, renders the bounding volume for each tile.
     * [debugShowContentBoundingVolume = false] - For debugging only. When true, renders the bounding volume for each tile's content.
     * [debugShowViewerRequestVolume = false] - For debugging only. When true, renders the viewer request volume for each tile.
     * [debugShowGeometricError = false] - For debugging only. When true, draws labels to indicate the geometric error of each tile.
     * [debugShowRenderingStatistics = false] - For debugging only. When true, draws labels to indicate the number of commands, points, triangles and features for each tile.
     * [debugShowMemoryUsage = false] - For debugging only. When true, draws labels to indicate the texture and geometry memory in megabytes used by each tile.
     * [debugShowUrl = false] - For debugging only. When true, draws labels to indicate the url of each tile.
     */
    type ConstructorOptions = {
        show?: boolean;
        modelMatrix?: Matrix4;
        modelUpAxis?: Axis;
        modelForwardAxis?: Axis;
        shadows?: ShadowMode;
        maximumScreenSpaceError?: number;
        cacheBytes?: number;
        maximumCacheOverflowBytes?: number;
        cullWithChildrenBounds?: boolean;
        cullRequestsWhileMoving?: boolean;
        cullRequestsWhileMovingMultiplier?: number;
        preloadWhenHidden?: boolean;
        preloadFlightDestinations?: boolean;
        preferLeaves?: boolean;
        dynamicScreenSpaceError?: boolean;
        dynamicScreenSpaceErrorDensity?: number;
        dynamicScreenSpaceErrorFactor?: number;
        dynamicScreenSpaceErrorHeightFalloff?: number;
        progressiveResolutionHeightFraction?: number;
        foveatedScreenSpaceError?: boolean;
        foveatedConeSize?: number;
        foveatedMinimumScreenSpaceErrorRelaxation?: number;
        foveatedInterpolationCallback?: Cesium3DTileset.foveatedInterpolationCallback;
        foveatedTimeDelay?: number;
        skipLevelOfDetail?: boolean;
        baseScreenSpaceError?: number;
        skipScreenSpaceErrorFactor?: number;
        skipLevels?: number;
        immediatelyLoadDesiredLevelOfDetail?: boolean;
        loadSiblings?: boolean;
        clippingPlanes?: ClippingPlaneCollection;
        classificationType?: ClassificationType;
        ellipsoid?: Ellipsoid;
        pointCloudShading?: any;
        lightColor?: Cartesian3;
        imageBasedLighting?: ImageBasedLighting;
        backFaceCulling?: boolean;
        enableShowOutline?: boolean;
        showOutline?: boolean;
        outlineColor?: Color;
        vectorClassificationOnly?: boolean;
        vectorKeepDecodedPositions?: boolean;
        featureIdLabel?: string | number;
        instanceFeatureIdLabel?: string | number;
        showCreditsOnScreen?: boolean;
        splitDirection?: SplitDirection;
        projectTo2D?: boolean;
        debugHeatmapTilePropertyName?: string;
        debugFreezeFrame?: boolean;
        debugColorizeTiles?: boolean;
        enableDebugWireframe?: boolean;
        debugWireframe?: boolean;
        debugShowBoundingVolume?: boolean;
        debugShowContentBoundingVolume?: boolean;
        debugShowViewerRequestVolume?: boolean;
        debugShowGeometricError?: boolean;
        debugShowRenderingStatistics?: boolean;
        debugShowMemoryUsage?: boolean;
        debugShowUrl?: boolean;
    };
    /**
     * Optimization option. Used as a callback when {@link Cesium3DTileset#foveatedScreenSpaceError} is true to control how much to raise the screen space error for tiles outside the foveated cone,
     * interpolating between {@link Cesium3DTileset#foveatedMinimumScreenSpaceErrorRelaxation} and {@link Cesium3DTileset#maximumScreenSpaceError}.
     * @param p - The start value to interpolate.
     * @param q - The end value to interpolate.
     * @param time - The time of interpolation generally in the range <code>[0.0, 1.0]</code>.
     */
    type foveatedInterpolationCallback = (p: number, q: number, time: number) => number;
}

/**
 * A {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification|3D Tiles tileset},
 * used for streaming massive heterogeneous 3D geospatial datasets.
 *
 * <div class="notice">
 * This object is normally not instantiated directly, use {@link Cesium3DTileset.fromUrl}.
 * </div>
 * @example
 * try {
 *   const tileset = await Cesium.Cesium3DTileset.fromUrl(
 *      "http://localhost:8002/tilesets/Seattle/tileset.json"
 *   );
 *   scene.primitives.add(tileset);
 * } catch (error) {
 *   console.error(`Error creating tileset: ${error}`);
 * }
 * @example
 * // Common setting for the skipLevelOfDetail optimization
 * const tileset = await Cesium.Cesium3DTileset.fromUrl(
 *   "http://localhost:8002/tilesets/Seattle/tileset.json", {
 *      skipLevelOfDetail: true,
 *      baseScreenSpaceError: 1024,
 *      skipScreenSpaceErrorFactor: 16,
 *      skipLevels: 1,
 *      immediatelyLoadDesiredLevelOfDetail: false,
 *      loadSiblings: false,
 *      cullWithChildrenBounds: true
 * });
 * scene.primitives.add(tileset);
 * @example
 * // Common settings for the dynamicScreenSpaceError optimization
 * const tileset = await Cesium.Cesium3DTileset.fromUrl(
 *   "http://localhost:8002/tilesets/Seattle/tileset.json", {
 *      dynamicScreenSpaceError: true,
 *      dynamicScreenSpaceErrorDensity: 0.00278,
 *      dynamicScreenSpaceErrorFactor: 4.0,
 *      dynamicScreenSpaceErrorHeightFalloff: 0.25
 * });
 * scene.primitives.add(tileset);
 * @param options - An object describing initialization options
 */
export class Cesium3DTileset {
    constructor(options: Cesium3DTileset.ConstructorOptions);
    /**
     * Optimization option. Don't request tiles that will likely be unused when they come back because of the camera's movement. This optimization only applies to stationary tilesets.
     */
    cullRequestsWhileMoving: boolean;
    /**
     * Optimization option. Multiplier used in culling requests while moving. Larger is more aggressive culling, smaller less aggressive culling.
     */
    cullRequestsWhileMovingMultiplier: number;
    /**
     * Optimization option. If between (0.0, 0.5], tiles at or above the screen space error for the reduced screen resolution of <code>progressiveResolutionHeightFraction*screenHeight</code> will be prioritized first. This can help get a quick layer of tiles down while full resolution tiles continue to load.
     */
    progressiveResolutionHeightFraction: number;
    /**
     * Optimization option. Prefer loading of leaves first.
     */
    preferLeaves: boolean;
    /**
     * Preload tiles when <code>tileset.show</code> is <code>false</code>. Loads tiles as if the tileset is visible but does not render them.
     */
    preloadWhenHidden: boolean;
    /**
     * Optimization option. Fetch tiles at the camera's flight destination while the camera is in flight.
     */
    preloadFlightDestinations: boolean;
    /**
     * Optimization option. Whether the tileset should refine based on a dynamic screen space error. Tiles that are further
     * away will be rendered with lower detail than closer tiles. This improves performance by rendering fewer
     * tiles and making less requests, but may result in a slight drop in visual quality for tiles in the distance.
     * The algorithm is biased towards "street views" where the camera is close to the ground plane of the tileset and looking
     * at the horizon. In addition results are more accurate for tightly fitting bounding volumes like box and region.
     */
    dynamicScreenSpaceError: boolean;
    /**
     * Optimization option. Prioritize loading tiles in the center of the screen by temporarily raising the
     * screen space error for tiles around the edge of the screen. Screen space error returns to normal once all
     * the tiles in the center of the screen as determined by the {@link Cesium3DTileset#foveatedConeSize} are loaded.
     */
    foveatedScreenSpaceError: boolean;
    /**
     * Gets or sets a callback to control how much to raise the screen space error for tiles outside the foveated cone,
     * interpolating between {@link Cesium3DTileset#foveatedMinimumScreenSpaceErrorRelaxation} and {@link Cesium3DTileset#maximumScreenSpaceError}.
     */
    foveatedInterpolationCallback: Cesium3DTileset.foveatedInterpolationCallback;
    /**
     * Optimization option. Used when {@link Cesium3DTileset#foveatedScreenSpaceError} is true to control
     * how long in seconds to wait after the camera stops moving before deferred tiles start loading in.
     * This time delay prevents requesting tiles around the edges of the screen when the camera is moving.
     * Setting this to 0.0 will immediately request all tiles in any given view.
     */
    foveatedTimeDelay: number;
    /**
     * A scalar that determines the density used to adjust the dynamic screen space error, similar to {@link Fog}. Increasing this
     * value has the effect of increasing the maximum screen space error for all tiles, but in a non-linear fashion.
     * The error starts at 0.0 and increases exponentially until a midpoint is reached, and then approaches 1.0 asymptotically.
     * This has the effect of keeping high detail in the closer tiles and lower detail in the further tiles, with all tiles
     * beyond a certain distance all roughly having an error of 1.0.
     * <p>
     * The dynamic error is in the range [0.0, 1.0) and is multiplied by <code>dynamicScreenSpaceErrorFactor</code> to produce the
     * final dynamic error. This dynamic error is then subtracted from the tile's actual screen space error.
     * </p>
     * <p>
     * Increasing <code>dynamicScreenSpaceErrorDensity</code> has the effect of moving the error midpoint closer to the camera.
     * It is analogous to moving fog closer to the camera.
     * </p>
     */
    dynamicScreenSpaceErrorDensity: number;
    /**
     * A factor used to increase the screen space error of tiles for dynamic screen space error. As this value increases less tiles
     * are requested for rendering and tiles in the distance will have lower detail. If set to zero, the feature will be disabled.
     */
    dynamicScreenSpaceErrorFactor: number;
    /**
     * A ratio of the tileset's height at which the density starts to falloff. If the camera is below this height the
     * full computed density is applied, otherwise the density falls off. This has the effect of higher density at
     * street level views.
     * <p>
     * Valid values are between 0.0 and 1.0.
     * </p>
     */
    dynamicScreenSpaceErrorHeightFalloff: number;
    /**
     * Determines whether the tileset casts or receives shadows from light sources.
     * <p>
     * Enabling shadows has a performance impact. A tileset that casts shadows must be rendered twice, once from the camera and again from the light's point of view.
     * </p>
     * <p>
     * Shadows are rendered only when {@link Viewer#shadows} is <code>true</code>.
     * </p>
     */
    shadows: ShadowMode;
    /**
     * Determines if the tileset will be shown.
     */
    show: boolean;
    /**
     * Defines how per-feature colors set from the Cesium API or declarative styling blend with the source colors from
     * the original feature, e.g. glTF material or per-point color in the tile.
     */
    colorBlendMode: Cesium3DTileColorBlendMode;
    /**
     * Defines the value used to linearly interpolate between the source color and feature color when the {@link Cesium3DTileset#colorBlendMode} is <code>MIX</code>.
     * A value of 0.0 results in the source color while a value of 1.0 results in the feature color, with any value in-between
     * resulting in a mix of the source color and feature color.
     */
    colorBlendAmount: number;
    /**
     * The event fired to indicate progress of loading new tiles.  This event is fired when a new tile
     * is requested, when a requested tile is finished downloading, and when a downloaded tile has been
     * processed and is ready to render.
     * <p>
     * The number of pending tile requests, <code>numberOfPendingRequests</code>, and number of tiles
     * processing, <code>numberOfTilesProcessing</code> are passed to the event listener.
     * </p>
     * <p>
     * This event is fired at the end of the frame after the scene is rendered.
     * </p>
     * @example
     * tileset.loadProgress.addEventListener(function(numberOfPendingRequests, numberOfTilesProcessing) {
     *     if ((numberOfPendingRequests === 0) && (numberOfTilesProcessing === 0)) {
     *         console.log('Stopped loading');
     *         return;
     *     }
     *
     *     console.log(`Loading: requests: ${numberOfPendingRequests}, processing: ${numberOfTilesProcessing}`);
     * });
     */
    loadProgress: Event;
    /**
     * The event fired to indicate that all tiles that meet the screen space error this frame are loaded. The tileset
     * is completely loaded for this view.
     * <p>
     * This event is fired at the end of the frame after the scene is rendered.
     * </p>
     * @example
     * tileset.allTilesLoaded.addEventListener(function() {
     *     console.log('All tiles are loaded');
     * });
     */
    allTilesLoaded: Event;
    /**
     * The event fired to indicate that all tiles that meet the screen space error this frame are loaded. This event
     * is fired once when all tiles in the initial view are loaded.
     * <p>
     * This event is fired at the end of the frame after the scene is rendered.
     * </p>
     * @example
     * tileset.initialTilesLoaded.addEventListener(function() {
     *     console.log('Initial tiles are loaded');
     * });
     */
    initialTilesLoaded: Event;
    /**
     * The event fired to indicate that a tile's content was loaded.
     * <p>
     * The loaded {@link Cesium3DTile} is passed to the event listener.
     * </p>
     * <p>
     * This event is fired during the tileset traversal while the frame is being rendered
     * so that updates to the tile take effect in the same frame.  Do not create or modify
     * Cesium entities or primitives during the event listener.
     * </p>
     * @example
     * tileset.tileLoad.addEventListener(function(tile) {
     *     console.log('A tile was loaded.');
     * });
     */
    tileLoad: Event;
    /**
     * The event fired to indicate that a tile's content was unloaded.
     * <p>
     * The unloaded {@link Cesium3DTile} is passed to the event listener.
     * </p>
     * <p>
     * This event is fired immediately before the tile's content is unloaded while the frame is being
     * rendered so that the event listener has access to the tile's content.  Do not create
     * or modify Cesium entities or primitives during the event listener.
     * </p>
     * @example
     * tileset.tileUnload.addEventListener(function(tile) {
     *     console.log('A tile was unloaded from the cache.');
     * });
     */
    tileUnload: Event;
    /**
     * The event fired to indicate that a tile's content failed to load.
     * <p>
     * If there are no event listeners, error messages will be logged to the console.
     * </p>
     * <p>
     * The error object passed to the listener contains two properties:
     * <ul>
     * <li><code>url</code>: the url of the failed tile.</li>
     * <li><code>message</code>: the error message.</li>
     * </ul>
     * <p>
     * If multiple contents are present, this event is raised once per inner content with errors.
     * </p>
     * @example
     * tileset.tileFailed.addEventListener(function(error) {
     *     console.log(`An error occurred loading tile: ${error.url}`);
     *     console.log(`Error: ${error.message}`);
     * });
     */
    tileFailed: Event;
    /**
     * This event fires once for each visible tile in a frame.  This can be used to manually
     * style a tileset.
     * <p>
     * The visible {@link Cesium3DTile} is passed to the event listener.
     * </p>
     * <p>
     * This event is fired during the tileset traversal while the frame is being rendered
     * so that updates to the tile take effect in the same frame.  Do not create or modify
     * Cesium entities or primitives during the event listener.
     * </p>
     * @example
     * tileset.tileVisible.addEventListener(function(tile) {
     *     if (tile.content instanceof Cesium.Model3DTileContent) {
     *         console.log('A 3D model tile is visible.');
     *     }
     * });
     * @example
     * // Apply a red style and then manually set random colors for every other feature when the tile becomes visible.
     * tileset.style = new Cesium.Cesium3DTileStyle({
     *     color : 'color("red")'
     * });
     * tileset.tileVisible.addEventListener(function(tile) {
     *     const content = tile.content;
     *     const featuresLength = content.featuresLength;
     *     for (let i = 0; i < featuresLength; i+=2) {
     *         content.getFeature(i).color = Cesium.Color.fromRandom();
     *     }
     * });
     */
    tileVisible: Event;
    /**
     * Optimization option. Determines if level of detail skipping should be applied during the traversal.
     * <p>
     * The common strategy for replacement-refinement traversal is to store all levels of the tree in memory and require
     * all children to be loaded before the parent can refine. With this optimization levels of the tree can be skipped
     * entirely and children can be rendered alongside their parents. The tileset requires significantly less memory when
     * using this optimization.
     * </p>
     */
    skipLevelOfDetail: boolean;
    /**
     * The screen space error that must be reached before skipping levels of detail.
     * <p>
     * Only used when {@link Cesium3DTileset#skipLevelOfDetail} is <code>true</code>.
     * </p>
     */
    baseScreenSpaceError: number;
    /**
     * Multiplier defining the minimum screen space error to skip.
     * For example, if a tile has screen space error of 100, no tiles will be loaded unless they
     * are leaves or have a screen space error <code><= 100 / skipScreenSpaceErrorFactor</code>.
     * <p>
     * Only used when {@link Cesium3DTileset#skipLevelOfDetail} is <code>true</code>.
     * </p>
     */
    skipScreenSpaceErrorFactor: number;
    /**
     * Constant defining the minimum number of levels to skip when loading tiles. When it is 0, no levels are skipped.
     * For example, if a tile is level 1, no tiles will be loaded unless they are at level greater than 2.
     * <p>
     * Only used when {@link Cesium3DTileset#skipLevelOfDetail} is <code>true</code>.
     * </p>
     */
    skipLevels: number;
    /**
     * When true, only tiles that meet the maximum screen space error will ever be downloaded.
     * Skipping factors are ignored and just the desired tiles are loaded.
     * <p>
     * Only used when {@link Cesium3DTileset#skipLevelOfDetail} is <code>true</code>.
     * </p>
     */
    immediatelyLoadDesiredLevelOfDetail: boolean;
    /**
     * Determines whether siblings of visible tiles are always downloaded during traversal.
     * This may be useful for ensuring that tiles are already available when the viewer turns left/right.
     * <p>
     * Only used when {@link Cesium3DTileset#skipLevelOfDetail} is <code>true</code>.
     * </p>
     */
    loadSiblings: boolean;
    /**
     * The light color when shading models. When <code>undefined</code> the scene's light color is used instead.
     * <p>
     * For example, disabling additional light sources by setting
     * <code>tileset.imageBasedLighting.imageBasedLightingFactor = new Cartesian2(0.0, 0.0)</code>
     * will make the tileset much darker. Here, increasing the intensity of the light source will make the tileset brighter.
     * </p>
     */
    lightColor: Cartesian3;
    /**
     * Whether to cull back-facing geometry. When true, back face culling is determined
     * by the glTF material's doubleSided property; when false, back face culling is disabled.
     */
    backFaceCulling: boolean;
    /**
     * Whether to display the outline for models using the
     * {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/CESIUM_primitive_outline|CESIUM_primitive_outline} extension.
     * When true, outlines are displayed. When false, outlines are not displayed.
     */
    showOutline: boolean;
    /**
     * The color to use when rendering outlines.
     */
    outlineColor: Color;
    /**
     * The {@link SplitDirection} to apply to this tileset.
     */
    splitDirection: SplitDirection;
    /**
     * This property is for debugging only; it is not optimized for production use.
     * <p>
     * Determines if only the tiles from last frame should be used for rendering.  This
     * effectively "freezes" the tileset to the previous frame so it is possible to zoom
     * out and see what was rendered.
     * </p>
     */
    debugFreezeFrame: boolean;
    /**
     * This property is for debugging only; it is not optimized for production use.
     * <p>
     * When true, assigns a random color to each tile.  This is useful for visualizing
     * what features belong to what tiles, especially with additive refinement where features
     * from parent tiles may be interleaved with features from child tiles.
     * </p>
     */
    debugColorizeTiles: boolean;
    /**
     * This property is for debugging only; it is not optimized for production use.
     * <p>
     * When true, renders each tile's content as a wireframe.
     * </p>
     */
    debugWireframe: boolean;
    /**
     * This property is for debugging only; it is not optimized for production use.
     * <p>
     * When true, renders the bounding volume for each visible tile.  The bounding volume is
     * white if the tile has a content bounding volume or is empty; otherwise, it is red.  Tiles that don't meet the
     * screen space error and are still refining to their descendants are yellow.
     * </p>
     */
    debugShowBoundingVolume: boolean;
    /**
     * This property is for debugging only; it is not optimized for production use.
     * <p>
     * When true, renders the bounding volume for each visible tile's content. The bounding volume is
     * blue if the tile has a content bounding volume; otherwise it is red.
     * </p>
     */
    debugShowContentBoundingVolume: boolean;
    /**
     * This property is for debugging only; it is not optimized for production use.
     * <p>
     * When true, renders the viewer request volume for each tile.
     * </p>
     */
    debugShowViewerRequestVolume: boolean;
    /**
     * This property is for debugging only; it is not optimized for production use.
     * <p>
     * When true, draws labels to indicate the geometric error of each tile.
     * </p>
     */
    debugShowGeometricError: boolean;
    /**
     * This property is for debugging only; it is not optimized for production use.
     * <p>
     * When true, draws labels to indicate the number of commands, points, triangles and features of each tile.
     * </p>
     */
    debugShowRenderingStatistics: boolean;
    /**
     * This property is for debugging only; it is not optimized for production use.
     * <p>
     * When true, draws labels to indicate the geometry and texture memory usage of each tile.
     * </p>
     */
    debugShowMemoryUsage: boolean;
    /**
     * This property is for debugging only; it is not optimized for production use.
     * <p>
     * When true, draws labels to indicate the url of each tile.
     * </p>
     */
    debugShowUrl: boolean;
    /**
     * Function for examining vector lines as they are being streamed.
     */
    examineVectorLinesFunction: (...params: any[]) => any;
    /**
     * Gets the tileset's asset object property, which contains metadata about the tileset.
     * <p>
     * See the {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification#reference-asset|asset schema reference}
     * in the 3D Tiles spec for the full set of properties.
     * </p>
     */
    readonly asset: any;
    /**
     * Gets the tileset's extensions object property.
     */
    readonly extensions: any;
    /**
     * The {@link ClippingPlaneCollection} used to selectively disable rendering the tileset.
     */
    clippingPlanes: ClippingPlaneCollection;
    /**
     * Gets the tileset's properties dictionary object, which contains metadata about per-feature properties.
     * <p>
     * See the {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification#reference-properties|properties schema reference}
     * in the 3D Tiles spec for the full set of properties.
     * </p>
     * @example
     * console.log(`Maximum building height: ${tileset.properties.height.maximum}`);
     * console.log(`Minimum building height: ${tileset.properties.height.minimum}`);
     */
    readonly properties: any;
    /**
     * When <code>true</code>, all tiles that meet the screen space error this frame are loaded. The tileset is
     * completely loaded for this view.
     */
    readonly tilesLoaded: boolean;
    /**
     * The resource used to fetch the tileset JSON file
     */
    readonly resource: Resource;
    /**
     * The base path that non-absolute paths in tileset JSON file are relative to.
     */
    readonly basePath: string;
    /**
     * The style, defined using the
     * {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Styling|3D Tiles Styling language},
     * applied to each feature in the tileset.
     * <p>
     * Assign <code>undefined</code> to remove the style, which will restore the visual
     * appearance of the tileset to its default when no style was applied.
     * </p>
     * <p>
     * The style is applied to a tile before the {@link Cesium3DTileset#tileVisible}
     * event is raised, so code in <code>tileVisible</code> can manually set a feature's
     * properties (e.g. color and show) after the style is applied. When
     * a new style is assigned any manually set properties are overwritten.
     * </p>
     * <p>
     * Use an always "true" condition to specify the Color for all objects that are not
     * overridden by pre-existing conditions. Otherwise, the default color Cesium.Color.White
     * will be used. Similarly, use an always "true" condition to specify the show property
     * for all objects that are not overridden by pre-existing conditions. Otherwise, the
     * default show value true will be used.
     * </p>
     * @example
     * tileset.style = new Cesium.Cesium3DTileStyle({
     *    color : {
     *        conditions : [
     *            ['${Height} >= 100', 'color("purple", 0.5)'],
     *            ['${Height} >= 50', 'color("red")'],
     *            ['true', 'color("blue")']
     *        ]
     *    },
     *    show : '${Height} > 0',
     *    meta : {
     *        description : '"Building id ${id} has height ${Height}."'
     *    }
     * });
     */
    style: Cesium3DTileStyle | undefined;
    /**
     * A custom shader to apply to all tiles in the tileset. Only used for
     * contents that use {@link Model}. Using custom shaders with a
     * {@link Cesium3DTileStyle} may lead to undefined behavior.
     */
    customShader: CustomShader | undefined;
    /**
     * The maximum screen space error used to drive level of detail refinement.  This value helps determine when a tile
     * refines to its descendants, and therefore plays a major role in balancing performance with visual quality.
     * <p>
     * A tile's screen space error is roughly equivalent to the number of pixels wide that would be drawn if a sphere with a
     * radius equal to the tile's <b>geometric error</b> were rendered at the tile's position. If this value exceeds
     * <code>maximumScreenSpaceError</code> the tile refines to its descendants.
     * </p>
     * <p>
     * Depending on the tileset, <code>maximumScreenSpaceError</code> may need to be tweaked to achieve the right balance.
     * Higher values provide better performance but lower visual quality.
     * </p>
     */
    maximumScreenSpaceError: number;
    /**
     * The amount of GPU memory (in bytes) used to cache tiles. This memory usage is estimated from
     * geometry, textures, and batch table textures of loaded tiles. For point clouds, this value also
     * includes per-point metadata.
     * <p>
     * Tiles not in view are unloaded to enforce this.
     * </p>
     * <p>
     * If decreasing this value results in unloading tiles, the tiles are unloaded the next frame.
     * </p>
     * <p>
     * If tiles sized more than <code>cacheBytes</code> are needed to meet the
     * desired screen space error, determined by {@link Cesium3DTileset#maximumScreenSpaceError},
     * for the current view, then the memory usage of the tiles loaded will exceed
     * <code>cacheBytes</code> by up to <code>maximumCacheOverflowBytes</code>.
     * For example, if <code>cacheBytes</code> is 500000, but 600000 bytes
     * of tiles are needed to meet the screen space error, then 600000 bytes of tiles
     * may be loaded (if <code>maximumCacheOverflowBytes</code> is at least 100000).
     * When these tiles go out of view, they will be unloaded.
     * </p>
     */
    cacheBytes: number;
    /**
     * The maximum additional amount of GPU memory (in bytes) that will be used to cache tiles.
     * <p>
     * If tiles sized more than <code>cacheBytes</code> plus <code>maximumCacheOverflowBytes</code>
     * are needed to meet the desired screen space error, determined by
     * {@link Cesium3DTileset#maximumScreenSpaceError} for the current view, then
     * {@link Cesium3DTileset#memoryAdjustedScreenSpaceError} will be adjusted
     * until the tiles required to meet the adjusted screen space error use less
     * than <code>cacheBytes</code> plus <code>maximumCacheOverflowBytes</code>.
     * </p>
     */
    maximumCacheOverflowBytes: number;
    /**
     * Options for controlling point size based on geometric error and eye dome lighting.
     */
    pointCloudShading: PointCloudShading;
    /**
     * The root tile.
     */
    readonly root: Cesium3DTile;
    /**
     * The tileset's bounding sphere.
     * @example
     * const tileset = await Cesium.Cesium3DTileset.fromUrl("http://localhost:8002/tilesets/Seattle/tileset.json");
     *
     * viewer.scene.primitives.add(tileset);
     *
     * // Set the camera to view the newly added tileset
     * viewer.camera.viewBoundingSphere(tileset.boundingSphere, new Cesium.HeadingPitchRange(0, -0.5, 0));
     */
    readonly boundingSphere: BoundingSphere;
    /**
     * A 4x4 transformation matrix that transforms the entire tileset.
     * @example
     * // Adjust a tileset's height from the globe's surface.
     * const heightOffset = 20.0;
     * const boundingSphere = tileset.boundingSphere;
     * const cartographic = Cesium.Cartographic.fromCartesian(boundingSphere.center);
     * const surface = Cesium.Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, 0.0);
     * const offset = Cesium.Cartesian3.fromRadians(cartographic.longitude, cartographic.latitude, heightOffset);
     * const translation = Cesium.Cartesian3.subtract(offset, surface, new Cesium.Cartesian3());
     * tileset.modelMatrix = Cesium.Matrix4.fromTranslation(translation);
     */
    modelMatrix: Matrix4;
    /**
     * Returns the time, in milliseconds, since the tileset was loaded and first updated.
     */
    readonly timeSinceLoad: number;
    /**
     * The total amount of GPU memory in bytes used by the tileset. This value is estimated from
     * geometry, texture, batch table textures, and binary metadata of loaded tiles.
     */
    readonly totalMemoryUsageInBytes: number;
    /**
     * Determines whether terrain, 3D Tiles, or both will be classified by this tileset.
     * <p>
     * This option is only applied to tilesets containing batched 3D models,
     * glTF content, geometry data, or vector data. Even when undefined, vector
     * and geometry data must render as classifications and will default to
     * rendering on both terrain and other 3D Tiles tilesets.
     * </p>
     * <p>
     * When enabled for batched 3D model and glTF tilesets, there are a few
     * requirements/limitations on the glTF:
     * <ul>
     *     <li>The glTF cannot contain morph targets, skins, or animations.</li>
     *     <li>The glTF cannot contain the <code>EXT_mesh_gpu_instancing</code> extension.</li>
     *     <li>Only meshes with TRIANGLES can be used to classify other assets.</li>
     *     <li>The <code>POSITION</code> semantic is required.</li>
     *     <li>If <code>_BATCHID</code>s and an index buffer are both present, all indices with the same batch id must occupy contiguous sections of the index buffer.</li>
     *     <li>If <code>_BATCHID</code>s are present with no index buffer, all positions with the same batch id must occupy contiguous sections of the position buffer.</li>
     * </ul>
     * </p>
     * <p>
     * Additionally, classification is not supported for points or instanced 3D
     * models.
     * </p>
     */
    readonly classificationType: ClassificationType;
    /**
     * Gets an ellipsoid describing the shape of the globe.
     */
    readonly ellipsoid: Ellipsoid;
    /**
     * Optimization option. Used when {@link Cesium3DTileset#foveatedScreenSpaceError} is true to control the cone size that determines which tiles are deferred.
     * Tiles that are inside this cone are loaded immediately. Tiles outside the cone are potentially deferred based on how far outside the cone they are and {@link Cesium3DTileset#foveatedInterpolationCallback} and {@link Cesium3DTileset#foveatedMinimumScreenSpaceErrorRelaxation}.
     * Setting this to 0.0 means the cone will be the line formed by the camera position and its view direction. Setting this to 1.0 means the cone encompasses the entire field of view of the camera, essentially disabling the effect.
     */
    foveatedConeSize: number;
    /**
     * Optimization option. Used when {@link Cesium3DTileset#foveatedScreenSpaceError} is true to control the starting screen space error relaxation for tiles outside the foveated cone.
     * The screen space error will be raised starting with this value up to {@link Cesium3DTileset#maximumScreenSpaceError} based on the provided {@link Cesium3DTileset#foveatedInterpolationCallback}.
     */
    foveatedMinimumScreenSpaceErrorRelaxation: number;
    /**
     * Returns the <code>extras</code> property at the top-level of the tileset JSON, which contains application specific metadata.
     * Returns <code>undefined</code> if <code>extras</code> does not exist.
     */
    readonly extras: any;
    /**
     * The properties for managing image-based lighting on this tileset.
     */
    imageBasedLighting: ImageBasedLighting;
    /**
     * Indicates that only the tileset's vector tiles should be used for classification.
     */
    vectorClassificationOnly: boolean;
    /**
     * Whether vector tiles should keep decoded positions in memory.
     * This is used with {@link Cesium3DTileFeature.getPolylinePositions}.
     */
    vectorKeepDecodedPositions: boolean;
    /**
     * Determines whether the credits of the tileset will be displayed on the screen
     */
    showCreditsOnScreen: boolean;
    /**
     * Label of the feature ID set to use for picking and styling.
     * <p>
     * For EXT_mesh_features, this is the feature ID's label property, or
     * "featureId_N" (where N is the index in the featureIds array) when not
     * specified. EXT_feature_metadata did not have a label field, so such
     * feature ID sets are always labeled "featureId_N" where N is the index in
     * the list of all feature Ids, where feature ID attributes are listed before
     * feature ID textures.
     * </p>
     * <p>
     * If featureIdLabel is set to an integer N, it is converted to
     * the string "featureId_N" automatically. If both per-primitive and
     * per-instance feature IDs are present, the instance feature IDs take
     * priority.
     * </p>
     */
    featureIdLabel: string;
    /**
     * Label of the instance feature ID set used for picking and styling.
     * <p>
     * If instanceFeatureIdLabel is set to an integer N, it is converted to
     * the string "instanceFeatureId_N" automatically.
     * If both per-primitive and per-instance feature IDs are present, the
     * instance feature IDs take priority.
     * </p>
     */
    instanceFeatureIdLabel: string;
    /**
     * Creates a {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification|3D Tiles tileset},
     * used for streaming massive heterogeneous 3D geospatial datasets, from a Cesium ion asset ID.
     * @example
     * // Load a Cesium3DTileset with a Cesium ion asset ID of 124624234
     * try {
     *   const tileset = await Cesium.Cesium3DTileset.fromIonAssetId(124624234);
     *   scene.primitives.add(tileset);
     * } catch (error) {
     *   console.error(`Error creating tileset: ${error}`);
     * }
     * @param assetId - The Cesium ion asset id.
     * @param options - An object describing initialization options
     */
    static fromIonAssetId(assetId: number, options: Cesium3DTileset.ConstructorOptions): Promise<Cesium3DTileset>;
    /**
     * Creates a {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification|3D Tiles tileset},
     * used for streaming massive heterogeneous 3D geospatial datasets.
     * @example
     * try {
     *   const tileset = await Cesium.Cesium3DTileset.fromUrl(
     *      "http://localhost:8002/tilesets/Seattle/tileset.json"
     *   );
     *   scene.primitives.add(tileset);
     * } catch (error) {
     *   console.error(`Error creating tileset: ${error}`);
     * }
     * @example
     * // Common setting for the skipLevelOfDetail optimization
     * const tileset = await Cesium.Cesium3DTileset.fromUrl(
     *   "http://localhost:8002/tilesets/Seattle/tileset.json", {
     *      skipLevelOfDetail: true,
     *      baseScreenSpaceError: 1024,
     *      skipScreenSpaceErrorFactor: 16,
     *      skipLevels: 1,
     *      immediatelyLoadDesiredLevelOfDetail: false,
     *      loadSiblings: false,
     *      cullWithChildrenBounds: true
     * });
     * scene.primitives.add(tileset);
     * @example
     * // Common settings for the dynamicScreenSpaceError optimization
     * const tileset = await Cesium.Cesium3DTileset.fromUrl(
     *   "http://localhost:8002/tilesets/Seattle/tileset.json", {
     *      dynamicScreenSpaceError: true,
     *      dynamicScreenSpaceErrorDensity: 0.00278,
     *      dynamicScreenSpaceErrorFactor: 4.0,
     *      dynamicScreenSpaceErrorHeightFalloff: 0.25
     * });
     * scene.primitives.add(tileset);
     * @param url - The url to a tileset JSON file.
     * @param [options] - An object describing initialization options
     */
    static fromUrl(url: Resource | string, options?: Cesium3DTileset.ConstructorOptions): Promise<Cesium3DTileset>;
    /**
     * Provides a hook to override the method used to request the tileset json
     * useful when fetching tilesets from remote servers
     * @param tilesetUrl - The url of the json file to be fetched
     * @returns A promise that resolves with the fetched json data
     */
    static loadJson(tilesetUrl: Resource | string): Promise<object>;
    /**
     * Marks the tileset's {@link Cesium3DTileset#style} as dirty, which forces all
     * features to re-evaluate the style in the next frame each is visible.
     */
    makeStyleDirty(): void;
    /**
     * Unloads all tiles that weren't selected the previous frame.  This can be used to
     * explicitly manage the tile cache and reduce the total number of tiles loaded below
     * {@link Cesium3DTileset#cacheBytes}.
     * <p>
     * Tile unloads occur at the next frame to keep all the WebGL delete calls
     * within the render loop.
     * </p>
     */
    trimLoadedTiles(): void;
    /**
     * <code>true</code> if the tileset JSON file lists the extension in extensionsUsed; otherwise, <code>false</code>.
     * @param extensionName - The name of the extension to check.
     * @returns <code>true</code> if the tileset JSON file lists the extension in extensionsUsed; otherwise, <code>false</code>.
     */
    hasExtension(extensionName: string): boolean;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     * @example
     * tileset = tileset && tileset.destroy();
     */
    destroy(): void;
}

/**
 * A ParticleEmitter that emits particles from a circle.
 * Particles will be positioned within a circle and have initial velocities going along the z vector.
 * @param [radius = 1.0] - The radius of the circle in meters.
 */
export class CircleEmitter {
    constructor(radius?: number);
    /**
     * The radius of the circle in meters.
     */
    radius: number;
    /**
     * The angle of the cone in radians.
     */
    angle: number;
}

/**
 * A classification primitive represents a volume enclosing geometry in the {@link Scene} to be highlighted.
 * <p>
 * A primitive combines geometry instances with an {@link Appearance} that describes the full shading, including
 * {@link Material} and {@link RenderState}.  Roughly, the geometry instance defines the structure and placement,
 * and the appearance defines the visual characteristics.  Decoupling geometry and appearance allows us to mix
 * and match most of them and add a new geometry or appearance independently of each other.
 * Only {@link PerInstanceColorAppearance} with the same color across all instances is supported at this time when using
 * ClassificationPrimitive directly.
 * For full {@link Appearance} support when classifying terrain or 3D Tiles use {@link GroundPrimitive} instead.
 * </p>
 * <p>
 * For correct rendering, this feature requires the EXT_frag_depth WebGL extension. For hardware that do not support this extension, there
 * will be rendering artifacts for some viewing angles.
 * </p>
 * <p>
 * Valid geometries are {@link BoxGeometry}, {@link CylinderGeometry}, {@link EllipsoidGeometry}, {@link PolylineVolumeGeometry}, and {@link SphereGeometry}.
 * </p>
 * <p>
 * Geometries that follow the surface of the ellipsoid, such as {@link CircleGeometry}, {@link CorridorGeometry}, {@link EllipseGeometry}, {@link PolygonGeometry}, and {@link RectangleGeometry},
 * are also valid if they are extruded volumes; otherwise, they will not be rendered.
 * </p>
 * @param [options] - Object with the following properties:
 * @param [options.geometryInstances] - The geometry instances to render. This can either be a single instance or an array of length one.
 * @param [options.appearance] - The appearance used to render the primitive. Defaults to PerInstanceColorAppearance when GeometryInstances have a color attribute.
 * @param [options.show = true] - Determines if this primitive will be shown.
 * @param [options.vertexCacheOptimize = false] - When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.
 * @param [options.interleave = false] - When <code>true</code>, geometry vertex attributes are interleaved, which can slightly improve rendering performance but increases load time.
 * @param [options.compressVertices = true] - When <code>true</code>, the geometry vertices are compressed, which will save memory.
 * @param [options.releaseGeometryInstances = true] - When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.
 * @param [options.allowPicking = true] - When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.
 * @param [options.asynchronous = true] - Determines if the primitive will be created asynchronously or block until ready. If false initializeTerrainHeights() must be called first.
 * @param [options.classificationType = ClassificationType.BOTH] - Determines whether terrain, 3D Tiles or both will be classified.
 * @param [options.debugShowBoundingVolume = false] - For debugging only. Determines if this primitive's commands' bounding spheres are shown.
 * @param [options.debugShowShadowVolume = false] - For debugging only. Determines if the shadow volume for each geometry in the primitive is drawn. Must be <code>true</code> on
 *                  creation for the volumes to be created before the geometry is released or options.releaseGeometryInstance must be <code>false</code>.
 */
export class ClassificationPrimitive {
    constructor(options?: {
        geometryInstances?: any[] | GeometryInstance;
        appearance?: Appearance;
        show?: boolean;
        vertexCacheOptimize?: boolean;
        interleave?: boolean;
        compressVertices?: boolean;
        releaseGeometryInstances?: boolean;
        allowPicking?: boolean;
        asynchronous?: boolean;
        classificationType?: ClassificationType;
        debugShowBoundingVolume?: boolean;
        debugShowShadowVolume?: boolean;
    });
    /**
     * The geometry instance rendered with this primitive.  This may
     * be <code>undefined</code> if <code>options.releaseGeometryInstances</code>
     * is <code>true</code> when the primitive is constructed.
     * <p>
     * Changing this property after the primitive is rendered has no effect.
     * </p>
     * <p>
     * Because of the rendering technique used, all geometry instances must be the same color.
     * If there is an instance with a differing color, a <code>DeveloperError</code> will be thrown
     * on the first attempt to render.
     * </p>
     */
    readonly geometryInstances: any[] | GeometryInstance;
    /**
     * Determines if the primitive will be shown.  This affects all geometry
     * instances in the primitive.
     */
    show: boolean;
    /**
     * Determines whether terrain, 3D Tiles or both will be classified.
     */
    classificationType: ClassificationType;
    /**
     * This property is for debugging only; it is not for production use nor is it optimized.
     * <p>
     * Draws the bounding sphere for each draw command in the primitive.
     * </p>
     */
    debugShowBoundingVolume: boolean;
    /**
     * This property is for debugging only; it is not for production use nor is it optimized.
     * <p>
     * Draws the shadow volume for each geometry in the primitive.
     * </p>
     */
    debugShowShadowVolume: boolean;
    /**
     * When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.
     */
    readonly vertexCacheOptimize: boolean;
    /**
     * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.
     */
    readonly interleave: boolean;
    /**
     * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.
     */
    readonly releaseGeometryInstances: boolean;
    /**
     * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.
     */
    readonly allowPicking: boolean;
    /**
     * Determines if the geometry instances will be created and batched on a web worker.
     */
    readonly asynchronous: boolean;
    /**
     * When <code>true</code>, geometry vertices are compressed, which will save memory.
     */
    readonly compressVertices: boolean;
    /**
     * Determines if the primitive is complete and ready to render.  If this property is
     * true, the primitive will be rendered the next time that {@link ClassificationPrimitive#update}
     * is called.
     */
    readonly ready: boolean;
    /**
     * Determines if ClassificationPrimitive rendering is supported.
     * @param scene - The scene.
     * @returns <code>true</code> if ClassificationPrimitives are supported; otherwise, returns <code>false</code>
     */
    static isSupported(scene: Scene): boolean;
    /**
     * Called when {@link Viewer} or {@link CesiumWidget} render the scene to
     * get the draw commands needed to render this primitive.
     * <p>
     * Do not call this function directly.  This is documented just to
     * list the exceptions that may be propagated when the scene is rendered:
     * </p>
     */
    update(): void;
    /**
     * Returns the modifiable per-instance attributes for a {@link GeometryInstance}.
     * @example
     * const attributes = primitive.getGeometryInstanceAttributes('an id');
     * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);
     * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);
     * @param id - The id of the {@link GeometryInstance}.
     * @returns The typed array in the attribute's format or undefined if the is no instance with id.
     */
    getGeometryInstanceAttributes(id: any): any;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <p>
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * </p>
     * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <p>
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     * </p>
     * @example
     * e = e && e.destroy();
     */
    destroy(): void;
}

/**
 * Whether a classification affects terrain, 3D Tiles or both.
 */
export enum ClassificationType {
    /**
     * Only terrain will be classified.
     */
    TERRAIN = 0,
    /**
     * Only 3D Tiles will be classified.
     */
    CESIUM_3D_TILE = 1,
    /**
     * Both terrain and 3D Tiles will be classified.
     */
    BOTH = 2
}

/**
 * A Plane in Hessian Normal form to be used with {@link ClippingPlaneCollection}.
 * Compatible with mathematics functions in {@link Plane}
 * @param normal - The plane's normal (normalized).
 * @param distance - The shortest distance from the origin to the plane.  The sign of
 * <code>distance</code> determines which side of the plane the origin
 * is on.  If <code>distance</code> is positive, the origin is in the half-space
 * in the direction of the normal; if negative, the origin is in the half-space
 * opposite to the normal; if zero, the plane passes through the origin.
 */
export class ClippingPlane {
    constructor(normal: Cartesian3, distance: number);
    /**
     * The shortest distance from the origin to the plane.  The sign of
     * <code>distance</code> determines which side of the plane the origin
     * is on.  If <code>distance</code> is positive, the origin is in the half-space
     * in the direction of the normal; if negative, the origin is in the half-space
     * opposite to the normal; if zero, the plane passes through the origin.
     */
    distance: number;
    /**
     * The plane's normal.
     */
    normal: Cartesian3;
    /**
     * Create a ClippingPlane from a Plane object.
     * @param plane - The plane containing parameters to copy
     * @param [result] - The object on which to store the result
     * @returns The ClippingPlane generated from the plane's parameters.
     */
    static fromPlane(plane: Plane, result?: ClippingPlane): ClippingPlane;
    /**
     * Clones the ClippingPlane without setting its ownership.
     * @param clippingPlane - The ClippingPlane to be cloned
     * @param [result] - The object on which to store the cloned parameters.
     * @returns a clone of the input ClippingPlane
     */
    static clone(clippingPlane: ClippingPlane, result?: ClippingPlane): ClippingPlane;
}

/**
 * Specifies a set of clipping planes. Clipping planes selectively disable rendering in a region on the
 * outside of the specified list of {@link ClippingPlane} objects for a single gltf model, 3D Tileset, or the globe.
 * <p>
 * In general the clipping planes' coordinates are relative to the object they're attached to, so a plane with distance set to 0 will clip
 * through the center of the object.
 * </p>
 * <p>
 * For 3D Tiles, the root tile's transform is used to position the clipping planes. If a transform is not defined, the root tile's {@link Cesium3DTile#boundingSphere} is used instead.
 * </p>
 * @example
 * // This clipping plane's distance is positive, which means its normal
 * // is facing the origin. This will clip everything that is behind
 * // the plane, which is anything with y coordinate < -5.
 * const clippingPlanes = new Cesium.ClippingPlaneCollection({
 *     planes : [
 *         new Cesium.ClippingPlane(new Cesium.Cartesian3(0.0, 1.0, 0.0), 5.0)
 *     ],
 * });
 * // Create an entity and attach the ClippingPlaneCollection to the model.
 * const entity = viewer.entities.add({
 *     position : Cesium.Cartesian3.fromDegrees(-123.0744619, 44.0503706, 10000),
 *     model : {
 *         uri : 'model.gltf',
 *         minimumPixelSize : 128,
 *         maximumScale : 20000,
 *         clippingPlanes : clippingPlanes
 *     }
 * });
 * viewer.zoomTo(entity);
 * @param [options] - Object with the following properties:
 * @param [options.planes = []] - An array of {@link ClippingPlane} objects used to selectively disable rendering on the outside of each plane.
 * @param [options.enabled = true] - Determines whether the clipping planes are active.
 * @param [options.modelMatrix = Matrix4.IDENTITY] - The 4x4 transformation matrix specifying an additional transform relative to the clipping planes original coordinate system.
 * @param [options.unionClippingRegions = false] - If true, a region will be clipped if it is on the outside of any plane in the collection. Otherwise, a region will only be clipped if it is on the outside of every plane.
 * @param [options.edgeColor = Color.WHITE] - The color applied to highlight the edge along which an object is clipped.
 * @param [options.edgeWidth = 0.0] - The width, in pixels, of the highlight applied to the edge along which an object is clipped.
 */
export class ClippingPlaneCollection {
    constructor(options?: {
        planes?: ClippingPlane[];
        enabled?: boolean;
        modelMatrix?: Matrix4;
        unionClippingRegions?: boolean;
        edgeColor?: Color;
        edgeWidth?: number;
    });
    /**
     * The 4x4 transformation matrix specifying an additional transform relative to the clipping planes
     * original coordinate system.
     */
    modelMatrix: Matrix4;
    /**
     * The color applied to highlight the edge along which an object is clipped.
     */
    edgeColor: Color;
    /**
     * The width, in pixels, of the highlight applied to the edge along which an object is clipped.
     */
    edgeWidth: number;
    /**
     * An event triggered when a new clipping plane is added to the collection.  Event handlers
     * are passed the new plane and the index at which it was added.
     */
    planeAdded: Event;
    /**
     * An event triggered when a new clipping plane is removed from the collection.  Event handlers
     * are passed the new plane and the index from which it was removed.
     */
    planeRemoved: Event;
    /**
     * Returns the number of planes in this collection.  This is commonly used with
     * {@link ClippingPlaneCollection#get} to iterate over all the planes
     * in the collection.
     */
    readonly length: number;
    /**
     * If true, a region will be clipped if it is on the outside of any plane in the
     * collection. Otherwise, a region will only be clipped if it is on the
     * outside of every plane.
     */
    unionClippingRegions: boolean;
    /**
     * If true, clipping will be enabled.
     */
    enabled: boolean;
    /**
     * Adds the specified {@link ClippingPlane} to the collection to be used to selectively disable rendering
     * on the outside of each plane. Use {@link ClippingPlaneCollection#unionClippingRegions} to modify
     * how modify the clipping behavior of multiple planes.
     * @param plane - The ClippingPlane to add to the collection.
     */
    add(plane: ClippingPlane): void;
    /**
     * Returns the plane in the collection at the specified index.  Indices are zero-based
     * and increase as planes are added.  Removing a plane shifts all planes after
     * it to the left, changing their indices.  This function is commonly used with
     * {@link ClippingPlaneCollection#length} to iterate over all the planes
     * in the collection.
     * @param index - The zero-based index of the plane.
     * @returns The ClippingPlane at the specified index.
     */
    get(index: number): ClippingPlane;
    /**
     * Checks whether this collection contains a ClippingPlane equal to the given ClippingPlane.
     * @param [clippingPlane] - The ClippingPlane to check for.
     * @returns true if this collection contains the ClippingPlane, false otherwise.
     */
    contains(clippingPlane?: ClippingPlane): boolean;
    /**
     * Removes the first occurrence of the given ClippingPlane from the collection.
     * @returns <code>true</code> if the plane was removed; <code>false</code> if the plane was not found in the collection.
     */
    remove(clippingPlane: ClippingPlane): boolean;
    /**
     * Removes all planes from the collection.
     */
    removeAll(): void;
    /**
     * Called when {@link Viewer} or {@link CesiumWidget} render the scene to
     * build the resources for clipping planes.
     * <p>
     * Do not call this function directly.
     * </p>
     */
    update(): void;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     * @example
     * clippingPlanes = clippingPlanes && clippingPlanes.destroy();
     */
    destroy(): void;
}

/**
 * A renderable collection of clouds in the 3D scene.
 * <br /><br />
 * <div align='center'>
 * <img src='Images/CumulusCloud.png' width='400' height='300' /><br />
 * Example cumulus clouds
 * </div>
 * <br /><br />
 * Clouds are added and removed from the collection using {@link CloudCollection#add}
 * and {@link CloudCollection#remove}.
 * @example
 * // Create a cloud collection with two cumulus clouds
 * const clouds = scene.primitives.add(new Cesium.CloudCollection());
 * clouds.add({
 *   position : new Cesium.Cartesian3(1.0, 2.0, 3.0),
 *   maximumSize: new Cesium.Cartesian3(20.0, 12.0, 8.0)
 * });
 * clouds.add({
 *   position : new Cesium.Cartesian3(4.0, 5.0, 6.0),
 *   maximumSize: new Cesium.Cartesian3(15.0, 9.0, 9.0),
 *   slice: 0.5
 * });
 * @param [options] - Object with the following properties:
 * @param [options.show = true] - Whether to display the clouds.
 * @param [options.noiseDetail = 16.0] - Desired amount of detail in the noise texture.
 * @param [options.noiseOffset = Cartesian3.ZERO] - Desired translation of data in noise texture.
 * @param [options.debugBillboards = false] - For debugging only. Determines if the billboards are rendered with an opaque color.
 * @param [options.debugEllipsoids = false] - For debugging only. Determines if the clouds will be rendered as opaque ellipsoids.
 */
export class CloudCollection {
    constructor(options?: {
        show?: boolean;
        noiseDetail?: number;
        noiseOffset?: number;
        debugBillboards?: boolean;
        debugEllipsoids?: boolean;
    });
    /**
     * <p>
     * Controls the amount of detail captured in the precomputed noise texture
     * used to render the cumulus clouds. In order for the texture to be tileable,
     * this must be a power of two. For best results, set this to be a power of two
     * between <code>8.0</code> and <code>32.0</code> (inclusive).
     * </p>
     *
     * <div align='center'>
     * <table border='0' cellpadding='5'><tr>
     * <td align='center'>
     *   <code>clouds.noiseDetail = 8.0;</code><br/>
     *   <img src='Images/CloudCollection.noiseDetail8.png' width='250' height='158' />
     * </td>
     * <td align='center'>
     *   <code>clouds.noiseDetail = 32.0;</code><br/>
     *   <img src='Images/CloudCollection.noiseDetail32.png' width='250' height='158' />
     * </td>
     * </tr></table>
     * </div>
     */
    noiseDetail: number;
    /**
     * <p>
     * Applies a translation to noise texture coordinates to generate different data.
     * This can be modified if the default noise does not generate good-looking clouds.
     * </p>
     *
     * <div align='center'>
     * <table border='0' cellpadding='5'><tr>
     * <td align='center'>
     *   <code>default</code><br/>
     *   <img src='Images/CloudCollection.noiseOffsetdefault.png' width='250' height='158' />
     * </td>
     * <td align='center'>
     *   <code>clouds.noiseOffset = new Cesium.Cartesian3(10, 20, 10);</code><br/>
     *   <img src='Images/CloudCollection.noiseOffsetx10y20z10.png' width='250' height='158' />
     * </td>
     * </tr></table>
     * </div>
     */
    noiseOffset: Cartesian3;
    /**
     * Determines if billboards in this collection will be shown.
     */
    show: boolean;
    /**
     * This property is for debugging only; it is not for production use nor is it optimized.
     * <p>
     * Renders the billboards with one opaque color for the sake of debugging.
     * </p>
     */
    debugBillboards: boolean;
    /**
     * This property is for debugging only; it is not for production use nor is it optimized.
     * <p>
     * Draws the clouds as opaque, monochrome ellipsoids for the sake of debugging.
     * If <code>debugBillboards</code> is also true, then the ellipsoids will draw on top of the billboards.
     * </p>
     */
    debugEllipsoids: boolean;
    /**
     * Returns the number of clouds in this collection.
     */
    length: number;
    /**
     * Creates and adds a cloud with the specified initial properties to the collection.
     * The added cloud is returned so it can be modified or removed from the collection later.
     * @example
     * // Example 1:  Add a cumulus cloud, specifying all the default values.
     * const c = clouds.add({
     *   show : true,
     *   position : Cesium.Cartesian3.ZERO,
     *   scale : new Cesium.Cartesian2(20.0, 12.0),
     *   maximumSize: new Cesium.Cartesian3(20.0, 12.0, 12.0),
     *   slice: -1.0,
     *   cloudType : CloudType.CUMULUS
     * });
     * @example
     * // Example 2:  Specify only the cloud's cartographic position.
     * const c = clouds.add({
     *   position : Cesium.Cartesian3.fromDegrees(longitude, latitude, height)
     * });
     * @param [options] - A template describing the cloud's properties as shown in Example 1.
     * @returns The cloud that was added to the collection.
     */
    add(options?: any): CumulusCloud;
    /**
     * Removes a cloud from the collection.
     * @example
     * const c = clouds.add(...);
     * clouds.remove(c);  // Returns true
     * @param cloud - The cloud to remove.
     * @returns <code>true</code> if the cloud was removed; <code>false</code> if the cloud was not found in the collection.
     */
    remove(cloud: CumulusCloud): boolean;
    /**
     * Removes all clouds from the collection.
     * @example
     * clouds.add(...);
     * clouds.add(...);
     * clouds.removeAll();
     */
    removeAll(): void;
    /**
     * Check whether this collection contains a given cloud.
     * @param [cloud] - The cloud to check for.
     * @returns true if this collection contains the cloud, false otherwise.
     */
    contains(cloud?: CumulusCloud): boolean;
    /**
     * Returns the cloud in the collection at the specified index. Indices are zero-based
     * and increase as clouds are added. Removing a cloud shifts all clouds after
     * it to the left, changing their indices. This function is commonly used with
     * {@link CloudCollection#length} to iterate over all the clouds in the collection.
     * @example
     * // Toggle the show property of every cloud in the collection
     * const len = clouds.length;
     * for (let i = 0; i < len; ++i) {
     *   const c = clouds.get(i);
     *   c.show = !c.show;
     * }
     * @param index - The zero-based index of the cloud.
     * @returns The cloud at the specified index.
     */
    get(index: number): CumulusCloud;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     * @example
     * clouds = clouds && clouds.destroy();
     */
    destroy(): void;
}

/**
 * Specifies the type of the cloud that is added to a {@link CloudCollection} in {@link CloudCollection#add}.
 */
export enum CloudType {
    /**
     * Cumulus cloud.
     */
    CUMULUS = 0
}

/**
 * Defines different modes for blending between a target color and a primitive's source color.
 *
 * HIGHLIGHT multiplies the source color by the target color
 * REPLACE replaces the source color with the target color
 * MIX blends the source color and target color together
 */
export enum ColorBlendMode {
    HIGHLIGHT = 0,
    REPLACE = 1,
    MIX = 2
}

/**
 * An expression for a style applied to a {@link Cesium3DTileset}.
 * <p>
 * Evaluates a conditions expression defined using the
 * {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Styling|3D Tiles Styling language}.
 * </p>
 * <p>
 * Implements the {@link StyleExpression} interface.
 * </p>
 * @example
 * const expression = new Cesium.ConditionsExpression({
 *     conditions : [
 *         ['${Area} > 10, 'color("#FF0000")'],
 *         ['${id} !== "1"', 'color("#00FF00")'],
 *         ['true', 'color("#FFFFFF")']
 *     ]
 * });
 * expression.evaluateColor(feature, result); // returns a Cesium.Color object
 * @param [conditionsExpression] - The conditions expression defined using the 3D Tiles Styling language.
 * @param [defines] - Defines in the style.
 */
export class ConditionsExpression {
    constructor(conditionsExpression?: any, defines?: any);
    /**
     * Gets the conditions expression defined in the 3D Tiles Styling language.
     */
    readonly conditionsExpression: any;
    /**
     * Evaluates the result of an expression, optionally using the provided feature's properties. If the result of
     * the expression in the
     * {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Styling|3D Tiles Styling language}
     * is of type <code>Boolean</code>, <code>Number</code>, or <code>String</code>, the corresponding JavaScript
     * primitive type will be returned. If the result is a <code>RegExp</code>, a Javascript <code>RegExp</code>
     * object will be returned. If the result is a <code>Cartesian2</code>, <code>Cartesian3</code>, or <code>Cartesian4</code>,
     * a {@link Cartesian2}, {@link Cartesian3}, or {@link Cartesian4} object will be returned. If the <code>result</code> argument is
     * a {@link Color}, the {@link Cartesian4} value is converted to a {@link Color} and then returned.
     * @param feature - The feature whose properties may be used as variables in the expression.
     * @param [result] - The object onto which to store the result.
     * @returns The result of evaluating the expression.
     */
    evaluate(feature: Cesium3DTileFeature, result?: any): boolean | number | string | RegExp | Cartesian2 | Cartesian3 | Cartesian4 | Color;
    /**
     * Evaluates the result of a Color expression, using the values defined by a feature.
     * <p>
     * This is equivalent to {@link ConditionsExpression#evaluate} but always returns a {@link Color} object.
     * </p>
     * @param feature - The feature whose properties may be used as variables in the expression.
     * @param [result] - The object in which to store the result
     * @returns The modified result parameter or a new Color instance if one was not provided.
     */
    evaluateColor(feature: Cesium3DTileFeature, result?: Color): Color;
}

/**
 * A ParticleEmitter that emits particles within a cone.
 * Particles will be positioned at the tip of the cone and have initial velocities going towards the base.
 * @param [angle = Cesium.Math.toRadians(30.0)] - The angle of the cone in radians.
 */
export class ConeEmitter {
    constructor(angle?: number);
}

/**
 * The credit display is responsible for displaying credits on screen.
 * @example
 * // Add a credit with a tooltip, image and link to display onscreen
 * const credit = new Cesium.Credit(`<a href="https://cesium.com/" target="_blank"><img src="/images/cesium_logo.png" title="Cesium"/></a>`, true);
 * viewer.creditDisplay.addStaticCredit(credit);
 * @example
 * // Add a credit with a plaintext link to display in the lightbox
 * const credit = new Cesium.Credit('<a href="https://cesium.com/" target="_blank">Cesium</a>');
 * viewer.creditDisplay.addStaticCredit(credit);
 * @param container - The HTML element where credits will be displayed
 * @param [delimiter = ' • '] - The string to separate text credits
 * @param [viewport = document.body] - The HTML element that will contain the credits popup
 */
export class CreditDisplay {
    constructor(container: HTMLElement, delimiter?: string, viewport?: HTMLElement);
    /**
     * The HTML element where credits will be displayed.
     */
    container: HTMLElement;
    /**
     * Adds a {@link Credit} that will show on screen or in the lightbox until
     * the next frame. This is mostly for internal use. Use {@link CreditDisplay.addStaticCredit} to add a persistent credit to the screen.
     * @param credit - The credit to display in the next frame.
     */
    addCreditToNextFrame(credit: Credit): void;
    /**
     * Adds a {@link Credit} that will show on screen or in the lightbox until removed with {@link CreditDisplay.removeStaticCredit}.
     * @example
     * // Add a credit with a tooltip, image and link to display onscreen
     * const credit = new Cesium.Credit(`<a href="https://cesium.com/" target="_blank"><img src="/images/cesium_logo.png" title="Cesium"/></a>`, true);
     * viewer.creditDisplay.addStaticCredit(credit);
     * @example
     * // Add a credit with a plaintext link to display in the lightbox
     * const credit = new Cesium.Credit('<a href="https://cesium.com/" target="_blank">Cesium</a>');
     * viewer.creditDisplay.addStaticCredit(credit);
     * @param credit - The credit to added
     */
    addStaticCredit(credit: Credit): void;
    /**
     * Removes a static credit shown on screen or in the lightbox.
     * @param credit - The credit to be removed.
     */
    removeStaticCredit(credit: Credit): void;
    /**
     * Updates the credit display before a new frame is rendered.
     */
    update(): void;
    /**
     * Resets the credit display to a beginning of frame state, clearing out current credits.
     */
    beginFrame(): void;
    /**
     * Sets the credit display to the end of frame state, displaying credits from the last frame in the credit container.
     */
    endFrame(): void;
    /**
     * Destroys the resources held by this object.  Destroying an object allows for deterministic
     * release of resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     */
    destroy(): void;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     */
    isDestroyed(): boolean;
    /**
     * Gets or sets the Cesium logo credit.
     */
    static cesiumCredit: Credit;
}

/**
 * Determines which triangles, if any, are culled.
 */
export enum CullFace {
    /**
     * Front-facing triangles are culled.
     */
    FRONT = WebGLConstants.FRONT,
    /**
     * Back-facing triangles are culled.
     */
    BACK = WebGLConstants.BACK,
    /**
     * Both front-facing and back-facing triangles are culled.
     */
    FRONT_AND_BACK = WebGLConstants.FRONT_AND_BACK
}

/**
 * <div class="notice">
 * A cloud is created and its initial properties are set by calling {@link CloudCollection#add}.
 * and {@link CloudCollection#remove}. Do not call the constructor directly.
 * </div>
 * A cumulus cloud billboard positioned in the 3D scene, that is created and rendered using a {@link CloudCollection}.
 * <br /><br />
 * <div align='center'>
 * <img src='Images/CumulusCloud.png' width='400' height='300' /><br />
 * Example cumulus clouds
 * </div>
 */
export class CumulusCloud {
    constructor();
    /**
     * Determines if this cumulus cloud will be shown.  Use this to hide or show a cloud, instead
     * of removing it and re-adding it to the collection.
     */
    show: boolean;
    /**
     * Gets or sets the Cartesian position of this cumulus cloud.
     */
    position: Cartesian3;
    /**
     * <p>Gets or sets the scale of the cumulus cloud billboard in meters.
     * The <code>scale</code> property will affect the size of the billboard,
     * but not the cloud's actual appearance.</p>
     * <div align='center'>
     * <table border='0' cellpadding='5'><tr>
     * <td align='center'>
     *   <code>cloud.scale = new Cesium.Cartesian2(12, 8);</code><br/>
     *   <img src='Images/CumulusCloud.scalex12y8.png' width='250' height='158' />
     * </td>
     * <td align='center'>
     *   <code>cloud.scale = new Cesium.Cartesian2(24, 10);</code><br/>
     *   <img src='Images/CumulusCloud.scalex24y10.png' width='250' height='158' />
     * </td>
     * </tr></table>
     * </div>
     *
     * <p>To modify the cloud's appearance, modify its <code>maximumSize</code>
     * and <code>slice</code> properties.</p>
     */
    scale: Cartesian2;
    /**
     * <p>Gets or sets the maximum size of the cumulus cloud rendered on the billboard.
     * This defines a maximum ellipsoid volume that the cloud can appear in.
     * Rather than guaranteeing a specific size, this specifies a boundary for the
     * cloud to appear in, and changing it can affect the shape of the cloud.</p>
     * <p>Changing the z-value of <code>maximumSize</code> has the most dramatic effect
     * on the cloud's appearance because it changes the depth of the cloud, and thus the
     * positions at which the cloud-shaping texture is sampled.</p>
     * <div align='center'>
     * <table border='0' cellpadding='5'>
     * <tr>
     *   <td align='center'>
     *     <code>cloud.maximumSize = new Cesium.Cartesian3(14, 9, 10);</code><br/>
     *     <img src='Images/CumulusCloud.maximumSizex14y9z10.png' width='250' height='158' />
     *   </td>
     *   <td align='center'>
     *     <code>cloud.maximumSize.x = 25;</code><br/>
     *     <img src='Images/CumulusCloud.maximumSizex25.png' width='250' height='158' />
     *   </td>
     * </tr>
     * <tr>
     *   <td align='center'>
     *     <code>cloud.maximumSize.y = 5;</code><br/>
     *     <img src='Images/CumulusCloud.maximumSizey5.png' width='250' height='158' />
     *   </td>
     *   <td align='center'>
     *     <code>cloud.maximumSize.z = 17;</code><br/>
     *     <img src='Images/CumulusCloud.maximumSizez17.png' width='250' height='158' />
     *   </td>
     * </tr>
     * </table>
     * </div>
     *
     * <p>To modify the billboard's actual size, modify the cloud's <code>scale</code> property.</p>
     */
    maximumSize: Cartesian3;
    /**
     * Sets the color of the cloud
     */
    color: Color;
    /**
     * <p>Gets or sets the "slice" of the cloud that is rendered on the billboard, i.e.
     * the specific cross-section of the cloud chosen for the billboard's appearance.
     * Given a value between 0 and 1, the slice specifies how deeply into the cloud
     * to intersect based on its maximum size in the z-direction.</p>
     * <div align='center'>
     * <table border='0' cellpadding='5'><tr>
     * <td align='center'><code>cloud.slice = 0.32;</code><br/><img src='Images/CumulusCloud.slice0.32.png' width='250' height='158' /></td>
     * <td align='center'><code>cloud.slice = 0.5;</code><br/><img src='Images/CumulusCloud.slice0.5.png' width='250' height='158' /></td>
     * <td align='center'><code>cloud.slice = 0.6;</code><br/><img src='Images/CumulusCloud.slice0.6.png' width='250' height='158' /></td>
     * </tr></table>
     * </div>
     *
     * <br />
     * <p>Due to the nature in which this slice is calculated,
     * values below <code>0.2</code> may result in cross-sections that are too small,
     * and the edge of the ellipsoid will be visible. Similarly, values above <code>0.7</code>
     * will cause the cloud to appear smaller. Values outside the range <code>[0.1, 0.9]</code>
     * should be avoided entirely because they do not produce desirable results.</p>
     *
     * <div align='center'>
     * <table border='0' cellpadding='5'><tr>
     * <td align='center'><code>cloud.slice = 0.08;</code><br/><img src='Images/CumulusCloud.slice0.08.png' width='250' height='158' /></td>
     * <td align='center'><code>cloud.slice = 0.8;</code><br/><img src='Images/CumulusCloud.slice0.8.png' width='250' height='158' /></td>
     * </tr></table>
     * </div>
     *
     * <p>If <code>slice</code> is set to a negative number, the cloud will not render a cross-section.
     * Instead, it will render the outside of the ellipsoid that is visible. For clouds with
     * small values of `maximumSize.z`, this can produce good-looking results, but for larger
     * clouds, this can result in a cloud that is undesirably warped to the ellipsoid volume.</p>
     *
     * <div align='center'>
     * <table border='0' cellpadding='5'><tr>
     * <td align='center'>
     *  <code>cloud.slice = -1.0;<br/>cloud.maximumSize.z = 18;</code><br/>
     *  <img src='Images/CumulusCloud.slice-1z18.png' width='250' height='158' />
     * </td>
     * <td align='center'>
     *   <code>cloud.slice = -1.0;<br/>cloud.maximumSize.z = 30;</code><br/>
     *   <img src='Images/CumulusCloud.slice-1z30.png' width='250' height='158' /></td>
     * </tr></table>
     * </div>
     */
    slice: number;
    /**
     * Gets or sets the brightness of the cloud. This can be used to give clouds
     * a darker, grayer appearance.
     * <br /><br />
     * <div align='center'>
     * <table border='0' cellpadding='5'><tr>
     * <td align='center'><code>cloud.brightness = 1.0;</code><br/><img src='Images/CumulusCloud.brightness1.png' width='250' height='158' /></td>
     * <td align='center'><code>cloud.brightness = 0.6;</code><br/><img src='Images/CumulusCloud.brightness0.6.png' width='250' height='158' /></td>
     * <td align='center'><code>cloud.brightness = 0.0;</code><br/><img src='Images/CumulusCloud.brightness0.png' width='250' height='158' /></td>
     * </tr></table>
     * </div>
     */
    brightness: number;
}

/**
 * Visualizes a vertex attribute by displaying it as a color for debugging.
 * <p>
 * Components for well-known unit-length vectors, i.e., <code>normal</code>,
 * <code>tangent</code>, and <code>bitangent</code>, are scaled and biased
 * from [-1.0, 1.0] to (-1.0, 1.0).
 * </p>
 * @example
 * const primitive = new Cesium.Primitive({
 *   geometryInstances : // ...
 *   appearance : new Cesium.DebugAppearance({
 *     attributeName : 'normal'
 *   })
 * });
 * @param options - Object with the following properties:
 * @param options.attributeName - The name of the attribute to visualize.
 * @param [options.perInstanceAttribute = false] - Boolean that determines whether this attribute is a per-instance geometry attribute.
 * @param [options.glslDatatype = 'vec3'] - The GLSL datatype of the attribute.  Supported datatypes are <code>float</code>, <code>vec2</code>, <code>vec3</code>, and <code>vec4</code>.
 * @param [options.vertexShaderSource] - Optional GLSL vertex shader source to override the default vertex shader.
 * @param [options.fragmentShaderSource] - Optional GLSL fragment shader source to override the default fragment shader.
 * @param [options.renderState] - Optional render state to override the default render state.
 */
export class DebugAppearance {
    constructor(options: {
        attributeName: string;
        perInstanceAttribute?: boolean;
        glslDatatype?: string;
        vertexShaderSource?: string;
        fragmentShaderSource?: string;
        renderState?: any;
    });
    /**
     * This property is part of the {@link Appearance} interface, but is not
     * used by {@link DebugAppearance} since a fully custom fragment shader is used.
     */
    material: Material;
    /**
     * When <code>true</code>, the geometry is expected to appear translucent.
     */
    translucent: boolean;
    /**
     * The GLSL source code for the vertex shader.
     */
    readonly vertexShaderSource: string;
    /**
     * The GLSL source code for the fragment shader.  The full fragment shader
     * source is built procedurally taking into account the {@link DebugAppearance#material}.
     * Use {@link DebugAppearance#getFragmentShaderSource} to get the full source.
     */
    readonly fragmentShaderSource: string;
    /**
     * The WebGL fixed-function state to use when rendering the geometry.
     */
    readonly renderState: any;
    /**
     * When <code>true</code>, the geometry is expected to be closed.
     */
    readonly closed: boolean;
    /**
     * The name of the attribute being visualized.
     */
    readonly attributeName: string;
    /**
     * The GLSL datatype of the attribute being visualized.
     */
    readonly glslDatatype: string;
    /**
     * Returns the full GLSL fragment shader source, which for {@link DebugAppearance} is just
     * {@link DebugAppearance#fragmentShaderSource}.
     * @returns The full GLSL fragment shader source.
     */
    getFragmentShaderSource(): string;
    /**
     * Determines if the geometry is translucent based on {@link DebugAppearance#translucent}.
     * @returns <code>true</code> if the appearance is translucent.
     */
    isTranslucent(): boolean;
    /**
     * Creates a render state.  This is not the final render state instance; instead,
     * it can contain a subset of render state properties identical to the render state
     * created in the context.
     * @returns The render state.
     */
    getRenderState(): any;
}

/**
 * Draws the outline of the camera's view frustum.
 * @example
 * primitives.add(new Cesium.DebugCameraPrimitive({
 *   camera : camera,
 *   color : Cesium.Color.YELLOW
 * }));
 * @param options - Object with the following properties:
 * @param options.camera - The camera.
 * @param [options.frustumSplits] - Distances to the near and far planes of the camera frustums. This overrides the camera's frustum near and far values.
 * @param [options.color = Color.CYAN] - The color of the debug outline.
 * @param [options.updateOnChange = true] - Whether the primitive updates when the underlying camera changes.
 * @param [options.show = true] - Determines if this primitive will be shown.
 * @param [options.id] - A user-defined object to return when the instance is picked with {@link Scene#pick}.
 */
export class DebugCameraPrimitive {
    constructor(options: {
        camera: Camera;
        frustumSplits?: number[];
        color?: Color;
        updateOnChange?: boolean;
        show?: boolean;
        id?: any;
    });
    /**
     * Determines if this primitive will be shown.
     */
    show: boolean;
    /**
     * User-defined value returned when the primitive is picked.
     */
    id: any;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <p>
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * </p>
     * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <p>
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     * </p>
     * @example
     * p = p && p.destroy();
     */
    destroy(): void;
}

/**
 * Draws the axes of a reference frame defined by a matrix that transforms to world
 * coordinates, i.e., Earth's WGS84 coordinates.  The most prominent example is
 * a primitives <code>modelMatrix</code>.
 * <p>
 * The X axis is red; Y is green; and Z is blue.
 * </p>
 * <p>
 * This is for debugging only; it is not optimized for production use.
 * </p>
 * @example
 * primitives.add(new Cesium.DebugModelMatrixPrimitive({
 *   modelMatrix : primitive.modelMatrix,  // primitive to debug
 *   length : 100000.0,
 *   width : 10.0
 * }));
 * @param [options] - Object with the following properties:
 * @param [options.length = 10000000.0] - The length of the axes in meters.
 * @param [options.width = 2.0] - The width of the axes in pixels.
 * @param [options.modelMatrix = Matrix4.IDENTITY] - The 4x4 matrix that defines the reference frame, i.e., origin plus axes, to visualize.
 * @param [options.show = true] - Determines if this primitive will be shown.
 * @param [options.id] - A user-defined object to return when the instance is picked with {@link Scene#pick}
 */
export class DebugModelMatrixPrimitive {
    constructor(options?: {
        length?: number;
        width?: number;
        modelMatrix?: Matrix4;
        show?: boolean;
        id?: any;
    });
    /**
     * The length of the axes in meters.
     */
    length: number;
    /**
     * The width of the axes in pixels.
     */
    width: number;
    /**
     * Determines if this primitive will be shown.
     */
    show: boolean;
    /**
     * The 4x4 matrix that defines the reference frame, i.e., origin plus axes, to visualize.
     */
    modelMatrix: Matrix4;
    /**
     * User-defined value returned when the primitive is picked.
     */
    id: any;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <p>
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * </p>
     * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <p>
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     * </p>
     * @example
     * p = p && p.destroy();
     */
    destroy(): void;
}

/**
 * Determines the function used to compare two depths for the depth test.
 */
export enum DepthFunction {
    /**
     * The depth test never passes.
     */
    NEVER = WebGLConstants.NEVER,
    /**
     * The depth test passes if the incoming depth is less than the stored depth.
     */
    LESS = WebGLConstants.LESS,
    /**
     * The depth test passes if the incoming depth is equal to the stored depth.
     */
    EQUAL = WebGLConstants.EQUAL,
    /**
     * The depth test passes if the incoming depth is less than or equal to the stored depth.
     */
    LESS_OR_EQUAL = WebGLConstants.LEQUAL,
    /**
     * The depth test passes if the incoming depth is greater than the stored depth.
     */
    GREATER = WebGLConstants.GREATER,
    /**
     * The depth test passes if the incoming depth is not equal to the stored depth.
     */
    NOT_EQUAL = WebGLConstants.NOTEQUAL,
    /**
     * The depth test passes if the incoming depth is greater than or equal to the stored depth.
     */
    GREATER_OR_EQUAL = WebGLConstants.GEQUAL,
    /**
     * The depth test always passes.
     */
    ALWAYS = WebGLConstants.ALWAYS
}

/**
 * A light that gets emitted in a single direction from infinitely far away.
 * @param options - Object with the following properties:
 * @param options.direction - The direction in which light gets emitted.
 * @param [options.color = Color.WHITE] - The color of the light.
 * @param [options.intensity = 1.0] - The intensity of the light.
 */
export class DirectionalLight {
    constructor(options: {
        direction: Cartesian3;
        color?: Color;
        intensity?: number;
    });
    /**
     * The direction in which light gets emitted.
     */
    direction: Cartesian3;
    /**
     * The color of the light.
     */
    color: Color;
    /**
     * The intensity of the light.
     */
    intensity: number;
}

/**
 * A policy for discarding tile images that contain no data (and so aren't actually images).
 * This policy discards {@link DiscardEmptyTileImagePolicy.EMPTY_IMAGE}, which is
 * expected to be used in place of any empty tile images by the image loading code.
 */
export class DiscardEmptyTileImagePolicy {
    constructor();
    /**
     * Determines if the discard policy is ready to process images.
     * @returns True if the discard policy is ready to process images; otherwise, false.
     */
    isReady(): boolean;
    /**
     * Given a tile image, decide whether to discard that image.
     * @param image - An image to test.
     * @returns True if the image should be discarded; otherwise, false.
     */
    shouldDiscardImage(image: HTMLImageElement): boolean;
    /**
     * Default value for representing an empty image.
     */
    static readonly EMPTY_IMAGE: HTMLImageElement;
}

/**
 * A policy for discarding tile images that match a known image containing a
 * "missing" image.
 * @param options - Object with the following properties:
 * @param options.missingImageUrl - The URL of the known missing image.
 * @param options.pixelsToCheck - An array of {@link Cartesian2} pixel positions to
 *        compare against the missing image.
 * @param [options.disableCheckIfAllPixelsAreTransparent = false] - If true, the discard check will be disabled
 *                  if all of the pixelsToCheck in the missingImageUrl have an alpha value of 0.  If false, the
 *                  discard check will proceed no matter the values of the pixelsToCheck.
 */
export class DiscardMissingTileImagePolicy {
    constructor(options: {
        missingImageUrl: Resource | string;
        pixelsToCheck: Cartesian2[];
        disableCheckIfAllPixelsAreTransparent?: boolean;
    });
    /**
     * Determines if the discard policy is ready to process images.
     * @returns True if the discard policy is ready to process images; otherwise, false.
     */
    isReady(): boolean;
    /**
     * Given a tile image, decide whether to discard that image.
     * @param image - An image to test.
     * @returns True if the image should be discarded; otherwise, false.
     */
    shouldDiscardImage(image: HTMLImageElement): boolean;
}

/**
 * An appearance for geometry on the surface of the ellipsoid like {@link PolygonGeometry}
 * and {@link RectangleGeometry}, which supports all materials like {@link MaterialAppearance}
 * with {@link MaterialAppearance.MaterialSupport.ALL}.  However, this appearance requires
 * fewer vertex attributes since the fragment shader can procedurally compute <code>normal</code>,
 * <code>tangent</code>, and <code>bitangent</code>.
 * @example
 * const primitive = new Cesium.Primitive({
 *   geometryInstances : new Cesium.GeometryInstance({
 *     geometry : new Cesium.PolygonGeometry({
 *       vertexFormat : Cesium.EllipsoidSurfaceAppearance.VERTEX_FORMAT,
 *       // ...
 *     })
 *   }),
 *   appearance : new Cesium.EllipsoidSurfaceAppearance({
 *     material : Cesium.Material.fromType('Stripe')
 *   })
 * });
 * @param [options] - Object with the following properties:
 * @param [options.flat = false] - When <code>true</code>, flat shading is used in the fragment shader, which means lighting is not taking into account.
 * @param [options.faceForward = options.aboveGround] - When <code>true</code>, the fragment shader flips the surface normal as needed to ensure that the normal faces the viewer to avoid dark spots.  This is useful when both sides of a geometry should be shaded like {@link WallGeometry}.
 * @param [options.translucent = true] - When <code>true</code>, the geometry is expected to appear translucent so {@link EllipsoidSurfaceAppearance#renderState} has alpha blending enabled.
 * @param [options.aboveGround = false] - When <code>true</code>, the geometry is expected to be on the ellipsoid's surface - not at a constant height above it - so {@link EllipsoidSurfaceAppearance#renderState} has backface culling enabled.
 * @param [options.material = Material.ColorType] - The material used to determine the fragment color.
 * @param [options.vertexShaderSource] - Optional GLSL vertex shader source to override the default vertex shader.
 * @param [options.fragmentShaderSource] - Optional GLSL fragment shader source to override the default fragment shader.
 * @param [options.renderState] - Optional render state to override the default render state.
 */
export class EllipsoidSurfaceAppearance {
    constructor(options?: {
        flat?: boolean;
        faceForward?: boolean;
        translucent?: boolean;
        aboveGround?: boolean;
        material?: Material;
        vertexShaderSource?: string;
        fragmentShaderSource?: string;
        renderState?: any;
    });
    /**
     * The material used to determine the fragment color.  Unlike other {@link EllipsoidSurfaceAppearance}
     * properties, this is not read-only, so an appearance's material can change on the fly.
     */
    material: Material;
    /**
     * When <code>true</code>, the geometry is expected to appear translucent.
     */
    translucent: boolean;
    /**
     * The GLSL source code for the vertex shader.
     */
    readonly vertexShaderSource: string;
    /**
     * The GLSL source code for the fragment shader.  The full fragment shader
     * source is built procedurally taking into account {@link EllipsoidSurfaceAppearance#material},
     * {@link EllipsoidSurfaceAppearance#flat}, and {@link EllipsoidSurfaceAppearance#faceForward}.
     * Use {@link EllipsoidSurfaceAppearance#getFragmentShaderSource} to get the full source.
     */
    readonly fragmentShaderSource: string;
    /**
     * The WebGL fixed-function state to use when rendering the geometry.
     * <p>
     * The render state can be explicitly defined when constructing a {@link EllipsoidSurfaceAppearance}
     * instance, or it is set implicitly via {@link EllipsoidSurfaceAppearance#translucent}
     * and {@link EllipsoidSurfaceAppearance#aboveGround}.
     * </p>
     */
    readonly renderState: any;
    /**
     * When <code>true</code>, the geometry is expected to be closed so
     * {@link EllipsoidSurfaceAppearance#renderState} has backface culling enabled.
     * If the viewer enters the geometry, it will not be visible.
     */
    readonly closed: boolean;
    /**
     * The {@link VertexFormat} that this appearance instance is compatible with.
     * A geometry can have more vertex attributes and still be compatible - at a
     * potential performance cost - but it can't have less.
     */
    readonly vertexFormat: VertexFormat;
    /**
     * When <code>true</code>, flat shading is used in the fragment shader,
     * which means lighting is not taking into account.
     */
    readonly flat: boolean;
    /**
     * When <code>true</code>, the fragment shader flips the surface normal
     * as needed to ensure that the normal faces the viewer to avoid
     * dark spots.  This is useful when both sides of a geometry should be
     * shaded like {@link WallGeometry}.
     */
    readonly faceForward: boolean;
    /**
     * When <code>true</code>, the geometry is expected to be on the ellipsoid's
     * surface - not at a constant height above it - so {@link EllipsoidSurfaceAppearance#renderState}
     * has backface culling enabled.
     */
    readonly aboveGround: boolean;
    /**
     * The {@link VertexFormat} that all {@link EllipsoidSurfaceAppearance} instances
     * are compatible with, which requires only <code>position</code> and <code>st</code>
     * attributes.  Other attributes are procedurally computed in the fragment shader.
     */
    static readonly VERTEX_FORMAT: VertexFormat;
    /**
     * Procedurally creates the full GLSL fragment shader source.  For {@link EllipsoidSurfaceAppearance},
     * this is derived from {@link EllipsoidSurfaceAppearance#fragmentShaderSource}, {@link EllipsoidSurfaceAppearance#flat},
     * and {@link EllipsoidSurfaceAppearance#faceForward}.
     * @returns The full GLSL fragment shader source.
     */
    getFragmentShaderSource(): string;
    /**
     * Determines if the geometry is translucent based on {@link EllipsoidSurfaceAppearance#translucent} and {@link Material#isTranslucent}.
     * @returns <code>true</code> if the appearance is translucent.
     */
    isTranslucent(): boolean;
    /**
     * Creates a render state.  This is not the final render state instance; instead,
     * it can contain a subset of render state properties identical to the render state
     * created in the context.
     * @returns The render state.
     */
    getRenderState(): any;
}

/**
 * An expression for a style applied to a {@link Cesium3DTileset}.
 * <p>
 * Evaluates an expression defined using the
 * {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Styling|3D Tiles Styling language}.
 * </p>
 * <p>
 * Implements the {@link StyleExpression} interface.
 * </p>
 * @example
 * const expression = new Cesium.Expression('(regExp("^Chest").test(${County})) && (${YearBuilt} >= 1970)');
 * expression.evaluate(feature); // returns true or false depending on the feature's properties
 * @example
 * const expression = new Cesium.Expression('(${Temperature} > 90) ? color("red") : color("white")');
 * expression.evaluateColor(feature, result); // returns a Cesium.Color object
 * @param [expression] - The expression defined using the 3D Tiles Styling language.
 * @param [defines] - Defines in the style.
 */
export class Expression {
    constructor(expression?: string, defines?: any);
    /**
     * Gets the expression defined in the 3D Tiles Styling language.
     */
    readonly expression: string;
    /**
     * Evaluates the result of an expression, optionally using the provided feature's properties. If the result of
     * the expression in the
     * {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Styling|3D Tiles Styling language}
     * is of type <code>Boolean</code>, <code>Number</code>, or <code>String</code>, the corresponding JavaScript
     * primitive type will be returned. If the result is a <code>RegExp</code>, a Javascript <code>RegExp</code>
     * object will be returned. If the result is a <code>Cartesian2</code>, <code>Cartesian3</code>, or <code>Cartesian4</code>,
     * a {@link Cartesian2}, {@link Cartesian3}, or {@link Cartesian4} object will be returned. If the <code>result</code> argument is
     * a {@link Color}, the {@link Cartesian4} value is converted to a {@link Color} and then returned.
     * @param feature - The feature whose properties may be used as variables in the expression.
     * @param [result] - The object onto which to store the result.
     * @returns The result of evaluating the expression.
     */
    evaluate(feature: Cesium3DTileFeature, result?: any): boolean | number | string | RegExp | Cartesian2 | Cartesian3 | Cartesian4 | Color;
    /**
     * Evaluates the result of a Color expression, optionally using the provided feature's properties.
     * <p>
     * This is equivalent to {@link Expression#evaluate} but always returns a {@link Color} object.
     * </p>
     * @param feature - The feature whose properties may be used as variables in the expression.
     * @param [result] - The object in which to store the result
     * @returns The modified result parameter or a new Color instance if one was not provided.
     */
    evaluateColor(feature: Cesium3DTileFeature, result?: Color): Color;
}

/**
 * Blends the atmosphere to geometry far from the camera for horizon views. Allows for additional
 * performance improvements by rendering less geometry and dispatching less terrain requests.
 */
export class Fog {
    constructor();
    /**
     * <code>true</code> if fog is enabled, <code>false</code> otherwise.
     */
    enabled: boolean;
    /**
     * <code>true</code> if fog is renderable in shaders, <code>false</code> otherwise.
     * This allows to benefits from optimized tile loading strategy based on fog density without the actual visual rendering.
     */
    renderable: boolean;
    /**
     * A scalar that determines the density of the fog. Terrain that is in full fog are culled.
     * The density of the fog increases as this number approaches 1.0 and becomes less dense as it approaches zero.
     * The more dense the fog is, the more aggressively the terrain is culled. For example, if the camera is a height of
     * 1000.0m above the ellipsoid, increasing the value to 3.0e-3 will cause many tiles close to the viewer be culled.
     * Decreasing the value will push the fog further from the viewer, but decrease performance as more of the terrain is rendered.
     */
    density: number;
    /**
     * A factor used to increase the screen space error of terrain tiles when they are partially in fog. The effect is to reduce
     * the number of terrain tiles requested for rendering. If set to zero, the feature will be disabled. If the value is increased
     * for mountainous regions, less tiles will need to be requested, but the terrain meshes near the horizon may be a noticeably
     * lower resolution. If the value is increased in a relatively flat area, there will be little noticeable change on the horizon.
     */
    screenSpaceErrorFactor: number;
    /**
     * The minimum brightness of the fog color from lighting. A value of 0.0 can cause the fog to be completely black. A value of 1.0 will not affect
     * the brightness at all.
     */
    minimumBrightness: number;
}

/**
 * Monitors the frame rate (frames per second) in a {@link Scene} and raises an event if the frame rate is
 * lower than a threshold.  Later, if the frame rate returns to the required level, a separate event is raised.
 * To avoid creating multiple FrameRateMonitors for a single {@link Scene}, use {@link FrameRateMonitor.fromScene}
 * instead of constructing an instance explicitly.
 * @param [options] - Object with the following properties:
 * @param options.scene - The Scene instance for which to monitor performance.
 * @param [options.samplingWindow = 5.0] - The length of the sliding window over which to compute the average frame rate, in seconds.
 * @param [options.quietPeriod = 2.0] - The length of time to wait at startup and each time the page becomes visible (i.e. when the user
 *        switches back to the tab) before starting to measure performance, in seconds.
 * @param [options.warmupPeriod = 5.0] - The length of the warmup period, in seconds.  During the warmup period, a separate
 *        (usually lower) frame rate is required.
 * @param [options.minimumFrameRateDuringWarmup = 4] - The minimum frames-per-second that are required for acceptable performance during
 *        the warmup period.  If the frame rate averages less than this during any samplingWindow during the warmupPeriod, the
 *        lowFrameRate event will be raised and the page will redirect to the redirectOnLowFrameRateUrl, if any.
 * @param [options.minimumFrameRateAfterWarmup = 8] - The minimum frames-per-second that are required for acceptable performance after
 *        the end of the warmup period.  If the frame rate averages less than this during any samplingWindow after the warmupPeriod, the
 *        lowFrameRate event will be raised and the page will redirect to the redirectOnLowFrameRateUrl, if any.
 */
export class FrameRateMonitor {
    constructor(options?: {
        scene: Scene;
        samplingWindow?: number;
        quietPeriod?: number;
        warmupPeriod?: number;
        minimumFrameRateDuringWarmup?: number;
        minimumFrameRateAfterWarmup?: number;
    });
    /**
     * Gets or sets the length of the sliding window over which to compute the average frame rate, in seconds.
     */
    samplingWindow: number;
    /**
     * Gets or sets the length of time to wait at startup and each time the page becomes visible (i.e. when the user
     * switches back to the tab) before starting to measure performance, in seconds.
     */
    quietPeriod: number;
    /**
     * Gets or sets the length of the warmup period, in seconds.  During the warmup period, a separate
     * (usually lower) frame rate is required.
     */
    warmupPeriod: number;
    /**
     * Gets or sets the minimum frames-per-second that are required for acceptable performance during
     * the warmup period.  If the frame rate averages less than this during any <code>samplingWindow</code> during the <code>warmupPeriod</code>, the
     * <code>lowFrameRate</code> event will be raised and the page will redirect to the <code>redirectOnLowFrameRateUrl</code>, if any.
     */
    minimumFrameRateDuringWarmup: number;
    /**
     * Gets or sets the minimum frames-per-second that are required for acceptable performance after
     * the end of the warmup period.  If the frame rate averages less than this during any <code>samplingWindow</code> after the <code>warmupPeriod</code>, the
     * <code>lowFrameRate</code> event will be raised and the page will redirect to the <code>redirectOnLowFrameRateUrl</code>, if any.
     */
    minimumFrameRateAfterWarmup: number;
    /**
     * The default frame rate monitoring settings.  These settings are used when {@link FrameRateMonitor.fromScene}
     * needs to create a new frame rate monitor, and for any settings that are not passed to the
     * {@link FrameRateMonitor} constructor.
     */
    static defaultSettings: any;
    /**
     * Gets the {@link FrameRateMonitor} for a given scene.  If the scene does not yet have
     * a {@link FrameRateMonitor}, one is created with the {@link FrameRateMonitor.defaultSettings}.
     * @param scene - The scene for which to get the {@link FrameRateMonitor}.
     * @returns The scene's {@link FrameRateMonitor}.
     */
    static fromScene(scene: Scene): FrameRateMonitor;
    /**
     * Gets the {@link Scene} instance for which to monitor performance.
     */
    scene: Scene;
    /**
     * Gets the event that is raised when a low frame rate is detected.  The function will be passed
     * the {@link Scene} instance as its first parameter and the average number of frames per second
     * over the sampling window as its second parameter.
     */
    lowFrameRate: Event;
    /**
     * Gets the event that is raised when the frame rate returns to a normal level after having been low.
     * The function will be passed the {@link Scene} instance as its first parameter and the average
     * number of frames per second over the sampling window as its second parameter.
     */
    nominalFrameRate: Event;
    /**
     * Gets the most recently computed average frames-per-second over the last <code>samplingWindow</code>.
     * This property may be undefined if the frame rate has not been computed.
     */
    lastFramesPerSecond: number;
    /**
     * Pauses monitoring of the frame rate.  To resume monitoring, {@link FrameRateMonitor#unpause}
     * must be called once for each time this function is called.
     */
    pause(): void;
    /**
     * Resumes monitoring of the frame rate.  If {@link FrameRateMonitor#pause} was called
     * multiple times, this function must be called the same number of times in order to
     * actually resume monitoring.
     */
    unpause(): void;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * @returns True if this object was destroyed; otherwise, false.
     */
    isDestroyed(): boolean;
    /**
     * Unsubscribes this instance from all events it is listening to.
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     */
    destroy(): void;
}

/**
 * Describes the format in which to request GetFeatureInfo from a Web Map Service (WMS) server.
 * @param type - The type of response to expect from a GetFeatureInfo request.  Valid
 *        values are 'json', 'xml', 'html', or 'text'.
 * @param [format] - The info format to request from the WMS server.  This is usually a
 *        MIME type such as 'application/json' or text/xml'.  If this parameter is not specified, the provider will request 'json'
 *        using 'application/json', 'xml' using 'text/xml', 'html' using 'text/html', and 'text' using 'text/plain'.
 * @param [callback] - A function to invoke with the GetFeatureInfo response from the WMS server
 *        in order to produce an array of picked {@link ImageryLayerFeatureInfo} instances.  If this parameter is not specified,
 *        a default function for the type of response is used.
 */
export class GetFeatureInfoFormat {
    constructor(type: string, format?: string, callback?: (...params: any[]) => any);
}

/**
 * The globe rendered in the scene, including its terrain ({@link Globe#terrainProvider})
 * and imagery layers ({@link Globe#imageryLayers}).  Access the globe using {@link Scene#globe}.
 * @param [ellipsoid = Ellipsoid.WGS84] - Determines the size and shape of the
 * globe.
 */
export class Globe {
    constructor(ellipsoid?: Ellipsoid);
    /**
     * Determines if the globe will be shown.
     */
    show: boolean;
    /**
     * The maximum screen-space error used to drive level-of-detail refinement.  Higher
     * values will provide better performance but lower visual quality.
     */
    maximumScreenSpaceError: number;
    /**
     * The size of the terrain tile cache, expressed as a number of tiles.  Any additional
     * tiles beyond this number will be freed, as long as they aren't needed for rendering
     * this frame.  A larger number will consume more memory but will show detail faster
     * when, for example, zooming out and then back in.
     */
    tileCacheSize: number;
    /**
     * Gets or sets the number of loading descendant tiles that is considered "too many".
     * If a tile has too many loading descendants, that tile will be loaded and rendered before any of
     * its descendants are loaded and rendered. This means more feedback for the user that something
     * is happening at the cost of a longer overall load time. Setting this to 0 will cause each
     * tile level to be loaded successively, significantly increasing load time. Setting it to a large
     * number (e.g. 1000) will minimize the number of tiles that are loaded but tend to make
     * detail appear all at once after a long wait.
     */
    loadingDescendantLimit: number;
    /**
     * Gets or sets a value indicating whether the ancestors of rendered tiles should be preloaded.
     * Setting this to true optimizes the zoom-out experience and provides more detail in
     * newly-exposed areas when panning. The down side is that it requires loading more tiles.
     */
    preloadAncestors: boolean;
    /**
     * Gets or sets a value indicating whether the siblings of rendered tiles should be preloaded.
     * Setting this to true causes tiles with the same parent as a rendered tile to be loaded, even
     * if they are culled. Setting this to true may provide a better panning experience at the
     * cost of loading more tiles.
     */
    preloadSiblings: boolean;
    /**
     * The color to use to highlight terrain fill tiles. If undefined, fill tiles are not
     * highlighted at all. The alpha value is used to alpha blend with the tile's
     * actual color. Because terrain fill tiles do not represent the actual terrain surface,
     * it may be useful in some applications to indicate visually that they are not to be trusted.
     */
    fillHighlightColor: Color;
    /**
     * Enable lighting the globe with the scene's light source.
     */
    enableLighting: boolean;
    /**
     * A multiplier to adjust terrain lambert lighting.
     * This number is multiplied by the result of <code>czm_getLambertDiffuse</code> in GlobeFS.glsl.
     * This only takes effect when <code>enableLighting</code> is <code>true</code>.
     */
    lambertDiffuseMultiplier: number;
    /**
     * Enable dynamic lighting effects on atmosphere and fog. This only takes effect
     * when <code>enableLighting</code> is <code>true</code>.
     */
    dynamicAtmosphereLighting: boolean;
    /**
     * Whether dynamic atmosphere lighting uses the sun direction instead of the scene's
     * light direction. This only takes effect when <code>enableLighting</code> and
     * <code>dynamicAtmosphereLighting</code> are <code>true</code>.
     */
    dynamicAtmosphereLightingFromSun: boolean;
    /**
     * Enable the ground atmosphere, which is drawn over the globe when viewed from a distance between <code>lightingFadeInDistance</code> and <code>lightingFadeOutDistance</code>.
     */
    showGroundAtmosphere: boolean;
    /**
     * The intensity of the light that is used for computing the ground atmosphere color.
     */
    atmosphereLightIntensity: number;
    /**
     * The Rayleigh scattering coefficient used in the atmospheric scattering equations for the ground atmosphere.
     */
    atmosphereRayleighCoefficient: Cartesian3;
    /**
     * The Mie scattering coefficient used in the atmospheric scattering equations for the ground atmosphere.
     */
    atmosphereMieCoefficient: Cartesian3;
    /**
     * The Rayleigh scale height used in the atmospheric scattering equations for the ground atmosphere, in meters.
     */
    atmosphereRayleighScaleHeight: number;
    /**
     * The Mie scale height used in the atmospheric scattering equations for the ground atmosphere, in meters.
     */
    atmosphereMieScaleHeight: number;
    /**
     * The anisotropy of the medium to consider for Mie scattering.
     * <p>
     * Valid values are between -1.0 and 1.0.
     * </p>
     */
    atmosphereMieAnisotropy: number;
    /**
     * The distance where everything becomes lit. This only takes effect
     * when <code>enableLighting</code> or <code>showGroundAtmosphere</code> is <code>true</code>.
     */
    lightingFadeOutDistance: number;
    /**
     * The distance where lighting resumes. This only takes effect
     * when <code>enableLighting</code> or <code>showGroundAtmosphere</code> is <code>true</code>.
     */
    lightingFadeInDistance: number;
    /**
     * The distance where the darkness of night from the ground atmosphere fades out to a lit ground atmosphere.
     * This only takes effect when <code>showGroundAtmosphere</code>, <code>enableLighting</code>, and
     * <code>dynamicAtmosphereLighting</code> are <code>true</code>.
     */
    nightFadeOutDistance: number;
    /**
     * The distance where the darkness of night from the ground atmosphere fades in to an unlit ground atmosphere.
     * This only takes effect when <code>showGroundAtmosphere</code>, <code>enableLighting</code>, and
     * <code>dynamicAtmosphereLighting</code> are <code>true</code>.
     */
    nightFadeInDistance: number;
    /**
     * True if an animated wave effect should be shown in areas of the globe
     * covered by water; otherwise, false.  This property is ignored if the
     * <code>terrainProvider</code> does not provide a water mask.
     */
    showWaterEffect: boolean;
    /**
     * True if primitives such as billboards, polylines, labels, etc. should be depth-tested
     * against the terrain surface, or false if such primitives should always be drawn on top
     * of terrain unless they're on the opposite side of the globe.  The disadvantage of depth
     * testing primitives against terrain is that slight numerical noise or terrain level-of-detail
     * switched can sometimes make a primitive that should be on the surface disappear underneath it.
     */
    depthTestAgainstTerrain: boolean;
    /**
     * Determines whether the globe casts or receives shadows from light sources. Setting the globe
     * to cast shadows may impact performance since the terrain is rendered again from the light's perspective.
     * Currently only terrain that is in view casts shadows. By default the globe does not cast shadows.
     */
    shadows: ShadowMode;
    /**
     * The hue shift to apply to the atmosphere. Defaults to 0.0 (no shift).
     * A hue shift of 1.0 indicates a complete rotation of the hues available.
     */
    atmosphereHueShift: number;
    /**
     * The saturation shift to apply to the atmosphere. Defaults to 0.0 (no shift).
     * A saturation shift of -1.0 is monochrome.
     */
    atmosphereSaturationShift: number;
    /**
     * The brightness shift to apply to the atmosphere. Defaults to 0.0 (no shift).
     * A brightness shift of -1.0 is complete darkness, which will let space show through.
     */
    atmosphereBrightnessShift: number;
    /**
     * A scalar used to exaggerate the terrain. Defaults to <code>1.0</code> (no exaggeration).
     * A value of <code>2.0</code> scales the terrain by 2x.
     * A value of <code>0.0</code> makes the terrain completely flat.
     * Note that terrain exaggeration will not modify any other primitive as they are positioned relative to the ellipsoid.
     */
    terrainExaggeration: number;
    /**
     * The height from which terrain is exaggerated. Defaults to <code>0.0</code> (scaled relative to ellipsoid surface).
     * Terrain that is above this height will scale upwards and terrain that is below this height will scale downwards.
     * Note that terrain exaggeration will not modify any other primitive as they are positioned relative to the ellipsoid.
     * If {@link Globe#terrainExaggeration} is <code>1.0</code> this value will have no effect.
     */
    terrainExaggerationRelativeHeight: number;
    /**
     * Whether to show terrain skirts. Terrain skirts are geometry extending downwards from a tile's edges used to hide seams between neighboring tiles.
     * Skirts are always hidden when the camera is underground or translucency is enabled.
     */
    showSkirts: boolean;
    /**
     * Whether to cull back-facing terrain. Back faces are not culled when the camera is underground or translucency is enabled.
     */
    backFaceCulling: boolean;
    /**
     * Determines the darkness of the vertex shadow.
     * This only takes effect when <code>enableLighting</code> is <code>true</code>.
     */
    vertexShadowDarkness: number;
    /**
     * Gets an ellipsoid describing the shape of this globe.
     */
    ellipsoid: Ellipsoid;
    /**
     * Gets the collection of image layers that will be rendered on this globe.
     */
    imageryLayers: ImageryLayerCollection;
    /**
     * Gets an event that's raised when an imagery layer is added, shown, hidden, moved, or removed.
     */
    readonly imageryLayersUpdatedEvent: Event;
    /**
     * Returns <code>true</code> when the tile load queue is empty, <code>false</code> otherwise.  When the load queue is empty,
     * all terrain and imagery for the current view have been loaded.
     */
    readonly tilesLoaded: boolean;
    /**
     * Gets or sets the color of the globe when no imagery is available.
     */
    baseColor: Color;
    /**
     * A property specifying a {@link ClippingPlaneCollection} used to selectively disable rendering on the outside of each plane.
     */
    clippingPlanes: ClippingPlaneCollection;
    /**
     * A property specifying a {@link Rectangle} used to limit globe rendering to a cartographic area.
     * Defaults to the maximum extent of cartographic coordinates.
     */
    cartographicLimitRectangle: Rectangle;
    /**
     * The normal map to use for rendering waves in the ocean.  Setting this property will
     * only have an effect if the configured terrain provider includes a water mask.
     */
    oceanNormalMapUrl: string;
    /**
     * The terrain provider providing surface geometry for this globe.
     */
    terrainProvider: TerrainProvider;
    /**
     * Gets an event that's raised when the terrain provider is changed
     */
    readonly terrainProviderChanged: Event;
    /**
     * Gets an event that's raised when the length of the tile load queue has changed since the last render frame.  When the load queue is empty,
     * all terrain and imagery for the current view have been loaded.  The event passes the new length of the tile load queue.
     */
    tileLoadProgressEvent: Event;
    /**
     * Gets or sets the material appearance of the Globe.  This can be one of several built-in {@link Material} objects or a custom material, scripted with
     * {@link https://github.com/CesiumGS/cesium/wiki/Fabric|Fabric}.
     */
    material: Material | undefined;
    /**
     * The color to render the back side of the globe when the camera is underground or the globe is translucent,
     * blended with the globe color based on the camera's distance.
     * <br /><br />
     * To disable underground coloring, set <code>undergroundColor</code> to <code>undefined</code>.
     */
    undergroundColor: Color;
    /**
     * Gets or sets the near and far distance for blending {@link Globe#undergroundColor} with the globe color.
     * The alpha will interpolate between the {@link NearFarScalar#nearValue} and
     * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
     * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
     * Outside of these ranges the alpha remains clamped to the nearest bound. If undefined,
     * the underground color will not be blended with the globe color.
     * <br /> <br />
     * When the camera is above the ellipsoid the distance is computed from the nearest
     * point on the ellipsoid instead of the camera's position.
     */
    undergroundColorAlphaByDistance: NearFarScalar;
    /**
     * Properties for controlling globe translucency.
     */
    translucency: GlobeTranslucency;
    /**
     * Find an intersection between a ray and the globe surface that was rendered. The ray must be given in world coordinates.
     * @example
     * // find intersection of ray through a pixel and the globe
     * const ray = viewer.camera.getPickRay(windowCoordinates);
     * const intersection = globe.pick(ray, scene);
     * @param ray - The ray to test for intersection.
     * @param scene - The scene.
     * @param [result] - The object onto which to store the result.
     * @returns The intersection or <code>undefined</code> if none was found.
     */
    pick(ray: Ray, scene: Scene, result?: Cartesian3): Cartesian3 | undefined;
    /**
     * Get the height of the surface at a given cartographic.
     * @param cartographic - The cartographic for which to find the height.
     * @returns The height of the cartographic or undefined if it could not be found.
     */
    getHeight(cartographic: Cartographic): number | undefined;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * @returns True if this object was destroyed; otherwise, false.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     * @example
     * globe = globe && globe.destroy();
     */
    destroy(): void;
}

/**
 * Properties for controlling globe translucency.
 */
export class GlobeTranslucency {
    constructor();
    /**
     * When true, the globe is rendered as a translucent surface.
     * <br /><br />
     * The alpha is computed by blending {@link Globe#material}, {@link Globe#imageryLayers},
     * and {@link Globe#baseColor}, all of which may contain translucency, and then multiplying by
     * {@link GlobeTranslucency#frontFaceAlpha} and {@link GlobeTranslucency#frontFaceAlphaByDistance} for front faces and
     * {@link GlobeTranslucency#backFaceAlpha} and {@link GlobeTranslucency#backFaceAlphaByDistance} for back faces.
     * When the camera is underground back faces and front faces are swapped, i.e. back-facing geometry
     * is considered front facing.
     * <br /><br />
     * Translucency is disabled by default.
     */
    enabled: boolean;
    /**
     * A constant translucency to apply to front faces of the globe.
     * <br /><br />
     * {@link GlobeTranslucency#enabled} must be set to true for this option to take effect.
     * @example
     * // Set front face translucency to 0.5.
     * globe.translucency.frontFaceAlpha = 0.5;
     * globe.translucency.enabled = true;
     */
    frontFaceAlpha: number;
    /**
     * Gets or sets near and far translucency properties of front faces of the globe based on the distance to the camera.
     * The translucency will interpolate between the {@link NearFarScalar#nearValue} and
     * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
     * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
     * Outside of these ranges the translucency remains clamped to the nearest bound.  If undefined,
     * frontFaceAlphaByDistance will be disabled.
     * <br /><br />
     * {@link GlobeTranslucency#enabled} must be set to true for this option to take effect.
     * @example
     * // Example 1.
     * // Set front face translucency to 0.5 when the
     * // camera is 1500 meters from the surface and 1.0
     * // as the camera distance approaches 8.0e6 meters.
     * globe.translucency.frontFaceAlphaByDistance = new Cesium.NearFarScalar(1.5e2, 0.5, 8.0e6, 1.0);
     * globe.translucency.enabled = true;
     * @example
     * // Example 2.
     * // Disable front face translucency by distance
     * globe.translucency.frontFaceAlphaByDistance = undefined;
     */
    frontFaceAlphaByDistance: NearFarScalar;
    /**
     * A constant translucency to apply to back faces of the globe.
     * <br /><br />
     * {@link GlobeTranslucency#enabled} must be set to true for this option to take effect.
     * @example
     * // Set back face translucency to 0.5.
     * globe.translucency.backFaceAlpha = 0.5;
     * globe.translucency.enabled = true;
     */
    backFaceAlpha: number;
    /**
     * Gets or sets near and far translucency properties of back faces of the globe based on the distance to the camera.
     * The translucency will interpolate between the {@link NearFarScalar#nearValue} and
     * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
     * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
     * Outside of these ranges the translucency remains clamped to the nearest bound.  If undefined,
     * backFaceAlphaByDistance will be disabled.
     * <br /><br />
     * {@link GlobeTranslucency#enabled} must be set to true for this option to take effect.
     * @example
     * // Example 1.
     * // Set back face translucency to 0.5 when the
     * // camera is 1500 meters from the surface and 1.0
     * // as the camera distance approaches 8.0e6 meters.
     * globe.translucency.backFaceAlphaByDistance = new Cesium.NearFarScalar(1.5e2, 0.5, 8.0e6, 1.0);
     * globe.translucency.enabled = true;
     * @example
     * // Example 2.
     * // Disable back face translucency by distance
     * globe.translucency.backFaceAlphaByDistance = undefined;
     */
    backFaceAlphaByDistance: NearFarScalar;
    /**
     * A property specifying a {@link Rectangle} used to limit translucency to a cartographic area.
     * Defaults to the maximum extent of cartographic coordinates.
     */
    rectangle: Rectangle;
}

/**
 * Loads the gltf object
 */
export function loadGltfJson(): void;

/**
 * Removes an extension from gltf.extensions, gltf.extensionsUsed, gltf.extensionsRequired, and any other objects in the glTF if it is present.
 * @param gltf - A javascript object containing a glTF asset.
 * @param extension - The extension to remove.
 * @returns The extension data removed from gltf.extensions.
 */
export function removeExtension(gltf: any, extension: string): any;

export namespace GoogleEarthEnterpriseImageryProvider {
    /**
     * Initialization options for the GoogleEarthEnterpriseImageryProvider constructor
     * [ellipsoid] - The ellipsoid.  If not specified, the WGS84 ellipsoid is used.
     * [tileDiscardPolicy] - The policy that determines if a tile
     *        is invalid and should be discarded. If this value is not specified, a default
     *        is to discard tiles that fail to download.
     * [credit] - A credit for the data source, which is displayed on the canvas.
     */
    type ConstructorOptions = {
        ellipsoid?: Ellipsoid;
        tileDiscardPolicy?: TileDiscardPolicy;
        credit?: Credit | string;
    };
}

/**
 * <div class="notice">
 * To construct a GoogleEarthEnterpriseImageryProvider, call {@link GoogleEarthEnterpriseImageryProvider.fromMetadata}. Do not call the constructor directly.
 * </div>
 *
 * Provides tiled imagery using the Google Earth Enterprise REST API.
 *
 * Notes: This provider is for use with the 3D Earth API of Google Earth Enterprise,
 *        {@link GoogleEarthEnterpriseMapsProvider} should be used with 2D Maps API.
 * @example
 * const geeMetadata = await GoogleEarthEnterpriseMetadata.fromUrl("http://www.example.com");
 * const gee = Cesium.GoogleEarthEnterpriseImageryProvider.fromMetadata(geeMetadata);
 * @param [options] - Object describing initialization options
 */
export class GoogleEarthEnterpriseImageryProvider {
    constructor(options?: GoogleEarthEnterpriseImageryProvider.ConstructorOptions);
    /**
     * Gets the name of the Google Earth Enterprise server url hosting the imagery.
     */
    readonly url: string;
    /**
     * Gets the proxy used by this provider.
     */
    readonly proxy: Proxy;
    /**
     * Gets the width of each tile, in pixels.
     */
    readonly tileWidth: number;
    /**
     * Gets the height of each tile, in pixels.
     */
    readonly tileHeight: number;
    /**
     * Gets the maximum level-of-detail that can be requested.
     */
    readonly maximumLevel: number | undefined;
    /**
     * Gets the minimum level-of-detail that can be requested.
     */
    readonly minimumLevel: number;
    /**
     * Gets the tiling scheme used by this provider.
     */
    readonly tilingScheme: TilingScheme;
    /**
     * Gets the rectangle, in radians, of the imagery provided by this instance.
     */
    readonly rectangle: Rectangle;
    /**
     * Gets the tile discard policy.  If not undefined, the discard policy is responsible
     * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
     * returns undefined, no tiles are filtered.
     */
    readonly tileDiscardPolicy: TileDiscardPolicy;
    /**
     * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
     * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
     * are passed an instance of {@link TileProviderError}.
     */
    readonly errorEvent: Event;
    /**
     * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
     * the source of the imagery.
     */
    readonly credit: Credit;
    /**
     * Gets a value indicating whether or not the images provided by this imagery provider
     * include an alpha channel.  If this property is false, an alpha channel, if present, will
     * be ignored.  If this property is true, any images without an alpha channel will be treated
     * as if their alpha is 1.0 everywhere.  Setting this property to false reduces memory usage
     * and texture upload time.
     */
    readonly hasAlphaChannel: boolean;
    /**
     * Creates a tiled imagery provider using the Google Earth Enterprise REST API.
     * @example
     * const geeMetadata = await GoogleEarthEnterpriseMetadata.fromUrl("http://www.example.com");
     * const gee = Cesium.GoogleEarthEnterpriseImageryProvider.fromMetadata(geeMetadata);
     * @param metadata - A metadata object that can be used to share metadata requests with a GoogleEarthEnterpriseTerrainProvider.
     * @param options - Object describing initialization options.
     */
    static fromMetadata(metadata: GoogleEarthEnterpriseMetadata, options: GoogleEarthEnterpriseImageryProvider.ConstructorOptions): GoogleEarthEnterpriseImageryProvider;
    /**
     * Gets the credits to be displayed when a given tile is displayed.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level;
     * @returns The credits to be displayed when the tile is displayed.
     */
    getTileCredits(x: number, y: number, level: number): Credit[];
    /**
     * Requests the image for a given tile.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level.
     * @param [request] - The request object. Intended for internal use only.
     * @returns A promise for the image that will resolve when the image is available, or
     *          undefined if there are too many active requests to the server, and the request should be retried later.
     */
    requestImage(x: number, y: number, level: number, request?: Request): Promise<ImageryTypes> | undefined;
    /**
     * Picking features is not currently supported by this imagery provider, so this function simply returns
     * undefined.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level.
     * @param longitude - The longitude at which to pick features.
     * @param latitude - The latitude at which to pick features.
     * @returns Undefined since picking is not supported.
     */
    pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): undefined;
}

export namespace GoogleEarthEnterpriseMapsProvider {
    /**
     * Initialization options for the GoogleEarthEnterpriseMapsProvider constructor
     * channel - The channel (id) to be used when requesting data from the server.
     *        The channel number can be found by looking at the json file located at:
     *        earth.localdomain/default_map/query?request=Json&vars=geeServerDefs The /default_map path may
     *        differ depending on your Google Earth Enterprise server configuration. Look for the "id" that
     *        is associated with a "ImageryMaps" requestType. There may be more than one id available.
     *        Example:
     *        {
     *          layers: [
     *            {
     *              id: 1002,
     *              requestType: "ImageryMaps"
     *            },
     *            {
     *              id: 1007,
     *              requestType: "VectorMapsRaster"
     *            }
     *          ]
     *        }
     * [path = "/default_map"] - The path of the Google Earth server hosting the imagery.
     * [maximumLevel] - The maximum level-of-detail supported by the Google Earth
     *        Enterprise server, or undefined if there is no limit.
     * [tileDiscardPolicy] - The policy that determines if a tile
     *        is invalid and should be discarded. To ensure that no tiles are discarded, construct and pass
     *        a {@link NeverTileDiscardPolicy} for this parameter.
     * [ellipsoid] - The ellipsoid.  If not specified, the WGS84 ellipsoid is used.
     */
    type ConstructorOptions = {
        channel: number;
        path?: string;
        maximumLevel?: number;
        tileDiscardPolicy?: TileDiscardPolicy;
        ellipsoid?: Ellipsoid;
    };
}

/**
 * <div class="notice">
 * To construct a GoogleEarthEnterpriseMapsProvider, call {@link GoogleEarthEnterpriseImageryProvider.fromUrl}. Do not call the constructor directly.
 * </div>
 *
 * Provides tiled imagery using the Google Earth Imagery API.
 *
 * Notes: This imagery provider does not work with the public Google Earth servers. It works with the
 *        Google Earth Enterprise Server.
 *
 *        By default the Google Earth Enterprise server does not set the
 *        {@link http://www.w3.org/TR/cors/|Cross-Origin Resource Sharing} headers. You can either
 *        use a proxy server which adds these headers, or in the /opt/google/gehttpd/conf/gehttpd.conf
 *        and add the 'Header set Access-Control-Allow-Origin "*"' option to the '&lt;Directory /&gt;' and
 *        '&lt;Directory "/opt/google/gehttpd/htdocs"&gt;' directives.
 *
 *        This provider is for use with 2D Maps API as part of Google Earth Enterprise. For 3D Earth API uses, it
 *        is necessary to use {@link GoogleEarthEnterpriseImageryProvider}
 * @example
 * const google = await Cesium.GoogleEarthEnterpriseMapsProvider.fromUrl("https://earth.localdomain", 1008);
 * @param options - Object describing initialization options
 */
export class GoogleEarthEnterpriseMapsProvider {
    constructor(options: GoogleEarthEnterpriseMapsProvider.ConstructorOptions);
    /**
     * Gets the URL of the Google Earth MapServer.
     */
    readonly url: string;
    /**
     * Gets the url path of the data on the Google Earth server.
     */
    readonly path: string;
    /**
     * Gets the proxy used by this provider.
     */
    readonly proxy: Proxy;
    /**
     * Gets the imagery channel (id) currently being used.
     */
    readonly channel: number;
    /**
     * Gets the width of each tile, in pixels.
     */
    readonly tileWidth: number;
    /**
     * Gets the height of each tile, in pixels.
     */
    readonly tileHeight: number;
    /**
     * Gets the maximum level-of-detail that can be requested.
     */
    readonly maximumLevel: number | undefined;
    /**
     * Gets the minimum level-of-detail that can be requested.
     */
    readonly minimumLevel: number;
    /**
     * Gets the tiling scheme used by this provider.
     */
    readonly tilingScheme: TilingScheme;
    /**
     * Gets the version of the data used by this provider.
     */
    readonly version: number;
    /**
     * Gets the type of data that is being requested from the provider.
     */
    readonly requestType: string;
    /**
     * Gets the rectangle, in radians, of the imagery provided by this instance.
     */
    readonly rectangle: Rectangle;
    /**
     * Gets the tile discard policy.  If not undefined, the discard policy is responsible
     * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
     * returns undefined, no tiles are filtered.
     */
    readonly tileDiscardPolicy: TileDiscardPolicy;
    /**
     * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
     * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
     * are passed an instance of {@link TileProviderError}.
     */
    readonly errorEvent: Event;
    /**
     * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
     * the source of the imagery.
     */
    readonly credit: Credit;
    /**
     * Gets a value indicating whether or not the images provided by this imagery provider
     * include an alpha channel.  If this property is false, an alpha channel, if present, will
     * be ignored.  If this property is true, any images without an alpha channel will be treated
     * as if their alpha is 1.0 everywhere.  When this property is false, memory usage
     * and texture upload time are reduced.
     */
    readonly hasAlphaChannel: boolean;
    /**
     * Creates a tiled imagery provider using the Google Earth Imagery API.
     * @example
     * const google = await Cesium.GoogleEarthEnterpriseMapsProvider.fromUrl("https://earth.localdomain", 1008);
     * @param url - The url of the Google Earth server hosting the imagery.
     * @param [options] - Object describing initialization options
     * @returns The created GoogleEarthEnterpriseMapsProvider.
     */
    static fromUrl(url: Resource | string, options?: GoogleEarthEnterpriseMapsProvider.ConstructorOptions): Promise<GoogleEarthEnterpriseMapsProvider>;
    /**
     * Gets the credits to be displayed when a given tile is displayed.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level;
     * @returns The credits to be displayed when the tile is displayed.
     */
    getTileCredits(x: number, y: number, level: number): Credit[];
    /**
     * Requests the image for a given tile.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level.
     * @param [request] - The request object. Intended for internal use only.
     * @returns A promise for the image that will resolve when the image is available, or
     *          undefined if there are too many active requests to the server, and the request should be retried later.
     */
    requestImage(x: number, y: number, level: number, request?: Request): Promise<ImageryTypes> | undefined;
    /**
     * Picking features is not currently supported by this imagery provider, so this function simply returns
     * undefined.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level.
     * @param longitude - The longitude at which to pick features.
     * @param latitude - The latitude at which to pick features.
     * @returns Undefined since picking is not supported.
     */
    pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): undefined;
    /**
     * Gets or sets the URL to the Google Earth logo for display in the credit.
     */
    static logoUrl: string;
}

export namespace GridImageryProvider {
    /**
     * Initialization options for the GridImageryProvider constructor
     * [tilingScheme = new GeographicTilingScheme()] - The tiling scheme for which to draw tiles.
     * [ellipsoid] - The ellipsoid.  If the tilingScheme is specified,
     *                    this parameter is ignored and the tiling scheme's ellipsoid is used instead. If neither
     *                    parameter is specified, the WGS84 ellipsoid is used.
     * [cells = 8] - The number of grids cells.
     * [color = Color(1.0, 1.0, 1.0, 0.4)] - The color to draw grid lines.
     * [glowColor = Color(0.0, 1.0, 0.0, 0.05)] - The color to draw glow for grid lines.
     * [glowWidth = 6] - The width of lines used for rendering the line glow effect.
     * [backgroundColor = Color(0.0, 0.5, 0.0, 0.2)] - Background fill color.
     * [tileWidth = 256] - The width of the tile for level-of-detail selection purposes.
     * [tileHeight = 256] - The height of the tile for level-of-detail selection purposes.
     * [canvasSize = 256] - The size of the canvas used for rendering.
     */
    type ConstructorOptions = {
        tilingScheme?: TilingScheme;
        ellipsoid?: Ellipsoid;
        cells?: number;
        color?: Color;
        glowColor?: Color;
        glowWidth?: number;
        backgroundColor?: Color;
        tileWidth?: number;
        tileHeight?: number;
        canvasSize?: number;
    };
}

/**
 * An {@link ImageryProvider} that draws a wireframe grid on every tile with controllable background and glow.
 * May be useful for custom rendering effects or debugging terrain.
 * @param options - Object describing initialization options
 */
export class GridImageryProvider {
    constructor(options: GridImageryProvider.ConstructorOptions);
    /**
     * Gets the proxy used by this provider.
     */
    readonly proxy: Proxy;
    /**
     * Gets the width of each tile, in pixels.
     */
    readonly tileWidth: number;
    /**
     * Gets the height of each tile, in pixels.
     */
    readonly tileHeight: number;
    /**
     * Gets the maximum level-of-detail that can be requested.
     */
    readonly maximumLevel: number | undefined;
    /**
     * Gets the minimum level-of-detail that can be requested.
     */
    readonly minimumLevel: number;
    /**
     * Gets the tiling scheme used by this provider.
     */
    readonly tilingScheme: TilingScheme;
    /**
     * Gets the rectangle, in radians, of the imagery provided by this instance.
     */
    readonly rectangle: Rectangle;
    /**
     * Gets the tile discard policy.  If not undefined, the discard policy is responsible
     * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
     * returns undefined, no tiles are filtered.
     */
    readonly tileDiscardPolicy: TileDiscardPolicy;
    /**
     * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
     * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
     * are passed an instance of {@link TileProviderError}.
     */
    readonly errorEvent: Event;
    /**
     * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
     * the source of the imagery.
     */
    readonly credit: Credit;
    /**
     * Gets a value indicating whether or not the images provided by this imagery provider
     * include an alpha channel.  If this property is false, an alpha channel, if present, will
     * be ignored.  If this property is true, any images without an alpha channel will be treated
     * as if their alpha is 1.0 everywhere.  When this property is false, memory usage
     * and texture upload time are reduced.
     */
    readonly hasAlphaChannel: boolean;
    /**
     * Draws a grid of lines into a canvas.
     */
    _drawGrid(): void;
    /**
     * Render a grid into a canvas with background and glow
     */
    _createGridCanvas(): void;
    /**
     * Gets the credits to be displayed when a given tile is displayed.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level;
     * @returns The credits to be displayed when the tile is displayed.
     */
    getTileCredits(x: number, y: number, level: number): Credit[];
    /**
     * Requests the image for a given tile.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level.
     * @param [request] - The request object. Intended for internal use only.
     * @returns The resolved image as a Canvas DOM object.
     */
    requestImage(x: number, y: number, level: number, request?: Request): Promise<HTMLCanvasElement>;
    /**
     * Picking features is not currently supported by this imagery provider, so this function simply returns
     * undefined.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level.
     * @param longitude - The longitude at which to pick features.
     * @param latitude - The latitude at which to pick features.
     * @returns Undefined since picking is not supported.
     */
    pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): undefined;
}

/**
 * A GroundPolylinePrimitive represents a polyline draped over the terrain or 3D Tiles in the {@link Scene}.
 * <p>
 * Only to be used with GeometryInstances containing {@link GroundPolylineGeometry}.
 * </p>
 * @example
 * // 1. Draw a polyline on terrain with a basic color material
 *
 * const instance = new Cesium.GeometryInstance({
 *   geometry : new Cesium.GroundPolylineGeometry({
 *      positions : Cesium.Cartesian3.fromDegreesArray([
 *          -112.1340164450331, 36.05494287836128,
 *          -112.08821010582645, 36.097804071380715
 *      ]),
 *      width : 4.0
 *   }),
 *   id : 'object returned when this instance is picked and to get/set per-instance attributes'
 * });
 *
 * scene.groundPrimitives.add(new Cesium.GroundPolylinePrimitive({
 *   geometryInstances : instance,
 *   appearance : new Cesium.PolylineMaterialAppearance()
 * }));
 *
 * // 2. Draw a looped polyline on terrain with per-instance color and a distance display condition.
 * // Distance display conditions for polylines on terrain are based on an approximate terrain height
 * // instead of true terrain height.
 *
 * const instance2 = new Cesium.GeometryInstance({
 *   geometry : new Cesium.GroundPolylineGeometry({
 *      positions : Cesium.Cartesian3.fromDegreesArray([
 *          -112.1340164450331, 36.05494287836128,
 *          -112.08821010582645, 36.097804071380715,
 *          -112.13296079730024, 36.168769146801104
 *      ]),
 *      loop : true,
 *      width : 4.0
 *   }),
 *   attributes : {
 *      color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.fromCssColorString('green').withAlpha(0.7)),
 *      distanceDisplayCondition : new Cesium.DistanceDisplayConditionGeometryInstanceAttribute(1000, 30000)
 *   },
 *   id : 'object returned when this instance is picked and to get/set per-instance attributes'
 * });
 *
 * scene.groundPrimitives.add(new Cesium.GroundPolylinePrimitive({
 *   geometryInstances : instance2,
 *   appearance : new Cesium.PolylineColorAppearance()
 * }));
 * @param [options] - Object with the following properties:
 * @param [options.geometryInstances] - GeometryInstances containing GroundPolylineGeometry
 * @param [options.appearance] - The Appearance used to render the polyline. Defaults to a white color {@link Material} on a {@link PolylineMaterialAppearance}.
 * @param [options.show = true] - Determines if this primitive will be shown.
 * @param [options.interleave = false] - When <code>true</code>, geometry vertex attributes are interleaved, which can slightly improve rendering performance but increases load time.
 * @param [options.releaseGeometryInstances = true] - When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.
 * @param [options.allowPicking = true] - When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.
 * @param [options.asynchronous = true] - Determines if the primitive will be created asynchronously or block until ready. If false initializeTerrainHeights() must be called first.
 * @param [options.classificationType = ClassificationType.BOTH] - Determines whether terrain, 3D Tiles or both will be classified.
 * @param [options.debugShowBoundingVolume = false] - For debugging only. Determines if this primitive's commands' bounding spheres are shown.
 * @param [options.debugShowShadowVolume = false] - For debugging only. Determines if the shadow volume for each geometry in the primitive is drawn. Must be <code>true</code> on creation to have effect.
 */
export class GroundPolylinePrimitive {
    constructor(options?: {
        geometryInstances?: any[] | GeometryInstance;
        appearance?: Appearance;
        show?: boolean;
        interleave?: boolean;
        releaseGeometryInstances?: boolean;
        allowPicking?: boolean;
        asynchronous?: boolean;
        classificationType?: ClassificationType;
        debugShowBoundingVolume?: boolean;
        debugShowShadowVolume?: boolean;
    });
    /**
     * The geometry instances rendered with this primitive. This may
     * be <code>undefined</code> if <code>options.releaseGeometryInstances</code>
     * is <code>true</code> when the primitive is constructed.
     * <p>
     * Changing this property after the primitive is rendered has no effect.
     * </p>
     */
    readonly geometryInstances: any[] | GeometryInstance;
    /**
     * The {@link Appearance} used to shade this primitive. Each geometry
     * instance is shaded with the same appearance.  Some appearances, like
     * {@link PolylineColorAppearance} allow giving each instance unique
     * properties.
     */
    appearance: Appearance;
    /**
     * Determines if the primitive will be shown.  This affects all geometry
     * instances in the primitive.
     */
    show: boolean;
    /**
     * Determines whether terrain, 3D Tiles or both will be classified.
     */
    classificationType: ClassificationType;
    /**
     * This property is for debugging only; it is not for production use nor is it optimized.
     * <p>
     * Draws the bounding sphere for each draw command in the primitive.
     * </p>
     */
    debugShowBoundingVolume: boolean;
    /**
     * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.
     */
    readonly interleave: boolean;
    /**
     * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.
     */
    readonly releaseGeometryInstances: boolean;
    /**
     * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.
     */
    readonly allowPicking: boolean;
    /**
     * Determines if the geometry instances will be created and batched on a web worker.
     */
    readonly asynchronous: boolean;
    /**
     * Determines if the primitive is complete and ready to render.  If this property is
     * true, the primitive will be rendered the next time that {@link GroundPolylinePrimitive#update}
     * is called.
     */
    readonly ready: boolean;
    /**
     * This property is for debugging only; it is not for production use nor is it optimized.
     * <p>
     * If true, draws the shadow volume for each geometry in the primitive.
     * </p>
     */
    readonly debugShowShadowVolume: boolean;
    /**
     * Initializes the minimum and maximum terrain heights. This only needs to be called if you are creating the
     * GroundPolylinePrimitive synchronously.
     * @returns A promise that will resolve once the terrain heights have been loaded.
     */
    static initializeTerrainHeights(): Promise<void>;
    /**
     * Called when {@link Viewer} or {@link CesiumWidget} render the scene to
     * get the draw commands needed to render this primitive.
     * <p>
     * Do not call this function directly.  This is documented just to
     * list the exceptions that may be propagated when the scene is rendered:
     * </p>
     */
    update(): void;
    /**
     * Returns the modifiable per-instance attributes for a {@link GeometryInstance}.
     * @example
     * const attributes = primitive.getGeometryInstanceAttributes('an id');
     * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);
     * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);
     * @param id - The id of the {@link GeometryInstance}.
     * @returns The typed array in the attribute's format or undefined if the is no instance with id.
     */
    getGeometryInstanceAttributes(id: any): any;
    /**
     * Checks if the given Scene supports GroundPolylinePrimitives.
     * GroundPolylinePrimitives require support for the WEBGL_depth_texture extension.
     * @param scene - The current scene.
     * @returns Whether or not the current scene supports GroundPolylinePrimitives.
     */
    static isSupported(scene: Scene): boolean;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <p>
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * </p>
     * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <p>
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     * </p>
     * @example
     * e = e && e.destroy();
     */
    destroy(): void;
}

/**
 * A ground primitive represents geometry draped over terrain or 3D Tiles in the {@link Scene}.
 * <p>
 * A primitive combines geometry instances with an {@link Appearance} that describes the full shading, including
 * {@link Material} and {@link RenderState}.  Roughly, the geometry instance defines the structure and placement,
 * and the appearance defines the visual characteristics.  Decoupling geometry and appearance allows us to mix
 * and match most of them and add a new geometry or appearance independently of each other.
 * </p>
 * <p>
 * Support for the WEBGL_depth_texture extension is required to use GeometryInstances with different PerInstanceColors
 * or materials besides PerInstanceColorAppearance.
 * </p>
 * <p>
 * Textured GroundPrimitives were designed for notional patterns and are not meant for precisely mapping
 * textures to terrain - for that use case, use {@link SingleTileImageryProvider}.
 * </p>
 * <p>
 * For correct rendering, this feature requires the EXT_frag_depth WebGL extension. For hardware that do not support this extension, there
 * will be rendering artifacts for some viewing angles.
 * </p>
 * <p>
 * Valid geometries are {@link CircleGeometry}, {@link CorridorGeometry}, {@link EllipseGeometry}, {@link PolygonGeometry}, and {@link RectangleGeometry}.
 * </p>
 * @example
 * // Example 1: Create primitive with a single instance
 * const rectangleInstance = new Cesium.GeometryInstance({
 *   geometry : new Cesium.RectangleGeometry({
 *     rectangle : Cesium.Rectangle.fromDegrees(-140.0, 30.0, -100.0, 40.0)
 *   }),
 *   id : 'rectangle',
 *   attributes : {
 *     color : new Cesium.ColorGeometryInstanceAttribute(0.0, 1.0, 1.0, 0.5)
 *   }
 * });
 * scene.primitives.add(new Cesium.GroundPrimitive({
 *   geometryInstances : rectangleInstance
 * }));
 *
 * // Example 2: Batch instances
 * const color = new Cesium.ColorGeometryInstanceAttribute(0.0, 1.0, 1.0, 0.5); // Both instances must have the same color.
 * const rectangleInstance = new Cesium.GeometryInstance({
 *   geometry : new Cesium.RectangleGeometry({
 *     rectangle : Cesium.Rectangle.fromDegrees(-140.0, 30.0, -100.0, 40.0)
 *   }),
 *   id : 'rectangle',
 *   attributes : {
 *     color : color
 *   }
 * });
 * const ellipseInstance = new Cesium.GeometryInstance({
 *     geometry : new Cesium.EllipseGeometry({
 *         center : Cesium.Cartesian3.fromDegrees(-105.0, 40.0),
 *         semiMinorAxis : 300000.0,
 *         semiMajorAxis : 400000.0
 *     }),
 *     id : 'ellipse',
 *     attributes : {
 *         color : color
 *     }
 * });
 * scene.primitives.add(new Cesium.GroundPrimitive({
 *   geometryInstances : [rectangleInstance, ellipseInstance]
 * }));
 * @param [options] - Object with the following properties:
 * @param [options.geometryInstances] - The geometry instances to render.
 * @param [options.appearance] - The appearance used to render the primitive. Defaults to a flat PerInstanceColorAppearance when GeometryInstances have a color attribute.
 * @param [options.show = true] - Determines if this primitive will be shown.
 * @param [options.vertexCacheOptimize = false] - When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.
 * @param [options.interleave = false] - When <code>true</code>, geometry vertex attributes are interleaved, which can slightly improve rendering performance but increases load time.
 * @param [options.compressVertices = true] - When <code>true</code>, the geometry vertices are compressed, which will save memory.
 * @param [options.releaseGeometryInstances = true] - When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.
 * @param [options.allowPicking = true] - When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.
 * @param [options.asynchronous = true] - Determines if the primitive will be created asynchronously or block until ready. If false initializeTerrainHeights() must be called first.
 * @param [options.classificationType = ClassificationType.BOTH] - Determines whether terrain, 3D Tiles or both will be classified.
 * @param [options.debugShowBoundingVolume = false] - For debugging only. Determines if this primitive's commands' bounding spheres are shown.
 * @param [options.debugShowShadowVolume = false] - For debugging only. Determines if the shadow volume for each geometry in the primitive is drawn. Must be <code>true</code> on
 *                  creation for the volumes to be created before the geometry is released or options.releaseGeometryInstance must be <code>false</code>.
 */
export class GroundPrimitive {
    constructor(options?: {
        geometryInstances?: any[] | GeometryInstance;
        appearance?: Appearance;
        show?: boolean;
        vertexCacheOptimize?: boolean;
        interleave?: boolean;
        compressVertices?: boolean;
        releaseGeometryInstances?: boolean;
        allowPicking?: boolean;
        asynchronous?: boolean;
        classificationType?: ClassificationType;
        debugShowBoundingVolume?: boolean;
        debugShowShadowVolume?: boolean;
    });
    /**
     * The {@link Appearance} used to shade this primitive. Each geometry
     * instance is shaded with the same appearance.  Some appearances, like
     * {@link PerInstanceColorAppearance} allow giving each instance unique
     * properties.
     */
    appearance: Appearance;
    /**
     * The geometry instances rendered with this primitive.  This may
     * be <code>undefined</code> if <code>options.releaseGeometryInstances</code>
     * is <code>true</code> when the primitive is constructed.
     * <p>
     * Changing this property after the primitive is rendered has no effect.
     * </p>
     */
    readonly geometryInstances: any[] | GeometryInstance;
    /**
     * Determines if the primitive will be shown.  This affects all geometry
     * instances in the primitive.
     */
    show: boolean;
    /**
     * Determines whether terrain, 3D Tiles or both will be classified.
     */
    classificationType: ClassificationType;
    /**
     * This property is for debugging only; it is not for production use nor is it optimized.
     * <p>
     * Draws the bounding sphere for each draw command in the primitive.
     * </p>
     */
    debugShowBoundingVolume: boolean;
    /**
     * This property is for debugging only; it is not for production use nor is it optimized.
     * <p>
     * Draws the shadow volume for each geometry in the primitive.
     * </p>
     */
    debugShowShadowVolume: boolean;
    /**
     * When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.
     */
    readonly vertexCacheOptimize: boolean;
    /**
     * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.
     */
    readonly interleave: boolean;
    /**
     * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.
     */
    readonly releaseGeometryInstances: boolean;
    /**
     * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.
     */
    readonly allowPicking: boolean;
    /**
     * Determines if the geometry instances will be created and batched on a web worker.
     */
    readonly asynchronous: boolean;
    /**
     * When <code>true</code>, geometry vertices are compressed, which will save memory.
     */
    readonly compressVertices: boolean;
    /**
     * Determines if the primitive is complete and ready to render.  If this property is
     * true, the primitive will be rendered the next time that {@link GroundPrimitive#update}
     * is called.
     */
    readonly ready: boolean;
    /**
     * Determines if GroundPrimitive rendering is supported.
     * @param scene - The scene.
     * @returns <code>true</code> if GroundPrimitives are supported; otherwise, returns <code>false</code>
     */
    static isSupported(scene: Scene): boolean;
    /**
     * Initializes the minimum and maximum terrain heights. This only needs to be called if you are creating the
     * GroundPrimitive synchronously.
     * @returns A promise that will resolve once the terrain heights have been loaded.
     */
    static initializeTerrainHeights(): Promise<void>;
    /**
     * Called when {@link Viewer} or {@link CesiumWidget} render the scene to
     * get the draw commands needed to render this primitive.
     * <p>
     * Do not call this function directly.  This is documented just to
     * list the exceptions that may be propagated when the scene is rendered:
     * </p>
     */
    update(): void;
    /**
     * Returns the modifiable per-instance attributes for a {@link GeometryInstance}.
     * @example
     * const attributes = primitive.getGeometryInstanceAttributes('an id');
     * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);
     * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);
     * @param id - The id of the {@link GeometryInstance}.
     * @returns The typed array in the attribute's format or undefined if the is no instance with id.
     */
    getGeometryInstanceAttributes(id: any): any;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <p>
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * </p>
     * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <p>
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     * </p>
     * @example
     * e = e && e.destroy();
     */
    destroy(): void;
    /**
     * Checks if the given Scene supports materials on GroundPrimitives.
     * Materials on GroundPrimitives require support for the WEBGL_depth_texture extension.
     * @param scene - The current scene.
     * @returns Whether or not the current scene supports materials on GroundPrimitives.
     */
    static supportsMaterials(scene: Scene): boolean;
}

/**
 * Represents the position relative to the terrain.
 */
export enum HeightReference {
    /**
     * The position is absolute.
     */
    NONE = 0,
    /**
     * The position is clamped to the terrain.
     */
    CLAMP_TO_GROUND = 1,
    /**
     * The position height is the height above the terrain.
     */
    RELATIVE_TO_GROUND = 2
}

/**
 * The horizontal location of an origin relative to an object, e.g., a {@link Billboard}
 * or {@link Label}.  For example, setting the horizontal origin to <code>LEFT</code>
 * or <code>RIGHT</code> will display a billboard to the left or right (in screen space)
 * of the anchor position.
 * <br /><br />
 * <div align='center'>
 * <img src='Images/Billboard.setHorizontalOrigin.png' width='648' height='196' /><br />
 * </div>
 */
export enum HorizontalOrigin {
    /**
     * The origin is at the horizontal center of the object.
     */
    CENTER = 0,
    /**
     * The origin is on the left side of the object.
     */
    LEFT = 1,
    /**
     * The origin is on the right side of the object.
     */
    RIGHT = -1
}

export namespace I3SDataProvider {
    /**
     * Initialization options for the I3SDataProvider constructor
     * [name] - The name of the I3S dataset.
     * [show = true] - Determines if the dataset will be shown.
     * [geoidTiledTerrainProvider] - Tiled elevation provider describing an Earth Gravitational Model. If defined, geometry will be shifted based on the offsets given by this provider. Required to position I3S data sets with gravity-related height at the correct location.
     * [traceFetches = false] - Debug option. When true, log a message whenever an I3S tile is fetched.
     * [cesium3dTilesetOptions] - Object containing options to pass to an internally created {@link Cesium3DTileset}. See {@link Cesium3DTileset} for list of valid properties. All options can be used with the exception of <code>url</code> and <code>show</code> which are overridden by values from I3SDataProvider.
     */
    type ConstructorOptions = {
        name?: string;
        show?: boolean;
        geoidTiledTerrainProvider?: ArcGISTiledElevationTerrainProvider | Promise<ArcGISTiledElevationTerrainProvider>;
        traceFetches?: boolean;
        cesium3dTilesetOptions?: Cesium3DTileset.ConstructorOptions;
    };
}

/**
 * An I3SDataProvider is the main public class for I3S support. The url option
 * should return a scene object. Currently supported I3S versions are 1.6 and
 * 1.7/1.8 (OGC I3S 1.2). I3SFeature and I3SNode classes implement the
 * Object Model for I3S entities, with public interfaces.
 *
 * <div class="notice">
 * This object is normally not instantiated directly, use {@link I3SDataProvider.fromUrl}.
 * </div>
 * @example
 * try {
 *   const i3sData = await I3SDataProvider.fromUrl(
 *     "https://tiles.arcgis.com/tiles/z2tnIkrLQ2BRzr6P/arcgis/rest/services/Frankfurt2017_vi3s_18/SceneServer/layers/0"
 *   );
 *   viewer.scene.primitives.add(i3sData);
 * } catch (error) {
 *   console.log(`There was an error creating the I3S Data Provider: ${error}`);
 * }
 * @example
 * try {
 *   const geoidService = await Cesium.ArcGISTiledElevationTerrainProvider.fromUrl(
 *     "https://tiles.arcgis.com/tiles/z2tnIkrLQ2BRzr6P/arcgis/rest/services/EGM2008/ImageServer"
 *   );
 *   const i3sData = await I3SDataProvider.fromUrl(
 *     "https://tiles.arcgis.com/tiles/z2tnIkrLQ2BRzr6P/arcgis/rest/services/Frankfurt2017_vi3s_18/SceneServer/layers/0", {
 *       geoidTiledTerrainProvider: geoidService
 *   });
 *   viewer.scene.primitives.add(i3sData);
 * } catch (error) {
 *   console.log(`There was an error creating the I3S Data Provider: ${error}`);
 * }
 * @param options - An object describing initialization options
 */
export class I3SDataProvider {
    constructor(options: I3SDataProvider.ConstructorOptions);
    /**
     * Gets a human-readable name for this dataset.
     */
    readonly name: string;
    /**
     * Determines if the dataset will be shown.
     */
    show: boolean;
    /**
     * Gets or sets debugging and tracing of I3S fetches.
     */
    traceFetches: boolean;
    /**
     * The terrain provider referencing the GEOID service to be used for orthometric to ellipsoidal conversion.
     */
    readonly geoidTiledTerrainProvider: ArcGISTiledElevationTerrainProvider;
    /**
     * Gets the collection of layers.
     */
    readonly layers: I3SLayer[];
    /**
     * Gets the I3S data for this object.
     */
    readonly data: any;
    /**
     * Gets the extent covered by this I3S.
     */
    readonly extent: Rectangle;
    /**
     * The resource used to fetch the I3S dataset.
     */
    readonly resource: Resource;
    /**
     * Destroys the WebGL resources held by this object. Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <p>
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception. Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     * </p>
     */
    destroy(): void;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <p>
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * </p>
     * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     */
    isDestroyed(): boolean;
    /**
     * Creates an I3SDataProvider. Currently supported I3S versions are 1.6 and
     * 1.7/1.8 (OGC I3S 1.2).
     * @example
     * try {
     *   const i3sData = await I3SDataProvider.fromUrl(
     *     "https://tiles.arcgis.com/tiles/z2tnIkrLQ2BRzr6P/arcgis/rest/services/Frankfurt2017_vi3s_18/SceneServer/layers/0"
     *   );
     *   viewer.scene.primitives.add(i3sData);
     * } catch (error) {
     *   console.log(`There was an error creating the I3S Data Provider: ${error}`);
     * }
     * @example
     * try {
     *   const geoidService = await Cesium.ArcGISTiledElevationTerrainProvider.fromUrl(
     *     "https://tiles.arcgis.com/tiles/z2tnIkrLQ2BRzr6P/arcgis/rest/services/EGM2008/ImageServer"
     *   );
     *   const i3sData = await I3SDataProvider.fromUrl(
     *     "https://tiles.arcgis.com/tiles/z2tnIkrLQ2BRzr6P/arcgis/rest/services/Frankfurt2017_vi3s_18/SceneServer/layers/0", {
     *       geoidTiledTerrainProvider: geoidService
     *   });
     *   viewer.scene.primitives.add(i3sData);
     * } catch (error) {
     *   console.log(`There was an error creating the I3S Data Provider: ${error}`);
     * }
     * @param url - The url of the I3S dataset, which should return an I3S scene object
     * @param options - An object describing initialization options
     */
    static fromUrl(url: string | Resource, options: I3SDataProvider.ConstructorOptions): Promise<I3SDataProvider>;
}

/**
 * This class implements an I3S Feature.
 * <p>
 * Do not construct this directly, instead access tiles through {@link I3SNode}.
 * </p>
 */
export class I3SFeature {
    constructor();
    /**
     * Gets the resource for the feature
     */
    readonly resource: Resource;
    /**
     * Gets the I3S data for this object.
     */
    readonly data: any;
}

/**
 * This class implements an I3S Field which is custom data attached
 * to nodes
 */
export class I3SField {
    constructor();
    /**
     * Gets the resource for the fields
     */
    readonly resource: Resource;
    /**
     * Gets the header for this field.
     */
    readonly header: any;
    /**
     * Gets the values for this field.
     */
    readonly values: any;
    /**
     * Gets the name for the field.
     */
    readonly name: string;
    /**
     * Loads the content.
     * @returns A promise that is resolved when the field data is loaded
     */
    load(): Promise<void>;
}

/**
 * This class implements an I3S Geometry. Each I3SGeometry
 * generates an in memory glTF to be used as content for a Cesium3DTile
 * <p>
 * Do not construct this directly, instead access tiles through {@link I3SNode}.
 * </p>
 */
export class I3SGeometry {
    constructor();
    /**
     * Gets the resource for the geometry
     */
    readonly resource: Resource;
    /**
     * Gets the I3S data for this object.
     */
    readonly data: any;
    /**
     * Gets the custom attributes of the geometry.
     */
    readonly customAttributes: any;
    /**
     * Find a triangle touching the point [px, py, pz], then return the vertex closest to the search point
     * @param px - The x component of the point to query
     * @param py - The y component of the point to query
     * @param pz - The z component of the point to query
     * @returns A structure containing the index of the closest point,
     * the squared distance from the queried point to the point that is found,
     * the distance from the queried point to the point that is found,
     * the queried position in local space,
     * the closest position in local space
     */
    getClosestPointIndexOnTriangle(px: number, py: number, pz: number): any;
}

/**
 * This class implements an I3S layer. In CesiumJS each I3SLayer creates a Cesium3DTileset.
 * <p>
 * Do not construct this directly, instead access layers through {@link I3SDataProvider}.
 * </p>
 */
export class I3SLayer {
    constructor();
    /**
     * Gets the resource for the layer.
     */
    readonly resource: Resource;
    /**
     * Gets the root node of this layer.
     */
    readonly rootNode: I3SNode;
    /**
     * Gets the Cesium3DTileset for this layer.
     */
    readonly tileset: Cesium3DTileset | undefined;
    /**
     * Gets the I3S data for this object.
     */
    readonly data: any;
    /**
     * The version string of the loaded I3S dataset
     */
    readonly version: string;
    /**
     * The major version number of the loaded I3S dataset
     */
    readonly majorVersion: number;
    /**
     * The minor version number of the loaded I3S dataset
     */
    readonly minorVersion: number;
    /**
     * When <code>true</code>, when the loaded I3S version is 1.6 or older
     */
    readonly legacyVersion16: boolean;
}

/**
 * This class implements an I3S Node. In CesiumJS each I3SNode creates a Cesium3DTile.
 * <p>
 * Do not construct this directly, instead access tiles through {@link I3SLayer}.
 * </p>
 */
export class I3SNode {
    constructor();
    /**
     * Gets the resource for the node.
     */
    readonly resource: Resource;
    /**
     * Gets the parent layer.
     */
    readonly layer: I3SLayer;
    /**
     * Gets the parent node.
     */
    readonly parent: I3SNode | undefined;
    /**
     * Gets the children nodes.
     */
    readonly children: I3SNode[];
    /**
     * Gets the collection of geometries.
     */
    readonly geometryData: I3SGeometry[];
    /**
     * Gets the collection of features.
     */
    readonly featureData: I3SFeature[];
    /**
     * Gets the collection of fields.
     */
    readonly fields: I3SField[];
    /**
     * Gets the Cesium3DTile for this node.
     */
    readonly tile: Cesium3DTile;
    /**
     * Gets the I3S data for this object.
     */
    readonly data: any;
    /**
     * Loads the node fields.
     * @returns A promise that is resolved when the I3S Node fields are loaded
     */
    loadFields(): Promise<void>;
    /**
     * Returns the fields for a given picked position
     * @param pickedPosition - The picked position
     * @returns Object containing field names and their values
     */
    getFieldsForPickedPosition(pickedPosition: Cartesian3): any;
    /**
     * Returns the fields for a given feature
     * @param featureIndex - Index of the feature whose attributes we want to get
     * @returns Object containing field names and their values
     */
    getFieldsForFeature(featureIndex: number): any;
}

/**
 * Properties for managing image-based lighting on tilesets and models.
 * Also manages the necessary resources and textures.
 * <p>
 * If specular environment maps are used, {@link ImageBasedLighting#destroy} must be called
 * when the image-based lighting is no longer needed to clean up GPU resources properly.
 * If a model or tileset creates an instance of ImageBasedLighting, it will handle this.
 * Otherwise, the application is responsible for calling destroy().
 * </p>
 * @param [options.imageBasedLightingFactor = Cartesian2(1.0, 1.0)] - Scales diffuse and specular image-based lighting from the earth, sky, atmosphere and star skybox.
 * @param [options.luminanceAtZenith = 0.2] - The sun's luminance at the zenith in kilo candela per meter squared to use for this model's procedural environment map.
 * @param [options.sphericalHarmonicCoefficients] - The third order spherical harmonic coefficients used for the diffuse color of image-based lighting.
 * @param [options.specularEnvironmentMaps] - A URL to a KTX2 file that contains a cube map of the specular lighting and the convoluted specular mipmaps.
 */
export class ImageBasedLighting {
    constructor();
    /**
     * Cesium adds lighting from the earth, sky, atmosphere, and star skybox.
     * This cartesian is used to scale the final diffuse and specular lighting
     * contribution from those sources to the final color. A value of 0.0 will
     * disable those light sources.
     */
    imageBasedLightingFactor: Cartesian2;
    /**
     * The sun's luminance at the zenith in kilo candela per meter squared
     * to use for this model's procedural environment map. This is used when
     * {@link ImageBasedLighting#specularEnvironmentMaps} and {@link ImageBasedLighting#sphericalHarmonicCoefficients}
     * are not defined.
     */
    luminanceAtZenith: number;
    /**
     * The third order spherical harmonic coefficients used for the diffuse color of image-based lighting. When <code>undefined</code>, a diffuse irradiance
     * computed from the atmosphere color is used.
     * <p>
     * There are nine <code>Cartesian3</code> coefficients.
     * The order of the coefficients is: L<sub>0,0</sub>, L<sub>1,-1</sub>, L<sub>1,0</sub>, L<sub>1,1</sub>, L<sub>2,-2</sub>, L<sub>2,-1</sub>, L<sub>2,0</sub>, L<sub>2,1</sub>, L<sub>2,2</sub>
     * </p>
     *
     * These values can be obtained by preprocessing the environment map using the <code>cmgen</code> tool of
     * {@link https://github.com/google/filament/releases|Google's Filament project}. This will also generate a KTX file that can be
     * supplied to {@link Model#specularEnvironmentMaps}.
     */
    sphericalHarmonicCoefficients: Cartesian3[];
    /**
     * A URL to a KTX2 file that contains a cube map of the specular lighting and the convoluted specular mipmaps.
     */
    specularEnvironmentMaps: string;
}

export namespace ImageryLayer {
    /**
     * A function that is called when an error occurs.
     * @param err - An object holding details about the error that occurred.
     */
    type ErrorEventCallback = (this: ImageryLayer, err: Error) => void;
    /**
     * A function that is called when the provider has been created
     * @param provider - The created imagery provider.
     */
    type ReadyEventCallback = (this: ImageryLayer, provider: ImageryProvider) => void;
    /**
     * Initialization options for the ImageryLayer constructor.
     * [rectangle = imageryProvider.rectangle] - The rectangle of the layer.  This rectangle
     *        can limit the visible portion of the imagery provider.
     * [alpha = 1.0] - The alpha blending value of this layer, from 0.0 to 1.0.
     *                          This can either be a simple number or a function with the signature
     *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the
     *                          current frame state, this layer, and the x, y, and level coordinates of the
     *                          imagery tile for which the alpha is required, and it is expected to return
     *                          the alpha value to use for the tile.
     * [nightAlpha = 1.0] - The alpha blending value of this layer on the night side of the globe, from 0.0 to 1.0.
     *                          This can either be a simple number or a function with the signature
     *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the
     *                          current frame state, this layer, and the x, y, and level coordinates of the
     *                          imagery tile for which the alpha is required, and it is expected to return
     *                          the alpha value to use for the tile. This only takes effect when <code>enableLighting</code> is <code>true</code>.
     * [dayAlpha = 1.0] - The alpha blending value of this layer on the day side of the globe, from 0.0 to 1.0.
     *                          This can either be a simple number or a function with the signature
     *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the
     *                          current frame state, this layer, and the x, y, and level coordinates of the
     *                          imagery tile for which the alpha is required, and it is expected to return
     *                          the alpha value to use for the tile. This only takes effect when <code>enableLighting</code> is <code>true</code>.
     * [brightness = 1.0] - The brightness of this layer.  1.0 uses the unmodified imagery
     *                          color.  Less than 1.0 makes the imagery darker while greater than 1.0 makes it brighter.
     *                          This can either be a simple number or a function with the signature
     *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the
     *                          current frame state, this layer, and the x, y, and level coordinates of the
     *                          imagery tile for which the brightness is required, and it is expected to return
     *                          the brightness value to use for the tile.  The function is executed for every
     *                          frame and for every tile, so it must be fast.
     * [contrast = 1.0] - The contrast of this layer.  1.0 uses the unmodified imagery color.
     *                          Less than 1.0 reduces the contrast while greater than 1.0 increases it.
     *                          This can either be a simple number or a function with the signature
     *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the
     *                          current frame state, this layer, and the x, y, and level coordinates of the
     *                          imagery tile for which the contrast is required, and it is expected to return
     *                          the contrast value to use for the tile.  The function is executed for every
     *                          frame and for every tile, so it must be fast.
     * [hue = 0.0] - The hue of this layer.  0.0 uses the unmodified imagery color.
     *                          This can either be a simple number or a function with the signature
     *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the
     *                          current frame state, this layer, and the x, y, and level coordinates
     *                          of the imagery tile for which the hue is required, and it is expected to return
     *                          the contrast value to use for the tile.  The function is executed for every
     *                          frame and for every tile, so it must be fast.
     * [saturation = 1.0] - The saturation of this layer.  1.0 uses the unmodified imagery color.
     *                          Less than 1.0 reduces the saturation while greater than 1.0 increases it.
     *                          This can either be a simple number or a function with the signature
     *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the
     *                          current frame state, this layer, and the x, y, and level coordinates
     *                          of the imagery tile for which the saturation is required, and it is expected to return
     *                          the contrast value to use for the tile.  The function is executed for every
     *                          frame and for every tile, so it must be fast.
     * [gamma = 1.0] - The gamma correction to apply to this layer.  1.0 uses the unmodified imagery color.
     *                          This can either be a simple number or a function with the signature
     *                          <code>function(frameState, layer, x, y, level)</code>.  The function is passed the
     *                          current frame state, this layer, and the x, y, and level coordinates of the
     *                          imagery tile for which the gamma is required, and it is expected to return
     *                          the gamma value to use for the tile.  The function is executed for every
     *                          frame and for every tile, so it must be fast.
     * [splitDirection = SplitDirection.NONE] - The {@link SplitDirection} split to apply to this layer.
     * [minificationFilter = TextureMinificationFilter.LINEAR] - The
     *                                    texture minification filter to apply to this layer. Possible values
     *                                    are <code>TextureMinificationFilter.LINEAR</code> and
     *                                    <code>TextureMinificationFilter.NEAREST</code>.
     * [magnificationFilter = TextureMagnificationFilter.LINEAR] - The
     *                                     texture minification filter to apply to this layer. Possible values
     *                                     are <code>TextureMagnificationFilter.LINEAR</code> and
     *                                     <code>TextureMagnificationFilter.NEAREST</code>.
     * [show = true] - True if the layer is shown; otherwise, false.
     * [maximumAnisotropy = maximum supported] - The maximum anisotropy level to use
     *        for texture filtering.  If this parameter is not specified, the maximum anisotropy supported
     *        by the WebGL stack will be used.  Larger values make the imagery look better in horizon
     *        views.
     * [minimumTerrainLevel] - The minimum terrain level-of-detail at which to show this imagery layer,
     *                 or undefined to show it at all levels.  Level zero is the least-detailed level.
     * [maximumTerrainLevel] - The maximum terrain level-of-detail at which to show this imagery layer,
     *                 or undefined to show it at all levels.  Level zero is the least-detailed level.
     * [cutoutRectangle] - Cartographic rectangle for cutting out a portion of this ImageryLayer.
     * [colorToAlpha] - Color to be used as alpha.
     * [colorToAlphaThreshold = 0.004] - Threshold for color-to-alpha.
     */
    type ConstructorOptions = {
        rectangle?: Rectangle;
        alpha?: number | ((...params: any[]) => any);
        nightAlpha?: number | ((...params: any[]) => any);
        dayAlpha?: number | ((...params: any[]) => any);
        brightness?: number | ((...params: any[]) => any);
        contrast?: number | ((...params: any[]) => any);
        hue?: number | ((...params: any[]) => any);
        saturation?: number | ((...params: any[]) => any);
        gamma?: number | ((...params: any[]) => any);
        splitDirection?: SplitDirection | ((...params: any[]) => any);
        minificationFilter?: TextureMinificationFilter;
        magnificationFilter?: TextureMagnificationFilter;
        show?: boolean;
        maximumAnisotropy?: number;
        minimumTerrainLevel?: number;
        maximumTerrainLevel?: number;
        cutoutRectangle?: Rectangle;
        colorToAlpha?: Color;
        colorToAlphaThreshold?: number;
    };
    /**
     * Initialization options for ImageryLayer.fromWorldImagery
     * [options.style = IonWorldImageryStyle] - The style of base imagery, only AERIAL, AERIAL_WITH_LABELS, and ROAD are currently supported.
     */
    type WorldImageryConstructorOptions = ImageryLayer.ConstructorOptions;
}

/**
 * An imagery layer that displays tiled image data from a single imagery provider
 * on a {@link Globe}.
 * @example
 * // Add an OpenStreetMaps layer
 * const imageryLayer = new Cesium.ImageryLayer(new Cesium.OpenStreetMapImageryProvider({
 *   url: "https://tile.openstreetmap.org/"
 * })),
 * scene.imageryLayers.add(imageryLayer);
 * @example
 * // Add Cesium ion's default world imagery layer
 * const imageryLayer = Cesium.ImageryLayer.fromWorldImagery();
 * scene.imageryLayers.add(imageryLayer);
 * @example
 * // Add a new transparent layer from Cesium ion
 * const imageryLayer = Cesium.ImageryLayer.fromProviderAsync(Cesium.IonImageryProvider.fromAssetId(3812));
 * imageryLayer.alpha = 0.5;
 * scene.imageryLayers.add(imageryLayer);
 * @param imageryProvider - The imagery provider to use.
 * @param options - An object describing initialization options
 */
export class ImageryLayer {
    constructor(imageryProvider: ImageryProvider, options: ImageryLayer.ConstructorOptions);
    /**
     * The alpha blending value of this layer, with 0.0 representing fully transparent and
     * 1.0 representing fully opaque.
     */
    alpha: number;
    /**
     * The alpha blending value of this layer on the night side of the globe, with 0.0 representing fully transparent and
     * 1.0 representing fully opaque. This only takes effect when {@link Globe#enableLighting} is <code>true</code>.
     */
    nightAlpha: number;
    /**
     * The alpha blending value of this layer on the day side of the globe, with 0.0 representing fully transparent and
     * 1.0 representing fully opaque. This only takes effect when {@link Globe#enableLighting} is <code>true</code>.
     */
    dayAlpha: number;
    /**
     * The brightness of this layer.  1.0 uses the unmodified imagery color.  Less than 1.0
     * makes the imagery darker while greater than 1.0 makes it brighter.
     */
    brightness: number;
    /**
     * The contrast of this layer.  1.0 uses the unmodified imagery color.  Less than 1.0 reduces
     * the contrast while greater than 1.0 increases it.
     */
    contrast: number;
    /**
     * The hue of this layer in radians. 0.0 uses the unmodified imagery color.
     */
    hue: number;
    /**
     * The saturation of this layer. 1.0 uses the unmodified imagery color. Less than 1.0 reduces the
     * saturation while greater than 1.0 increases it.
     */
    saturation: number;
    /**
     * The gamma correction to apply to this layer.  1.0 uses the unmodified imagery color.
     */
    gamma: number;
    /**
     * The {@link SplitDirection} to apply to this layer.
     */
    splitDirection: SplitDirection;
    /**
     * The {@link TextureMinificationFilter} to apply to this layer.
     * Possible values are {@link TextureMinificationFilter.LINEAR} (the default)
     * and {@link TextureMinificationFilter.NEAREST}.
     *
     * To take effect, this property must be set immediately after adding the imagery layer.
     * Once a texture is loaded it won't be possible to change the texture filter used.
     */
    minificationFilter: TextureMinificationFilter;
    /**
     * The {@link TextureMagnificationFilter} to apply to this layer.
     * Possible values are {@link TextureMagnificationFilter.LINEAR} (the default)
     * and {@link TextureMagnificationFilter.NEAREST}.
     *
     * To take effect, this property must be set immediately after adding the imagery layer.
     * Once a texture is loaded it won't be possible to change the texture filter used.
     */
    magnificationFilter: TextureMagnificationFilter;
    /**
     * Determines if this layer is shown.
     */
    show: boolean;
    /**
     * Rectangle cutout in this layer of imagery.
     */
    cutoutRectangle: Rectangle;
    /**
     * Color value that should be set to transparent.
     */
    colorToAlpha: Color;
    /**
     * Normalized (0-1) threshold for color-to-alpha.
     */
    colorToAlphaThreshold: number;
    /**
     * Gets the imagery provider for this layer. This should not be called before {@link ImageryLayer#ready} returns true.
     */
    readonly imageryProvider: ImageryProvider;
    /**
     * Returns true when the terrain provider has been successfully created. Otherwise, returns false.
     */
    readonly ready: boolean;
    /**
     * Gets an event that is raised when the imagery provider has been successfully created. Event listeners
     * are passed the created instance of {@link ImageryProvider}.
     */
    readonly readyEvent: Event<ImageryLayer.ReadyEventCallback>;
    /**
     * Gets the rectangle of this layer.  If this rectangle is smaller than the rectangle of the
     * {@link ImageryProvider}, only a portion of the imagery provider is shown.
     */
    readonly rectangle: Rectangle;
    /**
     * This value is used as the default brightness for the imagery layer if one is not provided during construction
     * or by the imagery provider. This value does not modify the brightness of the imagery.
     */
    static DEFAULT_BRIGHTNESS: number;
    /**
     * This value is used as the default contrast for the imagery layer if one is not provided during construction
     * or by the imagery provider. This value does not modify the contrast of the imagery.
     */
    static DEFAULT_CONTRAST: number;
    /**
     * This value is used as the default hue for the imagery layer if one is not provided during construction
     * or by the imagery provider. This value does not modify the hue of the imagery.
     */
    static DEFAULT_HUE: number;
    /**
     * This value is used as the default saturation for the imagery layer if one is not provided during construction
     * or by the imagery provider. This value does not modify the saturation of the imagery.
     */
    static DEFAULT_SATURATION: number;
    /**
     * This value is used as the default gamma for the imagery layer if one is not provided during construction
     * or by the imagery provider. This value does not modify the gamma of the imagery.
     */
    static DEFAULT_GAMMA: number;
    /**
     * This value is used as the default split for the imagery layer if one is not provided during construction
     * or by the imagery provider.
     */
    static DEFAULT_SPLIT: SplitDirection;
    /**
     * This value is used as the default texture minification filter for the imagery layer if one is not provided
     * during construction or by the imagery provider.
     */
    static DEFAULT_MINIFICATION_FILTER: TextureMinificationFilter;
    /**
     * This value is used as the default texture magnification filter for the imagery layer if one is not provided
     * during construction or by the imagery provider.
     */
    static DEFAULT_MAGNIFICATION_FILTER: TextureMagnificationFilter;
    /**
     * This value is used as the default threshold for color-to-alpha if one is not provided
     * during construction or by the imagery provider.
     */
    static DEFAULT_APPLY_COLOR_TO_ALPHA_THRESHOLD: number;
    /**
     * Create a new imagery layer from an asynchronous imagery provider. The layer will handle any asynchronous loads or errors, and begin rendering the imagery layer once ready.
     * @example
     * // Create a new base layer
     * const viewer = new Cesium.Viewer("cesiumContainer", {
     *   baseLayer: Cesium.ImageryLayer.fromProviderAsync(Cesium.IonImageryProvider.fromAssetId(3812));
     * });
     * @example
     * // Add a new transparent layer
     * const imageryLayer = Cesium.ImageryLayer.fromProviderAsync(Cesium.IonImageryProvider.fromAssetId(3812));
     * imageryLayer.alpha = 0.5;
     * viewer.imageryLayers.add(imageryLayer);
     * @example
     * // Handle loading events
     * const imageryLayer = Cesium.ImageryLayer.fromProviderAsync(Cesium.IonImageryProvider.fromAssetId(3812));
     * viewer.imageryLayers.add(imageryLayer);
     *
     * imageryLayer.readyEvent.addEventListener(provider => {
     *   imageryLayer.provider.errorEvent.addEventListener(error => {
     *     alert(`Encountered an error while loading imagery tiles! ${error}`);
     *   });
     * });
     *
     * imageryLayer.errorEvent.addEventListener(error => {
     *   alert(`Encountered an error while creating an imagery layer! ${error}`);
     * });
     * @param imageryProviderPromise - A promise which resolves to a imagery provider
     * @param options - An object describing initialization options
     * @returns The created imagery layer.
     */
    static fromProviderAsync(imageryProviderPromise: Promise<ImageryProvider>, options: ImageryLayer.ConstructorOptions): ImageryLayer;
    /**
     * Create a new imagery layer for ion's default global base imagery layer, currently Bing Maps. The layer will handle any asynchronous loads or errors, and begin rendering the imagery layer once ready.
     * @example
     * // Add a new transparent layer
     * const imageryLayer = Cesium.ImageryLayer.fromWorldImagery();
     * imageryLayer.alpha = 0.5;
     * viewer.imageryLayers.add(imageryLayer);
     * @example
     * // Handle loading events
     * const imageryLayer = Cesium.ImageryLayer.fromWorldImagery();
     * viewer.imageryLayers.add(imageryLayer);
     *
     * imageryLayer.readyEvent.addEventListener(provider => {
     *   imageryLayer.provider.errorEvent.addEventListener(error => {
     *     alert(`Encountered an error while loading imagery tiles! ${error}`);
     *   });
     * });
     *
     * imageryLayer.errorEvent.addEventListener(error => {
     *   alert(`Encountered an error while creating an imagery layer! ${error}`);
     * });
     * @param options - An object describing initialization options
     * @returns The created imagery layer.
     *
     * * @example
     * // Create a new base layer
     * const viewer = new Cesium.Viewer("cesiumContainer", {
     *   baseLayer: Cesium.ImageryLayer.fromWorldImagery();
     * });
     */
    static fromWorldImagery(options: ImageryLayer.WorldImageryConstructorOptions): ImageryLayer;
    /**
     * Gets a value indicating whether this layer is the base layer in the
     * {@link ImageryLayerCollection}.  The base layer is the one that underlies all
     * others.  It is special in that it is treated as if it has global rectangle, even if
     * it actually does not, by stretching the texels at the edges over the entire
     * globe.
     * @returns true if this is the base layer; otherwise, false.
     */
    isBaseLayer(): boolean;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * @returns True if this object was destroyed; otherwise, false.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     * @example
     * imageryLayer = imageryLayer && imageryLayer.destroy();
     */
    destroy(): void;
    /**
     * Computes the intersection of this layer's rectangle with the imagery provider's availability rectangle,
     * producing the overall bounds of imagery that can be produced by this layer.
     * @example
     * // Zoom to an imagery layer.
     * const imageryRectangle = imageryLayer.getImageryRectangle();
     * scene.camera.flyTo({
     *     destination: rectangle
     * });
     * @returns A rectangle which defines the overall bounds of imagery that can be produced by this layer.
     */
    getImageryRectangle(): Rectangle;
}

/**
 * An ordered collection of imagery layers.
 */
export class ImageryLayerCollection {
    constructor();
    /**
     * An event that is raised when a layer is added to the collection.  Event handlers are passed the layer that
     * was added and the index at which it was added.
     */
    layerAdded: Event;
    /**
     * An event that is raised when a layer is removed from the collection.  Event handlers are passed the layer that
     * was removed and the index from which it was removed.
     */
    layerRemoved: Event;
    /**
     * An event that is raised when a layer changes position in the collection.  Event handlers are passed the layer that
     * was moved, its new index after the move, and its old index prior to the move.
     */
    layerMoved: Event;
    /**
     * An event that is raised when a layer is shown or hidden by setting the
     * {@link ImageryLayer#show} property.  Event handlers are passed a reference to this layer,
     * the index of the layer in the collection, and a flag that is true if the layer is now
     * shown or false if it is now hidden.
     */
    layerShownOrHidden: Event;
    /**
     * Gets the number of layers in this collection.
     */
    length: number;
    /**
     * Adds a layer to the collection.
     * @example
     * const imageryLayer = Cesium.ImageryLayer.fromWorldImagery();
     * scene.imageryLayers.add(imageryLayer);
     * @example
     * const imageryLayer = Cesium.ImageryLayer.fromProviderAsync(Cesium.IonImageryProvider.fromAssetId(3812));
     * scene.imageryLayers.add(imageryLayer);
     * @param layer - the layer to add.
     * @param [index] - the index to add the layer at.  If omitted, the layer will
     *                         be added on top of all existing layers.
     */
    add(layer: ImageryLayer, index?: number): void;
    /**
     * Creates a new layer using the given ImageryProvider and adds it to the collection.
     * @example
     * try {
     *    const provider = await Cesium.IonImageryProvider.fromAssetId(3812);
     *    scene.imageryLayers.addImageryProvider(provider);
     * } catch (error) {
     *   console.log(`There was an error creating the imagery layer. ${error}`)
     * }
     * @param imageryProvider - the imagery provider to create a new layer for.
     * @param [index] - the index to add the layer at.  If omitted, the layer will
     *                         added on top of all existing layers.
     * @returns The newly created layer.
     */
    addImageryProvider(imageryProvider: ImageryProvider, index?: number): ImageryLayer;
    /**
     * Removes a layer from this collection, if present.
     * @param layer - The layer to remove.
     * @param [destroy = true] - whether to destroy the layers in addition to removing them.
     * @returns true if the layer was in the collection and was removed,
     *                    false if the layer was not in the collection.
     */
    remove(layer: ImageryLayer, destroy?: boolean): boolean;
    /**
     * Removes all layers from this collection.
     * @param [destroy = true] - whether to destroy the layers in addition to removing them.
     */
    removeAll(destroy?: boolean): void;
    /**
     * Checks to see if the collection contains a given layer.
     * @param layer - the layer to check for.
     * @returns true if the collection contains the layer, false otherwise.
     */
    contains(layer: ImageryLayer): boolean;
    /**
     * Determines the index of a given layer in the collection.
     * @param layer - The layer to find the index of.
     * @returns The index of the layer in the collection, or -1 if the layer does not exist in the collection.
     */
    indexOf(layer: ImageryLayer): number;
    /**
     * Gets a layer by index from the collection.
     * @param index - the index to retrieve.
     * @returns The imagery layer at the given index.
     */
    get(index: number): ImageryLayer;
    /**
     * Raises a layer up one position in the collection.
     * @param layer - the layer to move.
     */
    raise(layer: ImageryLayer): void;
    /**
     * Lowers a layer down one position in the collection.
     * @param layer - the layer to move.
     */
    lower(layer: ImageryLayer): void;
    /**
     * Raises a layer to the top of the collection.
     * @param layer - the layer to move.
     */
    raiseToTop(layer: ImageryLayer): void;
    /**
     * Lowers a layer to the bottom of the collection.
     * @param layer - the layer to move.
     */
    lowerToBottom(layer: ImageryLayer): void;
    /**
     * Determines the imagery layers that are intersected by a pick ray. To compute a pick ray from a
     * location on the screen, use {@link Camera.getPickRay}.
     * @param ray - The ray to test for intersection.
     * @param scene - The scene.
     * @returns An array that includes all of
     *                                 the layers that are intersected by a given pick ray. Undefined if
     *                                 no layers are selected.
     */
    pickImageryLayers(ray: Ray, scene: Scene): ImageryLayer[] | undefined;
    /**
     * Asynchronously determines the imagery layer features that are intersected by a pick ray.  The intersected imagery
     * layer features are found by invoking {@link ImageryProvider#pickFeatures} for each imagery layer tile intersected
     * by the pick ray.  To compute a pick ray from a location on the screen, use {@link Camera.getPickRay}.
     * @example
     * const pickRay = viewer.camera.getPickRay(windowPosition);
     * const featuresPromise = viewer.imageryLayers.pickImageryLayerFeatures(pickRay, viewer.scene);
     * if (!Cesium.defined(featuresPromise)) {
     *     console.log('No features picked.');
     * } else {
     *     Promise.resolve(featuresPromise).then(function(features) {
     *         // This function is called asynchronously when the list if picked features is available.
     *         console.log(`Number of features: ${features.length}`);
     *         if (features.length > 0) {
     *             console.log(`First feature name: ${features[0].name}`);
     *         }
     *     });
     * }
     * @param ray - The ray to test for intersection.
     * @param scene - The scene.
     * @returns A promise that resolves to an array of features intersected by the pick ray.
     *                                             If it can be quickly determined that no features are intersected (for example,
     *                                             because no active imagery providers support {@link ImageryProvider#pickFeatures}
     *                                             or because the pick ray does not intersect the surface), this function will
     *                                             return undefined.
     */
    pickImageryLayerFeatures(ray: Ray, scene: Scene): Promise<ImageryLayerFeatureInfo[]> | undefined;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * @returns true if this object was destroyed; otherwise, false.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the WebGL resources held by all layers in this collection.  Explicitly destroying this
     * object allows for deterministic release of WebGL resources, instead of relying on the garbage
     * collector.
     * <br /><br />
     * Once this object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     * @example
     * layerCollection = layerCollection && layerCollection.destroy();
     */
    destroy(): void;
}

/**
 * Describes a rasterized feature, such as a point, polygon, polyline, etc., in an imagery layer.
 */
export class ImageryLayerFeatureInfo {
    constructor();
    /**
     * Gets or sets the name of the feature.
     */
    name: string | undefined;
    /**
     * Gets or sets an HTML description of the feature.  The HTML is not trusted and should
     * be sanitized before display to the user.
     */
    description: string | undefined;
    /**
     * Gets or sets the position of the feature, or undefined if the position is not known.
     */
    position: Cartographic | undefined;
    /**
     * Gets or sets the raw data describing the feature.  The raw data may be in any
     * number of formats, such as GeoJSON, KML, etc.
     */
    data: any | undefined;
    /**
     * Gets or sets the image layer of the feature.
     */
    imageryLayer: any | undefined;
    /**
     * Configures the name of this feature by selecting an appropriate property.  The name will be obtained from
     * one of the following sources, in this order: 1) the property with the name 'name', 2) the property with the name 'title',
     * 3) the first property containing the word 'name', 4) the first property containing the word 'title'.  If
     * the name cannot be obtained from any of these sources, the existing name will be left unchanged.
     * @param properties - An object literal containing the properties of the feature.
     */
    configureNameFromProperties(properties: any): void;
    /**
     * Configures the description of this feature by creating an HTML table of properties and their values.
     * @param properties - An object literal containing the properties of the feature.
     */
    configureDescriptionFromProperties(properties: any): void;
}

/**
 * The format in which {@link ImageryProvider} methods return an image may
 * vary by provider, configuration, or server settings.  Most common are
 * <code>HTMLImageElement</code>, <code>HTMLCanvasElement</code>, or on supported
 * browsers, <code>ImageBitmap</code>.
 *
 * See the documentation for each ImageryProvider class for more information about how they return images.
 */
export type ImageryTypes = HTMLImageElement | HTMLCanvasElement | ImageBitmap;

/**
 * Provides imagery to be displayed on the surface of an ellipsoid.  This type describes an
 * interface and is not intended to be instantiated directly.
 */
export class ImageryProvider {
    constructor();
    /**
     * Gets the rectangle, in radians, of the imagery provided by the instance.
     */
    readonly rectangle: Rectangle;
    /**
     * Gets the width of each tile, in pixels.
     */
    readonly tileWidth: number;
    /**
     * Gets the height of each tile, in pixels.
     */
    readonly tileHeight: number;
    /**
     * Gets the maximum level-of-detail that can be requested.
     */
    readonly maximumLevel: number | undefined;
    /**
     * Gets the minimum level-of-detail that can be requested.  Generally,
     * a minimum level should only be used when the rectangle of the imagery is small
     * enough that the number of tiles at the minimum level is small.  An imagery
     * provider with more than a few tiles at the minimum level will lead to
     * rendering problems.
     */
    readonly minimumLevel: number;
    /**
     * Gets the tiling scheme used by the provider.
     */
    readonly tilingScheme: TilingScheme;
    /**
     * Gets the tile discard policy.  If not undefined, the discard policy is responsible
     * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
     * returns undefined, no tiles are filtered.
     */
    readonly tileDiscardPolicy: TileDiscardPolicy;
    /**
     * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
     * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
     * are passed an instance of {@link TileProviderError}.
     */
    readonly errorEvent: Event;
    /**
     * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
     * the source of the imagery.
     */
    readonly credit: Credit;
    /**
     * Gets the proxy used by this provider.
     */
    readonly proxy: Proxy;
    /**
     * Gets a value indicating whether or not the images provided by this imagery provider
     * include an alpha channel.  If this property is false, an alpha channel, if present, will
     * be ignored.  If this property is true, any images without an alpha channel will be treated
     * as if their alpha is 1.0 everywhere.  When this property is false, memory usage
     * and texture upload time are reduced.
     */
    readonly hasAlphaChannel: boolean;
    /**
     * Gets the credits to be displayed when a given tile is displayed.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level;
     * @returns The credits to be displayed when the tile is displayed.
     */
    getTileCredits(x: number, y: number, level: number): Credit[];
    /**
     * Requests the image for a given tile.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level.
     * @param [request] - The request object. Intended for internal use only.
     * @returns Returns a promise for the image that will resolve when the image is available, or
     *          undefined if there are too many active requests to the server, and the request should be retried later.
     */
    requestImage(x: number, y: number, level: number, request?: Request): Promise<ImageryTypes> | undefined;
    /**
     * Asynchronously determines what features, if any, are located at a given longitude and latitude within
     * a tile.
     * This function is optional, so it may not exist on all ImageryProviders.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level.
     * @param longitude - The longitude at which to pick features.
     * @param latitude - The latitude at which to pick features.
     * @returns A promise for the picked features that will resolve when the asynchronous
     *                   picking completes.  The resolved value is an array of {@link ImageryLayerFeatureInfo}
     *                   instances.  The array may be empty if no features are found at the given location.
     *                   It may also be undefined if picking is not supported.
     */
    pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): Promise<ImageryLayerFeatureInfo[]> | undefined;
    /**
     * Loads an image from a given URL.  If the server referenced by the URL already has
     * too many requests pending, this function will instead return undefined, indicating
     * that the request should be retried later.
     * @param imageryProvider - The imagery provider for the URL.
     * @param url - The URL of the image.
     * @returns A promise for the image that will resolve when the image is available, or
     *          undefined if there are too many active requests to the server, and the request should be retried later.
     */
    static loadImage(imageryProvider: ImageryProvider, url: Resource | string): Promise<ImageryTypes | CompressedTextureBuffer> | undefined;
}

export namespace IonImageryProvider {
    /**
     * Initialization options for the TileMapServiceImageryProvider constructor
     * [accessToken = Ion.defaultAccessToken] - The access token to use.
     * [server = Ion.defaultServer] - The resource to the Cesium ion API server.
     */
    type ConstructorOptions = {
        accessToken?: string;
        server?: string | Resource;
    };
}

/**
 * <div class="notice">
 * To construct a IonImageryProvider, call {@link IonImageryProvider.fromAssetId}. Do not call the constructor directly.
 * </div>
 *
 * Provides tiled imagery using the Cesium ion REST API.
 * @example
 * const imageryLayer = Cesium.ImageryLayer.fromProviderAsync(Cesium.IonImageryProvider.fromAssetId(3812));
 * viewer.imageryLayers.add(imageryLayer);
 * @param [options] - Object describing initialization options
 */
export class IonImageryProvider {
    constructor(options?: IonImageryProvider.ConstructorOptions);
    /**
     * Gets the rectangle, in radians, of the imagery provided by the instance.
     */
    readonly rectangle: Rectangle;
    /**
     * Gets the width of each tile, in pixels.
     */
    readonly tileWidth: number;
    /**
     * Gets the height of each tile, in pixels.
     */
    readonly tileHeight: number;
    /**
     * Gets the maximum level-of-detail that can be requested.
     */
    readonly maximumLevel: number | undefined;
    /**
     * Gets the minimum level-of-detail that can be requested. Generally,
     * a minimum level should only be used when the rectangle of the imagery is small
     * enough that the number of tiles at the minimum level is small.  An imagery
     * provider with more than a few tiles at the minimum level will lead to
     * rendering problems.
     */
    readonly minimumLevel: number;
    /**
     * Gets the tiling scheme used by the provider.
     */
    readonly tilingScheme: TilingScheme;
    /**
     * Gets the tile discard policy.  If not undefined, the discard policy is responsible
     * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
     * returns undefined, no tiles are filtered.
     */
    readonly tileDiscardPolicy: TileDiscardPolicy;
    /**
     * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
     * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
     * are passed an instance of {@link TileProviderError}.
     */
    readonly errorEvent: Event;
    /**
     * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
     * the source of the imagery.
     */
    readonly credit: Credit;
    /**
     * Gets a value indicating whether or not the images provided by this imagery provider
     * include an alpha channel.  If this property is false, an alpha channel, if present, will
     * be ignored.  If this property is true, any images without an alpha channel will be treated
     * as if their alpha is 1.0 everywhere.  When this property is false, memory usage
     * and texture upload time are reduced.
     */
    readonly hasAlphaChannel: boolean;
    /**
     * Gets the proxy used by this provider.
     */
    readonly proxy: Proxy;
    /**
     * Creates a provider for tiled imagery using the Cesium ion REST API.
     * @example
     * const imageryLayer = Cesium.ImageryLayer.fromProviderAsync(Cesium.IonImageryProvider.fromAssetId(3812));
     * viewer.imageryLayers.add(imageryLayer);
     * @param assetId - An ion imagery asset ID.
     * @param options - Object describing initialization options.
     * @returns A promise which resolves to the created IonImageryProvider.
     */
    static fromAssetId(assetId: number, options: IonImageryProvider.ConstructorOptions): Promise<IonImageryProvider>;
    /**
     * Gets the credits to be displayed when a given tile is displayed.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level;
     * @returns The credits to be displayed when the tile is displayed.
     */
    getTileCredits(x: number, y: number, level: number): Credit[];
    /**
     * Requests the image for a given tile.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level.
     * @param [request] - The request object. Intended for internal use only.
     * @returns A promise for the image that will resolve when the image is available, or
     *          undefined if there are too many active requests to the server, and the request should be retried later.
     */
    requestImage(x: number, y: number, level: number, request?: Request): Promise<ImageryTypes> | undefined;
    /**
     * Asynchronously determines what features, if any, are located at a given longitude and latitude within
     * a tile. This function is optional, so it may not exist on all ImageryProviders.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level.
     * @param longitude - The longitude at which to pick features.
     * @param latitude - The latitude at which to pick features.
     * @returns A promise for the picked features that will resolve when the asynchronous
     *                   picking completes.  The resolved value is an array of {@link ImageryLayerFeatureInfo}
     *                   instances.  The array may be empty if no features are found at the given location.
     *                   It may also be undefined if picking is not supported.
     */
    pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): Promise<ImageryLayerFeatureInfo[]> | undefined;
}

/**
 * The types of imagery provided by {@link createWorldImagery}.
 */
export enum IonWorldImageryStyle {
    /**
     * Aerial imagery.
     */
    AERIAL = 2,
    /**
     * Aerial imagery with a road overlay.
     */
    AERIAL_WITH_LABELS = 3,
    /**
     * Roads without additional imagery.
     */
    ROAD = 4
}

/**
 * <div class="notice">
 * Create labels by calling {@link LabelCollection#add}. Do not call the constructor directly.
 * </div>
 */
export class Label {
    constructor();
    /**
     * Determines if this label will be shown.  Use this to hide or show a label, instead
     * of removing it and re-adding it to the collection.
     */
    show: boolean;
    /**
     * Gets or sets the Cartesian position of this label.
     */
    position: Cartesian3;
    /**
     * Gets or sets the height reference of this billboard.
     */
    heightReference: HeightReference;
    /**
     * Gets or sets the text of this label.
     */
    text: string;
    /**
     * Gets or sets the font used to draw this label. Fonts are specified using the same syntax as the CSS 'font' property.
     */
    font: string;
    /**
     * Gets or sets the fill color of this label.
     */
    fillColor: Color;
    /**
     * Gets or sets the outline color of this label.
     */
    outlineColor: Color;
    /**
     * Gets or sets the outline width of this label.
     */
    outlineWidth: number;
    /**
     * Determines if a background behind this label will be shown.
     */
    showBackground: boolean;
    /**
     * Gets or sets the background color of this label.
     */
    backgroundColor: Color;
    /**
     * Gets or sets the background padding, in pixels, of this label.  The <code>x</code> value
     * controls horizontal padding, and the <code>y</code> value controls vertical padding.
     */
    backgroundPadding: Cartesian2;
    /**
     * Gets or sets the style of this label.
     */
    style: LabelStyle;
    /**
     * Gets or sets the pixel offset in screen space from the origin of this label.  This is commonly used
     * to align multiple labels and billboards at the same position, e.g., an image and text.  The
     * screen space origin is the top, left corner of the canvas; <code>x</code> increases from
     * left to right, and <code>y</code> increases from top to bottom.
     * <br /><br />
     * <div align='center'>
     * <table border='0' cellpadding='5'><tr>
     * <td align='center'><code>default</code><br/><img src='Images/Label.setPixelOffset.default.png' width='250' height='188' /></td>
     * <td align='center'><code>l.pixeloffset = new Cartesian2(25, 75);</code><br/><img src='Images/Label.setPixelOffset.x50y-25.png' width='250' height='188' /></td>
     * </tr></table>
     * The label's origin is indicated by the yellow point.
     * </div>
     */
    pixelOffset: Cartesian2;
    /**
     * Gets or sets near and far translucency properties of a Label based on the Label's distance from the camera.
     * A label's translucency will interpolate between the {@link NearFarScalar#nearValue} and
     * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
     * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
     * Outside of these ranges the label's translucency remains clamped to the nearest bound.  If undefined,
     * translucencyByDistance will be disabled.
     * @example
     * // Example 1.
     * // Set a label's translucencyByDistance to 1.0 when the
     * // camera is 1500 meters from the label and disappear as
     * // the camera distance approaches 8.0e6 meters.
     * text.translucencyByDistance = new Cesium.NearFarScalar(1.5e2, 1.0, 8.0e6, 0.0);
     * @example
     * // Example 2.
     * // disable translucency by distance
     * text.translucencyByDistance = undefined;
     */
    translucencyByDistance: NearFarScalar;
    /**
     * Gets or sets near and far pixel offset scaling properties of a Label based on the Label's distance from the camera.
     * A label's pixel offset will be scaled between the {@link NearFarScalar#nearValue} and
     * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
     * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
     * Outside of these ranges the label's pixel offset scaling remains clamped to the nearest bound.  If undefined,
     * pixelOffsetScaleByDistance will be disabled.
     * @example
     * // Example 1.
     * // Set a label's pixel offset scale to 0.0 when the
     * // camera is 1500 meters from the label and scale pixel offset to 10.0 pixels
     * // in the y direction the camera distance approaches 8.0e6 meters.
     * text.pixelOffset = new Cesium.Cartesian2(0.0, 1.0);
     * text.pixelOffsetScaleByDistance = new Cesium.NearFarScalar(1.5e2, 0.0, 8.0e6, 10.0);
     * @example
     * // Example 2.
     * // disable pixel offset by distance
     * text.pixelOffsetScaleByDistance = undefined;
     */
    pixelOffsetScaleByDistance: NearFarScalar;
    /**
     * Gets or sets near and far scaling properties of a Label based on the label's distance from the camera.
     * A label's scale will interpolate between the {@link NearFarScalar#nearValue} and
     * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
     * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
     * Outside of these ranges the label's scale remains clamped to the nearest bound.  If undefined,
     * scaleByDistance will be disabled.
     * @example
     * // Example 1.
     * // Set a label's scaleByDistance to scale by 1.5 when the
     * // camera is 1500 meters from the label and disappear as
     * // the camera distance approaches 8.0e6 meters.
     * label.scaleByDistance = new Cesium.NearFarScalar(1.5e2, 1.5, 8.0e6, 0.0);
     * @example
     * // Example 2.
     * // disable scaling by distance
     * label.scaleByDistance = undefined;
     */
    scaleByDistance: NearFarScalar;
    /**
     * Gets and sets the 3D Cartesian offset applied to this label in eye coordinates.  Eye coordinates is a left-handed
     * coordinate system, where <code>x</code> points towards the viewer's right, <code>y</code> points up, and
     * <code>z</code> points into the screen.  Eye coordinates use the same scale as world and model coordinates,
     * which is typically meters.
     * <br /><br />
     * An eye offset is commonly used to arrange multiple label or objects at the same position, e.g., to
     * arrange a label above its corresponding 3D model.
     * <br /><br />
     * Below, the label is positioned at the center of the Earth but an eye offset makes it always
     * appear on top of the Earth regardless of the viewer's or Earth's orientation.
     * <br /><br />
     * <div align='center'>
     * <table border='0' cellpadding='5'><tr>
     * <td align='center'><img src='Images/Billboard.setEyeOffset.one.png' width='250' height='188' /></td>
     * <td align='center'><img src='Images/Billboard.setEyeOffset.two.png' width='250' height='188' /></td>
     * </tr></table>
     * <code>l.eyeOffset = new Cartesian3(0.0, 8000000.0, 0.0);</code><br /><br />
     * </div>
     */
    eyeOffset: Cartesian3;
    /**
     * Gets or sets the horizontal origin of this label, which determines if the label is drawn
     * to the left, center, or right of its anchor position.
     * <br /><br />
     * <div align='center'>
     * <img src='Images/Billboard.setHorizontalOrigin.png' width='648' height='196' /><br />
     * </div>
     * @example
     * // Use a top, right origin
     * l.horizontalOrigin = Cesium.HorizontalOrigin.RIGHT;
     * l.verticalOrigin = Cesium.VerticalOrigin.TOP;
     */
    horizontalOrigin: HorizontalOrigin;
    /**
     * Gets or sets the vertical origin of this label, which determines if the label is
     * to the above, below, or at the center of its anchor position.
     * <br /><br />
     * <div align='center'>
     * <img src='Images/Billboard.setVerticalOrigin.png' width='695' height='175' /><br />
     * </div>
     * @example
     * // Use a top, right origin
     * l.horizontalOrigin = Cesium.HorizontalOrigin.RIGHT;
     * l.verticalOrigin = Cesium.VerticalOrigin.TOP;
     */
    verticalOrigin: VerticalOrigin;
    /**
     * Gets or sets the uniform scale that is multiplied with the label's size in pixels.
     * A scale of <code>1.0</code> does not change the size of the label; a scale greater than
     * <code>1.0</code> enlarges the label; a positive scale less than <code>1.0</code> shrinks
     * the label.
     * <br /><br />
     * Applying a large scale value may pixelate the label.  To make text larger without pixelation,
     * use a larger font size when calling {@link Label#font} instead.
     * <br /><br />
     * <div align='center'>
     * <img src='Images/Label.setScale.png' width='400' height='300' /><br/>
     * From left to right in the above image, the scales are <code>0.5</code>, <code>1.0</code>,
     * and <code>2.0</code>.
     * </div>
     */
    scale: number;
    /**
     * Gets the total scale of the label, which is the label's scale multiplied by the computed relative size
     * of the desired font compared to the generated glyph size.
     */
    totalScale: number;
    /**
     * Gets or sets the condition specifying at what distance from the camera that this label will be displayed.
     */
    distanceDisplayCondition: DistanceDisplayCondition;
    /**
     * Gets or sets the distance from the camera at which to disable the depth test to, for example, prevent clipping against terrain.
     * When set to zero, the depth test is always applied. When set to Number.POSITIVE_INFINITY, the depth test is never applied.
     */
    disableDepthTestDistance: number;
    /**
     * Gets or sets the user-defined value returned when the label is picked.
     */
    id: any;
    /**
     * Computes the screen-space position of the label's origin, taking into account eye and pixel offsets.
     * The screen space origin is the top, left corner of the canvas; <code>x</code> increases from
     * left to right, and <code>y</code> increases from top to bottom.
     * @example
     * console.log(l.computeScreenSpacePosition(scene).toString());
     * @param scene - The scene the label is in.
     * @param [result] - The object onto which to store the result.
     * @returns The screen-space position of the label.
     */
    computeScreenSpacePosition(scene: Scene, result?: Cartesian2): Cartesian2;
    /**
     * Determines if this label equals another label.  Labels are equal if all their properties
     * are equal.  Labels in different collections can be equal.
     * @param other - The label to compare for equality.
     * @returns <code>true</code> if the labels are equal; otherwise, <code>false</code>.
     */
    equals(other: Label): boolean;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * @returns True if this object was destroyed; otherwise, false.
     */
    isDestroyed(): boolean;
    /**
     * Determines whether or not run the algorithm, that match the text of the label to right-to-left languages
     * @example
     * // Example 1.
     * // Set a label's rightToLeft before init
     * Cesium.Label.enableRightToLeftDetection = true;
     * const myLabelEntity = viewer.entities.add({
     *   label: {
     *     id: 'my label',
     *     text: 'זה טקסט בעברית \n ועכשיו יורדים שורה',
     *   }
     * });
     * @example
     * // Example 2.
     * const myLabelEntity = viewer.entities.add({
     *   label: {
     *     id: 'my label',
     *     text: 'English text'
     *   }
     * });
     * // Set a label's rightToLeft after init
     * Cesium.Label.enableRightToLeftDetection = true;
     * myLabelEntity.text = 'טקסט חדש';
     */
    static enableRightToLeftDetection: boolean;
}

/**
 * A renderable collection of labels.  Labels are viewport-aligned text positioned in the 3D scene.
 * Each label can have a different font, color, scale, etc.
 * <br /><br />
 * <div align='center'>
 * <img src='Images/Label.png' width='400' height='300' /><br />
 * Example labels
 * </div>
 * <br /><br />
 * Labels are added and removed from the collection using {@link LabelCollection#add}
 * and {@link LabelCollection#remove}.
 * @example
 * // Create a label collection with two labels
 * const labels = scene.primitives.add(new Cesium.LabelCollection());
 * labels.add({
 *   position : new Cesium.Cartesian3(1.0, 2.0, 3.0),
 *   text : 'A label'
 * });
 * labels.add({
 *   position : new Cesium.Cartesian3(4.0, 5.0, 6.0),
 *   text : 'Another label'
 * });
 * @param [options] - Object with the following properties:
 * @param [options.modelMatrix = Matrix4.IDENTITY] - The 4x4 transformation matrix that transforms each label from model to world coordinates.
 * @param [options.debugShowBoundingVolume = false] - For debugging only. Determines if this primitive's commands' bounding spheres are shown.
 * @param [options.scene] - Must be passed in for labels that use the height reference property or will be depth tested against the globe.
 * @param [options.blendOption = BlendOption.OPAQUE_AND_TRANSLUCENT] - The label blending option. The default
 * is used for rendering both opaque and translucent labels. However, if either all of the labels are completely opaque or all are completely translucent,
 * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve performance by up to 2x.
 * @param [options.show = true] - Determines if the labels in the collection will be shown.
 */
export class LabelCollection {
    constructor(options?: {
        modelMatrix?: Matrix4;
        debugShowBoundingVolume?: boolean;
        scene?: Scene;
        blendOption?: BlendOption;
        show?: boolean;
    });
    /**
     * Determines if labels in this collection will be shown.
     */
    show: boolean;
    /**
     * The 4x4 transformation matrix that transforms each label in this collection from model to world coordinates.
     * When this is the identity matrix, the labels are drawn in world coordinates, i.e., Earth's WGS84 coordinates.
     * Local reference frames can be used by providing a different transformation matrix, like that returned
     * by {@link Transforms.eastNorthUpToFixedFrame}.
     * @example
     * const center = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);
     * labels.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(center);
     * labels.add({
     *   position : new Cesium.Cartesian3(0.0, 0.0, 0.0),
     *   text     : 'Center'
     * });
     * labels.add({
     *   position : new Cesium.Cartesian3(1000000.0, 0.0, 0.0),
     *   text     : 'East'
     * });
     * labels.add({
     *   position : new Cesium.Cartesian3(0.0, 1000000.0, 0.0),
     *   text     : 'North'
     * });
     * labels.add({
     *   position : new Cesium.Cartesian3(0.0, 0.0, 1000000.0),
     *   text     : 'Up'
     * });
     */
    modelMatrix: Matrix4;
    /**
     * This property is for debugging only; it is not for production use nor is it optimized.
     * <p>
     * Draws the bounding sphere for each draw command in the primitive.
     * </p>
     */
    debugShowBoundingVolume: boolean;
    /**
     * The label blending option. The default is used for rendering both opaque and translucent labels.
     * However, if either all of the labels are completely opaque or all are completely translucent,
     * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve
     * performance by up to 2x.
     */
    blendOption: BlendOption;
    /**
     * Returns the number of labels in this collection.  This is commonly used with
     * {@link LabelCollection#get} to iterate over all the labels
     * in the collection.
     */
    length: number;
    /**
     * Creates and adds a label with the specified initial properties to the collection.
     * The added label is returned so it can be modified or removed from the collection later.
     * @example
     * // Example 1:  Add a label, specifying all the default values.
     * const l = labels.add({
     *   show : true,
     *   position : Cesium.Cartesian3.ZERO,
     *   text : '',
     *   font : '30px sans-serif',
     *   fillColor : Cesium.Color.WHITE,
     *   outlineColor : Cesium.Color.BLACK,
     *   outlineWidth : 1.0,
     *   showBackground : false,
     *   backgroundColor : new Cesium.Color(0.165, 0.165, 0.165, 0.8),
     *   backgroundPadding : new Cesium.Cartesian2(7, 5),
     *   style : Cesium.LabelStyle.FILL,
     *   pixelOffset : Cesium.Cartesian2.ZERO,
     *   eyeOffset : Cesium.Cartesian3.ZERO,
     *   horizontalOrigin : Cesium.HorizontalOrigin.LEFT,
     *   verticalOrigin : Cesium.VerticalOrigin.BASELINE,
     *   scale : 1.0,
     *   translucencyByDistance : undefined,
     *   pixelOffsetScaleByDistance : undefined,
     *   heightReference : HeightReference.NONE,
     *   distanceDisplayCondition : undefined
     * });
     * @example
     * // Example 2:  Specify only the label's cartographic position,
     * // text, and font.
     * const l = labels.add({
     *   position : Cesium.Cartesian3.fromRadians(longitude, latitude, height),
     *   text : 'Hello World',
     *   font : '24px Helvetica',
     * });
     * @param [options] - A template describing the label's properties as shown in Example 1.
     * @returns The label that was added to the collection.
     */
    add(options?: any): Label;
    /**
     * Removes a label from the collection.  Once removed, a label is no longer usable.
     * @example
     * const l = labels.add(...);
     * labels.remove(l);  // Returns true
     * @param label - The label to remove.
     * @returns <code>true</code> if the label was removed; <code>false</code> if the label was not found in the collection.
     */
    remove(label: Label): boolean;
    /**
     * Removes all labels from the collection.
     * @example
     * labels.add(...);
     * labels.add(...);
     * labels.removeAll();
     */
    removeAll(): void;
    /**
     * Check whether this collection contains a given label.
     * @param label - The label to check for.
     * @returns true if this collection contains the label, false otherwise.
     */
    contains(label: Label): boolean;
    /**
     * Returns the label in the collection at the specified index.  Indices are zero-based
     * and increase as labels are added.  Removing a label shifts all labels after
     * it to the left, changing their indices.  This function is commonly used with
     * {@link LabelCollection#length} to iterate over all the labels
     * in the collection.
     * @example
     * // Toggle the show property of every label in the collection
     * const len = labels.length;
     * for (let i = 0; i < len; ++i) {
     *   const l = billboards.get(i);
     *   l.show = !l.show;
     * }
     * @param index - The zero-based index of the billboard.
     * @returns The label at the specified index.
     */
    get(index: number): Label;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * @returns True if this object was destroyed; otherwise, false.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     * @example
     * labels = labels && labels.destroy();
     */
    destroy(): void;
}

/**
 * Describes how to draw a label.
 */
export enum LabelStyle {
    /**
     * Fill the text of the label, but do not outline.
     */
    FILL = 0,
    /**
     * Outline the text of the label, but do not fill.
     */
    OUTLINE = 1,
    /**
     * Fill and outline the text of the label.
     */
    FILL_AND_OUTLINE = 2
}

/**
 * A light source. This type describes an interface and is not intended to be instantiated directly. Together, <code>color</code> and <code>intensity</code> produce a high-dynamic-range light color. <code>intensity</code> can also be used individually to dim or brighten the light without changing the hue.
 */
export class Light {
    constructor();
    /**
     * The color of the light.
     */
    color: Color;
    /**
     * The intensity controls the strength of the light. <code>intensity</code> has a minimum value of 0.0 and no maximum value.
     */
    intensity: number;
}

/**
 * Describes how the map will operate in 2D.
 */
export enum MapMode2D {
    /**
     * The 2D map can be rotated about the z axis.
     */
    ROTATE = 0,
    /**
     * The 2D map can be scrolled infinitely in the horizontal direction.
     */
    INFINITE_SCROLL = 1
}

export namespace MapboxImageryProvider {
    /**
     * Initialization options for the MapboxImageryProvider constructor
     * [url = 'https://api.mapbox.com/v4/'] - The Mapbox server url.
     * mapId - The Mapbox Map ID.
     * accessToken - The public access token for the imagery.
     * [format = 'png'] - The format of the image request.
     * [ellipsoid] - The ellipsoid.  If not specified, the WGS84 ellipsoid is used.
     * [minimumLevel = 0] - The minimum level-of-detail supported by the imagery provider.  Take care when specifying
     *                 this that the number of tiles at the minimum level is small, such as four or less.  A larger number is likely
     *                 to result in rendering problems.
     * [maximumLevel] - The maximum level-of-detail supported by the imagery provider, or undefined if there is no limit.
     * [rectangle = Rectangle.MAX_VALUE] - The rectangle, in radians, covered by the image.
     * [credit] - A credit for the data source, which is displayed on the canvas.
     */
    type ConstructorOptions = {
        url?: string;
        mapId: string;
        accessToken: string;
        format?: string;
        ellipsoid?: Ellipsoid;
        minimumLevel?: number;
        maximumLevel?: number;
        rectangle?: Rectangle;
        credit?: Credit | string;
    };
}

/**
 * Provides tiled imagery hosted by Mapbox.
 * @example
 * // Mapbox tile provider
 * const mapbox = new Cesium.MapboxImageryProvider({
 *     mapId: 'mapbox.mapbox-terrain-v2',
 *     accessToken: 'thisIsMyAccessToken'
 * });
 * @param options - Object describing initialization options
 */
export class MapboxImageryProvider {
    constructor(options: MapboxImageryProvider.ConstructorOptions);
    /**
     * Gets the URL of the Mapbox server.
     */
    readonly url: string;
    /**
     * Gets the rectangle, in radians, of the imagery provided by the instance.
     */
    readonly rectangle: Rectangle;
    /**
     * Gets the width of each tile, in pixels.
     */
    readonly tileWidth: number;
    /**
     * Gets the height of each tile, in pixels.
     */
    readonly tileHeight: number;
    /**
     * Gets the maximum level-of-detail that can be requested.
     */
    readonly maximumLevel: number | undefined;
    /**
     * Gets the minimum level-of-detail that can be requested. Generally,
     * a minimum level should only be used when the rectangle of the imagery is small
     * enough that the number of tiles at the minimum level is small.  An imagery
     * provider with more than a few tiles at the minimum level will lead to
     * rendering problems.
     */
    readonly minimumLevel: number;
    /**
     * Gets the tiling scheme used by the provider.
     */
    readonly tilingScheme: TilingScheme;
    /**
     * Gets the tile discard policy.  If not undefined, the discard policy is responsible
     * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
     * returns undefined, no tiles are filtered.
     */
    readonly tileDiscardPolicy: TileDiscardPolicy;
    /**
     * Gets an event that is raised when the imagery provider encounters an asynchronous error..  By subscribing
     * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
     * are passed an instance of {@link TileProviderError}.
     */
    readonly errorEvent: Event;
    /**
     * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
     * the source of the imagery.
     */
    readonly credit: Credit;
    /**
     * Gets the proxy used by this provider.
     */
    readonly proxy: Proxy;
    /**
     * Gets a value indicating whether or not the images provided by this imagery provider
     * include an alpha channel.  If this property is false, an alpha channel, if present, will
     * be ignored.  If this property is true, any images without an alpha channel will be treated
     * as if their alpha is 1.0 everywhere.  When this property is false, memory usage
     * and texture upload time are reduced.
     */
    readonly hasAlphaChannel: boolean;
    /**
     * Gets the credits to be displayed when a given tile is displayed.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level;
     * @returns The credits to be displayed when the tile is displayed.
     */
    getTileCredits(x: number, y: number, level: number): Credit[];
    /**
     * Requests the image for a given tile.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level.
     * @param [request] - The request object. Intended for internal use only.
     * @returns A promise for the image that will resolve when the image is available, or
     *          undefined if there are too many active requests to the server, and the request should be retried later.
     */
    requestImage(x: number, y: number, level: number, request?: Request): Promise<ImageryTypes> | undefined;
    /**
     * Asynchronously determines what features, if any, are located at a given longitude and latitude within
     * a tile. This function is optional, so it may not exist on all ImageryProviders.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level.
     * @param longitude - The longitude at which to pick features.
     * @param latitude - The latitude at which to pick features.
     * @returns A promise for the picked features that will resolve when the asynchronous
     *                   picking completes.  The resolved value is an array of {@link ImageryLayerFeatureInfo}
     *                   instances.  The array may be empty if no features are found at the given location.
     *                   It may also be undefined if picking is not supported.
     */
    pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): Promise<ImageryLayerFeatureInfo[]> | undefined;
}

export namespace MapboxStyleImageryProvider {
    /**
     * Initialization options for the MapboxStyleImageryProvider constructor
     * [url = 'https://api.mapbox.com/styles/v1/'] - The Mapbox server url.
     * [username = 'mapbox'] - The username of the map account.
     * styleId - The Mapbox Style ID.
     * accessToken - The public access token for the imagery.
     * [tilesize = 512] - The size of the image tiles.
     * [scaleFactor] - Determines if tiles are rendered at a @2x scale factor.
     * [ellipsoid] - The ellipsoid.  If not specified, the WGS84 ellipsoid is used.
     * [minimumLevel = 0] - The minimum level-of-detail supported by the imagery provider.  Take care when specifying
     *                 this that the number of tiles at the minimum level is small, such as four or less.  A larger number is likely
     *                 to result in rendering problems.
     * [maximumLevel] - The maximum level-of-detail supported by the imagery provider, or undefined if there is no limit.
     * [rectangle = Rectangle.MAX_VALUE] - The rectangle, in radians, covered by the image.
     * [credit] - A credit for the data source, which is displayed on the canvas.
     */
    type ConstructorOptions = {
        url?: Resource | string;
        username?: string;
        styleId: string;
        accessToken: string;
        tilesize?: number;
        scaleFactor?: boolean;
        ellipsoid?: Ellipsoid;
        minimumLevel?: number;
        maximumLevel?: number;
        rectangle?: Rectangle;
        credit?: Credit | string;
    };
}

/**
 * Provides tiled imagery hosted by Mapbox.
 * @example
 * // Mapbox style provider
 * const mapbox = new Cesium.MapboxStyleImageryProvider({
 *     styleId: 'streets-v11',
 *     accessToken: 'thisIsMyAccessToken'
 * });
 * @param options - Object describing initialization options
 */
export class MapboxStyleImageryProvider {
    constructor(options: MapboxStyleImageryProvider.ConstructorOptions);
    /**
     * Gets the URL of the Mapbox server.
     */
    readonly url: string;
    /**
     * Gets the rectangle, in radians, of the imagery provided by the instance.
     */
    readonly rectangle: Rectangle;
    /**
     * Gets the width of each tile, in pixels.
     */
    readonly tileWidth: number;
    /**
     * Gets the height of each tile, in pixels.
     */
    readonly tileHeight: number;
    /**
     * Gets the maximum level-of-detail that can be requested.
     */
    readonly maximumLevel: number | undefined;
    /**
     * Gets the minimum level-of-detail that can be requested. Generally,
     * a minimum level should only be used when the rectangle of the imagery is small
     * enough that the number of tiles at the minimum level is small.  An imagery
     * provider with more than a few tiles at the minimum level will lead to
     * rendering problems.
     */
    readonly minimumLevel: number;
    /**
     * Gets the tiling scheme used by the provider.
     */
    readonly tilingScheme: TilingScheme;
    /**
     * Gets the tile discard policy.  If not undefined, the discard policy is responsible
     * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
     * returns undefined, no tiles are filtered.
     */
    readonly tileDiscardPolicy: TileDiscardPolicy;
    /**
     * Gets an event that is raised when the imagery provider encounters an asynchronous error..  By subscribing
     * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
     * are passed an instance of {@link TileProviderError}.
     */
    readonly errorEvent: Event;
    /**
     * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
     * the source of the imagery.
     */
    readonly credit: Credit;
    /**
     * Gets the proxy used by this provider.
     */
    readonly proxy: Proxy;
    /**
     * Gets a value indicating whether or not the images provided by this imagery provider
     * include an alpha channel.  If this property is false, an alpha channel, if present, will
     * be ignored.  If this property is true, any images without an alpha channel will be treated
     * as if their alpha is 1.0 everywhere.  When this property is false, memory usage
     * and texture upload time are reduced.
     */
    readonly hasAlphaChannel: boolean;
    /**
     * Gets the credits to be displayed when a given tile is displayed.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level;
     * @returns The credits to be displayed when the tile is displayed.
     */
    getTileCredits(x: number, y: number, level: number): Credit[];
    /**
     * Requests the image for a given tile.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level.
     * @param [request] - The request object. Intended for internal use only.
     * @returns A promise for the image that will resolve when the image is available, or
     *          undefined if there are too many active requests to the server, and the request should be retried later.
     */
    requestImage(x: number, y: number, level: number, request?: Request): Promise<ImageryTypes> | undefined;
    /**
     * Asynchronously determines what features, if any, are located at a given longitude and latitude within
     * a tile. This function is optional, so it may not exist on all ImageryProviders.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level.
     * @param longitude - The longitude at which to pick features.
     * @param latitude - The latitude at which to pick features.
     * @returns A promise for the picked features that will resolve when the asynchronous
     *                   picking completes.  The resolved value is an array of {@link ImageryLayerFeatureInfo}
     *                   instances.  The array may be empty if no features are found at the given location.
     *                   It may also be undefined if picking is not supported.
     */
    pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): Promise<ImageryLayerFeatureInfo[]> | undefined;
}

/**
 * A Material defines surface appearance through a combination of diffuse, specular,
 * normal, emission, and alpha components. These values are specified using a
 * JSON schema called Fabric which gets parsed and assembled into glsl shader code
 * behind-the-scenes. Check out the {@link https://github.com/CesiumGS/cesium/wiki/Fabric|wiki page}
 * for more details on Fabric.
 * <br /><br />
 * <style type="text/css">
 *  #materialDescriptions code {
 *      font-weight: normal;
 *      font-family: Consolas, 'Lucida Console', Monaco, monospace;
 *      color: #A35A00;
 *  }
 *  #materialDescriptions ul, #materialDescriptions ul ul {
 *      list-style-type: none;
 *  }
 *  #materialDescriptions ul ul {
 *      margin-bottom: 10px;
 *  }
 *  #materialDescriptions ul ul li {
 *      font-weight: normal;
 *      color: #000000;
 *      text-indent: -2em;
 *      margin-left: 2em;
 *  }
 *  #materialDescriptions ul li {
 *      font-weight: bold;
 *      color: #0053CF;
 *  }
 * </style>
 *
 * Base material types and their uniforms:
 * <div id='materialDescriptions'>
 * <ul>
 *  <li>Color</li>
 *  <ul>
 *      <li><code>color</code>:  rgba color object.</li>
 *  </ul>
 *  <li>Image</li>
 *  <ul>
 *      <li><code>image</code>:  path to image.</li>
 *      <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>
 *  </ul>
 *  <li>DiffuseMap</li>
 *  <ul>
 *      <li><code>image</code>:  path to image.</li>
 *      <li><code>channels</code>:  Three character string containing any combination of r, g, b, and a for selecting the desired image channels.</li>
 *      <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>
 *  </ul>
 *  <li>AlphaMap</li>
 *  <ul>
 *      <li><code>image</code>:  path to image.</li>
 *      <li><code>channel</code>:  One character string containing r, g, b, or a for selecting the desired image channel. </li>
 *      <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>
 *  </ul>
 *  <li>SpecularMap</li>
 *  <ul>
 *      <li><code>image</code>: path to image.</li>
 *      <li><code>channel</code>: One character string containing r, g, b, or a for selecting the desired image channel. </li>
 *      <li><code>repeat</code>: Object with x and y values specifying the number of times to repeat the image.</li>
 *  </ul>
 *  <li>EmissionMap</li>
 *  <ul>
 *      <li><code>image</code>:  path to image.</li>
 *      <li><code>channels</code>:  Three character string containing any combination of r, g, b, and a for selecting the desired image channels. </li>
 *      <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>
 *  </ul>
 *  <li>BumpMap</li>
 *  <ul>
 *      <li><code>image</code>:  path to image.</li>
 *      <li><code>channel</code>:  One character string containing r, g, b, or a for selecting the desired image channel. </li>
 *      <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>
 *      <li><code>strength</code>:  Bump strength value between 0.0 and 1.0 where 0.0 is small bumps and 1.0 is large bumps.</li>
 *  </ul>
 *  <li>NormalMap</li>
 *  <ul>
 *      <li><code>image</code>:  path to image.</li>
 *      <li><code>channels</code>:  Three character string containing any combination of r, g, b, and a for selecting the desired image channels. </li>
 *      <li><code>repeat</code>:  Object with x and y values specifying the number of times to repeat the image.</li>
 *      <li><code>strength</code>:  Bump strength value between 0.0 and 1.0 where 0.0 is small bumps and 1.0 is large bumps.</li>
 *  </ul>
 *  <li>Grid</li>
 *  <ul>
 *      <li><code>color</code>:  rgba color object for the whole material.</li>
 *      <li><code>cellAlpha</code>: Alpha value for the cells between grid lines.  This will be combined with color.alpha.</li>
 *      <li><code>lineCount</code>:  Object with x and y values specifying the number of columns and rows respectively.</li>
 *      <li><code>lineThickness</code>:  Object with x and y values specifying the thickness of grid lines (in pixels where available).</li>
 *      <li><code>lineOffset</code>:  Object with x and y values specifying the offset of grid lines (range is 0 to 1).</li>
 *  </ul>
 *  <li>Stripe</li>
 *  <ul>
 *      <li><code>horizontal</code>:  Boolean that determines if the stripes are horizontal or vertical.</li>
 *      <li><code>evenColor</code>:  rgba color object for the stripe's first color.</li>
 *      <li><code>oddColor</code>:  rgba color object for the stripe's second color.</li>
 *      <li><code>offset</code>:  Number that controls at which point into the pattern to begin drawing; with 0.0 being the beginning of the even color, 1.0 the beginning of the odd color, 2.0 being the even color again, and any multiple or fractional values being in between.</li>
 *      <li><code>repeat</code>:  Number that controls the total number of stripes, half light and half dark.</li>
 *  </ul>
 *  <li>Checkerboard</li>
 *  <ul>
 *      <li><code>lightColor</code>:  rgba color object for the checkerboard's light alternating color.</li>
 *      <li><code>darkColor</code>: rgba color object for the checkerboard's dark alternating color.</li>
 *      <li><code>repeat</code>:  Object with x and y values specifying the number of columns and rows respectively.</li>
 *  </ul>
 *  <li>Dot</li>
 *  <ul>
 *      <li><code>lightColor</code>:  rgba color object for the dot color.</li>
 *      <li><code>darkColor</code>:  rgba color object for the background color.</li>
 *      <li><code>repeat</code>:  Object with x and y values specifying the number of columns and rows of dots respectively.</li>
 *  </ul>
 *  <li>Water</li>
 *  <ul>
 *      <li><code>baseWaterColor</code>:  rgba color object base color of the water.</li>
 *      <li><code>blendColor</code>:  rgba color object used when blending from water to non-water areas.</li>
 *      <li><code>specularMap</code>:  Single channel texture used to indicate areas of water.</li>
 *      <li><code>normalMap</code>:  Normal map for water normal perturbation.</li>
 *      <li><code>frequency</code>:  Number that controls the number of waves.</li>
 *      <li><code>animationSpeed</code>:  Number that controls the animations speed of the water.</li>
 *      <li><code>amplitude</code>:  Number that controls the amplitude of water waves.</li>
 *      <li><code>specularIntensity</code>:  Number that controls the intensity of specular reflections.</li>
 *  </ul>
 *  <li>RimLighting</li>
 *  <ul>
 *      <li><code>color</code>:  diffuse color and alpha.</li>
 *      <li><code>rimColor</code>:  diffuse color and alpha of the rim.</li>
 *      <li><code>width</code>:  Number that determines the rim's width.</li>
 *  </ul>
 *  <li>Fade</li>
 *  <ul>
 *      <li><code>fadeInColor</code>: diffuse color and alpha at <code>time</code></li>
 *      <li><code>fadeOutColor</code>: diffuse color and alpha at <code>maximumDistance</code> from <code>time</code></li>
 *      <li><code>maximumDistance</code>: Number between 0.0 and 1.0 where the <code>fadeInColor</code> becomes the <code>fadeOutColor</code>. A value of 0.0 gives the entire material a color of <code>fadeOutColor</code> and a value of 1.0 gives the the entire material a color of <code>fadeInColor</code></li>
 *      <li><code>repeat</code>: true if the fade should wrap around the texture coodinates.</li>
 *      <li><code>fadeDirection</code>: Object with x and y values specifying if the fade should be in the x and y directions.</li>
 *      <li><code>time</code>: Object with x and y values between 0.0 and 1.0 of the <code>fadeInColor</code> position</li>
 *  </ul>
 *  <li>PolylineArrow</li>
 *  <ul>
 *      <li><code>color</code>: diffuse color and alpha.</li>
 *  </ul>
 *  <li>PolylineDash</li>
 *  <ul>
 *      <li><code>color</code>: color for the line.</li>
 *      <li><code>gapColor</code>: color for the gaps in the line.</li>
 *      <li><code>dashLength</code>: Dash length in pixels.</li>
 *      <li><code>dashPattern</code>: The 16 bit stipple pattern for the line..</li>
 *  </ul>
 *  <li>PolylineGlow</li>
 *  <ul>
 *      <li><code>color</code>: color and maximum alpha for the glow on the line.</li>
 *      <li><code>glowPower</code>: strength of the glow, as a percentage of the total line width (less than 1.0).</li>
 *      <li><code>taperPower</code>: strength of the tapering effect, as a percentage of the total line length.  If 1.0 or higher, no taper effect is used.</li>
 *  </ul>
 *  <li>PolylineOutline</li>
 *  <ul>
 *      <li><code>color</code>: diffuse color and alpha for the interior of the line.</li>
 *      <li><code>outlineColor</code>: diffuse color and alpha for the outline.</li>
 *      <li><code>outlineWidth</code>: width of the outline in pixels.</li>
 *  </ul>
 *  <li>ElevationContour</li>
 *  <ul>
 *      <li><code>color</code>: color and alpha for the contour line.</li>
 *      <li><code>spacing</code>: spacing for contour lines in meters.</li>
 *      <li><code>width</code>: Number specifying the width of the grid lines in pixels.</li>
 *  </ul>
 *  <li>ElevationRamp</li>
 *  <ul>
 *      <li><code>image</code>: color ramp image to use for coloring the terrain.</li>
 *      <li><code>minimumHeight</code>: minimum height for the ramp.</li>
 *      <li><code>maximumHeight</code>: maximum height for the ramp.</li>
 *  </ul>
 *  <li>SlopeRamp</li>
 *  <ul>
 *      <li><code>image</code>: color ramp image to use for coloring the terrain by slope.</li>
 *  </ul>
 *  <li>AspectRamp</li>
 *  <ul>
 *      <li><code>image</code>: color ramp image to use for color the terrain by aspect.</li>
 *  </ul>
 *  <li>ElevationBand</li>
 *  <ul>
 *      <li><code>heights</code>: image of heights sorted from lowest to highest.</li>
 *      <li><code>colors</code>: image of colors at the corresponding heights.</li>
 * </ul>
 * </ul>
 * </ul>
 * </div>
 * @example
 * // Create a color material with fromType:
 * polygon.material = Cesium.Material.fromType('Color');
 * polygon.material.uniforms.color = new Cesium.Color(1.0, 1.0, 0.0, 1.0);
 *
 * // Create the default material:
 * polygon.material = new Cesium.Material();
 *
 * // Create a color material with full Fabric notation:
 * polygon.material = new Cesium.Material({
 *   fabric: {
 *     type: 'Color',
 *     uniforms: {
 *       color: new Cesium.Color(1.0, 1.0, 0.0, 1.0)
 *     }
 *   }
 * });
 * @param [options] - Object with the following properties:
 * @param [options.strict = false] - Throws errors for issues that would normally be ignored, including unused uniforms or materials.
 * @param [options.translucent = true] - When <code>true</code> or a function that returns <code>true</code>, the geometry
 *                           with this material is expected to appear translucent.
 * @param [options.minificationFilter = TextureMinificationFilter.LINEAR] - The {@link TextureMinificationFilter} to apply to this material's textures.
 * @param [options.magnificationFilter = TextureMagnificationFilter.LINEAR] - The {@link TextureMagnificationFilter} to apply to this material's textures.
 * @param options.fabric - The fabric JSON used to generate the material.
 * ructor
 */
export class Material {
    constructor(options?: {
        strict?: boolean;
        translucent?: boolean | ((...params: any[]) => any);
        minificationFilter?: TextureMinificationFilter;
        magnificationFilter?: TextureMagnificationFilter;
        fabric: any;
    });
    /**
     * The material type. Can be an existing type or a new type. If no type is specified in fabric, type is a GUID.
     */
    type: string;
    /**
     * The glsl shader source for this material.
     */
    shaderSource: string;
    /**
     * Maps sub-material names to Material objects.
     */
    materials: any;
    /**
     * Maps uniform names to their values.
     */
    uniforms: any;
    /**
     * When <code>true</code> or a function that returns <code>true</code>,
     * the geometry is expected to appear translucent.
     */
    translucent: boolean | ((...params: any[]) => any);
    /**
     * Creates a new material using an existing material type.
     * <br /><br />
     * Shorthand for: new Material({fabric : {type : type}});
     * @example
     * const material = Cesium.Material.fromType('Color', {
     *   color: new Cesium.Color(1.0, 0.0, 0.0, 1.0)
     * });
     * @param type - The base material type.
     * @param [uniforms] - Overrides for the default uniforms.
     * @returns New material object.
     */
    static fromType(type: string, uniforms?: any): Material;
    /**
     * Gets whether or not this material is translucent.
     * @returns <code>true</code> if this material is translucent, <code>false</code> otherwise.
     */
    isTranslucent(): boolean;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * @returns True if this object was destroyed; otherwise, false.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     * @example
     * material = material && material.destroy();
     */
    destroy(): void;
    /**
     * Gets or sets the default texture uniform value.
     */
    static DefaultImageId: string;
    /**
     * Gets or sets the default cube map texture uniform value.
     */
    static DefaultCubeMapId: string;
    /**
     * Gets the name of the color material.
     */
    static readonly ColorType: string;
    /**
     * Gets the name of the image material.
     */
    static readonly ImageType: string;
    /**
     * Gets the name of the diffuce map material.
     */
    static readonly DiffuseMapType: string;
    /**
     * Gets the name of the alpha map material.
     */
    static readonly AlphaMapType: string;
    /**
     * Gets the name of the specular map material.
     */
    static readonly SpecularMapType: string;
    /**
     * Gets the name of the emmision map material.
     */
    static readonly EmissionMapType: string;
    /**
     * Gets the name of the bump map material.
     */
    static readonly BumpMapType: string;
    /**
     * Gets the name of the normal map material.
     */
    static readonly NormalMapType: string;
    /**
     * Gets the name of the grid material.
     */
    static readonly GridType: string;
    /**
     * Gets the name of the stripe material.
     */
    static readonly StripeType: string;
    /**
     * Gets the name of the checkerboard material.
     */
    static readonly CheckerboardType: string;
    /**
     * Gets the name of the dot material.
     */
    static readonly DotType: string;
    /**
     * Gets the name of the water material.
     */
    static readonly WaterType: string;
    /**
     * Gets the name of the rim lighting material.
     */
    static readonly RimLightingType: string;
    /**
     * Gets the name of the fade material.
     */
    static readonly FadeType: string;
    /**
     * Gets the name of the polyline arrow material.
     */
    static readonly PolylineArrowType: string;
    /**
     * Gets the name of the polyline glow material.
     */
    static readonly PolylineDashType: string;
    /**
     * Gets the name of the polyline glow material.
     */
    static readonly PolylineGlowType: string;
    /**
     * Gets the name of the polyline outline material.
     */
    static readonly PolylineOutlineType: string;
    /**
     * Gets the name of the elevation contour material.
     */
    static readonly ElevationContourType: string;
    /**
     * Gets the name of the elevation contour material.
     */
    static readonly ElevationRampType: string;
    /**
     * Gets the name of the slope ramp material.
     */
    static readonly SlopeRampMaterialType: string;
    /**
     * Gets the name of the aspect ramp material.
     */
    static readonly AspectRampMaterialType: string;
    /**
     * Gets the name of the elevation band material.
     */
    static readonly ElevationBandType: string;
}

/**
 * An appearance for arbitrary geometry (as opposed to {@link EllipsoidSurfaceAppearance}, for example)
 * that supports shading with materials.
 * @example
 * const primitive = new Cesium.Primitive({
 *   geometryInstances : new Cesium.GeometryInstance({
 *     geometry : new Cesium.WallGeometry({
 *             materialSupport :  Cesium.MaterialAppearance.MaterialSupport.BASIC.vertexFormat,
 *       // ...
 *     })
 *   }),
 *   appearance : new Cesium.MaterialAppearance({
 *     material : Cesium.Material.fromType('Color'),
 *     faceForward : true
 *   })
 *
 * });
 * @param [options] - Object with the following properties:
 * @param [options.flat = false] - When <code>true</code>, flat shading is used in the fragment shader, which means lighting is not taking into account.
 * @param [options.faceForward = !options.closed] - When <code>true</code>, the fragment shader flips the surface normal as needed to ensure that the normal faces the viewer to avoid dark spots.  This is useful when both sides of a geometry should be shaded like {@link WallGeometry}.
 * @param [options.translucent = true] - When <code>true</code>, the geometry is expected to appear translucent so {@link MaterialAppearance#renderState} has alpha blending enabled.
 * @param [options.closed = false] - When <code>true</code>, the geometry is expected to be closed so {@link MaterialAppearance#renderState} has backface culling enabled.
 * @param [options.materialSupport = MaterialAppearance.MaterialSupport.TEXTURED] - The type of materials that will be supported.
 * @param [options.material = Material.ColorType] - The material used to determine the fragment color.
 * @param [options.vertexShaderSource] - Optional GLSL vertex shader source to override the default vertex shader.
 * @param [options.fragmentShaderSource] - Optional GLSL fragment shader source to override the default fragment shader.
 * @param [options.renderState] - Optional render state to override the default render state.
 */
export class MaterialAppearance {
    constructor(options?: {
        flat?: boolean;
        faceForward?: boolean;
        translucent?: boolean;
        closed?: boolean;
        materialSupport?: MaterialAppearance.MaterialSupportType;
        material?: Material;
        vertexShaderSource?: string;
        fragmentShaderSource?: string;
        renderState?: any;
    });
    /**
     * The material used to determine the fragment color.  Unlike other {@link MaterialAppearance}
     * properties, this is not read-only, so an appearance's material can change on the fly.
     */
    material: Material;
    /**
     * When <code>true</code>, the geometry is expected to appear translucent.
     */
    translucent: boolean;
    /**
     * The GLSL source code for the vertex shader.
     */
    readonly vertexShaderSource: string;
    /**
     * The GLSL source code for the fragment shader.  The full fragment shader
     * source is built procedurally taking into account {@link MaterialAppearance#material},
     * {@link MaterialAppearance#flat}, and {@link MaterialAppearance#faceForward}.
     * Use {@link MaterialAppearance#getFragmentShaderSource} to get the full source.
     */
    readonly fragmentShaderSource: string;
    /**
     * The WebGL fixed-function state to use when rendering the geometry.
     * <p>
     * The render state can be explicitly defined when constructing a {@link MaterialAppearance}
     * instance, or it is set implicitly via {@link MaterialAppearance#translucent}
     * and {@link MaterialAppearance#closed}.
     * </p>
     */
    readonly renderState: any;
    /**
     * When <code>true</code>, the geometry is expected to be closed so
     * {@link MaterialAppearance#renderState} has backface culling enabled.
     * If the viewer enters the geometry, it will not be visible.
     */
    readonly closed: boolean;
    /**
     * The type of materials supported by this instance.  This impacts the required
     * {@link VertexFormat} and the complexity of the vertex and fragment shaders.
     */
    readonly materialSupport: MaterialAppearance.MaterialSupportType;
    /**
     * The {@link VertexFormat} that this appearance instance is compatible with.
     * A geometry can have more vertex attributes and still be compatible - at a
     * potential performance cost - but it can't have less.
     */
    readonly vertexFormat: VertexFormat;
    /**
     * When <code>true</code>, flat shading is used in the fragment shader,
     * which means lighting is not taking into account.
     */
    readonly flat: boolean;
    /**
     * When <code>true</code>, the fragment shader flips the surface normal
     * as needed to ensure that the normal faces the viewer to avoid
     * dark spots.  This is useful when both sides of a geometry should be
     * shaded like {@link WallGeometry}.
     */
    readonly faceForward: boolean;
    /**
     * Procedurally creates the full GLSL fragment shader source.  For {@link MaterialAppearance},
     * this is derived from {@link MaterialAppearance#fragmentShaderSource}, {@link MaterialAppearance#material},
     * {@link MaterialAppearance#flat}, and {@link MaterialAppearance#faceForward}.
     * @returns The full GLSL fragment shader source.
     */
    getFragmentShaderSource(): string;
    /**
     * Determines if the geometry is translucent based on {@link MaterialAppearance#translucent} and {@link Material#isTranslucent}.
     * @returns <code>true</code> if the appearance is translucent.
     */
    isTranslucent(): boolean;
    /**
     * Creates a render state.  This is not the final render state instance; instead,
     * it can contain a subset of render state properties identical to the render state
     * created in the context.
     * @returns The render state.
     */
    getRenderState(): any;
}

export namespace MaterialAppearance {
    type MaterialSupportType = {
        vertexFormat: VertexFormat;
        vertexShaderSource: string;
        fragmentShaderSource: string;
    };
    /**
     * Determines the type of {@link Material} that is supported by a
     * {@link MaterialAppearance} instance.  This is a trade-off between
     * flexibility (a wide array of materials) and memory/performance
     * (required vertex format and GLSL shader complexity.
     */
    namespace MaterialSupport {
        /**
         * Only basic materials, which require just <code>position</code> and
         * <code>normal</code> vertex attributes, are supported.
         */
        const BASIC: MaterialAppearance.MaterialSupportType;
        /**
         * Materials with textures, which require <code>position</code>,
         * <code>normal</code>, and <code>st</code> vertex attributes,
         * are supported.  The vast majority of materials fall into this category.
         */
        const TEXTURED: MaterialAppearance.MaterialSupportType;
        /**
         * All materials, including those that work in tangent space, are supported.
         * This requires <code>position</code>, <code>normal</code>, <code>st</code>,
         * <code>tangent</code>, and <code>bitangent</code> vertex attributes.
         */
        const ALL: MaterialAppearance.MaterialSupportType;
    }
}

/**
 * A metadata class.
 *
 * <p>
 * See the {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Metadata|3D Metadata Specification} for 3D Tiles
 * </p>
 * @param options - Object with the following properties:
 * @param options.id - The ID of the class.
 * @param [options.name] - The name of the class.
 * @param [options.description] - The description of the class.
 * @param [options.properties] - The class properties, where each key is the property ID.
 * @param [options.extras] - Extra user-defined properties.
 * @param [options.extensions] - An object containing extensions.
 */
export class MetadataClass {
    constructor(options: {
        id: string;
        name?: string;
        description?: string;
        properties?: {
            [key: string]: MetadataClassProperty;
        };
        extras?: any;
        extensions?: any;
    });
    /**
     * The class properties.
     */
    readonly properties: {
        [key: string]: MetadataClassProperty;
    };
    /**
     * The ID of the class.
     */
    readonly id: string;
    /**
     * The name of the class.
     */
    readonly name: string;
    /**
     * The description of the class.
     */
    readonly description: string;
    /**
     * Extra user-defined properties.
     */
    readonly extras: any;
    /**
     * An object containing extensions.
     */
    readonly extensions: any;
}

/**
 * A metadata property, as part of a {@link MetadataClass}.
 * <p>
 * See the {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Metadata|3D Metadata Specification} for 3D Tiles
 * </p>
 * @param options - Object with the following properties:
 * @param options.id - The ID of the property.
 * @param options.type - The type of the property such as SCALAR, VEC2, VEC3.
 * @param [options.componentType] - The component type of the property. This includes integer (e.g. INT8 or UINT16), and floating point (FLOAT32 and FLOAT64) values.
 * @param [options.enumType] - The enum type of the property. Only defined when type is ENUM.
 * @param [options.isArray = false] - True if a property is an array (either fixed length or variable length), false otherwise.
 * @param [options.isVariableLengthArray = false] - True if a property is a variable length array, false otherwise.
 * @param [options.arrayLength] - The number of array elements. Only defined for fixed length arrays.
 * @param [options.normalized = false] - Whether the property is normalized.
 * @param [options.min] - A number or an array of numbers storing the minimum allowable value of this property. Only defined when type is a numeric type.
 * @param [options.max] - A number or an array of numbers storing the maximum allowable value of this property. Only defined when type is a numeric type.
 * @param [options.offset] - The offset to be added to property values as part of the value transform.
 * @param [options.scale] - The scale to be multiplied to property values as part of the value transform.
 * @param [options.noData] - The no-data sentinel value that represents null values.
 * @param [options.default] - A default value to use when an entity's property value is not defined.
 * @param [options.required = false] - Whether the property is required.
 * @param [options.name] - The name of the property.
 * @param [options.description] - The description of the property.
 * @param [options.semantic] - An identifier that describes how this property should be interpreted.
 * @param [options.extras] - Extra user-defined properties.
 * @param [options.extensions] - An object containing extensions.
 */
export class MetadataClassProperty {
    constructor(options: {
        id: string;
        type: MetadataType;
        componentType?: MetadataComponentType;
        enumType?: MetadataEnum;
        isArray?: boolean;
        isVariableLengthArray?: boolean;
        arrayLength?: number;
        normalized?: boolean;
        min?: number | number[] | number[][];
        max?: number | number[] | number[][];
        offset?: number | number[] | number[][];
        scale?: number | number[] | number[][];
        noData?: boolean | number | string | any[];
        default?: boolean | number | string | any[];
        required?: boolean;
        name?: string;
        description?: string;
        semantic?: string;
        extras?: any;
        extensions?: any;
    });
    /**
     * The ID of the property.
     */
    readonly id: string;
    /**
     * The name of the property.
     */
    readonly name: string;
    /**
     * The description of the property.
     */
    readonly description: string;
    /**
     * The type of the property such as SCALAR, VEC2, VEC3
     */
    readonly type: MetadataType;
    /**
     * The enum type of the property. Only defined when type is ENUM.
     */
    readonly enumType: MetadataEnum;
    /**
     * The component type of the property. This includes integer
     * (e.g. INT8 or UINT16), and floating point (FLOAT32 and FLOAT64) values
     */
    readonly componentType: MetadataComponentType;
    /**
     * True if a property is an array (either fixed length or variable length),
     * false otherwise.
     */
    readonly isArray: boolean;
    /**
     * True if a property is a variable length array, false otherwise.
     */
    readonly isVariableLengthArray: boolean;
    /**
     * The number of array elements. Only defined for fixed-size
     * arrays.
     */
    readonly arrayLength: number;
    /**
     * Whether the property is normalized.
     */
    readonly normalized: boolean;
    /**
     * A number or an array of numbers storing the maximum allowable value of this property. Only defined when type is a numeric type.
     */
    readonly max: number | number[] | number[][];
    /**
     * A number or an array of numbers storing the minimum allowable value of this property. Only defined when type is a numeric type.
     */
    readonly min: number | number[] | number[][];
    /**
     * The no-data sentinel value that represents null values
     */
    readonly noData: boolean | number | string | any[];
    /**
     * A default value to use when an entity's property value is not defined.
     */
    readonly default: boolean | number | string | any[];
    /**
     * Whether the property is required.
     */
    readonly required: boolean;
    /**
     * An identifier that describes how this property should be interpreted.
     */
    readonly semantic: string;
    /**
     * The offset to be added to property values as part of the value transform.
     */
    readonly offset: number | number[] | number[][];
    /**
     * The scale to be multiplied to property values as part of the value transform.
     */
    readonly scale: number | number[] | number[][];
    /**
     * Extra user-defined properties.
     */
    readonly extras: any;
    /**
     * An object containing extensions.
     */
    readonly extensions: any;
}

/**
 * An enum of metadata component types.
 */
export enum MetadataComponentType {
    /**
     * An 8-bit signed integer
     */
    INT8 = "INT8",
    /**
     * An 8-bit unsigned integer
     */
    UINT8 = "UINT8",
    /**
     * A 16-bit signed integer
     */
    INT16 = "INT16",
    /**
     * A 16-bit unsigned integer
     */
    UINT16 = "UINT16",
    /**
     * A 32-bit signed integer
     */
    INT32 = "INT32",
    /**
     * A 32-bit unsigned integer
     */
    UINT32 = "UINT32",
    /**
     * A 64-bit signed integer. This type requires BigInt support.
     */
    INT64 = "INT64",
    /**
     * A 64-bit signed integer. This type requires BigInt support
     */
    UINT64 = "UINT64",
    /**
     * A 32-bit (single precision) floating point number
     */
    FLOAT32 = "FLOAT32",
    /**
     * A 64-bit (double precision) floating point number
     */
    FLOAT64 = "FLOAT64"
}

/**
 * A metadata enum.
 * <p>
 * See the {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Metadata|3D Metadata Specification} for 3D Tiles
 * </p>
 * @param options - Object with the following properties:
 * @param options.id - The ID of the enum.
 * @param options.values - The enum values.
 * @param [options.valueType = MetadataComponentType.UINT16] - The enum value type.
 * @param [options.name] - The name of the enum.
 * @param [options.description] - The description of the enum.
 * @param [options.extras] - Extra user-defined properties.
 * @param [options.extensions] - An object containing extensions.
 */
export class MetadataEnum {
    constructor(options: {
        id: string;
        values: MetadataEnumValue[];
        valueType?: MetadataComponentType;
        name?: string;
        description?: string;
        extras?: any;
        extensions?: any;
    });
    /**
     * The enum values.
     */
    readonly values: MetadataEnumValue[];
    /**
     * The enum value type.
     */
    readonly valueType: MetadataComponentType;
    /**
     * The ID of the enum.
     */
    readonly id: string;
    /**
     * The name of the enum.
     */
    readonly name: string;
    /**
     * The description of the enum.
     */
    readonly description: string;
    /**
     * Extra user-defined properties.
     */
    readonly extras: any;
    /**
     * An object containing extensions.
     */
    readonly extensions: any;
}

/**
 * A metadata enum value.
 * <p>
 * See the {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Metadata|3D Metadata Specification} for 3D Tiles
 * </p>
 * @param options - Object with the following properties:
 * @param options.value - The integer value.
 * @param options.name - The name of the enum value.
 * @param [options.description] - The description of the enum value.
 * @param [options.extras] - Extra user-defined properties.
 * @param [options.extensions] - An object containing extensions.
 */
export class MetadataEnumValue {
    constructor(options: {
        value: number;
        name: string;
        description?: string;
        extras?: any;
        extensions?: any;
    });
    /**
     * The integer value.
     */
    readonly value: number;
    /**
     * The name of the enum value.
     */
    readonly name: string;
    /**
     * The description of the enum value.
     */
    readonly description: string;
    /**
     * Extra user-defined properties.
     */
    readonly extras: any;
    /**
     * An object containing extensions.
     */
    readonly extensions: any;
}

/**
 * A schema containing classes and enums.
 * <p>
 * See the {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Metadata|3D Metadata Specification} for 3D Tiles
 * </p>
 * @param options - Object with the following properties:
 * @param [options.id] - The ID of the schema
 * @param [options.name] - The name of the schema.
 * @param [options.description] - The description of the schema.
 * @param [options.version] - The application-specific version of the schema.
 * @param [options.classes] - Classes defined in the schema, where each key is the class ID.
 * @param [options.enums] - Enums defined in the schema, where each key is the enum ID.
 * @param [options.extras] - Extra user-defined properties.
 * @param [options.extensions] - An object containing extensions.
 */
export class MetadataSchema {
    constructor(options: {
        id?: string;
        name?: string;
        description?: string;
        version?: string;
        classes?: {
            [key: string]: MetadataClass;
        };
        enums?: {
            [key: string]: MetadataEnum;
        };
        extras?: any;
        extensions?: any;
    });
    /**
     * Classes defined in the schema.
     */
    readonly classes: {
        [key: string]: MetadataClass;
    };
    /**
     * Enums defined in the schema.
     */
    readonly enums: {
        [key: string]: MetadataEnum;
    };
    /**
     * The ID of the schema.
     */
    readonly id: string;
    /**
     * The name of the schema.
     */
    readonly name: string;
    /**
     * The description of the schema.
     */
    readonly description: string;
    /**
     * The application-specific version of the schema.
     */
    readonly version: string;
    /**
     * Extra user-defined properties.
     */
    readonly extras: any;
    /**
     * An object containing extensions.
     */
    readonly extensions: any;
}

/**
 * An enum of metadata types. These metadata types are containers containing
 * one or more components of type {@link MetadataComponentType}
 */
export enum MetadataType {
    /**
     * A single component
     */
    SCALAR = "SCALAR",
    /**
     * A vector with two components
     */
    VEC2 = "VEC2",
    /**
     * A vector with three components
     */
    VEC3 = "VEC3",
    /**
     * A vector with four components
     */
    VEC4 = "VEC4",
    /**
     * A 2x2 matrix, stored in column-major format.
     */
    MAT2 = "MAT2",
    /**
     * A 3x3 matrix, stored in column-major format.
     */
    MAT3 = "MAT3",
    /**
     * A 4x4 matrix, stored in column-major format.
     */
    MAT4 = "MAT4",
    /**
     * A boolean (true/false) value
     */
    BOOLEAN = "BOOLEAN",
    /**
     * A UTF-8 encoded string value
     */
    STRING = "STRING",
    /**
     * An enumerated value. This type is used in conjunction with a {@link MetadataEnum} to describe the valid values.
     */
    ENUM = "ENUM"
}

/**
 * An object describing a uniform, its type, and an initial value
 * type - The Glsl type of the uniform.
 * value - The initial value of the uniform
 */
export type UniformSpecifier = {
    type: UniformType;
    value: boolean | number | Cartesian2 | Cartesian3 | Cartesian4 | Matrix2 | Matrix3 | Matrix4 | TextureUniform;
};

/**
 * A user defined GLSL shader used with {@link Model} as well
 * as {@link Cesium3DTileset}.
 * <p>
 * If texture uniforms are used, additional resource management must be done:
 * </p>
 * <ul>
 *   <li>
 *      The <code>update</code> function must be called each frame. When a
 *      custom shader is passed to a {@link Model} or a
 *      {@link Cesium3DTileset}, this step is handled automaticaly
 *   </li>
 *   <li>
 *      {@link CustomShader#destroy} must be called when the custom shader is
 *      no longer needed to clean up GPU resources properly. The application
 *      is responsible for calling this method.
 *   </li>
 * </ul>
 * <p>
 * See the {@link https://github.com/CesiumGS/cesium/tree/main/Documentation/CustomShaderGuide|Custom Shader Guide} for more detailed documentation.
 * </p>
 * @example
 * const customShader = new CustomShader({
 *   uniforms: {
 *     u_colorIndex: {
 *       type: Cesium.UniformType.FLOAT,
 *       value: 1.0
 *     },
 *     u_normalMap: {
 *       type: Cesium.UniformType.SAMPLER_2D,
 *       value: new Cesium.TextureUniform({
 *         url: "http://example.com/normal.png"
 *       })
 *     }
 *   },
 *   varyings: {
 *     v_selectedColor: Cesium.VaryingType.VEC3
 *   },
 *   vertexShaderText: `
 *   void vertexMain(VertexInput vsInput, inout czm_modelVertexOutput vsOutput) {
 *     v_selectedColor = mix(vsInput.attributes.color_0, vsInput.attributes.color_1, u_colorIndex);
 *     vsOutput.positionMC += 0.1 * vsInput.attributes.normal;
 *   }
 *   `,
 *   fragmentShaderText: `
 *   void fragmentMain(FragmentInput fsInput, inout czm_modelMaterial material) {
 *     material.normal = texture(u_normalMap, fsInput.attributes.texCoord_0);
 *     material.diffuse = v_selectedColor;
 *   }
 *   `
 * });
 * @param options - An object with the following options
 * @param [options.mode = CustomShaderMode.MODIFY_MATERIAL] - The custom shader mode, which determines how the custom shader code is inserted into the fragment shader.
 * @param [options.lightingModel] - The lighting model (e.g. PBR or unlit). If present, this overrides the default lighting for the model.
 * @param [options.translucencyMode = CustomShaderTranslucencyMode.INHERIT] - The translucency mode, which determines how the custom shader will be applied. If the value is CustomShaderTransulcencyMode.OPAQUE or CustomShaderTransulcencyMode.TRANSLUCENT, the custom shader will override settings from the model's material. If the value is CustomShaderTransulcencyMode.INHERIT, the custom shader will render as either opaque or translucent depending on the primitive's material settings.
 * @param [options.uniforms] - A dictionary for user-defined uniforms. The key is the uniform name that will appear in the GLSL code. The value is an object that describes the uniform type and initial value
 * @param [options.varyings] - A dictionary for declaring additional GLSL varyings used in the shader. The key is the varying name that will appear in the GLSL code. The value is the data type of the varying. For each varying, the declaration will be added to the top of the shader automatically. The caller is responsible for assigning a value in the vertex shader and using the value in the fragment shader.
 * @param [options.vertexShaderText] - The custom vertex shader as a string of GLSL code. It must include a GLSL function called vertexMain. See the example for the expected signature. If not specified, the custom vertex shader step will be skipped in the computed vertex shader.
 * @param [options.fragmentShaderText] - The custom fragment shader as a string of GLSL code. It must include a GLSL function called fragmentMain. See the example for the expected signature. If not specified, the custom fragment shader step will be skipped in the computed fragment shader.
 */
export class CustomShader {
    constructor(options: {
        mode?: CustomShaderMode;
        lightingModel?: LightingModel;
        translucencyMode?: CustomShaderTranslucencyMode;
        uniforms?: {
            [key: string]: UniformSpecifier;
        };
        varyings?: {
            [key: string]: VaryingType;
        };
        vertexShaderText?: string;
        fragmentShaderText?: string;
    });
    /**
     * A value determining how the custom shader interacts with the overall
     * fragment shader. This is used by {@link CustomShaderPipelineStage}
     */
    readonly mode: CustomShaderMode;
    /**
     * The lighting model to use when using the custom shader.
     * This is used by {@link CustomShaderPipelineStage}
     */
    readonly lightingModel: LightingModel;
    /**
     * Additional uniforms as declared by the user.
     */
    readonly uniforms: {
        [key: string]: UniformSpecifier;
    };
    /**
     * Additional varyings as declared by the user.
     * This is used by {@link CustomShaderPipelineStage}
     */
    readonly varyings: {
        [key: string]: VaryingType;
    };
    /**
     * The user-defined GLSL code for the vertex shader
     */
    readonly vertexShaderText: string;
    /**
     * The user-defined GLSL code for the fragment shader
     */
    readonly fragmentShaderText: string;
    /**
     * The translucency mode, which determines how the custom shader will be applied. If the value is
     * CustomShaderTransulcencyMode.OPAQUE or CustomShaderTransulcencyMode.TRANSLUCENT, the custom shader
     * will override settings from the model's material. If the value isCustomShaderTransulcencyMode.INHERIT,
     * the custom shader will render as either opaque or translucent depending on the primitive's material settings.
     */
    readonly translucencyMode: CustomShaderTranslucencyMode;
    /**
     * Update the value of a uniform declared in the shader
     * @param uniformName - The GLSL name of the uniform. This must match one of the uniforms declared in the constructor
     * @param value - The new value of the uniform.
     */
    setUniform(uniformName: string, value: boolean | number | Cartesian2 | Cartesian3 | Cartesian4 | Matrix2 | Matrix3 | Matrix4 | string | Resource | TextureUniform): void;
}

/**
 * An enum describing how the {@link CustomShader} will be added to the
 * fragment shader. This determines how the shader interacts with the material.
 */
export enum CustomShaderMode {
    /**
     * The custom shader will be used to modify the results of the material stage
     * before lighting is applied.
     */
    MODIFY_MATERIAL = "MODIFY_MATERIAL",
    /**
     * The custom shader will be used instead of the material stage. This is a hint
     * to optimize out the material processing code.
     */
    REPLACE_MATERIAL = "REPLACE_MATERIAL"
}

/**
 * An enum for controling how {@link CustomShader} handles translucency compared with the original
 * primitive.
 */
export enum CustomShaderTranslucencyMode {
    /**
     * Inherit translucency settings from the primitive's material. If the primitive used a
     * translucent material, the custom shader will also be considered translucent. If the primitive
     * used an opaque material, the custom shader will be considered opaque.
     */
    INHERIT = 0,
    /**
     * Force the primitive to render the primitive as opaque, ignoring any material settings.
     */
    OPAQUE = 1,
    /**
     * Force the primitive to render the primitive as translucent, ignoring any material settings.
     */
    TRANSLUCENT = 2
}

/**
 * The lighting model to use for lighting a {@link Model}.
 */
export enum LightingModel {
    /**
     * Use unlit shading, i.e. skip lighting calculations. The model's
     * diffuse color (assumed to be linear RGB, not sRGB) is used directly
     * when computing <code>out_FragColor</code>. The alpha mode is still
     * applied.
     */
    UNLIT = 0,
    /**
     * Use physically-based rendering lighting calculations. This includes
     * both PBR metallic roughness and PBR specular glossiness. Image-based
     * lighting is also applied when possible.
     */
    PBR = 1
}

/**
 * <div class="notice">
 * To construct a Model, call {@link Model.fromGltfAsync}. Do not call the constructor directly.
 * </div>
 * A 3D model based on glTF, the runtime asset format for WebGL, OpenGL ES, and OpenGL.
 * <p>
 * Cesium supports glTF assets with the following extensions:
 * <ul>
 *  <li>
 *  {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/AGI_articulations/README.md|AGI_articulations}
 *  </li>
 *  <li>
 *  {@link https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Vendor/CESIUM_primitive_outline|CESIUM_primitive_outline}
 *  </li>
 *  <li>
 *  {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/1.0/Vendor/CESIUM_RTC/README.md|CESIUM_RTC}
 *  </li>
 *  <li>
 *  {@link https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_instance_features|EXT_instance_features}
 *  </li>
 *  <li>
 *  {@link https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_mesh_features|EXT_mesh_features}
 *  </li>
 *  <li>
 *  {@link https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Vendor/EXT_mesh_gpu_instancing|EXT_mesh_gpu_instancing}
 *  </li>
 *  <li>
 *  {@link https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Vendor/EXT_meshopt_compression|EXT_meshopt_compression}
 *  </li>
 *  <li>
 *  {@link https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_structural_metadata|EXT_structural_metadata}
 *  </li>
 *  <li>
 *  {@link https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Vendor/EXT_texture_webp|EXT_texture_webp}
 *  </li>
 *  <li>
 *  {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_draco_mesh_compression/README.md|KHR_draco_mesh_compression}
 *  </li>
 *  <li>
 *  {@link https://github.com/KhronosGroup/glTF/blob/main/extensions/2.0/Archived/KHR_techniques_webgl/README.md|KHR_techniques_webgl}
 *  </li>
 *  <li>
 *  {@link https://github.com/KhronosGroup/glTF/blob/main/extensions/1.0/Khronos/KHR_materials_common/README.md|KHR_materials_common}
 *  </li>
 *  <li>
 *  {@link https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Archived/KHR_materials_pbrSpecularGlossiness|KHR_materials_pbrSpecularGlossiness}
 *  </li>
 *  <li>
 *  {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Khronos/KHR_materials_unlit/README.md|KHR_materials_unlit}
 *  </li>
 *  <li>
 *  {@link https://github.com/KhronosGroup/glTF/tree/main/extensions/2.0/Khronos/KHR_mesh_quantization|KHR_mesh_quantization}
 *  </li>
 *  <li>
 *  {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_texture_basisu|KHR_texture_basisu}
 *  </li>
 *  <li>
 *  {@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_texture_transform/README.md|KHR_texture_transform}
 *  </li>
 *  <li>
 *  {@link https://github.com/KhronosGroup/glTF/blob/main/extensions/1.0/Vendor/WEB3D_quantized_attributes/README.md|WEB3D_quantized_attributes}
 *  </li>
 * </ul>
 * </p>
 * <p>
 * Note: for models with compressed textures using the KHR_texture_basisu extension, we recommend power of 2 textures in both dimensions
 * for maximum compatibility. This is because some samplers require power of 2 textures ({@link https://developer.mozilla.org/en-US/docs/Web/API/WebGL_API/Tutorial/Using_textures_in_WebGL|Using textures in WebGL})
 * and KHR_texture_basisu requires multiple of 4 dimensions ({@link https://github.com/KhronosGroup/glTF/blob/master/extensions/2.0/Khronos/KHR_texture_basisu/README.md#additional-requirements|KHR_texture_basisu additional requirements}).
 * </p>
 */
export class Model {
    constructor();
    /**
     * The 4x4 transformation matrix that transforms the model from model to world coordinates.
     * When this is the identity matrix, the model is drawn in world coordinates, i.e., Earth's Cartesian WGS84 coordinates.
     * Local reference frames can be used by providing a different transformation matrix, like that returned
     * by {@link Transforms.eastNorthUpToFixedFrame}.
     * @example
     * const origin = Cesium.Cartesian3.fromDegrees(-95.0, 40.0, 200000.0);
     * m.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);
     */
    modelMatrix: Matrix4;
    /**
     * Whether to display the outline for models using the
     * {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/CESIUM_primitive_outline|CESIUM_primitive_outline} extension.
     * When true, outlines are displayed. When false, outlines are not displayed.
     */
    showOutline: boolean;
    /**
     * The color to use when rendering outlines.
     */
    outlineColor: Color;
    /**
     * When <code>true</code>, this model is ready to render, i.e., the external binary, image,
     * and shader files were downloaded and the WebGL resources were created.
     */
    readonly ready: boolean;
    /**
     * Gets an event that is raised when the model encounters an asynchronous rendering error.  By subscribing
     * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
     * are passed an instance of {@link ModelError}.
     */
    readonly errorEvent: Event;
    /**
     * Gets an event that is raised when the model is loaded and ready for rendering, i.e. when the external resources
     * have been downloaded and the WebGL resources are created. Event listeners
     * are passed an instance of the {@link Model}.
     *
     * <p>
     * If {@link Model.incrementallyLoadTextures} is true, this event will be raised before all textures are loaded and ready for rendering. Subscribe to {@link Model.texturesReadyEvent} to be notified when the textures are ready.
     * </p>
     */
    readonly readyEvent: Event;
    /**
     * Gets an event that, if {@link Model.incrementallyLoadTextures} is true, is raised when the model textures are loaded and ready for rendering, i.e. when the external resources
     * have been downloaded and the WebGL resources are created. Event listeners
     * are passed an instance of the {@link Model}.
     */
    readonly texturesReadyEvent: Event;
    /**
     * The currently playing glTF animations.
     */
    readonly activeAnimations: ModelAnimationCollection;
    /**
     * Determines if the model's animations should hold a pose over frames where no keyframes are specified.
     */
    clampAnimations: boolean;
    /**
     * Point cloud shading settings for controlling point cloud attenuation
     * and lighting. For 3D Tiles, this is inherited from the
     * {@link Cesium3DTileset}.
     */
    pointCloudShading: PointCloudShading;
    /**
     * The model's custom shader, if it exists. Using custom shaders with a {@link Cesium3DTileStyle}
     * may lead to undefined behavior.
     */
    customShader: CustomShader;
    /**
     * The height reference of the model, which determines how the model is drawn
     * relative to terrain.
     */
    heightReference: HeightReference;
    /**
     * Gets or sets the distance display condition, which specifies at what distance
     * from the camera this model will be displayed.
     */
    distanceDisplayCondition: DistanceDisplayCondition;
    /**
     * A user-defined object that is returned when the model is picked.
     */
    id: any;
    /**
     * The style to apply to the features in the model. Cannot be applied if a {@link CustomShader} is also applied.
     */
    style: Cesium3DTileStyle;
    /**
     * The color to blend with the model's rendered color.
     */
    color: Color;
    /**
     * Defines how the color blends with the model.
     */
    colorBlendMode: Cesium3DTileColorBlendMode | ColorBlendMode;
    /**
     * Value used to determine the color strength when the <code>colorBlendMode</code> is <code>MIX</code>. A value of 0.0 results in the model's rendered color while a value of 1.0 results in a solid color, with any value in-between resulting in a mix of the two.
     */
    colorBlendAmount: number;
    /**
     * The silhouette color.
     */
    silhouetteColor: Color;
    /**
     * The size of the silhouette in pixels.
     */
    silhouetteSize: number;
    /**
     * Gets the model's bounding sphere in world space. This does not take into account
     * glTF animations, skins, or morph targets. It also does not account for
     * {@link Model#minimumPixelSize}.
     */
    readonly boundingSphere: BoundingSphere;
    /**
     * This property is for debugging only; it is not for production use nor is it optimized.
     * <p>
     * Draws the bounding sphere for each draw command in the model.
     * </p>
     */
    debugShowBoundingVolume: boolean;
    /**
     * This property is for debugging only; it is not for production use nor is it optimized.
     * <p>
     * Draws the model in wireframe.
     * </p>
     */
    debugWireframe: boolean;
    /**
     * Whether or not to render the model.
     */
    show: boolean;
    /**
     * Label of the feature ID set to use for picking and styling.
     * <p>
     * For EXT_mesh_features, this is the feature ID's label property, or
     * "featureId_N" (where N is the index in the featureIds array) when not
     * specified. EXT_feature_metadata did not have a label field, so such
     * feature ID sets are always labeled "featureId_N" where N is the index in
     * the list of all feature Ids, where feature ID attributes are listed before
     * feature ID textures.
     * </p>
     * <p>
     * If featureIdLabel is set to an integer N, it is converted to
     * the string "featureId_N" automatically. If both per-primitive and
     * per-instance feature IDs are present, the instance feature IDs take
     * priority.
     * </p>
     */
    featureIdLabel: string;
    /**
     * Label of the instance feature ID set used for picking and styling.
     * <p>
     * If instanceFeatureIdLabel is set to an integer N, it is converted to
     * the string "instanceFeatureId_N" automatically.
     * If both per-primitive and per-instance feature IDs are present, the
     * instance feature IDs take priority.
     * </p>
     */
    instanceFeatureIdLabel: string;
    /**
     * The {@link ClippingPlaneCollection} used to selectively disable rendering the model.
     */
    clippingPlanes: ClippingPlaneCollection;
    /**
     * The light color when shading the model. When <code>undefined</code> the scene's light color is used instead.
     * <p>
     * Disabling additional light sources by setting
     * <code>model.imageBasedLighting.imageBasedLightingFactor = new Cartesian2(0.0, 0.0)</code>
     * will make the model much darker. Here, increasing the intensity of the light source will make the model brighter.
     * </p>
     */
    lightColor: Cartesian3;
    /**
     * The properties for managing image-based lighting on this model.
     */
    imageBasedLighting: ImageBasedLighting;
    /**
     * Whether to cull back-facing geometry. When true, back face culling is
     * determined by the material's doubleSided property; when false, back face
     * culling is disabled. Back faces are not culled if {@link Model#color}
     * is translucent or {@link Model#silhouetteSize} is greater than 0.0.
     */
    backFaceCulling: boolean;
    /**
     * A uniform scale applied to this model before the {@link Model#modelMatrix}.
     * Values greater than <code>1.0</code> increase the size of the model; values
     * less than <code>1.0</code> decrease.
     */
    scale: number;
    /**
     * The approximate minimum pixel size of the model regardless of zoom.
     * This can be used to ensure that a model is visible even when the viewer
     * zooms out.  When <code>0.0</code>, no minimum size is enforced.
     */
    minimumPixelSize: number;
    /**
     * The maximum scale size for a model. This can be used to give
     * an upper limit to the {@link Model#minimumPixelSize}, ensuring that the model
     * is never an unreasonable scale.
     */
    maximumScale: number;
    /**
     * Determines whether the model casts or receives shadows from light sources.
     */
    shadows: ShadowMode;
    /**
     * Gets the credit that will be displayed for the model.
     */
    readonly credit: Credit;
    /**
     * Gets or sets whether the credits of the model will be displayed
     * on the screen.
     */
    showCreditsOnScreen: boolean;
    /**
     * The {@link SplitDirection} to apply to this model.
     */
    splitDirection: SplitDirection;
    /**
     * Gets the model's classification type. This determines whether terrain,
     * 3D Tiles, or both will be classified by this model.
     * <p>
     * Additionally, there are a few requirements/limitations:
     * <ul>
     *     <li>The glTF cannot contain morph targets, skins, or animations.</li>
     *     <li>The glTF cannot contain the <code>EXT_mesh_gpu_instancing</code> extension.</li>
     *     <li>Only meshes with TRIANGLES can be used to classify other assets.</li>
     *     <li>The position attribute is required.</li>
     *     <li>If feature IDs and an index buffer are both present, all indices with the same feature id must occupy contiguous sections of the index buffer.</li>
     *     <li>If feature IDs are present without an index buffer, all positions with the same feature id must occupy contiguous sections of the position buffer.</li>
     * </ul>
     * </p>
     */
    readonly classificationType: ClassificationType;
    /**
     * Returns the node with the given <code>name</code> in the glTF. This is used to
     * modify a node's transform for user-defined animation.
     * @example
     * // Apply non-uniform scale to node "Hand"
     * const node = model.getNode("Hand");
     * node.matrix = Cesium.Matrix4.fromScale(new Cesium.Cartesian3(5.0, 1.0, 1.0), node.matrix);
     * @param name - The name of the node in the glTF.
     * @returns The node, or <code>undefined</code> if no node with the <code>name</code> exists.
     */
    getNode(name: string): ModelNode;
    /**
     * Sets the current value of an articulation stage.  After setting one or
     * multiple stage values, call Model.applyArticulations() to
     * cause the node matrices to be recalculated.
     * @example
     * // Sets the value of the stage named "MoveX" belonging to the articulation named "SampleArticulation"
     * model.setArticulationStage("SampleArticulation MoveX", 50.0);
     * @param articulationStageKey - The name of the articulation, a space, and the name of the stage.
     * @param value - The numeric value of this stage of the articulation.
     */
    setArticulationStage(articulationStageKey: string, value: number): void;
    /**
     * Applies any modified articulation stages to the matrix of each node that
     * participates in any articulation. Note that this will overwrite any node
     * transformations on participating nodes.
     */
    applyArticulations(): void;
    /**
     * Marks the model's {@link Model#style} as dirty, which forces all features
     * to re-evaluate the style in the next frame the model is visible.
     */
    makeStyleDirty(): void;
    /**
     * Called when {@link Viewer} or {@link CesiumWidget} render the scene to
     * get the draw commands needed to render this primitive.
     * <p>
     * Do not call this function directly.  This is documented just to
     * list the exceptions that may be propagated when the scene is rendered:
     * </p>
     */
    update(): void;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     * @example
     * model = model && model.destroy();
     */
    destroy(): void;
    /**
     * <p>
     * Asynchronously creates a model from a glTF asset. This function returns a promise that resolves when the model is ready to render, i.e., when the external binary, image,
     * and shader files are downloaded and the WebGL resources are created.
     * </p>
     * <p>
     * The model can be a traditional glTF asset with a .gltf extension or a Binary glTF using the .glb extension.
     * @example
     * // Load a model and add it to the scene
     * try {
     *  const model = await Cesium.Model.fromGltfAsync({
     *    url: "../../SampleData/models/CesiumMan/Cesium_Man.glb"
     *  });
     *  viewer.scene.primitives.add(model);
     * } catch (error) {
     *  console.log(`Failed to load model. ${error}`);
     * }
     * @example
     * // Position a model with modelMatrix and display it with a minimum size of 128 pixels
     * const position = Cesium.Cartesian3.fromDegrees(
     *   -123.0744619,
     *   44.0503706,
     *   5000.0
     * );
     * const headingPositionRoll = new Cesium.HeadingPitchRoll();
     * const fixedFrameTransform = Cesium.Transforms.localFrameToFixedFrameGenerator(
     *   "north",
     *   "west"
     * );
     * try {
     *  const model = await Cesium.Model.fromGltfAsync({
     *    url: "../../SampleData/models/CesiumAir/Cesium_Air.glb",
     *    modelMatrix: Cesium.Transforms.headingPitchRollToFixedFrame(
     *      position,
     *      headingPositionRoll,
     *      Cesium.Ellipsoid.WGS84,
     *      fixedFrameTransform
     *    ),
     *    minimumPixelSize: 128,
     *  });
     *  viewer.scene.primitives.add(model);
     * } catch (error) {
     *  console.log(`Failed to load model. ${error}`);
     * }
     * @example
     * // Load a model and play the last animation at half speed
     * let animations;
     * try {
     *  const model = await Cesium.Model.fromGltfAsync({
     *    url: "../../SampleData/models/CesiumMan/Cesium_Man.glb",
     *    gltfCallback: gltf => {
     *      animations = gltf.animations
     *    }
     *  });
     *  viewer.scene.primitives.add(model);
     *  model.readyEvent.addEventListener(() => {
     *    model.activeAnimations.add({
     *      index: animations.length - 1,
     *      loop: Cesium.ModelAnimationLoop.REPEAT,
     *      multiplier: 0.5,
     *    });
     *  });
     * } catch (error) {
     *  console.log(`Failed to load model. ${error}`);
     * }
     * @param options - Object with the following properties:
     * @param options.url - The url to the .gltf or .glb file.
     * @param [options.basePath = ''] - The base path that paths in the glTF JSON are relative to.
     * @param [options.show = true] - Whether or not to render the model.
     * @param [options.modelMatrix = Matrix4.IDENTITY] - The 4x4 transformation matrix that transforms the model from model to world coordinates.
     * @param [options.scale = 1.0] - A uniform scale applied to this model.
     * @param [options.minimumPixelSize = 0.0] - The approximate minimum pixel size of the model regardless of zoom.
     * @param [options.maximumScale] - The maximum scale size of a model. An upper limit for minimumPixelSize.
     * @param [options.id] - A user-defined object to return when the model is picked with {@link Scene#pick}.
     * @param [options.allowPicking = true] - When <code>true</code>, each primitive is pickable with {@link Scene#pick}.
     * @param [options.incrementallyLoadTextures = true] - Determine if textures may continue to stream in after the model is loaded.
     * @param [options.asynchronous = true] - Determines if model WebGL resource creation will be spread out over several frames or block until completion once all glTF files are loaded.
     * @param [options.clampAnimations = true] - Determines if the model's animations should hold a pose over frames where no keyframes are specified.
     * @param [options.shadows = ShadowMode.ENABLED] - Determines whether the model casts or receives shadows from light sources.
     * @param [options.releaseGltfJson = false] - When true, the glTF JSON is released once the glTF is loaded. This is is especially useful for cases like 3D Tiles, where each .gltf model is unique and caching the glTF JSON is not effective.
     * @param [options.debugShowBoundingVolume = false] - For debugging only. Draws the bounding sphere for each draw command in the model.
     * @param [options.enableDebugWireframe = false] - For debugging only. This must be set to true for debugWireframe to work in WebGL1. This cannot be set after the model has loaded.
     * @param [options.debugWireframe = false] - For debugging only. Draws the model in wireframe. Will only work for WebGL1 if enableDebugWireframe is set to true.
     * @param [options.cull = true] - Whether or not to cull the model using frustum/horizon culling. If the model is part of a 3D Tiles tileset, this property will always be false, since the 3D Tiles culling system is used.
     * @param [options.opaquePass = Pass.OPAQUE] - The pass to use in the {@link DrawCommand} for the opaque portions of the model.
     * @param [options.upAxis = Axis.Y] - The up-axis of the glTF model.
     * @param [options.forwardAxis = Axis.Z] - The forward-axis of the glTF model.
     * @param [options.customShader] - A custom shader. This will add user-defined GLSL code to the vertex and fragment shaders. Using custom shaders with a {@link Cesium3DTileStyle} may lead to undefined behavior.
     * @param [options.content] - The tile content this model belongs to. This property will be undefined if model is not loaded as part of a tileset.
     * @param [options.heightReference = HeightReference.NONE] - Determines how the model is drawn relative to terrain.
     * @param [options.scene] - Must be passed in for models that use the height reference property.
     * @param [options.distanceDisplayCondition] - The condition specifying at what distance from the camera that this model will be displayed.
     * @param [options.color] - A color that blends with the model's rendered color.
     * @param [options.colorBlendMode = ColorBlendMode.HIGHLIGHT] - Defines how the color blends with the model.
     * @param [options.colorBlendAmount = 0.5] - Value used to determine the color strength when the <code>colorBlendMode</code> is <code>MIX</code>. A value of 0.0 results in the model's rendered color while a value of 1.0 results in a solid color, with any value in-between resulting in a mix of the two.
     * @param [options.silhouetteColor = Color.RED] - The silhouette color. If more than 256 models have silhouettes enabled, there is a small chance that overlapping models will have minor artifacts.
     * @param [options.silhouetteSize = 0.0] - The size of the silhouette in pixels.
     * @param [options.enableShowOutline = true] - Whether to enable outlines for models using the {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/CESIUM_primitive_outline|CESIUM_primitive_outline} extension. This can be set false to avoid post-processing geometry at load time. When false, the showOutlines and outlineColor options are ignored.
     * @param [options.showOutline = true] - Whether to display the outline for models using the {@link https://github.com/KhronosGroup/glTF/tree/master/extensions/2.0/Vendor/CESIUM_primitive_outline|CESIUM_primitive_outline} extension. When true, outlines are displayed. When false, outlines are not displayed.
     * @param [options.outlineColor = Color.BLACK] - The color to use when rendering outlines.
     * @param [options.clippingPlanes] - The {@link ClippingPlaneCollection} used to selectively disable rendering the model.
     * @param [options.lightColor] - The light color when shading the model. When <code>undefined</code> the scene's light color is used instead.
     * @param [options.imageBasedLighting] - The properties for managing image-based lighting on this model.
     * @param [options.backFaceCulling = true] - Whether to cull back-facing geometry. When true, back face culling is determined by the material's doubleSided property; when false, back face culling is disabled. Back faces are not culled if the model's color is translucent.
     * @param [options.credit] - A credit for the data source, which is displayed on the canvas.
     * @param [options.showCreditsOnScreen = false] - Whether to display the credits of this model on screen.
     * @param [options.splitDirection = SplitDirection.NONE] - The {@link SplitDirection} split to apply to this model.
     * @param [options.projectTo2D = false] - Whether to accurately project the model's positions in 2D. If this is true, the model will be projected accurately to 2D, but it will use more memory to do so. If this is false, the model will use less memory and will still render in 2D / CV mode, but its positions may be inaccurate. This disables minimumPixelSize and prevents future modification to the model matrix. This also cannot be set after the model has loaded.
     * @param [options.featureIdLabel = "featureId_0"] - Label of the feature ID set to use for picking and styling. For EXT_mesh_features, this is the feature ID's label property, or "featureId_N" (where N is the index in the featureIds array) when not specified. EXT_feature_metadata did not have a label field, so such feature ID sets are always labeled "featureId_N" where N is the index in the list of all feature Ids, where feature ID attributes are listed before feature ID textures. If featureIdLabel is an integer N, it is converted to the string "featureId_N" automatically. If both per-primitive and per-instance feature IDs are present, the instance feature IDs take priority.
     * @param [options.instanceFeatureIdLabel = "instanceFeatureId_0"] - Label of the instance feature ID set used for picking and styling. If instanceFeatureIdLabel is set to an integer N, it is converted to the string "instanceFeatureId_N" automatically. If both per-primitive and per-instance feature IDs are present, the instance feature IDs take priority.
     * @param [options.pointCloudShading] - Options for constructing a {@link PointCloudShading} object to control point attenuation and lighting.
     * @param [options.classificationType] - Determines whether terrain, 3D Tiles or both will be classified by this model. This cannot be set after the model has loaded.
     * @param [options.gltfCallback] - A function that is called with the loaded gltf object once loaded.
     * @returns A promise that resolves to the created model when it is ready to render.
     */
    static fromGltfAsync(options: {
        url: string | Resource;
        basePath?: string | Resource;
        show?: boolean;
        modelMatrix?: Matrix4;
        scale?: number;
        minimumPixelSize?: number;
        maximumScale?: number;
        id?: any;
        allowPicking?: boolean;
        incrementallyLoadTextures?: boolean;
        asynchronous?: boolean;
        clampAnimations?: boolean;
        shadows?: ShadowMode;
        releaseGltfJson?: boolean;
        debugShowBoundingVolume?: boolean;
        enableDebugWireframe?: boolean;
        debugWireframe?: boolean;
        cull?: boolean;
        opaquePass?: boolean;
        upAxis?: Axis;
        forwardAxis?: Axis;
        customShader?: CustomShader;
        content?: Cesium3DTileContent;
        heightReference?: HeightReference;
        scene?: Scene;
        distanceDisplayCondition?: DistanceDisplayCondition;
        color?: Color;
        colorBlendMode?: ColorBlendMode;
        colorBlendAmount?: number;
        silhouetteColor?: Color;
        silhouetteSize?: number;
        enableShowOutline?: boolean;
        showOutline?: boolean;
        outlineColor?: Color;
        clippingPlanes?: ClippingPlaneCollection;
        lightColor?: Cartesian3;
        imageBasedLighting?: ImageBasedLighting;
        backFaceCulling?: boolean;
        credit?: Credit | string;
        showCreditsOnScreen?: boolean;
        splitDirection?: SplitDirection;
        projectTo2D?: boolean;
        featureIdLabel?: string | number;
        instanceFeatureIdLabel?: string | number;
        pointCloudShading?: any;
        classificationType?: ClassificationType;
        gltfCallback?: Model.GltfCallback;
    }): Promise<Model>;
}

export namespace Model {
    /**
     * Interface for the function that is called with the loaded gltf object once loaded.
     * @param gltf - The gltf object
     */
    type GltfCallback = (gltf: any) => void;
}

/**
 * <div class="notice">
 * Create animations by calling {@link ModelAnimationCollection#add}. Do not call the constructor directly.
 * </div>
 *
 * An active animation derived from a glTF asset. An active animation is an
 * animation that is either currently playing or scheduled to be played due to
 * being added to a model's {@link ModelAnimationCollection}. An active animation
 * is an instance of an animation; for example, there can be multiple active
 * animations for the same glTF animation, each with a different start time.
 */
export class ModelAnimation {
    constructor();
    /**
     * When <code>true</code>, the animation is removed after it stops playing.
     * This is slightly more efficient that not removing it, but if, for example,
     * time is reversed, the animation is not played again.
     */
    removeOnStop: boolean;
    /**
     * The event fired when this animation is started.  This can be used, for
     * example, to play a sound or start a particle system, when the animation starts.
     * <p>
     * This event is fired at the end of the frame after the scene is rendered.
     * </p>
     * @example
     * animation.start.addEventListener(function(model, animation) {
     *   console.log(`Animation started: ${animation.name}`);
     * });
     */
    start: Event;
    /**
     * The event fired when on each frame when this animation is updated.  The
     * current time of the animation, relative to the glTF animation time span, is
     * passed to the event, which allows, for example, starting new animations at a
     * specific time relative to a playing animation.
     * <p>
     * This event is fired at the end of the frame after the scene is rendered.
     * </p>
     * @example
     * animation.update.addEventListener(function(model, animation, time) {
     *   console.log(`Animation updated: ${animation.name}. glTF animation time: ${time}`);
     * });
     */
    update: Event;
    /**
     * The event fired when this animation is stopped.  This can be used, for
     * example, to play a sound or start a particle system, when the animation stops.
     * <p>
     * This event is fired at the end of the frame after the scene is rendered.
     * </p>
     * @example
     * animation.stop.addEventListener(function(model, animation) {
     *   console.log(`Animation stopped: ${animation.name}`);
     * });
     */
    stop: Event;
    /**
     * The name that identifies this animation in the model, if it exists.
     */
    readonly name: string;
    /**
     * The scene time to start playing this animation. When this is <code>undefined</code>,
     * the animation starts at the next frame.
     */
    readonly startTime: JulianDate;
    /**
     * The delay, in seconds, from {@link ModelAnimation#startTime} to start playing.
     */
    readonly delay: number;
    /**
     * The scene time to stop playing this animation. When this is <code>undefined</code>,
     * the animation is played for its full duration and perhaps repeated depending on
     * {@link ModelAnimation#loop}.
     */
    readonly stopTime: JulianDate;
    /**
     * Values greater than <code>1.0</code> increase the speed that the animation is played relative
     * to the scene clock speed; values less than <code>1.0</code> decrease the speed.  A value of
     * <code>1.0</code> plays the animation at the speed in the glTF animation mapped to the scene
     * clock speed.  For example, if the scene is played at 2x real-time, a two-second glTF animation
     * will play in one second even if <code>multiplier</code> is <code>1.0</code>.
     */
    readonly multiplier: number;
    /**
     * When <code>true</code>, the animation is played in reverse.
     */
    readonly reverse: boolean;
    /**
     * Determines if and how the animation is looped.
     */
    readonly loop: ModelAnimationLoop;
    /**
     * If this is defined, it will be used to compute the local animation time
     * instead of the scene's time.
     */
    animationTime: ModelAnimation.AnimationTimeCallback;
}

export namespace ModelAnimation {
    /**
     * A function used to compute the local animation time for a ModelAnimation.
     * @example
     * // Use real time for model animation (assuming animateWhilePaused was set to true)
     * function animationTime(duration) {
     *     return Date.now() / 1000 / duration;
     * }
     * @example
     * // Offset the phase of the animation, so it starts halfway through its cycle.
     * function animationTime(duration, seconds) {
     *     return seconds / duration + 0.5;
     * }
     * @param duration - The animation's original duration in seconds.
     * @param seconds - The seconds since the animation started, in scene time.
     */
    type AnimationTimeCallback = (duration: number, seconds: number) => number;
}

/**
 * <div class="notice">
 * Access a model's animations {@link Model#activeAnimations}. Do not call the constructor directly
 * </div>
 *
 * A collection of active model animations.
 */
export class ModelAnimationCollection {
    constructor();
    /**
     * The event fired when an animation is added to the collection.  This can be used, for
     * example, to keep a UI in sync.
     * @example
     * model.activeAnimations.animationAdded.addEventListener(function(model, animation) {
     *   console.log(`Animation added: ${animation.name}`);
     * });
     */
    animationAdded: Event;
    /**
     * The event fired when an animation is removed from the collection.  This can be used, for
     * example, to keep a UI in sync.
     * @example
     * model.activeAnimations.animationRemoved.addEventListener(function(model, animation) {
     *   console.log(`Animation removed: ${animation.name}`);
     * });
     */
    animationRemoved: Event;
    /**
     * When true, the animation will play even when the scene time is paused. However,
     * whether animation takes place will depend on the animationTime functions assigned
     * to the model's animations. By default, this is based on scene time, so models using
     * the default will not animate regardless of this setting.
     */
    animateWhilePaused: boolean;
    /**
     * The number of animations in the collection.
     */
    readonly length: number;
    /**
     * The model that owns this animation collection.
     */
    readonly model: Model;
    /**
     * Creates and adds an animation with the specified initial properties to the collection.
     * <p>
     * This raises the {@link ModelAnimationCollection#animationAdded} event so, for example, a UI can stay in sync.
     * </p>
     * @example
     * // Example 1. Add an animation by name
     * model.activeAnimations.add({
     *   name : 'animation name'
     * });
     * @example
     * // Example 2. Add an animation by index
     * model.activeAnimations.add({
     *   index : 0
     * });
     * @example
     * // Example 3. Add an animation and provide all properties and events
     * const startTime = Cesium.JulianDate.now();
     *
     * const animation = model.activeAnimations.add({
     *   name : 'another animation name',
     *   startTime : startTime,
     *   delay : 0.0,                                 // Play at startTime (default)
     *   stopTime : Cesium.JulianDate.addSeconds(startTime, 4.0, new Cesium.JulianDate()),
     *   removeOnStop : false,                        // Do not remove when animation stops (default)
     *   multiplier : 2.0,                            // Play at double speed
     *   reverse : true,                              // Play in reverse
     *   loop : Cesium.ModelAnimationLoop.REPEAT      // Loop the animation
     * });
     *
     * animation.start.addEventListener(function(model, animation) {
     *   console.log(`Animation started: ${animation.name}`);
     * });
     * animation.update.addEventListener(function(model, animation, time) {
     *   console.log(`Animation updated: ${animation.name}. glTF animation time: ${time}`);
     * });
     * animation.stop.addEventListener(function(model, animation) {
     *   console.log(`Animation stopped: ${animation.name}`);
     * });
     * @param options - Object with the following properties:
     * @param [options.name] - The glTF animation name that identifies the animation. Must be defined if <code>options.index</code> is <code>undefined</code>.
     * @param [options.index] - The glTF animation index that identifies the animation. Must be defined if <code>options.name</code> is <code>undefined</code>.
     * @param [options.startTime] - The scene time to start playing the animation.  When this is <code>undefined</code>, the animation starts at the next frame.
     * @param [options.delay = 0.0] - The delay, in seconds, from <code>startTime</code> to start playing. This will only affect the animation if <code>options.loop</code> is ModelAnimationLoop.NONE.
     * @param [options.stopTime] - The scene time to stop playing the animation.  When this is <code>undefined</code>, the animation is played for its full duration.
     * @param [options.removeOnStop = false] - When <code>true</code>, the animation is removed after it stops playing. This will only affect the animation if <code>options.loop</code> is ModelAnimationLoop.NONE.
     * @param [options.multiplier = 1.0] - Values greater than <code>1.0</code> increase the speed that the animation is played relative to the scene clock speed; values less than <code>1.0</code> decrease the speed.
     * @param [options.reverse = false] - When <code>true</code>, the animation is played in reverse.
     * @param [options.loop = ModelAnimationLoop.NONE] - Determines if and how the animation is looped.
     * @param [options.animationTime] - If defined, computes the local animation time for this animation.
     * @returns The animation that was added to the collection.
     */
    add(options: {
        name?: string;
        index?: number;
        startTime?: JulianDate;
        delay?: number;
        stopTime?: JulianDate;
        removeOnStop?: boolean;
        multiplier?: number;
        reverse?: boolean;
        loop?: ModelAnimationLoop;
        animationTime?: ModelAnimation.AnimationTimeCallback;
    }): ModelAnimation;
    /**
     * Creates and adds animations with the specified initial properties to the collection
     * for all animations in the model.
     * <p>
     * This raises the {@link ModelAnimationCollection#animationAdded} event for each model so, for example, a UI can stay in sync.
     * </p>
     * @example
     * model.activeAnimations.addAll({
     *   multiplier : 0.5,                            // Play at half-speed
     *   loop : Cesium.ModelAnimationLoop.REPEAT      // Loop the animations
     * });
     * @param [options] - Object with the following properties:
     * @param [options.startTime] - The scene time to start playing the animations. When this is <code>undefined</code>, the animations starts at the next frame.
     * @param [options.delay = 0.0] - The delay, in seconds, from <code>startTime</code> to start playing. This will only affect the animation if <code>options.loop</code> is ModelAnimationLoop.NONE.
     * @param [options.stopTime] - The scene time to stop playing the animations. When this is <code>undefined</code>, the animations are played for its full duration.
     * @param [options.removeOnStop = false] - When <code>true</code>, the animations are removed after they stop playing. This will only affect the animation if <code>options.loop</code> is ModelAnimationLoop.NONE.
     * @param [options.multiplier = 1.0] - Values greater than <code>1.0</code> increase the speed that the animations play relative to the scene clock speed; values less than <code>1.0</code> decrease the speed.
     * @param [options.reverse = false] - When <code>true</code>, the animations are played in reverse.
     * @param [options.loop = ModelAnimationLoop.NONE] - Determines if and how the animations are looped.
     * @param [options.animationTime] - If defined, computes the local animation time for all of the animations.
     * @returns An array of {@link ModelAnimation} objects, one for each animation added to the collection.  If there are no glTF animations, the array is empty.
     */
    addAll(options?: {
        startTime?: JulianDate;
        delay?: number;
        stopTime?: JulianDate;
        removeOnStop?: boolean;
        multiplier?: number;
        reverse?: boolean;
        loop?: ModelAnimationLoop;
        animationTime?: ModelAnimation.AnimationTimeCallback;
    }): ModelAnimation[];
    /**
     * Removes an animation from the collection.
     * <p>
     * This raises the {@link ModelAnimationCollection#animationRemoved} event so, for example, a UI can stay in sync.
     * </p>
     * <p>
     * An animation can also be implicitly removed from the collection by setting {@link ModelAnimationCollection#removeOnStop} to
     * <code>true</code>.  The {@link ModelAnimationCollection#animationRemoved} event is still fired when the animation is removed.
     * </p>
     * @example
     * const a = model.activeAnimations.add({
     *   name : 'animation name'
     * });
     * model.activeAnimations.remove(a); // Returns true
     * @param runtimeAnimation - The runtime animation to remove.
     * @returns <code>true</code> if the animation was removed; <code>false</code> if the animation was not found in the collection.
     */
    remove(runtimeAnimation: ModelAnimation): boolean;
    /**
     * Removes all animations from the collection.
     * <p>
     * This raises the {@link ModelAnimationCollection#animationRemoved} event for each
     * animation so, for example, a UI can stay in sync.
     * </p>
     */
    removeAll(): void;
    /**
     * Determines whether this collection contains a given animation.
     * @param runtimeAnimation - The runtime animation to check for.
     * @returns <code>true</code> if this collection contains the animation, <code>false</code> otherwise.
     */
    contains(runtimeAnimation: ModelAnimation): boolean;
    /**
     * Returns the animation in the collection at the specified index.  Indices are zero-based
     * and increase as animations are added.  Removing an animation shifts all animations after
     * it to the left, changing their indices.  This function is commonly used to iterate over
     * all the animations in the collection.
     * @example
     * // Output the names of all the animations in the collection.
     * const animations = model.activeAnimations;
     * const length = animations.length;
     * for (let i = 0; i < length; ++i) {
     *   console.log(animations.get(i).name);
     * }
     * @param index - The zero-based index of the animation.
     * @returns The runtime animation at the specified index.
     */
    get(index: number): ModelAnimation;
}

/**
 * A feature of a {@link Model}.
 * <p>
 * Provides access to a feature's properties stored in the model's feature table.
 * </p>
 * <p>
 * Modifications to a <code>ModelFeature</code> object have the lifetime of the model.
 * </p>
 * <p>
 * Do not construct this directly. Access it through picking using {@link Scene#pick}.
 * </p>
 * @example
 * // On mouse over, display all the properties for a feature in the console log.
 * handler.setInputAction(function(movement) {
 *     const feature = scene.pick(movement.endPosition);
 *     if (feature instanceof Cesium.ModelFeature) {
 *         console.log(feature);
 *     }
 * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
 * @param options - Object with the following properties:
 * @param options.model - The model the feature belongs to.
 * @param options.featureId - The unique integral identifier for this feature.
 */
export class ModelFeature {
    constructor(options: {
        model: Model;
        featureId: number;
    });
    /**
     * Gets or sets if the feature will be shown. This is set for all features
     * when a style's show is evaluated.
     */
    show: boolean;
    /**
     * Gets or sets the highlight color multiplied with the feature's color.  When
     * this is white, the feature's color is not changed. This is set for all features
     * when a style's color is evaluated.
     */
    color: Color;
    /**
     * Get the feature ID associated with this feature. For 3D Tiles 1.0, the
     * batch ID is returned. For EXT_mesh_features, this is the feature ID from
     * the selected feature ID set.
     */
    readonly featureId: number;
    /**
     * Returns whether the feature contains this property.
     * @param name - The case-sensitive name of the property.
     * @returns Whether the feature contains this property.
     */
    hasProperty(name: string): boolean;
    /**
     * Returns a copy of the value of the feature's property with the given name.
     * @example
     * // Display all the properties for a feature in the console log.
     * const propertyIds = feature.getPropertyIds();
     * const length = propertyIds.length;
     * for (let i = 0; i < length; ++i) {
     *     const propertyId = propertyIds[i];
     *     console.log(propertyId + ': ' + feature.getProperty(propertyId));
     * }
     * @param name - The case-sensitive name of the property.
     * @returns The value of the property or <code>undefined</code> if the feature does not have this property.
     */
    getProperty(name: string): any;
    /**
     * Returns a copy of the feature's property with the given name, examining all
     * the metadata from the EXT_structural_metadata and legacy EXT_feature_metadata glTF
     * extensions. Metadata is checked against name from most specific to most
     * general and the first match is returned. Metadata is checked in this order:
     * <ol>
     *   <li>structural metadata property by semantic</li>
     *   <li>structural metadata property by property ID</li>
     * </ol>
     * <p>
     * See the {@link https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_structural_metadata|EXT_structural_metadata Extension} as well as the
     * previous {@link https://github.com/CesiumGS/glTF/tree/3d-tiles-next/extensions/2.0/Vendor/EXT_feature_metadata|EXT_feature_metadata Extension} for glTF.
     * </p>
     * @param name - The semantic or property ID of the feature. Semantics are checked before property IDs in each granularity of metadata.
     * @returns The value of the property or <code>undefined</code> if the feature does not have this property.
     */
    getPropertyInherited(name: string): any;
    /**
     * Returns an array of property IDs for the feature.
     * @param [results] - An array into which to store the results.
     * @returns The IDs of the feature's properties.
     */
    getPropertyIds(results?: string[]): string[];
    /**
     * Sets the value of the feature's property with the given name.
     * @example
     * const height = feature.getProperty('Height'); // e.g., the height of a building
     * @example
     * const name = 'clicked';
     * if (feature.getProperty(name)) {
     *     console.log('already clicked');
     * } else {
     *     feature.setProperty(name, true);
     *     console.log('first click');
     * }
     * @param name - The case-sensitive name of the property.
     * @param value - The value of the property that will be copied.
     * @returns <code>true</code> if the property was set, <code>false</code> otherwise.
     */
    setProperty(name: string, value: any): boolean;
}

/**
 * <div class="notice">
 * Use {@link Model#getNode} to get a node from a loaded model. Do not call the constructor directly.
 * </div>
 *
 * A model node with a modifiable transform to allow users to define their
 * own animations. While a model's asset can contain animations that target
 * a node's transform, this class allows users to change a node's transform
 * externally. In this way, animation can be driven by another source, not
 * just by the model's asset.
 * @example
 * const node = model.getNode("Hand");
 * node.matrix = Cesium.Matrix4.fromScale(new Cesium.Cartesian3(5.0, 1.0, 1.0), node.matrix);
 */
export class ModelNode {
    constructor();
    /**
     * The value of the <code>name</code> property of this node.
     */
    readonly name: string;
    /**
     * The index of the node in the glTF.
     */
    readonly id: number;
    /**
     * Determines if this node and its children will be shown.
     */
    show: boolean;
    /**
     * The node's 4x4 matrix transform from its local coordinates to
     * its parent's. Setting the matrix to undefined will restore the
     * node's original transform, and allow the node to be animated by
     * any animations in the model again.
     * <p>
     * For changes to take effect, this property must be assigned to;
     * setting individual elements of the matrix will not work.
     * </p>
     */
    matrix: Matrix4;
    /**
     * Gets the node's original 4x4 matrix transform from its local
     * coordinates to its parent's, without any node transformations
     * or articulations applied.
     */
    originalMatrix: Matrix4;
}

/**
 * A simple struct that serves as a value of a <code>sampler2D</code>-valued
 * uniform. This is used with {@link CustomShader} and {@link TextureManager}
 * @param options - An object with the following properties:
 * @param [options.typedArray] - A typed array storing the contents of a texture. Values are stored in row-major order. Since WebGL uses a y-up convention for textures, rows are listed from bottom to top.
 * @param [options.width] - The width of the image. Required when options.typedArray is present
 * @param [options.height] - The height of the image. Required when options.typedArray is present.
 * @param [options.url] - A URL string or resource pointing to a texture image.
 * @param [options.repeat = true] - When defined, the texture sampler will be set to wrap in both directions
 * @param [options.pixelFormat = PixelFormat.RGBA] - When options.typedArray is defined, this is used to determine the pixel format of the texture
 * @param [options.pixelDatatype = PixelDatatype.UNSIGNED_BYTE] - When options.typedArray is defined, this is the data type of pixel values in the typed array.
 * @param [options.minificationFilter = TextureMinificationFilter.LINEAR] - The minification filter of the texture sampler.
 * @param [options.magnificationFilter = TextureMagnificationFilter.LINEAR] - The magnification filter of the texture sampler.
 * @param [options.maximumAnisotropy = 1.0] - The maximum anisotropy of the texture sampler
 */
export class TextureUniform {
    constructor(options: {
        typedArray?: Uint8Array;
        width?: number;
        height?: number;
        url?: string | Resource;
        repeat?: boolean;
        pixelFormat?: PixelFormat;
        pixelDatatype?: PixelDatatype;
        minificationFilter?: TextureMinificationFilter;
        magnificationFilter?: TextureMagnificationFilter;
        maximumAnisotropy?: number;
    });
}

/**
 * An enum of the basic GLSL uniform types. These can be used with
 * {@link CustomShader} to declare user-defined uniforms.
 */
export enum UniformType {
    /**
     * A single floating point value.
     */
    FLOAT = "float",
    /**
     * A vector of 2 floating point values.
     */
    VEC2 = "vec2",
    /**
     * A vector of 3 floating point values.
     */
    VEC3 = "vec3",
    /**
     * A vector of 4 floating point values.
     */
    VEC4 = "vec4",
    /**
     * A single integer value
     */
    INT = "int",
    /**
     * A vector of 2 integer values.
     */
    INT_VEC2 = "ivec2",
    /**
     * A vector of 3 integer values.
     */
    INT_VEC3 = "ivec3",
    /**
     * A vector of 4 integer values.
     */
    INT_VEC4 = "ivec4",
    /**
     * A single boolean value.
     */
    BOOL = "bool",
    /**
     * A vector of 2 boolean values.
     */
    BOOL_VEC2 = "bvec2",
    /**
     * A vector of 3 boolean values.
     */
    BOOL_VEC3 = "bvec3",
    /**
     * A vector of 4 boolean values.
     */
    BOOL_VEC4 = "bvec4",
    /**
     * A 2x2 matrix of floating point values.
     */
    MAT2 = "mat2",
    /**
     * A 3x3 matrix of floating point values.
     */
    MAT3 = "mat3",
    /**
     * A 3x3 matrix of floating point values.
     */
    MAT4 = "mat4",
    /**
     * A 2D sampled texture.
     */
    SAMPLER_2D = "sampler2D",
    SAMPLER_CUBE = "samplerCube"
}

/**
 * An enum for the GLSL varying types. These can be used for declaring varyings
 * in {@link CustomShader}
 */
export enum VaryingType {
    /**
     * A single floating point value.
     */
    FLOAT = "float",
    /**
     * A vector of 2 floating point values.
     */
    VEC2 = "vec2",
    /**
     * A vector of 3 floating point values.
     */
    VEC3 = "vec3",
    /**
     * A vector of 4 floating point values.
     */
    VEC4 = "vec4",
    /**
     * A 2x2 matrix of floating point values.
     */
    MAT2 = "mat2",
    /**
     * A 3x3 matrix of floating point values.
     */
    MAT3 = "mat2",
    /**
     * A 3x3 matrix of floating point values.
     */
    MAT4 = "mat4"
}

/**
 * Determines if and how a glTF animation is looped.
 */
export enum ModelAnimationLoop {
    /**
     * Play the animation once; do not loop it.
     */
    NONE = 0,
    /**
     * Loop the animation playing it from the start immediately after it stops.
     */
    REPEAT = 1,
    /**
     * Loop the animation.  First, playing it forward, then in reverse, then forward, and so on.
     */
    MIRRORED_REPEAT = 2
}

/**
 * Draws the Moon in 3D.
 * @example
 * scene.moon = new Cesium.Moon();
 * @param [options] - Object with the following properties:
 * @param [options.show = true] - Determines whether the moon will be rendered.
 * @param [options.textureUrl = buildModuleUrl('Assets/Textures/moonSmall.jpg')] - The moon texture.
 * @param [options.ellipsoid = Ellipsoid.MOON] - The moon ellipsoid.
 * @param [options.onlySunLighting = true] - Use the sun as the only light source.
 */
export class Moon {
    constructor(options?: {
        show?: boolean;
        textureUrl?: string;
        ellipsoid?: Ellipsoid;
        onlySunLighting?: boolean;
    });
    /**
     * Determines if the moon will be shown.
     */
    show: boolean;
    /**
     * The moon texture.
     */
    textureUrl: string;
    /**
     * Use the sun as the only light source.
     */
    onlySunLighting: boolean;
    /**
     * Get the ellipsoid that defines the shape of the moon.
     */
    readonly ellipsoid: Ellipsoid;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     * @example
     * moon = moon && moon.destroy();
     */
    destroy(): void;
}

/**
 * A {@link TileDiscardPolicy} specifying that tile images should never be discard.
 */
export class NeverTileDiscardPolicy {
    constructor();
    /**
     * Determines if the discard policy is ready to process images.
     * @returns True if the discard policy is ready to process images; otherwise, false.
     */
    isReady(): boolean;
    /**
     * Given a tile image, decide whether to discard that image.
     * @param image - An image to test.
     * @returns True if the image should be discarded; otherwise, false.
     */
    shouldDiscardImage(image: HTMLImageElement): boolean;
}

export namespace OpenStreetMapImageryProvider {
    /**
     * Initialization options for the OpenStreetMapImageryProvider constructor
     * [url = 'https://tile.openstreetmap.org'] - The OpenStreetMap server url.
     * [fileExtension = 'png'] - The file extension for images on the server.
     * [retinaTiles = false] - When true, request tiles at the 2x resolution for retina displays.
     * [rectangle = Rectangle.MAX_VALUE] - The rectangle of the layer.
     * [minimumLevel = 0] - The minimum level-of-detail supported by the imagery provider.
     * [maximumLevel] - The maximum level-of-detail supported by the imagery provider, or undefined if there is no limit.
     * [ellipsoid] - The ellipsoid.  If not specified, the WGS84 ellipsoid is used.
     * [credit = 'MapQuest, Open Street Map and contributors, CC-BY-SA'] - A credit for the data source, which is displayed on the canvas.
     */
    type ConstructorOptions = {
        url?: string;
        fileExtension?: string;
        retinaTiles?: boolean;
        rectangle?: Rectangle;
        minimumLevel?: number;
        maximumLevel?: number;
        ellipsoid?: Ellipsoid;
        credit?: Credit | string;
    };
}

/**
 * An imagery provider that provides tiled imagery hosted by OpenStreetMap
 * or another provider of Slippy tiles.  The default url connects to OpenStreetMap's volunteer-run
 * servers, so you must conform to their
 * {@link http://wiki.openstreetmap.org/wiki/Tile_usage_policy|Tile Usage Policy}.
 * @example
 * const osm = new Cesium.OpenStreetMapImageryProvider({
 *     url : 'https://tile.openstreetmap.org/'
 * });
 * @param options - Object describing initialization options
 */
export class OpenStreetMapImageryProvider extends UrlTemplateImageryProvider {
    constructor(options: OpenStreetMapImageryProvider.ConstructorOptions);
}

/**
 * A particle emitted by a {@link ParticleSystem}.
 * @param options - An object with the following properties:
 * @param [options.mass = 1.0] - The mass of the particle in kilograms.
 * @param [options.position = Cartesian3.ZERO] - The initial position of the particle in world coordinates.
 * @param [options.velocity = Cartesian3.ZERO] - The velocity vector of the particle in world coordinates.
 * @param [options.life = Number.MAX_VALUE] - The life of the particle in seconds.
 * @param [options.image] - The URI, HTMLImageElement, or HTMLCanvasElement to use for the billboard.
 * @param [options.startColor = Color.WHITE] - The color of a particle when it is born.
 * @param [options.endColor = Color.WHITE] - The color of a particle when it dies.
 * @param [options.startScale = 1.0] - The scale of the particle when it is born.
 * @param [options.endScale = 1.0] - The scale of the particle when it dies.
 * @param [options.imageSize = new Cartesian2(1.0, 1.0)] - The dimensions, width by height, to scale the particle image in pixels.
 */
export class Particle {
    constructor(options: {
        mass?: number;
        position?: Cartesian3;
        velocity?: Cartesian3;
        life?: number;
        image?: any;
        startColor?: Color;
        endColor?: Color;
        startScale?: number;
        endScale?: number;
        imageSize?: Cartesian2;
    });
    /**
     * The mass of the particle in kilograms.
     */
    mass: number;
    /**
     * The positon of the particle in world coordinates.
     */
    position: Cartesian3;
    /**
     * The velocity of the particle in world coordinates.
     */
    velocity: Cartesian3;
    /**
     * The life of the particle in seconds.
     */
    life: number;
    /**
     * The image to use for the particle.
     */
    image: any;
    /**
     * The color of the particle when it is born.
     */
    startColor: Color;
    /**
     * The color of the particle when it dies.
     */
    endColor: Color;
    /**
     * the scale of the particle when it is born.
     */
    startScale: number;
    /**
     * The scale of the particle when it dies.
     */
    endScale: number;
    /**
     * The dimensions, width by height, to scale the particle image in pixels.
     */
    imageSize: Cartesian2;
    /**
     * Gets the age of the particle in seconds.
     */
    age: number;
    /**
     * Gets the age normalized to a value in the range [0.0, 1.0].
     */
    normalizedAge: number;
}

/**
 * Represents a burst of {@link Particle}s from a {@link ParticleSystem} at a given time in the systems lifetime.
 * @param [options] - An object with the following properties:
 * @param [options.time = 0.0] - The time in seconds after the beginning of the particle system's lifetime that the burst will occur.
 * @param [options.minimum = 0.0] - The minimum number of particles emmitted in the burst.
 * @param [options.maximum = 50.0] - The maximum number of particles emitted in the burst.
 */
export class ParticleBurst {
    constructor(options?: {
        time?: number;
        minimum?: number;
        maximum?: number;
    });
    /**
     * The time in seconds after the beginning of the particle system's lifetime that the burst will occur.
     */
    time: number;
    /**
     * The minimum number of particles emitted.
     */
    minimum: number;
    /**
     * The maximum number of particles emitted.
     */
    maximum: number;
    /**
     * <code>true</code> if the burst has been completed; <code>false</code> otherwise.
     */
    complete: boolean;
}

/**
 * <p>
 * An object that initializes a {@link Particle} from a {@link ParticleSystem}.
 * </p>
 * <p>
 * This type describes an interface and is not intended to be instantiated directly.
 * </p>
 */
export class ParticleEmitter {
    constructor();
}

/**
 * A ParticleSystem manages the updating and display of a collection of particles.
 * @param [options] - Object with the following properties:
 * @param [options.show = true] - Whether to display the particle system.
 * @param [options.updateCallback] - The callback function to be called each frame to update a particle.
 * @param [options.emitter = new CircleEmitter(0.5)] - The particle emitter for this system.
 * @param [options.modelMatrix = Matrix4.IDENTITY] - The 4x4 transformation matrix that transforms the particle system from model to world coordinates.
 * @param [options.emitterModelMatrix = Matrix4.IDENTITY] - The 4x4 transformation matrix that transforms the particle system emitter within the particle systems local coordinate system.
 * @param [options.emissionRate = 5] - The number of particles to emit per second.
 * @param [options.bursts] - An array of {@link ParticleBurst}, emitting bursts of particles at periodic times.
 * @param [options.loop = true] - Whether the particle system should loop its bursts when it is complete.
 * @param [options.scale = 1.0] - Sets the scale to apply to the image of the particle for the duration of its particleLife.
 * @param [options.startScale] - The initial scale to apply to the image of the particle at the beginning of its life.
 * @param [options.endScale] - The final scale to apply to the image of the particle at the end of its life.
 * @param [options.color = Color.WHITE] - Sets the color of a particle for the duration of its particleLife.
 * @param [options.startColor] - The color of the particle at the beginning of its life.
 * @param [options.endColor] - The color of the particle at the end of its life.
 * @param [options.image] - The URI, HTMLImageElement, or HTMLCanvasElement to use for the billboard.
 * @param [options.imageSize = new Cartesian2(1.0, 1.0)] - If set, overrides the minimumImageSize and maximumImageSize inputs that scale the particle image's dimensions in pixels.
 * @param [options.minimumImageSize] - Sets the minimum bound, width by height, above which to randomly scale the particle image's dimensions in pixels.
 * @param [options.maximumImageSize] - Sets the maximum bound, width by height, below which to randomly scale the particle image's dimensions in pixels.
 * @param [options.sizeInMeters] - Sets if the size of particles is in meters or pixels. <code>true</code> to size the particles in meters; otherwise, the size is in pixels.
 * @param [options.speed = 1.0] - If set, overrides the minimumSpeed and maximumSpeed inputs with this value.
 * @param [options.minimumSpeed] - Sets the minimum bound in meters per second above which a particle's actual speed will be randomly chosen.
 * @param [options.maximumSpeed] - Sets the maximum bound in meters per second below which a particle's actual speed will be randomly chosen.
 * @param [options.lifetime = Number.MAX_VALUE] - How long the particle system will emit particles, in seconds.
 * @param [options.particleLife = 5.0] - If set, overrides the minimumParticleLife and maximumParticleLife inputs with this value.
 * @param [options.minimumParticleLife] - Sets the minimum bound in seconds for the possible duration of a particle's life above which a particle's actual life will be randomly chosen.
 * @param [options.maximumParticleLife] - Sets the maximum bound in seconds for the possible duration of a particle's life below which a particle's actual life will be randomly chosen.
 * @param [options.mass = 1.0] - Sets the minimum and maximum mass of particles in kilograms.
 * @param [options.minimumMass] - Sets the minimum bound for the mass of a particle in kilograms. A particle's actual mass will be chosen as a random amount above this value.
 * @param [options.maximumMass] - Sets the maximum mass of particles in kilograms. A particle's actual mass will be chosen as a random amount below this value.
 */
export class ParticleSystem {
    constructor(options?: {
        show?: boolean;
        updateCallback?: ParticleSystem.updateCallback;
        emitter?: ParticleEmitter;
        modelMatrix?: Matrix4;
        emitterModelMatrix?: Matrix4;
        emissionRate?: number;
        bursts?: ParticleBurst[];
        loop?: boolean;
        scale?: number;
        startScale?: number;
        endScale?: number;
        color?: Color;
        startColor?: Color;
        endColor?: Color;
        image?: any;
        imageSize?: Cartesian2;
        minimumImageSize?: Cartesian2;
        maximumImageSize?: Cartesian2;
        sizeInMeters?: boolean;
        speed?: number;
        minimumSpeed?: number;
        maximumSpeed?: number;
        lifetime?: number;
        particleLife?: number;
        minimumParticleLife?: number;
        maximumParticleLife?: number;
        mass?: number;
        minimumMass?: number;
        maximumMass?: number;
    });
    /**
     * Whether to display the particle system.
     */
    show: boolean;
    /**
     * An array of force callbacks. The callback is passed a {@link Particle} and the difference from the last time
     */
    updateCallback: ParticleSystem.updateCallback;
    /**
     * Whether the particle system should loop it's bursts when it is complete.
     */
    loop: boolean;
    /**
     * The URI, HTMLImageElement, or HTMLCanvasElement to use for the billboard.
     */
    image: any;
    /**
     * The particle emitter for this
     */
    emitter: ParticleEmitter;
    /**
     * An array of {@link ParticleBurst}, emitting bursts of particles at periodic times.
     */
    bursts: ParticleBurst[];
    /**
     * The 4x4 transformation matrix that transforms the particle system from model to world coordinates.
     */
    modelMatrix: Matrix4;
    /**
     * The 4x4 transformation matrix that transforms the particle system emitter within the particle systems local coordinate system.
     */
    emitterModelMatrix: Matrix4;
    /**
     * The color of the particle at the beginning of its life.
     */
    startColor: Color;
    /**
     * The color of the particle at the end of its life.
     */
    endColor: Color;
    /**
     * The initial scale to apply to the image of the particle at the beginning of its life.
     */
    startScale: number;
    /**
     * The final scale to apply to the image of the particle at the end of its life.
     */
    endScale: number;
    /**
     * The number of particles to emit per second.
     */
    emissionRate: number;
    /**
     * Sets the minimum bound in meters per second above which a particle's actual speed will be randomly chosen.
     */
    minimumSpeed: number;
    /**
     * Sets the maximum bound in meters per second below which a particle's actual speed will be randomly chosen.
     */
    maximumSpeed: number;
    /**
     * Sets the minimum bound in seconds for the possible duration of a particle's life above which a particle's actual life will be randomly chosen.
     */
    minimumParticleLife: number;
    /**
     * Sets the maximum bound in seconds for the possible duration of a particle's life below which a particle's actual life will be randomly chosen.
     */
    maximumParticleLife: number;
    /**
     * Sets the minimum mass of particles in kilograms.
     */
    minimumMass: number;
    /**
     * Sets the maximum mass of particles in kilograms.
     */
    maximumMass: number;
    /**
     * Sets the minimum bound, width by height, above which to randomly scale the particle image's dimensions in pixels.
     */
    minimumImageSize: Cartesian2;
    /**
     * Sets the maximum bound, width by height, below which to randomly scale the particle image's dimensions in pixels.
     */
    maximumImageSize: Cartesian2;
    /**
     * Gets or sets if the particle size is in meters or pixels. <code>true</code> to size particles in meters; otherwise, the size is in pixels.
     */
    sizeInMeters: boolean;
    /**
     * How long the particle system will emit particles, in seconds.
     */
    lifetime: number;
    /**
     * Fires an event when the particle system has reached the end of its lifetime.
     */
    complete: Event;
    /**
     * When <code>true</code>, the particle system has reached the end of its lifetime; <code>false</code> otherwise.
     */
    isComplete: boolean;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     */
    destroy(): void;
}

export namespace ParticleSystem {
    /**
     * A function used to modify attributes of the particle at each time step. This can include force modifications,
     * color, sizing, etc.
     * @example
     * function applyGravity(particle, dt) {
     *    const position = particle.position;
     *    const gravityVector = Cesium.Cartesian3.normalize(position, new Cesium.Cartesian3());
     *    Cesium.Cartesian3.multiplyByScalar(gravityVector, GRAVITATIONAL_CONSTANT * dt, gravityVector);
     *    particle.velocity = Cesium.Cartesian3.add(particle.velocity, gravityVector, particle.velocity);
     * }
     * @param particle - The particle being updated.
     * @param dt - The time in seconds since the last update.
     */
    type updateCallback = (particle: Particle, dt: number) => void;
}

/**
 * An appearance for {@link GeometryInstance} instances with color attributes.
 * This allows several geometry instances, each with a different color, to
 * be drawn with the same {@link Primitive} as shown in the second example below.
 * @example
 * // A solid white line segment
 * const primitive = new Cesium.Primitive({
 *   geometryInstances : new Cesium.GeometryInstance({
 *     geometry : new Cesium.SimplePolylineGeometry({
 *       positions : Cesium.Cartesian3.fromDegreesArray([
 *         0.0, 0.0,
 *         5.0, 0.0
 *       ])
 *     }),
 *     attributes : {
 *       color : Cesium.ColorGeometryInstanceAttribute.fromColor(new Cesium.Color(1.0, 1.0, 1.0, 1.0))
 *     }
 *   }),
 *   appearance : new Cesium.PerInstanceColorAppearance({
 *     flat : true,
 *     translucent : false
 *   })
 * });
 *
 * // Two rectangles in a primitive, each with a different color
 * const instance = new Cesium.GeometryInstance({
 *   geometry : new Cesium.RectangleGeometry({
 *     rectangle : Cesium.Rectangle.fromDegrees(0.0, 20.0, 10.0, 30.0)
 *   }),
 *   attributes : {
 *     color : new Cesium.ColorGeometryInstanceAttribute(1.0, 0.0, 0.0, 0.5)
 *   }
 * });
 *
 * const anotherInstance = new Cesium.GeometryInstance({
 *   geometry : new Cesium.RectangleGeometry({
 *     rectangle : Cesium.Rectangle.fromDegrees(0.0, 40.0, 10.0, 50.0)
 *   }),
 *   attributes : {
 *     color : new Cesium.ColorGeometryInstanceAttribute(0.0, 0.0, 1.0, 0.5)
 *   }
 * });
 *
 * const rectanglePrimitive = new Cesium.Primitive({
 *   geometryInstances : [instance, anotherInstance],
 *   appearance : new Cesium.PerInstanceColorAppearance()
 * });
 * @param [options] - Object with the following properties:
 * @param [options.flat = false] - When <code>true</code>, flat shading is used in the fragment shader, which means lighting is not taking into account.
 * @param [options.faceForward = !options.closed] - When <code>true</code>, the fragment shader flips the surface normal as needed to ensure that the normal faces the viewer to avoid dark spots.  This is useful when both sides of a geometry should be shaded like {@link WallGeometry}.
 * @param [options.translucent = true] - When <code>true</code>, the geometry is expected to appear translucent so {@link PerInstanceColorAppearance#renderState} has alpha blending enabled.
 * @param [options.closed = false] - When <code>true</code>, the geometry is expected to be closed so {@link PerInstanceColorAppearance#renderState} has backface culling enabled.
 * @param [options.vertexShaderSource] - Optional GLSL vertex shader source to override the default vertex shader.
 * @param [options.fragmentShaderSource] - Optional GLSL fragment shader source to override the default fragment shader.
 * @param [options.renderState] - Optional render state to override the default render state.
 */
export class PerInstanceColorAppearance {
    constructor(options?: {
        flat?: boolean;
        faceForward?: boolean;
        translucent?: boolean;
        closed?: boolean;
        vertexShaderSource?: string;
        fragmentShaderSource?: string;
        renderState?: any;
    });
    /**
     * This property is part of the {@link Appearance} interface, but is not
     * used by {@link PerInstanceColorAppearance} since a fully custom fragment shader is used.
     */
    material: Material;
    /**
     * When <code>true</code>, the geometry is expected to appear translucent so
     * {@link PerInstanceColorAppearance#renderState} has alpha blending enabled.
     */
    translucent: boolean;
    /**
     * The GLSL source code for the vertex shader.
     */
    readonly vertexShaderSource: string;
    /**
     * The GLSL source code for the fragment shader.
     */
    readonly fragmentShaderSource: string;
    /**
     * The WebGL fixed-function state to use when rendering the geometry.
     * <p>
     * The render state can be explicitly defined when constructing a {@link PerInstanceColorAppearance}
     * instance, or it is set implicitly via {@link PerInstanceColorAppearance#translucent}
     * and {@link PerInstanceColorAppearance#closed}.
     * </p>
     */
    readonly renderState: any;
    /**
     * When <code>true</code>, the geometry is expected to be closed so
     * {@link PerInstanceColorAppearance#renderState} has backface culling enabled.
     * If the viewer enters the geometry, it will not be visible.
     */
    readonly closed: boolean;
    /**
     * The {@link VertexFormat} that this appearance instance is compatible with.
     * A geometry can have more vertex attributes and still be compatible - at a
     * potential performance cost - but it can't have less.
     */
    readonly vertexFormat: VertexFormat;
    /**
     * When <code>true</code>, flat shading is used in the fragment shader,
     * which means lighting is not taking into account.
     */
    readonly flat: boolean;
    /**
     * When <code>true</code>, the fragment shader flips the surface normal
     * as needed to ensure that the normal faces the viewer to avoid
     * dark spots.  This is useful when both sides of a geometry should be
     * shaded like {@link WallGeometry}.
     */
    readonly faceForward: boolean;
    /**
     * The {@link VertexFormat} that all {@link PerInstanceColorAppearance} instances
     * are compatible with.  This requires only <code>position</code> and <code>normal</code>
     * attributes.
     */
    static readonly VERTEX_FORMAT: VertexFormat;
    /**
     * The {@link VertexFormat} that all {@link PerInstanceColorAppearance} instances
     * are compatible with when {@link PerInstanceColorAppearance#flat} is <code>true</code>.
     * This requires only a <code>position</code> attribute.
     */
    static readonly FLAT_VERTEX_FORMAT: VertexFormat;
    /**
     * Procedurally creates the full GLSL fragment shader source.  For {@link PerInstanceColorAppearance},
     * this is derived from {@link PerInstanceColorAppearance#fragmentShaderSource}, {@link PerInstanceColorAppearance#flat},
     * and {@link PerInstanceColorAppearance#faceForward}.
     * @returns The full GLSL fragment shader source.
     */
    getFragmentShaderSource(): string;
    /**
     * Determines if the geometry is translucent based on {@link PerInstanceColorAppearance#translucent}.
     * @returns <code>true</code> if the appearance is translucent.
     */
    isTranslucent(): boolean;
    /**
     * Creates a render state.  This is not the final render state instance; instead,
     * it can contain a subset of render state properties identical to the render state
     * created in the context.
     * @returns The render state.
     */
    getRenderState(): any;
}

/**
 * Options for performing point attenuation based on geometric error when rendering
 * point clouds using 3D Tiles.
 * @param [options] - Object with the following properties:
 * @param [options.attenuation = false] - Perform point attenuation based on geometric error.
 * @param [options.geometricErrorScale = 1.0] - Scale to be applied to each tile's geometric error.
 * @param [options.maximumAttenuation] - Maximum attenuation in pixels. Defaults to the Cesium3DTileset's maximumScreenSpaceError.
 * @param [options.baseResolution] - Average base resolution for the dataset in meters. Substitute for Geometric Error when not available.
 * @param [options.eyeDomeLighting = true] - When true, use eye dome lighting when drawing with point attenuation.
 * @param [options.eyeDomeLightingStrength = 1.0] - Increasing this value increases contrast on slopes and edges.
 * @param [options.eyeDomeLightingRadius = 1.0] - Increase the thickness of contours from eye dome lighting.
 * @param [options.backFaceCulling = false] - Determines whether back-facing points are hidden. This option works only if data has normals included.
 * @param [options.normalShading = true] - Determines whether a point cloud that contains normals is shaded by the scene's light source.
 */
export class PointCloudShading {
    constructor(options?: {
        attenuation?: boolean;
        geometricErrorScale?: number;
        maximumAttenuation?: number;
        baseResolution?: number;
        eyeDomeLighting?: boolean;
        eyeDomeLightingStrength?: number;
        eyeDomeLightingRadius?: number;
        backFaceCulling?: boolean;
        normalShading?: boolean;
    });
    /**
     * Perform point attenuation based on geometric error.
     */
    attenuation: boolean;
    /**
     * Scale to be applied to the geometric error before computing attenuation.
     */
    geometricErrorScale: number;
    /**
     * Maximum point attenuation in pixels. If undefined, the Cesium3DTileset's maximumScreenSpaceError will be used.
     */
    maximumAttenuation: number;
    /**
     * Average base resolution for the dataset in meters.
     * Used in place of geometric error when geometric error is 0.
     * If undefined, an approximation will be computed for each tile that has geometric error of 0.
     */
    baseResolution: number;
    /**
     * Use eye dome lighting when drawing with point attenuation
     * Requires support for EXT_frag_depth, OES_texture_float, and WEBGL_draw_buffers extensions in WebGL 1.0,
     * otherwise eye dome lighting is ignored.
     */
    eyeDomeLighting: boolean;
    /**
     * Eye dome lighting strength (apparent contrast)
     */
    eyeDomeLightingStrength: number;
    /**
     * Thickness of contours from eye dome lighting
     */
    eyeDomeLightingRadius: number;
    /**
     * Determines whether back-facing points are hidden.
     * This option works only if data has normals included.
     */
    backFaceCulling: boolean;
    /**
     * Determines whether a point cloud that contains normals is shaded by the scene's light source.
     */
    normalShading: boolean;
    /**
     * Determines if point cloud shading is supported.
     * @param scene - The scene.
     * @returns <code>true</code> if point cloud shading is supported; otherwise, returns <code>false</code>
     */
    static isSupported(scene: Scene): boolean;
}

/**
 * <div class="notice">
 * A point is created and its initial properties are set by calling {@link PointPrimitiveCollection#add}. Do not call the constructor directly.
 * </div>
 * A graphical point positioned in the 3D scene, that is created
 * and rendered using a {@link PointPrimitiveCollection}.
 */
export class PointPrimitive {
    constructor();
    /**
     * Determines if this point will be shown.  Use this to hide or show a point, instead
     * of removing it and re-adding it to the collection.
     */
    show: boolean;
    /**
     * Gets or sets the Cartesian position of this point.
     */
    position: Cartesian3;
    /**
     * Gets or sets near and far scaling properties of a point based on the point's distance from the camera.
     * A point's scale will interpolate between the {@link NearFarScalar#nearValue} and
     * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
     * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
     * Outside of these ranges the point's scale remains clamped to the nearest bound.  This scale
     * multiplies the pixelSize and outlineWidth to affect the total size of the point.  If undefined,
     * scaleByDistance will be disabled.
     * @example
     * // Example 1.
     * // Set a pointPrimitive's scaleByDistance to scale to 15 when the
     * // camera is 1500 meters from the pointPrimitive and disappear as
     * // the camera distance approaches 8.0e6 meters.
     * p.scaleByDistance = new Cesium.NearFarScalar(1.5e2, 15, 8.0e6, 0.0);
     * @example
     * // Example 2.
     * // disable scaling by distance
     * p.scaleByDistance = undefined;
     */
    scaleByDistance: NearFarScalar;
    /**
     * Gets or sets near and far translucency properties of a point based on the point's distance from the camera.
     * A point's translucency will interpolate between the {@link NearFarScalar#nearValue} and
     * {@link NearFarScalar#farValue} while the camera distance falls within the lower and upper bounds
     * of the specified {@link NearFarScalar#near} and {@link NearFarScalar#far}.
     * Outside of these ranges the point's translucency remains clamped to the nearest bound.  If undefined,
     * translucencyByDistance will be disabled.
     * @example
     * // Example 1.
     * // Set a point's translucency to 1.0 when the
     * // camera is 1500 meters from the point and disappear as
     * // the camera distance approaches 8.0e6 meters.
     * p.translucencyByDistance = new Cesium.NearFarScalar(1.5e2, 1.0, 8.0e6, 0.0);
     * @example
     * // Example 2.
     * // disable translucency by distance
     * p.translucencyByDistance = undefined;
     */
    translucencyByDistance: NearFarScalar;
    /**
     * Gets or sets the inner size of the point in pixels.
     */
    pixelSize: number;
    /**
     * Gets or sets the inner color of the point.
     * The red, green, blue, and alpha values are indicated by <code>value</code>'s <code>red</code>, <code>green</code>,
     * <code>blue</code>, and <code>alpha</code> properties as shown in Example 1.  These components range from <code>0.0</code>
     * (no intensity) to <code>1.0</code> (full intensity).
     * @example
     * // Example 1. Assign yellow.
     * p.color = Cesium.Color.YELLOW;
     * @example
     * // Example 2. Make a pointPrimitive 50% translucent.
     * p.color = new Cesium.Color(1.0, 1.0, 1.0, 0.5);
     */
    color: Color;
    /**
     * Gets or sets the outline color of the point.
     */
    outlineColor: Color;
    /**
     * Gets or sets the outline width in pixels.  This width adds to pixelSize,
     * increasing the total size of the point.
     */
    outlineWidth: number;
    /**
     * Gets or sets the condition specifying at what distance from the camera that this point will be displayed.
     */
    distanceDisplayCondition: DistanceDisplayCondition;
    /**
     * Gets or sets the distance from the camera at which to disable the depth test to, for example, prevent clipping against terrain.
     * When set to zero, the depth test is always applied. When set to Number.POSITIVE_INFINITY, the depth test is never applied.
     */
    disableDepthTestDistance: number;
    /**
     * Gets or sets the user-defined value returned when the point is picked.
     */
    id: any;
    /**
     * Computes the screen-space position of the point's origin.
     * The screen space origin is the top, left corner of the canvas; <code>x</code> increases from
     * left to right, and <code>y</code> increases from top to bottom.
     * @example
     * console.log(p.computeScreenSpacePosition(scene).toString());
     * @param scene - The scene.
     * @param [result] - The object onto which to store the result.
     * @returns The screen-space position of the point.
     */
    computeScreenSpacePosition(scene: Scene, result?: Cartesian2): Cartesian2;
    /**
     * Determines if this point equals another point.  Points are equal if all their properties
     * are equal.  Points in different collections can be equal.
     * @param other - The point to compare for equality.
     * @returns <code>true</code> if the points are equal; otherwise, <code>false</code>.
     */
    equals(other: PointPrimitive): boolean;
}

/**
 * A renderable collection of points.
 * <br /><br />
 * Points are added and removed from the collection using {@link PointPrimitiveCollection#add}
 * and {@link PointPrimitiveCollection#remove}.
 * @example
 * // Create a pointPrimitive collection with two points
 * const points = scene.primitives.add(new Cesium.PointPrimitiveCollection());
 * points.add({
 *   position : new Cesium.Cartesian3(1.0, 2.0, 3.0),
 *   color : Cesium.Color.YELLOW
 * });
 * points.add({
 *   position : new Cesium.Cartesian3(4.0, 5.0, 6.0),
 *   color : Cesium.Color.CYAN
 * });
 * @param [options] - Object with the following properties:
 * @param [options.modelMatrix = Matrix4.IDENTITY] - The 4x4 transformation matrix that transforms each point from model to world coordinates.
 * @param [options.debugShowBoundingVolume = false] - For debugging only. Determines if this primitive's commands' bounding spheres are shown.
 * @param [options.blendOption = BlendOption.OPAQUE_AND_TRANSLUCENT] - The point blending option. The default
 * is used for rendering both opaque and translucent points. However, if either all of the points are completely opaque or all are completely translucent,
 * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve performance by up to 2x.
 * @param [options.show = true] - Determines if the primitives in the collection will be shown.
 */
export class PointPrimitiveCollection {
    constructor(options?: {
        modelMatrix?: Matrix4;
        debugShowBoundingVolume?: boolean;
        blendOption?: BlendOption;
        show?: boolean;
    });
    /**
     * Determines if primitives in this collection will be shown.
     */
    show: boolean;
    /**
     * The 4x4 transformation matrix that transforms each point in this collection from model to world coordinates.
     * When this is the identity matrix, the pointPrimitives are drawn in world coordinates, i.e., Earth's WGS84 coordinates.
     * Local reference frames can be used by providing a different transformation matrix, like that returned
     * by {@link Transforms.eastNorthUpToFixedFrame}.
     * @example
     * const center = Cesium.Cartesian3.fromDegrees(-75.59777, 40.03883);
     * pointPrimitives.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(center);
     * pointPrimitives.add({
     *   color : Cesium.Color.ORANGE,
     *   position : new Cesium.Cartesian3(0.0, 0.0, 0.0) // center
     * });
     * pointPrimitives.add({
     *   color : Cesium.Color.YELLOW,
     *   position : new Cesium.Cartesian3(1000000.0, 0.0, 0.0) // east
     * });
     * pointPrimitives.add({
     *   color : Cesium.Color.GREEN,
     *   position : new Cesium.Cartesian3(0.0, 1000000.0, 0.0) // north
     * });
     * pointPrimitives.add({
     *   color : Cesium.Color.CYAN,
     *   position : new Cesium.Cartesian3(0.0, 0.0, 1000000.0) // up
     * });
     */
    modelMatrix: Matrix4;
    /**
     * This property is for debugging only; it is not for production use nor is it optimized.
     * <p>
     * Draws the bounding sphere for each draw command in the primitive.
     * </p>
     */
    debugShowBoundingVolume: boolean;
    /**
     * The point blending option. The default is used for rendering both opaque and translucent points.
     * However, if either all of the points are completely opaque or all are completely translucent,
     * setting the technique to BlendOption.OPAQUE or BlendOption.TRANSLUCENT can improve
     * performance by up to 2x.
     */
    blendOption: BlendOption;
    /**
     * Returns the number of points in this collection.  This is commonly used with
     * {@link PointPrimitiveCollection#get} to iterate over all the points
     * in the collection.
     */
    length: number;
    /**
     * Creates and adds a point with the specified initial properties to the collection.
     * The added point is returned so it can be modified or removed from the collection later.
     * @example
     * // Example 1:  Add a point, specifying all the default values.
     * const p = pointPrimitives.add({
     *   show : true,
     *   position : Cesium.Cartesian3.ZERO,
     *   pixelSize : 10.0,
     *   color : Cesium.Color.WHITE,
     *   outlineColor : Cesium.Color.TRANSPARENT,
     *   outlineWidth : 0.0,
     *   id : undefined
     * });
     * @example
     * // Example 2:  Specify only the point's cartographic position.
     * const p = pointPrimitives.add({
     *   position : Cesium.Cartesian3.fromDegrees(longitude, latitude, height)
     * });
     * @param [options] - A template describing the point's properties as shown in Example 1.
     * @returns The point that was added to the collection.
     */
    add(options?: any): PointPrimitive;
    /**
     * Removes a point from the collection.
     * @example
     * const p = pointPrimitives.add(...);
     * pointPrimitives.remove(p);  // Returns true
     * @param pointPrimitive - The point to remove.
     * @returns <code>true</code> if the point was removed; <code>false</code> if the point was not found in the collection.
     */
    remove(pointPrimitive: PointPrimitive): boolean;
    /**
     * Removes all points from the collection.
     * @example
     * pointPrimitives.add(...);
     * pointPrimitives.add(...);
     * pointPrimitives.removeAll();
     */
    removeAll(): void;
    /**
     * Check whether this collection contains a given point.
     * @param [pointPrimitive] - The point to check for.
     * @returns true if this collection contains the point, false otherwise.
     */
    contains(pointPrimitive?: PointPrimitive): boolean;
    /**
     * Returns the point in the collection at the specified index.  Indices are zero-based
     * and increase as points are added.  Removing a point shifts all points after
     * it to the left, changing their indices.  This function is commonly used with
     * {@link PointPrimitiveCollection#length} to iterate over all the points
     * in the collection.
     * @example
     * // Toggle the show property of every point in the collection
     * const len = pointPrimitives.length;
     * for (let i = 0; i < len; ++i) {
     *   const p = pointPrimitives.get(i);
     *   p.show = !p.show;
     * }
     * @param index - The zero-based index of the point.
     * @returns The point at the specified index.
     */
    get(index: number): PointPrimitive;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     * @example
     * pointPrimitives = pointPrimitives && pointPrimitives.destroy();
     */
    destroy(): void;
}

/**
 * <div class="notice">
 * Create this by calling {@link PolylineCollection#add}. Do not call the constructor directly.
 * </div>
 *
 * A renderable polyline.
 */
export class Polyline {
    constructor();
    /**
     * Determines if this polyline will be shown.  Use this to hide or show a polyline, instead
     * of removing it and re-adding it to the collection.
     */
    show: boolean;
    /**
     * Gets or sets the positions of the polyline.
     * @example
     * polyline.positions = Cesium.Cartesian3.fromDegreesArray([
     *     0.0, 0.0,
     *     10.0, 0.0,
     *     0.0, 20.0
     * ]);
     */
    positions: Cartesian3[];
    /**
     * Gets or sets the surface appearance of the polyline.  This can be one of several built-in {@link Material} objects or a custom material, scripted with
     * {@link https://github.com/CesiumGS/cesium/wiki/Fabric|Fabric}.
     */
    material: Material;
    /**
     * Gets or sets the width of the polyline.
     */
    width: number;
    /**
     * Gets or sets whether a line segment will be added between the first and last polyline positions.
     */
    loop: boolean;
    /**
     * Gets or sets the user-defined value returned when the polyline is picked.
     */
    id: any;
    /**
     * Gets or sets the condition specifying at what distance from the camera that this polyline will be displayed.
     */
    distanceDisplayCondition: DistanceDisplayCondition;
}

/**
 * A renderable collection of polylines.
 * <br /><br />
 * <div align="center">
 * <img src="Images/Polyline.png" width="400" height="300" /><br />
 * Example polylines
 * </div>
 * <br /><br />
 * Polylines are added and removed from the collection using {@link PolylineCollection#add}
 * and {@link PolylineCollection#remove}.
 * @example
 * // Create a polyline collection with two polylines
 * const polylines = new Cesium.PolylineCollection();
 * polylines.add({
 *   positions : Cesium.Cartesian3.fromDegreesArray([
 *     -75.10, 39.57,
 *     -77.02, 38.53,
 *     -80.50, 35.14,
 *     -80.12, 25.46]),
 *   width : 2
 * });
 *
 * polylines.add({
 *   positions : Cesium.Cartesian3.fromDegreesArray([
 *     -73.10, 37.57,
 *     -75.02, 36.53,
 *     -78.50, 33.14,
 *     -78.12, 23.46]),
 *   width : 4
 * });
 * @param [options] - Object with the following properties:
 * @param [options.modelMatrix = Matrix4.IDENTITY] - The 4x4 transformation matrix that transforms each polyline from model to world coordinates.
 * @param [options.debugShowBoundingVolume = false] - For debugging only. Determines if this primitive's commands' bounding spheres are shown.
 * @param [options.show = true] - Determines if the polylines in the collection will be shown.
 */
export class PolylineCollection {
    constructor(options?: {
        modelMatrix?: Matrix4;
        debugShowBoundingVolume?: boolean;
        show?: boolean;
    });
    /**
     * Determines if polylines in this collection will be shown.
     */
    show: boolean;
    /**
     * The 4x4 transformation matrix that transforms each polyline in this collection from model to world coordinates.
     * When this is the identity matrix, the polylines are drawn in world coordinates, i.e., Earth's WGS84 coordinates.
     * Local reference frames can be used by providing a different transformation matrix, like that returned
     * by {@link Transforms.eastNorthUpToFixedFrame}.
     */
    modelMatrix: Matrix4;
    /**
     * This property is for debugging only; it is not for production use nor is it optimized.
     * <p>
     * Draws the bounding sphere for each draw command in the primitive.
     * </p>
     */
    debugShowBoundingVolume: boolean;
    /**
     * Returns the number of polylines in this collection.  This is commonly used with
     * {@link PolylineCollection#get} to iterate over all the polylines
     * in the collection.
     */
    length: number;
    /**
     * Creates and adds a polyline with the specified initial properties to the collection.
     * The added polyline is returned so it can be modified or removed from the collection later.
     * @example
     * // Example 1:  Add a polyline, specifying all the default values.
     * const p = polylines.add({
     *   show : true,
     *   positions : ellipsoid.cartographicArrayToCartesianArray([
     *            Cesium.Cartographic.fromDegrees(-75.10, 39.57),
     *            Cesium.Cartographic.fromDegrees(-77.02, 38.53)]),
     *   width : 1
     * });
     * @param [options] - A template describing the polyline's properties as shown in Example 1.
     * @returns The polyline that was added to the collection.
     */
    add(options?: any): Polyline;
    /**
     * Removes a polyline from the collection.
     * @example
     * const p = polylines.add(...);
     * polylines.remove(p);  // Returns true
     * @param polyline - The polyline to remove.
     * @returns <code>true</code> if the polyline was removed; <code>false</code> if the polyline was not found in the collection.
     */
    remove(polyline: Polyline): boolean;
    /**
     * Removes all polylines from the collection.
     * @example
     * polylines.add(...);
     * polylines.add(...);
     * polylines.removeAll();
     */
    removeAll(): void;
    /**
     * Determines if this collection contains the specified polyline.
     * @param polyline - The polyline to check for.
     * @returns true if this collection contains the polyline, false otherwise.
     */
    contains(polyline: Polyline): boolean;
    /**
     * Returns the polyline in the collection at the specified index.  Indices are zero-based
     * and increase as polylines are added.  Removing a polyline shifts all polylines after
     * it to the left, changing their indices.  This function is commonly used with
     * {@link PolylineCollection#length} to iterate over all the polylines
     * in the collection.
     * @example
     * // Toggle the show property of every polyline in the collection
     * const len = polylines.length;
     * for (let i = 0; i < len; ++i) {
     *   const p = polylines.get(i);
     *   p.show = !p.show;
     * }
     * @param index - The zero-based index of the polyline.
     * @returns The polyline at the specified index.
     */
    get(index: number): Polyline;
    /**
     * Called when {@link Viewer} or {@link CesiumWidget} render the scene to
     * get the draw commands needed to render this primitive.
     * <p>
     * Do not call this function directly.  This is documented just to
     * list the exceptions that may be propagated when the scene is rendered:
     * </p>
     */
    update(): void;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     * @example
     * polylines = polylines && polylines.destroy();
     */
    destroy(): void;
}

/**
 * An appearance for {@link GeometryInstance} instances with color attributes and
 * {@link PolylineGeometry} or {@link GroundPolylineGeometry}.
 * This allows several geometry instances, each with a different color, to
 * be drawn with the same {@link Primitive}.
 * @example
 * // A solid white line segment
 * const primitive = new Cesium.Primitive({
 *   geometryInstances : new Cesium.GeometryInstance({
 *     geometry : new Cesium.PolylineGeometry({
 *       positions : Cesium.Cartesian3.fromDegreesArray([
 *         0.0, 0.0,
 *         5.0, 0.0
 *       ]),
 *       width : 10.0,
 *       vertexFormat : Cesium.PolylineColorAppearance.VERTEX_FORMAT
 *     }),
 *     attributes : {
 *       color : Cesium.ColorGeometryInstanceAttribute.fromColor(new Cesium.Color(1.0, 1.0, 1.0, 1.0))
 *     }
 *   }),
 *   appearance : new Cesium.PolylineColorAppearance({
 *     translucent : false
 *   })
 * });
 * @param [options] - Object with the following properties:
 * @param [options.translucent = true] - When <code>true</code>, the geometry is expected to appear translucent so {@link PolylineColorAppearance#renderState} has alpha blending enabled.
 * @param [options.vertexShaderSource] - Optional GLSL vertex shader source to override the default vertex shader.
 * @param [options.fragmentShaderSource] - Optional GLSL fragment shader source to override the default fragment shader.
 * @param [options.renderState] - Optional render state to override the default render state.
 */
export class PolylineColorAppearance {
    constructor(options?: {
        translucent?: boolean;
        vertexShaderSource?: string;
        fragmentShaderSource?: string;
        renderState?: any;
    });
    /**
     * This property is part of the {@link Appearance} interface, but is not
     * used by {@link PolylineColorAppearance} since a fully custom fragment shader is used.
     */
    material: Material;
    /**
     * When <code>true</code>, the geometry is expected to appear translucent so
     * {@link PolylineColorAppearance#renderState} has alpha blending enabled.
     */
    translucent: boolean;
    /**
     * The GLSL source code for the vertex shader.
     */
    readonly vertexShaderSource: string;
    /**
     * The GLSL source code for the fragment shader.
     */
    readonly fragmentShaderSource: string;
    /**
     * The WebGL fixed-function state to use when rendering the geometry.
     * <p>
     * The render state can be explicitly defined when constructing a {@link PolylineColorAppearance}
     * instance, or it is set implicitly via {@link PolylineColorAppearance#translucent}.
     * </p>
     */
    readonly renderState: any;
    /**
     * When <code>true</code>, the geometry is expected to be closed so
     * {@link PolylineColorAppearance#renderState} has backface culling enabled.
     * This is always <code>false</code> for <code>PolylineColorAppearance</code>.
     */
    readonly closed: boolean;
    /**
     * The {@link VertexFormat} that this appearance instance is compatible with.
     * A geometry can have more vertex attributes and still be compatible - at a
     * potential performance cost - but it can't have less.
     */
    readonly vertexFormat: VertexFormat;
    /**
     * The {@link VertexFormat} that all {@link PolylineColorAppearance} instances
     * are compatible with. This requires only a <code>position</code> attribute.
     */
    static readonly VERTEX_FORMAT: VertexFormat;
    /**
     * Procedurally creates the full GLSL fragment shader source.
     * @returns The full GLSL fragment shader source.
     */
    getFragmentShaderSource(): string;
    /**
     * Determines if the geometry is translucent based on {@link PolylineColorAppearance#translucent}.
     * @returns <code>true</code> if the appearance is translucent.
     */
    isTranslucent(): boolean;
    /**
     * Creates a render state.  This is not the final render state instance; instead,
     * it can contain a subset of render state properties identical to the render state
     * created in the context.
     * @returns The render state.
     */
    getRenderState(): any;
}

/**
 * An appearance for {@link PolylineGeometry} that supports shading with materials.
 * @example
 * const primitive = new Cesium.Primitive({
 *   geometryInstances : new Cesium.GeometryInstance({
 *     geometry : new Cesium.PolylineGeometry({
 *       positions : Cesium.Cartesian3.fromDegreesArray([
 *         0.0, 0.0,
 *         5.0, 0.0
 *       ]),
 *       width : 10.0,
 *       vertexFormat : Cesium.PolylineMaterialAppearance.VERTEX_FORMAT
 *     })
 *   }),
 *   appearance : new Cesium.PolylineMaterialAppearance({
 *     material : Cesium.Material.fromType('Color')
 *   })
 * });
 * @param [options] - Object with the following properties:
 * @param [options.translucent = true] - When <code>true</code>, the geometry is expected to appear translucent so {@link PolylineMaterialAppearance#renderState} has alpha blending enabled.
 * @param [options.material = Material.ColorType] - The material used to determine the fragment color.
 * @param [options.vertexShaderSource] - Optional GLSL vertex shader source to override the default vertex shader.
 * @param [options.fragmentShaderSource] - Optional GLSL fragment shader source to override the default fragment shader.
 * @param [options.renderState] - Optional render state to override the default render state.
 */
export class PolylineMaterialAppearance {
    constructor(options?: {
        translucent?: boolean;
        material?: Material;
        vertexShaderSource?: string;
        fragmentShaderSource?: string;
        renderState?: any;
    });
    /**
     * The material used to determine the fragment color.  Unlike other {@link PolylineMaterialAppearance}
     * properties, this is not read-only, so an appearance's material can change on the fly.
     */
    material: Material;
    /**
     * When <code>true</code>, the geometry is expected to appear translucent so
     * {@link PolylineMaterialAppearance#renderState} has alpha blending enabled.
     */
    translucent: boolean;
    /**
     * The GLSL source code for the vertex shader.
     */
    readonly vertexShaderSource: string;
    /**
     * The GLSL source code for the fragment shader.
     */
    readonly fragmentShaderSource: string;
    /**
     * The WebGL fixed-function state to use when rendering the geometry.
     * <p>
     * The render state can be explicitly defined when constructing a {@link PolylineMaterialAppearance}
     * instance, or it is set implicitly via {@link PolylineMaterialAppearance#translucent}
     * and {@link PolylineMaterialAppearance#closed}.
     * </p>
     */
    readonly renderState: any;
    /**
     * When <code>true</code>, the geometry is expected to be closed so
     * {@link PolylineMaterialAppearance#renderState} has backface culling enabled.
     * This is always <code>false</code> for <code>PolylineMaterialAppearance</code>.
     */
    readonly closed: boolean;
    /**
     * The {@link VertexFormat} that this appearance instance is compatible with.
     * A geometry can have more vertex attributes and still be compatible - at a
     * potential performance cost - but it can't have less.
     */
    readonly vertexFormat: VertexFormat;
    /**
     * The {@link VertexFormat} that all {@link PolylineMaterialAppearance} instances
     * are compatible with. This requires <code>position</code> and <code>st</code> attributes.
     */
    static readonly VERTEX_FORMAT: VertexFormat;
    /**
     * Procedurally creates the full GLSL fragment shader source.  For {@link PolylineMaterialAppearance},
     * this is derived from {@link PolylineMaterialAppearance#fragmentShaderSource} and {@link PolylineMaterialAppearance#material}.
     * @returns The full GLSL fragment shader source.
     */
    getFragmentShaderSource(): string;
    /**
     * Determines if the geometry is translucent based on {@link PolylineMaterialAppearance#translucent} and {@link Material#isTranslucent}.
     * @returns <code>true</code> if the appearance is translucent.
     */
    isTranslucent(): boolean;
    /**
     * Creates a render state.  This is not the final render state instance; instead,
     * it can contain a subset of render state properties identical to the render state
     * created in the context.
     * @returns The render state.
     */
    getRenderState(): any;
}

/**
 * Runs a post-process stage on either the texture rendered by the scene or the output of a previous post-process stage.
 * @example
 * // Simple stage to change the color
 * const fs =`
 *     uniform sampler2D colorTexture;
 *     in vec2 v_textureCoordinates;
 *     uniform float scale;
 *     uniform vec3 offset;
 *     void main() {
 *         vec4 color = texture(colorTexture, v_textureCoordinates);
 *         out_FragColor = vec4(color.rgb * scale + offset, 1.0);
 *     }`;
 * scene.postProcessStages.add(new Cesium.PostProcessStage({
 *     fragmentShader : fs,
 *     uniforms : {
 *         scale : 1.1,
 *         offset : function() {
 *             return new Cesium.Cartesian3(0.1, 0.2, 0.3);
 *         }
 *     }
 * }));
 * @example
 * // Simple stage to change the color of what is selected.
 * // If czm_selected returns true, the current fragment belongs to geometry in the selected array.
 * const fs =`
 *     uniform sampler2D colorTexture;
 *     in vec2 v_textureCoordinates;
 *     uniform vec4 highlight;
 *     void main() {
 *         vec4 color = texture(colorTexture, v_textureCoordinates);
 *         if (czm_selected()) {
 *             vec3 highlighted = highlight.a * highlight.rgb + (1.0 - highlight.a) * color.rgb;
 *             out_FragColor = vec4(highlighted, 1.0);
 *         } else {
 *             out_FragColor = color;
 *         }
 *     }`;
 * const stage = scene.postProcessStages.add(new Cesium.PostProcessStage({
 *     fragmentShader : fs,
 *     uniforms : {
 *         highlight : function() {
 *             return new Cesium.Color(1.0, 0.0, 0.0, 0.5);
 *         }
 *     }
 * }));
 * stage.selected = [cesium3DTileFeature];
 * @param options - An object with the following properties:
 * @param options.fragmentShader - The fragment shader to use. The default <code>sampler2D</code> uniforms are <code>colorTexture</code> and <code>depthTexture</code>. The color texture is the output of rendering the scene or the previous stage. The depth texture is the output from rendering the scene. The shader should contain one or both uniforms. There is also a <code>vec2</code> varying named <code>v_textureCoordinates</code> that can be used to sample the textures.
 * @param [options.uniforms] - An object whose properties will be used to set the shaders uniforms. The properties can be constant values or a function. A constant value can also be a URI, data URI, or HTML element to use as a texture.
 * @param [options.textureScale = 1.0] - A number in the range (0.0, 1.0] used to scale the texture dimensions. A scale of 1.0 will render this post-process stage  to a texture the size of the viewport.
 * @param [options.forcePowerOfTwo = false] - Whether or not to force the texture dimensions to be both equal powers of two. The power of two will be the next power of two of the minimum of the dimensions.
 * @param [options.sampleMode = PostProcessStageSampleMode.NEAREST] - How to sample the input color texture.
 * @param [options.pixelFormat = PixelFormat.RGBA] - The color pixel format of the output texture.
 * @param [options.pixelDatatype = PixelDatatype.UNSIGNED_BYTE] - The pixel data type of the output texture.
 * @param [options.clearColor = Color.BLACK] - The color to clear the output texture to.
 * @param [options.scissorRectangle] - The rectangle to use for the scissor test.
 * @param [options.name = createGuid()] - The unique name of this post-process stage for reference by other stages in a composite. If a name is not supplied, a GUID will be generated.
 */
export class PostProcessStage {
    constructor(options: {
        fragmentShader: string;
        uniforms?: any;
        textureScale?: number;
        forcePowerOfTwo?: boolean;
        sampleMode?: PostProcessStageSampleMode;
        pixelFormat?: PixelFormat;
        pixelDatatype?: PixelDatatype;
        clearColor?: Color;
        scissorRectangle?: BoundingRectangle;
        name?: string;
    });
    /**
     * Whether or not to execute this post-process stage when ready.
     */
    enabled: boolean;
    /**
     * Determines if this post-process stage is ready to be executed. A stage is only executed when both <code>ready</code>
     * and {@link PostProcessStage#enabled} are <code>true</code>. A stage will not be ready while it is waiting on textures
     * to load.
     */
    readonly ready: boolean;
    /**
     * The unique name of this post-process stage for reference by other stages in a {@link PostProcessStageComposite}.
     */
    readonly name: string;
    /**
     * The fragment shader to use when execute this post-process stage.
     * <p>
     * The shader must contain a sampler uniform declaration for <code>colorTexture</code>, <code>depthTexture</code>,
     * or both.
     * </p>
     * <p>
     * The shader must contain a <code>vec2</code> varying declaration for <code>v_textureCoordinates</code> for sampling
     * the texture uniforms.
     * </p>
     */
    readonly fragmentShader: string;
    /**
     * An object whose properties are used to set the uniforms of the fragment shader.
     * <p>
     * The object property values can be either a constant or a function. The function will be called
     * each frame before the post-process stage is executed.
     * </p>
     * <p>
     * A constant value can also be a URI to an image, a data URI, or an HTML element that can be used as a texture, such as HTMLImageElement or HTMLCanvasElement.
     * </p>
     * <p>
     * If this post-process stage is part of a {@link PostProcessStageComposite} that does not execute in series, the constant value can also be
     * the name of another stage in a composite. This will set the uniform to the output texture the stage with that name.
     * </p>
     */
    readonly uniforms: any;
    /**
     * A number in the range (0.0, 1.0] used to scale the output texture dimensions. A scale of 1.0 will render this post-process stage to a texture the size of the viewport.
     */
    readonly textureScale: number;
    /**
     * Whether or not to force the output texture dimensions to be both equal powers of two. The power of two will be the next power of two of the minimum of the dimensions.
     */
    readonly forcePowerOfTwo: number;
    /**
     * How to sample the input color texture.
     */
    readonly sampleMode: PostProcessStageSampleMode;
    /**
     * The color pixel format of the output texture.
     */
    readonly pixelFormat: PixelFormat;
    /**
     * The pixel data type of the output texture.
     */
    readonly pixelDatatype: PixelDatatype;
    /**
     * The color to clear the output texture to.
     */
    readonly clearColor: Color;
    /**
     * The {@link BoundingRectangle} to use for the scissor test. A default bounding rectangle will disable the scissor test.
     */
    readonly scissorRectangle: BoundingRectangle;
    /**
     * The features selected for applying the post-process.
     * <p>
     * In the fragment shader, use <code>czm_selected</code> to determine whether or not to apply the post-process
     * stage to that fragment. For example:
     * <code>
     * if (czm_selected(v_textureCoordinates)) {
     *     // apply post-process stage
     * } else {
     *     out_FragColor = texture(colorTexture, v_textureCoordinates);
     * }
     * </code>
     * </p>
     */
    selected: any[];
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <p>
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * </p>
     * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <p>
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     * </p>
     */
    destroy(): void;
}

/**
 * A collection of {@link PostProcessStage}s and/or {@link PostProcessStageComposite}s.
 * <p>
 * The input texture for each post-process stage is the texture rendered to by the scene or the texture rendered
 * to by the previous stage in the collection.
 * </p>
 * <p>
 * If the ambient occlusion or bloom stages are enabled, they will execute before all other stages.
 * </p>
 * <p>
 * If the FXAA stage is enabled, it will execute after all other stages.
 * </p>
 */
export class PostProcessStageCollection {
    constructor();
    /**
     * Determines if all of the post-process stages in the collection are ready to be executed.
     */
    readonly ready: boolean;
    /**
     * A post-process stage for Fast Approximate Anti-aliasing.
     * <p>
     * When enabled, this stage will execute after all others.
     * </p>
     */
    readonly fxaa: PostProcessStage;
    /**
     * A post-process stage that applies Horizon-based Ambient Occlusion (HBAO) to the input texture.
     * <p>
     * Ambient occlusion simulates shadows from ambient light. These shadows would always be present when the
     * surface receives light and regardless of the light's position.
     * </p>
     * <p>
     * The uniforms have the following properties: <code>intensity</code>, <code>bias</code>, <code>lengthCap</code>,
     * <code>stepSize</code>, <code>frustumLength</code>, <code>ambientOcclusionOnly</code>,
     * <code>delta</code>, <code>sigma</code>, and <code>blurStepSize</code>.
     * </p>
     * <ul>
     * <li><code>intensity</code> is a scalar value used to lighten or darken the shadows exponentially. Higher values make the shadows darker. The default value is <code>3.0</code>.</li>
     *
     * <li><code>bias</code> is a scalar value representing an angle in radians. If the dot product between the normal of the sample and the vector to the camera is less than this value,
     * sampling stops in the current direction. This is used to remove shadows from near planar edges. The default value is <code>0.1</code>.</li>
     *
     * <li><code>lengthCap</code> is a scalar value representing a length in meters. If the distance from the current sample to first sample is greater than this value,
     * sampling stops in the current direction. The default value is <code>0.26</code>.</li>
     *
     * <li><code>stepSize</code> is a scalar value indicating the distance to the next texel sample in the current direction. The default value is <code>1.95</code>.</li>
     *
     * <li><code>frustumLength</code> is a scalar value in meters. If the current fragment has a distance from the camera greater than this value, ambient occlusion is not computed for the fragment.
     * The default value is <code>1000.0</code>.</li>
     *
     * <li><code>ambientOcclusionOnly</code> is a boolean value. When <code>true</code>, only the shadows generated are written to the output. When <code>false</code>, the input texture is modulated
     * with the ambient occlusion. This is a useful debug option for seeing the effects of changing the uniform values. The default value is <code>false</code>.</li>
     * </ul>
     * <p>
     * <code>delta</code>, <code>sigma</code>, and <code>blurStepSize</code> are the same properties as {@link PostProcessStageLibrary#createBlurStage}.
     * The blur is applied to the shadows generated from the image to make them smoother.
     * </p>
     * <p>
     * When enabled, this stage will execute before all others.
     * </p>
     */
    readonly ambientOcclusion: PostProcessStageComposite;
    /**
     * A post-process stage for a bloom effect.
     * <p>
     * A bloom effect adds glow effect, makes bright areas brighter, and dark areas darker.
     * </p>
     * <p>
     * This stage has the following uniforms: <code>contrast</code>, <code>brightness</code>, <code>glowOnly</code>,
     * <code>delta</code>, <code>sigma</code>, and <code>stepSize</code>.
     * </p>
     * <ul>
     * <li><code>contrast</code> is a scalar value in the range [-255.0, 255.0] and affects the contract of the effect. The default value is <code>128.0</code>.</li>
     *
     * <li><code>brightness</code> is a scalar value. The input texture RGB value is converted to hue, saturation, and brightness (HSB) then this value is
     * added to the brightness. The default value is <code>-0.3</code>.</li>
     *
     * <li><code>glowOnly</code> is a boolean value. When <code>true</code>, only the glow effect will be shown. When <code>false</code>, the glow will be added to the input texture.
     * The default value is <code>false</code>. This is a debug option for viewing the effects when changing the other uniform values.</li>
     * </ul>
     * <p>
     * <code>delta</code>, <code>sigma</code>, and <code>stepSize</code> are the same properties as {@link PostProcessStageLibrary#createBlurStage}.
     * The blur is applied to the shadows generated from the image to make them smoother.
     * </p>
     * <p>
     * When enabled, this stage will execute before all others.
     * </p>
     */
    readonly bloom: PostProcessStageComposite;
    /**
     * The number of post-process stages in this collection.
     */
    readonly length: number;
    /**
     * Adds the post-process stage to the collection.
     * @param stage - The post-process stage to add to the collection.
     * @returns The post-process stage that was added to the collection.
     */
    add(stage: PostProcessStage | PostProcessStageComposite): PostProcessStage | PostProcessStageComposite;
    /**
     * Removes a post-process stage from the collection and destroys it.
     * @param stage - The post-process stage to remove from the collection.
     * @returns Whether the post-process stage was removed.
     */
    remove(stage: PostProcessStage | PostProcessStageComposite): boolean;
    /**
     * Returns whether the collection contains a post-process stage.
     * @param stage - The post-process stage.
     * @returns Whether the collection contains the post-process stage.
     */
    contains(stage: PostProcessStage | PostProcessStageComposite): boolean;
    /**
     * Gets the post-process stage at <code>index</code>.
     * @param index - The index of the post-process stage.
     * @returns The post-process stage at index.
     */
    get(index: number): PostProcessStage | PostProcessStageComposite;
    /**
     * Removes all post-process stages from the collection and destroys them.
     */
    removeAll(): void;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <p>
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * </p>
     * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <p>
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     * </p>
     */
    destroy(): void;
}

/**
 * A collection of {@link PostProcessStage}s or other post-process composite stages that execute together logically.
 * <p>
 * All stages are executed in the order of the array. The input texture changes based on the value of <code>inputPreviousStageTexture</code>.
 * If <code>inputPreviousStageTexture</code> is <code>true</code>, the input to each stage is the output texture rendered to by the scene or of the stage that executed before it.
 * If <code>inputPreviousStageTexture</code> is <code>false</code>, the input texture is the same for each stage in the composite. The input texture is the texture rendered to by the scene
 * or the output texture of the previous stage.
 * </p>
 * @example
 * // Example 1: separable blur filter
 * // The input to blurXDirection is the texture rendered to by the scene or the output of the previous stage.
 * // The input to blurYDirection is the texture rendered to by blurXDirection.
 * scene.postProcessStages.add(new Cesium.PostProcessStageComposite({
 *     stages : [blurXDirection, blurYDirection]
 * }));
 * @example
 * // Example 2: referencing the output of another post-process stage
 * scene.postProcessStages.add(new Cesium.PostProcessStageComposite({
 *     inputPreviousStageTexture : false,
 *     stages : [
 *         // The same as Example 1.
 *         new Cesium.PostProcessStageComposite({
 *             inputPreviousStageTexture : true
 *             stages : [blurXDirection, blurYDirection],
 *             name : 'blur'
 *         }),
 *         // The input texture for this stage is the same input texture to blurXDirection since inputPreviousStageTexture is false
 *         new Cesium.PostProcessStage({
 *             fragmentShader : compositeShader,
 *             uniforms : {
 *                 blurTexture : 'blur' // The output of the composite with name 'blur' (the texture that blurYDirection rendered to).
 *             }
 *         })
 *     ]
 * });
 * @example
 * // Example 3: create a uniform alias
 * const uniforms = {};
 * Cesium.defineProperties(uniforms, {
 *     filterSize : {
 *         get : function() {
 *             return blurXDirection.uniforms.filterSize;
 *         },
 *         set : function(value) {
 *             blurXDirection.uniforms.filterSize = blurYDirection.uniforms.filterSize = value;
 *         }
 *     }
 * });
 * scene.postProcessStages.add(new Cesium.PostProcessStageComposite({
 *     stages : [blurXDirection, blurYDirection],
 *     uniforms : uniforms
 * }));
 * @param options - An object with the following properties:
 * @param options.stages - An array of {@link PostProcessStage}s or composites to be executed in order.
 * @param [options.inputPreviousStageTexture = true] - Whether to execute each post-process stage where the input to one stage is the output of the previous. Otherwise, the input to each contained stage is the output of the stage that executed before the composite.
 * @param [options.name = createGuid()] - The unique name of this post-process stage for reference by other composites. If a name is not supplied, a GUID will be generated.
 * @param [options.uniforms] - An alias to the uniforms of post-process stages.
 */
export class PostProcessStageComposite {
    constructor(options: {
        stages: any[];
        inputPreviousStageTexture?: boolean;
        name?: string;
        uniforms?: any;
    });
    /**
     * Determines if this post-process stage is ready to be executed.
     */
    readonly ready: boolean;
    /**
     * The unique name of this post-process stage for reference by other stages in a PostProcessStageComposite.
     */
    readonly name: string;
    /**
     * Whether or not to execute this post-process stage when ready.
     */
    enabled: boolean;
    /**
     * An alias to the uniform values of the post-process stages. May be <code>undefined</code>; in which case, get each stage to set uniform values.
     */
    uniforms: any;
    /**
     * All post-process stages are executed in the order of the array. The input texture changes based on the value of <code>inputPreviousStageTexture</code>.
     * If <code>inputPreviousStageTexture</code> is <code>true</code>, the input to each stage is the output texture rendered to by the scene or of the stage that executed before it.
     * If <code>inputPreviousStageTexture</code> is <code>false</code>, the input texture is the same for each stage in the composite. The input texture is the texture rendered to by the scene
     * or the output texture of the previous stage.
     */
    readonly inputPreviousStageTexture: boolean;
    /**
     * The number of post-process stages in this composite.
     */
    readonly length: number;
    /**
     * The features selected for applying the post-process.
     */
    selected: any[];
    /**
     * Gets the post-process stage at <code>index</code>
     * @param index - The index of the post-process stage or composite.
     * @returns The post-process stage or composite at index.
     */
    get(index: number): PostProcessStage | PostProcessStageComposite;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <p>
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * </p>
     * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <p>
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     * </p>
     */
    destroy(): void;
}

/**
 * Contains functions for creating common post-process stages.
 */
export namespace PostProcessStageLibrary {
    /**
     * Creates a post-process stage that applies a Gaussian blur to the input texture. This stage is usually applied in conjunction with another stage.
     * <p>
     * This stage has the following uniforms: <code>delta</code>, <code>sigma</code>, and <code>stepSize</code>.
     * </p>
     * <p>
     * <code>delta</code> and <code>sigma</code> are used to compute the weights of a Gaussian filter. The equation is <code>exp((-0.5 * delta * delta) / (sigma * sigma))</code>.
     * The default value for <code>delta</code> is <code>1.0</code>. The default value for <code>sigma</code> is <code>2.0</code>.
     * <code>stepSize</code> is the distance to the next texel. The default is <code>1.0</code>.
     * </p>
     * @returns A post-process stage that applies a Gaussian blur to the input texture.
     */
    function createBlurStage(): PostProcessStageComposite;
    /**
     * Creates a post-process stage that applies a depth of field effect.
     * <p>
     * Depth of field simulates camera focus. Objects in the scene that are in focus
     * will be clear whereas objects not in focus will be blurred.
     * </p>
     * <p>
     * This stage has the following uniforms: <code>focalDistance</code>, <code>delta</code>, <code>sigma</code>, and <code>stepSize</code>.
     * </p>
     * <p>
     * <code>focalDistance</code> is the distance in meters from the camera to set the camera focus.
     * </p>
     * <p>
     * <code>delta</code>, <code>sigma</code>, and <code>stepSize</code> are the same properties as {@link PostProcessStageLibrary#createBlurStage}.
     * The blur is applied to the areas out of focus.
     * </p>
     * @returns A post-process stage that applies a depth of field effect.
     */
    function createDepthOfFieldStage(): PostProcessStageComposite;
    /**
     * Whether or not a depth of field stage is supported.
     * <p>
     * This stage requires the WEBGL_depth_texture extension.
     * </p>
     * @param scene - The scene.
     * @returns Whether this post process stage is supported.
     */
    function isDepthOfFieldSupported(scene: Scene): boolean;
    /**
     * Creates a post-process stage that detects edges.
     * <p>
     * Writes the color to the output texture with alpha set to 1.0 when it is on an edge.
     * </p>
     * <p>
     * This stage has the following uniforms: <code>color</code> and <code>length</code>
     * </p>
     * <ul>
     * <li><code>color</code> is the color of the highlighted edge. The default is {@link Color#BLACK}.</li>
     * <li><code>length</code> is the length of the edges in pixels. The default is <code>0.5</code>.</li>
     * </ul>
     * <p>
     * This stage is not supported in 2D.
     * </p>
     * @example
     * // multiple silhouette effects
     * const yellowEdge = Cesium.PostProcessStageLibrary.createEdgeDetectionStage();
     * yellowEdge.uniforms.color = Cesium.Color.YELLOW;
     * yellowEdge.selected = [feature0];
     *
     * const greenEdge = Cesium.PostProcessStageLibrary.createEdgeDetectionStage();
     * greenEdge.uniforms.color = Cesium.Color.LIME;
     * greenEdge.selected = [feature1];
     *
     * // draw edges around feature0 and feature1
     * postProcessStages.add(Cesium.PostProcessStageLibrary.createSilhouetteStage([yellowEdge, greenEdge]);
     * @returns A post-process stage that applies an edge detection effect.
     */
    function createEdgeDetectionStage(): PostProcessStage;
    /**
     * Whether or not an edge detection stage is supported.
     * <p>
     * This stage requires the WEBGL_depth_texture extension.
     * </p>
     * @param scene - The scene.
     * @returns Whether this post process stage is supported.
     */
    function isEdgeDetectionSupported(scene: Scene): boolean;
    /**
     * Creates a post-process stage that applies a silhouette effect.
     * <p>
     * A silhouette effect composites the color from the edge detection pass with input color texture.
     * </p>
     * <p>
     * This stage has the following uniforms when <code>edgeDetectionStages</code> is <code>undefined</code>: <code>color</code> and <code>length</code>
     * </p>
     * <p>
     * <code>color</code> is the color of the highlighted edge. The default is {@link Color#BLACK}.
     * <code>length</code> is the length of the edges in pixels. The default is <code>0.5</code>.
     * </p>
     * @param [edgeDetectionStages] - An array of edge detection post process stages.
     * @returns A post-process stage that applies a silhouette effect.
     */
    function createSilhouetteStage(edgeDetectionStages?: PostProcessStage[]): PostProcessStageComposite;
    /**
     * Whether or not a silhouette stage is supported.
     * <p>
     * This stage requires the WEBGL_depth_texture extension.
     * </p>
     * @param scene - The scene.
     * @returns Whether this post process stage is supported.
     */
    function isSilhouetteSupported(scene: Scene): boolean;
    /**
     * Whether or not an ambient occlusion stage is supported.
     * <p>
     * This stage requires the WEBGL_depth_texture extension.
     * </p>
     * @param scene - The scene.
     * @returns Whether this post process stage is supported.
     */
    function isAmbientOcclusionSupported(scene: Scene): boolean;
    /**
     * Creates a post-process stage that renders the input texture with black and white gradations.
     * <p>
     * This stage has one uniform value, <code>gradations</code>, which scales the luminance of each pixel.
     * </p>
     * @returns A post-process stage that renders the input texture with black and white gradations.
     */
    function createBlackAndWhiteStage(): PostProcessStage;
    /**
     * Creates a post-process stage that saturates the input texture.
     * <p>
     * This stage has one uniform value, <code>brightness</code>, which scales the saturation of each pixel.
     * </p>
     * @returns A post-process stage that saturates the input texture.
     */
    function createBrightnessStage(): PostProcessStage;
    /**
     * Creates a post-process stage that adds a night vision effect to the input texture.
     * @returns A post-process stage that adds a night vision effect to the input texture.
     */
    function createNightVisionStage(): PostProcessStage;
    /**
     * Creates a post-process stage that applies an effect simulating light flaring a camera lens.
     * <p>
     * This stage has the following uniforms: <code>dirtTexture</code>, <code>starTexture</code>, <code>intensity</code>, <code>distortion</code>, <code>ghostDispersal</code>,
     * <code>haloWidth</code>, <code>dirtAmount</code>, and <code>earthRadius</code>.
     * <ul>
     * <li><code>dirtTexture</code> is a texture sampled to simulate dirt on the lens.</li>
     * <li><code>starTexture</code> is the texture sampled for the star pattern of the flare.</li>
     * <li><code>intensity</code> is a scalar multiplied by the result of the lens flare. The default value is <code>2.0</code>.</li>
     * <li><code>distortion</code> is a scalar value that affects the chromatic effect distortion. The default value is <code>10.0</code>.</li>
     * <li><code>ghostDispersal</code> is a scalar indicating how far the halo effect is from the center of the texture. The default value is <code>0.4</code>.</li>
     * <li><code>haloWidth</code> is a scalar representing the width of the halo  from the ghost dispersal. The default value is <code>0.4</code>.</li>
     * <li><code>dirtAmount</code> is a scalar representing the amount of dirt on the lens. The default value is <code>0.4</code>.</li>
     * <li><code>earthRadius</code> is the maximum radius of the earth. The default value is <code>Ellipsoid.WGS84.maximumRadius</code>.</li>
     * </ul>
     * </p>
     * @returns A post-process stage for applying a lens flare effect.
     */
    function createLensFlareStage(): PostProcessStage;
}

/**
 * Determines how input texture to a {@link PostProcessStage} is sampled.
 */
export enum PostProcessStageSampleMode {
    /**
     * Samples the texture by returning the closest texel.
     */
    NEAREST = 0,
    /**
     * Samples the texture through bi-linear interpolation of the four nearest texels.
     */
    LINEAR = 1
}

/**
 * A primitive represents geometry in the {@link Scene}.  The geometry can be from a single {@link GeometryInstance}
 * as shown in example 1 below, or from an array of instances, even if the geometry is from different
 * geometry types, e.g., an {@link RectangleGeometry} and an {@link EllipsoidGeometry} as shown in Code Example 2.
 * <p>
 * A primitive combines geometry instances with an {@link Appearance} that describes the full shading, including
 * {@link Material} and {@link RenderState}.  Roughly, the geometry instance defines the structure and placement,
 * and the appearance defines the visual characteristics.  Decoupling geometry and appearance allows us to mix
 * and match most of them and add a new geometry or appearance independently of each other.
 * </p>
 * <p>
 * Combining multiple instances into one primitive is called batching, and significantly improves performance for static data.
 * Instances can be individually picked; {@link Scene#pick} returns their {@link GeometryInstance#id}.  Using
 * per-instance appearances like {@link PerInstanceColorAppearance}, each instance can also have a unique color.
 * </p>
 * <p>
 * {@link Geometry} can either be created and batched on a web worker or the main thread. The first two examples
 * show geometry that will be created on a web worker by using the descriptions of the geometry. The third example
 * shows how to create the geometry on the main thread by explicitly calling the <code>createGeometry</code> method.
 * </p>
 * @example
 * // 1. Draw a translucent ellipse on the surface with a checkerboard pattern
 * const instance = new Cesium.GeometryInstance({
 *   geometry : new Cesium.EllipseGeometry({
 *       center : Cesium.Cartesian3.fromDegrees(-100.0, 20.0),
 *       semiMinorAxis : 500000.0,
 *       semiMajorAxis : 1000000.0,
 *       rotation : Cesium.Math.PI_OVER_FOUR,
 *       vertexFormat : Cesium.VertexFormat.POSITION_AND_ST
 *   }),
 *   id : 'object returned when this instance is picked and to get/set per-instance attributes'
 * });
 * scene.primitives.add(new Cesium.Primitive({
 *   geometryInstances : instance,
 *   appearance : new Cesium.EllipsoidSurfaceAppearance({
 *     material : Cesium.Material.fromType('Checkerboard')
 *   })
 * }));
 * @example
 * // 2. Draw different instances each with a unique color
 * const rectangleInstance = new Cesium.GeometryInstance({
 *   geometry : new Cesium.RectangleGeometry({
 *     rectangle : Cesium.Rectangle.fromDegrees(-140.0, 30.0, -100.0, 40.0),
 *     vertexFormat : Cesium.PerInstanceColorAppearance.VERTEX_FORMAT
 *   }),
 *   id : 'rectangle',
 *   attributes : {
 *     color : new Cesium.ColorGeometryInstanceAttribute(0.0, 1.0, 1.0, 0.5)
 *   }
 * });
 * const ellipsoidInstance = new Cesium.GeometryInstance({
 *   geometry : new Cesium.EllipsoidGeometry({
 *     radii : new Cesium.Cartesian3(500000.0, 500000.0, 1000000.0),
 *     vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL
 *   }),
 *   modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(
 *     Cesium.Cartesian3.fromDegrees(-95.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 500000.0), new Cesium.Matrix4()),
 *   id : 'ellipsoid',
 *   attributes : {
 *     color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA)
 *   }
 * });
 * scene.primitives.add(new Cesium.Primitive({
 *   geometryInstances : [rectangleInstance, ellipsoidInstance],
 *   appearance : new Cesium.PerInstanceColorAppearance()
 * }));
 * @example
 * // 3. Create the geometry on the main thread.
 * scene.primitives.add(new Cesium.Primitive({
 *   geometryInstances : new Cesium.GeometryInstance({
 *     geometry : Cesium.EllipsoidGeometry.createGeometry(new Cesium.EllipsoidGeometry({
 *       radii : new Cesium.Cartesian3(500000.0, 500000.0, 1000000.0),
 *       vertexFormat : Cesium.VertexFormat.POSITION_AND_NORMAL
 *     })),
 *     modelMatrix : Cesium.Matrix4.multiplyByTranslation(Cesium.Transforms.eastNorthUpToFixedFrame(
 *       Cesium.Cartesian3.fromDegrees(-95.59777, 40.03883)), new Cesium.Cartesian3(0.0, 0.0, 500000.0), new Cesium.Matrix4()),
 *     id : 'ellipsoid',
 *     attributes : {
 *       color : Cesium.ColorGeometryInstanceAttribute.fromColor(Cesium.Color.AQUA)
 *     }
 *   }),
 *   appearance : new Cesium.PerInstanceColorAppearance(),
 *   asynchronous : false
 * }));
 * @param [options] - Object with the following properties:
 * @param [options.geometryInstances] - The geometry instances - or a single geometry instance - to render.
 * @param [options.appearance] - The appearance used to render the primitive.
 * @param [options.depthFailAppearance] - The appearance used to shade this primitive when it fails the depth test.
 * @param [options.show = true] - Determines if this primitive will be shown.
 * @param [options.modelMatrix = Matrix4.IDENTITY] - The 4x4 transformation matrix that transforms the primitive (all geometry instances) from model to world coordinates.
 * @param [options.vertexCacheOptimize = false] - When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.
 * @param [options.interleave = false] - When <code>true</code>, geometry vertex attributes are interleaved, which can slightly improve rendering performance but increases load time.
 * @param [options.compressVertices = true] - When <code>true</code>, the geometry vertices are compressed, which will save memory.
 * @param [options.releaseGeometryInstances = true] - When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.
 * @param [options.allowPicking = true] - When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.
 * @param [options.cull = true] - When <code>true</code>, the renderer frustum culls and horizon culls the primitive's commands based on their bounding volume.  Set this to <code>false</code> for a small performance gain if you are manually culling the primitive.
 * @param [options.asynchronous = true] - Determines if the primitive will be created asynchronously or block until ready.
 * @param [options.debugShowBoundingVolume = false] - For debugging only. Determines if this primitive's commands' bounding spheres are shown.
 * @param [options.shadows = ShadowMode.DISABLED] - Determines whether this primitive casts or receives shadows from light sources.
 */
export class Primitive {
    constructor(options?: {
        geometryInstances?: GeometryInstance[] | GeometryInstance;
        appearance?: Appearance;
        depthFailAppearance?: Appearance;
        show?: boolean;
        modelMatrix?: Matrix4;
        vertexCacheOptimize?: boolean;
        interleave?: boolean;
        compressVertices?: boolean;
        releaseGeometryInstances?: boolean;
        allowPicking?: boolean;
        cull?: boolean;
        asynchronous?: boolean;
        debugShowBoundingVolume?: boolean;
        shadows?: ShadowMode;
    });
    /**
     * The geometry instances rendered with this primitive.  This may
     * be <code>undefined</code> if <code>options.releaseGeometryInstances</code>
     * is <code>true</code> when the primitive is constructed.
     * <p>
     * Changing this property after the primitive is rendered has no effect.
     * </p>
     */
    readonly geometryInstances: GeometryInstance[] | GeometryInstance;
    /**
     * The {@link Appearance} used to shade this primitive. Each geometry
     * instance is shaded with the same appearance.  Some appearances, like
     * {@link PerInstanceColorAppearance} allow giving each instance unique
     * properties.
     */
    appearance: Appearance;
    /**
     * The {@link Appearance} used to shade this primitive when it fails the depth test. Each geometry
     * instance is shaded with the same appearance.  Some appearances, like
     * {@link PerInstanceColorAppearance} allow giving each instance unique
     * properties.
     *
     * <p>
     * When using an appearance that requires a color attribute, like PerInstanceColorAppearance,
     * add a depthFailColor per-instance attribute instead.
     * </p>
     *
     * <p>
     * Requires the EXT_frag_depth WebGL extension to render properly. If the extension is not supported,
     * there may be artifacts.
     * </p>
     */
    depthFailAppearance: Appearance;
    /**
     * The 4x4 transformation matrix that transforms the primitive (all geometry instances) from model to world coordinates.
     * When this is the identity matrix, the primitive is drawn in world coordinates, i.e., Earth's WGS84 coordinates.
     * Local reference frames can be used by providing a different transformation matrix, like that returned
     * by {@link Transforms.eastNorthUpToFixedFrame}.
     *
     * <p>
     * This property is only supported in 3D mode.
     * </p>
     * @example
     * const origin = Cesium.Cartesian3.fromDegrees(-95.0, 40.0, 200000.0);
     * p.modelMatrix = Cesium.Transforms.eastNorthUpToFixedFrame(origin);
     */
    modelMatrix: Matrix4;
    /**
     * Determines if the primitive will be shown.  This affects all geometry
     * instances in the primitive.
     */
    show: boolean;
    /**
     * When <code>true</code>, the renderer frustum culls and horizon culls the primitive's commands
     * based on their bounding volume.  Set this to <code>false</code> for a small performance gain
     * if you are manually culling the primitive.
     */
    cull: boolean;
    /**
     * This property is for debugging only; it is not for production use nor is it optimized.
     * <p>
     * Draws the bounding sphere for each draw command in the primitive.
     * </p>
     */
    debugShowBoundingVolume: boolean;
    /**
     * Determines whether this primitive casts or receives shadows from light sources.
     */
    shadows: ShadowMode;
    /**
     * When <code>true</code>, geometry vertices are optimized for the pre and post-vertex-shader caches.
     */
    readonly vertexCacheOptimize: boolean;
    /**
     * Determines if geometry vertex attributes are interleaved, which can slightly improve rendering performance.
     */
    readonly interleave: boolean;
    /**
     * When <code>true</code>, the primitive does not keep a reference to the input <code>geometryInstances</code> to save memory.
     */
    readonly releaseGeometryInstances: boolean;
    /**
     * When <code>true</code>, each geometry instance will only be pickable with {@link Scene#pick}.  When <code>false</code>, GPU memory is saved.         *
     */
    readonly allowPicking: boolean;
    /**
     * Determines if the geometry instances will be created and batched on a web worker.
     */
    readonly asynchronous: boolean;
    /**
     * When <code>true</code>, geometry vertices are compressed, which will save memory.
     */
    readonly compressVertices: boolean;
    /**
     * Determines if the primitive is complete and ready to render.  If this property is
     * true, the primitive will be rendered the next time that {@link Primitive#update}
     * is called.
     * @example
     * // Wait for a primitive to become ready before accessing attributes
     * const removeListener = scene.postRender.addEventListener(() => {
     *   if (!frustumPrimitive.ready) {
     *     return;
     *   }
     *
     *   const attributes = primitive.getGeometryInstanceAttributes('an id');
     *   attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);
     *
     *   removeListener();
     * });
     */
    readonly ready: boolean;
    /**
     * Called when {@link Viewer} or {@link CesiumWidget} render the scene to
     * get the draw commands needed to render this primitive.
     * <p>
     * Do not call this function directly.  This is documented just to
     * list the exceptions that may be propagated when the scene is rendered:
     * </p>
     */
    update(): void;
    /**
     * Returns the modifiable per-instance attributes for a {@link GeometryInstance}.
     * @example
     * const attributes = primitive.getGeometryInstanceAttributes('an id');
     * attributes.color = Cesium.ColorGeometryInstanceAttribute.toValue(Cesium.Color.AQUA);
     * attributes.show = Cesium.ShowGeometryInstanceAttribute.toValue(true);
     * attributes.distanceDisplayCondition = Cesium.DistanceDisplayConditionGeometryInstanceAttribute.toValue(100.0, 10000.0);
     * attributes.offset = Cesium.OffsetGeometryInstanceAttribute.toValue(Cartesian3.IDENTITY);
     * @param id - The id of the {@link GeometryInstance}.
     * @returns The typed array in the attribute's format or undefined if the is no instance with id.
     */
    getGeometryInstanceAttributes(id: any): any;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <p>
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * </p>
     * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <p>
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     * </p>
     * @example
     * e = e && e.destroy();
     */
    destroy(): void;
}

/**
 * A collection of primitives.  This is most often used with {@link Scene#primitives},
 * but <code>PrimitiveCollection</code> is also a primitive itself so collections can
 * be added to collections forming a hierarchy.
 * @example
 * const billboards = new Cesium.BillboardCollection();
 * const labels = new Cesium.LabelCollection();
 *
 * const collection = new Cesium.PrimitiveCollection();
 * collection.add(billboards);
 *
 * scene.primitives.add(collection);  // Add collection
 * scene.primitives.add(labels);      // Add regular primitive
 * @param [options] - Object with the following properties:
 * @param [options.show = true] - Determines if the primitives in the collection will be shown.
 * @param [options.destroyPrimitives = true] - Determines if primitives in the collection are destroyed when they are removed.
 */
export class PrimitiveCollection {
    constructor(options?: {
        show?: boolean;
        destroyPrimitives?: boolean;
    });
    /**
     * Determines if primitives in this collection will be shown.
     */
    show: boolean;
    /**
     * Determines if primitives in the collection are destroyed when they are removed by
     * {@link PrimitiveCollection#destroy} or  {@link PrimitiveCollection#remove} or implicitly
     * by {@link PrimitiveCollection#removeAll}.
     * @example
     * // Example 1. Primitives are destroyed by default.
     * const primitives = new Cesium.PrimitiveCollection();
     * const labels = primitives.add(new Cesium.LabelCollection());
     * primitives = primitives.destroy();
     * const b = labels.isDestroyed(); // true
     * @example
     * // Example 2. Do not destroy primitives in a collection.
     * const primitives = new Cesium.PrimitiveCollection();
     * primitives.destroyPrimitives = false;
     * const labels = primitives.add(new Cesium.LabelCollection());
     * primitives = primitives.destroy();
     * const b = labels.isDestroyed(); // false
     * labels = labels.destroy();    // explicitly destroy
     */
    destroyPrimitives: boolean;
    /**
     * Gets the number of primitives in the collection.
     */
    readonly length: number;
    /**
     * An event that is raised when a primitive is added to the collection.
     * Event handlers are passed the primitive that was added.
     */
    readonly primitiveAdded: Event;
    /**
     * An event that is raised when a primitive is removed from the collection.
     * Event handlers are passed the primitive that was removed.
     * <p>
     * Note: Depending on the destroyPrimitives constructor option, the primitive may already be destroyed.
     * </p>
     */
    readonly primitiveRemoved: Event;
    /**
     * Adds a primitive to the collection.
     * @example
     * const billboards = scene.primitives.add(new Cesium.BillboardCollection());
     * @param primitive - The primitive to add.
     * @param [index] - The index to add the layer at.  If omitted, the primitive will be added at the bottom of all existing primitives.
     * @returns The primitive added to the collection.
     */
    add(primitive: any, index?: number): any;
    /**
     * Removes a primitive from the collection.
     * @example
     * const billboards = scene.primitives.add(new Cesium.BillboardCollection());
     * scene.primitives.remove(billboards);  // Returns true
     * @param [primitive] - The primitive to remove.
     * @returns <code>true</code> if the primitive was removed; <code>false</code> if the primitive is <code>undefined</code> or was not found in the collection.
     */
    remove(primitive?: any): boolean;
    /**
     * Removes all primitives in the collection.
     */
    removeAll(): void;
    /**
     * Determines if this collection contains a primitive.
     * @param [primitive] - The primitive to check for.
     * @returns <code>true</code> if the primitive is in the collection; <code>false</code> if the primitive is <code>undefined</code> or was not found in the collection.
     */
    contains(primitive?: any): boolean;
    /**
     * Raises a primitive "up one" in the collection.  If all primitives in the collection are drawn
     * on the globe surface, this visually moves the primitive up one.
     * @param [primitive] - The primitive to raise.
     */
    raise(primitive?: any): void;
    /**
     * Raises a primitive to the "top" of the collection.  If all primitives in the collection are drawn
     * on the globe surface, this visually moves the primitive to the top.
     * @param [primitive] - The primitive to raise the top.
     */
    raiseToTop(primitive?: any): void;
    /**
     * Lowers a primitive "down one" in the collection.  If all primitives in the collection are drawn
     * on the globe surface, this visually moves the primitive down one.
     * @param [primitive] - The primitive to lower.
     */
    lower(primitive?: any): void;
    /**
     * Lowers a primitive to the "bottom" of the collection.  If all primitives in the collection are drawn
     * on the globe surface, this visually moves the primitive to the bottom.
     * @param [primitive] - The primitive to lower to the bottom.
     */
    lowerToBottom(primitive?: any): void;
    /**
     * Returns the primitive in the collection at the specified index.
     * @example
     * // Toggle the show property of every primitive in the collection.
     * const primitives = scene.primitives;
     * const length = primitives.length;
     * for (let i = 0; i < length; ++i) {
     *   const p = primitives.get(i);
     *   p.show = !p.show;
     * }
     * @param index - The zero-based index of the primitive to return.
     * @returns The primitive at the <code>index</code>.
     */
    get(index: number): any;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * @returns True if this object was destroyed; otherwise, false.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the WebGL resources held by each primitive in this collection.  Explicitly destroying this
     * collection allows for deterministic release of WebGL resources, instead of relying on the garbage
     * collector to destroy this collection.
     * <br /><br />
     * Since destroying a collection destroys all the contained primitives, only destroy a collection
     * when you are sure no other code is still using any of the contained primitives.
     * <br /><br />
     * Once this collection is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     * @example
     * primitives = primitives && primitives.destroy();
     */
    destroy(): void;
}

/**
 * The container for all 3D graphical objects and state in a Cesium virtual scene.  Generally,
 * a scene is not created directly; instead, it is implicitly created by {@link CesiumWidget}.
 * @example
 * // Create scene without anisotropic texture filtering
 * const scene = new Cesium.Scene({
 *   canvas : canvas,
 *   contextOptions : {
 *     allowTextureFilterAnisotropic : false
 *   }
 * });
 * @param options - Object with the following properties:
 * @param options.canvas - The HTML canvas element to create the scene for.
 * @param [options.contextOptions] - Context and WebGL creation properties.
 * @param [options.creditContainer] - The HTML element in which the credits will be displayed.
 * @param [options.creditViewport] - The HTML element in which to display the credit popup.  If not specified, the viewport will be a added as a sibling of the canvas.
 * @param [options.mapProjection = new GeographicProjection()] - The map projection to use in 2D and Columbus View modes.
 * @param [options.orderIndependentTranslucency = true] - If true and the configuration supports it, use order independent translucency.
 * @param [options.scene3DOnly = false] - If true, optimizes memory use and performance for 3D mode but disables the ability to use 2D or Columbus View.
 * @param [options.shadows = false] - Determines if shadows are cast by light sources.
 * @param [options.mapMode2D = MapMode2D.INFINITE_SCROLL] - Determines if the 2D map is rotatable or can be scrolled infinitely in the horizontal direction.
 * @param [options.requestRenderMode = false] - If true, rendering a frame will only occur when needed as determined by changes within the scene. Enabling improves performance of the application, but requires using {@link Scene#requestRender} to render a new frame explicitly in this mode. This will be necessary in many cases after making changes to the scene in other parts of the API. See {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}.
 * @param [options.maximumRenderTimeChange = 0.0] - If requestRenderMode is true, this value defines the maximum change in simulation time allowed before a render is requested. See {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}.
 * @param [options.depthPlaneEllipsoidOffset = 0.0] - Adjust the DepthPlane to address rendering artefacts below ellipsoid zero elevation.
 * @param [options.msaaSamples = 1] - If provided, this value controls the rate of multisample antialiasing. Typical multisampling rates are 2, 4, and sometimes 8 samples per pixel. Higher sampling rates of MSAA may impact performance in exchange for improved visual quality. This value only applies to WebGL2 contexts that support multisample render targets.
 */
export class Scene {
    constructor(options: {
        canvas: HTMLCanvasElement;
        contextOptions?: ContextOptions;
        creditContainer?: Element;
        creditViewport?: Element;
        mapProjection?: MapProjection;
        orderIndependentTranslucency?: boolean;
        scene3DOnly?: boolean;
        shadows?: boolean;
        mapMode2D?: MapMode2D;
        requestRenderMode?: boolean;
        maximumRenderTimeChange?: number;
        depthPlaneEllipsoidOffset?: number;
        msaaSamples?: number;
    });
    /**
     * Exceptions occurring in <code>render</code> are always caught in order to raise the
     * <code>renderError</code> event.  If this property is true, the error is rethrown
     * after the event is raised.  If this property is false, the <code>render</code> function
     * returns normally after raising the event.
     */
    rethrowRenderErrors: boolean;
    /**
     * Determines whether or not to instantly complete the
     * scene transition animation on user input.
     */
    completeMorphOnUserInput: boolean;
    /**
     * The event fired at the beginning of a scene transition.
     */
    morphStart: Event;
    /**
     * The event fired at the completion of a scene transition.
     */
    morphComplete: Event;
    /**
     * The {@link SkyBox} used to draw the stars.
     */
    skyBox: SkyBox;
    /**
     * The sky atmosphere drawn around the globe.
     */
    skyAtmosphere: SkyAtmosphere;
    /**
     * The {@link Sun}.
     */
    sun: Sun;
    /**
     * Uses a bloom filter on the sun when enabled.
     */
    sunBloom: boolean;
    /**
     * The {@link Moon}
     */
    moon: Moon;
    /**
     * The background color, which is only visible if there is no sky box, i.e., {@link Scene#skyBox} is undefined.
     */
    backgroundColor: Color;
    /**
     * The current morph transition time between 2D/Columbus View and 3D,
     * with 0.0 being 2D or Columbus View and 1.0 being 3D.
     */
    morphTime: number;
    /**
     * The far-to-near ratio of the multi-frustum when using a normal depth buffer.
     * <p>
     * This value is used to create the near and far values for each frustum of the multi-frustum. It is only used
     * when {@link Scene#logarithmicDepthBuffer} is <code>false</code>. When <code>logarithmicDepthBuffer</code> is
     * <code>true</code>, use {@link Scene#logarithmicDepthFarToNearRatio}.
     * </p>
     */
    farToNearRatio: number;
    /**
     * The far-to-near ratio of the multi-frustum when using a logarithmic depth buffer.
     * <p>
     * This value is used to create the near and far values for each frustum of the multi-frustum. It is only used
     * when {@link Scene#logarithmicDepthBuffer} is <code>true</code>. When <code>logarithmicDepthBuffer</code> is
     * <code>false</code>, use {@link Scene#farToNearRatio}.
     * </p>
     */
    logarithmicDepthFarToNearRatio: number;
    /**
     * Determines the uniform depth size in meters of each frustum of the multifrustum in 2D. If a primitive or model close
     * to the surface shows z-fighting, decreasing this will eliminate the artifact, but decrease performance. On the
     * other hand, increasing this will increase performance but may cause z-fighting among primitives close to the surface.
     */
    nearToFarDistance2D: number;
    /**
     * This property is for debugging only; it is not for production use.
     * <p>
     * A function that determines what commands are executed.  As shown in the examples below,
     * the function receives the command's <code>owner</code> as an argument, and returns a boolean indicating if the
     * command should be executed.
     * </p>
     * <p>
     * The default is <code>undefined</code>, indicating that all commands are executed.
     * </p>
     * @example
     * // Do not execute any commands.
     * scene.debugCommandFilter = function(command) {
     *     return false;
     * };
     *
     * // Execute only the billboard's commands.  That is, only draw the billboard.
     * const billboards = new Cesium.BillboardCollection();
     * scene.debugCommandFilter = function(command) {
     *     return command.owner === billboards;
     * };
     */
    debugCommandFilter: (...params: any[]) => any;
    /**
     * This property is for debugging only; it is not for production use.
     * <p>
     * When <code>true</code>, commands are randomly shaded.  This is useful
     * for performance analysis to see what parts of a scene or model are
     * command-dense and could benefit from batching.
     * </p>
     */
    debugShowCommands: boolean;
    /**
     * This property is for debugging only; it is not for production use.
     * <p>
     * When <code>true</code>, commands are shaded based on the frustums they
     * overlap.  Commands in the closest frustum are tinted red, commands in
     * the next closest are green, and commands in the farthest frustum are
     * blue.  If a command overlaps more than one frustum, the color components
     * are combined, e.g., a command overlapping the first two frustums is tinted
     * yellow.
     * </p>
     */
    debugShowFrustums: boolean;
    /**
     * This property is for debugging only; it is not for production use.
     * <p>
     * Displays frames per second and time between frames.
     * </p>
     */
    debugShowFramesPerSecond: boolean;
    /**
     * This property is for debugging only; it is not for production use.
     * <p>
     * Indicates which frustum will have depth information displayed.
     * </p>
     */
    debugShowDepthFrustum: number;
    /**
     * This property is for debugging only; it is not for production use.
     * <p>
     * When <code>true</code>, draws outlines to show the boundaries of the camera frustums
     * </p>
     */
    debugShowFrustumPlanes: boolean;
    /**
     * When <code>true</code>, enables picking using the depth buffer.
     */
    useDepthPicking: boolean;
    /**
     * When <code>true</code>, enables picking translucent geometry using the depth buffer. Note that {@link Scene#useDepthPicking} must also be true for enabling this to work.
     *
     * <p>
     * There is a decrease in performance when enabled. There are extra draw calls to write depth for
     * translucent geometry.
     * </p>
     * @example
     * // picking the position of a translucent primitive
     * viewer.screenSpaceEventHandler.setInputAction(function onLeftClick(movement) {
     *      const pickedFeature = viewer.scene.pick(movement.position);
     *      if (!Cesium.defined(pickedFeature)) {
     *          // nothing picked
     *          return;
     *      }
     *      const worldPosition = viewer.scene.pickPosition(movement.position);
     * }, Cesium.ScreenSpaceEventType.LEFT_CLICK);
     */
    pickTranslucentDepth: boolean;
    /**
     * Blends the atmosphere to geometry far from the camera for horizon views. Allows for additional
     * performance improvements by rendering less geometry and dispatching less terrain requests.
     */
    fog: Fog;
    /**
     * The shadow map for the scene's light source. When enabled, models, primitives, and the globe may cast and receive shadows.
     */
    shadowMap: ShadowMap;
    /**
     * When <code>false</code>, 3D Tiles will render normally. When <code>true</code>, classified 3D Tile geometry will render normally and
     * unclassified 3D Tile geometry will render with the color multiplied by {@link Scene#invertClassificationColor}.
     */
    invertClassification: boolean;
    /**
     * The highlight color of unclassified 3D Tile geometry when {@link Scene#invertClassification} is <code>true</code>.
     * <p>When the color's alpha is less than 1.0, the unclassified portions of the 3D Tiles will not blend correctly with the classified positions of the 3D Tiles.</p>
     * <p>Also, when the color's alpha is less than 1.0, the WEBGL_depth_texture and EXT_frag_depth WebGL extensions must be supported.</p>
     */
    invertClassificationColor: Color;
    /**
     * The focal length for use when with cardboard or WebVR.
     */
    focalLength: number;
    /**
     * The eye separation distance in meters for use with cardboard or WebVR.
     */
    eyeSeparation: number;
    /**
     * Post processing effects applied to the final render.
     */
    postProcessStages: PostProcessStageCollection;
    /**
     * When <code>true</code>, rendering a frame will only occur when needed as determined by changes within the scene.
     * Enabling improves performance of the application, but requires using {@link Scene#requestRender}
     * to render a new frame explicitly in this mode. This will be necessary in many cases after making changes
     * to the scene in other parts of the API.
     */
    requestRenderMode: boolean;
    /**
     * If {@link Scene#requestRenderMode} is <code>true</code>, this value defines the maximum change in
     * simulation time allowed before a render is requested. Lower values increase the number of frames rendered
     * and higher values decrease the number of frames rendered. If <code>undefined</code>, changes to
     * the simulation time will never request a render.
     * This value impacts the rate of rendering for changes in the scene like lighting, entity property updates,
     * and animations.
     */
    maximumRenderTimeChange: number;
    /**
     * The spherical harmonic coefficients for image-based lighting of PBR models.
     */
    sphericalHarmonicCoefficients: Cartesian3[];
    /**
     * The url to the KTX2 file containing the specular environment map and convoluted mipmaps for image-based lighting of PBR models.
     */
    specularEnvironmentMaps: string;
    /**
     * The light source for shading. Defaults to a directional light from the Sun.
     */
    light: Light;
    /**
     * Gets the canvas element to which this scene is bound.
     */
    readonly canvas: HTMLCanvasElement;
    /**
     * The drawingBufferHeight of the underlying GL context.
     */
    readonly drawingBufferHeight: number;
    /**
     * The drawingBufferWidth of the underlying GL context.
     */
    readonly drawingBufferWidth: number;
    /**
     * The maximum aliased line width, in pixels, supported by this WebGL implementation.  It will be at least one.
     */
    readonly maximumAliasedLineWidth: number;
    /**
     * The maximum length in pixels of one edge of a cube map, supported by this WebGL implementation.  It will be at least 16.
     */
    readonly maximumCubeMapSize: number;
    /**
     * Returns <code>true</code> if the {@link Scene#pickPosition} function is supported.
     */
    readonly pickPositionSupported: boolean;
    /**
     * Returns <code>true</code> if the {@link Scene#sampleHeight} and {@link Scene#sampleHeightMostDetailed} functions are supported.
     */
    readonly sampleHeightSupported: boolean;
    /**
     * Returns <code>true</code> if the {@link Scene#clampToHeight} and {@link Scene#clampToHeightMostDetailed} functions are supported.
     */
    readonly clampToHeightSupported: boolean;
    /**
     * Returns <code>true</code> if the {@link Scene#invertClassification} is supported.
     */
    readonly invertClassificationSupported: boolean;
    /**
     * Returns <code>true</code> if specular environment maps are supported.
     */
    readonly specularEnvironmentMapsSupported: boolean;
    /**
     * Gets or sets the depth-test ellipsoid.
     */
    globe: Globe;
    /**
     * Gets the collection of primitives.
     */
    readonly primitives: PrimitiveCollection;
    /**
     * Gets the collection of ground primitives.
     */
    readonly groundPrimitives: PrimitiveCollection;
    /**
     * Gets or sets the camera.
     */
    readonly camera: Camera;
    /**
     * Gets the controller for camera input handling.
     */
    readonly screenSpaceCameraController: ScreenSpaceCameraController;
    /**
     * Get the map projection to use in 2D and Columbus View modes.
     */
    readonly mapProjection: MapProjection;
    /**
     * Gets the collection of image layers that will be rendered on the globe.
     */
    readonly imageryLayers: ImageryLayerCollection;
    /**
     * The terrain provider providing surface geometry for the globe.
     */
    terrainProvider: TerrainProvider;
    /**
     * Gets an event that's raised when the terrain provider is changed
     */
    readonly terrainProviderChanged: Event;
    /**
     * Gets the event that will be raised before the scene is updated or rendered.  Subscribers to the event
     * receive the Scene instance as the first parameter and the current time as the second parameter.
     */
    readonly preUpdate: Event;
    /**
     * Gets the event that will be raised immediately after the scene is updated and before the scene is rendered.
     * Subscribers to the event receive the Scene instance as the first parameter and the current time as the second
     * parameter.
     */
    readonly postUpdate: Event;
    /**
     * Gets the event that will be raised when an error is thrown inside the <code>render</code> function.
     * The Scene instance and the thrown error are the only two parameters passed to the event handler.
     * By default, errors are not rethrown after this event is raised, but that can be changed by setting
     * the <code>rethrowRenderErrors</code> property.
     */
    readonly renderError: Event;
    /**
     * Gets the event that will be raised after the scene is updated and immediately before the scene is rendered.
     * Subscribers to the event receive the Scene instance as the first parameter and the current time as the second
     * parameter.
     */
    readonly preRender: Event;
    /**
     * Gets the event that will be raised immediately after the scene is rendered.  Subscribers to the event
     * receive the Scene instance as the first parameter and the current time as the second parameter.
     */
    readonly postRender: Event;
    /**
     * Gets the simulation time when the scene was last rendered. Returns undefined if the scene has not yet been
     * rendered.
     */
    readonly lastRenderTime: JulianDate;
    /**
     * This property is for debugging only; it is not for production use.
     * <p>
     * When {@link Scene.debugShowFrustums} is <code>true</code>, this contains
     * properties with statistics about the number of command execute per frustum.
     * <code>totalCommands</code> is the total number of commands executed, ignoring
     * overlap. <code>commandsInFrustums</code> is an array with the number of times
     * commands are executed redundantly, e.g., how many commands overlap two or
     * three frustums.
     * </p>
     */
    readonly debugFrustumStatistics: any;
    /**
     * Gets whether or not the scene is optimized for 3D only viewing.
     */
    readonly scene3DOnly: boolean;
    /**
     * Gets whether or not the scene has order independent translucency enabled.
     * Note that this only reflects the original construction option, and there are
     * other factors that could prevent OIT from functioning on a given system configuration.
     */
    readonly orderIndependentTranslucency: boolean;
    /**
     * Gets the unique identifier for this scene.
     */
    readonly id: string;
    /**
     * Gets or sets the current mode of the scene.
     */
    mode: SceneMode;
    /**
     * When <code>true</code>, splits the scene into two viewports with steroscopic views for the left and right eyes.
     * Used for cardboard and WebVR.
     */
    useWebVR: boolean;
    /**
     * Determines if the 2D map is rotatable or can be scrolled infinitely in the horizontal direction.
     */
    readonly mapMode2D: MapMode2D;
    /**
     * Gets or sets the position of the splitter within the viewport.  Valid values are between 0.0 and 1.0.
     */
    splitPosition: number;
    /**
     * The distance from the camera at which to disable the depth test of billboards, labels and points
     * to, for example, prevent clipping against terrain. When set to zero, the depth test should always
     * be applied. When less than zero, the depth test should never be applied. Setting the disableDepthTestDistance
     * property of a billboard, label or point will override this value.
     */
    minimumDisableDepthTestDistance: number;
    /**
     * Whether or not to use a logarithmic depth buffer. Enabling this option will allow for less frustums in the multi-frustum,
     * increasing performance. This property relies on fragmentDepth being supported.
     */
    logarithmicDepthBuffer: boolean;
    /**
     * The value used for gamma correction. This is only used when rendering with high dynamic range.
     */
    gamma: number;
    /**
     * Whether or not to use high dynamic range rendering.
     */
    highDynamicRange: boolean;
    /**
     * Whether or not high dynamic range rendering is supported.
     */
    readonly highDynamicRangeSupported: boolean;
    /**
     * Whether or not the camera is underneath the globe.
     */
    readonly cameraUnderground: boolean;
    /**
     * The sample rate of multisample antialiasing (values greater than 1 enable MSAA).
     */
    msaaSamples: number;
    /**
     * Returns <code>true</code> if the Scene's context supports MSAA.
     */
    readonly msaaSupported: boolean;
    /**
     * Determines if a compressed texture format is supported.
     * @param format - The texture format. May be the name of the format or the WebGL extension name, e.g. s3tc or WEBGL_compressed_texture_s3tc.
     * @returns Whether or not the format is supported.
     */
    getCompressedTextureFormatSupported(format: string): boolean;
    /**
     * Update and render the scene. It is usually not necessary to call this function
     * directly because {@link CesiumWidget} will do it automatically.
     * @param [time] - The simulation time at which to render.
     */
    render(time?: JulianDate): void;
    /**
     * Requests a new rendered frame when {@link Scene#requestRenderMode} is set to <code>true</code>.
     * The render rate will not exceed the {@link CesiumWidget#targetFrameRate}.
     */
    requestRender(): void;
    /**
     * Returns an object with a `primitive` property that contains the first (top) primitive in the scene
     * at a particular window coordinate or undefined if nothing is at the location. Other properties may
     * potentially be set depending on the type of primitive and may be used to further identify the picked object.
     * <p>
     * When a feature of a 3D Tiles tileset is picked, <code>pick</code> returns a {@link Cesium3DTileFeature} object.
     * </p>
     * @example
     * // On mouse over, color the feature yellow.
     * handler.setInputAction(function(movement) {
     *     const feature = scene.pick(movement.endPosition);
     *     if (feature instanceof Cesium.Cesium3DTileFeature) {
     *         feature.color = Cesium.Color.YELLOW;
     *     }
     * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
     * @param windowPosition - Window coordinates to perform picking on.
     * @param [width = 3] - Width of the pick rectangle.
     * @param [height = 3] - Height of the pick rectangle.
     * @returns Object containing the picked primitive.
     */
    pick(windowPosition: Cartesian2, width?: number, height?: number): any;
    /**
     * Returns the cartesian position reconstructed from the depth buffer and window position.
     * <p>
     * The position reconstructed from the depth buffer in 2D may be slightly different from those
     * reconstructed in 3D and Columbus view. This is caused by the difference in the distribution
     * of depth values of perspective and orthographic projection.
     * </p>
     * <p>
     * Set {@link Scene#pickTranslucentDepth} to <code>true</code> to include the depth of
     * translucent primitives; otherwise, this essentially picks through translucent primitives.
     * </p>
     * @param windowPosition - Window coordinates to perform picking on.
     * @param [result] - The object on which to restore the result.
     * @returns The cartesian position.
     */
    pickPosition(windowPosition: Cartesian2, result?: Cartesian3): Cartesian3;
    /**
     * Returns a list of objects, each containing a `primitive` property, for all primitives at
     * a particular window coordinate position. Other properties may also be set depending on the
     * type of primitive and may be used to further identify the picked object. The primitives in
     * the list are ordered by their visual order in the scene (front to back).
     * @example
     * const pickedObjects = scene.drillPick(new Cesium.Cartesian2(100.0, 200.0));
     * @param windowPosition - Window coordinates to perform picking on.
     * @param [limit] - If supplied, stop drilling after collecting this many picks.
     * @param [width = 3] - Width of the pick rectangle.
     * @param [height = 3] - Height of the pick rectangle.
     * @returns Array of objects, each containing 1 picked primitives.
     */
    drillPick(windowPosition: Cartesian2, limit?: number, width?: number, height?: number): any[];
    /**
     * Returns the height of scene geometry at the given cartographic position or <code>undefined</code> if there was no
     * scene geometry to sample height from. The height of the input position is ignored. May be used to clamp objects to
     * the globe, 3D Tiles, or primitives in the scene.
     * <p>
     * This function only samples height from globe tiles and 3D Tiles that are rendered in the current view. Samples height
     * from all other primitives regardless of their visibility.
     * </p>
     * @example
     * const position = new Cesium.Cartographic(-1.31968, 0.698874);
     * const height = viewer.scene.sampleHeight(position);
     * console.log(height);
     * @param position - The cartographic position to sample height from.
     * @param [objectsToExclude] - A list of primitives, entities, or 3D Tiles features to not sample height from.
     * @param [width = 0.1] - Width of the intersection volume in meters.
     * @returns The height. This may be <code>undefined</code> if there was no scene geometry to sample height from.
     */
    sampleHeight(position: Cartographic, objectsToExclude?: object[], width?: number): number;
    /**
     * Clamps the given cartesian position to the scene geometry along the geodetic surface normal. Returns the
     * clamped position or <code>undefined</code> if there was no scene geometry to clamp to. May be used to clamp
     * objects to the globe, 3D Tiles, or primitives in the scene.
     * <p>
     * This function only clamps to globe tiles and 3D Tiles that are rendered in the current view. Clamps to
     * all other primitives regardless of their visibility.
     * </p>
     * @example
     * // Clamp an entity to the underlying scene geometry
     * const position = entity.position.getValue(Cesium.JulianDate.now());
     * entity.position = viewer.scene.clampToHeight(position);
     * @param cartesian - The cartesian position.
     * @param [objectsToExclude] - A list of primitives, entities, or 3D Tiles features to not clamp to.
     * @param [width = 0.1] - Width of the intersection volume in meters.
     * @param [result] - An optional object to return the clamped position.
     * @returns The modified result parameter or a new Cartesian3 instance if one was not provided. This may be <code>undefined</code> if there was no scene geometry to clamp to.
     */
    clampToHeight(cartesian: Cartesian3, objectsToExclude?: object[], width?: number, result?: Cartesian3): Cartesian3;
    /**
     * Initiates an asynchronous {@link Scene#sampleHeight} query for an array of {@link Cartographic} positions
     * using the maximum level of detail for 3D Tilesets in the scene. The height of the input positions is ignored.
     * Returns a promise that is resolved when the query completes. Each point height is modified in place.
     * If a height cannot be determined because no geometry can be sampled at that location, or another error occurs,
     * the height is set to undefined.
     * @example
     * const positions = [
     *     new Cesium.Cartographic(-1.31968, 0.69887),
     *     new Cesium.Cartographic(-1.10489, 0.83923)
     * ];
     * const promise = viewer.scene.sampleHeightMostDetailed(positions);
     * promise.then(function(updatedPosition) {
     *     // positions[0].height and positions[1].height have been updated.
     *     // updatedPositions is just a reference to positions.
     * }
     * @param positions - The cartographic positions to update with sampled heights.
     * @param [objectsToExclude] - A list of primitives, entities, or 3D Tiles features to not sample height from.
     * @param [width = 0.1] - Width of the intersection volume in meters.
     * @returns A promise that resolves to the provided list of positions when the query has completed.
     */
    sampleHeightMostDetailed(positions: Cartographic[], objectsToExclude?: object[], width?: number): Promise<Cartographic[]>;
    /**
     * Initiates an asynchronous {@link Scene#clampToHeight} query for an array of {@link Cartesian3} positions
     * using the maximum level of detail for 3D Tilesets in the scene. Returns a promise that is resolved when
     * the query completes. Each position is modified in place. If a position cannot be clamped because no geometry
     * can be sampled at that location, or another error occurs, the element in the array is set to undefined.
     * @example
     * const cartesians = [
     *     entities[0].position.getValue(Cesium.JulianDate.now()),
     *     entities[1].position.getValue(Cesium.JulianDate.now())
     * ];
     * const promise = viewer.scene.clampToHeightMostDetailed(cartesians);
     * promise.then(function(updatedCartesians) {
     *     entities[0].position = updatedCartesians[0];
     *     entities[1].position = updatedCartesians[1];
     * }
     * @param cartesians - The cartesian positions to update with clamped positions.
     * @param [objectsToExclude] - A list of primitives, entities, or 3D Tiles features to not clamp to.
     * @param [width = 0.1] - Width of the intersection volume in meters.
     * @returns A promise that resolves to the provided list of positions when the query has completed.
     */
    clampToHeightMostDetailed(cartesians: Cartesian3[], objectsToExclude?: object[], width?: number): Promise<Cartesian3[]>;
    /**
     * Transforms a position in cartesian coordinates to canvas coordinates.  This is commonly used to place an
     * HTML element at the same screen position as an object in the scene.
     * @example
     * // Output the canvas position of longitude/latitude (0, 0) every time the mouse moves.
     * const scene = widget.scene;
     * const ellipsoid = scene.globe.ellipsoid;
     * const position = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
     * const handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);
     * handler.setInputAction(function(movement) {
     *     console.log(scene.cartesianToCanvasCoordinates(position));
     * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
     * @param position - The position in cartesian coordinates.
     * @param [result] - An optional object to return the input position transformed to canvas coordinates.
     * @returns The modified result parameter or a new Cartesian2 instance if one was not provided.  This may be <code>undefined</code> if the input position is near the center of the ellipsoid.
     */
    cartesianToCanvasCoordinates(position: Cartesian3, result?: Cartesian2): Cartesian2;
    /**
     * Instantly completes an active transition.
     */
    completeMorph(): void;
    /**
     * Asynchronously transitions the scene to 2D.
     * @param [duration = 2.0] - The amount of time, in seconds, for transition animations to complete.
     */
    morphTo2D(duration?: number): void;
    /**
     * Asynchronously transitions the scene to Columbus View.
     * @param [duration = 2.0] - The amount of time, in seconds, for transition animations to complete.
     */
    morphToColumbusView(duration?: number): void;
    /**
     * Asynchronously transitions the scene to 3D.
     * @param [duration = 2.0] - The amount of time, in seconds, for transition animations to complete.
     */
    morphTo3D(duration?: number): void;
    /**
     * Update the terrain providing surface geometry for the globe.
     * @example
     * // Use Cesium World Terrain
     * scene.setTerrain(Cesium.Terrain.fromWorldTerrain());
     * @example
     * // Use a custom terrain provider
     * const terrain = new Cesium.Terrain(Cesium.CesiumTerrainProvider.fromUrl("https://myTestTerrain.com"));
     * scene.setTerrain(terrain);
     *
     * terrain.errorEvent.addEventListener(error => {
     *   alert(`Encountered an error while creating terrain! ${error}`);
     * });
     * @param terrain - The terrain provider async helper
     * @returns terrain The terrain provider async helper
     */
    setTerrain(terrain: Terrain): Terrain;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     * @example
     * scene = scene && scene.destroy();
     */
    destroy(): void;
}

/**
 * Indicates if the scene is viewed in 3D, 2D, or 2.5D Columbus view.
 */
export enum SceneMode {
    /**
     * Morphing between mode, e.g., 3D to 2D.
     */
    MORPHING = 0,
    /**
     * Columbus View mode.  A 2.5D perspective view where the map is laid out
     * flat and objects with non-zero height are drawn above it.
     */
    COLUMBUS_VIEW = 1,
    /**
     * 2D mode.  The map is viewed top-down with an orthographic projection.
     */
    SCENE2D = 2,
    /**
     * 3D mode.  A traditional 3D perspective view of the globe.
     */
    SCENE3D = 3
}

/**
 * Functions that do scene-dependent transforms between rendering-related coordinate systems.
 */
export namespace SceneTransforms {
    /**
     * Transforms a position in WGS84 coordinates to window coordinates.  This is commonly used to place an
     * HTML element at the same screen position as an object in the scene.
     * @example
     * // Output the window position of longitude/latitude (0, 0) every time the mouse moves.
     * const scene = widget.scene;
     * const ellipsoid = scene.globe.ellipsoid;
     * const position = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
     * const handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);
     * handler.setInputAction(function(movement) {
     *     console.log(Cesium.SceneTransforms.wgs84ToWindowCoordinates(scene, position));
     * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
     * @param scene - The scene.
     * @param position - The position in WGS84 (world) coordinates.
     * @param [result] - An optional object to return the input position transformed to window coordinates.
     * @returns The modified result parameter or a new Cartesian2 instance if one was not provided.  This may be <code>undefined</code> if the input position is near the center of the ellipsoid.
     */
    function wgs84ToWindowCoordinates(scene: Scene, position: Cartesian3, result?: Cartesian2): Cartesian2;
    /**
     * Transforms a position in WGS84 coordinates to drawing buffer coordinates.  This may produce different
     * results from SceneTransforms.wgs84ToWindowCoordinates when the browser zoom is not 100%, or on high-DPI displays.
     * @example
     * // Output the window position of longitude/latitude (0, 0) every time the mouse moves.
     * const scene = widget.scene;
     * const ellipsoid = scene.globe.ellipsoid;
     * const position = Cesium.Cartesian3.fromDegrees(0.0, 0.0);
     * const handler = new Cesium.ScreenSpaceEventHandler(scene.canvas);
     * handler.setInputAction(function(movement) {
     *     console.log(Cesium.SceneTransforms.wgs84ToWindowCoordinates(scene, position));
     * }, Cesium.ScreenSpaceEventType.MOUSE_MOVE);
     * @param scene - The scene.
     * @param position - The position in WGS84 (world) coordinates.
     * @param [result] - An optional object to return the input position transformed to window coordinates.
     * @returns The modified result parameter or a new Cartesian2 instance if one was not provided.  This may be <code>undefined</code> if the input position is near the center of the ellipsoid.
     */
    function wgs84ToDrawingBufferCoordinates(scene: Scene, position: Cartesian3, result?: Cartesian2): Cartesian2;
}

/**
 * Modifies the camera position and orientation based on mouse input to a canvas.
 * @param scene - The scene.
 */
export class ScreenSpaceCameraController {
    constructor(scene: Scene);
    /**
     * If true, inputs are allowed conditionally with the flags enableTranslate, enableZoom,
     * enableRotate, enableTilt, and enableLook.  If false, all inputs are disabled.
     *
     * NOTE: This setting is for temporary use cases, such as camera flights and
     * drag-selection of regions (see Picking demo).  It is typically set to false at the
     * start of such events, and set true on completion.  To keep inputs disabled
     * past the end of camera flights, you must use the other booleans (enableTranslate,
     * enableZoom, enableRotate, enableTilt, and enableLook).
     */
    enableInputs: boolean;
    /**
     * If true, allows the user to pan around the map.  If false, the camera stays locked at the current position.
     * This flag only applies in 2D and Columbus view modes.
     */
    enableTranslate: boolean;
    /**
     * If true, allows the user to zoom in and out.  If false, the camera is locked to the current distance from the ellipsoid.
     */
    enableZoom: boolean;
    /**
     * If true, allows the user to rotate the world which translates the user's position.
     * This flag only applies in 2D and 3D.
     */
    enableRotate: boolean;
    /**
     * If true, allows the user to tilt the camera.  If false, the camera is locked to the current heading.
     * This flag only applies in 3D and Columbus view.
     */
    enableTilt: boolean;
    /**
     * If true, allows the user to use free-look. If false, the camera view direction can only be changed through translating
     * or rotating. This flag only applies in 3D and Columbus view modes.
     */
    enableLook: boolean;
    /**
     * A parameter in the range <code>[0, 1)</code> used to determine how long
     * the camera will continue to spin because of inertia.
     * With value of zero, the camera will have no inertia.
     */
    inertiaSpin: number;
    /**
     * A parameter in the range <code>[0, 1)</code> used to determine how long
     * the camera will continue to translate because of inertia.
     * With value of zero, the camera will have no inertia.
     */
    inertiaTranslate: number;
    /**
     * A parameter in the range <code>[0, 1)</code> used to determine how long
     * the camera will continue to zoom because of inertia.
     * With value of zero, the camera will have no inertia.
     */
    inertiaZoom: number;
    /**
     * A parameter in the range <code>[0, 1)</code> used to limit the range
     * of various user inputs to a percentage of the window width/height per animation frame.
     * This helps keep the camera under control in low-frame-rate situations.
     */
    maximumMovementRatio: number;
    /**
     * Sets the duration, in seconds, of the bounce back animations in 2D and Columbus view.
     */
    bounceAnimationTime: number;
    /**
     * The minimum magnitude, in meters, of the camera position when zooming. Defaults to 1.0.
     */
    minimumZoomDistance: number;
    /**
     * The maximum magnitude, in meters, of the camera position when zooming. Defaults to positive infinity.
     */
    maximumZoomDistance: number;
    /**
     * The input that allows the user to pan around the map. This only applies in 2D and Columbus view modes.
     * <p>
     * The type can be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>
     * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},
     * or an array of any of the preceding.
     * </p>
     */
    translateEventTypes: CameraEventType | any[] | undefined;
    /**
     * The input that allows the user to zoom in/out.
     * <p>
     * The type can be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>
     * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},
     * or an array of any of the preceding.
     * </p>
     */
    zoomEventTypes: CameraEventType | any[] | undefined;
    /**
     * The input that allows the user to rotate around the globe or another object. This only applies in 3D and Columbus view modes.
     * <p>
     * The type can be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>
     * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},
     * or an array of any of the preceding.
     * </p>
     */
    rotateEventTypes: CameraEventType | any[] | undefined;
    /**
     * The input that allows the user to tilt in 3D and Columbus view or twist in 2D.
     * <p>
     * The type can be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>
     * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},
     * or an array of any of the preceding.
     * </p>
     */
    tiltEventTypes: CameraEventType | any[] | undefined;
    /**
     * The input that allows the user to change the direction the camera is viewing. This only applies in 3D and Columbus view modes.
     * <p>
     * The type can be a {@link CameraEventType}, <code>undefined</code>, an object with <code>eventType</code>
     * and <code>modifier</code> properties with types <code>CameraEventType</code> and {@link KeyboardEventModifier},
     * or an array of any of the preceding.
     * </p>
     */
    lookEventTypes: CameraEventType | any[] | undefined;
    /**
     * The minimum height the camera must be before picking the terrain or scene content instead of the ellipsoid.
     */
    minimumPickingTerrainHeight: number;
    /**
     * The minimum distance the camera must be before testing for collision with terrain when zoom with inertia.
     */
    minimumPickingTerrainDistanceWithInertia: number;
    /**
     * The minimum height the camera must be before testing for collision with terrain.
     */
    minimumCollisionTerrainHeight: number;
    /**
     * The minimum height the camera must be before switching from rotating a track ball to
     * free look when clicks originate on the sky or in space.
     */
    minimumTrackBallHeight: number;
    /**
     * When disabled, the values of <code>maximumZoomDistance</code> and <code>minimumZoomDistance</code> are ignored.
     */
    enableCollisionDetection: boolean;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     */
    isDestroyed(): boolean;
    /**
     * Removes mouse listeners held by this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     * @example
     * controller = controller && controller.destroy();
     */
    destroy(): void;
}

/**
 * <div class="notice">
 * Use {@link Viewer#shadowMap} to get the scene's shadow map. Do not construct this directly.
 * </div>
 *
 * <p>
 * The normalOffset bias pushes the shadows forward slightly, and may be disabled
 * for applications that require ultra precise shadows.
 * </p>
 */
export class ShadowMap {
    constructor();
    /**
     * Determines the darkness of the shadows.
     */
    darkness: number;
    /**
     * Determines whether shadows start to fade out once the light gets closer to the horizon.
     */
    fadingEnabled: boolean;
    /**
     * Determines the maximum distance of the shadow map. Only applicable for cascaded shadows. Larger distances may result in lower quality shadows.
     */
    maximumDistance: number;
    /**
     * Determines if the shadow map will be shown.
     */
    enabled: boolean;
    /**
     * Determines if a normal bias will be applied to shadows.
     */
    normalOffset: boolean;
    /**
     * Determines if soft shadows are enabled. Uses pcf filtering which requires more texture reads and may hurt performance.
     */
    softShadows: boolean;
    /**
     * The width and height, in pixels, of each shadow map.
     */
    size: number;
}

/**
 * Specifies whether the object casts or receives shadows from light sources when
 * shadows are enabled.
 */
export enum ShadowMode {
    /**
     * The object does not cast or receive shadows.
     */
    DISABLED = 0,
    /**
     * The object casts and receives shadows.
     */
    ENABLED = 1,
    /**
     * The object casts shadows only.
     */
    CAST_ONLY = 2,
    /**
     * The object receives shadows only.
     */
    RECEIVE_ONLY = 3
}

export namespace SingleTileImageryProvider {
    /**
     * Initialization options for the SingleTileImageryProvider constructor
     * url - The url for the tile.
     * [tileWidth] - The width of the tile, in pixels.
     * [tileHeight] - The height of the tile, in pixels.
     * [rectangle = Rectangle.MAX_VALUE] - The rectangle, in radians, covered by the image.
     * [credit] - A credit for the data source, which is displayed on the canvas.
     * [ellipsoid] - The ellipsoid.  If not specified, the WGS84 ellipsoid is used.
     */
    type ConstructorOptions = {
        url: Resource | string;
        tileWidth?: number;
        tileHeight?: number;
        rectangle?: Rectangle;
        credit?: Credit | string;
        ellipsoid?: Ellipsoid;
    };
    /**
     * Initialization options for the SingleTileImageryProvider constructor when using SingleTileImageryProvider.fromUrl
     * [rectangle = Rectangle.MAX_VALUE] - The rectangle, in radians, covered by the image.
     * [credit] - A credit for the data source, which is displayed on the canvas.
     * [ellipsoid] - The ellipsoid.  If not specified, the WGS84 ellipsoid is used.
     */
    type fromUrlOptions = {
        rectangle?: Rectangle;
        credit?: Credit | string;
        ellipsoid?: Ellipsoid;
    };
}

/**
 * Provides a single, top-level imagery tile.  The single image is assumed to be in
 * the Geographic projection (i.e. WGS84 / EPSG:4326),
 * and will be rendered using a {@link GeographicTilingScheme}.
 * @param options - Object describing initialization options
 */
export class SingleTileImageryProvider {
    constructor(options: SingleTileImageryProvider.ConstructorOptions);
    /**
     * Gets the URL of the single, top-level imagery tile.
     */
    readonly url: string;
    /**
     * Gets the proxy used by this provider.
     */
    readonly proxy: Proxy;
    /**
     * Gets the width of each tile, in pixels.
     */
    readonly tileWidth: number;
    /**
     * Gets the height of each tile, in pixels.
     */
    readonly tileHeight: number;
    /**
     * Gets the maximum level-of-detail that can be requested.
     */
    readonly maximumLevel: number | undefined;
    /**
     * Gets the minimum level-of-detail that can be requested.
     */
    readonly minimumLevel: number;
    /**
     * Gets the tiling scheme used by this provider.
     */
    readonly tilingScheme: TilingScheme;
    /**
     * Gets the rectangle, in radians, of the imagery provided by this instance.
     */
    readonly rectangle: Rectangle;
    /**
     * Gets the tile discard policy.  If not undefined, the discard policy is responsible
     * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
     * returns undefined, no tiles are filtered.
     */
    readonly tileDiscardPolicy: TileDiscardPolicy;
    /**
     * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
     * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
     * are passed an instance of {@link TileProviderError}.
     */
    readonly errorEvent: Event;
    /**
     * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
     * the source of the imagery.
     */
    readonly credit: Credit;
    /**
     * Gets a value indicating whether or not the images provided by this imagery provider
     * include an alpha channel.  If this property is false, an alpha channel, if present, will
     * be ignored.  If this property is true, any images without an alpha channel will be treated
     * as if their alpha is 1.0 everywhere.  When this property is false, memory usage
     * and texture upload time are reduced.
     */
    readonly hasAlphaChannel: boolean;
    /**
     * Creates a provider for a single, top-level imagery tile.  The single image is assumed to use a
     * @example
     * const provider = await SingleTileImageryProvider.fromUrl("https://yoururl.com/image.png");
     * @param url - The url for the tile
     * @param [options] - Object describing initialization options.
     * @returns The resolved SingleTileImageryProvider.
     */
    static fromUrl(url: Resource | string, options?: SingleTileImageryProvider.fromUrlOptions): Promise<SingleTileImageryProvider>;
    /**
     * Gets the credits to be displayed when a given tile is displayed.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level;
     * @returns The credits to be displayed when the tile is displayed.
     */
    getTileCredits(x: number, y: number, level: number): Credit[];
    /**
     * Requests the image for a given tile.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level.
     * @param [request] - The request object. Intended for internal use only.
     * @returns The resolved image
     */
    requestImage(x: number, y: number, level: number, request?: Request): Promise<ImageryTypes> | undefined;
    /**
     * Picking features is not currently supported by this imagery provider, so this function simply returns
     * undefined.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level.
     * @param longitude - The longitude at which to pick features.
     * @param latitude - The latitude at which to pick features.
     * @returns Undefined since picking is not supported.
     */
    pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): undefined;
}

/**
 * An atmosphere drawn around the limb of the provided ellipsoid. Based on
 * {@link http://nishitalab.org/user/nis/cdrom/sig93_nis.pdf|Display of The Earth Taking Into Account Atmospheric Scattering}.
 * <p>
 * This is only supported in 3D. Atmosphere is faded out when morphing to 2D or Columbus view.
 * </p>
 * @example
 * scene.skyAtmosphere = new Cesium.SkyAtmosphere();
 * @param [ellipsoid = Ellipsoid.WGS84] - The ellipsoid that the atmosphere is drawn around.
 */
export class SkyAtmosphere {
    constructor(ellipsoid?: Ellipsoid);
    /**
     * Determines if the atmosphere is shown.
     */
    show: boolean;
    /**
     * Compute atmosphere per-fragment instead of per-vertex.
     * This produces better looking atmosphere with a slight performance penalty.
     */
    perFragmentAtmosphere: boolean;
    /**
     * The intensity of the light that is used for computing the sky atmosphere color.
     */
    atmosphereLightIntensity: number;
    /**
     * The Rayleigh scattering coefficient used in the atmospheric scattering equations for the sky atmosphere.
     */
    atmosphereRayleighCoefficient: Cartesian3;
    /**
     * The Mie scattering coefficient used in the atmospheric scattering equations for the sky atmosphere.
     */
    atmosphereMieCoefficient: Cartesian3;
    /**
     * The Rayleigh scale height used in the atmospheric scattering equations for the sky atmosphere, in meters.
     */
    atmosphereRayleighScaleHeight: number;
    /**
     * The Mie scale height used in the atmospheric scattering equations for the sky atmosphere, in meters.
     */
    atmosphereMieScaleHeight: number;
    /**
     * The anisotropy of the medium to consider for Mie scattering.
     * <p>
     * Valid values are between -1.0 and 1.0.
     * </p>
     */
    atmosphereMieAnisotropy: number;
    /**
     * The hue shift to apply to the atmosphere. Defaults to 0.0 (no shift).
     * A hue shift of 1.0 indicates a complete rotation of the hues available.
     */
    hueShift: number;
    /**
     * The saturation shift to apply to the atmosphere. Defaults to 0.0 (no shift).
     * A saturation shift of -1.0 is monochrome.
     */
    saturationShift: number;
    /**
     * The brightness shift to apply to the atmosphere. Defaults to 0.0 (no shift).
     * A brightness shift of -1.0 is complete darkness, which will let space show through.
     */
    brightnessShift: number;
    /**
     * Gets the ellipsoid the atmosphere is drawn around.
     */
    readonly ellipsoid: Ellipsoid;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     * @example
     * skyAtmosphere = skyAtmosphere && skyAtmosphere.destroy();
     */
    destroy(): void;
}

/**
 * A sky box around the scene to draw stars.  The sky box is defined using the True Equator Mean Equinox (TEME) axes.
 * <p>
 * This is only supported in 3D.  The sky box is faded out when morphing to 2D or Columbus view.  The size of
 * the sky box must not exceed {@link Scene#maximumCubeMapSize}.
 * </p>
 * @example
 * scene.skyBox = new Cesium.SkyBox({
 *   sources : {
 *     positiveX : 'skybox_px.png',
 *     negativeX : 'skybox_nx.png',
 *     positiveY : 'skybox_py.png',
 *     negativeY : 'skybox_ny.png',
 *     positiveZ : 'skybox_pz.png',
 *     negativeZ : 'skybox_nz.png'
 *   }
 * });
 * @param options - Object with the following properties:
 * @param [options.sources] - The source URL or <code>Image</code> object for each of the six cube map faces.  See the example below.
 * @param [options.show = true] - Determines if this primitive will be shown.
 */
export class SkyBox {
    constructor(options: {
        sources?: any;
        show?: boolean;
    });
    /**
     * The sources used to create the cube map faces: an object
     * with <code>positiveX</code>, <code>negativeX</code>, <code>positiveY</code>,
     * <code>negativeY</code>, <code>positiveZ</code>, and <code>negativeZ</code> properties.
     * These can be either URLs or <code>Image</code> objects.
     */
    sources: any;
    /**
     * Determines if the sky box will be shown.
     */
    show: boolean;
    /**
     * Called when {@link Viewer} or {@link CesiumWidget} render the scene to
     * get the draw commands needed to render this primitive.
     * <p>
     * Do not call this function directly.  This is documented just to
     * list the exceptions that may be propagated when the scene is rendered:
     * </p>
     */
    update(): void;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     * @example
     * skyBox = skyBox && skyBox.destroy();
     */
    destroy(): void;
}

/**
 * A ParticleEmitter that emits particles within a sphere.
 * Particles will be positioned randomly within the sphere and have initial velocities emanating from the center of the sphere.
 * @param [radius = 1.0] - The radius of the sphere in meters.
 */
export class SphereEmitter {
    constructor(radius?: number);
    /**
     * The radius of the sphere in meters.
     */
    radius: number;
}

/**
 * The direction to display a primitive or ImageryLayer relative to the {@link Scene#splitPosition}.
 */
export enum SplitDirection {
    /**
     * Display the primitive or ImageryLayer to the left of the {@link Scene#splitPosition}.
     */
    LEFT = -1,
    /**
     * Always display the primitive or ImageryLayer.
     */
    NONE = 0,
    /**
     * Display the primitive or ImageryLayer to the right of the {@link Scene#splitPosition}.
     */
    RIGHT = 1
}

/**
 * Determines the function used to compare stencil values for the stencil test.
 */
export enum StencilFunction {
    /**
     * The stencil test never passes.
     */
    NEVER = WebGLConstants.NEVER,
    /**
     * The stencil test passes when the masked reference value is less than the masked stencil value.
     */
    LESS = WebGLConstants.LESS,
    /**
     * The stencil test passes when the masked reference value is equal to the masked stencil value.
     */
    EQUAL = WebGLConstants.EQUAL,
    /**
     * The stencil test passes when the masked reference value is less than or equal to the masked stencil value.
     */
    LESS_OR_EQUAL = WebGLConstants.LEQUAL,
    /**
     * The stencil test passes when the masked reference value is greater than the masked stencil value.
     */
    GREATER = WebGLConstants.GREATER,
    /**
     * The stencil test passes when the masked reference value is not equal to the masked stencil value.
     */
    NOT_EQUAL = WebGLConstants.NOTEQUAL,
    /**
     * The stencil test passes when the masked reference value is greater than or equal to the masked stencil value.
     */
    GREATER_OR_EQUAL = WebGLConstants.GEQUAL,
    /**
     * The stencil test always passes.
     */
    ALWAYS = WebGLConstants.ALWAYS
}

/**
 * Determines the action taken based on the result of the stencil test.
 */
export enum StencilOperation {
    /**
     * Sets the stencil buffer value to zero.
     */
    ZERO = WebGLConstants.ZERO,
    /**
     * Does not change the stencil buffer.
     */
    KEEP = WebGLConstants.KEEP,
    /**
     * Replaces the stencil buffer value with the reference value.
     */
    REPLACE = WebGLConstants.REPLACE,
    /**
     * Increments the stencil buffer value, clamping to unsigned byte.
     */
    INCREMENT = WebGLConstants.INCR,
    /**
     * Decrements the stencil buffer value, clamping to zero.
     */
    DECREMENT = WebGLConstants.DECR,
    /**
     * Bitwise inverts the existing stencil buffer value.
     */
    INVERT = WebGLConstants.INVERT,
    /**
     * Increments the stencil buffer value, wrapping to zero when exceeding the unsigned byte range.
     */
    INCREMENT_WRAP = WebGLConstants.INCR_WRAP,
    /**
     * Decrements the stencil buffer value, wrapping to the maximum unsigned byte instead of going below zero.
     */
    DECREMENT_WRAP = WebGLConstants.DECR_WRAP
}

/**
 * An expression for a style applied to a {@link Cesium3DTileset}.
 * <p>
 * Derived classes of this interface evaluate expressions in the
 * {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Styling|3D Tiles Styling language}.
 * </p>
 * <p>
 * This type describes an interface and is not intended to be instantiated directly.
 * </p>
 */
export class StyleExpression {
    constructor();
    /**
     * Evaluates the result of an expression, optionally using the provided feature's properties. If the result of
     * the expression in the
     * {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Styling|3D Tiles Styling language}
     * is of type <code>Boolean</code>, <code>Number</code>, or <code>String</code>, the corresponding JavaScript
     * primitive type will be returned. If the result is a <code>RegExp</code>, a Javascript <code>RegExp</code>
     * object will be returned. If the result is a <code>Cartesian2</code>, <code>Cartesian3</code>, or <code>Cartesian4</code>,
     * a {@link Cartesian2}, {@link Cartesian3}, or {@link Cartesian4} object will be returned. If the <code>result</code> argument is
     * a {@link Color}, the {@link Cartesian4} value is converted to a {@link Color} and then returned.
     * @param feature - The feature whose properties may be used as variables in the expression.
     * @param [result] - The object onto which to store the result.
     * @returns The result of evaluating the expression.
     */
    evaluate(feature: Cesium3DTileFeature, result?: any): boolean | number | string | RegExp | Cartesian2 | Cartesian3 | Cartesian4 | Color;
    /**
     * Evaluates the result of a Color expression, optionally using the provided feature's properties.
     * <p>
     * This is equivalent to {@link StyleExpression#evaluate} but always returns a {@link Color} object.
     * </p>
     * @param feature - The feature whose properties may be used as variables in the expression.
     * @param [result] - The object in which to store the result.
     * @returns The modified result parameter or a new Color instance if one was not provided.
     */
    evaluateColor(feature: Cesium3DTileFeature, result?: Color): Color;
}

/**
 * Draws a sun billboard.
 * <p>This is only supported in 3D and Columbus view.</p>
 * @example
 * scene.sun = new Cesium.Sun();
 */
export class Sun {
    constructor();
    /**
     * Determines if the sun will be shown.
     */
    show: boolean;
    /**
     * Gets or sets a number that controls how "bright" the Sun's lens flare appears
     * to be.  Zero shows just the Sun's disc without any flare.
     * Use larger values for a more pronounced flare around the Sun.
     */
    glowFactor: number;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     * @example
     * sun = sun && sun.destroy();
     *
     *
     */
    destroy(): void;
}

/**
 * A directional light source that originates from the Sun.
 * @param [options] - Object with the following properties:
 * @param [options.color = Color.WHITE] - The light's color.
 * @param [options.intensity = 2.0] - The light's intensity.
 */
export class SunLight {
    constructor(options?: {
        color?: Color;
        intensity?: number;
    });
    /**
     * The color of the light.
     */
    color: Color;
    /**
     * The intensity of the light.
     */
    intensity: number;
}

export namespace Terrain {
    /**
     * A function that is called when an error occurs.
     * @param err - An object holding details about the error that occurred.
     */
    type ErrorEventCallback = (this: Terrain, err: Error) => void;
    /**
     * A function that is called when the provider has been created
     * @param provider - The created terrain provider.
     */
    type ReadyEventCallback = (this: Terrain, provider: TerrainProvider) => void;
}

/**
 * A helper to manage async operations of a terrain provider.
 * @example
 * // Create
 * const viewer = new Cesium.Viewer("cesiumContainer", {
 *   terrain: new Cesium.Terrain(Cesium.CesiumTerrainProvider.fromUrl("https://myTestTerrain.com"));
 * });
 * @example
 * // Handle loading events
 * const terrain = new Cesium.Terrain(Cesium.CesiumTerrainProvider.fromUrl("https://myTestTerrain.com"));
 *
 * scene.setTerrain(terrain);
 *
 * terrain.readyEvent.addEventListener(provider => {
 *   scene.globe.enableLighting = true;
 *
 *   terrain.provider.errorEvent.addEventListener(error => {
 *     alert(`Encountered an error while loading terrain tiles! ${error}`);
 *   });
 * });
 *
 * terrain.errorEvent.addEventListener(error => {
 *   alert(`Encountered an error while creating terrain! ${error}`);
 * });
 * @param terrainProviderPromise - A promise which resolves to a terrain provider
 */
export class Terrain {
    constructor(terrainProviderPromise: Promise<TerrainProvider>);
    /**
     * Gets an event that is raised when the terrain provider encounters an asynchronous error.  By subscribing
     * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
     * are passed an instance of the thrown error.
     */
    readonly errorEvent: Event<Terrain.ErrorEventCallback>;
    /**
     * Gets an event that is raised when the terrain provider has been successfully created. Event listeners
     * are passed the created instance of {@link TerrainProvider}.
     */
    readonly readyEvent: Event<Terrain.ReadyEventCallback>;
    /**
     * Creates a {@link Terrain} instance for {@link https://cesium.com/content/#cesium-world-terrain|Cesium World Terrain}.
     * @example
     * // Create Cesium World Terrain with default settings
     * const viewer = new Cesium.Viewer("cesiumContainer", {
     *   terrain: Cesium.Terrain.fromWorldTerrain()
     * });
     * @example
     * // Create Cesium World Terrain with water and normals.
     * const viewer1 = new Cesium.Viewer("cesiumContainer", {
     *   terrain: Cesium.Terrain.fromWorldTerrain({
     *      requestWaterMask: true,
     *      requestVertexNormals: true
     *    });
     * });
     * @example
     * // Handle loading events
     * const terrain = Cesium.Terrain.fromWorldTerrain();
     *
     * scene.setTerrain(terrain);
     *
     * terrain.readyEvent.addEventListener(provider => {
     *   scene.globe.enableLighting = true;
     *
     *   terrain.provider.errorEvent.addEventListener(error => {
     *     alert(`Encountered an error while loading terrain tiles! ${error}`);
     *   });
     * });
     *
     * terrain.errorEvent.addEventListener(error => {
     *   alert(`Encountered an error while creating terrain! ${error}`);
     * });
     * @param [options] - Object with the following properties:
     * @param [options.requestVertexNormals = false] - Flag that indicates if the client should request additional lighting information from the server if available.
     * @param [options.requestWaterMask = false] - Flag that indicates if the client should request per tile water masks from the server if available.
     * @returns An asynchronous helper object for a CesiumTerrainProvider
     */
    static fromWorldTerrain(options?: {
        requestVertexNormals?: boolean;
        requestWaterMask?: boolean;
    }): Terrain;
}

export namespace TileCoordinatesImageryProvider {
    /**
     * Initialization options for the TileCoordinatesImageryProvider constructor
     * [tilingScheme = new GeographicTilingScheme()] - The tiling scheme for which to draw tiles.
     * [ellipsoid] - The ellipsoid.  If the tilingScheme is specified,
     *                    this parameter is ignored and the tiling scheme's ellipsoid is used instead. If neither
     *                    parameter is specified, the WGS84 ellipsoid is used.
     * [color = Color.YELLOW] - The color to draw the tile box and label.
     * [tileWidth = 256] - The width of the tile for level-of-detail selection purposes.
     * [tileHeight = 256] - The height of the tile for level-of-detail selection purposes.
     */
    type ConstructorOptions = {
        tilingScheme?: TilingScheme;
        ellipsoid?: Ellipsoid;
        color?: Color;
        tileWidth?: number;
        tileHeight?: number;
    };
}

/**
 * An {@link ImageryProvider} that draws a box around every rendered tile in the tiling scheme, and draws
 * a label inside it indicating the X, Y, Level coordinates of the tile.  This is mostly useful for
 * debugging terrain and imagery rendering problems.
 * @param [options] - Object describing initialization options
 */
export class TileCoordinatesImageryProvider {
    constructor(options?: TileCoordinatesImageryProvider.ConstructorOptions);
    /**
     * Gets the proxy used by this provider.
     */
    readonly proxy: Proxy;
    /**
     * Gets the width of each tile, in pixels.
     */
    readonly tileWidth: number;
    /**
     * Gets the height of each tile, in pixels.
     */
    readonly tileHeight: number;
    /**
     * Gets the maximum level-of-detail that can be requested.
     */
    readonly maximumLevel: number | undefined;
    /**
     * Gets the minimum level-of-detail that can be requested.
     */
    readonly minimumLevel: number;
    /**
     * Gets the tiling scheme used by this provider.
     */
    readonly tilingScheme: TilingScheme;
    /**
     * Gets the rectangle, in radians, of the imagery provided by this instance.
     */
    readonly rectangle: Rectangle;
    /**
     * Gets the tile discard policy.  If not undefined, the discard policy is responsible
     * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
     * returns undefined, no tiles are filtered.
     */
    readonly tileDiscardPolicy: TileDiscardPolicy;
    /**
     * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
     * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
     * are passed an instance of {@link TileProviderError}.
     */
    readonly errorEvent: Event;
    /**
     * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
     * the source of the imagery.
     */
    readonly credit: Credit;
    /**
     * Gets a value indicating whether or not the images provided by this imagery provider
     * include an alpha channel.  If this property is false, an alpha channel, if present, will
     * be ignored.  If this property is true, any images without an alpha channel will be treated
     * as if their alpha is 1.0 everywhere.  Setting this property to false reduces memory usage
     * and texture upload time.
     */
    readonly hasAlphaChannel: boolean;
    /**
     * Gets the credits to be displayed when a given tile is displayed.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level;
     * @returns The credits to be displayed when the tile is displayed.
     */
    getTileCredits(x: number, y: number, level: number): Credit[];
    /**
     * Requests the image for a given tile.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level.
     * @param [request] - The request object. Intended for internal use only.
     * @returns The resolved image as a Canvas DOM object.
     */
    requestImage(x: number, y: number, level: number, request?: Request): Promise<HTMLCanvasElement>;
    /**
     * Picking features is not currently supported by this imagery provider, so this function simply returns
     * undefined.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level.
     * @param longitude - The longitude at which to pick features.
     * @param latitude - The latitude at which to pick features.
     * @returns Undefined since picking is not supported.
     */
    pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): undefined;
}

/**
 * A policy for discarding tile images according to some criteria.  This type describes an
 * interface and is not intended to be instantiated directly.
 */
export class TileDiscardPolicy {
    constructor();
    /**
     * Determines if the discard policy is ready to process images.
     * @returns True if the discard policy is ready to process images; otherwise, false.
     */
    isReady(): boolean;
    /**
     * Given a tile image, decide whether to discard that image.
     * @param image - An image to test.
     * @returns True if the image should be discarded; otherwise, false.
     */
    shouldDiscardImage(image: HTMLImageElement): boolean;
}

export namespace TileMapServiceImageryProvider {
    /**
     * Initialization options for the TileMapServiceImageryProvider constructor
     * [fileExtension = 'png'] - The file extension for images on the server.
     * [credit = ''] - A credit for the data source, which is displayed on the canvas.
     * [minimumLevel = 0] - The minimum level-of-detail supported by the imagery provider.  Take care when specifying
     *                 this that the number of tiles at the minimum level is small, such as four or less.  A larger number is likely
     *                 to result in rendering problems.
     * [maximumLevel] - The maximum level-of-detail supported by the imagery provider, or undefined if there is no limit.
     * [rectangle = Rectangle.MAX_VALUE] - The rectangle, in radians, covered by the image.
     * [tilingScheme] - The tiling scheme specifying how the ellipsoidal
     * surface is broken into tiles.  If this parameter is not provided, a {@link WebMercatorTilingScheme}
     * is used.
     * [ellipsoid] - The ellipsoid.  If the tilingScheme is specified,
     *                    this parameter is ignored and the tiling scheme's ellipsoid is used instead. If neither
     *                    parameter is specified, the WGS84 ellipsoid is used.
     * [tileWidth = 256] - Pixel width of image tiles.
     * [tileHeight = 256] - Pixel height of image tiles.
     * [flipXY] - Older versions of gdal2tiles.py flipped X and Y values in tilemapresource.xml.
     * [tileDiscardPolicy] - A policy for discarding tile images according to some criteria
     * Specifying this option will do the same, allowing for loading of these incorrect tilesets.
     */
    type ConstructorOptions = {
        fileExtension?: string;
        credit?: Credit | string;
        minimumLevel?: number;
        maximumLevel?: number;
        rectangle?: Rectangle;
        tilingScheme?: TilingScheme;
        ellipsoid?: Ellipsoid;
        tileWidth?: number;
        tileHeight?: number;
        flipXY?: boolean;
        tileDiscardPolicy?: TileDiscardPolicy;
    };
}

/**
 * <div class="notice">
 * To construct a TileMapServiceImageryProvider, call {@link TileMapServiceImageryProvider.fromUrl}. Do not call the constructor directly.
 * </div>
 *
 * An imagery provider that provides tiled imagery as generated by
 * {@link http://www.maptiler.org/|MapTiler}, {@link http://www.klokan.cz/projects/gdal2tiles/|GDAL2Tiles}, etc.
 * @example
 * const tms = await Cesium.TileMapServiceImageryProvider.fromUrl(
 *    "../images/cesium_maptiler/Cesium_Logo_Color", {
 *      fileExtension: 'png',
 *      maximumLevel: 4,
 *      rectangle: new Cesium.Rectangle(
 *        Cesium.Math.toRadians(-120.0),
 *        Cesium.Math.toRadians(20.0),
 *        Cesium.Math.toRadians(-60.0),
 *        Cesium.Math.toRadians(40.0))
 * });
 * @param [options] - Object describing initialization options
 */
export class TileMapServiceImageryProvider extends UrlTemplateImageryProvider {
    constructor(options?: TileMapServiceImageryProvider.ConstructorOptions);
    /**
     * Creates a TileMapServiceImageryProvider from the specified url.
     * @example
     * const tms = await Cesium.TileMapServiceImageryProvider.fromUrl(
     *    '../images/cesium_maptiler/Cesium_Logo_Color', {
     *      fileExtension: 'png',
     *      maximumLevel: 4,
     *      rectangle: new Cesium.Rectangle(
     *        Cesium.Math.toRadians(-120.0),
     *        Cesium.Math.toRadians(20.0),
     *        Cesium.Math.toRadians(-60.0),
     *        Cesium.Math.toRadians(40.0))
     * });
     * @param url - Path to image tiles on server.
     * @param [options] - Object describing initialization options.
     * @returns A promise that resolves to the created TileMapServiceImageryProvider.
     */
    static fromUrl(url: Resource | string, options?: TileMapServiceImageryProvider.ConstructorOptions): Promise<TileMapServiceImageryProvider>;
}

/**
 * Provides functionality for ImageryProviders that have time dynamic imagery
 * @param options - Object with the following properties:
 * @param options.clock - A Clock instance that is used when determining the value for the time dimension. Required when <code>options.times</code> is specified.
 * @param options.times - TimeIntervalCollection with its <code>data</code> property being an object containing time dynamic dimension and their values.
 * @param options.requestImageFunction - A function that will request imagery tiles.
 * @param options.reloadFunction - A function that will be called when all imagery tiles need to be reloaded.
 */
export class TimeDynamicImagery {
    constructor(options: {
        clock: Clock;
        times: TimeIntervalCollection;
        requestImageFunction: (...params: any[]) => any;
        reloadFunction: (...params: any[]) => any;
    });
    /**
     * Gets or sets a clock that is used to get keep the time used for time dynamic parameters.
     */
    clock: Clock;
    /**
     * Gets or sets a time interval collection.
     */
    times: TimeIntervalCollection;
    /**
     * Gets the current interval.
     */
    currentInterval: TimeInterval;
    /**
     * Gets the tile from the cache if its available.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level.
     * @param [request] - The request object. Intended for internal use only.
     * @returns A promise for the image that will resolve when the image is available, or
     *          undefined if the tile is not in the cache.
     */
    getFromCache(x: number, y: number, level: number, request?: Request): Promise<HTMLImageElement> | undefined;
    /**
     * Checks if the next interval is approaching and will start preload the tile if necessary. Otherwise it will
     * just add the tile to a list to preload when we approach the next interval.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level.
     * @param [request] - The request object. Intended for internal use only.
     */
    checkApproachingInterval(x: number, y: number, level: number, request?: Request): void;
}

/**
 * Provides playback of time-dynamic point cloud data.
 * <p>
 * Point cloud frames are prefetched in intervals determined by the average frame load time and the current clock speed.
 * If intermediate frames cannot be loaded in time to meet playback speed, they will be skipped. If frames are sufficiently
 * small or the clock is sufficiently slow then no frames will be skipped.
 * </p>
 * @param options - Object with the following properties:
 * @param options.clock - A {@link Clock} instance that is used when determining the value for the time dimension.
 * @param options.intervals - A {@link TimeIntervalCollection} with its data property being an object containing a <code>uri</code> to a 3D Tiles Point Cloud tile and an optional <code>transform</code>.
 * @param [options.show = true] - Determines if the point cloud will be shown.
 * @param [options.modelMatrix = Matrix4.IDENTITY] - A 4x4 transformation matrix that transforms the point cloud.
 * @param [options.shadows = ShadowMode.ENABLED] - Determines whether the point cloud casts or receives shadows from light sources.
 * @param [options.maximumMemoryUsage = 256] - The maximum amount of memory in MB that can be used by the point cloud.
 * @param [options.shading] - Options for constructing a {@link PointCloudShading} object to control point attenuation and eye dome lighting.
 * @param [options.style] - The style, defined using the {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Styling|3D Tiles Styling language}, applied to each point in the point cloud.
 * @param [options.clippingPlanes] - The {@link ClippingPlaneCollection} used to selectively disable rendering the point cloud.
 */
export class TimeDynamicPointCloud {
    constructor(options: {
        clock: Clock;
        intervals: TimeIntervalCollection;
        show?: boolean;
        modelMatrix?: Matrix4;
        shadows?: ShadowMode;
        maximumMemoryUsage?: number;
        shading?: any;
        style?: Cesium3DTileStyle;
        clippingPlanes?: ClippingPlaneCollection;
    });
    /**
     * Determines if the point cloud will be shown.
     */
    show: boolean;
    /**
     * A 4x4 transformation matrix that transforms the point cloud.
     */
    modelMatrix: Matrix4;
    /**
     * Determines whether the point cloud casts or receives shadows from light sources.
     * <p>
     * Enabling shadows has a performance impact. A point cloud that casts shadows must be rendered twice, once from the camera and again from the light's point of view.
     * </p>
     * <p>
     * Shadows are rendered only when {@link Viewer#shadows} is <code>true</code>.
     * </p>
     */
    shadows: ShadowMode;
    /**
     * The maximum amount of GPU memory (in MB) that may be used to cache point cloud frames.
     * <p>
     * Frames that are not being loaded or rendered are unloaded to enforce this.
     * </p>
     * <p>
     * If decreasing this value results in unloading tiles, the tiles are unloaded the next frame.
     * </p>
     */
    maximumMemoryUsage: number;
    /**
     * Options for controlling point size based on geometric error and eye dome lighting.
     */
    shading: PointCloudShading;
    /**
     * The style, defined using the
     * {@link https://github.com/CesiumGS/3d-tiles/tree/main/specification/Styling|3D Tiles Styling language},
     * applied to each point in the point cloud.
     * <p>
     * Assign <code>undefined</code> to remove the style, which will restore the visual
     * appearance of the point cloud to its default when no style was applied.
     * </p>
     * @example
     * pointCloud.style = new Cesium.Cesium3DTileStyle({
     *    color : {
     *        conditions : [
     *            ['${Classification} === 0', 'color("purple", 0.5)'],
     *            ['${Classification} === 1', 'color("red")'],
     *            ['true', '${COLOR}']
     *        ]
     *    },
     *    show : '${Classification} !== 2'
     * });
     */
    style: Cesium3DTileStyle;
    /**
     * The event fired to indicate that a frame failed to load. A frame may fail to load if the
     * request for its uri fails or processing fails due to invalid content.
     * <p>
     * If there are no event listeners, error messages will be logged to the console.
     * </p>
     * <p>
     * The error object passed to the listener contains two properties:
     * <ul>
     * <li><code>uri</code>: the uri of the failed frame.</li>
     * <li><code>message</code>: the error message.</li>
     * </ul>
     * @example
     * pointCloud.frameFailed.addEventListener(function(error) {
     *     console.log(`An error occurred loading frame: ${error.uri}`);
     *     console.log(`Error: ${error.message}`);
     * });
     */
    frameFailed: Event;
    /**
     * The event fired to indicate that a new frame was rendered.
     * <p>
     * The time dynamic point cloud {@link TimeDynamicPointCloud} is passed to the event listener.
     * </p>
     * @example
     * pointCloud.frameChanged.addEventListener(function(timeDynamicPointCloud) {
     *     viewer.camera.viewBoundingSphere(timeDynamicPointCloud.boundingSphere);
     * });
     */
    frameChanged: Event;
    /**
     * The {@link ClippingPlaneCollection} used to selectively disable rendering the point cloud.
     */
    clippingPlanes: ClippingPlaneCollection;
    /**
     * The total amount of GPU memory in bytes used by the point cloud.
     */
    readonly totalMemoryUsageInBytes: number;
    /**
     * The bounding sphere of the frame being rendered. Returns <code>undefined</code> if no frame is being rendered.
     */
    readonly boundingSphere: BoundingSphere;
    /**
     * Marks the point cloud's {@link TimeDynamicPointCloud#style} as dirty, which forces all
     * points to re-evaluate the style in the next frame.
     */
    makeStyleDirty(): void;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     * @example
     * pointCloud = pointCloud && pointCloud.destroy();
     */
    destroy(): void;
}

export namespace UrlTemplateImageryProvider {
    /**
     * Initialization options for the UrlTemplateImageryProvider constructor
     * url - The URL template to use to request tiles.  It has the following keywords:
     * <ul>
     *     <li><code>{z}</code>: The level of the tile in the tiling scheme.  Level zero is the root of the quadtree pyramid.</li>
     *     <li><code>{x}</code>: The tile X coordinate in the tiling scheme, where 0 is the Westernmost tile.</li>
     *     <li><code>{y}</code>: The tile Y coordinate in the tiling scheme, where 0 is the Northernmost tile.</li>
     *     <li><code>{s}</code>: One of the available subdomains, used to overcome browser limits on the number of simultaneous requests per host.</li>
     *     <li><code>{reverseX}</code>: The tile X coordinate in the tiling scheme, where 0 is the Easternmost tile.</li>
     *     <li><code>{reverseY}</code>: The tile Y coordinate in the tiling scheme, where 0 is the Southernmost tile.</li>
     *     <li><code>{reverseZ}</code>: The level of the tile in the tiling scheme, where level zero is the maximum level of the quadtree pyramid.  In order to use reverseZ, maximumLevel must be defined.</li>
     *     <li><code>{westDegrees}</code>: The Western edge of the tile in geodetic degrees.</li>
     *     <li><code>{southDegrees}</code>: The Southern edge of the tile in geodetic degrees.</li>
     *     <li><code>{eastDegrees}</code>: The Eastern edge of the tile in geodetic degrees.</li>
     *     <li><code>{northDegrees}</code>: The Northern edge of the tile in geodetic degrees.</li>
     *     <li><code>{westProjected}</code>: The Western edge of the tile in projected coordinates of the tiling scheme.</li>
     *     <li><code>{southProjected}</code>: The Southern edge of the tile in projected coordinates of the tiling scheme.</li>
     *     <li><code>{eastProjected}</code>: The Eastern edge of the tile in projected coordinates of the tiling scheme.</li>
     *     <li><code>{northProjected}</code>: The Northern edge of the tile in projected coordinates of the tiling scheme.</li>
     *     <li><code>{width}</code>: The width of each tile in pixels.</li>
     *     <li><code>{height}</code>: The height of each tile in pixels.</li>
     * </ul>
     * [pickFeaturesUrl] - The URL template to use to pick features.  If this property is not specified,
     *                 {@link UrlTemplateImageryProvider#pickFeatures} will immediately returned undefined, indicating no
     *                 features picked.  The URL template supports all of the keywords supported by the <code>url</code>
     *                 parameter, plus the following:
     * <ul>
     *     <li><code>{i}</code>: The pixel column (horizontal coordinate) of the picked position, where the Westernmost pixel is 0.</li>
     *     <li><code>{j}</code>: The pixel row (vertical coordinate) of the picked position, where the Northernmost pixel is 0.</li>
     *     <li><code>{reverseI}</code>: The pixel column (horizontal coordinate) of the picked position, where the Easternmost pixel is 0.</li>
     *     <li><code>{reverseJ}</code>: The pixel row (vertical coordinate) of the picked position, where the Southernmost pixel is 0.</li>
     *     <li><code>{longitudeDegrees}</code>: The longitude of the picked position in degrees.</li>
     *     <li><code>{latitudeDegrees}</code>: The latitude of the picked position in degrees.</li>
     *     <li><code>{longitudeProjected}</code>: The longitude of the picked position in the projected coordinates of the tiling scheme.</li>
     *     <li><code>{latitudeProjected}</code>: The latitude of the picked position in the projected coordinates of the tiling scheme.</li>
     *     <li><code>{format}</code>: The format in which to get feature information, as specified in the {@link GetFeatureInfoFormat}.</li>
     * </ul>
     * [urlSchemeZeroPadding] - Gets the URL scheme zero padding for each tile coordinate. The format is '000' where
     * each coordinate will be padded on the left with zeros to match the width of the passed string of zeros. e.g. Setting:
     * urlSchemeZeroPadding : { '{x}' : '0000'}
     * will cause an 'x' value of 12 to return the string '0012' for {x} in the generated URL.
     * It the passed object has the following keywords:
     * <ul>
     *  <li> <code>{z}</code>: The zero padding for the level of the tile in the tiling scheme.</li>
     *  <li> <code>{x}</code>: The zero padding for the tile X coordinate in the tiling scheme.</li>
     *  <li> <code>{y}</code>: The zero padding for the the tile Y coordinate in the tiling scheme.</li>
     *  <li> <code>{reverseX}</code>: The zero padding for the tile reverseX coordinate in the tiling scheme.</li>
     *  <li> <code>{reverseY}</code>: The zero padding for the tile reverseY coordinate in the tiling scheme.</li>
     *  <li> <code>{reverseZ}</code>: The zero padding for the reverseZ coordinate of the tile in the tiling scheme.</li>
     * </ul>
     * [subdomains = 'abc'] - The subdomains to use for the <code>{s}</code> placeholder in the URL template.
     *                          If this parameter is a single string, each character in the string is a subdomain.  If it is
     *                          an array, each element in the array is a subdomain.
     * [credit = ''] - A credit for the data source, which is displayed on the canvas.
     * [minimumLevel = 0] - The minimum level-of-detail supported by the imagery provider.  Take care when specifying
     *                 this that the number of tiles at the minimum level is small, such as four or less.  A larger number is likely
     *                 to result in rendering problems.
     * [maximumLevel] - The maximum level-of-detail supported by the imagery provider, or undefined if there is no limit.
     * [rectangle = Rectangle.MAX_VALUE] - The rectangle, in radians, covered by the image.
     * [tilingScheme = WebMercatorTilingScheme] - The tiling scheme specifying how the ellipsoidal
     * surface is broken into tiles.  If this parameter is not provided, a {@link WebMercatorTilingScheme}
     * is used.
     * [ellipsoid] - The ellipsoid.  If the tilingScheme is specified,
     *                    this parameter is ignored and the tiling scheme's ellipsoid is used instead. If neither
     *                    parameter is specified, the WGS84 ellipsoid is used.
     * [tileWidth = 256] - Pixel width of image tiles.
     * [tileHeight = 256] - Pixel height of image tiles.
     * [hasAlphaChannel = true] - true if the images provided by this imagery provider
     *                  include an alpha channel; otherwise, false.  If this property is false, an alpha channel, if
     *                  present, will be ignored.  If this property is true, any images without an alpha channel will
     *                  be treated as if their alpha is 1.0 everywhere.  When this property is false, memory usage
     *                  and texture upload time are potentially reduced.
     * [getFeatureInfoFormats] - The formats in which to get feature information at a
     *                                 specific location when {@link UrlTemplateImageryProvider#pickFeatures} is invoked.  If this
     *                                 parameter is not specified, feature picking is disabled.
     * [enablePickFeatures = true] - If true, {@link UrlTemplateImageryProvider#pickFeatures} will
     *        request the <code>pickFeaturesUrl</code> and attempt to interpret the features included in the response.  If false,
     *        {@link UrlTemplateImageryProvider#pickFeatures} will immediately return undefined (indicating no pickable
     *        features) without communicating with the server.  Set this property to false if you know your data
     *        source does not support picking features or if you don't want this provider's features to be pickable. Note
     *        that this can be dynamically overridden by modifying the {@link UriTemplateImageryProvider#enablePickFeatures}
     *        property.
     * [tileDiscardPolicy] - A policy for discarding tile images according to some criteria
     * [customTags] - Allow to replace custom keywords in the URL template. The object must have strings as keys and functions as values.
     */
    type ConstructorOptions = {
        url: Resource | string;
        pickFeaturesUrl?: Resource | string;
        urlSchemeZeroPadding?: any;
        subdomains?: string | string[];
        credit?: Credit | string;
        minimumLevel?: number;
        maximumLevel?: number;
        rectangle?: Rectangle;
        tilingScheme?: TilingScheme;
        ellipsoid?: Ellipsoid;
        tileWidth?: number;
        tileHeight?: number;
        hasAlphaChannel?: boolean;
        getFeatureInfoFormats?: GetFeatureInfoFormat[];
        enablePickFeatures?: boolean;
        tileDiscardPolicy?: TileDiscardPolicy;
        customTags?: any;
    };
}

/**
 * Provides imagery by requesting tiles using a specified URL template.
 * @example
 * // Access Natural Earth II imagery, which uses a TMS tiling scheme and Geographic (EPSG:4326) project
 * const tms = new Cesium.UrlTemplateImageryProvider({
 *     url : Cesium.buildModuleUrl('Assets/Textures/NaturalEarthII') + '/{z}/{x}/{reverseY}.jpg',
 *     tilingScheme : new Cesium.GeographicTilingScheme(),
 *     maximumLevel : 5
 * });
 * // Access the CartoDB Positron basemap, which uses an OpenStreetMap-like tiling scheme.
 * const positron = new Cesium.UrlTemplateImageryProvider({
 *     url : 'http://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}.png',
 *     credit : 'Map tiles by CartoDB, under CC BY 3.0. Data by OpenStreetMap, under ODbL.'
 * });
 * // Access a Web Map Service (WMS) server.
 * const wms = new Cesium.UrlTemplateImageryProvider({
 *    url : 'https://programs.communications.gov.au/geoserver/ows?tiled=true&' +
 *          'transparent=true&format=image%2Fpng&exceptions=application%2Fvnd.ogc.se_xml&' +
 *          'styles=&service=WMS&version=1.1.1&request=GetMap&' +
 *          'layers=public%3AMyBroadband_Availability&srs=EPSG%3A3857&' +
 *          'bbox={westProjected}%2C{southProjected}%2C{eastProjected}%2C{northProjected}&' +
 *          'width=256&height=256',
 *    rectangle : Cesium.Rectangle.fromDegrees(96.799393, -43.598214999057824, 153.63925700000001, -9.2159219997013)
 * });
 * // Using custom tags in your template url.
 * const custom = new Cesium.UrlTemplateImageryProvider({
 *    url : 'https://yoururl/{Time}/{z}/{y}/{x}.png',
 *    customTags : {
 *        Time: function(imageryProvider, x, y, level) {
 *            return '20171231'
 *        }
 *    }
 * });
 * @param options - Object describing initialization options
 */
export class UrlTemplateImageryProvider {
    constructor(options: UrlTemplateImageryProvider.ConstructorOptions);
    /**
     * Gets or sets a value indicating whether feature picking is enabled.  If true, {@link UrlTemplateImageryProvider#pickFeatures} will
     * request the <code>options.pickFeaturesUrl</code> and attempt to interpret the features included in the response.  If false,
     * {@link UrlTemplateImageryProvider#pickFeatures} will immediately return undefined (indicating no pickable
     * features) without communicating with the server.  Set this property to false if you know your data
     * source does not support picking features or if you don't want this provider's features to be pickable.
     */
    enablePickFeatures: boolean;
    /**
     * Gets the URL template to use to request tiles.  It has the following keywords:
     * <ul>
     *  <li> <code>{z}</code>: The level of the tile in the tiling scheme.  Level zero is the root of the quadtree pyramid.</li>
     *  <li> <code>{x}</code>: The tile X coordinate in the tiling scheme, where 0 is the Westernmost tile.</li>
     *  <li> <code>{y}</code>: The tile Y coordinate in the tiling scheme, where 0 is the Northernmost tile.</li>
     *  <li> <code>{s}</code>: One of the available subdomains, used to overcome browser limits on the number of simultaneous requests per host.</li>
     *  <li> <code>{reverseX}</code>: The tile X coordinate in the tiling scheme, where 0 is the Easternmost tile.</li>
     *  <li> <code>{reverseY}</code>: The tile Y coordinate in the tiling scheme, where 0 is the Southernmost tile.</li>
     *  <li> <code>{reverseZ}</code>: The level of the tile in the tiling scheme, where level zero is the maximum level of the quadtree pyramid.  In order to use reverseZ, maximumLevel must be defined.</li>
     *  <li> <code>{westDegrees}</code>: The Western edge of the tile in geodetic degrees.</li>
     *  <li> <code>{southDegrees}</code>: The Southern edge of the tile in geodetic degrees.</li>
     *  <li> <code>{eastDegrees}</code>: The Eastern edge of the tile in geodetic degrees.</li>
     *  <li> <code>{northDegrees}</code>: The Northern edge of the tile in geodetic degrees.</li>
     *  <li> <code>{westProjected}</code>: The Western edge of the tile in projected coordinates of the tiling scheme.</li>
     *  <li> <code>{southProjected}</code>: The Southern edge of the tile in projected coordinates of the tiling scheme.</li>
     *  <li> <code>{eastProjected}</code>: The Eastern edge of the tile in projected coordinates of the tiling scheme.</li>
     *  <li> <code>{northProjected}</code>: The Northern edge of the tile in projected coordinates of the tiling scheme.</li>
     *  <li> <code>{width}</code>: The width of each tile in pixels.</li>
     *  <li> <code>{height}</code>: The height of each tile in pixels.</li>
     * </ul>
     */
    readonly url: string;
    /**
     * Gets the URL scheme zero padding for each tile coordinate. The format is '000' where each coordinate will be padded on
     * the left with zeros to match the width of the passed string of zeros. e.g. Setting:
     * urlSchemeZeroPadding : { '{x}' : '0000'}
     * will cause an 'x' value of 12 to return the string '0012' for {x} in the generated URL.
     * It has the following keywords:
     * <ul>
     *  <li> <code>{z}</code>: The zero padding for the level of the tile in the tiling scheme.</li>
     *  <li> <code>{x}</code>: The zero padding for the tile X coordinate in the tiling scheme.</li>
     *  <li> <code>{y}</code>: The zero padding for the the tile Y coordinate in the tiling scheme.</li>
     *  <li> <code>{reverseX}</code>: The zero padding for the tile reverseX coordinate in the tiling scheme.</li>
     *  <li> <code>{reverseY}</code>: The zero padding for the tile reverseY coordinate in the tiling scheme.</li>
     *  <li> <code>{reverseZ}</code>: The zero padding for the reverseZ coordinate of the tile in the tiling scheme.</li>
     * </ul>
     */
    readonly urlSchemeZeroPadding: any;
    /**
     * Gets the URL template to use to use to pick features.  If this property is not specified,
     * {@link UrlTemplateImageryProvider#pickFeatures} will immediately return undefined, indicating no
     * features picked.  The URL template supports all of the keywords supported by the
     * {@link UrlTemplateImageryProvider#url} property, plus the following:
     * <ul>
     *     <li><code>{i}</code>: The pixel column (horizontal coordinate) of the picked position, where the Westernmost pixel is 0.</li>
     *     <li><code>{j}</code>: The pixel row (vertical coordinate) of the picked position, where the Northernmost pixel is 0.</li>
     *     <li><code>{reverseI}</code>: The pixel column (horizontal coordinate) of the picked position, where the Easternmost pixel is 0.</li>
     *     <li><code>{reverseJ}</code>: The pixel row (vertical coordinate) of the picked position, where the Southernmost pixel is 0.</li>
     *     <li><code>{longitudeDegrees}</code>: The longitude of the picked position in degrees.</li>
     *     <li><code>{latitudeDegrees}</code>: The latitude of the picked position in degrees.</li>
     *     <li><code>{longitudeProjected}</code>: The longitude of the picked position in the projected coordinates of the tiling scheme.</li>
     *     <li><code>{latitudeProjected}</code>: The latitude of the picked position in the projected coordinates of the tiling scheme.</li>
     *     <li><code>{format}</code>: The format in which to get feature information, as specified in the {@link GetFeatureInfoFormat}.</li>
     * </ul>
     */
    readonly pickFeaturesUrl: string;
    /**
     * Gets the proxy used by this provider.
     */
    readonly proxy: Proxy;
    /**
     * Gets the width of each tile, in pixels.
     */
    readonly tileWidth: number;
    /**
     * Gets the height of each tile, in pixels.
     */
    readonly tileHeight: number;
    /**
     * Gets the maximum level-of-detail that can be requested, or undefined if there is no limit.
     */
    readonly maximumLevel: number | undefined;
    /**
     * Gets the minimum level-of-detail that can be requested.
     */
    readonly minimumLevel: number;
    /**
     * Gets the tiling scheme used by this provider.
     */
    readonly tilingScheme: TilingScheme;
    /**
     * Gets the rectangle, in radians, of the imagery provided by this instance.
     */
    readonly rectangle: Rectangle;
    /**
     * Gets the tile discard policy.  If not undefined, the discard policy is responsible
     * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
     * returns undefined, no tiles are filtered.
     */
    readonly tileDiscardPolicy: TileDiscardPolicy;
    /**
     * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
     * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
     * are passed an instance of {@link TileProviderError}.
     */
    readonly errorEvent: Event;
    /**
     * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
     * the source of the imagery.
     */
    readonly credit: Credit;
    /**
     * Gets a value indicating whether or not the images provided by this imagery provider
     * include an alpha channel.  If this property is false, an alpha channel, if present, will
     * be ignored.  If this property is true, any images without an alpha channel will be treated
     * as if their alpha is 1.0 everywhere.  When this property is false, memory usage
     * and texture upload time are reduced.
     */
    readonly hasAlphaChannel: boolean;
    /**
     * Gets the credits to be displayed when a given tile is displayed.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level;
     * @returns The credits to be displayed when the tile is displayed.
     */
    getTileCredits(x: number, y: number, level: number): Credit[];
    /**
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level.
     * @param [request] - The request object. Intended for internal use only.
     * @returns A promise for the image that will resolve when the image is available, or
     *          undefined if there are too many active requests to the server, and the request should be retried later.
     */
    requestImage(x: number, y: number, level: number, request?: Request): Promise<ImageryTypes> | undefined;
    /**
     * Asynchronously determines what features, if any, are located at a given longitude and latitude within
     * a tile.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level.
     * @param longitude - The longitude at which to pick features.
     * @param latitude - The latitude at which to pick features.
     * @returns A promise for the picked features that will resolve when the asynchronous
     *                   picking completes.  The resolved value is an array of {@link ImageryLayerFeatureInfo}
     *                   instances.  The array may be empty if no features are found at the given location.
     *                   It may also be undefined if picking is not supported.
     */
    pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): Promise<ImageryLayerFeatureInfo[]> | undefined;
}

/**
 * The vertical location of an origin relative to an object, e.g., a {@link Billboard}
 * or {@link Label}.  For example, setting the vertical origin to <code>TOP</code>
 * or <code>BOTTOM</code> will display a billboard above or below (in screen space)
 * the anchor position.
 * <br /><br />
 * <div align='center'>
 * <img src='Images/Billboard.setVerticalOrigin.png' width='695' height='175' /><br />
 * </div>
 */
export enum VerticalOrigin {
    /**
     * The origin is at the vertical center between <code>BASELINE</code> and <code>TOP</code>.
     */
    CENTER = 0,
    /**
     * The origin is at the bottom of the object.
     */
    BOTTOM = 1,
    /**
     * If the object contains text, the origin is at the baseline of the text, else the origin is at the bottom of the object.
     */
    BASELINE = 2,
    /**
     * The origin is at the top of the object.
     */
    TOP = -1
}

/**
 * A viewport aligned quad.
 * @example
 * const viewportQuad = new Cesium.ViewportQuad(new Cesium.BoundingRectangle(0, 0, 80, 40));
 * viewportQuad.material.uniforms.color = new Cesium.Color(1.0, 0.0, 0.0, 1.0);
 * @param [rectangle] - The {@link BoundingRectangle} defining the quad's position within the viewport.
 * @param [material] - The {@link Material} defining the surface appearance of the viewport quad.
 */
export class ViewportQuad {
    constructor(rectangle?: BoundingRectangle, material?: Material);
    /**
     * Determines if the viewport quad primitive will be shown.
     */
    show: boolean;
    /**
     * The BoundingRectangle defining the quad's position within the viewport.
     * @example
     * viewportQuad.rectangle = new Cesium.BoundingRectangle(0, 0, 80, 40);
     */
    rectangle: BoundingRectangle;
    /**
     * The surface appearance of the viewport quad.  This can be one of several built-in {@link Material} objects or a custom material, scripted with
     * {@link https://github.com/CesiumGS/cesium/wiki/Fabric|Fabric}.
     * <p>
     * The default material is <code>Material.ColorType</code>.
     * </p>
     * @example
     * // 1. Change the color of the default material to yellow
     * viewportQuad.material.uniforms.color = new Cesium.Color(1.0, 1.0, 0.0, 1.0);
     *
     * // 2. Change material to horizontal stripes
     * viewportQuad.material = Cesium.Material.fromType(Cesium.Material.StripeType);
     */
    material: Material;
    /**
     * Called when {@link Viewer} or {@link CesiumWidget} render the scene to
     * get the draw commands needed to render this primitive.
     * <p>
     * Do not call this function directly.  This is documented just to
     * list the exceptions that may be propagated when the scene is rendered:
     * </p>
     */
    update(): void;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * @returns True if this object was destroyed; otherwise, false.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     * @example
     * quad = quad && quad.destroy();
     */
    destroy(): void;
}

/**
 * A primitive that renders voxel data from a {@link VoxelProvider}.
 * @param [options] - Object with the following properties:
 * @param [options.provider] - The voxel provider that supplies the primitive with tile data.
 * @param [options.modelMatrix = Matrix4.IDENTITY] - The model matrix used to transform the primitive.
 * @param [options.customShader] - The custom shader used to style the primitive.
 * @param [options.clock] - The clock used to control time dynamic behavior.
 */
export class VoxelPrimitive {
    constructor(options?: {
        provider?: VoxelProvider;
        modelMatrix?: Matrix4;
        customShader?: CustomShader;
        clock?: Clock;
    });
    /**
     * Gets a value indicating whether or not the primitive is ready for use.
     */
    readonly ready: boolean;
    /**
     * Gets the {@link VoxelProvider} associated with this primitive.
     */
    readonly provider: VoxelProvider;
    /**
     * Gets the bounding sphere.
     */
    readonly boundingSphere: BoundingSphere;
    /**
     * Gets the oriented bounding box.
     */
    readonly orientedBoundingBox: OrientedBoundingBox;
    /**
     * Gets the model matrix.
     */
    readonly modelMatrix: Matrix4;
    /**
     * Gets the shape type.
     */
    readonly shape: VoxelShapeType;
    /**
     * Gets the voxel dimensions.
     */
    readonly dimensions: Cartesian3;
    /**
     * Gets the minimum value per channel of the voxel data.
     */
    readonly minimumValues: number[][];
    /**
     * Gets the maximum value per channel of the voxel data.
     */
    readonly maximumValues: number[][];
    /**
     * Gets or sets whether or not this primitive should be displayed.
     */
    show: boolean;
    /**
     * Gets or sets whether or not the primitive should update when the view changes.
     */
    disableUpdate: boolean;
    /**
     * Gets or sets whether or not to render debug visualizations.
     */
    debugDraw: boolean;
    /**
     * Gets or sets whether or not to test against depth when rendering.
     */
    depthTest: boolean;
    /**
     * Gets or sets whether or not to jitter the view ray during the raymarch.
     * This reduces stair-step artifacts but introduces noise.
     */
    jitter: boolean;
    /**
     * Gets or sets the nearest sampling.
     */
    nearestSampling: boolean;
    /**
     * Gets or sets the screen space error in pixels. If the screen space size
     * of a voxel is greater than the screen space error, the tile is subdivided.
     * Lower screen space error corresponds with higher detail rendering, but could
     * result in worse performance and higher memory consumption.
     */
    screenSpaceError: number;
    /**
     * Gets or sets the step size multiplier used during raymarching.
     * The lower the value, the higher the rendering quality, but
     * also the worse the performance.
     */
    stepSize: number;
    /**
     * Gets or sets the minimum bounds in the shape's local coordinate system.
     * Voxel data is stretched or squashed to fit the bounds.
     */
    minBounds: Cartesian3;
    /**
     * Gets or sets the maximum bounds in the shape's local coordinate system.
     * Voxel data is stretched or squashed to fit the bounds.
     */
    maxBounds: Cartesian3;
    /**
     * Gets or sets the minimum clipping location in the shape's local coordinate system.
     * Any voxel content outside the range is clipped.
     */
    minClippingBounds: Cartesian3;
    /**
     * Gets or sets the maximum clipping location in the shape's local coordinate system.
     * Any voxel content outside the range is clipped.
     */
    maxClippingBounds: Cartesian3;
    /**
     * The {@link ClippingPlaneCollection} used to selectively disable rendering the primitive.
     */
    clippingPlanes: ClippingPlaneCollection;
    /**
     * Gets or sets the custom shader. If undefined, {@link VoxelPrimitive.DefaultCustomShader} is set.
     */
    customShader: CustomShader;
    /**
     * Gets an event that is raised whenever a custom shader is compiled.
     */
    readonly customShaderCompilationEvent: Event;
    /**
     * Returns true if this object was destroyed; otherwise, false.
     * <br /><br />
     * If this object was destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.
     * @returns <code>true</code> if this object was destroyed; otherwise, <code>false</code>.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the WebGL resources held by this object.  Destroying an object allows for deterministic
     * release of WebGL resources, instead of relying on the garbage collector to destroy this object.
     * <br /><br />
     * Once an object is destroyed, it should not be used; calling any function other than
     * <code>isDestroyed</code> will result in a {@link DeveloperError} exception.  Therefore,
     * assign the return value (<code>undefined</code>) to the object as done in the example.
     * @example
     * voxelPrimitive = voxelPrimitive && voxelPrimitive.destroy();
     */
    destroy(): void;
}

/**
 * Provides voxel data. Intended to be used with {@link VoxelPrimitive}.
 * This type describes an interface and is not intended to be instantiated directly.
 */
export class VoxelProvider {
    constructor();
    /**
     * A transform from local space to global space. If undefined, the identity matrix will be used instead.
     */
    readonly globalTransform: Matrix4 | undefined;
    /**
     * A transform from shape space to local space. If undefined, the identity matrix will be used instead.
     */
    readonly shapeTransform: Matrix4 | undefined;
    /**
     * Gets the {@link VoxelShapeType}
     * This should not be called before {@link VoxelProvider#ready} returns true.
     */
    readonly shape: VoxelShapeType;
    /**
     * Gets the minimum bounds.
     * If undefined, the shape's default minimum bounds will be used instead.
     * This should not be called before {@link VoxelProvider#ready} returns true.
     */
    readonly minBounds: Cartesian3 | undefined;
    /**
     * Gets the maximum bounds.
     * If undefined, the shape's default maximum bounds will be used instead.
     * This should not be called before {@link VoxelProvider#ready} returns true.
     */
    readonly maxBounds: Cartesian3 | undefined;
    /**
     * Gets the number of voxels per dimension of a tile. This is the same for all tiles in the dataset.
     * This should not be called before {@link VoxelProvider#ready} returns true.
     */
    readonly dimensions: Cartesian3;
    /**
     * Gets the number of padding voxels before the tile. This improves rendering quality when sampling the edge of a tile, but it increases memory usage.
     * This should not be called before {@link VoxelProvider#ready} returns true.
     */
    readonly paddingBefore: Cartesian3 | undefined;
    /**
     * Gets the number of padding voxels after the tile. This improves rendering quality when sampling the edge of a tile, but it increases memory usage.
     * This should not be called before {@link VoxelProvider#ready} returns true.
     */
    readonly paddingAfter: Cartesian3 | undefined;
    /**
     * Gets the metadata names.
     * This should not be called before {@link VoxelProvider#ready} returns true.
     */
    readonly names: string[];
    /**
     * Gets the metadata types.
     * This should not be called before {@link VoxelProvider#ready} returns true.
     */
    readonly types: MetadataType[];
    /**
     * Gets the metadata component types.
     * This should not be called before {@link VoxelProvider#ready} returns true.
     */
    readonly componentTypes: MetadataComponentType[];
    /**
     * Gets the metadata minimum values.
     * This should not be called before {@link VoxelProvider#ready} returns true.
     */
    readonly minimumValues: number[][] | undefined;
    /**
     * Gets the metadata maximum values.
     * This should not be called before {@link VoxelProvider#ready} returns true.
     */
    readonly maximumValues: number[][] | undefined;
    /**
     * The maximum number of tiles that exist for this provider. This value is used as a hint to the voxel renderer to allocate an appropriate amount of GPU memory. If this value is not known it can be undefined.
     * This should not be called before {@link VoxelProvider#ready} returns true.
     */
    readonly maximumTileCount: number | undefined;
    /**
     * Requests the data for a given tile. The data is a flattened 3D array ordered by X, then Y, then Z.
     * This function should not be called before {@link VoxelProvider#ready} returns true.
     * @param [options] - Object with the following properties:
     * @param [options.tileLevel = 0] - The tile's level.
     * @param [options.tileX = 0] - The tile's X coordinate.
     * @param [options.tileY = 0] - The tile's Y coordinate.
     * @param [options.tileZ = 0] - The tile's Z coordinate.
     * @returns A promise to an array of typed arrays containing the requested voxel data or undefined if there was a problem loading the data.
     */
    requestData(options?: {
        tileLevel?: number;
        tileX?: number;
        tileY?: number;
        tileZ?: number;
    }): Promise<any[][]> | undefined;
}

export const shaderUniforms: {
    [key: string]: any;
};

export const shaderDefines: {
    [key: string]: any;
};

/**
 * The maximum number of intersections against the shape for any ray direction.
 */
export const shaderMaximumIntersectionsLength: number;

/**
 * An enum of voxel shapes. The shape controls how the voxel grid is mapped to 3D space.
 */
export enum VoxelShapeType {
    /**
     * A box shape.
     */
    BOX = "BOX",
    /**
     * An ellipsoid shape.
     */
    ELLIPSOID = "ELLIPSOID",
    /**
     * A cylinder shape.
     */
    CYLINDER = "CYLINDER"
}

/**
 * EPSG codes known to include reverse axis orders, but are not within 4000-5000.
 */
export const includesReverseAxis: number[];

/**
 * EPSG codes known to not include reverse axis orders, and are within 4000-5000.
 */
export const excludesReverseAxis: number[];

export namespace WebMapServiceImageryProvider {
    /**
     * Initialization options for the WebMapServiceImageryProvider constructor
     * url - The URL of the WMS service. The URL supports the same keywords as the {@link UrlTemplateImageryProvider}.
     * layers - The layers to include, separated by commas.
     * [parameters = WebMapServiceImageryProvider.DefaultParameters] - Additional parameters to pass to the WMS server in the GetMap URL.
     * [getFeatureInfoParameters = WebMapServiceImageryProvider.GetFeatureInfoDefaultParameters] - Additional parameters to pass to the WMS server in the GetFeatureInfo URL.
     * [enablePickFeatures = true] - If true, {@link WebMapServiceImageryProvider#pickFeatures} will invoke
     *        the GetFeatureInfo operation on the WMS server and return the features included in the response.  If false,
     *        {@link WebMapServiceImageryProvider#pickFeatures} will immediately return undefined (indicating no pickable features)
     *        without communicating with the server.  Set this property to false if you know your WMS server does not support
     *        GetFeatureInfo or if you don't want this provider's features to be pickable. Note that this can be dynamically
     *        overridden by modifying the WebMapServiceImageryProvider#enablePickFeatures property.
     * [getFeatureInfoFormats = WebMapServiceImageryProvider.DefaultGetFeatureInfoFormats] - The formats
     *        in which to try WMS GetFeatureInfo requests.
     * [rectangle = Rectangle.MAX_VALUE] - The rectangle of the layer.
     * [tilingScheme = new GeographicTilingScheme()] - The tiling scheme to use to divide the world into tiles.
     * [ellipsoid] - The ellipsoid.  If the tilingScheme is specified,
     *        this parameter is ignored and the tiling scheme's ellipsoid is used instead. If neither
     *        parameter is specified, the WGS84 ellipsoid is used.
     * [tileWidth = 256] - The width of each tile in pixels.
     * [tileHeight = 256] - The height of each tile in pixels.
     * [minimumLevel = 0] - The minimum level-of-detail supported by the imagery provider.  Take care when
     *        specifying this that the number of tiles at the minimum level is small, such as four or less.  A larger number is
     *        likely to result in rendering problems.
     * [maximumLevel] - The maximum level-of-detail supported by the imagery provider, or undefined if there is no limit.
     *        If not specified, there is no limit.
     * [crs] - CRS specification, for use with WMS specification >= 1.3.0.
     * [srs] - SRS specification, for use with WMS specification 1.1.0 or 1.1.1
     * [credit] - A credit for the data source, which is displayed on the canvas.
     * [subdomains = 'abc'] - The subdomains to use for the <code>{s}</code> placeholder in the URL template.
     *                          If this parameter is a single string, each character in the string is a subdomain.  If it is
     *                          an array, each element in the array is a subdomain.
     * [clock] - A Clock instance that is used when determining the value for the time dimension. Required when `times` is specified.
     * [times] - TimeIntervalCollection with its data property being an object containing time dynamic dimension and their values.
     * [getFeatureInfoUrl] - The getFeatureInfo URL of the WMS service. If the property is not defined then we use the property value of url.
     */
    type ConstructorOptions = {
        url: Resource | string;
        layers: string;
        parameters?: any;
        getFeatureInfoParameters?: any;
        enablePickFeatures?: boolean;
        getFeatureInfoFormats?: GetFeatureInfoFormat[];
        rectangle?: Rectangle;
        tilingScheme?: TilingScheme;
        ellipsoid?: Ellipsoid;
        tileWidth?: number;
        tileHeight?: number;
        minimumLevel?: number;
        maximumLevel?: number;
        crs?: string;
        srs?: string;
        credit?: Credit | string;
        subdomains?: string | string[];
        clock?: Clock;
        times?: TimeIntervalCollection;
        getFeatureInfoUrl?: Resource | string;
    };
}

/**
 * Provides tiled imagery hosted by a Web Map Service (WMS) server.
 * @example
 * const provider = new Cesium.WebMapServiceImageryProvider({
 *     url : 'https://sampleserver1.arcgisonline.com/ArcGIS/services/Specialty/ESRI_StatesCitiesRivers_USA/MapServer/WMSServer',
 *     layers : '0',
 *     proxy: new Cesium.DefaultProxy('/proxy/')
 * });
 * const imageryLayer = new Cesium.ImageryLayer(provider);
 * viewer.imageryLayers.add(imageryLayer);
 * @param options - Object describing initialization options
 */
export class WebMapServiceImageryProvider {
    constructor(options: WebMapServiceImageryProvider.ConstructorOptions);
    /**
     * Gets the URL of the WMS server.
     */
    readonly url: string;
    /**
     * Gets the proxy used by this provider.
     */
    readonly proxy: Proxy;
    /**
     * Gets the names of the WMS layers, separated by commas.
     */
    readonly layers: string;
    /**
     * Gets the width of each tile, in pixels.
     */
    readonly tileWidth: number;
    /**
     * Gets the height of each tile, in pixels.
     */
    readonly tileHeight: number;
    /**
     * Gets the maximum level-of-detail that can be requested.
     */
    readonly maximumLevel: number | undefined;
    /**
     * Gets the minimum level-of-detail that can be requested.
     */
    readonly minimumLevel: number;
    /**
     * Gets the tiling scheme used by this provider.
     */
    readonly tilingScheme: TilingScheme;
    /**
     * Gets the rectangle, in radians, of the imagery provided by this instance.
     */
    readonly rectangle: Rectangle;
    /**
     * Gets the tile discard policy.  If not undefined, the discard policy is responsible
     * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
     * returns undefined, no tiles are filtered.
     */
    readonly tileDiscardPolicy: TileDiscardPolicy;
    /**
     * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
     * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
     * are passed an instance of {@link TileProviderError}.
     */
    readonly errorEvent: Event;
    /**
     * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
     * the source of the imagery.
     */
    readonly credit: Credit;
    /**
     * Gets a value indicating whether or not the images provided by this imagery provider
     * include an alpha channel.  If this property is false, an alpha channel, if present, will
     * be ignored.  If this property is true, any images without an alpha channel will be treated
     * as if their alpha is 1.0 everywhere.  When this property is false, memory usage
     * and texture upload time are reduced.
     */
    readonly hasAlphaChannel: boolean;
    /**
     * Gets or sets a value indicating whether feature picking is enabled.  If true, {@link WebMapServiceImageryProvider#pickFeatures} will
     * invoke the <code>GetFeatureInfo</code> service on the WMS server and attempt to interpret the features included in the response.  If false,
     * {@link WebMapServiceImageryProvider#pickFeatures} will immediately return undefined (indicating no pickable
     * features) without communicating with the server.  Set this property to false if you know your data
     * source does not support picking features or if you don't want this provider's features to be pickable.
     */
    enablePickFeatures: boolean;
    /**
     * Gets or sets a clock that is used to get keep the time used for time dynamic parameters.
     */
    clock: Clock;
    /**
     * Gets or sets a time interval collection that is used to get time dynamic parameters. The data of each
     * TimeInterval is an object containing the keys and values of the properties that are used during
     * tile requests.
     */
    times: TimeIntervalCollection;
    /**
     * Gets the getFeatureInfo URL of the WMS server.
     */
    readonly getFeatureInfoUrl: Resource | string;
    /**
     * Gets the credits to be displayed when a given tile is displayed.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level;
     * @returns The credits to be displayed when the tile is displayed.
     */
    getTileCredits(x: number, y: number, level: number): Credit[];
    /**
     * Requests the image for a given tile.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level.
     * @param [request] - The request object. Intended for internal use only.
     * @returns A promise for the image that will resolve when the image is available, or
     *          undefined if there are too many active requests to the server, and the request should be retried later.
     */
    requestImage(x: number, y: number, level: number, request?: Request): Promise<ImageryTypes> | undefined;
    /**
     * Asynchronously determines what features, if any, are located at a given longitude and latitude within
     * a tile.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level.
     * @param longitude - The longitude at which to pick features.
     * @param latitude - The latitude at which to pick features.
     * @returns A promise for the picked features that will resolve when the asynchronous
     *                   picking completes.  The resolved value is an array of {@link ImageryLayerFeatureInfo}
     *                   instances.  The array may be empty if no features are found at the given location.
     */
    pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): Promise<ImageryLayerFeatureInfo[]> | undefined;
    /**
     * The default parameters to include in the WMS URL to obtain images.  The values are as follows:
     *    service=WMS
     *    version=1.1.1
     *    request=GetMap
     *    styles=
     *    format=image/jpeg
     */
    static readonly DefaultParameters: any;
    /**
     * The default parameters to include in the WMS URL to get feature information.  The values are as follows:
     *     service=WMS
     *     version=1.1.1
     *     request=GetFeatureInfo
     */
    static readonly GetFeatureInfoDefaultParameters: any;
}

export namespace WebMapTileServiceImageryProvider {
    /**
     * Initialization options for the WebMapTileServiceImageryProvider constructor
     * url - The base URL for the WMTS GetTile operation (for KVP-encoded requests) or the tile-URL template (for RESTful requests). The tile-URL template should contain the following variables: &#123;style&#125;, &#123;TileMatrixSet&#125;, &#123;TileMatrix&#125;, &#123;TileRow&#125;, &#123;TileCol&#125;. The first two are optional if actual values are hardcoded or not required by the server. The &#123;s&#125; keyword may be used to specify subdomains.
     * [format = 'image/jpeg'] - The MIME type for images to retrieve from the server.
     * layer - The layer name for WMTS requests.
     * style - The style name for WMTS requests.
     * tileMatrixSetID - The identifier of the TileMatrixSet to use for WMTS requests.
     * [tileMatrixLabels] - A list of identifiers in the TileMatrix to use for WMTS requests, one per TileMatrix level.
     * [clock] - A Clock instance that is used when determining the value for the time dimension. Required when `times` is specified.
     * [times] - TimeIntervalCollection with its <code>data</code> property being an object containing time dynamic dimension and their values.
     * [dimensions] - A object containing static dimensions and their values.
     * [tileWidth = 256] - The tile width in pixels.
     * [tileHeight = 256] - The tile height in pixels.
     * [tilingScheme] - The tiling scheme corresponding to the organization of the tiles in the TileMatrixSet.
     * [rectangle = Rectangle.MAX_VALUE] - The rectangle covered by the layer.
     * [minimumLevel = 0] - The minimum level-of-detail supported by the imagery provider.
     * [maximumLevel] - The maximum level-of-detail supported by the imagery provider, or undefined if there is no limit.
     * [ellipsoid] - The ellipsoid.  If not specified, the WGS84 ellipsoid is used.
     * [credit] - A credit for the data source, which is displayed on the canvas.
     * [subdomains = 'abc'] - The subdomains to use for the <code>{s}</code> placeholder in the URL template.
     *                          If this parameter is a single string, each character in the string is a subdomain.  If it is
     *                          an array, each element in the array is a subdomain.
     */
    type ConstructorOptions = {
        url: Resource | string;
        format?: string;
        layer: string;
        style: string;
        tileMatrixSetID: string;
        tileMatrixLabels?: any[];
        clock?: Clock;
        times?: TimeIntervalCollection;
        dimensions?: any;
        tileWidth?: number;
        tileHeight?: number;
        tilingScheme?: TilingScheme;
        rectangle?: Rectangle;
        minimumLevel?: number;
        maximumLevel?: number;
        ellipsoid?: Ellipsoid;
        credit?: Credit | string;
        subdomains?: string | string[];
    };
}

/**
 * Provides tiled imagery served by {@link http://www.opengeospatial.org/standards/wmts|WMTS 1.0.0} compliant servers.
 * This provider supports HTTP KVP-encoded and RESTful GetTile requests, but does not yet support the SOAP encoding.
 * @example
 * // Example 1. USGS shaded relief tiles (KVP)
 * const shadedRelief1 = new Cesium.WebMapTileServiceImageryProvider({
 *     url : 'http://basemap.nationalmap.gov/arcgis/rest/services/USGSShadedReliefOnly/MapServer/WMTS',
 *     layer : 'USGSShadedReliefOnly',
 *     style : 'default',
 *     format : 'image/jpeg',
 *     tileMatrixSetID : 'default028mm',
 *     // tileMatrixLabels : ['default028mm:0', 'default028mm:1', 'default028mm:2' ...],
 *     maximumLevel: 19,
 *     credit : new Cesium.Credit('U. S. Geological Survey')
 * });
 * viewer.imageryLayers.addImageryProvider(shadedRelief1);
 * @example
 * // Example 2. USGS shaded relief tiles (RESTful)
 * const shadedRelief2 = new Cesium.WebMapTileServiceImageryProvider({
 *     url : 'http://basemap.nationalmap.gov/arcgis/rest/services/USGSShadedReliefOnly/MapServer/WMTS/tile/1.0.0/USGSShadedReliefOnly/{Style}/{TileMatrixSet}/{TileMatrix}/{TileRow}/{TileCol}.jpg',
 *     layer : 'USGSShadedReliefOnly',
 *     style : 'default',
 *     format : 'image/jpeg',
 *     tileMatrixSetID : 'default028mm',
 *     maximumLevel: 19,
 *     credit : new Cesium.Credit('U. S. Geological Survey')
 * });
 * viewer.imageryLayers.addImageryProvider(shadedRelief2);
 * @example
 * // Example 3. NASA time dynamic weather data (RESTful)
 * const times = Cesium.TimeIntervalCollection.fromIso8601({
 *     iso8601: '2015-07-30/2017-06-16/P1D',
 *     dataCallback: function dataCallback(interval, index) {
 *         return {
 *             Time: Cesium.JulianDate.toIso8601(interval.start)
 *         };
 *     }
 * });
 * const weather = new Cesium.WebMapTileServiceImageryProvider({
 *     url : 'https://gibs.earthdata.nasa.gov/wmts/epsg4326/best/AMSR2_Snow_Water_Equivalent/default/{Time}/{TileMatrixSet}/{TileMatrix}/{TileRow}/{TileCol}.png',
 *     layer : 'AMSR2_Snow_Water_Equivalent',
 *     style : 'default',
 *     tileMatrixSetID : '2km',
 *     maximumLevel : 5,
 *     format : 'image/png',
 *     clock: clock,
 *     times: times,
 *     credit : new Cesium.Credit('NASA Global Imagery Browse Services for EOSDIS')
 * });
 * viewer.imageryLayers.addImageryProvider(weather);
 * @param options - Object describing initialization options
 */
export class WebMapTileServiceImageryProvider {
    constructor(options: WebMapTileServiceImageryProvider.ConstructorOptions);
    /**
     * Gets the URL of the service hosting the imagery.
     */
    readonly url: string;
    /**
     * Gets the proxy used by this provider.
     */
    readonly proxy: Proxy;
    /**
     * Gets the width of each tile, in pixels.
     */
    readonly tileWidth: number;
    /**
     * Gets the height of each tile, in pixels.
     */
    readonly tileHeight: number;
    /**
     * Gets the maximum level-of-detail that can be requested.
     */
    readonly maximumLevel: number | undefined;
    /**
     * Gets the minimum level-of-detail that can be requested.
     */
    readonly minimumLevel: number;
    /**
     * Gets the tiling scheme used by this provider.
     */
    readonly tilingScheme: TilingScheme;
    /**
     * Gets the rectangle, in radians, of the imagery provided by this instance.
     */
    readonly rectangle: Rectangle;
    /**
     * Gets the tile discard policy.  If not undefined, the discard policy is responsible
     * for filtering out "missing" tiles via its shouldDiscardImage function.  If this function
     * returns undefined, no tiles are filtered.
     */
    readonly tileDiscardPolicy: TileDiscardPolicy;
    /**
     * Gets an event that is raised when the imagery provider encounters an asynchronous error.  By subscribing
     * to the event, you will be notified of the error and can potentially recover from it.  Event listeners
     * are passed an instance of {@link TileProviderError}.
     */
    readonly errorEvent: Event;
    /**
     * Gets the mime type of images returned by this imagery provider.
     */
    readonly format: string;
    /**
     * Gets the credit to display when this imagery provider is active.  Typically this is used to credit
     * the source of the imagery.
     */
    readonly credit: Credit;
    /**
     * Gets a value indicating whether or not the images provided by this imagery provider
     * include an alpha channel.  If this property is false, an alpha channel, if present, will
     * be ignored.  If this property is true, any images without an alpha channel will be treated
     * as if their alpha is 1.0 everywhere.  When this property is false, memory usage
     * and texture upload time are reduced.
     */
    readonly hasAlphaChannel: boolean;
    /**
     * Gets or sets a clock that is used to get keep the time used for time dynamic parameters.
     */
    clock: Clock;
    /**
     * Gets or sets a time interval collection that is used to get time dynamic parameters. The data of each
     * TimeInterval is an object containing the keys and values of the properties that are used during
     * tile requests.
     */
    times: TimeIntervalCollection;
    /**
     * Gets or sets an object that contains static dimensions and their values.
     */
    dimensions: any;
    /**
     * Gets the credits to be displayed when a given tile is displayed.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level;
     * @returns The credits to be displayed when the tile is displayed.
     */
    getTileCredits(x: number, y: number, level: number): Credit[];
    /**
     * Requests the image for a given tile.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level.
     * @param [request] - The request object. Intended for internal use only.
     * @returns A promise for the image that will resolve when the image is available, or
     *          undefined if there are too many active requests to the server, and the request should be retried later.
     */
    requestImage(x: number, y: number, level: number, request?: Request): Promise<ImageryTypes> | undefined;
    /**
     * Picking features is not currently supported by this imagery provider, so this function simply returns
     * undefined.
     * @param x - The tile X coordinate.
     * @param y - The tile Y coordinate.
     * @param level - The tile level.
     * @param longitude - The longitude at which to pick features.
     * @param latitude - The latitude at which to pick features.
     * @returns Undefined since picking is not supported.
     */
    pickFeatures(x: number, y: number, level: number, longitude: number, latitude: number): undefined;
}

/**
 * height - The height.
 * color - The color at this height.
 */
export type createElevationBandMaterialEntry = {
    height: number;
    color: Color;
};

/**
 * entries - A list of elevation entries. They will automatically be sorted from lowest to highest. If there is only one entry and <code>extendsDownards</code> and <code>extendUpwards</code> are both <code>false</code>, they will both be set to <code>true</code>.
 * [extendDownwards = false] - If <code>true</code>, the band's minimum elevation color will extend infinitely downwards.
 * [extendUpwards = false] - If <code>true</code>, the band's maximum elevation color will extend infinitely upwards.
 */
export type createElevationBandMaterialBand = {
    entries: createElevationBandMaterialEntry[];
    extendDownwards?: boolean;
    extendUpwards?: boolean;
};

/**
 * Creates a {@link Material} that combines multiple layers of color/gradient bands and maps them to terrain heights.
 *
 * The shader does a binary search over all the heights to find out which colors are above and below a given height, and
 * interpolates between them for the final color. This material supports hundreds of entries relatively cheaply.
 * @example
 * scene.globe.material = Cesium.createElevationBandMaterial({
 *     scene : scene,
 *     layers : [{
 *         entries : [{
 *             height : 4200.0,
 *             color : new Cesium.Color(0.0, 0.0, 0.0, 1.0)
 *         }, {
 *             height : 8848.0,
 *             color : new Cesium.Color(1.0, 1.0, 1.0, 1.0)
 *         }],
 *         extendDownwards : true,
 *         extendUpwards : true,
 *     }, {
 *         entries : [{
 *             height : 7000.0,
 *             color : new Cesium.Color(1.0, 0.0, 0.0, 0.5)
 *         }, {
 *             height : 7100.0,
 *             color : new Cesium.Color(1.0, 0.0, 0.0, 0.5)
 *         }]
 *     }]
 * });
 * @param options - Object with the following properties:
 * @param options.scene - The scene where the visualization is taking place.
 * @param options.layers - A list of bands ordered from lowest to highest precedence.
 * @returns A new {@link Material} instance.
 */
export function createElevationBandMaterial(options: {
    scene: Scene;
    layers: createElevationBandMaterialBand[];
}): Material;

/**
 * Creates a {@link Cesium3DTileset} instance for the Google Photorealistic 3D Tiles tileset.
 * @example
 * Cesium.GoogleMaps.defaultApiKey = "your-api-key";
 *
 * const viewer = new Cesium.Viewer("cesiumContainer");
 *
 * try {
 *   const tileset = await Cesium.createGooglePhotorealistic3DTileset();
 *   viewer.scene.primitives.add(tileset));
 * } catch (error) {
 *   console.log(`Error creating tileset: ${error}`);
 * }
 * @param [key = GoogleMaps.defaultApiKey] - Your API key to access Google Photorealistic 3D Tiles. See {@link https://developers.google.com/maps/documentation/javascript/get-api-key} for instructions on how to create your own key.
 * @param [options] - An object describing initialization options.
 */
export function createGooglePhotorealistic3DTileset(key?: string, options?: Cesium3DTileset.ConstructorOptions): Promise<Cesium3DTileset>;

/**
 * Creates a {@link Cesium3DTileset} instance for the
 * {@link https://cesium.com/content/cesium-osm-buildings/|Cesium OSM Buildings}
 * tileset.
 * @example
 * // Create Cesium OSM Buildings with default styling
 * const viewer = new Cesium.Viewer("cesiumContainer");
 * try {
 *   const tileset = await Cesium.createOsmBuildingsAsync();
 *   viewer.scene.primitives.add(tileset));
 * } catch (error) {
 *   console.log(`Error creating tileset: ${error}`);
 * }
 * @example
 * // Create Cesium OSM Buildings with a custom style highlighting
 * // schools and hospitals.
 * const viewer = new Cesium.Viewer("cesiumContainer");
 * try {
 *   const tileset = await Cesium.createOsmBuildingsAsync({
 *     style: new Cesium.Cesium3DTileStyle({
 *       color: {
 *         conditions: [
 *           ["${feature['building']} === 'hospital'", "color('#0000FF')"],
 *           ["${feature['building']} === 'school'", "color('#00FF00')"],
 *           [true, "color('#ffffff')"]
 *         ]
 *       }
 *     })
 *   });
 *   viewer.scene.primitives.add(tileset));
 * } catch (error) {
 *   console.log(`Error creating tileset: ${error}`);
 * }
 * @param [options] - Construction options. Any options allowed by the {@link Cesium3DTileset} constructor
 *        may be specified here. In addition to those, the following properties are supported:
 * @param [options.defaultColor = Color.WHITE] - The default color to use for buildings
 *        that do not have a color. This parameter is ignored if <code>options.style</code> is specified.
 * @param [options.style] - The style to use with the tileset. If not
 *        specified, a default style is used which gives each building or building part a
 *        color inferred from its OpenStreetMap <code>tags</code>. If no color can be inferred,
 *        <code>options.defaultColor</code> is used.
 * @param [options.enableShowOutline = true] - If true, enable rendering outlines. This can be set to false to avoid the additional processing of geometry at load time.
 * @param [options.showOutline = true] - Whether to show outlines around buildings. When true,
 *        outlines are displayed. When false, outlines are not displayed.
 */
export function createOsmBuildingsAsync(options?: {
    defaultColor?: Color;
    style?: Cesium3DTileStyle;
    enableShowOutline?: boolean;
    showOutline?: boolean;
}): Promise<Cesium3DTileset>;

/**
 * Creates a {@link Primitive} to visualize well-known vector vertex attributes:
 * <code>normal</code>, <code>tangent</code>, and <code>bitangent</code>.  Normal
 * is red; tangent is green; and bitangent is blue.  If an attribute is not
 * present, it is not drawn.
 * @example
 * scene.primitives.add(Cesium.createTangentSpaceDebugPrimitive({
 *    geometry : instance.geometry,
 *    length : 100000.0,
 *    modelMatrix : instance.modelMatrix
 * }));
 * @param options - Object with the following properties:
 * @param options.geometry - The <code>Geometry</code> instance with the attribute.
 * @param [options.length = 10000.0] - The length of each line segment in meters.  This can be negative to point the vector in the opposite direction.
 * @param [options.modelMatrix = Matrix4.IDENTITY] - The model matrix that transforms to transform the geometry from model to world coordinates.
 * @returns A new <code>Primitive</code> instance with geometry for the vectors.
 */
export function createTangentSpaceDebugPrimitive(options: {
    geometry: Geometry;
    length?: number;
    modelMatrix?: Matrix4;
}): Primitive;

/**
 * Creates an {@link IonImageryProvider} instance for ion's default global base imagery layer, currently Bing Maps.
 * @example
 * // Create a Cesium World Imagery base layer with default settings
 * try {
 *   const imageryProvider = await Cesium.createWorldImageryAsync();
 * } catch (error) {
 *   console.log(`There was an error creating world imagery: ${error}`);
 * }
 * @example
 * // Create Cesium World Imagery with different style
 * try {
 *   const imageryProvider = await Cesium.createWorldImageryAsync({
 *         style: Cesium.IonWorldImageryStyle.AERIAL_WITH_LABELS
 *   });
 * } catch (error) {
 *   console.log(`There was an error creating world imagery: ${error}`);
 * }
 * @param [options] - Object with the following properties:
 * @param [options.style = IonWorldImageryStyle] - The style of base imagery, only AERIAL, AERIAL_WITH_LABELS, and ROAD are currently supported.
 */
export function createWorldImageryAsync(options?: {
    style?: IonWorldImageryStyle;
}): Promise<IonImageryProvider>;

/**
 * A widget containing a Cesium scene.
 * @example
 * // For each example, include a link to CesiumWidget.css stylesheet in HTML head,
 * // and in the body, include: <div id="cesiumContainer"></div>
 *
 * // Widget with no terrain and default Bing Maps imagery provider.
 * const widget = new Cesium.CesiumWidget("cesiumContainer");
 *
 * // Widget with ion imagery and Cesium World Terrain.
 * const widget2 = new Cesium.CesiumWidget("cesiumContainer", {
 *     baseLayer: Cesium.ImageryLayer.fromWorldTerrain(),
 *     terrain: Cesium.Terrain.fromWorldTerrain()
 *     skyBox: new Cesium.SkyBox({
 *       sources: {
 *         positiveX: "stars/TychoSkymapII.t3_08192x04096_80_px.jpg",
 *         negativeX: "stars/TychoSkymapII.t3_08192x04096_80_mx.jpg",
 *         positiveY: "stars/TychoSkymapII.t3_08192x04096_80_py.jpg",
 *         negativeY: "stars/TychoSkymapII.t3_08192x04096_80_my.jpg",
 *         positiveZ: "stars/TychoSkymapII.t3_08192x04096_80_pz.jpg",
 *         negativeZ: "stars/TychoSkymapII.t3_08192x04096_80_mz.jpg"
 *       }
 *     }),
 *     // Show Columbus View map with Web Mercator projection
 *     sceneMode: Cesium.SceneMode.COLUMBUS_VIEW,
 *     mapProjection: new Cesium.WebMercatorProjection()
 * });
 * @param container - The DOM element or ID that will contain the widget.
 * @param [options] - Object with the following properties:
 * @param [options.clock = new Clock()] - The clock to use to control current time.
 * @param [options.baseLayer = ImageryLayer.fromWorldImagery()] - The bottommost imagery layer applied to the globe. If set to <code>false</code>, no imagery provider will be added.
 * @param [options.terrainProvider = new EllipsoidTerrainProvider] - The terrain provider.
 * @param [options.terrain] - A terrain object which handles asynchronous terrain provider. Can only specify if options.terrainProvider is undefined.
 * @param [options.skyBox] - The skybox used to render the stars.  When <code>undefined</code>, the default stars are used. If set to <code>false</code>, no skyBox, Sun, or Moon will be added.
 * @param [options.skyAtmosphere] - Blue sky, and the glow around the Earth's limb.  Set to <code>false</code> to turn it off.
 * @param [options.sceneMode = SceneMode.SCENE3D] - The initial scene mode.
 * @param [options.scene3DOnly = false] - When <code>true</code>, each geometry instance will only be rendered in 3D to save GPU memory.
 * @param [options.orderIndependentTranslucency = true] - If true and the configuration supports it, use order independent translucency.
 * @param [options.mapProjection = new GeographicProjection()] - The map projection to use in 2D and Columbus View modes.
 * @param [options.globe = new Globe(mapProjection.ellipsoid)] - The globe to use in the scene.  If set to <code>false</code>, no globe will be added and the sky atmosphere will be hidden by default.
 * @param [options.useDefaultRenderLoop = true] - True if this widget should control the render loop, false otherwise.
 * @param [options.useBrowserRecommendedResolution = true] - If true, render at the browser's recommended resolution and ignore <code>window.devicePixelRatio</code>.
 * @param [options.targetFrameRate] - The target frame rate when using the default render loop.
 * @param [options.showRenderLoopErrors = true] - If true, this widget will automatically display an HTML panel to the user containing the error, if a render loop error occurs.
 * @param [options.contextOptions] - Context and WebGL creation properties passed to {@link Scene}.
 * @param [options.creditContainer] - The DOM element or ID that will contain the {@link CreditDisplay}.  If not specified, the credits are added
 *        to the bottom of the widget itself.
 * @param [options.creditViewport] - The DOM element or ID that will contain the credit pop up created by the {@link CreditDisplay}.  If not specified, it will appear over the widget itself.
 * @param [options.shadows = false] - Determines if shadows are cast by light sources.
 * @param [options.terrainShadows = ShadowMode.RECEIVE_ONLY] - Determines if the terrain casts or receives shadows from light sources.
 * @param [options.mapMode2D = MapMode2D.INFINITE_SCROLL] - Determines if the 2D map is rotatable or can be scrolled infinitely in the horizontal direction.
 * @param [options.blurActiveElementOnCanvasFocus = true] - If true, the active element will blur when the viewer's canvas is clicked. Setting this to false is useful for cases when the canvas is clicked only for retrieving position or an entity data without actually meaning to set the canvas to be the active element.
 * @param [options.requestRenderMode = false] - If true, rendering a frame will only occur when needed as determined by changes within the scene. Enabling improves performance of the application, but requires using {@link Scene#requestRender} to render a new frame explicitly in this mode. This will be necessary in many cases after making changes to the scene in other parts of the API. See {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}.
 * @param [options.maximumRenderTimeChange = 0.0] - If requestRenderMode is true, this value defines the maximum change in simulation time allowed before a render is requested. See {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}.
 * @param [options.msaaSamples = 1] - If provided, this value controls the rate of multisample antialiasing. Typical multisampling rates are 2, 4, and sometimes 8 samples per pixel. Higher sampling rates of MSAA may impact performance in exchange for improved visual quality. This value only applies to WebGL2 contexts that support multisample render targets.
 */
export class CesiumWidget {
    constructor(container: Element | string, options?: {
        clock?: Clock;
        baseLayer?: ImageryLayer | false;
        terrainProvider?: TerrainProvider;
        terrain?: Terrain;
        skyBox?: SkyBox | false;
        skyAtmosphere?: SkyAtmosphere | false;
        sceneMode?: SceneMode;
        scene3DOnly?: boolean;
        orderIndependentTranslucency?: boolean;
        mapProjection?: MapProjection;
        globe?: Globe | false;
        useDefaultRenderLoop?: boolean;
        useBrowserRecommendedResolution?: boolean;
        targetFrameRate?: number;
        showRenderLoopErrors?: boolean;
        contextOptions?: ContextOptions;
        creditContainer?: Element | string;
        creditViewport?: Element | string;
        shadows?: boolean;
        terrainShadows?: ShadowMode;
        mapMode2D?: MapMode2D;
        blurActiveElementOnCanvasFocus?: boolean;
        requestRenderMode?: boolean;
        maximumRenderTimeChange?: number;
        msaaSamples?: number;
    });
    /**
     * Gets the parent container.
     */
    readonly container: Element;
    /**
     * Gets the canvas.
     */
    readonly canvas: HTMLCanvasElement;
    /**
     * Gets the credit container.
     */
    readonly creditContainer: Element;
    /**
     * Gets the credit viewport
     */
    readonly creditViewport: Element;
    /**
     * Gets the scene.
     */
    readonly scene: Scene;
    /**
     * Gets the collection of image layers that will be rendered on the globe.
     */
    readonly imageryLayers: ImageryLayerCollection;
    /**
     * The terrain provider providing surface geometry for the globe.
     */
    terrainProvider: TerrainProvider;
    /**
     * Manages the list of credits to display on screen and in the lightbox.
     */
    creditDisplay: CreditDisplay;
    /**
     * Gets the camera.
     */
    readonly camera: Camera;
    /**
     * Gets the clock.
     */
    readonly clock: Clock;
    /**
     * Gets the screen space event handler.
     */
    readonly screenSpaceEventHandler: ScreenSpaceEventHandler;
    /**
     * Gets or sets the target frame rate of the widget when <code>useDefaultRenderLoop</code>
     * is true. If undefined, the browser's requestAnimationFrame implementation
     * determines the frame rate.  If defined, this value must be greater than 0.  A value higher
     * than the underlying requestAnimationFrame implementation will have no effect.
     */
    targetFrameRate: number;
    /**
     * Gets or sets whether or not this widget should control the render loop.
     * If true the widget will use requestAnimationFrame to
     * perform rendering and resizing of the widget, as well as drive the
     * simulation clock. If set to false, you must manually call the
     * <code>resize</code>, <code>render</code> methods as part of a custom
     * render loop.  If an error occurs during rendering, {@link Scene}'s
     * <code>renderError</code> event will be raised and this property
     * will be set to false.  It must be set back to true to continue rendering
     * after the error.
     */
    useDefaultRenderLoop: boolean;
    /**
     * Gets or sets a scaling factor for rendering resolution.  Values less than 1.0 can improve
     * performance on less powerful devices while values greater than 1.0 will render at a higher
     * resolution and then scale down, resulting in improved visual fidelity.
     * For example, if the widget is laid out at a size of 640x480, setting this value to 0.5
     * will cause the scene to be rendered at 320x240 and then scaled up while setting
     * it to 2.0 will cause the scene to be rendered at 1280x960 and then scaled down.
     */
    resolutionScale: number;
    /**
     * Boolean flag indicating if the browser's recommended resolution is used.
     * If true, the browser's device pixel ratio is ignored and 1.0 is used instead,
     * effectively rendering based on CSS pixels instead of device pixels. This can improve
     * performance on less powerful devices that have high pixel density. When false, rendering
     * will be in device pixels. {@link CesiumWidget#resolutionScale} will still take effect whether
     * this flag is true or false.
     */
    useBrowserRecommendedResolution: boolean;
    /**
     * Show an error panel to the user containing a title and a longer error message,
     * which can be dismissed using an OK button.  This panel is displayed automatically
     * when a render loop error occurs, if showRenderLoopErrors was not false when the
     * widget was constructed.
     * @param title - The title to be displayed on the error panel.  This string is interpreted as text.
     * @param [message] - A helpful, user-facing message to display prior to the detailed error information.  This string is interpreted as HTML.
     * @param [error] - The error to be displayed on the error panel.  This string is formatted using {@link formatError} and then displayed as text.
     */
    showErrorPanel(title: string, message?: string, error?: string): void;
    /**
     * @returns true if the object has been destroyed, false otherwise.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the widget.  Should be called if permanently
     * removing the widget from layout.
     */
    destroy(): void;
    /**
     * Updates the canvas size, camera aspect ratio, and viewport size.
     * This function is called automatically as needed unless
     * <code>useDefaultRenderLoop</code> is set to false.
     */
    resize(): void;
    /**
     * Renders the scene.  This function is called automatically
     * unless <code>useDefaultRenderLoop</code> is set to false;
     */
    render(): void;
}

/**
 * <span style="display: block; text-align: center;">
 * <img src="Images/AnimationWidget.png" width="211" height="142" alt="" />
 * <br />Animation widget
 * </span>
 * <br /><br />
 * The Animation widget provides buttons for play, pause, and reverse, along with the
 * current time and date, surrounded by a "shuttle ring" for controlling the speed of animation.
 * <br /><br />
 * The "shuttle ring" concept is borrowed from video editing, where typically a
 * "jog wheel" can be rotated to move past individual animation frames very slowly, and
 * a surrounding shuttle ring can be twisted to control direction and speed of fast playback.
 * Cesium typically treats time as continuous (not broken into pre-defined animation frames),
 * so this widget offers no jog wheel.  Instead, the shuttle ring is capable of both fast and
 * very slow playback.  Click and drag the shuttle ring pointer itself (shown above in green),
 * or click in the rest of the ring area to nudge the pointer to the next preset speed in that direction.
 * <br /><br />
 * The Animation widget also provides a "realtime" button (in the upper-left) that keeps
 * animation time in sync with the end user's system clock, typically displaying
 * "today" or "right now."  This mode is not available in {@link ClockRange.CLAMPED} or
 * {@link ClockRange.LOOP_STOP} mode if the current time is outside of {@link Clock}'s startTime and endTime.
 * @example
 * // In HTML head, include a link to Animation.css stylesheet,
 * // and in the body, include: <div id="animationContainer"></div>
 *
 * const clock = new Cesium.Clock();
 * const clockViewModel = new Cesium.ClockViewModel(clock);
 * const viewModel = new Cesium.AnimationViewModel(clockViewModel);
 * const widget = new Cesium.Animation('animationContainer', viewModel);
 *
 * function tick() {
 *     clock.tick();
 *     requestAnimationFrame(tick);
 * }
 * requestAnimationFrame(tick);
 * @param container - The DOM element or ID that will contain the widget.
 * @param viewModel - The view model used by this widget.
 */
export class Animation {
    constructor(container: Element | string, viewModel: AnimationViewModel);
    /**
     * Gets the parent container.
     */
    readonly container: Element;
    /**
     * Gets the view model.
     */
    readonly viewModel: AnimationViewModel;
    /**
     * @returns true if the object has been destroyed, false otherwise.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the animation widget.  Should be called if permanently
     * removing the widget from layout.
     */
    destroy(): void;
    /**
     * Resizes the widget to match the container size.
     * This function should be called whenever the container size is changed.
     */
    resize(): void;
    /**
     * Updates the widget to reflect any modified CSS rules for theming.
     * @example
     * //Switch to the cesium-lighter theme.
     * document.body.className = 'cesium-lighter';
     * animation.applyThemeChanges();
     */
    applyThemeChanges(): void;
}

/**
 * The view model for the {@link Animation} widget.
 * @param clockViewModel - The ClockViewModel instance to use.
 */
export class AnimationViewModel {
    constructor(clockViewModel: ClockViewModel);
    /**
     * Gets or sets whether the shuttle ring is currently being dragged.  This property is observable.
     */
    shuttleRingDragging: boolean;
    /**
     * Gets or sets whether dragging the shuttle ring should cause the multiplier
     * to snap to the defined tick values rather than interpolating between them.
     * This property is observable.
     */
    snapToTicks: boolean;
    /**
     * Gets the string representation of the current time.  This property is observable.
     */
    timeLabel: string;
    /**
     * Gets the string representation of the current date.  This property is observable.
     */
    dateLabel: string;
    /**
     * Gets the string representation of the current multiplier.  This property is observable.
     */
    multiplierLabel: string;
    /**
     * Gets or sets the current shuttle ring angle.  This property is observable.
     */
    shuttleRingAngle: number;
    /**
     * Gets or sets the default date formatter used by new instances.
     */
    static defaultDateFormatter: AnimationViewModel.DateFormatter;
    /**
     * Gets or sets the default array of known clock multipliers associated with new instances of the shuttle ring.
     */
    static defaultTicks: number[];
    /**
     * Gets or sets the default time formatter used by new instances.
     */
    static defaultTimeFormatter: AnimationViewModel.TimeFormatter;
    /**
     * Gets a copy of the array of positive known clock multipliers to associate with the shuttle ring.
     * @returns The array of known clock multipliers associated with the shuttle ring.
     */
    getShuttleRingTicks(): number[];
    /**
     * Sets the array of positive known clock multipliers to associate with the shuttle ring.
     * These values will have negative equivalents created for them and sets both the minimum
     * and maximum range of values for the shuttle ring as well as the values that are snapped
     * to when a single click is made.  The values need not be in order, as they will be sorted
     * automatically, and duplicate values will be removed.
     * @param positiveTicks - The list of known positive clock multipliers to associate with the shuttle ring.
     */
    setShuttleRingTicks(positiveTicks: number[]): void;
    /**
     * Gets a command that decreases the speed of animation.
     */
    slower: Command;
    /**
     * Gets a command that increases the speed of animation.
     */
    faster: Command;
    /**
     * Gets the clock view model.
     */
    clockViewModel: ClockViewModel;
    /**
     * Gets the pause toggle button view model.
     */
    pauseViewModel: ToggleButtonViewModel;
    /**
     * Gets the reverse toggle button view model.
     */
    playReverseViewModel: ToggleButtonViewModel;
    /**
     * Gets the play toggle button view model.
     */
    playForwardViewModel: ToggleButtonViewModel;
    /**
     * Gets the realtime toggle button view model.
     */
    playRealtimeViewModel: ToggleButtonViewModel;
    /**
     * Gets or sets the function which formats a date for display.
     */
    dateFormatter: AnimationViewModel.DateFormatter;
    /**
     * Gets or sets the function which formats a time for display.
     */
    timeFormatter: AnimationViewModel.TimeFormatter;
}

export namespace AnimationViewModel {
    /**
     * A function that formats a date for display.
     * @param date - The date to be formatted
     * @param viewModel - The AnimationViewModel instance requesting formatting.
     */
    type DateFormatter = (date: JulianDate, viewModel: AnimationViewModel) => string;
    /**
     * A function that formats a time for display.
     * @param date - The date to be formatted
     * @param viewModel - The AnimationViewModel instance requesting formatting.
     */
    type TimeFormatter = (date: JulianDate, viewModel: AnimationViewModel) => string;
}

/**
 * <span style="display: block; text-align: center;">
 * <img src="Images/BaseLayerPicker.png" width="264" alt="BaseLayerPicker" />
 * <br />BaseLayerPicker with its drop-panel open.
 * </span>
 * <br /><br />
 * The BaseLayerPicker is a single button widget that displays a panel of available imagery and
 * terrain providers.  When imagery is selected, the corresponding imagery layer is created and inserted
 * as the base layer of the imagery collection; removing the existing base.  When terrain is selected,
 * it replaces the current terrain provider.  Each item in the available providers list contains a name,
 * a representative icon, and a tooltip to display more information when hovered. The list is initially
 * empty, and must be configured before use, as illustrated in the below example.
 * <br /><br />
 * By default, the BaseLayerPicker uses a default list of example providers for demonstration purposes.
 * Notably some of these providers, such as <a href="https://developers.arcgis.com" target="_blank">Esri ArcGIS</a> and <a href="https://docs.stadiamaps.com/ target="_blank">Stadia Maps</a>, have seperate terms of service and require authentication for production use.
 * @example
 * // In HTML head, include a link to the BaseLayerPicker.css stylesheet,
 * // and in the body, include: <div id="baseLayerPickerContainer"
 * //   style="position:absolute;top:24px;right:24px;width:38px;height:38px;"></div>
 *
 * //Create the list of available providers we would like the user to select from.
 * //This example uses 3, OpenStreetMap, The Black Marble, and a single, non-streaming world image.
 * const imageryViewModels = [];
 * imageryViewModels.push(new Cesium.ProviderViewModel({
 *      name: "Open\u00adStreet\u00adMap",
 *      iconUrl: Cesium.buildModuleUrl("Widgets/Images/ImageryProviders/openStreetMap.png"),
 *      tooltip: "OpenStreetMap (OSM) is a collaborative project to create a free editable \
 * map of the world.\nhttp://www.openstreetmap.org",
 *      creationFunction: function() {
 *          return new Cesium.OpenStreetMapImageryProvider({
 *              url: "https://tile.openstreetmap.org/"
 *          });
 *      }
 *  }));
 *
 *  imageryViewModels.push(new Cesium.ProviderViewModel({
 *      name: "Earth at Night",
 *      iconUrl: Cesium.buildModuleUrl("Widgets/Images/ImageryProviders/blackMarble.png"),
 *      tooltip: "The lights of cities and villages trace the outlines of civilization \
 * in this global view of the Earth at night as seen by NASA/NOAA's Suomi NPP satellite.",
 *      creationFunction: function() {
 *          return Cesium.IonImageryProvider.fromAssetId(3812);
 *      }
 *  }));
 *
 *  imageryViewModels.push(new Cesium.ProviderViewModel({
 *      name: "Natural Earth\u00a0II",
 *      iconUrl: Cesium.buildModuleUrl("Widgets/Images/ImageryProviders/naturalEarthII.png"),
 *      tooltip: "Natural Earth II, darkened for contrast.\nhttp://www.naturalearthdata.com/",
 *      creationFunction: function() {
 *          return Cesium.TileMapServiceImageryProvider.fromUrl(
 *              Cesium.buildModuleUrl("Assets/Textures/NaturalEarthII")
 *          );
 *      }
 *  }));
 *
 * //Create a CesiumWidget without imagery, if you haven't already done so.
 * const cesiumWidget = new Cesium.CesiumWidget("cesiumContainer", { baseLayer: false });
 *
 * //Finally, create the baseLayerPicker widget using our view models.
 * const layers = cesiumWidget.imageryLayers;
 * const baseLayerPicker = new Cesium.BaseLayerPicker("baseLayerPickerContainer", {
 *     globe: cesiumWidget.scene.globe,
 *     imageryProviderViewModels: imageryViewModels
 * });
 * @param container - The parent HTML container node or ID for this widget.
 * @param options - Object with the following properties:
 * @param options.globe - The Globe to use.
 * @param [options.imageryProviderViewModels = []] - The array of ProviderViewModel instances to use for imagery.
 * @param [options.selectedImageryProviderViewModel] - The view model for the current base imagery layer, if not supplied the first available imagery layer is used.
 * @param [options.terrainProviderViewModels = []] - The array of ProviderViewModel instances to use for terrain.
 * @param [options.selectedTerrainProviderViewModel] - The view model for the current base terrain layer, if not supplied the first available terrain layer is used.
 */
export class BaseLayerPicker {
    constructor(container: Element | string, options: {
        globe: Globe;
        imageryProviderViewModels?: ProviderViewModel[];
        selectedImageryProviderViewModel?: ProviderViewModel;
        terrainProviderViewModels?: ProviderViewModel[];
        selectedTerrainProviderViewModel?: ProviderViewModel;
    });
    /**
     * Gets the parent container.
     */
    container: Element;
    /**
     * Gets the view model.
     */
    viewModel: BaseLayerPickerViewModel;
    /**
     * @returns true if the object has been destroyed, false otherwise.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the widget.  Should be called if permanently
     * removing the widget from layout.
     */
    destroy(): void;
}

/**
 * The view model for {@link BaseLayerPicker}.
 * @param options - Object with the following properties:
 * @param options.globe - The Globe to use.
 * @param [options.imageryProviderViewModels = []] - The array of ProviderViewModel instances to use for imagery.
 * @param [options.selectedImageryProviderViewModel] - The view model for the current base imagery layer, if not supplied the first available imagery layer is used.
 * @param [options.terrainProviderViewModels = []] - The array of ProviderViewModel instances to use for terrain.
 * @param [options.selectedTerrainProviderViewModel] - The view model for the current base terrain layer, if not supplied the first available terrain layer is used.
 */
export class BaseLayerPickerViewModel {
    constructor(options: {
        globe: Globe;
        imageryProviderViewModels?: ProviderViewModel[];
        selectedImageryProviderViewModel?: ProviderViewModel;
        terrainProviderViewModels?: ProviderViewModel[];
        selectedTerrainProviderViewModel?: ProviderViewModel;
    });
    /**
     * Gets or sets an array of ProviderViewModel instances available for imagery selection.
     * This property is observable.
     */
    imageryProviderViewModels: ProviderViewModel[];
    /**
     * Gets or sets an array of ProviderViewModel instances available for terrain selection.
     * This property is observable.
     */
    terrainProviderViewModels: ProviderViewModel[];
    /**
     * Gets or sets whether the imagery selection drop-down is currently visible.
     */
    dropDownVisible: boolean;
    /**
     * Gets the button tooltip.  This property is observable.
     */
    buttonTooltip: string;
    /**
     * Gets the button background image.  This property is observable.
     */
    buttonImageUrl: string;
    /**
     * Gets or sets the currently selected imagery.  This property is observable.
     */
    selectedImagery: ProviderViewModel;
    /**
     * Gets or sets the currently selected terrain.  This property is observable.
     */
    selectedTerrain: ProviderViewModel;
    /**
     * Gets the command to toggle the visibility of the drop down.
     */
    toggleDropDown: Command;
    /**
     * Gets the globe.
     */
    globe: Globe;
}

/**
 * A view model that represents each item in the {@link BaseLayerPicker}.
 * @param options - The object containing all parameters.
 * @param options.name - The name of the layer.
 * @param options.tooltip - The tooltip to show when the item is moused over.
 * @param options.iconUrl - An icon representing the layer.
 * @param [options.category] - A category for the layer.
 * @param options.creationFunction - A function or Command
 *        that creates one or more providers which will be added to the globe when this item is selected.
 */
export class ProviderViewModel {
    constructor(options: {
        name: string;
        tooltip: string;
        iconUrl: string;
        category?: string;
        creationFunction: ProviderViewModel.CreationFunction | Command;
    });
    /**
     * Gets the display name.  This property is observable.
     */
    name: string;
    /**
     * Gets the tooltip.  This property is observable.
     */
    tooltip: string;
    /**
     * Gets the icon.  This property is observable.
     */
    iconUrl: string;
    /**
     * Gets the Command that creates one or more providers which will be added to
     * the globe when this item is selected.
     */
    readonly creationCommand: Command;
    /**
     * Gets the category
     */
    readonly category: string;
}

export namespace ProviderViewModel {
    /**
     * A function which creates one or more providers.
     */
    type CreationFunction = () => ImageryProvider | TerrainProvider | ImageryProvider[] | TerrainProvider[] | Promise<TerrainProvider> | Promise<ImageryProvider> | Promise<TerrainProvider[]> | Promise<ImageryProvider[]>;
}

/**
 * Inspector widget to aid in debugging 3D Tiles
 * @param container - The DOM element or ID that will contain the widget.
 * @param scene - the Scene instance to use.
 */
export class Cesium3DTilesInspector {
    constructor(container: Element | string, scene: Scene);
    /**
     * Gets the parent container.
     */
    container: Element;
    /**
     * Gets the view model.
     */
    viewModel: Cesium3DTilesInspectorViewModel;
    /**
     * @returns true if the object has been destroyed, false otherwise.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the widget.  Should be called if permanently
     * removing the widget from layout.
     */
    destroy(): void;
}

/**
 * The view model for {@link Cesium3DTilesInspector}.
 * @param scene - The scene instance to use.
 * @param performanceContainer - The container for the performance display
 */
export class Cesium3DTilesInspectorViewModel {
    constructor(scene: Scene, performanceContainer: HTMLElement);
    /**
     * Gets or sets the flag to enable performance display.  This property is observable.
     */
    performance: boolean;
    /**
     * Gets or sets the flag to show statistics.  This property is observable.
     */
    showStatistics: boolean;
    /**
     * Gets or sets the flag to show pick statistics.  This property is observable.
     */
    showPickStatistics: boolean;
    /**
     * Gets or sets the flag to show resource cache statistics. This property is
     * observable.
     */
    showResourceCacheStatistics: boolean;
    /**
     * Gets or sets the flag to show the inspector.  This property is observable.
     */
    inspectorVisible: boolean;
    /**
     * Gets or sets the flag to show the tileset section.  This property is observable.
     */
    tilesetVisible: boolean;
    /**
     * Gets or sets the flag to show the display section.  This property is observable.
     */
    displayVisible: boolean;
    /**
     * Gets or sets the flag to show the update section.  This property is observable.
     */
    updateVisible: boolean;
    /**
     * Gets or sets the flag to show the logging section.  This property is observable.
     */
    loggingVisible: boolean;
    /**
     * Gets or sets the flag to show the style section.  This property is observable.
     */
    styleVisible: boolean;
    /**
     * Gets or sets the flag to show the tile info section.  This property is observable.
     */
    tileDebugLabelsVisible: boolean;
    /**
     * Gets or sets the flag to show the optimization info section. This property is observable.
     */
    optimizationVisible: boolean;
    /**
     * Gets or sets the JSON for the tileset style.  This property is observable.
     */
    styleString: string;
    /**
     * Gets or sets the JSON for the tileset enableDebugWireframe attribute.  This property is observable.
     */
    hasEnabledWireframe: boolean;
    /**
     * Gets the names of the properties in the tileset.  This property is observable.
     */
    readonly properties: string[];
    /**
     * Gets or sets the flag to enable dynamic screen space error.  This property is observable.
     */
    dynamicScreenSpaceError: boolean;
    /**
     * Gets or sets the color blend mode.  This property is observable.
     */
    colorBlendMode: Cesium3DTileColorBlendMode;
    /**
     * Gets or sets the flag to enable picking.  This property is observable.
     */
    picking: boolean;
    /**
     * Gets or sets the flag to colorize tiles.  This property is observable.
     */
    colorize: boolean;
    /**
     * Gets or sets the flag to draw with wireframe.  This property is observable.
     */
    wireframe: boolean;
    /**
     * Gets or sets the flag to show bounding volumes.  This property is observable.
     */
    showBoundingVolumes: boolean;
    /**
     * Gets or sets the flag to show content volumes.  This property is observable.
     */
    showContentBoundingVolumes: boolean;
    /**
     * Gets or sets the flag to show request volumes.  This property is observable.
     */
    showRequestVolumes: boolean;
    /**
     * Gets or sets the flag to suspend updates.  This property is observable.
     */
    freezeFrame: boolean;
    /**
     * Gets or sets the flag to show debug labels only for the currently picked tile.  This property is observable.
     */
    showOnlyPickedTileDebugLabel: boolean;
    /**
     * Gets or sets the flag to show tile geometric error.  This property is observable.
     */
    showGeometricError: boolean;
    /**
     * Displays the number of commands, points, triangles and features used per tile.  This property is observable.
     */
    showRenderingStatistics: boolean;
    /**
     * Displays the memory used per tile.  This property is observable.
     */
    showMemoryUsage: boolean;
    /**
     * Gets or sets the flag to show the tile url.  This property is observable.
     */
    showUrl: boolean;
    /**
     * Gets or sets the maximum screen space error.  This property is observable.
     */
    maximumScreenSpaceError: number;
    /**
     * Gets or sets the dynamic screen space error density.  This property is observable.
     */
    dynamicScreenSpaceErrorDensity: number;
    /**
     * Gets or sets the dynamic screen space error density slider value.
     * This allows the slider to be exponential because values tend to be closer to 0 than 1.
     * This property is observable.
     */
    dynamicScreenSpaceErrorDensitySliderValue: number;
    /**
     * Gets or sets the dynamic screen space error factor.  This property is observable.
     */
    dynamicScreenSpaceErrorFactor: number;
    /**
     * Gets or sets the flag to enable point cloud shading. This property is observable.
     */
    pointCloudShading: boolean;
    /**
     * Gets or sets the geometric error scale.  This property is observable.
     */
    geometricErrorScale: number;
    /**
     * Gets or sets the maximum attenuation.  This property is observable.
     */
    maximumAttenuation: number;
    /**
     * Gets or sets the base resolution.  This property is observable.
     */
    baseResolution: number;
    /**
     * Gets or sets the flag to enable eye dome lighting. This property is observable.
     */
    eyeDomeLighting: boolean;
    /**
     * Gets or sets the eye dome lighting strength.  This property is observable.
     */
    eyeDomeLightingStrength: number;
    /**
     * Gets or sets the eye dome lighting radius.  This property is observable.
     */
    eyeDomeLightingRadius: number;
    /**
     * Gets or sets the pick state
     */
    pickActive: boolean;
    /**
     * Gets or sets the flag to determine if level of detail skipping should be applied during the traversal.
     * This property is observable.
     */
    skipLevelOfDetail: boolean;
    /**
     * Gets or sets the multiplier defining the minimum screen space error to skip. This property is observable.
     */
    skipScreenSpaceErrorFactor: number;
    /**
     * Gets or sets the screen space error that must be reached before skipping levels of detail. This property is observable.
     */
    baseScreenSpaceError: number;
    /**
     * Gets or sets the constant defining the minimum number of levels to skip when loading tiles. This property is observable.
     */
    skipLevels: number;
    /**
     * Gets or sets the flag which, when true, only tiles that meet the maximum screen space error will ever be downloaded.
     * This property is observable.
     */
    immediatelyLoadDesiredLevelOfDetail: boolean;
    /**
     * Gets or sets the flag which determines whether siblings of visible tiles are always downloaded during traversal.
     * This property is observable
     */
    loadSiblings: boolean;
    /**
     * Gets the scene
     */
    readonly scene: Scene;
    /**
     * Gets the performance container
     */
    readonly performanceContainer: HTMLElement;
    /**
     * Gets the statistics text.  This property is observable.
     */
    readonly statisticsText: string;
    /**
     * Gets the pick statistics text.  This property is observable.
     */
    readonly pickStatisticsText: string;
    /**
     * Gets the resource cache statistics text. This property is observable.
     */
    readonly resourceCacheStatisticsText: string;
    /**
     * Gets the available blend modes
     */
    readonly colorBlendModes: object[];
    /**
     * Gets the editor error message
     */
    readonly editorError: string;
    /**
     * Gets or sets the tileset of the view model.
     */
    tileset: Cesium3DTileset;
    /**
     * Gets the current feature of the view model.
     */
    feature: Cesium3DTileFeature;
    /**
     * Gets the current tile of the view model
     */
    tile: Cesium3DTile;
    /**
     * Toggles the pick tileset mode
     */
    togglePickTileset(): void;
    /**
     * Toggles the inspector visibility
     */
    toggleInspector(): void;
    /**
     * Toggles the visibility of the tileset section
     */
    toggleTileset(): void;
    /**
     * Toggles the visibility of the display section
     */
    toggleDisplay(): void;
    /**
     * Toggles the visibility of the update section
     */
    toggleUpdate(): void;
    /**
     * Toggles the visibility of the logging section
     */
    toggleLogging(): void;
    /**
     * Toggles the visibility of the style section
     */
    toggleStyle(): void;
    /**
     * Toggles the visibility of the tile Debug Info section
     */
    toggleTileDebugLabels(): void;
    /**
     * Toggles the visibility of the optimization section
     */
    toggleOptimization(): void;
    /**
     * Trims tile cache
     */
    trimTilesCache(): void;
    /**
     * Compiles the style in the style editor.
     */
    compileStyle(): void;
    /**
     * Handles key press events on the style editor.
     */
    styleEditorKeyPress(): void;
    /**
     * @returns true if the object has been destroyed, false otherwise.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the widget.  Should be called if permanently
     * removing the widget from layout.
     */
    destroy(): void;
    /**
     * Generates an HTML string of the statistics
     * @param tileset - The tileset
     * @param isPick - Whether this is getting the statistics for the pick pass
     * @returns The formatted statistics
     */
    static getStatistics(tileset: Cesium3DTileset, isPick: boolean): string;
}

/**
 * Inspector widget to aid in debugging
 * @param container - The DOM element or ID that will contain the widget.
 * @param scene - The Scene instance to use.
 */
export class CesiumInspector {
    constructor(container: Element | string, scene: Scene);
    /**
     * Gets the parent container.
     */
    container: Element;
    /**
     * Gets the view model.
     */
    viewModel: CesiumInspectorViewModel;
    /**
     * @returns true if the object has been destroyed, false otherwise.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the widget.  Should be called if permanently
     * removing the widget from layout.
     */
    destroy(): void;
}

/**
 * The view model for {@link CesiumInspector}.
 * @param scene - The scene instance to use.
 * @param performanceContainer - The instance to use for performance container.
 */
export class CesiumInspectorViewModel {
    constructor(scene: Scene, performanceContainer: Element);
    /**
     * Gets or sets the show frustums state.  This property is observable.
     */
    frustums: boolean;
    /**
     * Gets or sets the show frustum planes state.  This property is observable.
     */
    frustumPlanes: boolean;
    /**
     * Gets or sets the show performance display state.  This property is observable.
     */
    performance: boolean;
    /**
     * Gets or sets the shader cache text.  This property is observable.
     */
    shaderCacheText: string;
    /**
     * Gets or sets the show primitive bounding sphere state.  This property is observable.
     */
    primitiveBoundingSphere: boolean;
    /**
     * Gets or sets the show primitive reference frame state.  This property is observable.
     */
    primitiveReferenceFrame: boolean;
    /**
     * Gets or sets the filter primitive state.  This property is observable.
     */
    filterPrimitive: boolean;
    /**
     * Gets or sets the show tile bounding sphere state.  This property is observable.
     */
    tileBoundingSphere: boolean;
    /**
     * Gets or sets the filter tile state.  This property is observable.
     */
    filterTile: boolean;
    /**
     * Gets or sets the show wireframe state.  This property is observable.
     */
    wireframe: boolean;
    /**
     * Gets or sets the index of the depth frustum to display.  This property is observable.
     */
    depthFrustum: number;
    /**
     * Gets or sets the suspend updates state.  This property is observable.
     */
    suspendUpdates: boolean;
    /**
     * Gets or sets the show tile coordinates state.  This property is observable.
     */
    tileCoordinates: boolean;
    /**
     * Gets or sets the frustum statistic text.  This property is observable.
     */
    frustumStatisticText: string;
    /**
     * Gets or sets the selected tile information text.  This property is observable.
     */
    tileText: string;
    /**
     * Gets if a primitive has been selected.  This property is observable.
     */
    hasPickedPrimitive: boolean;
    /**
     * Gets if a tile has been selected.  This property is observable
     */
    hasPickedTile: boolean;
    /**
     * Gets if the picking primitive command is active.  This property is observable.
     */
    pickPrimitiveActive: boolean;
    /**
     * Gets if the picking tile command is active.  This property is observable.
     */
    pickTileActive: boolean;
    /**
     * Gets or sets if the cesium inspector drop down is visible.  This property is observable.
     */
    dropDownVisible: boolean;
    /**
     * Gets or sets if the general section is visible.  This property is observable.
     */
    generalVisible: boolean;
    /**
     * Gets or sets if the primitive section is visible.  This property is observable.
     */
    primitivesVisible: boolean;
    /**
     * Gets or sets if the terrain section is visible.  This property is observable.
     */
    terrainVisible: boolean;
    /**
     * Gets or sets the index of the depth frustum text.  This property is observable.
     */
    depthFrustumText: string;
    /**
     * Gets the scene to control.
     */
    scene: Scene;
    /**
     * Gets the container of the PerformanceDisplay
     */
    performanceContainer: Element;
    /**
     * Gets the command to toggle the visibility of the drop down.
     */
    toggleDropDown: Command;
    /**
     * Gets the command to toggle the visibility of a BoundingSphere for a primitive
     */
    showPrimitiveBoundingSphere: Command;
    /**
     * Gets the command to toggle the visibility of a {@link DebugModelMatrixPrimitive} for the model matrix of a primitive
     */
    showPrimitiveReferenceFrame: Command;
    /**
     * Gets the command to toggle a filter that renders only a selected primitive
     */
    doFilterPrimitive: Command;
    /**
     * Gets the command to increment the depth frustum index to be shown
     */
    incrementDepthFrustum: Command;
    /**
     * Gets the command to decrement the depth frustum index to be shown
     */
    decrementDepthFrustum: Command;
    /**
     * Gets the command to toggle the visibility of tile coordinates
     */
    showTileCoordinates: Command;
    /**
     * Gets the command to toggle the visibility of a BoundingSphere for a selected tile
     */
    showTileBoundingSphere: Command;
    /**
     * Gets the command to toggle a filter that renders only a selected tile
     */
    doFilterTile: Command;
    /**
     * Gets the command to expand and collapse the general section
     */
    toggleGeneral: Command;
    /**
     * Gets the command to expand and collapse the primitives section
     */
    togglePrimitives: Command;
    /**
     * Gets the command to expand and collapse the terrain section
     */
    toggleTerrain: Command;
    /**
     * Gets the command to pick a primitive
     */
    pickPrimitive: Command;
    /**
     * Gets the command to pick a tile
     */
    pickTile: Command;
    /**
     * Gets the command to pick a tile
     */
    selectParent: Command;
    /**
     * Gets the command to pick a tile
     */
    selectNW: Command;
    /**
     * Gets the command to pick a tile
     */
    selectNE: Command;
    /**
     * Gets the command to pick a tile
     */
    selectSW: Command;
    /**
     * Gets the command to pick a tile
     */
    selectSE: Command;
    /**
     * Gets or sets the current selected primitive
     */
    primitive: Command;
    /**
     * Gets or sets the current selected tile
     */
    tile: Command;
    /**
     * @returns true if the object has been destroyed, false otherwise.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the widget.  Should be called if permanently
     * removing the widget from layout.
     */
    destroy(): void;
}

/**
 * A view model which exposes a {@link Clock} for user interfaces.
 * @param [clock] - The clock object wrapped by this view model, if undefined a new instance will be created.
 */
export class ClockViewModel {
    constructor(clock?: Clock);
    /**
     * Gets the current system time.
     * This property is observable.
     */
    systemTime: JulianDate;
    /**
     * Gets or sets the start time of the clock.
     * See {@link Clock#startTime}.
     * This property is observable.
     */
    startTime: JulianDate;
    /**
     * Gets or sets the stop time of the clock.
     * See {@link Clock#stopTime}.
     * This property is observable.
     */
    stopTime: JulianDate;
    /**
     * Gets or sets the current time.
     * See {@link Clock#currentTime}.
     * This property is observable.
     */
    currentTime: JulianDate;
    /**
     * Gets or sets the clock multiplier.
     * See {@link Clock#multiplier}.
     * This property is observable.
     */
    multiplier: number;
    /**
     * Gets or sets the clock step setting.
     * See {@link Clock#clockStep}.
     * This property is observable.
     */
    clockStep: ClockStep;
    /**
     * Gets or sets the clock range setting.
     * See {@link Clock#clockRange}.
     * This property is observable.
     */
    clockRange: ClockRange;
    /**
     * Gets or sets whether the clock can animate.
     * See {@link Clock#canAnimate}.
     * This property is observable.
     */
    canAnimate: boolean;
    /**
     * Gets or sets whether the clock should animate.
     * See {@link Clock#shouldAnimate}.
     * This property is observable.
     */
    shouldAnimate: boolean;
    /**
     * Gets the underlying Clock.
     */
    clock: Clock;
    /**
     * Updates the view model with the contents of the underlying clock.
     * Can be called to force an update of the viewModel if the underlying
     * clock has changed and <code>Clock.tick</code> has not yet been called.
     */
    synchronize(): void;
    /**
     * @returns true if the object has been destroyed, false otherwise.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the view model.  Should be called to
     * properly clean up the view model when it is no longer needed.
     */
    destroy(): void;
}

/**
 * A Command is a function with an extra <code>canExecute</code> observable property to determine
 * whether the command can be executed.  When executed, a Command function will check the
 * value of <code>canExecute</code> and throw if false.
 *
 * This type describes an interface and is not intended to be instantiated directly.
 * See {@link createCommand} to create a command from a function.
 */
export class Command {
    constructor();
    /**
     * Gets whether this command can currently be executed.  This property is observable.
     */
    canExecute: boolean;
    /**
     * Gets an event which is raised before the command executes, the event
     * is raised with an object containing two properties: a <code>cancel</code> property,
     * which if set to false by the listener will prevent the command from being executed, and
     * an <code>args</code> property, which is the array of arguments being passed to the command.
     */
    beforeExecute: Event;
    /**
     * Gets an event which is raised after the command executes, the event
     * is raised with the return value of the command as its only parameter.
     */
    afterExecute: Event;
}

/**
 * A single button widget for toggling fullscreen mode.
 * @param container - The DOM element or ID that will contain the widget.
 * @param [fullscreenElement = document.body] - The element or id to be placed into fullscreen mode.
 */
export class FullscreenButton {
    constructor(container: Element | string, fullscreenElement?: Element | string);
    /**
     * Gets the parent container.
     */
    container: Element;
    /**
     * Gets the view model.
     */
    viewModel: FullscreenButtonViewModel;
    /**
     * @returns true if the object has been destroyed, false otherwise.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the widget.  Should be called if permanently
     * removing the widget from layout.
     */
    destroy(): void;
}

/**
 * The view model for {@link FullscreenButton}.
 * @param [fullscreenElement = document.body] - The element or id to be placed into fullscreen mode.
 * @param [container] - The DOM element or ID that will contain the widget.
 */
export class FullscreenButtonViewModel {
    constructor(fullscreenElement?: Element | string, container?: Element | string);
    /**
     * Gets whether or not fullscreen mode is active.  This property is observable.
     */
    isFullscreen: boolean;
    /**
     * Gets or sets whether or not fullscreen functionality should be enabled.  This property is observable.
     */
    isFullscreenEnabled: boolean;
    /**
     * Gets the tooltip.  This property is observable.
     */
    tooltip: string;
    /**
     * Gets or sets the HTML element to place into fullscreen mode when the
     * corresponding button is pressed.
     */
    fullscreenElement: Element;
    /**
     * Gets the Command to toggle fullscreen mode.
     */
    command: Command;
    /**
     * @returns true if the object has been destroyed, false otherwise.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the view model.  Should be called to
     * properly clean up the view model when it is no longer needed.
     */
    destroy(): void;
}

/**
 * A widget for finding addresses and landmarks, and flying the camera to them.  Geocoding is
 * performed using {@link https://cesium.com/cesium-ion/|Cesium ion}.
 * @param options - Object with the following properties:
 * @param options.container - The DOM element or ID that will contain the widget.
 * @param options.scene - The Scene instance to use.
 * @param [options.geocoderServices] - The geocoder services to be used
 * @param [options.autoComplete = true] - True if the geocoder should query as the user types to autocomplete
 * @param [options.flightDuration = 1.5] - The duration of the camera flight to an entered location, in seconds.
 * @param [options.destinationFound = GeocoderViewModel.flyToDestination] - A callback function that is called after a successful geocode.  If not supplied, the default behavior is to fly the camera to the result destination.
 */
export class Geocoder {
    constructor(options: {
        container: Element | string;
        scene: Scene;
        geocoderServices?: GeocoderService[];
        autoComplete?: boolean;
        flightDuration?: number;
        destinationFound?: Geocoder.DestinationFoundFunction;
    });
    /**
     * Gets the parent container.
     */
    container: Element;
    /**
     * Gets the parent container.
     */
    searchSuggestionsContainer: Element;
    /**
     * Gets the view model.
     */
    viewModel: GeocoderViewModel;
    /**
     * @returns true if the object has been destroyed, false otherwise.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the widget.  Should be called if permanently
     * removing the widget from layout.
     */
    destroy(): void;
}

export namespace Geocoder {
    /**
     * A function that handles the result of a successful geocode.
     * @param viewModel - The view model.
     * @param destination - The destination result of the geocode.
     */
    type DestinationFoundFunction = (viewModel: GeocoderViewModel, destination: Cartesian3 | Rectangle) => void;
}

/**
 * The view model for the {@link Geocoder} widget.
 * @param options - Object with the following properties:
 * @param options.scene - The Scene instance to use.
 * @param [options.geocoderServices] - Geocoder services to use for geocoding queries.
 *        If more than one are supplied, suggestions will be gathered for the geocoders that support it,
 *        and if no suggestion is selected the result from the first geocoder service wil be used.
 * @param [options.flightDuration] - The duration of the camera flight to an entered location, in seconds.
 * @param [options.destinationFound = GeocoderViewModel.flyToDestination] - A callback function that is called after a successful geocode.  If not supplied, the default behavior is to fly the camera to the result destination.
 */
export class GeocoderViewModel {
    constructor(options: {
        scene: Scene;
        geocoderServices?: GeocoderService[];
        flightDuration?: number;
        destinationFound?: Geocoder.DestinationFoundFunction;
    });
    /**
     * Gets or sets a value indicating if this instance should always show its text input field.
     */
    keepExpanded: boolean;
    /**
     * True if the geocoder should query as the user types to autocomplete
     */
    autoComplete: boolean;
    /**
     * Gets and sets the command called when a geocode destination is found
     */
    destinationFound: Geocoder.DestinationFoundFunction;
    /**
     * Gets a value indicating whether a search is currently in progress.  This property is observable.
     */
    isSearchInProgress: boolean;
    /**
     * Gets or sets the text to search for.  The text can be an address, or longitude, latitude,
     * and optional height, where longitude and latitude are in degrees and height is in meters.
     */
    searchText: string;
    /**
     * Gets or sets the the duration of the camera flight in seconds.
     * A value of zero causes the camera to instantly switch to the geocoding location.
     * The duration will be computed based on the distance when undefined.
     */
    flightDuration: number | undefined;
    /**
     * Gets the event triggered on flight completion.
     */
    complete: Event;
    /**
     * Gets the scene to control.
     */
    scene: Scene;
    /**
     * Gets the Command that is executed when the button is clicked.
     */
    search: Command;
    /**
     * Gets the currently selected geocoder search suggestion
     */
    selectedSuggestion: any;
    /**
     * Gets the list of geocoder search suggestions
     */
    suggestions: object[];
    /**
     * Destroys the widget.  Should be called if permanently
     * removing the widget from layout.
     */
    destroy(): void;
    /**
     * A function to fly to the destination found by a successful geocode.
     */
    static flyToDestination: Geocoder.DestinationFoundFunction;
    /**
     * @returns true if the object has been destroyed, false otherwise.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the widget.  Should be called if permanently
     * removing the widget from layout.
     */
    destroy(): void;
}

/**
 * A single button widget for returning to the default camera view of the current scene.
 * @param container - The DOM element or ID that will contain the widget.
 * @param scene - The Scene instance to use.
 * @param [duration] - The time, in seconds, it takes to complete the camera flight home.
 */
export class HomeButton {
    constructor(container: Element | string, scene: Scene, duration?: number);
    /**
     * Gets the parent container.
     */
    container: Element;
    /**
     * Gets the view model.
     */
    viewModel: HomeButtonViewModel;
    /**
     * @returns true if the object has been destroyed, false otherwise.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the widget.  Should be called if permanently
     * removing the widget from layout.
     */
    destroy(): void;
}

/**
 * The view model for {@link HomeButton}.
 * @param scene - The scene instance to use.
 * @param [duration] - The duration of the camera flight in seconds.
 */
export class HomeButtonViewModel {
    constructor(scene: Scene, duration?: number);
    /**
     * Gets or sets the tooltip.  This property is observable.
     */
    tooltip: string;
    /**
     * Gets the scene to control.
     */
    scene: Scene;
    /**
     * Gets the Command that is executed when the button is clicked.
     */
    command: Command;
    /**
     * Gets or sets the the duration of the camera flight in seconds.
     * A value of zero causes the camera to instantly switch to home view.
     * The duration will be computed based on the distance when undefined.
     */
    duration: number | undefined;
}

/**
 * A widget for displaying information or a description.
 * @param container - The DOM element or ID that will contain the widget.
 */
export class InfoBox {
    constructor(container: Element | string);
    /**
     * Gets the parent container.
     */
    container: Element;
    /**
     * Gets the view model.
     */
    viewModel: InfoBoxViewModel;
    /**
     * Gets the iframe used to display the description.
     */
    frame: HTMLIFrameElement;
    /**
     * @returns true if the object has been destroyed, false otherwise.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the widget.  Should be called if permanently
     * removing the widget from layout.
     */
    destroy(): void;
}

/**
 * The view model for {@link InfoBox}.
 */
export class InfoBoxViewModel {
    constructor();
    /**
     * Gets or sets the maximum height of the info box in pixels.  This property is observable.
     */
    maxHeight: number;
    /**
     * Gets or sets whether the camera tracking icon is enabled.
     */
    enableCamera: boolean;
    /**
     * Gets or sets the status of current camera tracking of the selected object.
     */
    isCameraTracking: boolean;
    /**
     * Gets or sets the visibility of the info box.
     */
    showInfo: boolean;
    /**
     * Gets or sets the title text in the info box.
     */
    titleText: string;
    /**
     * Gets or sets the description HTML for the info box.
     */
    description: string;
    /**
     * Gets the SVG path of the camera icon, which can change to be "crossed out" or not.
     */
    cameraIconPath: string;
    /**
     * Gets the maximum height of sections within the info box, minus an offset, in CSS-ready form.
     * @param offset - The offset in pixels.
     */
    maxHeightOffset(offset: number): string;
    /**
     * Gets an {@link Event} that is fired when the user clicks the camera icon.
     */
    cameraClicked: Event;
    /**
     * Gets an {@link Event} that is fired when the user closes the info box.
     */
    closeClicked: Event;
}

/**
 * <p>The NavigationHelpButton is a single button widget for displaying instructions for
 * navigating the globe with the mouse.</p><p style="clear: both;"></p><br/>
 * @example
 * // In HTML head, include a link to the NavigationHelpButton.css stylesheet,
 * // and in the body, include: <div id="navigationHelpButtonContainer"></div>
 *
 * const navigationHelpButton = new Cesium.NavigationHelpButton({
 *     container : 'navigationHelpButtonContainer'
 * });
 * @param options - Object with the following properties:
 * @param options.container - The DOM element or ID that will contain the widget.
 * @param [options.instructionsInitiallyVisible = false] - True if the navigation instructions should initially be visible; otherwise, false.
 */
export class NavigationHelpButton {
    constructor(options: {
        container: Element | string;
        instructionsInitiallyVisible?: boolean;
    });
    /**
     * Gets the parent container.
     */
    container: Element;
    /**
     * Gets the view model.
     */
    viewModel: NavigationHelpButtonViewModel;
    /**
     * @returns true if the object has been destroyed, false otherwise.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the widget.  Should be called if permanently
     * removing the widget from layout.
     */
    destroy(): void;
}

/**
 * The view model for {@link NavigationHelpButton}.
 */
export class NavigationHelpButtonViewModel {
    constructor();
    /**
     * Gets or sets whether the instructions are currently shown.  This property is observable.
     */
    showInstructions: boolean;
    /**
     * Gets or sets the tooltip.  This property is observable.
     */
    tooltip: string;
    /**
     * Gets the Command that is executed when the button is clicked.
     */
    command: Command;
    /**
     * Gets the Command that is executed when the mouse instructions should be shown.
     */
    showClick: Command;
    /**
     * Gets the Command that is executed when the touch instructions should be shown.
     */
    showTouch: Command;
}

/**
 * Monitors performance of the application and displays a message if poor performance is detected.
 * @param [options] - Object with the following properties:
 * @param options.container - The DOM element or ID that will contain the widget.
 * @param options.scene - The {@link Scene} for which to monitor performance.
 * @param [options.lowFrameRateMessage = 'This application appears to be performing poorly on your system.  Please try using a different web browser or updating your video drivers.'] - The
 *        message to display when a low frame rate is detected.  The message is interpeted as HTML, so make sure
 *        it comes from a trusted source so that your application is not vulnerable to cross-site scripting attacks.
 */
export class PerformanceWatchdog {
    constructor(options?: {
        container: Element | string;
        scene: Scene;
        lowFrameRateMessage?: string;
    });
    /**
     * Gets the parent container.
     */
    container: Element;
    /**
     * Gets the view model.
     */
    viewModel: PerformanceWatchdogViewModel;
    /**
     * @returns true if the object has been destroyed, false otherwise.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the widget.  Should be called if permanently
     * removing the widget from layout.
     */
    destroy(): void;
}

/**
 * The view model for {@link PerformanceWatchdog}.
 * @param [options] - Object with the following properties:
 * @param options.scene - The Scene instance for which to monitor performance.
 * @param [options.lowFrameRateMessage = 'This application appears to be performing poorly on your system.  Please try using a different web browser or updating your video drivers.'] - The
 *        message to display when a low frame rate is detected.  The message is interpeted as HTML, so make sure
 *        it comes from a trusted source so that your application is not vulnerable to cross-site scripting attacks.
 */
export class PerformanceWatchdogViewModel {
    constructor(options?: {
        scene: Scene;
        lowFrameRateMessage?: string;
    });
    /**
     * Gets or sets the message to display when a low frame rate is detected.  This string will be interpreted as HTML.
     */
    lowFrameRateMessage: string;
    /**
     * Gets or sets a value indicating whether the low frame rate message has previously been dismissed by the user.  If it has
     * been dismissed, the message will not be redisplayed, no matter the frame rate.
     */
    lowFrameRateMessageDismissed: boolean;
    /**
     * Gets or sets a value indicating whether the low frame rate message is currently being displayed.
     */
    showingLowFrameRateMessage: boolean;
    /**
     * Gets the {@link Scene} instance for which to monitor performance.
     */
    scene: Scene;
    /**
     * Gets a command that dismisses the low frame rate message.  Once it is dismissed, the message
     * will not be redisplayed.
     */
    dismissMessage: Command;
}

/**
 * The ProjectionPicker is a single button widget for switching between perspective and orthographic projections.
 * @example
 * // In HTML head, include a link to the ProjectionPicker.css stylesheet,
 * // and in the body, include: <div id="projectionPickerContainer"></div>
 * // Note: This code assumes you already have a Scene instance.
 *
 * const projectionPicker = new Cesium.ProjectionPicker('projectionPickerContainer', scene);
 * @param container - The DOM element or ID that will contain the widget.
 * @param scene - The Scene instance to use.
 */
export class ProjectionPicker {
    constructor(container: Element | string, scene: Scene);
    /**
     * Gets the parent container.
     */
    container: Element;
    /**
     * Gets the view model.
     */
    viewModel: ProjectionPickerViewModel;
    /**
     * @returns true if the object has been destroyed, false otherwise.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the widget.  Should be called if permanently
     * removing the widget from layout.
     */
    destroy(): void;
}

/**
 * The view model for {@link ProjectionPicker}.
 * @param scene - The Scene to switch projections.
 */
export class ProjectionPickerViewModel {
    constructor(scene: Scene);
    /**
     * Gets or sets whether the button drop-down is currently visible.  This property is observable.
     */
    dropDownVisible: boolean;
    /**
     * Gets or sets the perspective projection tooltip.  This property is observable.
     */
    tooltipPerspective: string;
    /**
     * Gets or sets the orthographic projection tooltip.  This property is observable.
     */
    tooltipOrthographic: string;
    /**
     * Gets the currently active tooltip.  This property is observable.
     */
    selectedTooltip: string;
    /**
     * Gets or sets the current SceneMode.  This property is observable.
     */
    sceneMode: SceneMode;
    /**
     * Gets the scene
     */
    scene: Scene;
    /**
     * Gets the command to toggle the drop down box.
     */
    toggleDropDown: Command;
    /**
     * Gets the command to switch to a perspective projection.
     */
    switchToPerspective: Command;
    /**
     * Gets the command to switch to orthographic projection.
     */
    switchToOrthographic: Command;
    /**
     * Gets whether the scene is currently using an orthographic projection.
     */
    isOrthographicProjection: Command;
    /**
     * @returns true if the object has been destroyed, false otherwise.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the view model.
     */
    destroy(): void;
}

/**
 * <img src="Images/sceneModePicker.png" style="float: left; margin-right: 10px;" width="44" height="116" />
 * <p>The SceneModePicker is a single button widget for switching between scene modes;
 * shown to the left in its expanded state. Programatic switching of scene modes will
 * be automatically reflected in the widget as long as the specified Scene
 * is used to perform the change.</p><p style="clear: both;"></p><br/>
 * @example
 * // In HTML head, include a link to the SceneModePicker.css stylesheet,
 * // and in the body, include: <div id="sceneModePickerContainer"></div>
 * // Note: This code assumes you already have a Scene instance.
 *
 * const sceneModePicker = new Cesium.SceneModePicker('sceneModePickerContainer', scene);
 * @param container - The DOM element or ID that will contain the widget.
 * @param scene - The Scene instance to use.
 * @param [duration = 2.0] - The time, in seconds, it takes for the scene to transition.
 */
export class SceneModePicker {
    constructor(container: Element | string, scene: Scene, duration?: number);
    /**
     * Gets the parent container.
     */
    container: Element;
    /**
     * Gets the view model.
     */
    viewModel: SceneModePickerViewModel;
    /**
     * @returns true if the object has been destroyed, false otherwise.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the widget.  Should be called if permanently
     * removing the widget from layout.
     */
    destroy(): void;
}

/**
 * The view model for {@link SceneModePicker}.
 * @param scene - The Scene to morph
 * @param [duration = 2.0] - The duration of scene morph animations, in seconds
 */
export class SceneModePickerViewModel {
    constructor(scene: Scene, duration?: number);
    /**
     * Gets or sets the current SceneMode.  This property is observable.
     */
    sceneMode: SceneMode;
    /**
     * Gets or sets whether the button drop-down is currently visible.  This property is observable.
     */
    dropDownVisible: boolean;
    /**
     * Gets or sets the 2D tooltip.  This property is observable.
     */
    tooltip2D: string;
    /**
     * Gets or sets the 3D tooltip.  This property is observable.
     */
    tooltip3D: string;
    /**
     * Gets or sets the Columbus View tooltip.  This property is observable.
     */
    tooltipColumbusView: string;
    /**
     * Gets the currently active tooltip.  This property is observable.
     */
    selectedTooltip: string;
    /**
     * Gets the scene
     */
    scene: Scene;
    /**
     * Gets or sets the the duration of scene mode transition animations in seconds.
     * A value of zero causes the scene to instantly change modes.
     */
    duration: number;
    /**
     * Gets the command to toggle the drop down box.
     */
    toggleDropDown: Command;
    /**
     * Gets the command to morph to 2D.
     */
    morphTo2D: Command;
    /**
     * Gets the command to morph to 3D.
     */
    morphTo3D: Command;
    /**
     * Gets the command to morph to Columbus View.
     */
    morphToColumbusView: Command;
    /**
     * @returns true if the object has been destroyed, false otherwise.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the view model.
     */
    destroy(): void;
}

/**
 * A widget for displaying an indicator on a selected object.
 * @param container - The DOM element or ID that will contain the widget.
 * @param scene - The Scene instance to use.
 */
export class SelectionIndicator {
    constructor(container: Element | string, scene: Scene);
    /**
     * Gets the parent container.
     */
    container: Element;
    /**
     * Gets the view model.
     */
    viewModel: SelectionIndicatorViewModel;
    /**
     * @returns true if the object has been destroyed, false otherwise.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the widget.  Should be called if permanently
     * removing the widget from layout.
     */
    destroy(): void;
}

/**
 * The view model for {@link SelectionIndicator}.
 * @param scene - The scene instance to use for screen-space coordinate conversion.
 * @param selectionIndicatorElement - The element containing all elements that make up the selection indicator.
 * @param container - The DOM element that contains the widget.
 */
export class SelectionIndicatorViewModel {
    constructor(scene: Scene, selectionIndicatorElement: Element, container: Element);
    /**
     * Gets or sets the world position of the object for which to display the selection indicator.
     */
    position: Cartesian3;
    /**
     * Gets or sets the visibility of the selection indicator.
     */
    showSelection: boolean;
    /**
     * Gets the visibility of the position indicator.  This can be false even if an
     * object is selected, when the selected object has no position.
     */
    isVisible: boolean;
    /**
     * Gets or sets the function for converting the world position of the object to the screen space position.
     * @example
     * selectionIndicatorViewModel.computeScreenSpacePosition = function(position, result) {
     *     return Cesium.SceneTransforms.wgs84ToWindowCoordinates(scene, position, result);
     * };
     */
    computeScreenSpacePosition: SelectionIndicatorViewModel.ComputeScreenSpacePosition;
    /**
     * Updates the view of the selection indicator to match the position and content properties of the view model.
     * This function should be called as part of the render loop.
     */
    update(): void;
    /**
     * Animate the indicator to draw attention to the selection.
     */
    animateAppear(): void;
    /**
     * Animate the indicator to release the selection.
     */
    animateDepart(): void;
    /**
     * Gets the HTML element containing the selection indicator.
     */
    container: Element;
    /**
     * Gets the HTML element that holds the selection indicator.
     */
    selectionIndicatorElement: Element;
    /**
     * Gets the scene being used.
     */
    scene: Scene;
}

export namespace SelectionIndicatorViewModel {
    /**
     * A function that converts the world position of an object to a screen space position.
     * @param position - The position in WGS84 (world) coordinates.
     * @param result - An object to return the input position transformed to window coordinates.
     */
    type ComputeScreenSpacePosition = (position: Cartesian3, result: Cartesian2) => Cartesian2;
}

/**
 * A Knockout binding handler that creates a DOM element for a single SVG path.
 * This binding handler will be registered as cesiumSvgPath.
 *
 * <p>
 * The parameter to this binding is an object with the following properties:
 * </p>
 *
 * <ul>
 * <li>path: The SVG path as a string.</li>
 * <li>width: The width of the SVG path with no transformations applied.</li>
 * <li>height: The height of the SVG path with no transformations applied.</li>
 * <li>css: Optional. A string containing additional CSS classes to apply to the SVG. 'cesium-svgPath-svg' is always applied.</li>
 * </ul>
 * @example
 * // Create an SVG as a child of a div
 * <div data-bind="cesiumSvgPath: { path: 'M 100 100 L 300 100 L 200 300 z', width: 28, height: 28 }"></div>
 *
 * // parameters can be observable from the view model
 * <div data-bind="cesiumSvgPath: { path: currentPath, width: currentWidth, height: currentHeight }"></div>
 *
 * // or the whole object can be observable from the view model
 * <div data-bind="cesiumSvgPath: svgPathOptions"></div>
 */
export namespace SvgPathBindingHandler {
    function register(): void;
}

/**
 * The Timeline is a widget for displaying and controlling the current scene time.
 * @param container - The parent HTML container node for this widget.
 * @param clock - The clock to use.
 */
export class Timeline {
    constructor(container: Element, clock: Clock);
    /**
     * Gets the parent container.
     */
    container: Element;
    /**
     * @returns true if the object has been destroyed, false otherwise.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the widget.  Should be called if permanently
     * removing the widget from layout.
     */
    destroy(): void;
    /**
     * Sets the view to the provided times.
     * @param startTime - The start time.
     * @param stopTime - The stop time.
     */
    zoomTo(startTime: JulianDate, stopTime: JulianDate): void;
    /**
     * Resizes the widget to match the container size.
     */
    resize(): void;
}

/**
 * A view model which exposes the properties of a toggle button.
 * @param command - The command which will be executed when the button is toggled.
 * @param [options] - Object with the following properties:
 * @param [options.toggled = false] - A boolean indicating whether the button should be initially toggled.
 * @param [options.tooltip = ''] - A string containing the button's tooltip.
 */
export class ToggleButtonViewModel {
    constructor(command: Command, options?: {
        toggled?: boolean;
        tooltip?: string;
    });
    /**
     * Gets or sets whether the button is currently toggled.  This property is observable.
     */
    toggled: boolean;
    /**
     * Gets or sets the button's tooltip.  This property is observable.
     */
    tooltip: string;
    /**
     * Gets the command which will be executed when the button is toggled.
     */
    command: Command;
}

/**
 * A single button widget for toggling vr mode.
 * @param container - The DOM element or ID that will contain the widget.
 * @param scene - The scene.
 * @param [vrElement = document.body] - The element or id to be placed into vr mode.
 */
export class VRButton {
    constructor(container: Element | string, scene: Scene, vrElement?: Element | string);
    /**
     * Gets the parent container.
     */
    container: Element;
    /**
     * Gets the view model.
     */
    viewModel: VRButtonViewModel;
    /**
     * @returns true if the object has been destroyed, false otherwise.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the widget.  Should be called if permanently
     * removing the widget from layout.
     */
    destroy(): void;
}

/**
 * The view model for {@link VRButton}.
 * @param scene - The scene.
 * @param [vrElement = document.body] - The element or id to be placed into VR mode.
 */
export class VRButtonViewModel {
    constructor(scene: Scene, vrElement?: Element | string);
    /**
     * Gets whether or not VR mode is active.
     */
    isVRMode: boolean;
    /**
     * Gets or sets whether or not VR functionality should be enabled.
     */
    isVREnabled: boolean;
    /**
     * Gets the tooltip.  This property is observable.
     */
    tooltip: string;
    /**
     * Gets or sets the HTML element to place into VR mode when the
     * corresponding button is pressed.
     */
    vrElement: Element;
    /**
     * Gets the Command to toggle VR mode.
     */
    command: Command;
    /**
     * @returns true if the object has been destroyed, false otherwise.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the view model.  Should be called to
     * properly clean up the view model when it is no longer needed.
     */
    destroy(): void;
}

export namespace Viewer {
    /**
     * Initialization options for the Viewer constructor
     * [animation = true] - If set to false, the Animation widget will not be created.
     * [baseLayerPicker = true] - If set to false, the BaseLayerPicker widget will not be created.
     * [fullscreenButton = true] - If set to false, the FullscreenButton widget will not be created.
     * [vrButton = false] - If set to true, the VRButton widget will be created.
     * [geocoder = true] - If set to false, the Geocoder widget will not be created.
     * [homeButton = true] - If set to false, the HomeButton widget will not be created.
     * [infoBox = true] - If set to false, the InfoBox widget will not be created.
     * [sceneModePicker = true] - If set to false, the SceneModePicker widget will not be created.
     * [selectionIndicator = true] - If set to false, the SelectionIndicator widget will not be created.
     * [timeline = true] - If set to false, the Timeline widget will not be created.
     * [navigationHelpButton = true] - If set to false, the navigation help button will not be created.
     * [navigationInstructionsInitiallyVisible = true] - True if the navigation instructions should initially be visible, or false if the should not be shown until the user explicitly clicks the button.
     * [scene3DOnly = false] - When <code>true</code>, each geometry instance will only be rendered in 3D to save GPU memory.
     * [shouldAnimate = false] - <code>true</code> if the clock should attempt to advance simulation time by default, <code>false</code> otherwise.  This option takes precedence over setting {@link Viewer#clockViewModel}.
     * [clockViewModel = new ClockViewModel(clock)] - The clock view model to use to control current time.
     * [selectedImageryProviderViewModel] - The view model for the current base imagery layer, if not supplied the first available base layer is used.  This value is only valid if `baseLayerPicker` is set to true.
     * [imageryProviderViewModels = createDefaultImageryProviderViewModels()] - The array of ProviderViewModels to be selectable from the BaseLayerPicker.  This value is only valid if `baseLayerPicker` is set to true.
     * [selectedTerrainProviderViewModel] - The view model for the current base terrain layer, if not supplied the first available base layer is used.  This value is only valid if `baseLayerPicker` is set to true.
     * [terrainProviderViewModels = createDefaultTerrainProviderViewModels()] - The array of ProviderViewModels to be selectable from the BaseLayerPicker.  This value is only valid if `baseLayerPicker` is set to true.
     * [baseLayer = ImageryLayer.fromWorldImagery()] - The bottommost imagery layer applied to the globe. If set to <code>false</code>, no imagery provider will be added. This value is only valid if `baseLayerPicker` is set to false.
     * [terrainProvider = new EllipsoidTerrainProvider()] - The terrain provider to use
     * [terrain] - A terrain object which handles asynchronous terrain provider. Can only specify if options.terrainProvider is undefined.
     * [skyBox] - The skybox used to render the stars.  When <code>undefined</code>, the default stars are used. If set to <code>false</code>, no skyBox, Sun, or Moon will be added.
     * [skyAtmosphere] - Blue sky, and the glow around the Earth's limb.  Set to <code>false</code> to turn it off.
     * [fullscreenElement = document.body] - The element or id to be placed into fullscreen mode when the full screen button is pressed.
     * [useDefaultRenderLoop = true] - True if this widget should control the render loop, false otherwise.
     * [targetFrameRate] - The target frame rate when using the default render loop.
     * [showRenderLoopErrors = true] - If true, this widget will automatically display an HTML panel to the user containing the error, if a render loop error occurs.
     * [useBrowserRecommendedResolution = true] - If true, render at the browser's recommended resolution and ignore <code>window.devicePixelRatio</code>.
     * [automaticallyTrackDataSourceClocks = true] - If true, this widget will automatically track the clock settings of newly added DataSources, updating if the DataSource's clock changes.  Set this to false if you want to configure the clock independently.
     * [contextOptions] - Context and WebGL creation properties passed to {@link Scene}.
     * [sceneMode = SceneMode.SCENE3D] - The initial scene mode.
     * [mapProjection = new GeographicProjection()] - The map projection to use in 2D and Columbus View modes.
     * [globe = new Globe(mapProjection.ellipsoid)] - The globe to use in the scene.  If set to <code>false</code>, no globe will be added and the sky atmosphere will be hidden by default.
     * [orderIndependentTranslucency = true] - If true and the configuration supports it, use order independent translucency.
     * [creditContainer] - The DOM element or ID that will contain the {@link CreditDisplay}.  If not specified, the credits are added to the bottom of the widget itself.
     * [creditViewport] - The DOM element or ID that will contain the credit pop up created by the {@link CreditDisplay}.  If not specified, it will appear over the widget itself.
     * [dataSources = new DataSourceCollection()] - The collection of data sources visualized by the widget.  If this parameter is provided,
     *                               the instance is assumed to be owned by the caller and will not be destroyed when the viewer is destroyed.
     * [shadows = false] - Determines if shadows are cast by light sources.
     * [terrainShadows = ShadowMode.RECEIVE_ONLY] - Determines if the terrain casts or receives shadows from light sources.
     * [mapMode2D = MapMode2D.INFINITE_SCROLL] - Determines if the 2D map is rotatable or can be scrolled infinitely in the horizontal direction.
     * [projectionPicker = false] - If set to true, the ProjectionPicker widget will be created.
     * [blurActiveElementOnCanvasFocus = true] - If true, the active element will blur when the viewer's canvas is clicked. Setting this to false is useful for cases when the canvas is clicked only for retrieving position or an entity data without actually meaning to set the canvas to be the active element.
     * [requestRenderMode = false] - If true, rendering a frame will only occur when needed as determined by changes within the scene. Enabling reduces the CPU/GPU usage of your application and uses less battery on mobile, but requires using {@link Scene#requestRender} to render a new frame explicitly in this mode. This will be necessary in many cases after making changes to the scene in other parts of the API. See {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}.
     * [maximumRenderTimeChange = 0.0] - If requestRenderMode is true, this value defines the maximum change in simulation time allowed before a render is requested. See {@link https://cesium.com/blog/2018/01/24/cesium-scene-rendering-performance/|Improving Performance with Explicit Rendering}.
     * [depthPlaneEllipsoidOffset = 0.0] - Adjust the DepthPlane to address rendering artefacts below ellipsoid zero elevation.
     * [msaaSamples = 1] - If provided, this value controls the rate of multisample antialiasing. Typical multisampling rates are 2, 4, and sometimes 8 samples per pixel. Higher sampling rates of MSAA may impact performance in exchange for improved visual quality. This value only applies to WebGL2 contexts that support multisample render targets.
     */
    type ConstructorOptions = {
        animation?: boolean;
        baseLayerPicker?: boolean;
        fullscreenButton?: boolean;
        vrButton?: boolean;
        geocoder?: boolean | GeocoderService[];
        homeButton?: boolean;
        infoBox?: boolean;
        sceneModePicker?: boolean;
        selectionIndicator?: boolean;
        timeline?: boolean;
        navigationHelpButton?: boolean;
        navigationInstructionsInitiallyVisible?: boolean;
        scene3DOnly?: boolean;
        shouldAnimate?: boolean;
        clockViewModel?: ClockViewModel;
        selectedImageryProviderViewModel?: ProviderViewModel;
        imageryProviderViewModels?: ProviderViewModel[];
        selectedTerrainProviderViewModel?: ProviderViewModel;
        terrainProviderViewModels?: ProviderViewModel[];
        baseLayer?: ImageryLayer | false;
        terrainProvider?: TerrainProvider;
        terrain?: Terrain;
        skyBox?: SkyBox | false;
        skyAtmosphere?: SkyAtmosphere | false;
        fullscreenElement?: Element | string;
        useDefaultRenderLoop?: boolean;
        targetFrameRate?: number;
        showRenderLoopErrors?: boolean;
        useBrowserRecommendedResolution?: boolean;
        automaticallyTrackDataSourceClocks?: boolean;
        contextOptions?: ContextOptions;
        sceneMode?: SceneMode;
        mapProjection?: MapProjection;
        globe?: Globe | false;
        orderIndependentTranslucency?: boolean;
        creditContainer?: Element | string;
        creditViewport?: Element | string;
        dataSources?: DataSourceCollection;
        shadows?: boolean;
        terrainShadows?: ShadowMode;
        mapMode2D?: MapMode2D;
        projectionPicker?: boolean;
        blurActiveElementOnCanvasFocus?: boolean;
        requestRenderMode?: boolean;
        maximumRenderTimeChange?: number;
        depthPlaneEllipsoidOffset?: number;
        msaaSamples?: number;
    };
    /**
     * A function that augments a Viewer instance with additional functionality.
     * @param viewer - The viewer instance.
     * @param options - Options object to be passed to the mixin function.
     */
    type ViewerMixin = (viewer: Viewer, options: any) => void;
}

/**
 * A base widget for building applications.  It composites all of the standard Cesium widgets into one reusable package.
 * The widget can always be extended by using mixins, which add functionality useful for a variety of applications.
 * @example
 * // Initialize the viewer widget with several custom options and mixins.
 * try {
 *   const viewer = new Cesium.Viewer("cesiumContainer", {
 *     // Start in Columbus Viewer
 *     sceneMode: Cesium.SceneMode.COLUMBUS_VIEW,
 *     // Use Cesium World Terrain
 *     terrain: Cesium.Terrain.fromWorldTerrain(),
 *     // Hide the base layer picker
 *     baseLayerPicker: false,
 *     // Use OpenStreetMaps
 *     baseLayer: new Cesium.ImageryLayer(new Cesium.OpenStreetMapImageryProvider({
 *       url: "https://tile.openstreetmap.org/"
 *     })),
 *     skyBox: new Cesium.SkyBox({
 *       sources: {
 *         positiveX: "stars/TychoSkymapII.t3_08192x04096_80_px.jpg",
 *         negativeX: "stars/TychoSkymapII.t3_08192x04096_80_mx.jpg",
 *         positiveY: "stars/TychoSkymapII.t3_08192x04096_80_py.jpg",
 *         negativeY: "stars/TychoSkymapII.t3_08192x04096_80_my.jpg",
 *         positiveZ: "stars/TychoSkymapII.t3_08192x04096_80_pz.jpg",
 *         negativeZ: "stars/TychoSkymapII.t3_08192x04096_80_mz.jpg"
 *       }
 *     }),
 *     // Show Columbus View map with Web Mercator projection
 *     mapProjection: new Cesium.WebMercatorProjection()
 *   });
 * } catch (error) {
 *   console.log(error);
 * }
 *
 * // Add basic drag and drop functionality
 * viewer.extend(Cesium.viewerDragDropMixin);
 *
 * // Show a pop-up alert if we encounter an error when processing a dropped file
 * viewer.dropError.addEventListener(function(dropHandler, name, error) {
 *   console.log(error);
 *   window.alert(error);
 * });
 * @param container - The DOM element or ID that will contain the widget.
 * @param [options] - Object describing initialization options
 */
export class Viewer {
    constructor(container: Element | string, options?: Viewer.ConstructorOptions);
    /**
     * Returns true when the terrain provider has been successfully created. Otherwise, returns false.
     */
    readonly ready: boolean;
    /**
     * The terrain provider providing surface geometry to a globe. Do not use until {@link Terrain.readyEvent} is raised.
     */
    readonly provider: TerrainProvider;
    /**
     * Gets the parent container.
     */
    readonly container: Element;
    /**
     * Manages the list of credits to display on screen and in the lightbox.
     */
    creditDisplay: CreditDisplay;
    /**
     * Gets the DOM element for the area at the bottom of the window containing the
     * {@link CreditDisplay} and potentially other things.
     */
    readonly bottomContainer: Element;
    /**
     * Gets the CesiumWidget.
     */
    readonly cesiumWidget: CesiumWidget;
    /**
     * Gets the selection indicator.
     */
    readonly selectionIndicator: SelectionIndicator;
    /**
     * Gets the info box.
     */
    readonly infoBox: InfoBox;
    /**
     * Gets the Geocoder.
     */
    readonly geocoder: Geocoder;
    /**
     * Gets the HomeButton.
     */
    readonly homeButton: HomeButton;
    /**
     * Gets the SceneModePicker.
     */
    readonly sceneModePicker: SceneModePicker;
    /**
     * Gets the ProjectionPicker.
     */
    readonly projectionPicker: ProjectionPicker;
    /**
     * Gets the BaseLayerPicker.
     */
    readonly baseLayerPicker: BaseLayerPicker;
    /**
     * Gets the NavigationHelpButton.
     */
    readonly navigationHelpButton: NavigationHelpButton;
    /**
     * Gets the Animation widget.
     */
    readonly animation: Animation;
    /**
     * Gets the Timeline widget.
     */
    readonly timeline: Timeline;
    /**
     * Gets the FullscreenButton.
     */
    readonly fullscreenButton: FullscreenButton;
    /**
     * Gets the VRButton.
     */
    readonly vrButton: VRButton;
    /**
     * Gets the display used for {@link DataSource} visualization.
     */
    readonly dataSourceDisplay: DataSourceDisplay;
    /**
     * Gets the collection of entities not tied to a particular data source.
     * This is a shortcut to [dataSourceDisplay.defaultDataSource.entities]{@link Viewer#dataSourceDisplay}.
     */
    readonly entities: EntityCollection;
    /**
     * Gets the set of {@link DataSource} instances to be visualized.
     */
    readonly dataSources: DataSourceCollection;
    /**
     * Gets the canvas.
     */
    readonly canvas: HTMLCanvasElement;
    /**
     * Gets the scene.
     */
    readonly scene: Scene;
    /**
     * Determines if shadows are cast by light sources.
     */
    shadows: boolean;
    /**
     * Determines if the terrain casts or shadows from light sources.
     */
    terrainShadows: ShadowMode;
    /**
     * Get the scene's shadow map
     */
    readonly shadowMap: ShadowMap;
    /**
     * Gets the collection of image layers that will be rendered on the globe.
     */
    readonly imageryLayers: ImageryLayerCollection;
    /**
     * The terrain provider providing surface geometry for the globe.
     */
    terrainProvider: TerrainProvider;
    /**
     * Gets the camera.
     */
    readonly camera: Camera;
    /**
     * Gets the post-process stages.
     */
    readonly postProcessStages: PostProcessStageCollection;
    /**
     * Gets the clock.
     */
    readonly clock: Clock;
    /**
     * Gets the clock view model.
     */
    readonly clockViewModel: ClockViewModel;
    /**
     * Gets the screen space event handler.
     */
    readonly screenSpaceEventHandler: ScreenSpaceEventHandler;
    /**
     * Gets or sets the target frame rate of the widget when <code>useDefaultRenderLoop</code>
     * is true. If undefined, the browser's requestAnimationFrame implementation
     * determines the frame rate.  If defined, this value must be greater than 0.  A value higher
     * than the underlying requestAnimationFrame implementation will have no effect.
     */
    targetFrameRate: number;
    /**
     * Gets or sets whether or not this widget should control the render loop.
     * If true the widget will use requestAnimationFrame to
     * perform rendering and resizing of the widget, as well as drive the
     * simulation clock. If set to false, you must manually call the
     * <code>resize</code>, <code>render</code> methods
     * as part of a custom render loop.  If an error occurs during rendering, {@link Scene}'s
     * <code>renderError</code> event will be raised and this property
     * will be set to false.  It must be set back to true to continue rendering
     * after the error.
     */
    useDefaultRenderLoop: boolean;
    /**
     * Gets or sets a scaling factor for rendering resolution.  Values less than 1.0 can improve
     * performance on less powerful devices while values greater than 1.0 will render at a higher
     * resolution and then scale down, resulting in improved visual fidelity.
     * For example, if the widget is laid out at a size of 640x480, setting this value to 0.5
     * will cause the scene to be rendered at 320x240 and then scaled up while setting
     * it to 2.0 will cause the scene to be rendered at 1280x960 and then scaled down.
     */
    resolutionScale: number;
    /**
     * Boolean flag indicating if the browser's recommended resolution is used.
     * If true, the browser's device pixel ratio is ignored and 1.0 is used instead,
     * effectively rendering based on CSS pixels instead of device pixels. This can improve
     * performance on less powerful devices that have high pixel density. When false, rendering
     * will be in device pixels. {@link Viewer#resolutionScale} will still take effect whether
     * this flag is true or false.
     */
    useBrowserRecommendedResolution: boolean;
    /**
     * Gets or sets whether or not data sources can temporarily pause
     * animation in order to avoid showing an incomplete picture to the user.
     * For example, if asynchronous primitives are being processed in the
     * background, the clock will not advance until the geometry is ready.
     */
    allowDataSourcesToSuspendAnimation: boolean;
    /**
     * Gets or sets the Entity instance currently being tracked by the camera.
     */
    trackedEntity: Entity | undefined;
    /**
     * Gets or sets the object instance for which to display a selection indicator.
     *
     * If a user interactively picks a Cesium3DTilesFeature instance, then this property
     * will contain a transient Entity instance with a property named "feature" that is
     * the instance that was picked.
     */
    selectedEntity: Entity | undefined;
    /**
     * Gets the event that is raised when the selected entity changes.
     */
    readonly selectedEntityChanged: Event;
    /**
     * Gets the event that is raised when the tracked entity changes.
     */
    readonly trackedEntityChanged: Event;
    /**
     * Gets or sets the data source to track with the viewer's clock.
     */
    clockTrackedDataSource: DataSource;
    /**
     * Extends the base viewer functionality with the provided mixin.
     * A mixin may add additional properties, functions, or other behavior
     * to the provided viewer instance.
     * @param mixin - The Viewer mixin to add to this instance.
     * @param [options] - The options object to be passed to the mixin function.
     */
    extend(mixin: Viewer.ViewerMixin, options?: any): void;
    /**
     * Resizes the widget to match the container size.
     * This function is called automatically as needed unless
     * <code>useDefaultRenderLoop</code> is set to false.
     */
    resize(): void;
    /**
     * This forces the widget to re-think its layout, including
     * widget sizes and credit placement.
     */
    forceResize(): void;
    /**
     * Renders the scene.  This function is called automatically
     * unless <code>useDefaultRenderLoop</code> is set to false;
     */
    render(): void;
    /**
     * @returns true if the object has been destroyed, false otherwise.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the widget.  Should be called if permanently
     * removing the widget from layout.
     */
    destroy(): void;
    /**
     * Asynchronously sets the camera to view the provided entity, entities, or data source.
     * If the data source is still in the process of loading or the visualization is otherwise still loading,
     * this method waits for the data to be ready before performing the zoom.
     *
     * <p>The offset is heading/pitch/range in the local east-north-up reference frame centered at the center of the bounding sphere.
     * The heading and the pitch angles are defined in the local east-north-up reference frame.
     * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch
     * angles are above the plane. Negative pitch angles are below the plane. The range is the distance from the center. If the range is
     * zero, a range will be computed such that the whole bounding sphere is visible.</p>
     *
     * <p>In 2D, there must be a top down view. The camera will be placed above the target looking down. The height above the
     * target will be the range. The heading will be determined from the offset. If the heading cannot be
     * determined from the offset, the heading will be north.</p>
     * @param target - The entity, array of entities, entity collection, data source, Cesium3DTileset, point cloud, or imagery layer to view. You can also pass a promise that resolves to one of the previously mentioned types.
     * @param [offset] - The offset from the center of the entity in the local east-north-up reference frame.
     * @returns A Promise that resolves to true if the zoom was successful or false if the target is not currently visualized in the scene or the zoom was cancelled.
     */
    zoomTo(target: Entity | Entity[] | EntityCollection | DataSource | ImageryLayer | Cesium3DTileset | TimeDynamicPointCloud | Promise<Entity | Entity[] | EntityCollection | DataSource | ImageryLayer | Cesium3DTileset | TimeDynamicPointCloud | VoxelPrimitive>, offset?: HeadingPitchRange): Promise<boolean>;
    /**
     * Flies the camera to the provided entity, entities, or data source.
     * If the data source is still in the process of loading or the visualization is otherwise still loading,
     * this method waits for the data to be ready before performing the flight.
     *
     * <p>The offset is heading/pitch/range in the local east-north-up reference frame centered at the center of the bounding sphere.
     * The heading and the pitch angles are defined in the local east-north-up reference frame.
     * The heading is the angle from y axis and increasing towards the x axis. Pitch is the rotation from the xy-plane. Positive pitch
     * angles are above the plane. Negative pitch angles are below the plane. The range is the distance from the center. If the range is
     * zero, a range will be computed such that the whole bounding sphere is visible.</p>
     *
     * <p>In 2D, there must be a top down view. The camera will be placed above the target looking down. The height above the
     * target will be the range. The heading will be determined from the offset. If the heading cannot be
     * determined from the offset, the heading will be north.</p>
     * @param target - The entity, array of entities, entity collection, data source, Cesium3DTileset, point cloud, or imagery layer to view. You can also pass a promise that resolves to one of the previously mentioned types.
     * @param [options] - Object with the following properties:
     * @param [options.duration = 3.0] - The duration of the flight in seconds.
     * @param [options.maximumHeight] - The maximum height at the peak of the flight.
     * @param [options.offset] - The offset from the target in the local east-north-up reference frame centered at the target.
     * @returns A Promise that resolves to true if the flight was successful or false if the target is not currently visualized in the scene or the flight was cancelled. //TODO: Cleanup entity mentions
     */
    flyTo(target: Entity | Entity[] | EntityCollection | DataSource | ImageryLayer | Cesium3DTileset | TimeDynamicPointCloud | Promise<Entity | Entity[] | EntityCollection | DataSource | ImageryLayer | Cesium3DTileset | TimeDynamicPointCloud | VoxelPrimitive>, options?: {
        duration?: number;
        maximumHeight?: number;
        offset?: HeadingPitchRange;
    }): Promise<boolean>;
}

/**
 * A mixin which adds the {@link Cesium3DTilesInspector} widget to the {@link Viewer} widget.
 * Rather than being called directly, this function is normally passed as
 * a parameter to {@link Viewer#extend}, as shown in the example below.
 * @example
 * const viewer = new Cesium.Viewer('cesiumContainer');
 * viewer.extend(Cesium.viewerCesium3DTilesInspectorMixin);
 * @param viewer - The viewer instance.
 */
export function viewerCesium3DTilesInspectorMixin(viewer: Viewer): void;

/**
 * A mixin which adds the CesiumInspector widget to the Viewer widget.
 * Rather than being called directly, this function is normally passed as
 * a parameter to {@link Viewer#extend}, as shown in the example below.
 * @example
 * const viewer = new Cesium.Viewer('cesiumContainer');
 * viewer.extend(Cesium.viewerCesiumInspectorMixin);
 * @param viewer - The viewer instance.
 */
export function viewerCesiumInspectorMixin(viewer: Viewer): void;

/**
 * A mixin which adds default drag and drop support for CZML files to the Viewer widget.
 * Rather than being called directly, this function is normally passed as
 * a parameter to {@link Viewer#extend}, as shown in the example below.
 * @example
 * // Add basic drag and drop support and pop up an alert window on error.
 * const viewer = new Cesium.Viewer('cesiumContainer');
 * viewer.extend(Cesium.viewerDragDropMixin);
 * viewer.dropError.addEventListener(function(viewerArg, source, error) {
 *     window.alert('Error processing ' + source + ':' + error);
 * });
 * @param viewer - The viewer instance.
 * @param [options] - Object with the following properties:
 * @param [options.dropTarget = viewer.container] - The DOM element which will serve as the drop target.
 * @param [options.clearOnDrop = true] - When true, dropping files will clear all existing data sources first, when false, new data sources will be loaded after the existing ones.
 * @param [options.flyToOnDrop = true] - When true, dropping files will fly to the data source once it is loaded.
 * @param [options.clampToGround = true] - When true, datasources are clamped to the ground.
 * @param [options.proxy] - The proxy to be used for KML network links.
 */
export function viewerDragDropMixin(viewer: Viewer, options?: {
    dropTarget?: Element | string;
    clearOnDrop?: boolean;
    flyToOnDrop?: boolean;
    clampToGround?: boolean;
    proxy?: Proxy;
}): void;

/**
 * A mixin which adds the {@link PerformanceWatchdog} widget to the {@link Viewer} widget.
 * Rather than being called directly, this function is normally passed as
 * a parameter to {@link Viewer#extend}, as shown in the example below.
 * @example
 * const viewer = new Cesium.Viewer('cesiumContainer');
 * viewer.extend(Cesium.viewerPerformanceWatchdogMixin, {
 *     lowFrameRateMessage : 'Why is this going so <em>slowly</em>?'
 * });
 * @param viewer - The viewer instance.
 * @param [options] - An object with properties.
 * @param [options.lowFrameRateMessage = 'This application appears to be performing poorly on your system.  Please try using a different web browser or updating your video drivers.'] - The
 *        message to display when a low frame rate is detected.  The message is interpeted as HTML, so make sure
 *        it comes from a trusted source so that your application is not vulnerable to cross-site scripting attacks.
 */
export function viewerPerformanceWatchdogMixin(viewer: Viewer, options?: {
    lowFrameRateMessage?: string;
}): void;

/**
 * A mixin which adds the {@link VoxelInspector} widget to the {@link Viewer} widget.
 * Rather than being called directly, this function is normally passed as
 * a parameter to {@link Viewer#extend}, as shown in the example below.
 * @example
 * var viewer = new Cesium.Viewer('cesiumContainer');
 * viewer.extend(Cesium.viewerVoxelInspectorMixin);
 * @param viewer - The viewer instance.
 */
export function viewerVoxelInspectorMixin(viewer: Viewer): void;

/**
 * Inspector widget to aid in debugging voxels
 * @param container - The DOM element or ID that will contain the widget.
 * @param scene - the Scene instance to use.
 */
export class VoxelInspector {
    constructor(container: Element | string, scene: Scene);
    /**
     * Gets the parent container.
     */
    container: Element;
    /**
     * Gets the view model.
     */
    viewModel: VoxelInspectorViewModel;
    /**
     * @returns true if the object has been destroyed, false otherwise.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the widget.  Should be called if permanently
     * removing the widget from layout.
     */
    destroy(): void;
}

/**
 * The view model for {@link VoxelInspector}.
 * @param scene - The scene instance to use.
 */
export class VoxelInspectorViewModel {
    constructor(scene: Scene);
    /**
     * Gets the scene
     */
    readonly scene: Scene;
    /**
     * Gets or sets the primitive of the view model.
     */
    voxelPrimitive: VoxelPrimitive;
    /**
     * Toggles the inspector visibility
     */
    toggleInspector(): void;
    /**
     * Toggles the visibility of the display section
     */
    toggleDisplay(): void;
    /**
     * Toggles the visibility of the transform section
     */
    toggleTransform(): void;
    /**
     * Toggles the visibility of the bounds section
     */
    toggleBounds(): void;
    /**
     * Toggles the visibility of the clipping section
     */
    toggleClipping(): void;
    /**
     * Toggles the visibility of the shader section
     */
    toggleShader(): void;
    /**
     * Compiles the shader in the shader editor.
     */
    compileShader(): void;
    /**
     * Handles key press events on the shader editor.
     */
    shaderEditorKeyPress(): void;
    /**
     * @returns true if the object has been destroyed, false otherwise.
     */
    isDestroyed(): boolean;
    /**
     * Destroys the widget.  Should be called if permanently
     * removing the widget from layout.
     */
    destroy(): void;
}

/**
 * Create a Command from a given function, for use with ViewModels.
 *
 * A Command is a function with an extra <code>canExecute</code> observable property to determine
 * whether the command can be executed.  When executed, a Command function will check the
 * value of <code>canExecute</code> and throw if false.  It also provides events for when
 * a command has been or is about to be executed.
 * @param func - The function to execute.
 * @param [canExecute = true] - A boolean indicating whether the function can currently be executed.
 */
export function createCommand(func: (...params: any[]) => any, canExecute?: boolean): void;




