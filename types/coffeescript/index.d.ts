/**
 * Babel AST source location.
 */
export interface BabelSourceLocation {
  start: {
    line: number;
    column: number;
  };
  end: {
    line: number;
    column: number;
  };
}

/**
 * Babel abstract syntax tree comment.
 */
export interface BabelComment {
  value: string;
  start: number;
  end: number;
  loc: BabelSourceLocation;
}

/**
 * Babel transpilation result for file.
 */
export interface BabelFileResult {
  ast?: {
    type: string;
    leadingComments?: BabelComment[];
    innerComments?: BabelComment[];
    trailingComments?: BabelComment[];
    start: number;
    end: number;
    loc: BabelSourceLocation;
  };
  code?: string;
  ignored?: boolean;
  map?: object;
  metadata?: {
    usedHelpers: string[];
    marked: Array<{ type: string; message: string; loc: object }>;
    modules: {
      imports: object[];
      exports: {
        exported: object[];
        specifiers: object[];
      };
    };
  };
}

export interface BabelTransformOptions {
  [k: string]: unknown;
  /**
   * Include the AST in the returned object.
   */
  ast?: boolean;
  /**
   * Attach a comment after all non-user injected code.
   */
  auxiliaryCommentAfter?: string;
  /**
   * Attach a comment before all non-user injected code.
   */
  auxiliaryCommentBefore?: string;
  /**
   * Enable code generation
   */
  code?: boolean;
  /**
   * Output comments in generated output.
   */
  comments?: boolean;
  /**
   * Do not include superfluous whitespace characters and line terminators.
   * When set to "auto" compact is set to true on input sizes of >500KB.
   */
  compact?: "auto" | true | false;
  /**
   * A path to a .babelrc file to extend.
   */
  extends?: string;
  /**
   * Filename for use in errors etc.
   */
  filename?: string;
  /**
   * Filename relative to sourceRoot Defaults to "filename".
   */
  filenameRelative?: string;
  /**
   * ANSI highlight syntax error code frames.
   */
  highlightCode?: boolean;
  /**
   * Opposite of the "only" option.
   */
  ignore?: string | string[];
  /**
   * If true, attempt to load an input sourcemap from the file itself.
   * If an object is provided, it will be treated as the source map object itself.
   */
  inputSourceMap?: boolean | { [k: string]: unknown };
  /**
   * Keep extensions in module ids
   */
  keepModuleIdExtensions?: boolean;
  /**
   * Specify a custom name for module ids.
   */
  moduleId?: string;
  /**
   * If truthy, insert an explicit id for modules. By default, all modules are
   * anonymous. (Not available for common modules)
   */
  moduleIds?: boolean & string;
  /**
   * Optional prefix for the AMD module formatter that will be prepend to the
   * filename on module definitions. Defaults to "sourceRoot".
   */
  moduleRoot?: string;
  /**
   * A glob, regex, or mixed array of both, matching paths to only compile. Can
   * also be an array of arrays containing paths to explicitly match. When
   * attempting to compile a non-matching file it's returned verbatim.
   */
  only?: string | string[];
  /**
   * List of plugins to load and use
   */
  plugins?: Array<string | string[] | [string, { [k: string]: unknown }]>;
  /**
   * List of presets (a set of plugins) to load and use
   */
  presets?: Array<string | string[] | [string, { [k: string]: unknown }]>;
  /**
   * Retain line numbers. This will lead to wacky code but is handy for
   * scenarios where you can't use source maps. NOTE: This will obviously not
   * retain the columns.
   */
  retainLines?: boolean;
  /**
   * Set sources[0] on returned source map. Defaults to "filenameRelative".
   */
  sourceFileName?: string;
  /**
   * If truthy, adds a map property to returned output. If set to "inline", a
   * comment with a sourceMappingURL directive is added to the bottom of the
   * returned code. If set to "both" then a map property is returned as well
   * as a source map comment appended.
   */
  sourceMaps?: "both" | "inline" | true | false;
  /**
   * Set file on returned source map. Defaults to "filenameRelative".
   */
  sourceMapTarget?: string;
  /**
   * The root from which all sources are relative. Defaults to "moduleRoot".
   */
  sourceRoot?: string;
}

/**
 * CoffeeScript compiler options.
 *
 * @member ast If true, output an abstract syntax tree of the input CoffeeScript source code.
 * @member bare If true, omit a top-level IIFE safety wrapper.
 * @member filename File name to compile - defaults to `index.js`.
 * @member header If true, output the `Generated by CoffeeScript` header.
 * @member inlineMap If true, output the source map as a base64-encoded string in a comment at the bottom.
 * @member sourceMap If true, output a source map object with the code.
 * @member transpile Babel transpilation options - see `babel.TransformOptions`.
 */
export interface Options {
  ast?: boolean;
  bare?: boolean;
  filename?: string;
  header?: boolean;
  inlineMap?: boolean;
  sourceMap?: boolean;
  transpile?: BabelTransformOptions;
}

/**
 * CoffeeScript compiler options for source map output.
 * Type for compiler options when `sourceMap` is `true`.
 *
 * @member ast If true, output an abstract syntax tree of the input CoffeeScript source code.
 * @member bare If true, omit a top-level IIFE safety wrapper.
 * @member filename File name to compile - defaults to `index.js`.
 * @member header If true, output the `Generated by CoffeeScript` header.
 * @member inlineMap If true, output the source map as a base64-encoded string in a comment at the bottom.
 * @member sourceMap Output a source map object with the code.
 * @member transpile Babel transpilation options - see `babel.TransformOptions`.
 */
export interface SourceMapOptions {
  ast?: boolean;
  bare?: boolean;
  filename?: string;
  header?: boolean;
  inlineMap?: boolean;
  sourceMap: true;
  transpile?: BabelTransformOptions;
}

/**
 * Source location array.
 *
 * @member {number} 1 Zero-indexed line number.
 * @member {number} 2 Zero-indexed column number.
 */
export type SourceLocation = [number, number];

/**
 * Mozilla V3 raw source map.
 *
 * @member file The generated filename this source map is associated with (optional).
 * @member mappings A string of base64 VLQs which contain the actual mappings.
 * @member names An array of identifiers which can be referenced by individual mappings.
 * @member sourceRoot The URL root from which all sources are relative (optional).
 * @member sources An array of URLs to the original source files.
 * @member sourcesContent An array of contents of the original source files (optional).
 * @member version Which version of the source map spec this map is following.
 */
export interface RawSourceMap {
  file: string;
  mappings: string;
  names: string[];
  sourceRoot?: string;
  sources: string[];
  sourcesContent?: string[];
  version: number;
}

/**
 * Tracker object for line and column positions for a single line.
 * Used to implement the `SourceMap` class.
 */
export interface LineMap {
  columns: {
    column: number;
    line: number;
    sourceColumn: number;
    sourceLine: number;
  };
  line: number;
  /**
   * Add source location data to line map.
   *
   * @param {number} column Zero-indexed column number.
   * @param {SourceLocation} source Source line and column to insert into map.
   * @param {object} [options={}] Column insertion options,
   * @param {boolean} [options.noReplace] If `true`, column replacement is allowed.
   * @returns {SourceLocation|undefined} Added source location data.
   */
  add: (column: number, source: SourceLocation, options?: { noReplace: boolean }) => SourceLocation | undefined;
  /**
   * Fetch source location data for a specific column.
   *
   * @param {number} column Zero-indexed column number.
   * @returns {SourceLocation|undefined} `[sourceLine, sourceColumn]` if it exists in line map.
   */
  sourceLocation: (column: number) => SourceLocation | void;
}

/**
 * Maps locations.
 */
export interface SourceMap {
  lines: LineMap[];
  /**
   * Adds a mapping to the source map.
   *
   * @param {SourceLocation} sourceLocation Zero-indexed source location.
   * @param {SourceLocation} generatedLocation Source line and column to insert into map.
   * @param {object} [options={}] Column insertion options.
   * @param {boolean} [options.noReplace] If `true`, column replacement is allowed.
   * @returns {SourceLocation} Added source location data.
   */
  add: (sourceLocation: SourceLocation, generatedLocation: SourceLocation, options?: { noReplace: boolean }) => ReturnType<LineMap["add"]>;
  /**
   * Fetch source location data for a specific column.
   *
   * @param {number} column Zero-indexed column number.
   * @returns {SourceLocation|undefined} `[sourceLine, sourceColumn]` if it exists in line map.
   */
  sourceLocation: (column: number) => SourceLocation | void;
  /**
   * Generates a V3 source map, returning the generated JSON as a string.
   *
   * @param {object} [options={}] Column insertion options
   * @param {string} [options.generatedFile] Property `generatedFile` in source map.
   * @param {string[]} [options.sourceFiles] Property `sources` in source map.
   * @param {string} [options.sourceRoot] Property `sourceRoot` in source map.
   * @returns {string} Added source location data.
   */
  generate: (column: number, source: SourceLocation, options?: { noReplace: boolean }) => string;
  /**
   * VLQ encoding in reverse byte order.
   *
   * @param {string} value Base-64 encoded value.
   * @returns {string} Reversed VLQ-encoded value.
   * @throws "Cannot Base64 encode value: ${value}"
   */
  encodeVlq: (value: string) => string;
  /**
   * Base-64 encoding for byte number.
   *
   * @param {string} value Byte number in ASCII.
   * @returns {string} Base-64 encoded value or undefined.
   * @throws "Cannot Base64 encode value: ${value}"
   */
  encodeBase64: (value: string) => string;
}

/**
 * Output of `CoffeeScript.compile` when `options.sourceMap` is `true`.
 * Emitted as an object in the form `{js, v3SourceMap, sourceMap}`.
 */
export interface CodeWithSourceMap {
  js: string;
  sourceMap: SourceMap;
  v3SourceMap: ReturnType<SourceMap["generate"]>;
}

/**
 * Acorn.js parser location data object.
 */
export interface AcornLocationData {
  end: number;
  loc: {
    end: {
      line: number;
      column: number;
    };
    start: {
      line: number;
      column: number;
    };
  };
  range: LineMap;
  start: number;
}

/**
 * Jison parser location data object.
 */
export interface JisonLocationData {
  first_column: number;
  first_line: number;
  last_line: number;
  last_column: number;
}

/**
 * CoffeeScript abstract syntax tree location data.
 */
export type ASTNodeLocationData = AcornLocationData | JisonLocationData;

/**
 * Range data interface for CoffeeScript abstract syntax tree nodes.
 */
export interface ASTNodeRange {
  from: ASTNode | null;
  to: ASTNode | null;
  exclusive: boolean;
  equals: string;
  locationData: ASTNodeLocationData;
}

/**
 * CoffeeScript's abstract syntax tree node interfaces with all possible node properties.
 */
export interface ASTNode {
  array?: boolean | ASTNode;
  asKey?: boolean;
  args?: ASTNode[];
  base?: ASTNode;
  body?: ASTBody | ASTNode;
  bound?: boolean;
  boundFuncs?: ASTNode[];
  cases?: ASTNode[][];
  classBody?: boolean;
  comments?: string[];
  condition?: ASTNode;
  context?: string;
  elseBody?: ASTNode | null;
  expression?: ASTNode;
  expressions?: ASTNode[];
  first?: ASTNode;
  flip?: boolean;
  generated?: boolean;
  guard?: ASTNode;
  index?: ASTNode;
  isChain?: boolean;
  isGenerator?: boolean;
  isNew?: boolean;
  isSuper?: boolean;
  locationData: ASTNodeLocationData;
  name?: ASTNode;
  negated?: boolean;
  object?: boolean | ASTNode;
  objects?: ASTNode[];
  operator?: string;
  otherwise?: ASTNode;
  own?: boolean;
  param?: boolean;
  params?: ASTNode[];
  parent?: ASTNode | null;
  pattern?: boolean;
  properties?: ASTNode[];
  range?: boolean | ASTNodeRange[];
  returns?: boolean;
  subject?: ASTNode;
  second?: ASTNode;
  soak?: boolean;
  source?: ASTNode;
  subpattern?: boolean;
  this?: boolean;
  val?: string;
  value?: ASTNode | string;
  variable?: ASTNode;
}

/**
 * Container interface for CoffeeScript abstract syntax trees.
 */
export interface ASTBody {
  classBody?: boolean;
  expressions: ASTNode[] | [];
  locationData: ASTNodeLocationData;
}

/**
 * Syntax error thrown by CoffeeScript compiler.
 *
 * @member code Source code that generated the `coffee` compiler error
 * @member filename File name for invalid CoffeeScript resource.
 * @member location Starting and ending location data.
 * @member stack String representation of syntax error.
 * @member toString Stack trace generator for error.
 */
export interface SyntaxError {
  code?: string;
  filename?: string;
  location: ASTNodeLocationData;
  stack: ReturnType<SyntaxError["toString"]>;
  toString: () => string;
}

/**
 * Options for `coffeescript.helpers.replaceUnicodeCodePointEscapes`.
 *
 * @member {string} [delimiter]
 *   Separator between two Unicode characters in `str` parameter of
 *   `coffeescript.helpers.replaceUnicodeCodePointEscapes`.
 * @member {string} [error=unicode code point escapes greater than \\u{10ffff} are not allowed]
 *   Error message if `coffeescript.helpers.replaceUnicodeCodePointEscapes` fails.
 * @member {string} [flags]
 *   Which flags are present in the regular expression for the replacement operation.
 *   Must include `u` if provided to support Unicode escapes.
 */
export interface ReplaceUnicodeCodePointEscapesOptions {
  error?: string;
  flags?: string;
  delimiter?: string;
}

/**
 * List of precompiled CoffeeScript file extensions.
 */
export let FILE_EXTENSIONS: [".coffee", ".coffee.md", ".litcoffee"];

/**
 * Version number of the CoffeeScript compiler.
 */
export let VERSION: string;

/**
 * Helpers used internally to compile CoffeeScript code.
 *
 * @deprecated Unstable and designed for internal use.
 */
export interface helpers {
  /**
   * Polyfill for `Array.prototype.some` used pre-transpilation in the compiler.
   * Determines whether the specified callback function returns true for any
   * element of an array.
   *
   * @this {Array} Array instance or prototype to polyfill.
   * @param {function} fn Predicate function test for each array element.
   * @returns {boolean} Whether one or more elements return `true` when passed to
   *   the predicate `fn(...)`.
   */
  some:
    | typeof Array.prototype.some
    | ((this: any[], predicate: (value: any) => unknown) => boolean);
  /**
   * Peek at the start of a given string to see if it matches a sequence.
   *
   * @param {string} string Target string to check the prefix literal against.
   * @param {string} literal Literal string to use for the prefix check.
   * @param {number} start Zero-indexed starting position of the prefix.
   *   The offset preceding the first character of the string is `0`.
   * @returns {boolean} Whether the `literal` prefix is found in `string`
   *   at the provided `start` position.
   */
  starts(string: string, literal: string, start: number): boolean;
  /**
   * Peek at the end of a given string to see if it matches a sequence.
   *
   * @param {string} string Target string to check the suffix literal against.
   * @param {string} literal Literal string to use for the suffix check.
   * @param {number} [back=0] Zero-indexed backtracking position of the prefix.
   *   The offset following the last character of the string is `0`.
   * @returns {boolean} Whether the `literal` suffix is found in `string`
   *   at the backtracking position or end of the string.
   */
  ends(string: string, literal: string, back?: number): boolean;
  /**
   * Repeat a string `n` times.
   * Uses a clever algorithm to have O(log(n)) string concatenation operations.
   *
   * @param {string} str String to repeat.
   * @param {number} n 1-indexed number of repetitions.
   * @returns {string} Repeated string.
   */
  repeat(str: string, n: number): string;
  /**
   * Trim out all falsy values from an array.
   *
   * @param {Array} array Array of boolean-operator indeterminate values.
   * @returns {Array} Array of truthy values.
   */
  compact(array: any[]): any[];
  /**
   * Count the number of occurrences of a search string in another string.
   *
   * @param {string} string Target string to search.
   * @param {string} substring Search string to compute against target.
   * @returns {number} Number of times the search string appears in the
   *   target string.
   */
  count(string: string, substr: any): number;
  /**
   * Merge objects, returning a fresh copy with attributes from both sides.
   * Used every time `CoffeeScript.compile` is called, to allow properties in the
   * options hash to propagate down the tree without polluting other branches.
   *
   * @param {object} options  Original, target object for merge operation.
   * @param {object} overrides Map of override key-values for merge operation.
   * @returns {object} Cloned object that merges `options` with `overrides`. The
   *   `overrides` properties have a higher merge priority than `options` properties.
   */
  merge(options: object, overrides: object): object;
  /**
   * Extend a source object with the properties of another object (shallow copy).
   *
   * @param {object} object Target object to extend.
   * @param {object} properties Source object to extend the source object.
   * @returns {object} The original `object` extended by the `properties` object.
   */
  extend(object: object, properties: object): object;
  /**
   * Flattens an array recursively.
   * Handy for getting a list of descendants from the nodes.
   *
   * @param {Array} array Array containing array and non-array elements.
   * @returns {Array} A flattened version of the array with an array depth of `0`.
   */
  flatten(array: any[]): any[];
  /**
   * Delete a key from an object, returning the value. Useful when a node is
   * looking for a particular method in an options hash.
   *
   * @param {object} obj Object to delete a key from.
   * @param {*} key Target key of object for the deletion operation.
   * @returns {*} The value of the deleted object entry.
   */
  del(obj: object, key: any): any;
  /**
   * Helper function for extracting code from Literate CoffeeScript by stripping
   * out all non-code blocks, producing a string of CoffeeScript code that can
   * be compiled "normally."
   *
   * @param {string} code Literate CoffeeScript code to extract code blocks from.
   * @returns {string} CoffeeScript code without surrounding Markdown documentation.
   */
  invertLiterate(code: string): string;
  /**
   * Build a list of all comments attached to tokens.
   *
   * @param {CoffeeScriptASTNode[]} tokens Collection of CoffeeScript abstract
   *   syntax tree tokens, all sorted by source order.
   * @returns {string[]} List of comment strings present in CoffeeScript AST.
   */
  extractAllCommentTokens(tokens: any[]): string[];
  /**
   * Build a dictionary of token comments organized by tokensâ€™ locations
   * used as lookup hashes.
   *
   * Though multiple tokens can have the same location hash, using exclusive
   * location data allows to distinguish between zero-length generated tokens and
   * actual source tokens, for example.
   *
   * The ranges for "overlapping" tokens with the same location data and
   * and matching token hashes are merged into one array.
   *
   * If there are duplicate comments, they will get sorted out later.
   *
   * @param {CoffeeScriptASTNode[]} tokens List of CoffeeScript abstract syntax
   *   tree tokens with or without comments.
   * @returns {object} Hashmap of token comments vs token location offsets.
   */
  buildTokenDataDictionary(tokens: any[]): object;
  /**
   * Generates a setter function that updates the location data of an object
   * if it is a CoffeeScript abstract syntax tree node.
   *
   * @param {object} parserState CoffeeScript parser state.
   * @param {CoffeeScriptASTLocationData} firstLocationData Location data for first node.
   * @param {CoffeeScriptASTNode} firstValue Abstract syntax tree for first node.
   * @param {CoffeeScriptASTLocationData} lastLocationData Location data for last node.
   * @param {CoffeeScriptASTNode} lastValue Abstract syntax tree for first node.
   * @param {boolean} [forceUpdateLocation=true] Whether to override the location data of the
   *   container and child nodes if the container has location data already.
   */
  addDataToNode(parserState: object, firstLocationData: any, firstValue: any, lastLocationData: any, lastValue: any, forceUpdateLocation?: boolean): (obj: any) => any;
  /**
   * Attaches a set of comments to the supplied node.
   *
   * @param {string[]} comments Collection of comment strings.
   * @param {CofffeScriptASTNode} node Node associated with `comments`.
   * @returns {CofffeScriptASTNode} The `node` merged with the `comments` array.
   */
  attachCommentsToNode(comments: string[], node: any): any;
  /**
   * Convert JISON location data to a string.
   *
   * @param obj Token or `CoffeeScriptASTLocationData` object.
   * @returns {string} String representation of location data.
   */
  locationDataToString(obj: any): string;
  /**
   * A `.coffee.md` compatible version of `path.basename`.
   *
   * @param {string} file File name path. Can be relative, absolute or missing a directory.
   * @param {boolean} [stripExt=false]
   * @param {*} [useWinPathSep=false] Whether to  use the Windows path separator `\`
   *   as well as the Unix path separator `/`.
   * @returns {string} File name without extension.
   */
  baseFileName(file: string, stripExt?: boolean, useWinPathSep?: any): string;
  /**
   * Determine if a filename represents a CoffeeScript file.
   * A CoffeeScript file has the file extensions `.coffee`, `.coffee.md` or
   * `.litcoffee`.
   *
   * @param {string} file Filename without directories.
   * @returns {boolean} Whether a filename is a CoffeeScript file.
   */
  isCoffee(file: string): boolean;
  /**
   * Determine if a filename represents a Literate CoffeeScript file.
   * A Literate CoffeeScript file has the file extensions `.litcoffee`,
   * or `.coffee.md`.
   *
   * @param {string} file Filename without directories.
   * @returns {boolean} Whether a filename is a CoffeeScript file.
   */
  isLiterate(file: string): boolean;
  /**
   * Throws a `CoffeeScriptSyntaxError` from a given location.
   * The error's `toString` will return an error message following the "standard"
   * format `<filename>:<line>:<col>: <message>` plus the line with the error and a
   * marker showing where the error is.
   *
   * Instead of showing the compiler's stacktrace, show our custom error message
   * (this is useful when the error bubbles up in Node.js applications that
   * compile CoffeeScript for example).
   *
   * @throws {CoffeeScriptSyntaxError} Error object with location data and string
   *   representation.
   */
  throwSyntaxError(message: any, location: any): never;
  /**
   * Update a compiler `SyntaxError` with source code information if it didn't have
   * it already.
   *
   * @param {CoffeeScriptSyntaxError} error Syntax error with or without source code
   *   information.
   * @param {string} code Source code that produced the syntax error.
   * @param {string} filename File name for invalid CoffeeScript resource.
   * @returns {CoffeeScriptSyntaxError} Syntax error with source code.
   */
  updateSyntaxError(error: any, code: string, filename: string): any;
  /**
   * Maps a whitespace character to a character name.
   *
   * @param {string} Single-character string.
   * @returns {string} Human-readable identifier for whitespace character, or the
   * `string` parameter.
   */
  nameWhitespaceCharacter(string: any): string;
  /**
   * Parses a CoffeeScript number string to a primitive JS number.
   *
   * @param {string} string String representation of a number.
   * @retuns {number} Parsed float or integer corresponding to number.
   */
  parseNumber(string: string): number;
  /**
   * Checks if a value is a function.
   *
   * @param {*} obj JavaScript value to check.
   * @returns {boolean} True if `obj` is a function.
   */
  isFunction(obj: any): boolean;
  /**
   * Checks if a value is a number.
   *
   * @param {*} obj JavaScript value to check.
   * @returns {boolean} True if `obj` is a number.
   */
  isNumber(obj: any): boolean;
  /**
   * Checks if an value is a string.
   *
   * @param {*} obj JavaScript value to check.
   * @returns {boolean} True if `obj` is a string.
   */
  isString(obj: any): boolean;
  /**
   * Checks if an value is a primitive boolean or `Boolean` instance.
   *
   * @param {*} obj JavaScript value to check.
   * @returns {boolean} True if `obj` is a boolean.
   */
  isBoolean(obj: any): boolean;
  /**
   * Checks if an value is a literal JS object - `{}`.
   *
   * @param {*} obj JavaScript value to check.
   * @returns {boolean} True if `obj` is a literal JS object.
   */
  isPlainObject(obj: any): boolean;
  /**
   * Replace `\u{...}` with `\uxxxx[\uxxxx]` in regexes without the `u` flag.
   *
   * @param {string} str String that may contain Unicode brace syntax - `\u{...}`.
   * @param {object} options Options for Unicode replacement.
   * @member {string} [options.delimiter]
   *   Separator between two Unicode characters in `str` parameter of
   *   `coffeescript.helpers.replaceUnicodeCodePointEscapes`.
   * @member {string} [options.error=unicode code point escapes greater than \\u{10ffff} are not allowed]
   *   Error message if `coffeescript.helpers.replaceUnicodeCodePointEscapes` fails.
   * @member {string} [options.flags]
   *   Which flags are present in the regular expression for the replacement operation.
   *   Must include `u` if provided to support Unicode escapes.
   * @returns RegExp string with Unicode brace groups in the format `\uxxxx[\uxxxx]`.
   */
  replaceUnicodeCodePointEscapes(str: string, options?: ReplaceUnicodeCodePointEscapesOptions): string;
}

/**
 * Transpiles CoffeeScript to legacy, high-compatibility ECMAScript versions using Babel.
 *
 * @param {string} code CoffeeScript code to be compiled.
 * @param {coffeescript.Options} [options] CoffeeScript compiler options.
 * @param {boolean} [options.ast=false] If true, output an abstract syntax tree of the input CoffeeScript source code.
 * @param {boolean} [options.bare=false] If true, omit a top-level IIFE safety wrapper.
 * @param {string} [options.filename=index.js] File name to compile.
 * @param {boolean} [options.header=false] If true, output the `Generated by CoffeeScript` header.
 * @param {boolean} [options.inlineMap=false] If true, output the source map as a base64-encoded string in a comment at the bottom.
 * @param {boolean} [options.sourceMap=false] If true, output a source map object with the code.
 * @param {babel.TransformOptions} [options.transpile={}] Babel transpilation options - see `babel.TransformOptions`.
 * @returns {babel.BabelFileResult} Babel transpiler result for file.
 */
export function transpile(code: string, options?: Options): BabelFileResult;

/**
 * Compiles CoffeeScript to JavaScript code, then outputs it as a string.
 *
 * @param {string} code CoffeeScript code to be compiled.
 * @param {coffeescript.Options} [options] CoffeeScript compiler options.
 * @param {boolean} [options.ast=false] If true, output an abstract syntax tree of the input CoffeeScript source code.
 * @param {boolean} [options.bare=false] If true, omit a top-level IIFE safety wrapper.
 * @param {string} [options.filename=index.js] File name to compile.
 * @param {boolean} [options.header=false] If true, output the `Generated by CoffeeScript` header.
 * @param {boolean} [options.inlineMap=false] If true, output the source map as a base64-encoded string in a comment at the bottom.
 * @param {boolean} [options.sourceMap=false] If true, output a source map object with the code.
 * @param {babel.TransformOptions} [options.transpile={}] Babel transpilation options - see `babel.TransformOptions`.
 * @returns {string|CodeWithSourceMap} Compiled and unevaluated JavaScript code if `options.sourceMap` is falsy and/or `undefined`.
 * If `options.sourceMap` is `true`, this returns a `{js, v3SourceMap, sourceMap}` object, where `sourceMap` is a
 * `SourceMap` object handy for doing programmatic lookups.
 */
export function compile(code: string, options: SourceMapOptions): CodeWithSourceMap;
export function compile(code: string, options?: Options): string;

/**
 * Parse a string of CoffeeScript code or an array of lexed tokens, and return the AST. You can then compile it by
 * calling `.compile()` on the root, or traverse it by using `.traverseChildren()` with a callback.
 *
 * @param {string} code CoffeeScript code to be compiled.
 * @param {coffeescript.Options} [options] CoffeeScript compiler options.
 * @param {boolean} [options.ast=false] If true, output an abstract syntax tree of the input CoffeeScript source code.
 * @param {boolean} [options.bare=false] If true, omit a top-level IIFE safety wrapper.
 * @param {string} [options.filename=index.js] File name to compile.
 * @param {boolean} [options.header=false] If true, output the `Generated by CoffeeScript` header.
 * @param {boolean} [options.inlineMap=false] If true, output the source map as a base64-encoded string in a comment
 *   at the bottom.
 * @param {boolean} [options.sourceMap=false] If true, output a source map object with the code.
 * @param {babel.TransformOptions} [options.transpile={}] Babel transpilation options - see `babel.TransformOptions`.
 * @returns {CoffeeScriptASTBody} Compiled and unevaluated JavaScript code.
 */
export function nodes(code: string, options?: Options): ASTBody;

/**
 * Compiles and executes a CoffeeScript string in the NodeJS environment.
 * Evaluates `__filename` and `__dirname` correctly in order to execute the CoffeeScript input.
 *
 * @param {string} code CoffeeScript code to be compiled.
 * @param {coffeescript.Options} [options] CoffeeScript compiler options.
 * @param {boolean} [options.ast=false] If true, output an abstract syntax tree of the input CoffeeScript source code.
 * @param {boolean} [options.bare=false] If true, omit a top-level IIFE safety wrapper.
 * @param {string} [options.filename=index.js] File name to compile.
 * @param {boolean} [options.header=false] If true, output the `Generated by CoffeeScript` header.
 * @param {boolean} [options.inlineMap=false] If true, output the source map as a base64-encoded string in a comment at the bottom.
 * @param {boolean} [options.sourceMap=false] If true, output a source map object with the code.
 * @param {babel.TransformOptions} [options.transpile={}] Babel transpilation options - see `babel.TransformOptions`.
 * @returns Output of evaluated CoffeeScript code in the NodeJS environment.
 */
export function run(code: string, options?: Options): any;

/**
 * Compiles and executes a CoffeeScript string in a NodeJS-like browser environment.
 * The CoffeeScript REPL uses this to run the input.
 *
 * @type {function}
 * @param {string} code CoffeeScript code to be compiled.
 * @param {coffeescript.Options} [options] CoffeeScript compiler options.
 * @param {boolean} [options.ast=false] If true, output an abstract syntax tree of the input CoffeeScript source code.
 * @param {boolean} [options.bare=false] If true, omit a top-level IIFE safety wrapper.
 * @param {string} [options.filename=index.js] File name to compile.
 * @param {boolean} [options.header=false] If true, output the `Generated by CoffeeScript` header.
 * @param {boolean} [options.inlineMap=false] If true, output the source map as a Base64-encoded string in a comment at the bottom.
 * @param {boolean} [options.sourceMap=false] If true, output a source map object with the code.
 * @param {babel.TransformOptions} [options.transpile={}] Babel transpilation options - see `babel.TransformOptions`.
 */
export interface eval {
  (code: string, options?: Options): any;
} // hack to avoid TS eval call protection

/**
 * Node's module loader, patched to be able to handle multi-dot extensions.
 * This is a horrible thing that should not be required.
 */
export function register(): {
  [path: string]: object;
  (path: string): object;
};

/**
 * Synchronous module definitions for the CoffeeScript library files.
 *
 * @param {string} path Path to CoffeeScript library submodule relative to the `./lib/coffeescript` directory.
 * @returns {(object|undefined)} CoffeeScript library submodule.
 */
export interface require {
  [path: string]: object;
  (path: string): require[keyof require];
}

/**
 * Compiles a raw CoffeeScript file buffer string.
 * Requires UTF-8 character encoding on the `raw` input string.
 * Strip the Unicode byte order mark, if `filename` begins with one.
 *
 * @param {string} raw Raw UTF-8 CoffeeScript file contents.
 * @param {string} filename File name with extension (not including
 *   directories).
 * @param {coffeescript.Options} [options] CoffeeScript compiler
 *   options.
 * @param {boolean} [options.ast=false] If true, output an abstract syntax
 *   tree of the input CoffeeScript source code.
 * @param {boolean} [options.bare=false] If true, omit a top-level IIFE safety
 *   wrapper.
 * @param {string} [options.filename=index.js] File name to compile.
 * @param {boolean} [options.header=false] If true, output the `Generated by CoffeeScript` header.
 * @param {boolean} [options.inlineMap=false] If true, output the source map as a Base64-encoded string in a comment at the bottom.
 * @param {boolean} [options.sourceMap=false] If true, output a source map object with the code.
 * @private
 */
export function _compileRawFileContent(raw: string, filename: string, options?: Options): string;

/**
 * Reads and compiles a CoffeeScript file using `fs.readFileSync`.
 * NodeJS wrapper around `coffeescript._compileRawFileContent`.
 * Files are decoded as if they are UTF-8 character encoded or compliant with UTF-8.
 *
 * @param {string} raw Raw UTF-8 CoffeeScript file contents.
 * @param {string} filename File name with extension (not including directories).
 * @param {coffeescript.Options} [options] CoffeeScript compiler options.
 * @param {boolean} [options.ast=false] If true, output an abstract syntax tree
 *   of the input CoffeeScript source code.
 * @param {boolean} [options.bare=false] If true, omit a top-level IIFE safety
 *   wrapper.
 * @param {string} [options.filename=index.js] File name to compile.
 * @param {boolean} [options.header=false] If true, output the `Generated by
 *   CoffeeScript` header.
 * @param {boolean} [options.inlineMap=false] If true, output the source map as
 *   a Base64-encoded string in a comment at the bottom.
 * @param {boolean} [options.sourceMap=false] If true, output a source map
 *   object with the code.
 * @private
 */
export function _compileFile(filename: string, options?: Options): string;
